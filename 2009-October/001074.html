<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [OpenFDM-svn] r1116 - in branches/OpenFDM-StateSeparation/src:	OpenFDM builder test
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/openfdm-svn/2009-October/index.html" >
   <LINK REL="made" HREF="mailto:openfdm-svn%40lists.berlios.de?Subject=Re%3A%20%5BOpenFDM-svn%5D%20r1116%20-%20in%20branches/OpenFDM-StateSeparation/src%3A%0A%09OpenFDM%20builder%20test&In-Reply-To=%3C200910131913.n9DJDGMj024733%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   
   <LINK REL="Next"  HREF="001075.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[OpenFDM-svn] r1116 - in branches/OpenFDM-StateSeparation/src:	OpenFDM builder test</H1>
    <B>frohlich at BerliOS</B> 
    <A HREF="mailto:openfdm-svn%40lists.berlios.de?Subject=Re%3A%20%5BOpenFDM-svn%5D%20r1116%20-%20in%20branches/OpenFDM-StateSeparation/src%3A%0A%09OpenFDM%20builder%20test&In-Reply-To=%3C200910131913.n9DJDGMj024733%40sheep.berlios.de%3E"
       TITLE="[OpenFDM-svn] r1116 - in branches/OpenFDM-StateSeparation/src:	OpenFDM builder test">frohlich at mail.berlios.de
       </A><BR>
    <I>Tue Oct 13 21:13:16 CEST 2009</I>
    <P><UL>
        
        <LI>Next message: <A HREF="001075.html">[OpenFDM-svn] r1117 - branches/OpenFDM-StateSeparation/src/OpenFDM
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1074">[ date ]</a>
              <a href="thread.html#1074">[ thread ]</a>
              <a href="subject.html#1074">[ subject ]</a>
              <a href="author.html#1074">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: frohlich
Date: 2009-10-13 21:13:13 +0200 (Tue, 13 Oct 2009)
New Revision: 1116

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Assert.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/AtmosphereSTD1976.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/DoPri5.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/ExternalInteract.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJoint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/ImplicitEuler.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Launchbar.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/LogStream.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/MidpointRule.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJoint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Model.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Newton.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/PrismaticActuator.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/PrismaticJoint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteActuator.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Tailhook.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/TransferFunction.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/UniversalJoint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/WheelContact.cpp
   branches/OpenFDM-StateSeparation/src/builder/QOsgWidget.cpp
   branches/OpenFDM-StateSeparation/src/test/inertianav.cpp
Log:
No longer using std::...

M    src/test/inertianav.cpp
M    src/builder/QOsgWidget.cpp
M    src/OpenFDM/MidpointRule.cpp
M    src/OpenFDM/MobileRootJoint.cpp
M    src/OpenFDM/Newton.cpp
M    src/OpenFDM/WheelContact.cpp
M    src/OpenFDM/CartesianJoint.h
M    src/OpenFDM/ImplicitEuler.cpp
M    src/OpenFDM/PrismaticActuator.cpp
M    src/OpenFDM/PrismaticJoint.cpp
M    src/OpenFDM/DoPri5.cpp
M    src/OpenFDM/Tailhook.cpp
M    src/OpenFDM/RevoluteActuator.cpp
M    src/OpenFDM/RevoluteJoint.cpp
M    src/OpenFDM/TransferFunction.cpp
M    src/OpenFDM/Launchbar.cpp
M    src/OpenFDM/FixedRootJoint.cpp
M    src/OpenFDM/System.cpp
M    src/OpenFDM/Model.cpp
M    src/OpenFDM/Assert.cpp
M    src/OpenFDM/AtmosphereSTD1976.cpp
M    src/OpenFDM/LogStream.h
M    src/OpenFDM/UniversalJoint.cpp
M    src/OpenFDM/ExternalInteract.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Assert.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Assert.cpp	2009-09-11 05:18:17 UTC (rev 1115)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Assert.cpp	2009-10-13 19:13:13 UTC (rev 1116)
@@ -1,4 +1,4 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2009 Mathias Froehlich 
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2009 Mathias Froehlich
  *
  */
 
@@ -19,6 +19,7 @@
 #endif
 
 #include &lt;cstdlib&gt;
+#include &lt;ostream&gt;
 
 namespace OpenFDM {
 
@@ -26,7 +27,7 @@
 {
   Log(Assert, Error) &lt;&lt; &quot;Assertion OpenFDMAssert(&quot; &lt;&lt; condition
                      &lt;&lt; &quot;) failed at line &quot;
-                     &lt;&lt; line &lt;&lt; &quot; in &quot; &lt;&lt; file &lt;&lt; endl;
+                     &lt;&lt; line &lt;&lt; &quot; in &quot; &lt;&lt; file &lt;&lt; std::endl;
 
 #if defined(HAVE_BACKTRACE_SYMBOLS) &amp;&amp; defined(HAVE_BACKTRACE)
 
@@ -36,10 +37,10 @@
   size_t size = backtrace(array, 1 + BACKTRACE_SIZE);
   char **strings = backtrace_symbols(array, size);
 
-  Log(Assert, Error) &lt;&lt; &quot; Backtrace:&quot; &lt;&lt; endl;
+  Log(Assert, Error) &lt;&lt; &quot; Backtrace:&quot; &lt;&lt; std::endl;
 
   for (size_t i = 1; i &lt; size; ++i) {
-    Log(Assert, Error) &lt;&lt; &quot;  &quot; &lt;&lt; strings[i] &lt;&lt; endl;
+    Log(Assert, Error) &lt;&lt; &quot;  &quot; &lt;&lt; strings[i] &lt;&lt; std::endl;
 #ifdef HAVE_CXXABI_H
     char *mangled = ::strchr(strings[i], '(');
     char *rest = 0;
@@ -47,8 +48,8 @@
       rest = ::strchr(mangled+1, '+');
       if (!rest)
         rest = ::strchr(mangled+1, ')');
-    }        
-     
+    }
+
     if (mangled &amp;&amp; rest &amp;&amp; rest-mangled &lt; 1024) {
       char manglebuf[1024];
       ::memcpy(manglebuf, mangled+1, rest-mangled-1);
@@ -58,7 +59,7 @@
       int status = 0;
       abi::__cxa_demangle(manglebuf, demangled, &amp;length, &amp;status);
       if (status == 0)
-        Log(Assert, Error) &lt;&lt; &quot;    (&quot; &lt;&lt; demangled &lt;&lt; &quot;)&quot; &lt;&lt; endl;
+        Log(Assert, Error) &lt;&lt; &quot;    (&quot; &lt;&lt; demangled &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
     }
 #endif
   }

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/AtmosphereSTD1976.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/AtmosphereSTD1976.cpp	2009-09-11 05:18:17 UTC (rev 1115)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/AtmosphereSTD1976.cpp	2009-10-13 19:13:13 UTC (rev 1116)
@@ -92,7 +92,7 @@
 
   Log(Environment, Debug) &lt;&lt; &quot;p = &quot; &lt;&lt; data.pressure &lt;&lt; &quot;, T = &quot;
                           &lt;&lt; data.temperature &lt;&lt; &quot;, rho = &quot;
-                          &lt;&lt; data.density &lt;&lt; endl;
+                          &lt;&lt; data.density &lt;&lt; std::endl;
   
   return data;
 }

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h	2009-09-11 05:18:17 UTC (rev 1115)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h	2009-10-13 19:13:13 UTC (rev 1116)
@@ -36,12 +36,12 @@
   {
     if (!parentLinkValue) {
       Log(Model, Error) &lt;&lt; &quot;Parent link is not set while creating context &quot;
-                        &lt;&lt; &quot;for model \&quot;&quot; &lt;&lt; getName() &lt;&lt; &quot;\&quot;&quot; &lt;&lt; endl;
+                        &lt;&lt; &quot;for model \&quot;&quot; &lt;&lt; getName() &lt;&lt; &quot;\&quot;&quot; &lt;&lt; std::endl;
       return 0;
     }
     if (!childLinkValue) {
       Log(Model, Error) &lt;&lt; &quot;Child link is not set while creating context &quot;
-                        &lt;&lt; &quot;for model \&quot;&quot; &lt;&lt; getName() &lt;&lt; &quot;\&quot;&quot; &lt;&lt; endl;
+                        &lt;&lt; &quot;for model \&quot;&quot; &lt;&lt; getName() &lt;&lt; &quot;\&quot;&quot; &lt;&lt; std::endl;
       return 0;
     }
     SharedPtr&lt;Context&gt; context;
@@ -49,7 +49,7 @@
                           parentLinkValue, childLinkValue, portValueList);
     if (!context-&gt;allocStates()) {
       Log(Model, Warning) &lt;&lt; &quot;Could not alloc for model \&quot;&quot;
-                          &lt;&lt; getName() &lt;&lt; &quot;\&quot;&quot; &lt;&lt; endl;
+                          &lt;&lt; getName() &lt;&lt; &quot;\&quot;&quot; &lt;&lt; std::endl;
       return 0;
     }
     return context.release();
@@ -200,7 +200,7 @@
       if (hIh.singular()) {
         Log(ArtBody,Error) &lt;&lt; &quot;Detected singular mass matrix for &quot;
                            &lt;&lt; &quot;CartesianJoint \&quot;&quot; &lt;&lt; mCartesianJoint-&gt;getName()
-                           &lt;&lt; &quot;\&quot;: Fix your model!&quot; &lt;&lt; endl;
+                           &lt;&lt; &quot;\&quot;: Fix your model!&quot; &lt;&lt; std::endl;
         return;
       }
 

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/DoPri5.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/DoPri5.cpp	2009-09-11 05:18:17 UTC (rev 1115)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/DoPri5.cpp	2009-10-13 19:13:13 UTC (rev 1116)
@@ -59,9 +59,9 @@
     real_type en = scaledErr(y7, err, atol, rtol);
 
     if (1 &lt; en)
-      Log(TimeStep, Warning) &lt;&lt; &quot;DOPRI5: error too big: &quot; &lt;&lt; en &lt;&lt; endl;
+      Log(TimeStep, Warning) &lt;&lt; &quot;DOPRI5: error too big: &quot; &lt;&lt; en &lt;&lt; std::endl;
     else
-      Log(TimeStep, Info) &lt;&lt; &quot;DOPRI5: local error: &quot; &lt;&lt; en &lt;&lt; endl;
+      Log(TimeStep, Info) &lt;&lt; &quot;DOPRI5: local error: &quot; &lt;&lt; en &lt;&lt; std::endl;
 
     // Need to save that here
     mRCont[0] = mState;
@@ -87,7 +87,7 @@
   if (t &lt; mTime - mStepsize || mTime &lt; t) {
     Log(TimeStep, Error) &lt;&lt; &quot;Request for dense output at t = &quot; &lt;&lt; t
                          &lt;&lt; &quot; out of range [&quot; &lt;&lt; mTime - mStepsize
-                         &lt;&lt; &quot;,&quot; &lt;&lt; mTime &lt;&lt; &quot;]&quot; &lt;&lt; endl;
+                         &lt;&lt; &quot;,&quot; &lt;&lt; mTime &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;
 //     return false;
   }
 

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/ExternalInteract.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ExternalInteract.cpp	2009-09-11 05:18:17 UTC (rev 1115)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ExternalInteract.cpp	2009-10-13 19:13:13 UTC (rev 1116)
@@ -285,7 +285,7 @@
   SharedPtr&lt;Context&gt; context = new Context(this, environment, portValueList);
   if (!context-&gt;alloc()) {
     Log(Model, Warning) &lt;&lt; &quot;Could not alloc for model \&quot;&quot;
-                        &lt;&lt; getName() &lt;&lt; &quot;\&quot;&quot; &lt;&lt; endl;
+                        &lt;&lt; getName() &lt;&lt; &quot;\&quot;&quot; &lt;&lt; std::endl;
     return 0;
   }
   return context.release();

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJoint.cpp	2009-09-11 05:18:17 UTC (rev 1115)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJoint.cpp	2009-10-13 19:13:13 UTC (rev 1116)
@@ -88,7 +88,7 @@
                                            childLinkValue, portValueList);
   if (!context-&gt;allocStates()) {
     Log(Model, Warning) &lt;&lt; &quot;Could not alloc for model \&quot;&quot;
-                        &lt;&lt; getName() &lt;&lt; &quot;\&quot;&quot; &lt;&lt; endl;
+                        &lt;&lt; getName() &lt;&lt; &quot;\&quot;&quot; &lt;&lt; std::endl;
     return false;
   }
   return context.release();

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/ImplicitEuler.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ImplicitEuler.cpp	2009-09-11 05:18:17 UTC (rev 1115)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ImplicitEuler.cpp	2009-10-13 19:13:13 UTC (rev 1116)
@@ -41,7 +41,7 @@
 ImplicitEuler::ImplicitEuler(void)
 {
   Log(TimeStep, Warning) &lt;&lt; &quot;Using mostly hacked implicit Euler method!!!&quot;
-                         &lt;&lt; endl;
+                         &lt;&lt; std::endl;
   mJacStepsize = 0;
 }
 
@@ -77,10 +77,10 @@
     }
 
     if (mJacDecomp.singular())
-      Log(TimeStep, Warning) &lt;&lt; &quot;Have singular jacobian!&quot; &lt;&lt; endl;
+      Log(TimeStep, Warning) &lt;&lt; &quot;Have singular jacobian!&quot; &lt;&lt; std::endl;
     bool conv = Newton(iefun, mJacDecomp, mTime+h, fState, 1e-4, 1e-10);
     if (!conv)
-      Log(TimeStep, Warning) &lt;&lt; &quot;Have singular jacobian!&quot; &lt;&lt; endl;
+      Log(TimeStep, Warning) &lt;&lt; &quot;Have singular jacobian!&quot; &lt;&lt; std::endl;
 
     mState += fState;
     mTime += h;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Launchbar.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Launchbar.cpp	2009-09-11 05:18:17 UTC (rev 1115)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Launchbar.cpp	2009-10-13 19:13:13 UTC (rev 1116)
@@ -62,7 +62,7 @@
   if (!mTryMountPort.isConnected()) {
     Log(Model, Error) &lt;&lt; &quot;Initialization of Launchbar model \&quot;&quot; &lt;&lt; getName()
                       &lt;&lt; &quot;\&quot; failed: Input port \&quot;&quot; &lt;&lt; getInputPortName(0)
-                      &lt;&lt; &quot;\&quot; is not connected!&quot; &lt;&lt; endl;
+                      &lt;&lt; &quot;\&quot; is not connected!&quot; &lt;&lt; std::endl;
     return false;
   }
 
@@ -70,7 +70,7 @@
   if (!mLaunchCommandPort.isConnected()) {
     Log(Model, Error) &lt;&lt; &quot;Initialization of Launchbar model \&quot;&quot; &lt;&lt; getName()
                       &lt;&lt; &quot;\&quot; failed: Input port \&quot;&quot; &lt;&lt; getInputPortName(1)
-                      &lt;&lt; &quot;\&quot; is not connected!&quot; &lt;&lt; endl;
+                      &lt;&lt; &quot;\&quot; is not connected!&quot; &lt;&lt; std::endl;
     return false;
   }
 
@@ -83,7 +83,7 @@
   if (nonZeroIntersection(taskInfo.getSampleTimeSet(),
                           SampleTime::PerTimestep)) {
     Log(Model, Debug) &lt;&lt; &quot;Launchbar::output(): \&quot;&quot; &lt;&lt; getName()
-                      &lt;&lt; &quot;\&quot; computing ground plane below&quot; &lt;&lt; endl;
+                      &lt;&lt; &quot;\&quot; computing ground plane below&quot; &lt;&lt; std::endl;
     getGround(taskInfo.getTime());
   }
 

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/LogStream.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/LogStream.h	2009-09-11 05:18:17 UTC (rev 1115)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/LogStream.h	2009-10-13 19:13:13 UTC (rev 1116)
@@ -1,4 +1,4 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2009 Mathias Froehlich 
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2009 Mathias Froehlich
  *
  */
 
@@ -6,8 +6,6 @@
 #define OpenFDM_LogStream_H
 
 #include &lt;iosfwd&gt;
-// FIXME: because of using std::endl;
-#include &lt;ostream&gt;
 #include &quot;Referenced.h&quot;
 
 namespace OpenFDM {
@@ -28,7 +26,7 @@
     Schedule         = Model &lt;&lt; 1,
     Assert           = ~0
   };
-  
+
   enum Priority {
     /// Non recoverable error, either due to an implementation problem or
     /// due to a user problem probably ignoring previous error return values.
@@ -50,7 +48,7 @@
     Debug2           = Debug1 + 1,
     Debug3           = Debug2 + 1
   };
-  
+
   static void setCategoryEnable(Category category, bool enable = true);
   static void setCategoryDisable(Category category);
   static void setPriority(Priority priority);
@@ -66,7 +64,7 @@
 #endif
     return Instance()-&gt;getEnabled(category, priority);
   }
-  
+
   static std::ostream&amp; getStream(Priority priority);
 
 protected:
@@ -85,8 +83,6 @@
 if (Logger::getStaticEnabled(Logger::category, Logger::priority)) \
   Logger::getStream(Logger::priority)
 
-using std::endl;
-
 } // namespace OpenFDM
 
 #endif

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MidpointRule.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MidpointRule.cpp	2009-09-11 05:18:17 UTC (rev 1115)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MidpointRule.cpp	2009-10-13 19:13:13 UTC (rev 1116)
@@ -96,7 +96,7 @@
       // If we cannot solve the nonlinear equation, do an explicit euler step
       mCollocationPolynomialValid = false;
 
-      Log(TimeStep, Warning) &lt;&lt; &quot;MidpointRule did not converge&quot; &lt;&lt; endl;
+      Log(TimeStep, Warning) &lt;&lt; &quot;MidpointRule did not converge&quot; &lt;&lt; std::endl;
 
       evalFunction(t, mState, mDeriv);
       mState += h*mDeriv;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJoint.cpp	2009-09-11 05:18:17 UTC (rev 1115)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJoint.cpp	2009-10-13 19:13:13 UTC (rev 1116)
@@ -101,7 +101,7 @@
                                            childLinkValue, portValueList);
   if (!context-&gt;allocStates()) {
     Log(Model, Warning) &lt;&lt; &quot;Could not alloc for model \&quot;&quot;
-                        &lt;&lt; getName() &lt;&lt; &quot;\&quot;&quot; &lt;&lt; endl;
+                        &lt;&lt; getName() &lt;&lt; &quot;\&quot;&quot; &lt;&lt; std::endl;
     return false;
   }
   return context.release();

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Model.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Model.cpp	2009-09-11 05:18:17 UTC (rev 1115)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Model.cpp	2009-10-13 19:13:13 UTC (rev 1116)
@@ -79,14 +79,14 @@
     if (!portValue) {
       Log(Model, Error) &lt;&lt; &quot;No port value given for model \&quot;&quot; &lt;&lt; getName()
                         &lt;&lt; &quot;\&quot; and port \&quot;&quot; &lt;&lt; getPort(i)-&gt;getName()
-                        &lt;&lt; &quot;\&quot;&quot; &lt;&lt; endl;
+                        &lt;&lt; &quot;\&quot;&quot; &lt;&lt; std::endl;
       return false;
     }
     context-&gt;setPortValue(*getPort(i), portValue);
   }
   if (!context-&gt;alloc()) {
     Log(Model, Warning) &lt;&lt; &quot;Could not alloc for model \&quot;&quot;
-                        &lt;&lt; getName() &lt;&lt; &quot;\&quot;&quot; &lt;&lt; endl;
+                        &lt;&lt; getName() &lt;&lt; &quot;\&quot;&quot; &lt;&lt; std::endl;
     return false;
   }
   return context.release();

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Newton.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Newton.cpp	2009-09-11 05:18:17 UTC (rev 1115)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Newton.cpp	2009-10-13 19:13:13 UTC (rev 1116)
@@ -65,14 +65,14 @@
   // x_new is the potential solution at the next iteration step.
   Vector x_new;
 
-  Log(NewtonMethod, Debug) &lt;&lt; &quot;__________________________&quot; &lt;&lt; endl;
+  Log(NewtonMethod, Debug) &lt;&lt; &quot;__________________________&quot; &lt;&lt; std::endl;
   // The displacement of the undamped newton method for the first
   // iteration step.
   Vector err;
   f.eval(t, x, err);
-  Log(NewtonMethod, Debug1) &lt;&lt; &quot;err &quot; &lt;&lt; trans(err) &lt;&lt; endl;
+  Log(NewtonMethod, Debug1) &lt;&lt; &quot;err &quot; &lt;&lt; trans(err) &lt;&lt; std::endl;
   Vector dx_bar = jacInv.solve(err);
-  Log(NewtonMethod, Debug2) &lt;&lt; &quot;dx_bar &quot; &lt;&lt; trans(dx_bar) &lt;&lt; endl;
+  Log(NewtonMethod, Debug2) &lt;&lt; &quot;dx_bar &quot; &lt;&lt; trans(dx_bar) &lt;&lt; std::endl;
   do {
     // Increment the iteration counter. Just statistics ...
     if (itCount)
@@ -88,7 +88,7 @@
     if (normdx == 0.0)
       return true;
 
-    Log(NewtonMethod, Debug1) &lt;&lt; &quot;outer &quot; &lt;&lt; normdx &lt;&lt; endl;
+    Log(NewtonMethod, Debug1) &lt;&lt; &quot;outer &quot; &lt;&lt; normdx &lt;&lt; std::endl;
 
     // Damped newton method:
     // Use lambda*dx with 0 &lt; lambda &lt;= 1 instead of just dx as displacement.
@@ -106,13 +106,13 @@
       // Compute the error of that new approximation.
       f.eval(t, x_new, err);
 
-      Log(NewtonMethod, Debug) &lt;&lt; &quot;err &quot; &lt;&lt; trans(err) &lt;&lt; endl;
+      Log(NewtonMethod, Debug) &lt;&lt; &quot;err &quot; &lt;&lt; trans(err) &lt;&lt; std::endl;
 
       // Check if we get some kind of convergence with this lambda.
       // This jacobian evaluation will also be used for the next step if
       // this lambda truns out to be acceptable.
       dx_bar = jacInv.solve(err);
-      Log(NewtonMethod, Debug2) &lt;&lt; &quot;dx_bar &quot; &lt;&lt; trans(dx_bar) &lt;&lt; endl;
+      Log(NewtonMethod, Debug2) &lt;&lt; &quot;dx_bar &quot; &lt;&lt; trans(dx_bar) &lt;&lt; std::endl;
 
       // The convergence criterion parameter theta.
       real_type theta = 1.0 - 0.5*lambda;
@@ -121,12 +121,12 @@
       // to the current solution.
       real_type normdx_bar = norm(dx_bar);
 
-      Log(NewtonMethod, Debug) &lt;&lt; &quot;inner &quot; &lt;&lt; normdx_bar &lt;&lt; endl;
+      Log(NewtonMethod, Debug) &lt;&lt; &quot;inner &quot; &lt;&lt; normdx_bar &lt;&lt; std::endl;
 
       const real_type min_conv_rate = 1e-10;
       if (normdx == 0.0) {
         Log(NewtonMethod, Error) &lt;&lt; &quot;Whow: we have most likely an exact &quot;
-          &quot;solution and we iterate furter:  normdx = &quot; &lt;&lt; normdx &lt;&lt; endl;
+          &quot;solution and we iterate furter:  normdx = &quot; &lt;&lt; normdx &lt;&lt; std::endl;
         convergenceRate = min_conv_rate;
       } else
         convergenceRate = max(min_conv_rate, normdx_bar/normdx);
@@ -155,16 +155,16 @@
     } else if (0 &lt;= maxjac) {
       --maxjac;
 
-      Log(NewtonMethod, Debug) &lt;&lt; &quot;Computing new jacobian&quot; &lt;&lt; endl;
+      Log(NewtonMethod, Debug) &lt;&lt; &quot;Computing new jacobian&quot; &lt;&lt; std::endl;
 
       // get a new jacobian ...
       f.jac(t, x, jacInv.data());
-      Log(NewtonMethod, Debug2) &lt;&lt; jacInv.data() &lt;&lt; endl;
+      Log(NewtonMethod, Debug2) &lt;&lt; jacInv.data() &lt;&lt; std::endl;
       jacInv.factorize();
-      Log(NewtonMethod, Debug2) &lt;&lt; &quot;decomposed qr\n&quot; &lt;&lt; jacInv.data() &lt;&lt; endl;
+      Log(NewtonMethod, Debug2) &lt;&lt; &quot;decomposed qr\n&quot; &lt;&lt; jacInv.data() &lt;&lt; std::endl;
 
       if (jacInv.singular())
-        Log(NewtonMethod, Warning) &lt;&lt; &quot;Have singular jacobian!&quot; &lt;&lt; endl;
+        Log(NewtonMethod, Warning) &lt;&lt; &quot;Have singular jacobian!&quot; &lt;&lt; std::endl;
 
       converging = true;
     }
@@ -174,7 +174,7 @@
   } while (!converged &amp;&amp; converging &amp;&amp; 0 &lt; maxit);
 
   Log(NewtonMethod, Info) &lt;&lt; &quot;Newton type method: converged = &quot;
-                          &lt;&lt; converged &lt;&lt; endl;
+                          &lt;&lt; converged &lt;&lt; std::endl;
   
   // Tell the caller if it worked or not.
   return converged;
@@ -216,7 +216,7 @@
 
   while (norm1(v - w) &gt; thresh) {
     Log(NewtonMethod, Debug2) &lt;&lt; &quot; Line Search: errv = &quot; &lt;&lt; fv
-                              &lt;&lt; &quot;, errw = &quot; &lt;&lt; fw &lt;&lt; endl;
+                              &lt;&lt; &quot;, errw = &quot; &lt;&lt; fw &lt;&lt; std::endl;
     // check for isfinite ...
     if (fv &gt; fw) {
       v = v + vfac*(w-v);
@@ -255,7 +255,7 @@
   do {
     // Compute in each step a new jacobian
     f.jac(t, x, J);
-    Log(NewtonMethod, Debug) &lt;&lt; &quot;Jacobian is:\n&quot; &lt;&lt; J &lt;&lt; endl;
+    Log(NewtonMethod, Debug) &lt;&lt; &quot;Jacobian is:\n&quot; &lt;&lt; J &lt;&lt; std::endl;
 #ifdef USE_QR
     jacFactors = J;
 #else
@@ -263,7 +263,7 @@
 #endif
     Log(NewtonMethod, Debug) &lt;&lt; &quot;Jacobian is &quot;
                              &lt;&lt; (jacFactors.singular() ? &quot;singular&quot; : &quot;ok&quot;)
-                             &lt;&lt; endl;
+                             &lt;&lt; std::endl;
    
     // Compute the actual error
     f.eval(t, x, err);
@@ -275,9 +275,9 @@
     dx = jacFactors.solve(trans(J)*err);
 #endif
     Log(NewtonMethod, Debug) &lt;&lt; &quot;dx residual &quot;
-                             &lt;&lt; trans(J*dx - err) &lt;&lt; endl
+                             &lt;&lt; trans(J*dx - err) &lt;&lt; std::endl
                              &lt;&lt; trans(J*dx - err)*J
-                             &lt;&lt; endl;
+                             &lt;&lt; std::endl;
 
     // Get a better search guess
     if (1 &lt; norm(dx))
@@ -289,7 +289,7 @@
     
 
     Log(NewtonMethod, Debug) &lt;&lt; &quot;Convergence test: |dx| = &quot; &lt;&lt; norm(xnew - x)
-                             &lt;&lt; &quot;, converged = &quot; &lt;&lt; converged &lt;&lt; endl;
+                             &lt;&lt; &quot;, converged = &quot; &lt;&lt; converged &lt;&lt; std::endl;
     // New guess is the better one
     x = xnew;
   } while (!converged);
@@ -305,7 +305,7 @@
                   unsigned *itCount,
                   unsigned maxit)
 {
-  Log(NewtonMethod, Debug3) &lt;&lt; &quot;Start guess\nx = &quot; &lt;&lt; trans(x) &lt;&lt; endl;
+  Log(NewtonMethod, Debug3) &lt;&lt; &quot;Start guess\nx = &quot; &lt;&lt; trans(x) &lt;&lt; std::endl;
 
   Matrix J;
   LinAlg::MatrixFactors&lt;real_type,0,0,LinAlg::LUTag&gt; jacFactors;
@@ -316,7 +316,7 @@
 
   // Compute in each step a new jacobian
   f.jac(t, x, J);
-  Log(NewtonMethod, Debug3) &lt;&lt; &quot;Jacobian is:\n&quot; &lt;&lt; J &lt;&lt; endl;
+  Log(NewtonMethod, Debug3) &lt;&lt; &quot;Jacobian is:\n&quot; &lt;&lt; J &lt;&lt; std::endl;
   real_type mu = tau*norm1(J);
 
   Vector fx;
@@ -328,12 +328,12 @@
     jacFactors = trans(J)*J + mu*LinAlg::Eye&lt;real_type,0,0&gt;(rows(x), rows(x));
     Log(NewtonMethod, Debug) &lt;&lt; &quot;Jacobian is &quot;
                              &lt;&lt; (jacFactors.singular() ? &quot;singular&quot; : &quot;ok&quot;)
-                             &lt;&lt; endl;
+                             &lt;&lt; std::endl;
    
     // Compute the search direction
     Vector h = jacFactors.solve(-g);
     Log(NewtonMethod, Debug) &lt;&lt; &quot;Solve Residual &quot;
-                             &lt;&lt; norm(trans(J)*J*h + mu*h + g)/norm(g) &lt;&lt; endl;
+                             &lt;&lt; norm(trans(J)*J*h + mu*h + g)/norm(g) &lt;&lt; std::endl;
 
     // Get a better search guess
     Vector xnew = x + h;
@@ -341,7 +341,7 @@
     // check convergence
     converged = equal(x, xnew, atol, rtol);
     Log(NewtonMethod, Debug) &lt;&lt; &quot;Convergence test: ||h||_1 = &quot; &lt;&lt; norm1(h)
-                             &lt;&lt; &quot;, converged = &quot; &lt;&lt; converged &lt;&lt; endl;
+                             &lt;&lt; &quot;, converged = &quot; &lt;&lt; converged &lt;&lt; std::endl;
     if (converged)
       break;
 
@@ -353,22 +353,22 @@
     Log(NewtonMethod, Debug) &lt;&lt; &quot;Rho = &quot; &lt;&lt; rho
                              &lt;&lt; &quot;, Fxnew = &quot; &lt;&lt; Fxnew 
                              &lt;&lt; &quot;, Fx = &quot; &lt;&lt; Fx
-                             &lt;&lt; endl;
+                             &lt;&lt; std::endl;
     if (0 &lt; rho) {
-      Log(NewtonMethod, Debug) &lt;&lt; &quot;Accepted step!&quot; &lt;&lt; endl;
-      Log(NewtonMethod, Debug3) &lt;&lt; &quot;xnew = &quot; &lt;&lt; trans(xnew) &lt;&lt; endl;
-      Log(NewtonMethod, Debug3) &lt;&lt; &quot;h    = &quot; &lt;&lt; trans(h) &lt;&lt; endl;
+      Log(NewtonMethod, Debug) &lt;&lt; &quot;Accepted step!&quot; &lt;&lt; std::endl;
+      Log(NewtonMethod, Debug3) &lt;&lt; &quot;xnew = &quot; &lt;&lt; trans(xnew) &lt;&lt; std::endl;
+      Log(NewtonMethod, Debug3) &lt;&lt; &quot;h    = &quot; &lt;&lt; trans(h) &lt;&lt; std::endl;
 
       // New guess is the better one
       x = xnew;
 
       f.jac(t, x, J);
-      Log(NewtonMethod, Debug3) &lt;&lt; &quot;Jacobian is:\n&quot; &lt;&lt; J &lt;&lt; endl;
+      Log(NewtonMethod, Debug3) &lt;&lt; &quot;Jacobian is:\n&quot; &lt;&lt; J &lt;&lt; std::endl;
       // Compute the actual error
       f.eval(t, x, fx);
       g = trans(J)*fx;
       converged = norm1(g) &lt; atol;
-      Log(NewtonMethod, Debug) &lt;&lt; &quot;||g||_1 = &quot; &lt;&lt; norm1(g) &lt;&lt; endl;
+      Log(NewtonMethod, Debug) &lt;&lt; &quot;||g||_1 = &quot; &lt;&lt; norm1(g) &lt;&lt; std::endl;
 
       mu = mu * max(real_type(1)/3, 1-pow(2*rho-1, real_type(3)));
       nu = 2;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/PrismaticActuator.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/PrismaticActuator.cpp	2009-09-11 05:18:17 UTC (rev 1115)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/PrismaticActuator.cpp	2009-10-13 19:13:13 UTC (rev 1116)
@@ -66,7 +66,7 @@
 {
   real_type nrm = norm(axis);
   if (nrm &lt;= Limits&lt;real_type&gt;::min()) {
-    Log(Initialization, Error) &lt;&lt; &quot;JointAxis is zero ...&quot; &lt;&lt; endl;
+    Log(Initialization, Error) &lt;&lt; &quot;JointAxis is zero ...&quot; &lt;&lt; std::endl;
     return;
   }
   mAxis = (1/nrm)*axis;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/PrismaticJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/PrismaticJoint.cpp	2009-09-11 05:18:17 UTC (rev 1115)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/PrismaticJoint.cpp	2009-10-13 19:13:13 UTC (rev 1116)
@@ -57,7 +57,7 @@
 {
   real_type nrm = norm(axis);
   if (nrm &lt;= Limits&lt;real_type&gt;::min()) {
-    Log(Initialization, Error) &lt;&lt; &quot;JointAxis is zero ...&quot; &lt;&lt; endl;
+    Log(Initialization, Error) &lt;&lt; &quot;JointAxis is zero ...&quot; &lt;&lt; std::endl;
     return;
   }
   mAxis = (1/nrm)*axis;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteActuator.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteActuator.cpp	2009-09-11 05:18:17 UTC (rev 1115)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteActuator.cpp	2009-10-13 19:13:13 UTC (rev 1116)
@@ -66,7 +66,7 @@
 {
   real_type nrm = norm(axis);
   if (nrm &lt;= Limits&lt;real_type&gt;::min()) {
-    Log(Initialization, Error) &lt;&lt; &quot;JointAxis is zero ...&quot; &lt;&lt; endl;
+    Log(Initialization, Error) &lt;&lt; &quot;JointAxis is zero ...&quot; &lt;&lt; std::endl;
     return;
   }
   mAxis = (1/nrm)*axis;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.cpp	2009-09-11 05:18:17 UTC (rev 1115)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.cpp	2009-10-13 19:13:13 UTC (rev 1116)
@@ -54,7 +54,7 @@
 {
   real_type nrm = norm(axis);
   if (nrm &lt;= Limits&lt;real_type&gt;::min()) {
-    Log(Initialization, Error) &lt;&lt; &quot;JointAxis is zero ...&quot; &lt;&lt; endl;
+    Log(Initialization, Error) &lt;&lt; &quot;JointAxis is zero ...&quot; &lt;&lt; std::endl;
     return;
   }
   mAxis = (1/nrm)*axis;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2009-09-11 05:18:17 UTC (rev 1115)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2009-10-13 19:13:13 UTC (rev 1116)
@@ -448,12 +448,12 @@
         Log(Schedule, Debug3) &lt;&lt; &quot;Try to create port value \&quot;&quot;
                               &lt;&lt; mPortDataVector[i]-&gt;getPort()-&gt;getName()
                               &lt;&lt; &quot;\&quot; of \&quot;&quot; &lt;&lt; getNodeNamePath()
-                              &lt;&lt; &quot;\&quot;&quot; &lt;&lt; endl;
+                              &lt;&lt; &quot;\&quot;&quot; &lt;&lt; std::endl;
         if (!mPortDataVector[i]-&gt;createPortValue()) {
           Log(Schedule, Warning) &lt;&lt; &quot;Failed to create port value \&quot;&quot;
                                  &lt;&lt; mPortDataVector[i]-&gt;getPort()-&gt;getName()
                                  &lt;&lt; &quot;\&quot; of \&quot;&quot; &lt;&lt; getNodeNamePath()
-                                 &lt;&lt; &quot;\&quot;.\nAborting!&quot; &lt;&lt; endl;
+                                 &lt;&lt; &quot;\&quot;.\nAborting!&quot; &lt;&lt; std::endl;
 
           return false;
         }
@@ -467,20 +467,20 @@
         Log(Schedule, Debug3) &lt;&lt; &quot;Try to fetch port value \&quot;&quot;
                               &lt;&lt; mPortDataVector[i]-&gt;getPort()-&gt;getName()
                               &lt;&lt; &quot;\&quot; of \&quot;&quot; &lt;&lt; getNodeNamePath()
-                              &lt;&lt; &quot;\&quot;&quot; &lt;&lt; endl;
+                              &lt;&lt; &quot;\&quot;&quot; &lt;&lt; std::endl;
         PortValue* portValue = mPortDataVector[i]-&gt;getPortValue();
         if (!portValue) {
           Log(Schedule, Warning) &lt;&lt; &quot;Failed to fetch port value \&quot;&quot;
                                  &lt;&lt; mPortDataVector[i]-&gt;getPort()-&gt;getName()
                                  &lt;&lt; &quot;\&quot; of \&quot;&quot; &lt;&lt; getNodeNamePath()
-                                 &lt;&lt; &quot;\&quot;.\nAborting!&quot; &lt;&lt; endl;
+                                 &lt;&lt; &quot;\&quot;.\nAborting!&quot; &lt;&lt; std::endl;
           return false;
         }
         if (!mPortDataVector[i]-&gt;getPort()-&gt;acceptPortValue(portValue)) {
           Log(Schedule, Warning) &lt;&lt; &quot;Failed to accept fetched port value \&quot;&quot;
                                  &lt;&lt; mPortDataVector[i]-&gt;getPort()-&gt;getName()
                                  &lt;&lt; &quot;\&quot; of \&quot;&quot; &lt;&lt; getNodeNamePath()
-                                 &lt;&lt; &quot;\&quot;.\nAborting!&quot; &lt;&lt; endl;
+                                 &lt;&lt; &quot;\&quot;.\nAborting!&quot; &lt;&lt; std::endl;
           return false;
         }
 
@@ -528,7 +528,7 @@
       mModelContext = mModel-&gt;newModelContext(mPortValueList);
       if (!mModelContext) {
         Log(Schedule, Warning) &lt;&lt; &quot;Could not create context for model \&quot;&quot;
-                               &lt;&lt; getNodeNamePath() &lt;&lt; &quot;\&quot;&quot; &lt;&lt; endl;
+                               &lt;&lt; getNodeNamePath() &lt;&lt; &quot;\&quot;&quot; &lt;&lt; std::endl;
         return false;
       }
       return true;
@@ -604,7 +604,7 @@
       if (!mMechanicContext) {
         Log(Schedule, Warning) &lt;&lt; &quot;Could not create context for mechanic &quot;
                                &lt;&lt; &quot;node \&quot;&quot; &lt;&lt; getNodeNamePath()
-                               &lt;&lt; &quot;\&quot;&quot; &lt;&lt; endl;
+                               &lt;&lt; &quot;\&quot;&quot; &lt;&lt; std::endl;
         return false;
       }
       return true;
@@ -700,7 +700,7 @@
       if (!mMechanicContext) {
         Log(Schedule, Warning) &lt;&lt; &quot;Could not create context for mechanic &quot;
                                &lt;&lt; &quot;node \&quot;&quot; &lt;&lt; getNodeNamePath()
-                               &lt;&lt; &quot;\&quot;&quot; &lt;&lt; endl;
+                               &lt;&lt; &quot;\&quot;&quot; &lt;&lt; std::endl;
         return false;
       }
       return true;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Tailhook.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Tailhook.cpp	2009-09-11 05:18:17 UTC (rev 1115)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Tailhook.cpp	2009-10-13 19:13:13 UTC (rev 1116)
@@ -56,7 +56,7 @@
   if (!mHookPositionPort.isConnected()) {
     Log(Model, Error) &lt;&lt; &quot;Initialization of Tailhook model \&quot;&quot; &lt;&lt; getName()
                       &lt;&lt; &quot;\&quot; failed: Input port \&quot;&quot; &lt;&lt; getInputPortName(0)
-                      &lt;&lt; &quot;\&quot; is not connected!&quot; &lt;&lt; endl;
+                      &lt;&lt; &quot;\&quot; is not connected!&quot; &lt;&lt; std::endl;
     return false;
   }
 
@@ -69,7 +69,7 @@
   if (nonZeroIntersection(taskInfo.getSampleTimeSet(),
                           SampleTime::PerTimestep)) {
     Log(Model, Debug) &lt;&lt; &quot;Tailhook::output(): \&quot;&quot; &lt;&lt; getName()
-                      &lt;&lt; &quot;\&quot; computing ground plane below&quot; &lt;&lt; endl;
+                      &lt;&lt; &quot;\&quot; computing ground plane below&quot; &lt;&lt; std::endl;
     getGround(taskInfo.getTime());
   }
 
@@ -94,7 +94,7 @@
   Vector3 wireEnd0 = mWireFrame-&gt;posToParent(width*0.5*Vector3::unit(1));
   Vector3 wireEnd1 = mWireFrame-&gt;posToParent(-width*0.5*Vector3::unit(1));
 
-//   Log(Model,Error) &lt;&lt; trans(wireEnd0) &lt;&lt; trans(wireEnd1) &lt;&lt; endl;
+//   Log(Model,Error) &lt;&lt; trans(wireEnd0) &lt;&lt; trans(wireEnd1) &lt;&lt; std::endl;
 
   // The intersection of the x/z plane with the line between the wire ends
   Vector3 wireDir = wireEnd1 - wireEnd0;
@@ -127,7 +127,7 @@
   real_type vel0 = dot(relVel0.getLinear(), wireDir0);
   real_type vel1 = dot(relVel0.getLinear(), wireDir1);
 
-// Log(Model,Error) &lt;&lt; vel0 &lt;&lt; &quot;  &quot; &lt;&lt; vel1 &lt;&lt; endl;
+// Log(Model,Error) &lt;&lt; vel0 &lt;&lt; &quot;  &quot; &lt;&lt; vel1 &lt;&lt; std::endl;
   
   real_type v = 0.5*(vel0 + vel1);
   if (v &lt; 0.1) {
@@ -155,7 +155,7 @@
     const Ground* ground = mEnvironment-&gt;getGround();
     mHasWire = ground-&gt;caughtWire(mOldHookPosition, currentPosition);
     if (mHasWire)
-      Log(Model,Debug) &lt;&lt; &quot;Caught wire!&quot; &lt;&lt; endl;
+      Log(Model,Debug) &lt;&lt; &quot;Caught wire!&quot; &lt;&lt; std::endl;
   }
   mOldHookPosition = currentPosition;
   mFirstTime = false;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/TransferFunction.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/TransferFunction.cpp	2009-09-11 05:18:17 UTC (rev 1115)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/TransferFunction.cpp	2009-10-13 19:13:13 UTC (rev 1116)
@@ -68,7 +68,7 @@
 
   Log(Model, Info) &lt;&lt; &quot;Processing transfer function \&quot;&quot; &lt;&lt; getName()
                    &lt;&lt; &quot;\&quot;, nummerator: &quot; &lt;&lt; trans(mNum)
-                   &lt;&lt; &quot;, denominator&quot; &lt;&lt; trans(mDen) &lt;&lt; endl;
+                   &lt;&lt; &quot;, denominator&quot; &lt;&lt; trans(mDen) &lt;&lt; std::endl;
 
   // Make sure the first, not stored coefficient in the denominator is 1
   // Rescale the other coefficient vectors
@@ -89,7 +89,7 @@
   if ((rows(mDenNorm) + 1) &lt; rows(mNumNorm)) {
     Log(Model, Error) &lt;&lt; &quot;Cannot handle higher degree numerator than &quot;
                       &lt;&lt; &quot;denoninator polynomials for transfer function \&quot;&quot;
-                      &lt;&lt; getName() &lt;&lt; &quot;\&quot;!&quot; &lt;&lt; endl;
+                      &lt;&lt; getName() &lt;&lt; &quot;\&quot;!&quot; &lt;&lt; std::endl;
     return false;
   }
 
@@ -114,7 +114,7 @@
   Log(Model, Info) &lt;&lt; &quot;Normalized Processing transfer function \&quot;&quot; &lt;&lt; getName()
                    &lt;&lt; &quot;\&quot;, nummerator: &quot; &lt;&lt; trans(mNumNorm)
                    &lt;&lt; &quot;, denominator: &quot; &lt;&lt; trans(mDenNorm)
-                   &lt;&lt; &quot;, direct factor: &quot; &lt;&lt; mD &lt;&lt; endl;
+                   &lt;&lt; &quot;, direct factor: &quot; &lt;&lt; mD &lt;&lt; std::endl;
 
   return Model::alloc(context);
 }

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/UniversalJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/UniversalJoint.cpp	2009-09-11 05:18:17 UTC (rev 1115)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/UniversalJoint.cpp	2009-10-13 19:13:13 UTC (rev 1116)
@@ -51,7 +51,7 @@
 {
   real_type nrm = norm(axis);
   if (nrm &lt;= Limits&lt;real_type&gt;::min()) {
-    Log(Initialization, Error) &lt;&lt; &quot;JointAxis is zero ...&quot; &lt;&lt; endl;
+    Log(Initialization, Error) &lt;&lt; &quot;JointAxis is zero ...&quot; &lt;&lt; std::endl;
     return;
   }
   mAxis = (1/nrm)*axis;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/WheelContact.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/WheelContact.cpp	2009-09-11 05:18:17 UTC (rev 1115)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/WheelContact.cpp	2009-10-13 19:13:13 UTC (rev 1116)
@@ -83,7 +83,7 @@
     //                    &lt;&lt; trans(wheelVel) &lt;&lt; &quot; &quot;
     //                    &lt;&lt; omegaR &lt;&lt; &quot; &quot;
     //                    &lt;&lt; compressLength &lt;&lt; &quot; &quot;
-    //                    &lt;&lt; distHubGround &lt;&lt; endl;
+    //                    &lt;&lt; distHubGround &lt;&lt; std::endl;
     
     
     // Get the plane normal force.

Modified: branches/OpenFDM-StateSeparation/src/builder/QOsgWidget.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/builder/QOsgWidget.cpp	2009-09-11 05:18:17 UTC (rev 1115)
+++ branches/OpenFDM-StateSeparation/src/builder/QOsgWidget.cpp	2009-10-13 19:13:13 UTC (rev 1116)
@@ -233,7 +233,7 @@
 void
 QOsgWidget::initializeGL()
 {
-//   cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; endl;
+//   cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl;
 
   glColorMaterial(GL_FRONT, GL_AMBIENT_AND_DIFFUSE);
   glColorMaterial(GL_BACK, GL_AMBIENT_AND_DIFFUSE);
@@ -255,7 +255,7 @@
 void
 QOsgWidget::resizeGL(int w, int h)
 {
-//   cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; endl;
+//   cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl;
 
   if (!isValid())
     return;
@@ -268,7 +268,7 @@
 void
 QOsgWidget::paintGL()
 {
-//   cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; endl;
+//   cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl;
 
   if (!isValid())
     return;

Modified: branches/OpenFDM-StateSeparation/src/test/inertianav.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/inertianav.cpp	2009-09-11 05:18:17 UTC (rev 1115)
+++ branches/OpenFDM-StateSeparation/src/test/inertianav.cpp	2009-10-13 19:13:13 UTC (rev 1116)
@@ -140,7 +140,7 @@
     SharedPtr&lt;Context&gt; context = new Context(this, environment, portValueList);
     if (!context-&gt;alloc()) {
       Log(Model, Warning) &lt;&lt; &quot;Could not alloc for model \&quot;&quot;
-                          &lt;&lt; getName() &lt;&lt; &quot;\&quot;&quot; &lt;&lt; endl;
+                          &lt;&lt; getName() &lt;&lt; &quot;\&quot;&quot; &lt;&lt; std::endl;
       return 0;
     }
     return context.release();


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	
	<LI>Next message: <A HREF="001075.html">[OpenFDM-svn] r1117 - branches/OpenFDM-StateSeparation/src/OpenFDM
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1074">[ date ]</a>
              <a href="thread.html#1074">[ thread ]</a>
              <a href="subject.html#1074">[ subject ]</a>
              <a href="author.html#1074">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/openfdm-svn">More information about the OpenFDM-svn
mailing list</a><br>
</body></html>
