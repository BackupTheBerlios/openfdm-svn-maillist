From frohlich at mail.berlios.de  Tue Oct 13 21:13:16 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Tue, 13 Oct 2009 21:13:16 +0200
Subject: [OpenFDM-svn] r1116 - in branches/OpenFDM-StateSeparation/src:
	OpenFDM builder test
Message-ID: <200910131913.n9DJDGMj024733@sheep.berlios.de>

Author: frohlich
Date: 2009-10-13 21:13:13 +0200 (Tue, 13 Oct 2009)
New Revision: 1116

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Assert.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/AtmosphereSTD1976.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/DoPri5.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/ExternalInteract.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJoint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/ImplicitEuler.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Launchbar.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/LogStream.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/MidpointRule.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJoint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Model.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Newton.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/PrismaticActuator.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/PrismaticJoint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteActuator.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Tailhook.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/TransferFunction.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/UniversalJoint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/WheelContact.cpp
   branches/OpenFDM-StateSeparation/src/builder/QOsgWidget.cpp
   branches/OpenFDM-StateSeparation/src/test/inertianav.cpp
Log:
No longer using std::...

M    src/test/inertianav.cpp
M    src/builder/QOsgWidget.cpp
M    src/OpenFDM/MidpointRule.cpp
M    src/OpenFDM/MobileRootJoint.cpp
M    src/OpenFDM/Newton.cpp
M    src/OpenFDM/WheelContact.cpp
M    src/OpenFDM/CartesianJoint.h
M    src/OpenFDM/ImplicitEuler.cpp
M    src/OpenFDM/PrismaticActuator.cpp
M    src/OpenFDM/PrismaticJoint.cpp
M    src/OpenFDM/DoPri5.cpp
M    src/OpenFDM/Tailhook.cpp
M    src/OpenFDM/RevoluteActuator.cpp
M    src/OpenFDM/RevoluteJoint.cpp
M    src/OpenFDM/TransferFunction.cpp
M    src/OpenFDM/Launchbar.cpp
M    src/OpenFDM/FixedRootJoint.cpp
M    src/OpenFDM/System.cpp
M    src/OpenFDM/Model.cpp
M    src/OpenFDM/Assert.cpp
M    src/OpenFDM/AtmosphereSTD1976.cpp
M    src/OpenFDM/LogStream.h
M    src/OpenFDM/UniversalJoint.cpp
M    src/OpenFDM/ExternalInteract.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Assert.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Assert.cpp	2009-09-11 05:18:17 UTC (rev 1115)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Assert.cpp	2009-10-13 19:13:13 UTC (rev 1116)
@@ -1,4 +1,4 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2009 Mathias Froehlich 
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2009 Mathias Froehlich
  *
  */
 
@@ -19,6 +19,7 @@
 #endif
 
 #include <cstdlib>
+#include <ostream>
 
 namespace OpenFDM {
 
@@ -26,7 +27,7 @@
 {
   Log(Assert, Error) << "Assertion OpenFDMAssert(" << condition
                      << ") failed at line "
-                     << line << " in " << file << endl;
+                     << line << " in " << file << std::endl;
 
 #if defined(HAVE_BACKTRACE_SYMBOLS) && defined(HAVE_BACKTRACE)
 
@@ -36,10 +37,10 @@
   size_t size = backtrace(array, 1 + BACKTRACE_SIZE);
   char **strings = backtrace_symbols(array, size);
 
-  Log(Assert, Error) << " Backtrace:" << endl;
+  Log(Assert, Error) << " Backtrace:" << std::endl;
 
   for (size_t i = 1; i < size; ++i) {
-    Log(Assert, Error) << "  " << strings[i] << endl;
+    Log(Assert, Error) << "  " << strings[i] << std::endl;
 #ifdef HAVE_CXXABI_H
     char *mangled = ::strchr(strings[i], '(');
     char *rest = 0;
@@ -47,8 +48,8 @@
       rest = ::strchr(mangled+1, '+');
       if (!rest)
         rest = ::strchr(mangled+1, ')');
-    }        
-     
+    }
+
     if (mangled && rest && rest-mangled < 1024) {
       char manglebuf[1024];
       ::memcpy(manglebuf, mangled+1, rest-mangled-1);
@@ -58,7 +59,7 @@
       int status = 0;
       abi::__cxa_demangle(manglebuf, demangled, &length, &status);
       if (status == 0)
-        Log(Assert, Error) << "    (" << demangled << ")" << endl;
+        Log(Assert, Error) << "    (" << demangled << ")" << std::endl;
     }
 #endif
   }

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/AtmosphereSTD1976.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/AtmosphereSTD1976.cpp	2009-09-11 05:18:17 UTC (rev 1115)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/AtmosphereSTD1976.cpp	2009-10-13 19:13:13 UTC (rev 1116)
@@ -92,7 +92,7 @@
 
   Log(Environment, Debug) << "p = " << data.pressure << ", T = "
                           << data.temperature << ", rho = "
-                          << data.density << endl;
+                          << data.density << std::endl;
   
   return data;
 }

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h	2009-09-11 05:18:17 UTC (rev 1115)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h	2009-10-13 19:13:13 UTC (rev 1116)
@@ -36,12 +36,12 @@
   {
     if (!parentLinkValue) {
       Log(Model, Error) << "Parent link is not set while creating context "
-                        << "for model \"" << getName() << "\"" << endl;
+                        << "for model \"" << getName() << "\"" << std::endl;
       return 0;
     }
     if (!childLinkValue) {
       Log(Model, Error) << "Child link is not set while creating context "
-                        << "for model \"" << getName() << "\"" << endl;
+                        << "for model \"" << getName() << "\"" << std::endl;
       return 0;
     }
     SharedPtr<Context> context;
@@ -49,7 +49,7 @@
                           parentLinkValue, childLinkValue, portValueList);
     if (!context->allocStates()) {
       Log(Model, Warning) << "Could not alloc for model \""
-                          << getName() << "\"" << endl;
+                          << getName() << "\"" << std::endl;
       return 0;
     }
     return context.release();
@@ -200,7 +200,7 @@
       if (hIh.singular()) {
         Log(ArtBody,Error) << "Detected singular mass matrix for "
                            << "CartesianJoint \"" << mCartesianJoint->getName()
-                           << "\": Fix your model!" << endl;
+                           << "\": Fix your model!" << std::endl;
         return;
       }
 

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/DoPri5.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/DoPri5.cpp	2009-09-11 05:18:17 UTC (rev 1115)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/DoPri5.cpp	2009-10-13 19:13:13 UTC (rev 1116)
@@ -59,9 +59,9 @@
     real_type en = scaledErr(y7, err, atol, rtol);
 
     if (1 < en)
-      Log(TimeStep, Warning) << "DOPRI5: error too big: " << en << endl;
+      Log(TimeStep, Warning) << "DOPRI5: error too big: " << en << std::endl;
     else
-      Log(TimeStep, Info) << "DOPRI5: local error: " << en << endl;
+      Log(TimeStep, Info) << "DOPRI5: local error: " << en << std::endl;
 
     // Need to save that here
     mRCont[0] = mState;
@@ -87,7 +87,7 @@
   if (t < mTime - mStepsize || mTime < t) {
     Log(TimeStep, Error) << "Request for dense output at t = " << t
                          << " out of range [" << mTime - mStepsize
-                         << "," << mTime << "]" << endl;
+                         << "," << mTime << "]" << std::endl;
 //     return false;
   }
 

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/ExternalInteract.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ExternalInteract.cpp	2009-09-11 05:18:17 UTC (rev 1115)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ExternalInteract.cpp	2009-10-13 19:13:13 UTC (rev 1116)
@@ -285,7 +285,7 @@
   SharedPtr<Context> context = new Context(this, environment, portValueList);
   if (!context->alloc()) {
     Log(Model, Warning) << "Could not alloc for model \""
-                        << getName() << "\"" << endl;
+                        << getName() << "\"" << std::endl;
     return 0;
   }
   return context.release();

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJoint.cpp	2009-09-11 05:18:17 UTC (rev 1115)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJoint.cpp	2009-10-13 19:13:13 UTC (rev 1116)
@@ -88,7 +88,7 @@
                                            childLinkValue, portValueList);
   if (!context->allocStates()) {
     Log(Model, Warning) << "Could not alloc for model \""
-                        << getName() << "\"" << endl;
+                        << getName() << "\"" << std::endl;
     return false;
   }
   return context.release();

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/ImplicitEuler.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ImplicitEuler.cpp	2009-09-11 05:18:17 UTC (rev 1115)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ImplicitEuler.cpp	2009-10-13 19:13:13 UTC (rev 1116)
@@ -41,7 +41,7 @@
 ImplicitEuler::ImplicitEuler(void)
 {
   Log(TimeStep, Warning) << "Using mostly hacked implicit Euler method!!!"
-                         << endl;
+                         << std::endl;
   mJacStepsize = 0;
 }
 
@@ -77,10 +77,10 @@
     }
 
     if (mJacDecomp.singular())
-      Log(TimeStep, Warning) << "Have singular jacobian!" << endl;
+      Log(TimeStep, Warning) << "Have singular jacobian!" << std::endl;
     bool conv = Newton(iefun, mJacDecomp, mTime+h, fState, 1e-4, 1e-10);
     if (!conv)
-      Log(TimeStep, Warning) << "Have singular jacobian!" << endl;
+      Log(TimeStep, Warning) << "Have singular jacobian!" << std::endl;
 
     mState += fState;
     mTime += h;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Launchbar.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Launchbar.cpp	2009-09-11 05:18:17 UTC (rev 1115)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Launchbar.cpp	2009-10-13 19:13:13 UTC (rev 1116)
@@ -62,7 +62,7 @@
   if (!mTryMountPort.isConnected()) {
     Log(Model, Error) << "Initialization of Launchbar model \"" << getName()
                       << "\" failed: Input port \"" << getInputPortName(0)
-                      << "\" is not connected!" << endl;
+                      << "\" is not connected!" << std::endl;
     return false;
   }
 
@@ -70,7 +70,7 @@
   if (!mLaunchCommandPort.isConnected()) {
     Log(Model, Error) << "Initialization of Launchbar model \"" << getName()
                       << "\" failed: Input port \"" << getInputPortName(1)
-                      << "\" is not connected!" << endl;
+                      << "\" is not connected!" << std::endl;
     return false;
   }
 
@@ -83,7 +83,7 @@
   if (nonZeroIntersection(taskInfo.getSampleTimeSet(),
                           SampleTime::PerTimestep)) {
     Log(Model, Debug) << "Launchbar::output(): \"" << getName()
-                      << "\" computing ground plane below" << endl;
+                      << "\" computing ground plane below" << std::endl;
     getGround(taskInfo.getTime());
   }
 

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/LogStream.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/LogStream.h	2009-09-11 05:18:17 UTC (rev 1115)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/LogStream.h	2009-10-13 19:13:13 UTC (rev 1116)
@@ -1,4 +1,4 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2009 Mathias Froehlich 
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2009 Mathias Froehlich
  *
  */
 
@@ -6,8 +6,6 @@
 #define OpenFDM_LogStream_H
 
 #include <iosfwd>
-// FIXME: because of using std::endl;
-#include <ostream>
 #include "Referenced.h"
 
 namespace OpenFDM {
@@ -28,7 +26,7 @@
     Schedule         = Model << 1,
     Assert           = ~0
   };
-  
+
   enum Priority {
     /// Non recoverable error, either due to an implementation problem or
     /// due to a user problem probably ignoring previous error return values.
@@ -50,7 +48,7 @@
     Debug2           = Debug1 + 1,
     Debug3           = Debug2 + 1
   };
-  
+
   static void setCategoryEnable(Category category, bool enable = true);
   static void setCategoryDisable(Category category);
   static void setPriority(Priority priority);
@@ -66,7 +64,7 @@
 #endif
     return Instance()->getEnabled(category, priority);
   }
-  
+
   static std::ostream& getStream(Priority priority);
 
 protected:
@@ -85,8 +83,6 @@
 if (Logger::getStaticEnabled(Logger::category, Logger::priority)) \
   Logger::getStream(Logger::priority)
 
-using std::endl;
-
 } // namespace OpenFDM
 
 #endif

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MidpointRule.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MidpointRule.cpp	2009-09-11 05:18:17 UTC (rev 1115)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MidpointRule.cpp	2009-10-13 19:13:13 UTC (rev 1116)
@@ -96,7 +96,7 @@
       // If we cannot solve the nonlinear equation, do an explicit euler step
       mCollocationPolynomialValid = false;
 
-      Log(TimeStep, Warning) << "MidpointRule did not converge" << endl;
+      Log(TimeStep, Warning) << "MidpointRule did not converge" << std::endl;
 
       evalFunction(t, mState, mDeriv);
       mState += h*mDeriv;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJoint.cpp	2009-09-11 05:18:17 UTC (rev 1115)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJoint.cpp	2009-10-13 19:13:13 UTC (rev 1116)
@@ -101,7 +101,7 @@
                                            childLinkValue, portValueList);
   if (!context->allocStates()) {
     Log(Model, Warning) << "Could not alloc for model \""
-                        << getName() << "\"" << endl;
+                        << getName() << "\"" << std::endl;
     return false;
   }
   return context.release();

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Model.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Model.cpp	2009-09-11 05:18:17 UTC (rev 1115)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Model.cpp	2009-10-13 19:13:13 UTC (rev 1116)
@@ -79,14 +79,14 @@
     if (!portValue) {
       Log(Model, Error) << "No port value given for model \"" << getName()
                         << "\" and port \"" << getPort(i)->getName()
-                        << "\"" << endl;
+                        << "\"" << std::endl;
       return false;
     }
     context->setPortValue(*getPort(i), portValue);
   }
   if (!context->alloc()) {
     Log(Model, Warning) << "Could not alloc for model \""
-                        << getName() << "\"" << endl;
+                        << getName() << "\"" << std::endl;
     return false;
   }
   return context.release();

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Newton.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Newton.cpp	2009-09-11 05:18:17 UTC (rev 1115)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Newton.cpp	2009-10-13 19:13:13 UTC (rev 1116)
@@ -65,14 +65,14 @@
   // x_new is the potential solution at the next iteration step.
   Vector x_new;
 
-  Log(NewtonMethod, Debug) << "__________________________" << endl;
+  Log(NewtonMethod, Debug) << "__________________________" << std::endl;
   // The displacement of the undamped newton method for the first
   // iteration step.
   Vector err;
   f.eval(t, x, err);
-  Log(NewtonMethod, Debug1) << "err " << trans(err) << endl;
+  Log(NewtonMethod, Debug1) << "err " << trans(err) << std::endl;
   Vector dx_bar = jacInv.solve(err);
-  Log(NewtonMethod, Debug2) << "dx_bar " << trans(dx_bar) << endl;
+  Log(NewtonMethod, Debug2) << "dx_bar " << trans(dx_bar) << std::endl;
   do {
     // Increment the iteration counter. Just statistics ...
     if (itCount)
@@ -88,7 +88,7 @@
     if (normdx == 0.0)
       return true;
 
-    Log(NewtonMethod, Debug1) << "outer " << normdx << endl;
+    Log(NewtonMethod, Debug1) << "outer " << normdx << std::endl;
 
     // Damped newton method:
     // Use lambda*dx with 0 < lambda <= 1 instead of just dx as displacement.
@@ -106,13 +106,13 @@
       // Compute the error of that new approximation.
       f.eval(t, x_new, err);
 
-      Log(NewtonMethod, Debug) << "err " << trans(err) << endl;
+      Log(NewtonMethod, Debug) << "err " << trans(err) << std::endl;
 
       // Check if we get some kind of convergence with this lambda.
       // This jacobian evaluation will also be used for the next step if
       // this lambda truns out to be acceptable.
       dx_bar = jacInv.solve(err);
-      Log(NewtonMethod, Debug2) << "dx_bar " << trans(dx_bar) << endl;
+      Log(NewtonMethod, Debug2) << "dx_bar " << trans(dx_bar) << std::endl;
 
       // The convergence criterion parameter theta.
       real_type theta = 1.0 - 0.5*lambda;
@@ -121,12 +121,12 @@
       // to the current solution.
       real_type normdx_bar = norm(dx_bar);
 
-      Log(NewtonMethod, Debug) << "inner " << normdx_bar << endl;
+      Log(NewtonMethod, Debug) << "inner " << normdx_bar << std::endl;
 
       const real_type min_conv_rate = 1e-10;
       if (normdx == 0.0) {
         Log(NewtonMethod, Error) << "Whow: we have most likely an exact "
-          "solution and we iterate furter:  normdx = " << normdx << endl;
+          "solution and we iterate furter:  normdx = " << normdx << std::endl;
         convergenceRate = min_conv_rate;
       } else
         convergenceRate = max(min_conv_rate, normdx_bar/normdx);
@@ -155,16 +155,16 @@
     } else if (0 <= maxjac) {
       --maxjac;
 
-      Log(NewtonMethod, Debug) << "Computing new jacobian" << endl;
+      Log(NewtonMethod, Debug) << "Computing new jacobian" << std::endl;
 
       // get a new jacobian ...
       f.jac(t, x, jacInv.data());
-      Log(NewtonMethod, Debug2) << jacInv.data() << endl;
+      Log(NewtonMethod, Debug2) << jacInv.data() << std::endl;
       jacInv.factorize();
-      Log(NewtonMethod, Debug2) << "decomposed qr\n" << jacInv.data() << endl;
+      Log(NewtonMethod, Debug2) << "decomposed qr\n" << jacInv.data() << std::endl;
 
       if (jacInv.singular())
-        Log(NewtonMethod, Warning) << "Have singular jacobian!" << endl;
+        Log(NewtonMethod, Warning) << "Have singular jacobian!" << std::endl;
 
       converging = true;
     }
@@ -174,7 +174,7 @@
   } while (!converged && converging && 0 < maxit);
 
   Log(NewtonMethod, Info) << "Newton type method: converged = "
-                          << converged << endl;
+                          << converged << std::endl;
   
   // Tell the caller if it worked or not.
   return converged;
@@ -216,7 +216,7 @@
 
   while (norm1(v - w) > thresh) {
     Log(NewtonMethod, Debug2) << " Line Search: errv = " << fv
-                              << ", errw = " << fw << endl;
+                              << ", errw = " << fw << std::endl;
     // check for isfinite ...
     if (fv > fw) {
       v = v + vfac*(w-v);
@@ -255,7 +255,7 @@
   do {
     // Compute in each step a new jacobian
     f.jac(t, x, J);
-    Log(NewtonMethod, Debug) << "Jacobian is:\n" << J << endl;
+    Log(NewtonMethod, Debug) << "Jacobian is:\n" << J << std::endl;
 #ifdef USE_QR
     jacFactors = J;
 #else
@@ -263,7 +263,7 @@
 #endif
     Log(NewtonMethod, Debug) << "Jacobian is "
                              << (jacFactors.singular() ? "singular" : "ok")
-                             << endl;
+                             << std::endl;
    
     // Compute the actual error
     f.eval(t, x, err);
@@ -275,9 +275,9 @@
     dx = jacFactors.solve(trans(J)*err);
 #endif
     Log(NewtonMethod, Debug) << "dx residual "
-                             << trans(J*dx - err) << endl
+                             << trans(J*dx - err) << std::endl
                              << trans(J*dx - err)*J
-                             << endl;
+                             << std::endl;
 
     // Get a better search guess
     if (1 < norm(dx))
@@ -289,7 +289,7 @@
     
 
     Log(NewtonMethod, Debug) << "Convergence test: |dx| = " << norm(xnew - x)
-                             << ", converged = " << converged << endl;
+                             << ", converged = " << converged << std::endl;
     // New guess is the better one
     x = xnew;
   } while (!converged);
@@ -305,7 +305,7 @@
                   unsigned *itCount,
                   unsigned maxit)
 {
-  Log(NewtonMethod, Debug3) << "Start guess\nx = " << trans(x) << endl;
+  Log(NewtonMethod, Debug3) << "Start guess\nx = " << trans(x) << std::endl;
 
   Matrix J;
   LinAlg::MatrixFactors<real_type,0,0,LinAlg::LUTag> jacFactors;
@@ -316,7 +316,7 @@
 
   // Compute in each step a new jacobian
   f.jac(t, x, J);
-  Log(NewtonMethod, Debug3) << "Jacobian is:\n" << J << endl;
+  Log(NewtonMethod, Debug3) << "Jacobian is:\n" << J << std::endl;
   real_type mu = tau*norm1(J);
 
   Vector fx;
@@ -328,12 +328,12 @@
     jacFactors = trans(J)*J + mu*LinAlg::Eye<real_type,0,0>(rows(x), rows(x));
     Log(NewtonMethod, Debug) << "Jacobian is "
                              << (jacFactors.singular() ? "singular" : "ok")
-                             << endl;
+                             << std::endl;
    
     // Compute the search direction
     Vector h = jacFactors.solve(-g);
     Log(NewtonMethod, Debug) << "Solve Residual "
-                             << norm(trans(J)*J*h + mu*h + g)/norm(g) << endl;
+                             << norm(trans(J)*J*h + mu*h + g)/norm(g) << std::endl;
 
     // Get a better search guess
     Vector xnew = x + h;
@@ -341,7 +341,7 @@
     // check convergence
     converged = equal(x, xnew, atol, rtol);
     Log(NewtonMethod, Debug) << "Convergence test: ||h||_1 = " << norm1(h)
-                             << ", converged = " << converged << endl;
+                             << ", converged = " << converged << std::endl;
     if (converged)
       break;
 
@@ -353,22 +353,22 @@
     Log(NewtonMethod, Debug) << "Rho = " << rho
                              << ", Fxnew = " << Fxnew 
                              << ", Fx = " << Fx
-                             << endl;
+                             << std::endl;
     if (0 < rho) {
-      Log(NewtonMethod, Debug) << "Accepted step!" << endl;
-      Log(NewtonMethod, Debug3) << "xnew = " << trans(xnew) << endl;
-      Log(NewtonMethod, Debug3) << "h    = " << trans(h) << endl;
+      Log(NewtonMethod, Debug) << "Accepted step!" << std::endl;
+      Log(NewtonMethod, Debug3) << "xnew = " << trans(xnew) << std::endl;
+      Log(NewtonMethod, Debug3) << "h    = " << trans(h) << std::endl;
 
       // New guess is the better one
       x = xnew;
 
       f.jac(t, x, J);
-      Log(NewtonMethod, Debug3) << "Jacobian is:\n" << J << endl;
+      Log(NewtonMethod, Debug3) << "Jacobian is:\n" << J << std::endl;
       // Compute the actual error
       f.eval(t, x, fx);
       g = trans(J)*fx;
       converged = norm1(g) < atol;
-      Log(NewtonMethod, Debug) << "||g||_1 = " << norm1(g) << endl;
+      Log(NewtonMethod, Debug) << "||g||_1 = " << norm1(g) << std::endl;
 
       mu = mu * max(real_type(1)/3, 1-pow(2*rho-1, real_type(3)));
       nu = 2;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/PrismaticActuator.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/PrismaticActuator.cpp	2009-09-11 05:18:17 UTC (rev 1115)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/PrismaticActuator.cpp	2009-10-13 19:13:13 UTC (rev 1116)
@@ -66,7 +66,7 @@
 {
   real_type nrm = norm(axis);
   if (nrm <= Limits<real_type>::min()) {
-    Log(Initialization, Error) << "JointAxis is zero ..." << endl;
+    Log(Initialization, Error) << "JointAxis is zero ..." << std::endl;
     return;
   }
   mAxis = (1/nrm)*axis;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/PrismaticJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/PrismaticJoint.cpp	2009-09-11 05:18:17 UTC (rev 1115)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/PrismaticJoint.cpp	2009-10-13 19:13:13 UTC (rev 1116)
@@ -57,7 +57,7 @@
 {
   real_type nrm = norm(axis);
   if (nrm <= Limits<real_type>::min()) {
-    Log(Initialization, Error) << "JointAxis is zero ..." << endl;
+    Log(Initialization, Error) << "JointAxis is zero ..." << std::endl;
     return;
   }
   mAxis = (1/nrm)*axis;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteActuator.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteActuator.cpp	2009-09-11 05:18:17 UTC (rev 1115)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteActuator.cpp	2009-10-13 19:13:13 UTC (rev 1116)
@@ -66,7 +66,7 @@
 {
   real_type nrm = norm(axis);
   if (nrm <= Limits<real_type>::min()) {
-    Log(Initialization, Error) << "JointAxis is zero ..." << endl;
+    Log(Initialization, Error) << "JointAxis is zero ..." << std::endl;
     return;
   }
   mAxis = (1/nrm)*axis;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.cpp	2009-09-11 05:18:17 UTC (rev 1115)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.cpp	2009-10-13 19:13:13 UTC (rev 1116)
@@ -54,7 +54,7 @@
 {
   real_type nrm = norm(axis);
   if (nrm <= Limits<real_type>::min()) {
-    Log(Initialization, Error) << "JointAxis is zero ..." << endl;
+    Log(Initialization, Error) << "JointAxis is zero ..." << std::endl;
     return;
   }
   mAxis = (1/nrm)*axis;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2009-09-11 05:18:17 UTC (rev 1115)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2009-10-13 19:13:13 UTC (rev 1116)
@@ -448,12 +448,12 @@
         Log(Schedule, Debug3) << "Try to create port value \""
                               << mPortDataVector[i]->getPort()->getName()
                               << "\" of \"" << getNodeNamePath()
-                              << "\"" << endl;
+                              << "\"" << std::endl;
         if (!mPortDataVector[i]->createPortValue()) {
           Log(Schedule, Warning) << "Failed to create port value \""
                                  << mPortDataVector[i]->getPort()->getName()
                                  << "\" of \"" << getNodeNamePath()
-                                 << "\".\nAborting!" << endl;
+                                 << "\".\nAborting!" << std::endl;
 
           return false;
         }
@@ -467,20 +467,20 @@
         Log(Schedule, Debug3) << "Try to fetch port value \""
                               << mPortDataVector[i]->getPort()->getName()
                               << "\" of \"" << getNodeNamePath()
-                              << "\"" << endl;
+                              << "\"" << std::endl;
         PortValue* portValue = mPortDataVector[i]->getPortValue();
         if (!portValue) {
           Log(Schedule, Warning) << "Failed to fetch port value \""
                                  << mPortDataVector[i]->getPort()->getName()
                                  << "\" of \"" << getNodeNamePath()
-                                 << "\".\nAborting!" << endl;
+                                 << "\".\nAborting!" << std::endl;
           return false;
         }
         if (!mPortDataVector[i]->getPort()->acceptPortValue(portValue)) {
           Log(Schedule, Warning) << "Failed to accept fetched port value \""
                                  << mPortDataVector[i]->getPort()->getName()
                                  << "\" of \"" << getNodeNamePath()
-                                 << "\".\nAborting!" << endl;
+                                 << "\".\nAborting!" << std::endl;
           return false;
         }
 
@@ -528,7 +528,7 @@
       mModelContext = mModel->newModelContext(mPortValueList);
       if (!mModelContext) {
         Log(Schedule, Warning) << "Could not create context for model \""
-                               << getNodeNamePath() << "\"" << endl;
+                               << getNodeNamePath() << "\"" << std::endl;
         return false;
       }
       return true;
@@ -604,7 +604,7 @@
       if (!mMechanicContext) {
         Log(Schedule, Warning) << "Could not create context for mechanic "
                                << "node \"" << getNodeNamePath()
-                               << "\"" << endl;
+                               << "\"" << std::endl;
         return false;
       }
       return true;
@@ -700,7 +700,7 @@
       if (!mMechanicContext) {
         Log(Schedule, Warning) << "Could not create context for mechanic "
                                << "node \"" << getNodeNamePath()
-                               << "\"" << endl;
+                               << "\"" << std::endl;
         return false;
       }
       return true;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Tailhook.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Tailhook.cpp	2009-09-11 05:18:17 UTC (rev 1115)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Tailhook.cpp	2009-10-13 19:13:13 UTC (rev 1116)
@@ -56,7 +56,7 @@
   if (!mHookPositionPort.isConnected()) {
     Log(Model, Error) << "Initialization of Tailhook model \"" << getName()
                       << "\" failed: Input port \"" << getInputPortName(0)
-                      << "\" is not connected!" << endl;
+                      << "\" is not connected!" << std::endl;
     return false;
   }
 
@@ -69,7 +69,7 @@
   if (nonZeroIntersection(taskInfo.getSampleTimeSet(),
                           SampleTime::PerTimestep)) {
     Log(Model, Debug) << "Tailhook::output(): \"" << getName()
-                      << "\" computing ground plane below" << endl;
+                      << "\" computing ground plane below" << std::endl;
     getGround(taskInfo.getTime());
   }
 
@@ -94,7 +94,7 @@
   Vector3 wireEnd0 = mWireFrame->posToParent(width*0.5*Vector3::unit(1));
   Vector3 wireEnd1 = mWireFrame->posToParent(-width*0.5*Vector3::unit(1));
 
-//   Log(Model,Error) << trans(wireEnd0) << trans(wireEnd1) << endl;
+//   Log(Model,Error) << trans(wireEnd0) << trans(wireEnd1) << std::endl;
 
   // The intersection of the x/z plane with the line between the wire ends
   Vector3 wireDir = wireEnd1 - wireEnd0;
@@ -127,7 +127,7 @@
   real_type vel0 = dot(relVel0.getLinear(), wireDir0);
   real_type vel1 = dot(relVel0.getLinear(), wireDir1);
 
-// Log(Model,Error) << vel0 << "  " << vel1 << endl;
+// Log(Model,Error) << vel0 << "  " << vel1 << std::endl;
   
   real_type v = 0.5*(vel0 + vel1);
   if (v < 0.1) {
@@ -155,7 +155,7 @@
     const Ground* ground = mEnvironment->getGround();
     mHasWire = ground->caughtWire(mOldHookPosition, currentPosition);
     if (mHasWire)
-      Log(Model,Debug) << "Caught wire!" << endl;
+      Log(Model,Debug) << "Caught wire!" << std::endl;
   }
   mOldHookPosition = currentPosition;
   mFirstTime = false;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/TransferFunction.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/TransferFunction.cpp	2009-09-11 05:18:17 UTC (rev 1115)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/TransferFunction.cpp	2009-10-13 19:13:13 UTC (rev 1116)
@@ -68,7 +68,7 @@
 
   Log(Model, Info) << "Processing transfer function \"" << getName()
                    << "\", nummerator: " << trans(mNum)
-                   << ", denominator" << trans(mDen) << endl;
+                   << ", denominator" << trans(mDen) << std::endl;
 
   // Make sure the first, not stored coefficient in the denominator is 1
   // Rescale the other coefficient vectors
@@ -89,7 +89,7 @@
   if ((rows(mDenNorm) + 1) < rows(mNumNorm)) {
     Log(Model, Error) << "Cannot handle higher degree numerator than "
                       << "denoninator polynomials for transfer function \""
-                      << getName() << "\"!" << endl;
+                      << getName() << "\"!" << std::endl;
     return false;
   }
 
@@ -114,7 +114,7 @@
   Log(Model, Info) << "Normalized Processing transfer function \"" << getName()
                    << "\", nummerator: " << trans(mNumNorm)
                    << ", denominator: " << trans(mDenNorm)
-                   << ", direct factor: " << mD << endl;
+                   << ", direct factor: " << mD << std::endl;
 
   return Model::alloc(context);
 }

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/UniversalJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/UniversalJoint.cpp	2009-09-11 05:18:17 UTC (rev 1115)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/UniversalJoint.cpp	2009-10-13 19:13:13 UTC (rev 1116)
@@ -51,7 +51,7 @@
 {
   real_type nrm = norm(axis);
   if (nrm <= Limits<real_type>::min()) {
-    Log(Initialization, Error) << "JointAxis is zero ..." << endl;
+    Log(Initialization, Error) << "JointAxis is zero ..." << std::endl;
     return;
   }
   mAxis = (1/nrm)*axis;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/WheelContact.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/WheelContact.cpp	2009-09-11 05:18:17 UTC (rev 1115)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/WheelContact.cpp	2009-10-13 19:13:13 UTC (rev 1116)
@@ -83,7 +83,7 @@
     //                    << trans(wheelVel) << " "
     //                    << omegaR << " "
     //                    << compressLength << " "
-    //                    << distHubGround << endl;
+    //                    << distHubGround << std::endl;
     
     
     // Get the plane normal force.

Modified: branches/OpenFDM-StateSeparation/src/builder/QOsgWidget.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/builder/QOsgWidget.cpp	2009-09-11 05:18:17 UTC (rev 1115)
+++ branches/OpenFDM-StateSeparation/src/builder/QOsgWidget.cpp	2009-10-13 19:13:13 UTC (rev 1116)
@@ -233,7 +233,7 @@
 void
 QOsgWidget::initializeGL()
 {
-//   cout << __PRETTY_FUNCTION__ << endl;
+//   cout << __PRETTY_FUNCTION__ << std::endl;
 
   glColorMaterial(GL_FRONT, GL_AMBIENT_AND_DIFFUSE);
   glColorMaterial(GL_BACK, GL_AMBIENT_AND_DIFFUSE);
@@ -255,7 +255,7 @@
 void
 QOsgWidget::resizeGL(int w, int h)
 {
-//   cout << __PRETTY_FUNCTION__ << endl;
+//   cout << __PRETTY_FUNCTION__ << std::endl;
 
   if (!isValid())
     return;
@@ -268,7 +268,7 @@
 void
 QOsgWidget::paintGL()
 {
-//   cout << __PRETTY_FUNCTION__ << endl;
+//   cout << __PRETTY_FUNCTION__ << std::endl;
 
   if (!isValid())
     return;

Modified: branches/OpenFDM-StateSeparation/src/test/inertianav.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/inertianav.cpp	2009-09-11 05:18:17 UTC (rev 1115)
+++ branches/OpenFDM-StateSeparation/src/test/inertianav.cpp	2009-10-13 19:13:13 UTC (rev 1116)
@@ -140,7 +140,7 @@
     SharedPtr<Context> context = new Context(this, environment, portValueList);
     if (!context->alloc()) {
       Log(Model, Warning) << "Could not alloc for model \""
-                          << getName() << "\"" << endl;
+                          << getName() << "\"" << std::endl;
       return 0;
     }
     return context.release();



From frohlich at mail.berlios.de  Tue Oct 13 22:26:35 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Tue, 13 Oct 2009 22:26:35 +0200
Subject: [OpenFDM-svn] r1117 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200910132026.n9DKQZ4n029711@sheep.berlios.de>

Author: frohlich
Date: 2009-10-13 22:26:34 +0200 (Tue, 13 Oct 2009)
New Revision: 1117

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/LogStream.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Logger.cpp
Log:
Cleanup.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/LogStream.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/LogStream.h	2009-10-13 19:13:13 UTC (rev 1116)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/LogStream.h	2009-10-13 20:26:34 UTC (rev 1117)
@@ -53,23 +53,28 @@
   static void setCategoryDisable(Category category);
   static void setPriority(Priority priority);
 
-  static inline bool
-  getStaticEnabled(Category category, Priority priority)
+  static std::ostream* getStaticStream(Category category, Priority priority)
   {
 #if defined(NDEBUG) || defined(_NDEBUG)
     // In the NDEBUG case, give the compilers optimizer a chance to
-    // completely remove the code.
+    // completely remove some code.
     if (Debug <= priority)
-      return false;
+      return 0;
 #endif
-    return Instance()->getEnabled(category, priority);
+    return Instance()->getStream(category, priority);
   }
 
-  static std::ostream& getStream(Priority priority);
-
 protected:
   static Logger* Instance(void);
-  bool getEnabled(Category category, Priority priority);
+  std::ostream* getStream(Category category, Priority priority);
+  bool getEnabled(Category category, Priority priority)
+  {
+    if (priority == Error)
+      return true;
+    if (!(category & mCategory))
+      return false;
+    return priority <= mPriority;
+  }
 
 private:
   Logger(std::ostream* stream = 0);
@@ -79,9 +84,9 @@
   int mPriority;
 };
 
-#define Log(category, priority) \
-if (Logger::getStaticEnabled(Logger::category, Logger::priority)) \
-  Logger::getStream(Logger::priority)
+#define Log(cat, pri) \
+if (std::ostream* stream = Logger::getStaticStream(Logger::cat, Logger::pri)) \
+  *stream
 
 } // namespace OpenFDM
 

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Logger.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Logger.cpp	2009-10-13 19:13:13 UTC (rev 1116)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Logger.cpp	2009-10-13 20:26:34 UTC (rev 1117)
@@ -1,4 +1,4 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2009 Mathias Froehlich 
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2009 Mathias Froehlich
  *
  */
 
@@ -52,18 +52,6 @@
   logger->mPriority = priority;
 }
 
-std::ostream&
-Logger::getStream(Logger::Priority priority)
-{
-  Logger* logger = Instance();
-  if (logger->mStream)
-    return *logger->mStream;
-  else if (Info <= priority)
-    return std::cout;
-  else
-    return std::cerr;
-}
-
 Logger*
 Logger::Instance(void)
 {
@@ -79,14 +67,18 @@
   return ptr;
 }
 
-bool
-Logger::getEnabled(Logger::Category category, Logger::Priority priority)
+std::ostream*
+Logger::getStream(Category category, Logger::Priority priority)
 {
-  if (priority == Error)
-    return true;
-  if (!(category & mCategory))
-    return false;
-  return priority <= mPriority;
+  if (!getEnabled(category, priority))
+    return 0;
+
+  if (mStream)
+    return mStream;
+  else if (Info <= priority)
+    return &std::cout;
+  else
+    return &std::cerr;
 }
 
 Logger::Logger(std::ostream* stream) :
@@ -98,7 +90,7 @@
   unsigned value = atou(std::getenv("OPENFDM_DEBUG_PRIORITY"));
   if (value)
     mPriority = value;
-      
+
   value = atou(std::getenv("OPENFDM_DEBUG_CATEGORY"));
   if (value)
     mCategory = value;



