From frohlich at berlios.de  Wed Oct  5 16:11:12 2005
From: frohlich at berlios.de (Mathias Froehlich at BerliOS)
Date: Wed, 5 Oct 2005 16:11:12 +0200
Subject: [Openfdm-svn] r7 - trunk/flightgear
Message-ID: <200510051411.j95EBC9G027824@sheep.berlios.de>

Author: frohlich
Date: 2005-10-05 16:11:12 +0200 (Wed, 05 Oct 2005)
New Revision: 7

Added:
   trunk/flightgear/FGOpenFDM.cpp
   trunk/flightgear/FGOpenFDM.h
   trunk/flightgear/FGPropertyAdapter.h
Log:
Initial import to berlios.


Added: trunk/flightgear/FGOpenFDM.cpp
===================================================================
--- trunk/flightgear/FGOpenFDM.cpp	2005-10-05 14:10:06 UTC (rev 6)
+++ trunk/flightgear/FGOpenFDM.cpp	2005-10-05 14:11:12 UTC (rev 7)
@@ -0,0 +1,482 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
+ *
+ */
+
+#include <simgear/misc/sg_path.hxx>
+#include <simgear/math/sg_geodesy.hxx>
+#include <simgear/props/props.hxx>
+
+#include <Controls/controls.hxx>
+#include <Main/globals.hxx>
+#include <Main/fg_props.hxx>
+
+#include <JSBSim/JSBReader.h>
+#include <OpenFDM/Units.h>
+#include <OpenFDM/Vehicle.h>
+#include <OpenFDM/Input.h>
+#include <OpenFDM/Ground.h>
+#include <OpenFDM/Model.h>
+#include <OpenFDM/ModelGroup.h>
+
+#include "FGPropertyAdapter.h"
+
+#include "FGOpenFDM.h"
+
+namespace OpenFDM {
+
+class FGGround
+  : public Ground {
+public:
+  FGGround(FGInterface *ifce)
+    : mIfce(ifce)
+  { }
+  virtual ~FGGround(void)
+  { }
+
+  virtual GroundValues
+  getGroundPlane(real_type t, const Vector3& refPos) const
+  {
+    double loc_cart[3] = { refPos(1), refPos(2), refPos(3) };
+    double contact[3], normal[3], vel[3], lc, ff, agl;
+    int groundtype;
+    // FIXME!!!!!!!
+    bool ok = false;
+    if (mIfce)
+      ok = mIfce->get_agl_m(t, loc_cart, contact, normal, vel,
+                            &groundtype, &lc, &ff, &agl);
+    Vector3 unitDown(-normal[0], -normal[1], -normal[2]);
+    Vector3 groundOff(contact[0], contact[1], contact[2]);
+    // FIXME: why is this not normalized?? ...
+    Plane p(normalize(unitDown), groundOff);
+    Vector6 v(Vector3::zeros(), Vector3(vel[0], vel[1], vel[2]));
+    return GroundValues(p, v, ff);
+  }
+
+  void setInterface(FGInterface *ifce)
+  { mIfce = ifce; }
+  
+private:
+  FGInterface *mIfce;
+};
+
+
+class FGPlanet
+  : public Planet {
+public:
+  /** Default constructor.
+   */
+  FGPlanet(void) {}
+
+  /** Default destructor.
+   */
+  virtual ~FGPlanet(void) {}
+
+  /** Gravity acceleration at the cartesion position cart.
+   */
+  virtual Vector3 gravityAccel(const Vector3& cart) const
+  {
+    real_type planetMass = 5.9742e24;
+    real_type dist = norm(cart);
+    return (-planetMass*gravity_constant/(dist*dist*dist))*cart;
+  }
+
+  /** Transform cartesian coordinates to geodetic coordinates.
+   */
+  virtual Geodetic toGeod(const Vector3& cart) const
+  {
+    double xyz[3] = { cart(1), cart(2), cart(3) };
+    double lat, lon, alt;
+    sgCartToGeod(xyz, &lat, &lon, &alt);
+    return Geodetic(lat, lon, alt);
+  }
+
+  /** Transform geodetic coordinates to cartesian coordinates.
+   */
+  virtual Vector3 toCart(const Geodetic& geod) const
+  {
+    double xyz[3];
+    sgGeodToCart(geod.latitude, geod.longitude, geod.altitude, xyz);
+    return Vector3(xyz[0], xyz[1], xyz[2]);
+  }
+};
+
+class FGWind
+  : public Wind {
+public:
+  FGWind(void) {}
+  virtual ~FGWind(void) {}
+
+  // Return the wind velocity in the global coordinate frame.
+  // ????
+  // FIXME: make pure virtual
+  virtual Vector3 getWindVel(const Vector3& pos) const
+  {
+    double xyz[3] = { pos(1), pos(2), pos(3) };
+    double lat, lon, alt;
+    sgCartToGeod(xyz, &lat, &lon, &alt);
+
+    real_type cosLat = cos(lat);
+    real_type sinLat = sin(lat);
+    real_type cosLon = cos(lon);
+    real_type sinLon = sin(lon);
+
+    Matrix33 T(-cosLon*sinLat, -sinLon, -cosLon*cosLat,
+               -sinLon*sinLat, cosLon , -sinLon*cosLat,
+               cosLat        , 0.0    , -sinLat);
+
+    double north = fgGetDouble("/environment/wind-from-north-fps");
+    double east = fgGetDouble("/environment/wind-from-east-fps");
+    double down = fgGetDouble("/environment/wind-from-down-fps");
+
+    return convertFrom(uFeetPSecond, T*Vector3(north, east, down));
+  }
+};
+
+
+//     temperature = fgGetNode("/environment/temperature-degc",true);
+//     pressure = fgGetNode("/environment/pressure-inhg",true);
+//     density = fgGetNode("/environment/density-slugft3",true);
+//     turbulence_gain = fgGetNode("/environment/turbulence/magnitude-norm",true);
+//     turbulence_rate = fgGetNode("/environment/turbulence/rate-hz",true);
+
+
+
+class FGPropertyImpl : public PropertyImpl<real_type> {
+public:
+  FGPropertyImpl(SGPropertyNode* ptr) : mPropertyNode(ptr) {}
+  virtual void setValue(const real_type& value) { if (mPropertyNode.valid()) mPropertyNode->setDoubleValue(value); }
+  virtual const Object* getObject(void) const { return 0; }
+  virtual Object* getObject(void) { return 0; }
+  virtual bool isValid(void) const { return true; }
+  virtual real_type getValue(void) const { if (mPropertyNode.valid()) return mPropertyNode->getDoubleValue(); else return 0; }
+private:
+  SGPropertyNode_ptr mPropertyNode;
+};
+
+// Our local storage covers the pointer to our vehicle.
+// A list of the property to expression adaptors.
+struct FGOpenFDMData {
+  OpenFDM::shared_ptr<OpenFDM::Vehicle> vehicle;
+  OpenFDM::shared_ptr<OpenFDM::FGGround> ground;
+};
+
+FGOpenFDM::FGOpenFDM(SGPropertyNode* fdmRootNode) :
+  mAircraftRootNode(fdmRootNode)
+{
+  SG_LOG(SG_FLIGHT, SG_INFO, "FGOpenFDM::FGOpenFDM(...)");
+
+  mData = new FGOpenFDMData;
+
+  // FIXME: this is the place where we can plug in our stuff into an other
+  // base directory. For example if this will get an AI aircraft or what ever.
+  if (!mAircraftRootNode)
+    mAircraftRootNode = SGPropertyNode_ptr(fgGetNode("/", true));
+}
+
+FGOpenFDM::~FGOpenFDM(void)
+{
+  SG_LOG(SG_FLIGHT, SG_INFO, "FGOpenFDM::~FGOpenFDM()");
+  mData->ground->setInterface(0);
+  delete mData;
+}
+
+void FGOpenFDM::init()
+{
+  SG_LOG(SG_FLIGHT, SG_INFO, "FGOpenFDM::init()");
+
+  // Call what needs to be done ... ;-(
+  common_init();
+
+  SGPath fdmConfig(fgGetString("/sim/aircraft-dir"));
+  fdmConfig.append(fgGetString("/sim/aero"));
+  fdmConfig.concat(".xml");
+
+  // Try to read JSBSim legacy files.
+  JSBReader reader;
+  try {
+    readXML(fdmConfig.str(), reader);
+  } catch (const sg_exception& e) {
+    SG_LOG(SG_IO, SG_ALERT, "While loading \"" << fdmConfig.str()
+           << "\":\nGot an sg_exception from " << e.getOrigin() << ": "
+           << e.getFormattedMessage());
+    return;
+  }
+
+  mData->vehicle = reader.getVehicle();
+  mData->ground = new FGGround(this);
+  mData->vehicle->setGround(mData->ground);
+  mData->vehicle->setPlanet(new FGPlanet);
+  mData->vehicle->setWind(new FGWind);
+
+  mData->vehicle->init();
+
+  set_inited(true);
+}
+
+void FGOpenFDM::bind()
+{
+  SG_LOG(SG_FLIGHT, SG_INFO, "FGOpenFDM::bind()");
+
+  FGInterface::bind();
+
+  SGPropertyNode* sgProp = mAircraftRootNode->getChild("fdm/vehicle", 0, true);
+  sgProp = sgProp->getChild("system", 0, true);
+  tieModelGroup(sgProp, mData->vehicle->getSystem());
+}
+
+void FGOpenFDM::unbind()
+{
+  SG_LOG(SG_FLIGHT, SG_INFO, "FGOpenFDM::unbind()");
+
+  untieNamed(mAircraftRootNode, "fdm/vehicle");
+
+  FGInterface::unbind();
+}
+
+void FGOpenFDM::update(double dt)
+{
+  if (is_suspended() || dt == 0)
+    return;
+
+  // Get a local vehicle pointer
+  Vehicle* vehicle = mData->vehicle;
+
+  if (!vehicle) {
+    SG_LOG(SG_FLIGHT, SG_ALERT,
+           "FGOpenFDM::update(double) is called without an aircraft loaded!");
+    return;
+  }
+
+
+  // Check if somebody has fiddled with the state values since the past step...
+  bool stateChanged = false;
+
+  // Check the position
+  Geodetic gp = Geodetic(get_Latitude(),
+                         get_Longitude(),
+                         convertFrom(uFoot, get_Altitude()));
+  if (!equal(vehicle->getPlanet()->toCart(gp), vehicle->getCartPosition())) {
+    stateChanged = true;
+    SG_LOG(SG_FLIGHT, SG_INFO,
+           "Geod Pos set, error = "
+           << norm(vehicle->getPlanet()->toCart(gp)-vehicle->getCartPosition())
+           << "\n\tprevous: " << vehicle->getGeodPosition()
+           << "\n\tcurrent: "<< gp );
+    vehicle->setGeodPosition(gp);
+  }
+
+  // Check the orientation 
+  Vector3 euler = vehicle->getGeodOrientation().getEuler();
+  if (!equal(euler, Vector3(get_Phi(), get_Theta(), get_Psi()))) {
+    stateChanged = true;
+    Quaternion
+      go = Quaternion::fromHeadAttBank(get_Psi(), get_Theta(), get_Phi());
+    SG_LOG(SG_FLIGHT, SG_INFO,
+           "Geod Or set, error = "
+           << norm(vehicle->getGeodOrientation() - go)
+           << "\n\tprevous: " << vehicle->getGeodOrientation()
+           << "\n\tcurrent: "<< go );
+    vehicle->setGeodOrientation(go);
+  }
+  
+  if (stateChanged)
+    SG_LOG(SG_FLIGHT, SG_INFO, "State changed ------------------------------");
+
+  double acrad = vehicle->getRadius();
+  double groundCacheRadius = acrad
+    + 2*dt*norm(vehicle->getVelocity().getLinear());
+  Vector3 cart = vehicle->getCartPosition();
+  double cart_pos[3] = { cart(1), cart(2), cart(3) };
+  double t = vehicle->getTime();
+  if (!prepare_ground_cache_m(t, cart_pos, groundCacheRadius))
+    SG_LOG(SG_FLIGHT, SG_WARN,
+           "FGInterface is beeing called without scenery below the aircraft!");
+
+  vehicle->output();
+  vehicle->update(dt);
+
+  // Now write the newly computed values into the interface class.
+  gp = vehicle->getGeodPosition();
+  _updateGeodeticPosition(gp.latitude, gp.longitude,
+                          convertTo(uFoot, gp.altitude));
+
+  euler = vehicle->getGeodOrientation().getEuler();
+  _set_Euler_Angles(euler(1), euler(2), euler(3));
+
+
+  _set_V_rel_wind(convertTo(uFeetPSecond,
+                            norm(vehicle->getVelocity().getLinear())));
+
+  _set_V_equiv_kts(convertTo(uKnots,
+                             norm(vehicle->getVelocity().getLinear())));
+  
+  _set_V_calibrated_kts(convertTo(uKnots,
+                                  norm(vehicle->getVelocity().getLinear())));
+
+  _set_V_ground_speed(convertTo(uFeetPSecond,
+                                norm(vehicle->getVelocity().getLinear())));
+
+  // Velocities
+//   _set_Velocities_Local( Propagate->GetVel(eNorth),
+//                          Propagate->GetVel(eEast),
+//                          Propagate->GetVel(eDown) );
+
+//     _set_Velocities_Wind_Body( Propagate->GetUVW(1),
+//                                Propagate->GetUVW(2),
+//                                Propagate->GetUVW(3) );
+
+//     _set_Velocities_Ground( Propagate->GetVel(eNorth),
+//                             Propagate->GetVel(eEast),
+//                             -Propagate->GetVel(eDown) );
+
+}
+
+
+void
+FGOpenFDM::tieObject(SGPropertyNode* base, Object* object)
+{
+  // Check for output models
+  // If so, we want to reflect that in flightgears property tree
+  Output* outputModel = dynamic_cast<Output*>(object);
+  if (outputModel) {
+    std::string pName = outputModel->getOutputName();
+    SGPropertyNode* sgProp = mAircraftRootNode->getNode(pName.c_str(), true);
+    Property prop = object->getProperty("value");
+    sgProp->tie(FGRealPropertyAdapter(prop.toRealProperty()));
+  }
+
+  // Check for input models
+  // If so, we need to register a change notifier in flightgears property tree
+  Input* inputModel = dynamic_cast<Input*>(object);
+  if (inputModel) {
+    SG_LOG(SG_FLIGHT, SG_INFO,
+           "Registering input for \"" << inputModel->getName() << "\"");
+    std::string pName = inputModel->getInputName();
+    SGPropertyNode* sgProp = mAircraftRootNode->getNode(pName.c_str(), true);
+    // That adds a change listener to the property node which in turn
+    // writes changes to the property back to the input model.
+    inputModel->setUserData(new InputChangeUserData(inputModel, sgProp));
+  }
+
+  // The usual, whole object reflection so that one can take a look into
+  // OpenFDM's internal modules ...
+  std::list<std::string> propertyList = object->listProperties();
+  std::list<std::string>::const_iterator it = propertyList.begin();
+  while (it != propertyList.end()) {
+    // ... well, FIXME cleanup ...
+    std::string pName = toPropname(*it);
+    SGPropertyNode* sgProp = base->getChild(pName.c_str(), 0, true);
+    Property prop = object->getProperty(*it);
+    if (prop.isStringProperty())
+      sgProp->tie(FGStringPropertyAdapter(prop.toStringProperty()));
+    else if (prop.isRealProperty())
+      sgProp->tie(FGRealPropertyAdapter(prop.toRealProperty()));
+    else if (prop.isIntegerProperty())
+      sgProp->tie(FGIntPropertyAdapter(prop.toIntegerProperty()));
+    else if (prop.isUnsignedProperty())
+      sgProp->tie(FGUnsignedPropertyAdapter(prop.toUnsignedProperty()));
+    else if (prop.isVector2Property()) {
+      sgProp->tie(FGVector2PropertyAdapter(prop.toVector2Property(), 1));
+      sgProp = base->getChild(pName.c_str(), 1, true);
+      sgProp->tie(FGVector2PropertyAdapter(prop.toVector2Property(), 2));
+    }
+    else if (prop.isVector3Property()) {
+      sgProp->tie(FGVector3PropertyAdapter(prop.toVector3Property(), 1));
+      sgProp = base->getChild(pName.c_str(), 1, true);
+      sgProp->tie(FGVector3PropertyAdapter(prop.toVector3Property(), 2));
+      sgProp = base->getChild(pName.c_str(), 2, true);
+      sgProp->tie(FGVector3PropertyAdapter(prop.toVector3Property(), 3));
+    }
+    else if (prop.isQuaternionProperty()) {
+      sgProp->tie(FGQuaternionPropertyAdapter(prop.toQuaternionProperty(), 1));
+      sgProp = base->getChild(pName.c_str(), 1, true);
+      sgProp->tie(FGQuaternionPropertyAdapter(prop.toQuaternionProperty(), 2));
+      sgProp = base->getChild(pName.c_str(), 2, true);
+      sgProp->tie(FGQuaternionPropertyAdapter(prop.toQuaternionProperty(), 3));
+      sgProp = base->getChild(pName.c_str(), 3, true);
+      sgProp->tie(FGQuaternionPropertyAdapter(prop.toQuaternionProperty(), 4));
+    }
+    else if (prop.isVector6Property()) {
+      sgProp->tie(FGVector6PropertyAdapter(prop.toVector6Property(), 1));
+      sgProp = base->getChild(pName.c_str(), 1, true);
+      sgProp->tie(FGVector6PropertyAdapter(prop.toVector6Property(), 2));
+      sgProp = base->getChild(pName.c_str(), 2, true);
+      sgProp->tie(FGVector6PropertyAdapter(prop.toVector6Property(), 3));
+      sgProp = base->getChild(pName.c_str(), 3, true);
+      sgProp->tie(FGVector6PropertyAdapter(prop.toVector6Property(), 4));
+      sgProp = base->getChild(pName.c_str(), 4, true);
+      sgProp->tie(FGVector6PropertyAdapter(prop.toVector6Property(), 5));
+      sgProp = base->getChild(pName.c_str(), 5, true);
+      sgProp->tie(FGVector6PropertyAdapter(prop.toVector6Property(), 6));
+    }
+    else
+      sgProp->tie(FGVariantPropertyAdapter(prop));
+    ++it;
+  }
+}
+
+void
+FGOpenFDM::tieModelGroup(SGPropertyNode* base, ModelGroup* modelGroup)
+{
+  unsigned numModels = modelGroup->getNumModels();
+  for (unsigned i = 0; i < numModels; ++i) {
+    Model* model = modelGroup->getModel(i);
+    std::string pName = toPropname(model->getName());
+    SGPropertyNode* sgProp = base->getNode(pName.c_str(), true);
+    tieObject(sgProp, model);
+
+    ModelGroup* nestedGroup = model->toModelGroup();
+    if (nestedGroup) {
+      tieModelGroup(sgProp, nestedGroup);
+    }
+  }
+}
+
+void
+FGOpenFDM::untieRecursive(SGPropertyNode* base)
+{
+  // Unties and removes a whole tree.
+  // Sadly, it is not possible to remove the properties, so following models
+  // will see the properties even if they are no longer usefull.
+  int nChildren = base->nChildren();
+  for (int i = nChildren-1; 0 <= i; --i) {
+    SGPropertyNode* child = base->getChild(i);
+    if (!child)
+      continue;
+
+    child->clearValue();
+    untieRecursive(child);
+  }
+}
+
+void
+FGOpenFDM::untieNamed(SGPropertyNode* base, const char* name)
+{
+  int sz = base->getChildren(name).size();
+  for (int j = sz - 1; 0 <= j; --j) {
+    SGPropertyNode* tmpChild = base->getChild(name, j);
+    if (!tmpChild)
+      continue;
+    untieRecursive(tmpChild);
+    tmpChild->clearValue();
+  }
+}
+
+std::string
+FGOpenFDM::toPropname(const std::string& name)
+{
+  std::string pName = name;
+  std::string::size_type pos;
+  while ((pos = pName.find(' ')) != std::string::npos) {
+    pName.replace(pos, 1, 1, '_');
+  }
+  while ((pos = pName.find('<')) != std::string::npos) {
+    pName.replace(pos, 1, 1, '[');
+  }
+  while ((pos = pName.find('>')) != std::string::npos) {
+    pName.replace(pos, 1, 1, ']');
+  }
+  return pName;
+}
+
+} // namespace OpenFDM


Property changes on: trunk/flightgear/FGOpenFDM.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/flightgear/FGOpenFDM.h
===================================================================
--- trunk/flightgear/FGOpenFDM.h	2005-10-05 14:10:06 UTC (rev 6)
+++ trunk/flightgear/FGOpenFDM.h	2005-10-05 14:11:12 UTC (rev 7)
@@ -0,0 +1,51 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
+ *
+ */
+
+#ifndef FGOpenFDM_H
+#define FGOpenFDM_H
+
+#include <FDM/flight.hxx>
+
+namespace OpenFDM {
+
+struct FGOpenFDMData;
+class Object;
+class ModelGroup;
+
+///
+/// Interface to an OpenFDM flightmodel.
+///
+class FGOpenFDM
+  : public FGInterface {
+public:
+  FGOpenFDM(SGPropertyNode* fdmRootNode = 0);
+  virtual ~FGOpenFDM(void);
+
+  /// Initializes the fdm
+  virtual void init();
+
+  /// Connects the fdm with the flightgear property tree
+  virtual void bind();
+
+  /// Disconnects the fdm from the flightgear property tree
+  virtual void unbind();
+  
+  /// Advances the FDM by dt seconds
+  virtual void update(double dt);
+
+private:
+  void tieObject(SGPropertyNode* base, Object* object);
+  void tieModelGroup(SGPropertyNode* base, ModelGroup* modelGroup);
+  static void untieNamed(SGPropertyNode* base, const char* name);
+  static void untieRecursive(SGPropertyNode* base);
+
+  static std::string toPropname(const std::string& name);
+
+  FGOpenFDMData* mData;
+  SGPropertyNode_ptr mAircraftRootNode;
+};
+
+} // namespace OpenFDM
+
+#endif


Property changes on: trunk/flightgear/FGOpenFDM.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/flightgear/FGPropertyAdapter.h
===================================================================
--- trunk/flightgear/FGPropertyAdapter.h	2005-10-05 14:10:06 UTC (rev 6)
+++ trunk/flightgear/FGPropertyAdapter.h	2005-10-05 14:11:12 UTC (rev 7)
@@ -0,0 +1,336 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
+ *
+ */
+
+#ifndef FGPropertyAdapter_H
+#define FGPropertyAdapter_H
+
+#include <string>
+#include <simgear/props/props.hxx>
+#include <OpenFDM/Property.h>
+#include <OpenFDM/Model.h>
+
+namespace OpenFDM {
+
+class FGStringPropertyAdapter :
+    public SGRawValue<const char*> {
+public:
+  FGStringPropertyAdapter(const StringProperty& stringProperty) :
+    mStringProperty(stringProperty)
+  {}
+  virtual ~FGStringPropertyAdapter(void) {}
+
+  /// Implements the SimGear property interface.
+  virtual bool setValue(const char* value)
+  { return false; }
+  /// Implements the SimGear property interface.
+  virtual const char* getValue(void) const
+  { mValue = mStringProperty.getValue(); return mValue.c_str(); }
+  
+  virtual FGStringPropertyAdapter* clone(void) const
+  { return new FGStringPropertyAdapter(*this); }
+
+private:
+  mutable std::string mValue;
+  mutable StringProperty mStringProperty; /*FIXME*/
+};
+
+class FGRealPropertyAdapter :
+    public SGRawValue<double> {
+public:
+  FGRealPropertyAdapter(const RealProperty& realProperty) :
+    mRealProperty(realProperty)
+  { }
+  virtual ~FGRealPropertyAdapter(void) {}
+
+  /// Implements the SimGear property interface.
+  virtual bool setValue(double value)
+  { mRealProperty.setValue(value); return mRealProperty.isValid(); }
+  /// Implements the SimGear property interface.
+  virtual double getValue(void) const
+  { return mRealProperty.getValue(); }
+  
+  virtual FGRealPropertyAdapter* clone(void) const
+  { return new FGRealPropertyAdapter(*this); }
+
+private:
+  mutable RealProperty mRealProperty; /*FIXME*/
+};
+
+class FGIntPropertyAdapter :
+    public SGRawValue<int> {
+public:
+  FGIntPropertyAdapter(const IntegerProperty& intProperty) :
+    mIntProperty(intProperty)
+  { }
+  virtual ~FGIntPropertyAdapter(void) {}
+
+  /// Implements the SimGear property interface.
+  virtual bool setValue(int value)
+  { mIntProperty.setValue(value); return mIntProperty.isValid(); }
+  /// Implements the SimGear property interface.
+  virtual int getValue(void) const
+  { return mIntProperty.getValue(); }
+  
+  virtual FGIntPropertyAdapter* clone(void) const
+  { return new FGIntPropertyAdapter(*this); }
+
+private:
+  mutable IntegerProperty mIntProperty; /*FIXME*/
+};
+
+class FGUnsignedPropertyAdapter :
+    public SGRawValue<int> {
+public:
+  FGUnsignedPropertyAdapter(const UnsignedProperty& unsignedProperty) :
+    mUnsignedProperty(unsignedProperty)
+  { }
+  virtual ~FGUnsignedPropertyAdapter(void) {}
+
+  /// Implements the SimGear property interface.
+  virtual bool setValue(int value)
+  { if (value < 0) return false; mUnsignedProperty.setValue(value); return mUnsignedProperty.isValid(); }
+  /// Implements the SimGear property interface.
+  virtual int getValue(void) const
+  { return mUnsignedProperty.getValue(); }
+  
+  virtual FGUnsignedPropertyAdapter* clone(void) const
+  { return new FGUnsignedPropertyAdapter(*this); }
+
+private:
+  mutable UnsignedProperty mUnsignedProperty; /*FIXME*/
+};
+
+class FGVector2PropertyAdapter :
+    public SGRawValue<double> {
+public:
+  FGVector2PropertyAdapter(const Vector2Property& property, unsigned idx) :
+    mProperty(property), mIndex(idx)
+  { if (mIndex < 1 || 2 < mIndex) mIndex = 1; }
+  virtual ~FGVector2PropertyAdapter(void) {}
+
+  /// Implements the SimGear property interface.
+  virtual bool setValue(double value)
+  { Vector2 tmp = mProperty.getValue(); tmp(mIndex) = value; mProperty.setValue(tmp); return mProperty.isValid(); }
+  /// Implements the SimGear property interface.
+  virtual double getValue(void) const
+  { Vector2 value = mProperty.getValue(); return value(mIndex); }
+  
+  virtual FGVector2PropertyAdapter* clone(void) const
+  { return new FGVector2PropertyAdapter(*this); }
+
+private:
+  mutable Vector2Property mProperty; /*FIXME*/
+  unsigned mIndex;
+};
+
+class FGVector3PropertyAdapter :
+    public SGRawValue<double> {
+public:
+  FGVector3PropertyAdapter(const Vector3Property& property, unsigned idx) :
+    mProperty(property), mIndex(idx)
+  { if (mIndex < 1 || 3 < mIndex) mIndex = 1; }
+  virtual ~FGVector3PropertyAdapter(void) {}
+
+  /// Implements the SimGear property interface.
+  virtual bool setValue(double value)
+  { Vector3 tmp = mProperty.getValue(); tmp(mIndex) = value; mProperty.setValue(tmp); return mProperty.isValid(); }
+  /// Implements the SimGear property interface.
+  virtual double getValue(void) const
+  { Vector3 value = mProperty.getValue(); return value(mIndex); }
+  
+  virtual FGVector3PropertyAdapter* clone(void) const
+  { return new FGVector3PropertyAdapter(*this); }
+
+private:
+  mutable Vector3Property mProperty; /*FIXME*/
+  unsigned mIndex;
+};
+
+class FGQuaternionPropertyAdapter :
+    public SGRawValue<double> {
+public:
+  FGQuaternionPropertyAdapter(const QuaternionProperty& property, unsigned idx) :
+    mProperty(property), mIndex(idx)
+  { if (mIndex < 1 || 4 < mIndex) mIndex = 1; }
+  virtual ~FGQuaternionPropertyAdapter(void) {}
+
+  /// Implements the SimGear property interface.
+  virtual bool setValue(double value)
+  { Quaternion tmp = mProperty.getValue(); tmp(mIndex) = value; mProperty.setValue(tmp); return mProperty.isValid(); }
+  /// Implements the SimGear property interface.
+  virtual double getValue(void) const
+  { Quaternion value = mProperty.getValue(); return value(mIndex); }
+  
+  virtual FGQuaternionPropertyAdapter* clone(void) const
+  { return new FGQuaternionPropertyAdapter(*this); }
+
+private:
+  mutable QuaternionProperty mProperty; /*FIXME*/
+  unsigned mIndex;
+};
+
+class FGVector6PropertyAdapter :
+    public SGRawValue<double> {
+public:
+  FGVector6PropertyAdapter(const Vector6Property& property, unsigned idx) :
+    mProperty(property), mIndex(idx)
+  { if (mIndex < 1 || 6 < mIndex) mIndex = 1; }
+  virtual ~FGVector6PropertyAdapter(void) {}
+
+  /// Implements the SimGear property interface.
+  virtual bool setValue(double value)
+  { Vector6 tmp = mProperty.getValue(); tmp(mIndex) = value; mProperty.setValue(tmp); return mProperty.isValid(); }
+  /// Implements the SimGear property interface.
+  virtual double getValue(void) const
+  { Vector6 value = mProperty.getValue(); return value(mIndex); }
+  
+  virtual FGVector6PropertyAdapter* clone(void) const
+  { return new FGVector6PropertyAdapter(*this); }
+
+private:
+  mutable Vector6Property mProperty; /*FIXME*/
+  unsigned mIndex;
+};
+
+class FGVariantPropertyAdapter :
+    public SGRawValue<double> {
+public:
+  FGVariantPropertyAdapter(const Property& property) :
+    mProperty(property)
+  { }
+  virtual ~FGVariantPropertyAdapter(void) {}
+
+  /// Implements the SimGear property interface.
+  virtual bool setValue(double value)
+  { mProperty.setValue(Variant(value)); return mProperty.isValid(); }
+  /// Implements the SimGear property interface.
+  virtual double getValue(void) const
+  { return mProperty.getValue().toReal(); }
+  
+  virtual FGVariantPropertyAdapter* clone(void) const
+  { return new FGVariantPropertyAdapter(*this); }
+
+private:
+  mutable Property mProperty; /*FIXME*/
+};
+
+class FGRealInputModel :
+    public Model {
+public:
+  FGRealInputModel(const std::string& name, SGPropertyNode* propertyNode) :
+    Model(name),
+    mPropertyNode(propertyNode)
+  {
+    setDirectFeedThrough(false);
+  
+//   setNumInputPorts(1);
+//   setInputPortName(0, "input");
+  
+    setNumOutputPorts(1);
+    setOutputPort(0, "value", Property(this, &FGRealInputModel::getValue));
+  }
+  virtual ~FGRealInputModel(void)
+  {
+  }
+
+  void setPropertyNode(SGPropertyNode* propertyNode)
+  { mPropertyNode = propertyNode; }
+  SGPropertyNode* getPropertyNode(void)
+  { return mPropertyNode.ptr(); }
+
+  real_type getValue(void) const
+  {
+    if (mPropertyNode.valid())
+      return mPropertyNode->getDoubleValue();
+    else
+      return 0;
+  }
+private:
+  SGPropertyNode_ptr mPropertyNode;
+};
+
+class FGRealOutputModel :
+    public Model {
+public:
+  FGRealOutputModel(const std::string& name, SGPropertyNode* propertyNode) :
+    Model(name),
+    mPropertyNode(propertyNode)
+  {
+    setDirectFeedThrough(false);
+  
+    setNumInputPorts(1);
+    setInputPortName(0, "input");
+  }
+  virtual ~FGRealOutputModel(void)
+  { }
+
+  void setPropertyNode(SGPropertyNode* propertyNode)
+  { mPropertyNode = propertyNode; }
+  SGPropertyNode* getPropertyNode(void)
+  { return mPropertyNode.ptr(); }
+
+  virtual bool init(void)
+  {
+    OpenFDMAssert(getInputPort(0).isValid());
+    return getInputPort(0).isValid();
+  }
+
+  virtual void output(void)
+  {
+    OpenFDMAssert(getInputPort(0).isValid());
+    if (mPropertyNode.valid())
+      mPropertyNode->setDoubleValue(getInputPort(0).getValue().toReal());
+  }
+
+private:
+  SGPropertyNode_ptr mPropertyNode;
+};
+
+// This one is used to write changes to input properties into their input
+// models
+class InputChangeListener : public SGPropertyChangeListener {
+public:
+  InputChangeListener(Input* inputModel) : mInputModel(inputModel) {}
+  virtual ~InputChangeListener(void) {}
+  virtual void valueChanged(SGPropertyNode * node)
+  {
+    // Just to be sure
+    if (!node)
+      return;
+    // Check if it is still valid
+    if (!mInputModel)
+      return;
+    // Set the input from the nodes's value.
+    mInputModel->setInputValue(node->getDoubleValue());
+  }
+private:
+  // Holds the input model where it should write the value
+  // Note that this shal not be a shared_ptr, since we get a recursive
+  // ref count loop in that case.
+  managed_ptr<Input> mInputModel;
+};
+
+// That class just takes care that the listeners to a specific Input are
+// cleaned up past the input is deleted.
+class InputChangeUserData : public Object {
+public:
+  InputChangeUserData(Input* inputModel, SGPropertyNode* node) :
+    mListener(new InputChangeListener(inputModel))
+  {
+    node->addChangeListener(mListener);
+    // Don't forget to set the initial value
+    mListener->valueChanged(node);
+  }
+  virtual ~InputChangeUserData(void)
+  {
+    // Also deregisters itself at the SGPropertyNode.
+    delete mListener;
+  }
+private:
+  InputChangeListener* mListener;
+};
+
+} // namespace OpenFDM
+
+#endif


Property changes on: trunk/flightgear/FGPropertyAdapter.h
___________________________________________________________________
Name: svn:eol-style
   + native



From frohlich at berlios.de  Wed Oct  5 16:21:08 2005
From: frohlich at berlios.de (Mathias Froehlich at BerliOS)
Date: Wed, 5 Oct 2005 16:21:08 +0200
Subject: [Openfdm-svn] r8 - trunk/flightgear
Message-ID: <200510051421.j95EL8DX028569@sheep.berlios.de>

Author: frohlich
Date: 2005-10-05 16:21:08 +0200 (Wed, 05 Oct 2005)
New Revision: 8

Added:
   trunk/flightgear/Makefile.am
Log:
Move Makefile.am into the fg interface directory.


Added: trunk/flightgear/Makefile.am
===================================================================
--- trunk/flightgear/Makefile.am	2005-10-05 14:11:12 UTC (rev 7)
+++ trunk/flightgear/Makefile.am	2005-10-05 14:21:08 UTC (rev 8)
@@ -0,0 +1,3 @@
+INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/src
+noinst_LIBRARIES = libFGOpenFDM.a
+libFGOpenFDM_a_SOURCES = FGOpenFDM.cpp FGOpenFDM.h


Property changes on: trunk/flightgear/Makefile.am
___________________________________________________________________
Name: svn:eol-style
   + native



From frohlich at berlios.de  Wed Oct  5 17:24:58 2005
From: frohlich at berlios.de (Mathias Froehlich at BerliOS)
Date: Wed, 5 Oct 2005 17:24:58 +0200
Subject: [Openfdm-svn] r9 - trunk/flightgear
Message-ID: <200510051524.j95FOw2I001284@sheep.berlios.de>

Author: frohlich
Date: 2005-10-05 17:24:57 +0200 (Wed, 05 Oct 2005)
New Revision: 9

Added:
   trunk/flightgear/README
   trunk/flightgear/flightgear.diff
Log:
Add flightgear patch and minimal build instructions.


Added: trunk/flightgear/README
===================================================================
--- trunk/flightgear/README	2005-10-05 14:21:08 UTC (rev 8)
+++ trunk/flightgear/README	2005-10-05 15:24:57 UTC (rev 9)
@@ -0,0 +1,21 @@
+This directory contains the files required to integrate OpenFDM
+into flightgear.
+
+To do this, build and install the OpenFDM package into the same
+prefix than SimGear is built into.
+
+Create a new directory in flightgears source directory:
+  source/src/FDM/OpenFDM
+
+Then copy the files from this directory into the newly created
+one.
+
+Apply the patch 'flightgear.diff' to the source directory. This
+one will integrate this new directory into the build system and
+it will call the initialization routines if we find a OpenFDM
+aircraft.
+
+Reconfigure and rebuild flightgear.
+
+Have fun.
+

Added: trunk/flightgear/flightgear.diff
===================================================================
--- trunk/flightgear/flightgear.diff	2005-10-05 14:21:08 UTC (rev 8)
+++ trunk/flightgear/flightgear.diff	2005-10-05 15:24:57 UTC (rev 9)
@@ -0,0 +1,129 @@
+Index: configure.ac
+===================================================================
+RCS file: /var/cvs/FlightGear-0.9/source/configure.ac,v
+retrieving revision 1.96
+diff -u -r1.96 configure.ac
+--- configure.ac	24 Sep 2005 12:31:41 -0000	1.96
++++ configure.ac	5 Oct 2005 15:17:44 -0000
+@@ -444,6 +444,14 @@
+ fi
+ AM_CONDITIONAL(ENABLE_JPEG_SERVER, test "x$ac_cv_header_simgear_screen_jpgfactory_hxx" = "xyes")
+ 
++dnl Check for installed OpenFDM
++AC_CHECK_HEADER(OpenFDM/OpenFDMConfig.h)
++AM_CONDITIONAL(ENABLE_OpenFDM_FDM, \
++               [ test "x$ac_cv_header_OpenFDM_OpenFDMConfig_h" = "xyes" ] )
++if test "x$ac_cv_header_OpenFDM_OpenFDMConfig_h" = "xyes" ; then
++    AC_DEFINE([FG_ENABLE_OPENFDM_FDM], 1, [Define for no logging output])
++fi
++
+ AC_LANG_POP
+ 
+ dnl Check for system installed zlib
+@@ -519,6 +527,7 @@
+ 	src/FDM/JSBSim/Makefile \
+ 	src/FDM/JSBSim/filtersjb/Makefile \
+ 	src/FDM/LaRCsim/Makefile \
++	src/FDM/OpenFDM/Makefile \
+ 	src/FDM/SP/Makefile \
+ 	src/FDM/UIUCModel/Makefile \
+ 	src/FDM/YASim/Makefile \
+Index: src/FDM/Makefile.am
+===================================================================
+RCS file: /var/cvs/FlightGear-0.9/source/src/FDM/Makefile.am,v
+retrieving revision 1.7
+diff -u -r1.7 Makefile.am
+--- src/FDM/Makefile.am	22 Nov 2004 10:10:33 -0000	1.7
++++ src/FDM/Makefile.am	5 Oct 2005 15:17:44 -0000
+@@ -4,8 +4,14 @@
+ SP_DIR =
+ endif
+ 
++if ENABLE_OpenFDM_FDM
++OpenFDM_DIR = OpenFDM
++else
++OpenFDM_DIR =
++endif
++
+ SUBDIRS	= Balloon JSBSim LaRCsim UIUCModel YASim \
+-          $(SP_DIR) ExternalNet ExternalPipe
++          $(SP_DIR) $(OpenFDM_DIR) ExternalNet ExternalPipe
+ 
+ noinst_LIBRARIES = libFlight.a
+ 
+Index: src/FDM/flight.hxx
+===================================================================
+RCS file: /var/cvs/FlightGear-0.9/source/src/FDM/flight.hxx,v
+retrieving revision 1.9
+diff -u -r1.9 flight.hxx
+--- src/FDM/flight.hxx	3 Jul 2005 09:39:14 -0000	1.9
++++ src/FDM/flight.hxx	5 Oct 2005 15:17:45 -0000
+@@ -433,7 +433,10 @@
+ 	FG_PARACHUTE = 9,
+ 
+ 	// Driven externally via a serial port, net, file, etc.
+-	FG_EXTERNAL = 10
++	FG_EXTERNAL = 10,
++
++	// OpenFDM. Reads JSBSim legacy and new files.
++	FG_OPENFDM = 11
+     };
+ 
+     // initialization
+Index: src/Main/Makefile.am
+===================================================================
+RCS file: /var/cvs/FlightGear-0.9/source/src/Main/Makefile.am,v
+retrieving revision 1.54
+diff -u -r1.54 Makefile.am
+--- src/Main/Makefile.am	25 Jun 2005 11:21:18 -0000	1.54
++++ src/Main/Makefile.am	5 Oct 2005 15:17:45 -0000
+@@ -13,6 +13,13 @@
+ SP_FDM_LIBS = 
+ endif
+ 
++if ENABLE_OpenFDM_FDM
++OpenFDM_LIBS = $(top_builddir)/src/FDM/OpenFDM/libFGOpenFDM.a \
++               -lJSBReader -lOpenFDM
++else
++OpenFDM_LIBS = 
++endif
++
+ if WITH_THREADS
+ THREAD_LIBS = -lsgthreads $(thread_LIBS)
+ else
+@@ -70,6 +77,7 @@
+ 	$(top_builddir)/src/FDM/LaRCsim/libLaRCsim.a \
+ 	$(top_builddir)/src/FDM/UIUCModel/libUIUCModel.a \
+ 	$(SP_FDM_LIBS) \
++	$(OpenFDM_LIBS) \
+ 	$(top_builddir)/src/GUI/libGUI.a \
+ 	$(top_builddir)/src/Autopilot/libAutopilot.a \
+ 	$(top_builddir)/src/Input/libInput.a \
+Index: src/Main/fg_init.cxx
+===================================================================
+RCS file: /var/cvs/FlightGear-0.9/source/src/Main/fg_init.cxx,v
+retrieving revision 1.131
+diff -u -r1.131 fg_init.cxx
+--- src/Main/fg_init.cxx	4 Oct 2005 20:36:38 -0000	1.131
++++ src/Main/fg_init.cxx	5 Oct 2005 15:17:46 -0000
+@@ -91,6 +91,9 @@
+ #include <FDM/UFO.hxx>
+ #include <FDM/NullFDM.hxx>
+ #include <FDM/YASim/YASim.hxx>
++#ifdef FG_ENABLE_OPENFDM_FDM
++#include <FDM/OpenFDM/FGOpenFDM.h>
++#endif
+ #include <GUI/new_gui.hxx>
+ #include <Include/general.hxx>
+ #include <Input/input.hxx>
+@@ -1382,6 +1385,10 @@
+             cur_fdm_state = new FGNullFDM( dt );
+         } else if ( model == "yasim" ) {
+             cur_fdm_state = new YASim( dt );
++#ifdef FG_ENABLE_OPENFDM_FDM
++        } else if ( model == "openfdm" ) {
++            cur_fdm_state = new OpenFDM::FGOpenFDM();
++#endif
+         } else {
+             SG_LOG(SG_GENERAL, SG_ALERT,
+                    "Unrecognized flight model '" << model



From frohlich at berlios.de  Wed Oct  5 19:53:03 2005
From: frohlich at berlios.de (Mathias Froehlich at BerliOS)
Date: Wed, 5 Oct 2005 19:53:03 +0200
Subject: [Openfdm-svn] r10 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200510051753.j95Hr36v030332@sheep.berlios.de>

Author: frohlich
Date: 2005-10-05 19:52:49 +0200 (Wed, 05 Oct 2005)
New Revision: 10

Modified:
   trunk/OpenFDM/src/OpenFDM/Object.cpp
   trunk/OpenFDM/src/OpenFDM/Object.h
   trunk/OpenFDM/src/OpenFDM/Variant.h
   trunk/OpenFDM/src/OpenFDM/main.cpp
Log:
Provide direct property get/set method to an Object.


Modified: trunk/OpenFDM/src/OpenFDM/Object.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Object.cpp	2005-10-05 15:24:57 UTC (rev 9)
+++ trunk/OpenFDM/src/OpenFDM/Object.cpp	2005-10-05 17:52:49 UTC (rev 10)
@@ -42,7 +42,28 @@
   return nameList;
 }
 
+Variant
+Object::getPropertyValue(const std::string& name) const
+{
+  // Just use the current property system for now
+
+  // Return an empty variant if this property does not exist.
+  if (mProperties.count(name) <= 0)
+    return Variant();
+
+  // Return the value of the property
+  // FIXME: properties, like they are now, do not preserve constness
+  return ((Property&)(mProperties.find(name)->second)).getValue();
+}
+
 void
+Object::setPropertyValue(const std::string& name, const Variant& value)
+{
+  // Just use the current property system for now
+  getProperty(name).setValue(value);
+}
+
+void
 Object::addProperty(const std::string& name, const Property& property)
 {
   mProperties[name] = property;

Modified: trunk/OpenFDM/src/OpenFDM/Object.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Object.h	2005-10-05 15:24:57 UTC (rev 9)
+++ trunk/OpenFDM/src/OpenFDM/Object.h	2005-10-05 17:52:49 UTC (rev 10)
@@ -8,6 +8,7 @@
 #include <list>
 #include <map>
 #include "Referenced.h"
+#include "Variant.h"
 #include "Property.h"
 
 namespace OpenFDM {
@@ -25,10 +26,18 @@
   Property getProperty(const std::string& name);
   std::list<std::string> listProperties(void) const;
 
+  /// Returns the objects property named name
+  Variant getPropertyValue(const std::string& name) const;
+  /// Set an objects property named name to the given value
+  void setPropertyValue(const std::string& name, const Variant& value);
+
+  /// Returns the objects attached user data
   Object* getUserData(void)
   { return mUserData; }
+  /// Returns the objects attached const user data
   const Object* getUserData(void) const
   { return mUserData; }
+  /// Sets the objects user data
   void setUserData(Object* userData)
   { mUserData = userData; }
 

Modified: trunk/OpenFDM/src/OpenFDM/Variant.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Variant.h	2005-10-05 15:24:57 UTC (rev 9)
+++ trunk/OpenFDM/src/OpenFDM/Variant.h	2005-10-05 17:52:49 UTC (rev 10)
@@ -10,7 +10,6 @@
 #include "Types.h"
 #include "Referenced.h"
 #include "RefPtr.h"
-#include "Vector.h"
 #include "Matrix.h"
 
 namespace OpenFDM {
@@ -47,13 +46,14 @@
     mData(new StringVariantData(value))
   {}
 
-  // FIXME we need some kind of struct
-  
   /// Assignment operator
   /// Variant follows the copy on copy sematics, that is in this operator
   /// the contents of the Variant is copied.
   inline Variant& operator=(const Variant& value);
 
+  /// Returns true if the variant contains some value
+  inline bool isValid(void) const;
+
   /// Returns true if the variant can be converted to the given type.
   inline bool isString(void) const;
   inline bool isReal(void) const;
@@ -142,6 +142,12 @@
 }
 
 inline bool
+Variant::isValid(void) const
+{
+  return mData;
+}
+
+inline bool
 Variant::isString() const
 {
   return mData && mData->toStringVariant();

Modified: trunk/OpenFDM/src/OpenFDM/main.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/main.cpp	2005-10-05 15:24:57 UTC (rev 9)
+++ trunk/OpenFDM/src/OpenFDM/main.cpp	2005-10-05 17:52:49 UTC (rev 10)
@@ -279,28 +279,15 @@
 
       const XMLElement* propElement = element->getElement(*it);
       if (propElement) {
-        Property prop = object->getProperty(*it);
+        if (1 != propElement->getNumElements("matrix"))
+          return error("InitialValue tag found without content!");
 
-        if (prop.isMatrixProperty()) {
-          if (1 != propElement->getNumElements("matrix"))
-            return error("InitialValue tag found without content!");
+        Matrix m;
+        if (!readMatrix(propElement->getElement("matrix"), m))
+          return error("Cannot read InitialValue Matrix!");
 
-          Matrix m;
-          if (!readMatrix(propElement->getElement("matrix"), m))
-            return error("Cannot read InitialValue Matrix!");
+        object->setPropertyValue(*it, Variant(m));
 
-          prop.setValue(m);
-        } else if (prop.isRealProperty()) {
-          if (1 != propElement->getNumElements("matrix"))
-            return error("InitialValue tag found without content!");
-
-          Matrix m;
-          if (!readMatrix(propElement->getElement("matrix"), m))
-            return error("Cannot read InitialValue Matrix!");
-
-          /// FIXME
-          prop.setValue(m(1, 1));
-        }
         // FIXME add more here
       }
       ++it;
@@ -695,9 +682,6 @@
   }
 #endif
 
-//   Property prop = vehicle->getProperty("cartPosition");
-//   cout << prop.getValue().toMatrix() << std::endl;
-
   return 0;
 }
 



From frohlich at berlios.de  Thu Oct  6 12:12:46 2005
From: frohlich at berlios.de (Mathias Froehlich at BerliOS)
Date: Thu, 6 Oct 2005 12:12:46 +0200
Subject: [Openfdm-svn] r11 - trunk/flightgear
Message-ID: <200510061012.j96ACkHZ015781@sheep.berlios.de>

Author: frohlich
Date: 2005-10-06 12:12:46 +0200 (Thu, 06 Oct 2005)
New Revision: 11

Modified:
   trunk/flightgear/FGOpenFDM.cpp
   trunk/flightgear/FGPropertyAdapter.h
Log:
Use the get/setPropertyValue calls.


Modified: trunk/flightgear/FGOpenFDM.cpp
===================================================================
--- trunk/flightgear/FGOpenFDM.cpp	2005-10-05 17:52:49 UTC (rev 10)
+++ trunk/flightgear/FGOpenFDM.cpp	2005-10-06 10:12:46 UTC (rev 11)
@@ -219,7 +219,8 @@
 
   FGInterface::bind();
 
-  SGPropertyNode* sgProp = mAircraftRootNode->getChild("fdm/vehicle", 0, true);
+  SGPropertyNode* sgProp = mAircraftRootNode->getChild("fdm", 0, true);
+  sgProp = sgProp->getChild("vehicle", 0, true);
   sgProp = sgProp->getChild("system", 0, true);
   tieModelGroup(sgProp, mData->vehicle->getSystem());
 }
@@ -341,8 +342,7 @@
   if (outputModel) {
     std::string pName = outputModel->getOutputName();
     SGPropertyNode* sgProp = mAircraftRootNode->getNode(pName.c_str(), true);
-    Property prop = object->getProperty("value");
-    sgProp->tie(FGRealPropertyAdapter(prop.toRealProperty()));
+    sgProp->tie(FGRealPropertyAdapter(outputModel, "value"));
   }
 
   // Check for input models
@@ -366,51 +366,32 @@
     // ... well, FIXME cleanup ...
     std::string pName = toPropname(*it);
     SGPropertyNode* sgProp = base->getChild(pName.c_str(), 0, true);
-    Property prop = object->getProperty(*it);
-    if (prop.isStringProperty())
-      sgProp->tie(FGStringPropertyAdapter(prop.toStringProperty()));
-    else if (prop.isRealProperty())
-      sgProp->tie(FGRealPropertyAdapter(prop.toRealProperty()));
-    else if (prop.isIntegerProperty())
-      sgProp->tie(FGIntPropertyAdapter(prop.toIntegerProperty()));
-    else if (prop.isUnsignedProperty())
-      sgProp->tie(FGUnsignedPropertyAdapter(prop.toUnsignedProperty()));
-    else if (prop.isVector2Property()) {
-      sgProp->tie(FGVector2PropertyAdapter(prop.toVector2Property(), 1));
-      sgProp = base->getChild(pName.c_str(), 1, true);
-      sgProp->tie(FGVector2PropertyAdapter(prop.toVector2Property(), 2));
+    Variant value = object->getPropertyValue(*it);
+
+    if (value.isString())
+      sgProp->tie(FGStringPropertyAdapter(object, *it));
+    else if (value.isReal())
+      sgProp->tie(FGRealPropertyAdapter(object, *it));
+    else if (value.isInteger())
+      sgProp->tie(FGIntegerPropertyAdapter(object, *it));
+    else if (value.isUnsigned())
+      sgProp->tie(FGIntegerPropertyAdapter(object, *it));
+
+    else if (value.isMatrix()) {
+      Matrix m = value.toMatrix();
+      unsigned reshapeSize = rows(m) * cols(m);
+
+      sgProp->tie(FGRealPropertyAdapter(object, *it));
+      for (unsigned i = 2; i <= reshapeSize; ++i) {
+        sgProp = base->getChild(pName.c_str(), i-1, true);
+        sgProp->tie(FGRealPropertyAdapter(object, *it, i));
+      }
     }
-    else if (prop.isVector3Property()) {
-      sgProp->tie(FGVector3PropertyAdapter(prop.toVector3Property(), 1));
-      sgProp = base->getChild(pName.c_str(), 1, true);
-      sgProp->tie(FGVector3PropertyAdapter(prop.toVector3Property(), 2));
-      sgProp = base->getChild(pName.c_str(), 2, true);
-      sgProp->tie(FGVector3PropertyAdapter(prop.toVector3Property(), 3));
+    else if (value.isValid()) {
+      SG_LOG(SG_FLIGHT, SG_WARN,
+             "Found unexpected property type with property named \""
+             << *it << "\"");
     }
-    else if (prop.isQuaternionProperty()) {
-      sgProp->tie(FGQuaternionPropertyAdapter(prop.toQuaternionProperty(), 1));
-      sgProp = base->getChild(pName.c_str(), 1, true);
-      sgProp->tie(FGQuaternionPropertyAdapter(prop.toQuaternionProperty(), 2));
-      sgProp = base->getChild(pName.c_str(), 2, true);
-      sgProp->tie(FGQuaternionPropertyAdapter(prop.toQuaternionProperty(), 3));
-      sgProp = base->getChild(pName.c_str(), 3, true);
-      sgProp->tie(FGQuaternionPropertyAdapter(prop.toQuaternionProperty(), 4));
-    }
-    else if (prop.isVector6Property()) {
-      sgProp->tie(FGVector6PropertyAdapter(prop.toVector6Property(), 1));
-      sgProp = base->getChild(pName.c_str(), 1, true);
-      sgProp->tie(FGVector6PropertyAdapter(prop.toVector6Property(), 2));
-      sgProp = base->getChild(pName.c_str(), 2, true);
-      sgProp->tie(FGVector6PropertyAdapter(prop.toVector6Property(), 3));
-      sgProp = base->getChild(pName.c_str(), 3, true);
-      sgProp->tie(FGVector6PropertyAdapter(prop.toVector6Property(), 4));
-      sgProp = base->getChild(pName.c_str(), 4, true);
-      sgProp->tie(FGVector6PropertyAdapter(prop.toVector6Property(), 5));
-      sgProp = base->getChild(pName.c_str(), 5, true);
-      sgProp->tie(FGVector6PropertyAdapter(prop.toVector6Property(), 6));
-    }
-    else
-      sgProp->tie(FGVariantPropertyAdapter(prop));
     ++it;
   }
 }

Modified: trunk/flightgear/FGPropertyAdapter.h
===================================================================
--- trunk/flightgear/FGPropertyAdapter.h	2005-10-05 17:52:49 UTC (rev 10)
+++ trunk/flightgear/FGPropertyAdapter.h	2005-10-06 10:12:46 UTC (rev 11)
@@ -12,209 +12,126 @@
 
 namespace OpenFDM {
 
+template<typename T>
+class FGPropertyAdapter :
+    public SGRawValue<T> {
+public:
+  FGPropertyAdapter(Object* object, const std::string& propertyName) :
+    mObject(object), mPropertyName(propertyName)
+  {}
+
+protected:
+  Variant getPropertyValue(void) const
+  {
+    if (!mObject)
+      return Variant();
+
+    return mObject->getPropertyValue(mPropertyName);
+  }
+  bool setPropertyValue(const Variant& value)
+  {
+    if (!mObject)
+      return false;
+
+    // FIXME: check if settable ...
+    mObject->setPropertyValue(mPropertyName, value);
+    return true;
+  }
+
+private:
+  std::string mPropertyName;
+  managed_ptr<Object> mObject;
+};
+
+
 class FGStringPropertyAdapter :
-    public SGRawValue<const char*> {
+    public FGPropertyAdapter<const char*> {
 public:
-  FGStringPropertyAdapter(const StringProperty& stringProperty) :
-    mStringProperty(stringProperty)
+  FGStringPropertyAdapter(Object* object, const std::string& propertyName) :
+    FGPropertyAdapter<const char*>(object, propertyName)
   {}
   virtual ~FGStringPropertyAdapter(void) {}
 
   /// Implements the SimGear property interface.
   virtual bool setValue(const char* value)
-  { return false; }
+  { return setPropertyValue(Variant(std::string(value))); }
   /// Implements the SimGear property interface.
   virtual const char* getValue(void) const
-  { mValue = mStringProperty.getValue(); return mValue.c_str(); }
+  { mValue = getPropertyValue().toString(); return mValue.c_str(); }
   
   virtual FGStringPropertyAdapter* clone(void) const
   { return new FGStringPropertyAdapter(*this); }
 
 private:
   mutable std::string mValue;
-  mutable StringProperty mStringProperty; /*FIXME*/
 };
 
+
 class FGRealPropertyAdapter :
-    public SGRawValue<double> {
+    public FGPropertyAdapter<double> {
 public:
-  FGRealPropertyAdapter(const RealProperty& realProperty) :
-    mRealProperty(realProperty)
-  { }
+  FGRealPropertyAdapter(Object* object, const std::string& propertyName,
+                        unsigned index = 1) :
+    FGPropertyAdapter<double>(object, propertyName), mIndex(index)
+  {}
   virtual ~FGRealPropertyAdapter(void) {}
 
   /// Implements the SimGear property interface.
   virtual bool setValue(double value)
-  { mRealProperty.setValue(value); return mRealProperty.isValid(); }
+  {
+    Matrix m = getPropertyValue().toMatrix();
+    unsigned r = mIndex % rows(m);
+    unsigned c = mIndex / rows(m);
+    if (r < 1 || rows(m) < r)
+      return false;
+    if (c < 1 || cols(m) < c)
+      return false;
+    
+    m(r, c) = value;
+    return setPropertyValue(Variant(m));
+  }
   /// Implements the SimGear property interface.
   virtual double getValue(void) const
-  { return mRealProperty.getValue(); }
+  {
+    if (mIndex == 1)
+      return getPropertyValue().toReal();
+    else {
+      Matrix m = getPropertyValue().toMatrix();
+      unsigned r = mIndex % rows(m);
+      unsigned c = mIndex / rows(m);
+      if (r < 1 || rows(m) < r)
+        return 0;
+      if (c < 1 || cols(m) < c)
+        return 0;
+      return m(r, c);
+    }
+  }
   
   virtual FGRealPropertyAdapter* clone(void) const
   { return new FGRealPropertyAdapter(*this); }
-
 private:
-  mutable RealProperty mRealProperty; /*FIXME*/
+  unsigned mIndex;
 };
 
-class FGIntPropertyAdapter :
-    public SGRawValue<int> {
+class FGIntegerPropertyAdapter :
+    public FGPropertyAdapter<int> {
 public:
-  FGIntPropertyAdapter(const IntegerProperty& intProperty) :
-    mIntProperty(intProperty)
-  { }
-  virtual ~FGIntPropertyAdapter(void) {}
+  FGIntegerPropertyAdapter(Object* object, const std::string& propertyName) :
+    FGPropertyAdapter<int>(object, propertyName)
+  {}
+  virtual ~FGIntegerPropertyAdapter(void) {}
 
   /// Implements the SimGear property interface.
   virtual bool setValue(int value)
-  { mIntProperty.setValue(value); return mIntProperty.isValid(); }
+  { return setPropertyValue(Variant(value)); }
   /// Implements the SimGear property interface.
   virtual int getValue(void) const
-  { return mIntProperty.getValue(); }
-  
-  virtual FGIntPropertyAdapter* clone(void) const
-  { return new FGIntPropertyAdapter(*this); }
+  { return getPropertyValue().toInteger(); }
 
-private:
-  mutable IntegerProperty mIntProperty; /*FIXME*/
+  virtual FGIntegerPropertyAdapter* clone(void) const
+  { return new FGIntegerPropertyAdapter(*this); }
 };
 
-class FGUnsignedPropertyAdapter :
-    public SGRawValue<int> {
-public:
-  FGUnsignedPropertyAdapter(const UnsignedProperty& unsignedProperty) :
-    mUnsignedProperty(unsignedProperty)
-  { }
-  virtual ~FGUnsignedPropertyAdapter(void) {}
-
-  /// Implements the SimGear property interface.
-  virtual bool setValue(int value)
-  { if (value < 0) return false; mUnsignedProperty.setValue(value); return mUnsignedProperty.isValid(); }
-  /// Implements the SimGear property interface.
-  virtual int getValue(void) const
-  { return mUnsignedProperty.getValue(); }
-  
-  virtual FGUnsignedPropertyAdapter* clone(void) const
-  { return new FGUnsignedPropertyAdapter(*this); }
-
-private:
-  mutable UnsignedProperty mUnsignedProperty; /*FIXME*/
-};
-
-class FGVector2PropertyAdapter :
-    public SGRawValue<double> {
-public:
-  FGVector2PropertyAdapter(const Vector2Property& property, unsigned idx) :
-    mProperty(property), mIndex(idx)
-  { if (mIndex < 1 || 2 < mIndex) mIndex = 1; }
-  virtual ~FGVector2PropertyAdapter(void) {}
-
-  /// Implements the SimGear property interface.
-  virtual bool setValue(double value)
-  { Vector2 tmp = mProperty.getValue(); tmp(mIndex) = value; mProperty.setValue(tmp); return mProperty.isValid(); }
-  /// Implements the SimGear property interface.
-  virtual double getValue(void) const
-  { Vector2 value = mProperty.getValue(); return value(mIndex); }
-  
-  virtual FGVector2PropertyAdapter* clone(void) const
-  { return new FGVector2PropertyAdapter(*this); }
-
-private:
-  mutable Vector2Property mProperty; /*FIXME*/
-  unsigned mIndex;
-};
-
-class FGVector3PropertyAdapter :
-    public SGRawValue<double> {
-public:
-  FGVector3PropertyAdapter(const Vector3Property& property, unsigned idx) :
-    mProperty(property), mIndex(idx)
-  { if (mIndex < 1 || 3 < mIndex) mIndex = 1; }
-  virtual ~FGVector3PropertyAdapter(void) {}
-
-  /// Implements the SimGear property interface.
-  virtual bool setValue(double value)
-  { Vector3 tmp = mProperty.getValue(); tmp(mIndex) = value; mProperty.setValue(tmp); return mProperty.isValid(); }
-  /// Implements the SimGear property interface.
-  virtual double getValue(void) const
-  { Vector3 value = mProperty.getValue(); return value(mIndex); }
-  
-  virtual FGVector3PropertyAdapter* clone(void) const
-  { return new FGVector3PropertyAdapter(*this); }
-
-private:
-  mutable Vector3Property mProperty; /*FIXME*/
-  unsigned mIndex;
-};
-
-class FGQuaternionPropertyAdapter :
-    public SGRawValue<double> {
-public:
-  FGQuaternionPropertyAdapter(const QuaternionProperty& property, unsigned idx) :
-    mProperty(property), mIndex(idx)
-  { if (mIndex < 1 || 4 < mIndex) mIndex = 1; }
-  virtual ~FGQuaternionPropertyAdapter(void) {}
-
-  /// Implements the SimGear property interface.
-  virtual bool setValue(double value)
-  { Quaternion tmp = mProperty.getValue(); tmp(mIndex) = value; mProperty.setValue(tmp); return mProperty.isValid(); }
-  /// Implements the SimGear property interface.
-  virtual double getValue(void) const
-  { Quaternion value = mProperty.getValue(); return value(mIndex); }
-  
-  virtual FGQuaternionPropertyAdapter* clone(void) const
-  { return new FGQuaternionPropertyAdapter(*this); }
-
-private:
-  mutable QuaternionProperty mProperty; /*FIXME*/
-  unsigned mIndex;
-};
-
-class FGVector6PropertyAdapter :
-    public SGRawValue<double> {
-public:
-  FGVector6PropertyAdapter(const Vector6Property& property, unsigned idx) :
-    mProperty(property), mIndex(idx)
-  { if (mIndex < 1 || 6 < mIndex) mIndex = 1; }
-  virtual ~FGVector6PropertyAdapter(void) {}
-
-  /// Implements the SimGear property interface.
-  virtual bool setValue(double value)
-  { Vector6 tmp = mProperty.getValue(); tmp(mIndex) = value; mProperty.setValue(tmp); return mProperty.isValid(); }
-  /// Implements the SimGear property interface.
-  virtual double getValue(void) const
-  { Vector6 value = mProperty.getValue(); return value(mIndex); }
-  
-  virtual FGVector6PropertyAdapter* clone(void) const
-  { return new FGVector6PropertyAdapter(*this); }
-
-private:
-  mutable Vector6Property mProperty; /*FIXME*/
-  unsigned mIndex;
-};
-
-class FGVariantPropertyAdapter :
-    public SGRawValue<double> {
-public:
-  FGVariantPropertyAdapter(const Property& property) :
-    mProperty(property)
-  { }
-  virtual ~FGVariantPropertyAdapter(void) {}
-
-  /// Implements the SimGear property interface.
-  virtual bool setValue(double value)
-  { mProperty.setValue(Variant(value)); return mProperty.isValid(); }
-  /// Implements the SimGear property interface.
-  virtual double getValue(void) const
-  { return mProperty.getValue().toReal(); }
-  
-  virtual FGVariantPropertyAdapter* clone(void) const
-  { return new FGVariantPropertyAdapter(*this); }
-
-private:
-  mutable Property mProperty; /*FIXME*/
-};
-
 class FGRealInputModel :
     public Model {
 public:
@@ -224,9 +141,6 @@
   {
     setDirectFeedThrough(false);
   
-//   setNumInputPorts(1);
-//   setInputPortName(0, "input");
-  
     setNumOutputPorts(1);
     setOutputPort(0, "value", Property(this, &FGRealInputModel::getValue));
   }



From frohlich at berlios.de  Fri Oct  7 14:35:49 2005
From: frohlich at berlios.de (Mathias Froehlich at BerliOS)
Date: Fri, 7 Oct 2005 14:35:49 +0200
Subject: [Openfdm-svn] r12 - in trunk/OpenFDM/src: JSBSim OpenFDM
Message-ID: <200510071235.j97CZnvB003306@sheep.berlios.de>

Author: frohlich
Date: 2005-10-07 14:35:48 +0200 (Fri, 07 Oct 2005)
New Revision: 12

Added:
   trunk/OpenFDM/src/OpenFDM/DiscreteIntegrator.cpp
   trunk/OpenFDM/src/OpenFDM/DiscreteIntegrator.h
Modified:
   trunk/OpenFDM/src/JSBSim/JSBReader.cpp
   trunk/OpenFDM/src/OpenFDM/Integrator.cpp
   trunk/OpenFDM/src/OpenFDM/Integrator.h
   trunk/OpenFDM/src/OpenFDM/Makefile.am
   trunk/OpenFDM/src/OpenFDM/Model.cpp
   trunk/OpenFDM/src/OpenFDM/Model.h
   trunk/OpenFDM/src/OpenFDM/RootFrame.cpp
   trunk/OpenFDM/src/OpenFDM/main.cpp
Log:
Implement a continous integrator, move the discrete
integrator into its own file.


Modified: trunk/OpenFDM/src/JSBSim/JSBReader.cpp
===================================================================
--- trunk/OpenFDM/src/JSBSim/JSBReader.cpp	2005-10-06 10:12:46 UTC (rev 11)
+++ trunk/OpenFDM/src/JSBSim/JSBReader.cpp	2005-10-07 12:35:48 UTC (rev 12)
@@ -17,7 +17,7 @@
 #include <OpenFDM/ModelGroup.h>
 #include <OpenFDM/TimeDerivative.h>
 #include <OpenFDM/TransferFunction.h>
-#include <OpenFDM/Integrator.h>
+#include <OpenFDM/DiscreteIntegrator.h>
 #include <OpenFDM/Mass.h>
 #include <OpenFDM/Vehicle.h>
 #include <OpenFDM/Saturation.h>

Added: trunk/OpenFDM/src/OpenFDM/DiscreteIntegrator.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/DiscreteIntegrator.cpp	2005-10-06 10:12:46 UTC (rev 11)
+++ trunk/OpenFDM/src/OpenFDM/DiscreteIntegrator.cpp	2005-10-07 12:35:48 UTC (rev 12)
@@ -0,0 +1,106 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
+ *
+ */
+
+#include "Assert.h"
+#include "Types.h"
+#include "Object.h"
+#include "Expression.h"
+#include "DiscreteIntegrator.h"
+
+namespace OpenFDM {
+
+DiscreteIntegrator::DiscreteIntegrator(const std::string& name) :
+  Model(name)
+{
+  setNumInputPorts(1);
+  setInputPortName(0, "derivatirve");
+
+  setNumOutputPorts(1);
+  setOutputPort(0, "output", Property(this, &DiscreteIntegrator::getIntegralOutput));
+
+  addProperty("initialValue", Property(this, &DiscreteIntegrator::getInitialValue, &DiscreteIntegrator::setInitialValue));
+  addProperty("output", Property(this, &DiscreteIntegrator::getIntegralOutput));
+}
+
+DiscreteIntegrator::~DiscreteIntegrator(void)
+{
+}
+
+bool
+DiscreteIntegrator::init(void)
+{
+  OpenFDMAssert(getInputPort(0).isValid());
+
+  // The initial value defaults to zero
+  if (rows(mInitialValue) == 0 || cols(mInitialValue) == 0) {
+    mInitialValue.resize(getInputPort(0).getValue().toMatrix());
+    mInitialValue.clear();
+  }
+
+  setNumDiscreteStates(rows(mInitialValue)*cols(mInitialValue));
+
+  mIntegralState = mInitialValue;
+  mIntegralOutput = mIntegralState;
+  return true;
+}
+
+void
+DiscreteIntegrator::output(void)
+{
+  mIntegralOutput = mIntegralState;
+}
+
+void
+DiscreteIntegrator::update(real_type dt)
+{
+  OpenFDMAssert(getInputPort(0).isValid());
+
+  // Just compute the integral.
+  Matrix input = getInputPort(0).getValue().toMatrix();
+  OpenFDMAssert(size(input) == size(mIntegralState));
+  if (size(input) == size(mIntegralState))
+    mIntegralState += dt*input;
+}
+
+void
+DiscreteIntegrator::setDiscreteState(const Vector& state, unsigned offset)
+{
+  // FIXME reshape ...
+  for (unsigned j = 1; j <= cols(mIntegralState); ++j) {
+    for (unsigned i = 1; i <= rows(mIntegralState); ++i) {
+      mIntegralState(i, j) = state(offset + i + (j-1)*rows(mIntegralState));
+    }
+  }
+}
+
+void
+DiscreteIntegrator::getDiscreteState(Vector& state, unsigned offset) const
+{
+  // FIXME reshape ...
+  for (unsigned j = 1; j <= cols(mIntegralState); ++j) {
+    for (unsigned i = 1; i <= rows(mIntegralState); ++i) {
+      state(offset + i + (j-1)*rows(mIntegralState)) = mIntegralState(i, j);
+    }
+  }
+}
+
+const Matrix&
+DiscreteIntegrator::getInitialValue(void) const
+{
+  return mInitialValue;
+}
+
+void
+DiscreteIntegrator::setInitialValue(const Matrix& value)
+{
+  mInitialValue = value;
+}
+
+const Matrix&
+DiscreteIntegrator::getIntegralOutput(void) const
+{
+  return mIntegralOutput;
+}
+
+} // namespace OpenFDM


Property changes on: trunk/OpenFDM/src/OpenFDM/DiscreteIntegrator.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/OpenFDM/src/OpenFDM/DiscreteIntegrator.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/DiscreteIntegrator.h	2005-10-06 10:12:46 UTC (rev 11)
+++ trunk/OpenFDM/src/OpenFDM/DiscreteIntegrator.h	2005-10-07 12:35:48 UTC (rev 12)
@@ -0,0 +1,44 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_DiscreteIntegrator_H
+#define OpenFDM_DiscreteIntegrator_H
+
+#include "Assert.h"
+#include "Types.h"
+#include "Object.h"
+#include "Model.h"
+
+namespace OpenFDM {
+
+class DiscreteIntegrator :
+    public Model {
+public:
+  DiscreteIntegrator(const std::string& name);
+  virtual ~DiscreteIntegrator(void);
+
+  virtual bool init(void);
+  virtual void output(void);
+  virtual void update(real_type dt);
+
+  virtual void setDiscreteState(const Vector& state, unsigned offset);
+  virtual void getDiscreteState(Vector& state, unsigned offset) const;
+
+  const Matrix& getInitialValue(void) const;
+  void setInitialValue(const Matrix& value);
+
+  const Matrix& getIntegralOutput(void) const;
+
+private:
+  /// Holds the current output.
+  Matrix mIntegralOutput;
+  /// Holds the current integral state.
+  Matrix mIntegralState;
+  /// Holds the current integral initial state.
+  Matrix mInitialValue;
+};
+
+} // namespace OpenFDM
+
+#endif


Property changes on: trunk/OpenFDM/src/OpenFDM/DiscreteIntegrator.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/OpenFDM/src/OpenFDM/Integrator.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Integrator.cpp	2005-10-06 10:12:46 UTC (rev 11)
+++ trunk/OpenFDM/src/OpenFDM/Integrator.cpp	2005-10-07 12:35:48 UTC (rev 12)
@@ -10,66 +10,104 @@
 
 namespace OpenFDM {
 
-DiscreteIntegrator::DiscreteIntegrator(const std::string& name) :
+Integrator::Integrator(const std::string& name) :
   Model(name)
 {
   setNumInputPorts(1);
-  addProperty("initialValue", Property(this, &DiscreteIntegrator::getInitialValue, &DiscreteIntegrator::setInitialValue));
+  setInputPortName(0, "derivatirve");
 
   setNumOutputPorts(1);
-  setOutputPort(0, "output", Property(this, &DiscreteIntegrator::getIntegralOutput));
-  addProperty("output", Property(this, &DiscreteIntegrator::getIntegralOutput));
+  setOutputPort(0, "output",
+                Property(this, &Integrator::getIntegralOutput));
+
+  addProperty("initialValue",
+              Property(this, &Integrator::getInitialValue,
+                       &Integrator::setInitialValue));
+  addProperty("output",
+              Property(this, &Integrator::getIntegralOutput));
 }
 
-DiscreteIntegrator::~DiscreteIntegrator(void)
+Integrator::~Integrator(void)
 {
 }
 
 bool
-DiscreteIntegrator::init(void)
+Integrator::init(void)
 {
   OpenFDMAssert(getInputPort(0).isValid());
-  if (mInitialValue.rows() == 0 || mInitialValue.cols() == 0) {
+
+  // The initial value defaults to zero
+  if (rows(mInitialValue) == 0 || cols(mInitialValue) == 0) {
     mInitialValue.resize(getInputPort(0).getValue().toMatrix());
     mInitialValue.clear();
   }
+
+  setNumContinousStates(rows(mInitialValue)*cols(mInitialValue));
+
   mIntegralState = mInitialValue;
   mIntegralOutput = mIntegralState;
   return true;
 }
 
 void
-DiscreteIntegrator::output(void)
+Integrator::output(void)
 {
   mIntegralOutput = mIntegralState;
 }
 
 void
-DiscreteIntegrator::update(real_type dt)
+Integrator::setState(real_type, const Vector& state, unsigned offset)
 {
+  // FIXME reshape ...
+  for (unsigned j = 1; j <= cols(mIntegralState); ++j) {
+    for (unsigned i = 1; i <= rows(mIntegralState); ++i) {
+      mIntegralState(i, j) = state(offset + i + (j-1)*rows(mIntegralState));
+    }
+  }
+}
+
+void
+Integrator::getState(Vector& state, unsigned offset) const
+{
+  // FIXME reshape ...
+  for (unsigned j = 1; j <= cols(mIntegralState); ++j) {
+    for (unsigned i = 1; i <= rows(mIntegralState); ++i) {
+      state(offset + i + (j-1)*rows(mIntegralState)) = mIntegralState(i, j);
+    }
+  }
+}
+
+void
+Integrator::getStateDeriv(Vector& stateDeriv, unsigned offset)
+{
   OpenFDMAssert(getInputPort(0).isValid());
 
   // Just compute the integral.
   Matrix input = getInputPort(0).getValue().toMatrix();
   OpenFDMAssert(size(input) == size(mIntegralState));
-  if (size(input) == size(mIntegralState))
-    mIntegralState += dt*input;
+
+  // FIXME reshape ...
+  for (unsigned j = 1; j <= cols(input); ++j) {
+    for (unsigned i = 1; i <= rows(input); ++i) {
+      stateDeriv(offset + i + (j-1)*rows(input)) = input(i, j);
+    }
+  }
 }
 
 const Matrix&
-DiscreteIntegrator::getInitialValue(void) const
+Integrator::getInitialValue(void) const
 {
   return mInitialValue;
 }
 
 void
-DiscreteIntegrator::setInitialValue(const Matrix& value)
+Integrator::setInitialValue(const Matrix& value)
 {
   mInitialValue = value;
 }
 
 const Matrix&
-DiscreteIntegrator::getIntegralOutput(void) const
+Integrator::getIntegralOutput(void) const
 {
   return mIntegralOutput;
 }

Modified: trunk/OpenFDM/src/OpenFDM/Integrator.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Integrator.h	2005-10-06 10:12:46 UTC (rev 11)
+++ trunk/OpenFDM/src/OpenFDM/Integrator.h	2005-10-07 12:35:48 UTC (rev 12)
@@ -12,16 +12,19 @@
 
 namespace OpenFDM {
 
-class DiscreteIntegrator :
+class Integrator :
     public Model {
 public:
-  DiscreteIntegrator(const std::string& name);
-  virtual ~DiscreteIntegrator(void);
+  Integrator(const std::string& name);
+  virtual ~Integrator(void);
 
   virtual bool init(void);
   virtual void output(void);
-  virtual void update(real_type dt);
 
+  virtual void setState(real_type t, const Vector& state, unsigned offset);
+  virtual void getState(Vector& state, unsigned offset) const;
+  virtual void getStateDeriv(Vector& stateDeriv, unsigned offset);
+
   const Matrix& getInitialValue(void) const;
   void setInitialValue(const Matrix& value);
 

Modified: trunk/OpenFDM/src/OpenFDM/Makefile.am
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Makefile.am	2005-10-06 10:12:46 UTC (rev 11)
+++ trunk/OpenFDM/src/OpenFDM/Makefile.am	2005-10-07 12:35:48 UTC (rev 12)
@@ -47,6 +47,7 @@
   DefaultGround.h \
   DefaultPlanet.h \
   DirectForce.h \
+  DiscreteIntegrator.h \
   DoPri5.h \
   Environment.h \
   EnvironmentObject.h \
@@ -124,6 +125,7 @@
   DefaultGround.cpp \
   DefaultPlanet.cpp \
   DirectForce.cpp \
+  DiscreteIntegrator.cpp \
   DoPri5.cpp \
   Environment.cpp \
   EnvironmentObject.cpp \

Modified: trunk/OpenFDM/src/OpenFDM/Model.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Model.cpp	2005-10-06 10:12:46 UTC (rev 11)
+++ trunk/OpenFDM/src/OpenFDM/Model.cpp	2005-10-07 12:35:48 UTC (rev 12)
@@ -72,6 +72,16 @@
 }
 
 void
+Model::evalFunction(real_type t, const Vector& v, Vector& out)
+{
+  /// FIXME Hmm, may be different ...
+  setState(t, v, 0);
+  output();
+  out.resize(getNumContinousStates());
+  getStateDeriv(out, 0);
+}
+
+void
 Model::evalJacobian(real_type t, const Vector& v,
                    Matrix& jac, unsigned offset)
 {
@@ -84,6 +94,7 @@
   // Get the function value at the current position.
   Vector fv(nStates);
   setState(t, v, 0);
+  output();
   getStateDeriv(fv, 0);
 
   real_type sqrteps = 1e4*sqrt(Limits<real_type>::epsilon());
@@ -95,6 +106,7 @@
 
     // Evaluate then function ...
     setState(t, tmpv, 0);
+    output();
     getStateDeriv(tmpfv, 0);
 
     // ... and compute the differencequotient to approximate the derivative.

Modified: trunk/OpenFDM/src/OpenFDM/Model.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Model.h	2005-10-06 10:12:46 UTC (rev 11)
+++ trunk/OpenFDM/src/OpenFDM/Model.h	2005-10-07 12:35:48 UTC (rev 12)
@@ -39,8 +39,7 @@
   virtual void getStateDeriv(Vector& stateDeriv, unsigned offset);
 
   /// FIXME Hmm, may be different ...
-  void evalFunction(real_type t, const Vector& v, Vector& out)
-  { setState(t, v, 0); out.resize(getNumContinousStates()); getStateDeriv(out, 0); }
+  void evalFunction(real_type t, const Vector& v, Vector& out);
   /// Compute the jacobian
   /// The default implementation computes a numeric approximation by finite
   /// differences

Modified: trunk/OpenFDM/src/OpenFDM/RootFrame.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RootFrame.cpp	2005-10-06 10:12:46 UTC (rev 11)
+++ trunk/OpenFDM/src/OpenFDM/RootFrame.cpp	2005-10-07 12:35:48 UTC (rev 12)
@@ -206,8 +206,6 @@
 void
 MultiBodySystem::getStateDeriv(Vector& stateDeriv, unsigned offset)
 {
-  OpenFDMAssert(offset == 0);
-
   // Compute the external and interaction forces.
   ForceComputationVisitor forceVisitor;
   mRootFrame->accept(forceVisitor);
@@ -223,9 +221,7 @@
   // And finally extract the derivative vector from the tree.
   GetStateDerivVisitor gsdv(getNumContinousStates());
   mRootFrame->accept(gsdv);
-//   stateDeriv(Range(offset+1, offset+getNumContinousStates()))
-//     = gsdv.getStateDeriv();
-  stateDeriv
+  stateDeriv(Range(offset+1, offset+getNumContinousStates()))
     = gsdv.getStateDeriv();
 }
 

Modified: trunk/OpenFDM/src/OpenFDM/main.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/main.cpp	2005-10-06 10:12:46 UTC (rev 11)
+++ trunk/OpenFDM/src/OpenFDM/main.cpp	2005-10-07 12:35:48 UTC (rev 12)
@@ -40,19 +40,22 @@
 #include <OpenFDM/LogStream.h>
 #include <OpenFDM/Variant.h>
 #include <OpenFDM/Property.h>
+
+// Model includes
 #include <OpenFDM/Model.h>
 #include <OpenFDM/ModelGroup.h>
+#include <OpenFDM/Bias.h>
 #include <OpenFDM/ConstSystem.h>
+#include <OpenFDM/DeadBand.h>
+#include <OpenFDM/DiscreteIntegrator.h>
+#include <OpenFDM/Gain.h>
 #include <OpenFDM/Integrator.h>
 #include <OpenFDM/TimeDerivative.h>
 #include <OpenFDM/UnaryFunctionModel.h>
 #include <OpenFDM/BinaryFunctionModel.h>
 #include <OpenFDM/Product.h>
+#include <OpenFDM/Saturation.h>
 #include <OpenFDM/Summer.h>
-#include <OpenFDM/Bias.h>
-#include <OpenFDM/Gain.h>
-#include <OpenFDM/DeadBand.h>
-#include <OpenFDM/Saturation.h>
 
 #include "XML/XMLReader.h"
 
@@ -309,14 +312,18 @@
       model = new ConstSystem(name, Matrix()); // FIXME
     } else if (type == "DeadBand") {
       model = new DeadBand(name);
+    } else if (type == "DiscreteIntegrator") {
+      model = new DiscreteIntegrator(name);
     } else if (type == "Gain") {
       model = new Gain(name);
     } else if (type == "Integrator") {
-      model = new DiscreteIntegrator(name);
+      model = new Integrator(name);
     } else if (type == "Product") {
       model = new Product(name);
     } else if (type == "Saturation") {
       model = new Saturation(name);
+    } else if (type == "TimeDerivative") {
+      model = new TimeDerivative(name);
     } else
       return error(std::string("Error loading Models: Unknown Model type \"")
                    + type + "\" !");
@@ -605,19 +612,18 @@
 
   printVehicle(vehicle);
 
+  System* system = vehicle->getSystem();
+  bool initOk = system->init();
+  if (!initOk) {
+    cout << "Error  in init" << endl;
+    return -17;
+  }
   ModelGroup* modelGroup = vehicle->getModelGroup();
   for (unsigned i = 0; i < modelGroup->getNumModels(); ++i) {
     cout << modelGroup->getModel(i)->getName() << endl;
   }
-
-  bool initOk = modelGroup->init();
-  if (!initOk) {
-    cout << "Error  in init" << endl;
-    return -17;
-  }
   for (unsigned j = 0; j < 1000; ++j) {
-    modelGroup->output();
-    modelGroup->update(0.01);
+    system->simulate(j*0.01);
 
     for (unsigned i = 0; i < modelGroup->getNumModels(); ++i)
       cout << modelGroup->getModel(i)->getOutputPort("output").getValue().toMatrix() << " ";



From frohlich at berlios.de  Fri Oct  7 14:46:49 2005
From: frohlich at berlios.de (Mathias Froehlich at BerliOS)
Date: Fri, 7 Oct 2005 14:46:49 +0200
Subject: [Openfdm-svn] r13 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200510071246.j97CknwS018310@sheep.berlios.de>

Author: frohlich
Date: 2005-10-07 14:46:48 +0200 (Fri, 07 Oct 2005)
New Revision: 13

Modified:
   trunk/OpenFDM/src/OpenFDM/test-vehicle.xml
Log:
Longstanding bug. Id's are removed in favour to
names. Reflect that in the test file.


Modified: trunk/OpenFDM/src/OpenFDM/test-vehicle.xml
===================================================================
--- trunk/OpenFDM/src/OpenFDM/test-vehicle.xml	2005-10-07 12:35:48 UTC (rev 12)
+++ trunk/OpenFDM/src/OpenFDM/test-vehicle.xml	2005-10-07 12:46:48 UTC (rev 13)
@@ -48,9 +48,9 @@
 
   <MechanicalSystem>
 
-    <Frame Name="Structural Frame" Id="structural"/>
+    <Frame Name="structural"/>
 
-    <RigidBody Name="Vehicle Top Body" Id="top">
+    <RigidBody Name="top">
       <Mass>
         <Position>
           <Vector Unit="m">1 1 1</Vector>
@@ -69,8 +69,8 @@
       </Mass>
     </RigidBody>
 
-    <Joint Type="Revolute" Name="Nose Strut Retract Joint" Id="noseStrutRetractJoint">
-      <Mount Id="top">
+    <Joint Type="Revolute" Name="noseStrutRetractJoint">
+      <Mount Name="top">
         <!-- The position of the joint in this body's coordinates. -->
         <Position>
           <Vector Unit="m">1 1 1</Vector>
@@ -80,7 +80,7 @@
           <quaternion>1 0 0 0</quaternion>
         </Orientation>
       </Mount>
-      <Mount Id="noseStrutBody">
+      <Mount Name="noseStrutBody">
         <!-- The position of the joint in this body's coordinates. -->
         <Position>
           <Vector Unit="m">1 1 1</Vector>
@@ -92,37 +92,37 @@
       </Mount>
 <!--       <Actuator></Actuator> -->
     </Joint>
-    <RigidBody Name="Nose Strut Body" Id="noseStrutBody">
+    <RigidBody Name="noseStrutBody">
     </RigidBody>
-    <Joint Type="Revolute" Name="Nose Strut Steering Joint" Id="noseStrutSteeringJoint">
-      <Mount Id="noseStrutBody">
+    <Joint Type="Revolute" Name="noseStrutSteeringJoint">
+      <Mount Name="noseStrutBody">
       </Mount>
-      <Mount Id="noseStrutSteerBody">
+      <Mount Name="noseStrutSteerBody">
       </Mount>
     </Joint>
-    <RigidBody Name="Nose Strut Steering Body" Id="noseStrutSteerBody">
+    <RigidBody Name="noseStrutSteerBody">
       <Mass>
         <Mass Unit="kg">17</Mass>
       </Mass>
     </RigidBody>
-    <Joint Type="Prismatic" Name="Nose Compression Joint" Id="noseCompressionJoint">
-      <Mount Id="noseStrutSteerBody">
+    <Joint Type="Prismatic" Name="noseCompressionJoint">
+      <Mount Name="noseStrutSteerBody">
       </Mount>
-      <Mount Id="noseStrutCompressBody">
+      <Mount Name="noseStrutCompressBody">
       </Mount>
     </Joint>
-    <RigidBody Name="Nose Strut Compress Body" Id="noseStrutCompressBody">
+    <RigidBody Name="noseStrutCompressBody">
       <Mass>
         <Mass Unit="kg">17</Mass>
       </Mass>
     </RigidBody>
-    <Joint Type="Revolute" Name="Nose Wheel Hub" Id="noseWheelHub">
-      <Mount Id="noseStrutCompressBody">
+    <Joint Type="Revolute" Name="noseWheelHub">
+      <Mount Name="noseStrutCompressBody">
       </Mount>
-      <Mount Id="noseWheel">
+      <Mount Name="noseWheel">
       </Mount>
     </Joint>
-    <RigidBody Name="Nose Wheel" Id="noseWheel">
+    <RigidBody Name="noseWheel">
       <Mass>
         <Mass Unit="kg">17</Mass>
       </Mass>
@@ -132,35 +132,35 @@
     </RigidBody>
 
 
-    <Joint Type="Revolute" Name="Right Main Strut Retract" Id="rightStrutRestractJoint">
-      <Mount Id="top">
+    <Joint Type="Revolute" Name="rightStrutRestractJoint">
+      <Mount Name="top">
       </Mount>
-      <Mount Id="rightStrutBody">
+      <Mount Name="rightStrutBody">
       </Mount>
     </Joint>
-    <RigidBody Name="Right Strut Body" Id="rightStrutBody">
+    <RigidBody Name="rightStrutBody">
       <Mass>
         <Mass Unit="kg">17</Mass>
       </Mass>
     </RigidBody>
-    <Joint Type="Revolute" Name="Right Strut Compress Joint" Id="rightStrutCompressJoint">
-      <Mount Id="rightStrutBody">
+    <Joint Type="Revolute" Name="rightStrutCompressJoint">
+      <Mount Name="rightStrutBody">
       </Mount>
-      <Mount Id="rightStrutCompressBody">
+      <Mount Name="rightStrutCompressBody">
       </Mount>
     </Joint>
-    <RigidBody Name="Right Strut Compression Body" Id="rightStrutCompressBody">
+    <RigidBody Name="rightStrutCompressBody">
       <Mass>
         <Mass Unit="kg">17</Mass>
       </Mass>
     </RigidBody>
-    <Joint Type="Revolute" Name="Right Wheel Hub" Id="rightWheelHub">
-      <Mount Id="rightStrutCompressBody">
+    <Joint Type="Revolute" Name="rightWheelHub">
+      <Mount Name="rightStrutCompressBody">
       </Mount>
-      <Mount Id="rightWheel">
+      <Mount Name="rightWheel">
       </Mount>
     </Joint>
-    <RigidBody Name="Right Wheel" Id="rightWheel">
+    <RigidBody Name="rightWheel">
       <Mass>
         <Mass Unit="kg">17</Mass>
       </Mass>
@@ -169,35 +169,35 @@
       </Inertia>
     </RigidBody>
 
-    <Joint Type="Revolute" Name="Left Main Strut" Id="leftStrut">
-      <Mount Id="top">
+    <Joint Type="Revolute" Name="leftStrut">
+      <Mount Name="top">
       </Mount>
-      <Mount Id="leftStrutBody">
+      <Mount Name="leftStrutBody">
       </Mount>
     </Joint>
-    <RigidBody Name="Left Strut Body" Id="leftStrutBody">
+    <RigidBody Name="leftStrutBody">
       <Mass>
         <Mass Unit="kg">17</Mass>
       </Mass>
     </RigidBody>
-    <Joint Type="Revolute" Name="Left Strut Compress Joint" Id="leftStrutCompressJoint">
-      <Mount Id="leftStrutBody">
+    <Joint Type="Revolute" Name="leftStrutCompressJoint">
+      <Mount Name="leftStrutBody">
       </Mount>
-      <Mount Id="leftStrutCompressBody">
+      <Mount Name="leftStrutCompressBody">
       </Mount>
     </Joint>
-    <RigidBody Type="Revolute" Name="Left Strut Compression Body" Id="leftStrutCompressBody">
+    <RigidBody Type="Revolute" Name="leftStrutCompressBody">
       <Mass>
         <Mass Unit="kg">17</Mass>
       </Mass>
     </RigidBody>
-    <Joint Type="Revolute" Name="Left Wheel Hub" Id="leftWheelHub">
-      <Mount Id="leftStrutCompressBody">
+    <Joint Type="Revolute" Name="leftWheelHub">
+      <Mount Name="leftStrutCompressBody">
       </Mount>
-      <Mount Id="leftWheel">
+      <Mount Name="leftWheel">
       </Mount>
     </Joint>
-    <RigidBody Name="Left Wheel" Id="leftWheel">
+    <RigidBody Name="leftWheel">
       <Mass>
         <Mass Unit="kg">17</Mass>
       </Mass>
@@ -207,21 +207,21 @@
     </RigidBody>
 
 
-    <AeroForce Name="Aerodynamic Force Tables" Id="aeroFroce">
-      <Mount Id="top">
+    <AeroForce Name="aeroFroce">
+      <Mount Name="top">
         <Position>
           <Vector Unit="m">1 1 1</Vector>
         </Position>
       </Mount>
     </AeroForce>
 
-    <SimpleContact Name="Contact 1" Id="contact1">
+    <SimpleContact Name="contact1">
     </SimpleContact>
-    <SimpleContact Name="Contact 2" Id="contact2">
+    <SimpleContact Name="contact2">
     </SimpleContact>
-    <SimpleContact Name="Contact 3" Id="contact3">
+    <SimpleContact Name="contact3">
     </SimpleContact>
-    <SimpleContact Name="Contact 4" Id="contact4">
+    <SimpleContact Name="contact4">
     </SimpleContact>
   </MechanicalSystem>
 </OpenFDM>



From frohlich at berlios.de  Fri Oct  7 14:47:26 2005
From: frohlich at berlios.de (Mathias Froehlich at BerliOS)
Date: Fri, 7 Oct 2005 14:47:26 +0200
Subject: [Openfdm-svn] r14 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200510071247.j97ClQMQ018373@sheep.berlios.de>

Author: frohlich
Date: 2005-10-07 14:47:25 +0200 (Fri, 07 Oct 2005)
New Revision: 14

Modified:
   trunk/OpenFDM/src/OpenFDM/main.cpp
Log:
Be more verbose in the error case.


Modified: trunk/OpenFDM/src/OpenFDM/main.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/main.cpp	2005-10-07 12:46:48 UTC (rev 13)
+++ trunk/OpenFDM/src/OpenFDM/main.cpp	2005-10-07 12:47:25 UTC (rev 14)
@@ -448,9 +448,12 @@
         return error("Error loading Vehicle: More or less then 2 Mounts!");
       std::list<XMLElement::const_pointer>::iterator mit = mounts.begin();
       for (unsigned idx = 0; mit != mounts.end(); ++idx, ++mit) {
-        RigidBody* body = mVehicle->getRigidBody((*mit)->getAttribute("Name"));
+        std::string mountAttrName = (*mit)->getAttribute("Name");
+        RigidBody* body = mVehicle->getRigidBody(mountAttrName);
         if (!body)
-          return error("Error loading Vehicle: Cannot find RigidBody for Mount!");
+          return error(std::string("Error loading Vehicle:") +
+                       " Can not find RigidBody \"" + mountAttrName +
+                       "\" for Mount of Joint \"" + joint->getName() + "\"!");
        
         joint->setParentFrame(body, idx);
         



From frohlich at berlios.de  Mon Oct 10 20:08:16 2005
From: frohlich at berlios.de (Mathias Froehlich at BerliOS)
Date: Mon, 10 Oct 2005 20:08:16 +0200
Subject: [OpenFDM-svn] r18 - in trunk/OpenFDM/src: JSBSim OpenFDM
Message-ID: <200510101808.j9AI8Gus025061@sheep.berlios.de>

Author: frohlich
Date: 2005-10-10 20:08:03 +0200 (Mon, 10 Oct 2005)
New Revision: 18

Added:
   trunk/OpenFDM/src/JSBSim/jsb2openfdm.cpp
Removed:
   trunk/OpenFDM/src/JSBSim/main.cpp
Modified:
   trunk/OpenFDM/src/JSBSim/Makefile.am
   trunk/OpenFDM/src/OpenFDM/Makefile.am
Log:
Rename main to something more descriptive, updates to the build system.


Modified: trunk/OpenFDM/src/JSBSim/Makefile.am
===================================================================
--- trunk/OpenFDM/src/JSBSim/Makefile.am	2005-10-09 22:41:48 UTC (rev 17)
+++ trunk/OpenFDM/src/JSBSim/Makefile.am	2005-10-10 18:08:03 UTC (rev 18)
@@ -1,9 +1,9 @@
 INCLUDES = -I$(srcdir)/..
 
-noinst_PROGRAMS = main
-main_SOURCES = main.cpp
-main_LDFLAGS = 
-main_LDADD = libJSBReader.la ../OpenFDM/libOpenFDM.la -L$(HOME)/sw/lib -lsgxml -lsgstructure
+bin_PROGRAMS = jsb2openfdm
+jsb2openfdm_SOURCES = jsb2openfdm.cpp
+jsb2openfdm_LDFLAGS = 
+jsb2openfdm_LDADD = libJSBReader.la ../OpenFDM/libOpenFDM.la
 
 ### FIXME!!!
 OpenFDMincludedir = $(includedir)/JSBSim

Copied: trunk/OpenFDM/src/JSBSim/jsb2openfdm.cpp (from rev 17, trunk/OpenFDM/src/JSBSim/main.cpp)

Deleted: trunk/OpenFDM/src/JSBSim/main.cpp
===================================================================
--- trunk/OpenFDM/src/JSBSim/main.cpp	2005-10-09 22:41:48 UTC (rev 17)
+++ trunk/OpenFDM/src/JSBSim/main.cpp	2005-10-10 18:08:03 UTC (rev 18)
@@ -1,38 +0,0 @@
-#include <iostream>
-
-#include <OpenFDM/ReaderWriter.h>
-#include "LegacyJSBSimReader.h"
-
-using OpenFDM::ReaderWriter;
-using OpenFDM::LegacyJSBSimReader;
-
-int
-main(int argc, char *argv[])
-{
-  if (argc < 3)
-    return 1;
-
-  // Try to read JSBSim legacy files.
-  LegacyJSBSimReader reader;
-
-  reader.addAircraftPath(argv[1]);
-  reader.addEnginePath(std::string(argv[1]) + "Engines/");
-
-  reader.loadAircraft(argv[2]);
-  if (reader.getErrorState()) {
-    std::cerr << "FGOpenFDM::init() cannot read aircraft!" << std::endl;
-    const ReaderWriter::StringList errors = reader.getErrors();
-    ReaderWriter::StringList::const_iterator it;
-    for (it = errors.begin(); it != errors.end(); ++it)
-      std::cerr << *it << std::endl;
-
-    return 1;
-  }
-
-  // Ok, now the Vehicle here contains the imported data
-  // When the reflection stuff is ready, we can dump that data to a
-  // native format ...
-  // reader.getVehicle();
-
-  return 0;
-}

Modified: trunk/OpenFDM/src/OpenFDM/Makefile.am
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Makefile.am	2005-10-09 22:41:48 UTC (rev 17)
+++ trunk/OpenFDM/src/OpenFDM/Makefile.am	2005-10-10 18:08:03 UTC (rev 18)
@@ -7,7 +7,7 @@
 noinst_PROGRAMS = main units
 
 main_SOURCES = main.cpp
-main_LDADD = libOpenFDM.la -lsgxml -lsgstructure
+main_LDADD = libOpenFDM.la
 
 units_SOURCES = units.cpp
 units_LDADD = libOpenFDM.la
@@ -15,6 +15,9 @@
 OpenFDMincludedir = $(includedir)/OpenFDM
 
 lib_LTLIBRARIES = libOpenFDM.la
+
+# Will need these at the moment ...
+libOpenFDM_la_LIBADD = -lsgxml -lsgstructure
 nobase_OpenFDMinclude_HEADERS = \
   Matrix.h \
   Quaternion.h \



From frohlich at berlios.de  Tue Oct 11 21:32:26 2005
From: frohlich at berlios.de (Mathias Froehlich at BerliOS)
Date: Tue, 11 Oct 2005 21:32:26 +0200
Subject: [OpenFDM-svn] r20 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200510111932.j9BJWQjF010713@sheep.berlios.de>

Author: frohlich
Date: 2005-10-11 21:32:25 +0200 (Tue, 11 Oct 2005)
New Revision: 20

Modified:
   trunk/OpenFDM/src/OpenFDM/ModelGroup.cpp
Log:
Fix invalid iterator error.


Modified: trunk/OpenFDM/src/OpenFDM/ModelGroup.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/ModelGroup.cpp	2005-10-10 22:35:14 UTC (rev 19)
+++ trunk/OpenFDM/src/OpenFDM/ModelGroup.cpp	2005-10-11 19:32:25 UTC (rev 20)
@@ -325,14 +325,18 @@
       return false;
     }
 
+    // We need to store that one here since the iterator possibly invalidates
+    // during the next append dependency call
+    shared_ptr<Model> tmpModel = *it;
+    mModels.erase(it);
+
     // Now recurse into that model.
-    if (!appendDependecies(firstModel, *it, newList))
+    if (!appendDependecies(firstModel, tmpModel, newList))
       return false;
-
+ 
     // Finally, past all the dependent models are already in the list,
     // push that one in question.
-    newList.push_back(*it);
-    mModels.erase(it);
+    newList.push_back(tmpModel);
   }
 }
 



From frohlich at berlios.de  Tue Oct 11 21:56:01 2005
From: frohlich at berlios.de (Mathias Froehlich at BerliOS)
Date: Tue, 11 Oct 2005 21:56:01 +0200
Subject: [OpenFDM-svn] r21 - trunk/OpenFDM/src/JSBSim
Message-ID: <200510111956.j9BJu1nq012847@sheep.berlios.de>

Author: frohlich
Date: 2005-10-11 21:56:00 +0200 (Tue, 11 Oct 2005)
New Revision: 21

Modified:
   trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
Log:
Improove kinemat elements somewhat.


Modified: trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
===================================================================
--- trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2005-10-11 19:32:25 UTC (rev 20)
+++ trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2005-10-11 19:56:00 UTC (rev 21)
@@ -482,6 +482,18 @@
   if (!convertMetrics(metricsElem->getData()))
     return error("Cannot convert METRICS data");
 
+  // Convert all the flight control system elements.
+  const XMLElement* fcsElem = topElem->getElement("FLIGHT_CONTROL");
+  if (fcsElem) {
+    if (!convertFCSList(fcsElem))
+      return error("Cannot convert FLIGHT_CONTROL data");
+  }
+  const XMLElement* autopilotElem = topElem->getElement("AUTOPILOT");
+  if (autopilotElem) {
+    if (!convertFCSList(autopilotElem))
+      return error("Cannot convert AUTOPILOT data");
+  }
+
   // Parse the undercarriage section
   const XMLElement* undercarriageElem = topElem->getElement("UNDERCARRIAGE");
   if (undercarriageElem) {
@@ -496,19 +508,6 @@
       return error("Cannot convert PROPULSION data");
   }
   
-  // Convert all the flight control system elements.
-  const XMLElement* fcsElem = topElem->getElement("FLIGHT_CONTROL");
-  if (fcsElem) {
-    if (!convertFCSList(fcsElem))
-      return error("Cannot convert FLIGHT_CONTROL data");
-  }
-  const XMLElement* autopilotElem = topElem->getElement("AUTOPILOT");
-  if (autopilotElem) {
-    if (!convertFCSList(autopilotElem))
-      return error("Cannot convert AUTOPILOT data");
-  }
-
-
   // Convert the aerodynamic force.
   const XMLElement* aeroElem = topElem->getElement("AERODYNAMICS");
   if (aeroElem) {
@@ -875,7 +874,7 @@
     gain->setGain(1);
     model = gain;
 
-    inputSaturation = new Saturation(name + "Input Saturation");
+    inputSaturation = new Saturation(name + " Input Saturation");
     addFCSModel(inputSaturation);
     inputSaturation->setInputPort(0, gain->getOutputPort(0));
 
@@ -898,7 +897,8 @@
     addFCSModel(integrator);
     integrator->setInputPort(0, kinematRateLimit->getOutputPort(0));
     Matrix tmp(1, 1);
-    tmp.clear();
+    tmp(1, 1) = 1;
+//     tmp.clear();
     integrator->setInitialValue(tmp);
     out = integrator->getOutputPort(0);
 
@@ -1385,11 +1385,6 @@
                  "Ignoring whole FCS component \"" + name + "\"");
   }
 
-  // For KINEMATS ...
-  if (type == "KINEMAT" && noScale) {
-    gain->setGain(1);
-  }
-
   // Now put the expressions for the output chain together.
   // Doing that now will put them together in a well defined order.
   if (outbias) {
@@ -1410,14 +1405,29 @@
   // FIXME put in here a normalized out property, or at least a gain to
   // normalize
 
+  // For KINEMATS ...
+  if (type == "KINEMAT") {
+    if (noScale) {
+      gain->setGain(1);
+      normOut = out;
+    } else {
+      Gain* normGain = new Gain(name + " Normalize Gain");
+      normGain->setGain(1/gain->getGain());
+      addFCSModel(normGain);
+      normGain->setInputPort(0, out);
+      normOut = normGain->getOutputPort(0);
+    }
+  }
+
+  if (!normOut.isValid())
+    normOut = inputs.front();
+
   // Register all output property names.
   std::list<std::string>::iterator it;
   for (it = outlist.begin(); it != outlist.end(); ++it) {
     std::string propName = *it;
     registerJSBExpression(propName, out);
 
-    if (!normOut.isValid())
-      normOut = inputs.front();
     // Well, just an other kind of black magic ...
     if (propName == "fcs/elevator-pos-rad") {
       registerJSBExpression("fcs/elevator-pos-norm", normOut);



From frohlich at berlios.de  Sun Oct 16 20:45:03 2005
From: frohlich at berlios.de (Mathias Froehlich at BerliOS)
Date: Sun, 16 Oct 2005 20:45:03 +0200
Subject: [OpenFDM-svn] r22 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200510161845.j9GIj35R025906@sheep.berlios.de>

Author: frohlich
Date: 2005-10-16 20:45:02 +0200 (Sun, 16 Oct 2005)
New Revision: 22

Modified:
   trunk/OpenFDM/src/OpenFDM/Math.h
Log:
Implement greatest common divisor


Modified: trunk/OpenFDM/src/OpenFDM/Math.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Math.h	2005-10-11 19:56:00 UTC (rev 21)
+++ trunk/OpenFDM/src/OpenFDM/Math.h	2005-10-16 18:45:02 UTC (rev 22)
@@ -52,7 +52,8 @@
 using std::max;
 
 template<typename T>
-inline int sign(T val)
+inline int
+sign(T val)
 {
   if (val <= -Limits<T>::min())
     return -1;
@@ -62,7 +63,8 @@
 }
 
 template<typename S, typename T>
-inline S interpolate(T x, T x0, const S& y0, T x1, const S& y1)
+inline S
+interpolate(T x, T x0, const S& y0, T x1, const S& y1)
 {
   // If called in the wrong order, simply call with the correct order ...
   if (x1 < x0)
@@ -80,6 +82,31 @@
   }
 }
 
+/// Compute the greatest common divisor of a and b
+/// Floating point version, might provide problems with roundoff ...
+inline
+real_type
+greatestCommonDivisor(real_type a_, real_type b_)
+{
+  real_type a = fabs(a_);
+  real_type b = fabs(b_);
+
+  real_type eps = 64*max(a, b)*Limits<real_type>::epsilon();
+  unsigned opcount = 1;
+  while (eps*opcount < b) {
+    real_type r = fmod(a, b);
+    a = b;
+    b = r;
+    ++opcount;
+  }
+
+  // should return a, but make it a natural numbered quotient as much
+  // as possible
+//   std::cout << a - a_/floor(a_/a + 0.5) << std::endl;
+//   return a;
+  return fabs(a_)/floor(fabs(a_)/a + 0.5);
+}
+
 } // namespace OpenFDM
 
 #endif



From frohlich at berlios.de  Wed Oct 19 08:06:46 2005
From: frohlich at berlios.de (Mathias Froehlich at BerliOS)
Date: Wed, 19 Oct 2005 08:06:46 +0200
Subject: [OpenFDM-svn] r23 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200510190606.j9J66kuF027058@sheep.berlios.de>

Author: frohlich
Date: 2005-10-19 08:06:40 +0200 (Wed, 19 Oct 2005)
New Revision: 23

Modified:
   trunk/OpenFDM/src/OpenFDM/AeroForce.cpp
   trunk/OpenFDM/src/OpenFDM/Contact.cpp
Log:
Fix problem not taking the frames orientation into account.


Modified: trunk/OpenFDM/src/OpenFDM/AeroForce.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/AeroForce.cpp	2005-10-16 18:45:02 UTC (rev 22)
+++ trunk/OpenFDM/src/OpenFDM/AeroForce.cpp	2005-10-19 06:06:40 UTC (rev 23)
@@ -183,7 +183,7 @@
     OpenFDMAssert(frame);
     if (frame) {
       // Get the position in the earth centered coordinate frame.
-      mRefPosition = frame->getRefPosition() + getPosition();
+      mRefPosition = frame->posToRef(getPosition());
       mDirtyRefPosition = false;
     }
   }

Modified: trunk/OpenFDM/src/OpenFDM/Contact.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Contact.cpp	2005-10-16 18:45:02 UTC (rev 22)
+++ trunk/OpenFDM/src/OpenFDM/Contact.cpp	2005-10-19 06:06:40 UTC (rev 23)
@@ -123,7 +123,7 @@
     return;
 
   // Get the position of the contact in the reference system.
-  Vector3 pos = frame->getRefPosition() + getPosition();
+  Vector3 pos = frame->posToRef(getPosition());
   // Query for the ground parameters at this point.
   mGroundVal = mEnvironment->getGround()->getGroundPlane(t, pos);
 }



From frohlich at berlios.de  Sat Oct 22 16:09:24 2005
From: frohlich at berlios.de (Mathias Froehlich at BerliOS)
Date: Sat, 22 Oct 2005 16:09:24 +0200
Subject: [OpenFDM-svn] r25 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200510221409.j9ME9Okn013413@sheep.berlios.de>

Author: frohlich
Date: 2005-10-22 16:09:23 +0200 (Sat, 22 Oct 2005)
New Revision: 25

Modified:
   trunk/OpenFDM/src/OpenFDM/Quaternion.h
Log:
Make it more robust wrt nonnormalized quaternions.


Modified: trunk/OpenFDM/src/OpenFDM/Quaternion.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Quaternion.h	2005-10-22 12:13:28 UTC (rev 24)
+++ trunk/OpenFDM/src/OpenFDM/Quaternion.h	2005-10-22 14:09:23 UTC (rev 25)
@@ -155,17 +155,23 @@
     value_type q3 = (*this)(3);
     value_type q4 = (*this)(4);
 
+    value_type r = 1/dot(*this, *this);
+    value_type rq1 = r*q1;
+    value_type rq2 = r*q2;
+    value_type rq3 = r*q3;
+    value_type rq4 = r*q4;
+
     // Now compute the transformation matrix.
-    value_type q1q1 = q1*q1;
-    value_type q2q2 = q2*q2;
-    value_type q3q3 = q3*q3;
-    value_type q4q4 = q4*q4;
-    value_type q1q2 = q1*q2;
-    value_type q1q3 = q1*q3;
-    value_type q1q4 = q1*q4;
-    value_type q2q3 = q2*q3;
-    value_type q2q4 = q2*q4;
-    value_type q3q4 = q3*q4;
+    value_type q1q1 = rq1*q1;
+    value_type q2q2 = rq2*q2;
+    value_type q3q3 = rq3*q3;
+    value_type q4q4 = rq4*q4;
+    value_type q1q2 = rq1*q2;
+    value_type q1q3 = rq1*q3;
+    value_type q1q4 = rq1*q4;
+    value_type q2q3 = rq2*q3;
+    value_type q2q4 = rq2*q4;
+    value_type q3q4 = rq3*q4;
     
     return Matrix33(q1q1+q2q2-q3q3-q4q4, 2*(q2q3+q1q4), 2*(q2q4-q1q3),
                     2*(q2q3-q1q4), q1q1-q2q2+q3q3-q4q4, 2*(q3q4+q1q2),
@@ -177,15 +183,21 @@
 
   Vector3 transform(const Vector3& v) const
   {
+    value_type r = 1/dot(*this, *this);
     Vector3 qimag = imag(*this);
     value_type qr = real(*this);
-    return (2*qr*qr - 1)*v + (2*dot(qimag, v))*qimag - (2*qr)*cross(qimag, v);
+    return (2*r*qr*qr - 1)*v
+      + (2*r*dot(qimag, v))*qimag
+      - (2*r*qr)*cross(qimag, v);
   }
   Vector3 backTransform(const Vector3& v) const
   {
+    value_type r = 1/dot(*this, *this);
     Vector3 qimag = imag(*this);
     value_type qr = real(*this);
-    return (2*qr*qr - 1)*v + (2*dot(qimag, v))*qimag + (2*qr)*cross(qimag, v);
+    return (2*r*qr*qr - 1)*v
+      + (2*r*dot(qimag, v))*qimag
+      + (2*r*qr)*cross(qimag, v);
   }
 
 



From frohlich at berlios.de  Sat Oct 22 16:10:17 2005
From: frohlich at berlios.de (Mathias Froehlich at BerliOS)
Date: Sat, 22 Oct 2005 16:10:17 +0200
Subject: [OpenFDM-svn] r26 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200510221410.j9MEAHfX013516@sheep.berlios.de>

Author: frohlich
Date: 2005-10-22 16:10:16 +0200 (Sat, 22 Oct 2005)
New Revision: 26

Modified:
   trunk/OpenFDM/src/OpenFDM/Transform.h
Log:
Zap some FIXME's: rethink transformations of a Plane.


Modified: trunk/OpenFDM/src/OpenFDM/Transform.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Transform.h	2005-10-22 14:09:23 UTC (rev 25)
+++ trunk/OpenFDM/src/OpenFDM/Transform.h	2005-10-22 14:10:16 UTC (rev 26)
@@ -207,23 +207,18 @@
 inline Plane
 planeTo(const Vector3& p, const Rotation& r, const Plane& plane)
 {
-  // FIXME: simplify
-  return Plane(normalize(r.transform(plane.getNormal())),
-               posTo(p, r, plane.getPointOnPlane()));
+  return Plane(r.transform(plane.getNormal()),
+               plane.getDist() + dot(plane.getNormal(), p));
 }
 inline Plane
 planeTo(const Vector3& p, const Plane& plane)
 {
-  // FIXME: simplify
-  return Plane(plane.getNormal(),
-               posTo(p, plane.getPointOnPlane()));
+  return Plane(plane.getNormal(), plane.getDist() + dot(plane.getNormal(), p));
 }
 inline Plane
 planeTo(const Rotation& r, const Plane& plane)
 {
-  // FIXME: simplify
-  return Plane(normalize(r.transform(plane.getNormal())),
-               posTo(r, plane.getPointOnPlane()));
+  return Plane(r.transform(plane.getNormal()), plane.getDist());
 }
 
 
@@ -232,23 +227,18 @@
 inline Plane
 planeFrom(const Vector3& p, const Rotation& r, const Plane& plane)
 {
-  // FIXME: simplify
-  return Plane(normalize(r.backTransform(plane.getNormal())),
-               posFrom(p, r, plane.getPointOnPlane()));
+  return Plane(r.backTransform(plane.getNormal()),
+               plane.getDist() - dot(plane.getNormal(), p));
 }
 inline Plane
 planeFrom(const Vector3& p, const Plane& plane)
 {
-  // FIXME: simplify
-  return Plane(plane.getNormal(),
-               posFrom(p, plane.getPointOnPlane()));
+  return Plane(plane.getNormal(), plane.getDist() - dot(plane.getNormal(), p));
 }
 inline Plane
 planeFrom(const Rotation& r, const Plane& plane)
 {
-  // FIXME: simplify
-  return Plane(normalize(r.backTransform(plane.getNormal())),
-               posFrom(r, plane.getPointOnPlane()));
+  return Plane(r.backTransform(plane.getNormal()), plane.getDist());
 }
 
 



From frohlich at berlios.de  Sat Oct 22 16:10:34 2005
From: frohlich at berlios.de (Mathias Froehlich at BerliOS)
Date: Sat, 22 Oct 2005 16:10:34 +0200
Subject: [OpenFDM-svn] r27 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200510221410.j9MEAYo7013557@sheep.berlios.de>

Author: frohlich
Date: 2005-10-22 16:10:34 +0200 (Sat, 22 Oct 2005)
New Revision: 27

Modified:
   trunk/OpenFDM/src/OpenFDM/Plane.h
Log:
Add missing header.


Modified: trunk/OpenFDM/src/OpenFDM/Plane.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Plane.h	2005-10-22 14:10:16 UTC (rev 26)
+++ trunk/OpenFDM/src/OpenFDM/Plane.h	2005-10-22 14:10:34 UTC (rev 27)
@@ -5,6 +5,7 @@
 #ifndef OpenFDM_Plane_H
 #define OpenFDM_Plane_H
 
+#include "Assert.h"
 #include "Types.h"
 #include "Limits.h"
 #include "Vector.h"
@@ -23,14 +24,10 @@
   {}
   Plane(const Vector3& normal, value_type dist)
     : mNormal(normal), mDist(dist)
-  {
-    OpenFDMAssert((norm(mNormal)-1) < 8*Limits<value_type>::epsilon());
-  }
+  { OpenFDMAssert((norm(mNormal)-1) < 8*Limits<value_type>::epsilon()); }
   Plane(const Vector3& normal, const Vector3& off)
     : mNormal(normal), mDist(-dot(normal, off))
-  {
-    OpenFDMAssert((norm(mNormal)-1) < 8*Limits<value_type>::epsilon());
-  }
+  { OpenFDMAssert((norm(mNormal)-1) < 8*Limits<value_type>::epsilon()); }
 
   const Vector3& getNormal(void) const
   { return mNormal; }



From frohlich at berlios.de  Sat Oct 22 16:49:18 2005
From: frohlich at berlios.de (Mathias Froehlich at BerliOS)
Date: Sat, 22 Oct 2005 16:49:18 +0200
Subject: [OpenFDM-svn] r28 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200510221449.j9MEnIcS015967@sheep.berlios.de>

Author: frohlich
Date: 2005-10-22 16:49:18 +0200 (Sat, 22 Oct 2005)
New Revision: 28

Modified:
   trunk/OpenFDM/src/OpenFDM/Transform.h
Log:
Fix a bug tranforming inertia matrices.


Modified: trunk/OpenFDM/src/OpenFDM/Transform.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Transform.h	2005-10-22 14:10:34 UTC (rev 27)
+++ trunk/OpenFDM/src/OpenFDM/Transform.h	2005-10-22 14:49:18 UTC (rev 28)
@@ -246,12 +246,8 @@
 inline SpatialInertia
 inertiaFrom(const Vector3& p, const Rotation& r, const SpatialInertia& I)
 {
-  InertiaMatrix I11(I(1,1),
-                    I(2,1), I(2,2),
-                    I(3,1), I(3,2), I(3,3));
-  InertiaMatrix I22(I(4,4),
-                    I(5,4), I(5,5),
-                    I(6,4), I(6,5), I(6,6));
+  InertiaMatrix I11(I(1,1), I(2,1), I(3,1), I(2,2), I(3,2), I(3,3));
+  InertiaMatrix I22(I(4,4), I(5,4), I(6,4), I(5,5), I(6,5), I(6,6));
   
   Matrix33 RI11(trans(r.getTransform())*I11);
   Matrix33 RI22(trans(r.getTransform())*I22);
@@ -304,12 +300,8 @@
 inline SpatialInertia
 inertiaFrom(const Vector3& p, const SpatialInertia& I)
 {
-  InertiaMatrix I11(I(1,1),
-                    I(2,1), I(2,2),
-                    I(3,1), I(3,2), I(3,3));
-  InertiaMatrix I22(I(4,4),
-                    I(5,4), I(5,5),
-                    I(6,4), I(6,5), I(6,6));
+  InertiaMatrix I11(I(1,1), I(2,1), I(3,1), I(2,2), I(3,2), I(3,3));
+  InertiaMatrix I22(I(4,4), I(5,4), I(6,4), I(5,5), I(6,5), I(6,6));
   
   SpatialInertia It2;
   It2(4,4) = I22(1,1);
@@ -355,12 +347,8 @@
 inline SpatialInertia
 inertiaFrom(const Rotation& r, const SpatialInertia& I)
 {
-  InertiaMatrix I11(I(1,1),
-                    I(2,1), I(2,2),
-                    I(3,1), I(3,2), I(3,3));
-  InertiaMatrix I22(I(4,4),
-                    I(5,4), I(5,5),
-                    I(6,4), I(6,5), I(6,6));
+  InertiaMatrix I11(I(1,1), I(2,1), I(3,1), I(2,2), I(3,2), I(3,3));
+  InertiaMatrix I22(I(4,4), I(5,4), I(6,4), I(5,5), I(6,5), I(6,6));
   
   Matrix33 RI11(trans(r.getTransform())*I11);
   Matrix33 RI22(trans(r.getTransform())*I22);



From frohlich at berlios.de  Sat Oct 22 16:52:56 2005
From: frohlich at berlios.de (Mathias Froehlich at BerliOS)
Date: Sat, 22 Oct 2005 16:52:56 +0200
Subject: [OpenFDM-svn] r29 - trunk/OpenFDM/src/JSBSim
Message-ID: <200510221452.j9MEquOq016301@sheep.berlios.de>

Author: frohlich
Date: 2005-10-22 16:52:56 +0200 (Sat, 22 Oct 2005)
New Revision: 29

Modified:
   trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
   trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.h
Log:
Implement the vrp somehow ...


Modified: trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
===================================================================
--- trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2005-10-22 14:49:18 UTC (rev 28)
+++ trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2005-10-22 14:52:56 UTC (rev 29)
@@ -535,6 +535,7 @@
   InertiaMatrix I(0, 0, 0, 0, 0, 0);
   real_type mass = 0;
   Vector3 vrp, ap, ep;
+  bool haveVrp = false;
   typedef std::pair<Vector3,real_type> masspoint;
   typedef std::list<masspoint> masslist;
   masslist masses;
@@ -544,88 +545,96 @@
     datastr >> name;
     
     if (name == "AC_WINGAREA") {
-      double value;
+      real_type value;
       datastr >> value;
       mAeroForce->setWingArea(convertFrom(uFoot2, value));
     } else if (name == "AC_WINGSPAN") {
-      double value;
+      real_type value;
       datastr >> value;
       mAeroForce->setWingSpan(convertFrom(uFoot, value));
     } else if (name == "AC_WINGINCIDENCE") {
-      double value;
+      real_type value;
       datastr >> value;
       registerJSBExpression("metrics/iw-deg",
                             Property(new ConstExpressionPropertyImpl<real_type>(value)));
     } else if (name == "AC_CHORD") {
-      double value;
+      real_type value;
       datastr >> value;
       mAeroForce->setCoord(convertFrom(uFoot, value));
     } else if (name == "AC_HTAILAREA") {
-      double value;
+      real_type value;
       datastr >> value;
       registerJSBExpression("metrics/Sh-sqft",
                             Property(new ConstExpressionPropertyImpl<real_type>(value)));
     } else if (name == "AC_HTAILARM") {
-      double value;
+      real_type value;
       datastr >> value;
       registerJSBExpression("metrics/lh-ft",
                             Property(new ConstExpressionPropertyImpl<real_type>(value)));
     } else if (name == "AC_VTAILAREA") {
-      double value;
+      real_type value;
       datastr >> value;
       registerJSBExpression("metrics/Sv-sqft",
                             Property(new ConstExpressionPropertyImpl<real_type>(value)));
     } else if (name == "AC_VTAILARM") {
-      double value;
+      real_type value;
       datastr >> value;
       registerJSBExpression("metrics/lv-ft",
                             Property(new ConstExpressionPropertyImpl<real_type>(value)));
     } else if (name == "AC_IXX") {
-      double value;
+      real_type value;
       datastr >> value;
       I(1, 1) = convertFrom(uSlugFt2, value);
     } else if (name == "AC_IYY") {
-      double value;
+      real_type value;
       datastr >> value;
       I(2, 2) = convertFrom(uSlugFt2, value);
     } else if (name == "AC_IZZ") {
-      double value;
+      real_type value;
       datastr >> value;
       I(3, 3) = convertFrom(uSlugFt2, value);
     } else if (name == "AC_IXY") {
-      double value;
+      real_type value;
       datastr >> value;
       I(1, 2) = -convertFrom(uSlugFt2, value);;
     } else if (name == "AC_IXZ") {
-      double value;
+      real_type value;
       datastr >> value;
       I(1, 3) = -convertFrom(uSlugFt2, value);
     } else if (name == "AC_IYZ") {
-      double value;
+      real_type value;
       datastr >> value;
       I(2, 3) = -convertFrom(uSlugFt2, value);
     } else if (name == "AC_EMPTYWT") {
       datastr >> mass;
       mass = convertFrom(uPoundSealevel, mass);
     } else if (name == "AC_CGLOC") {
-      datastr >> mCG(1) >> mCG(2) >> mCG(3);
+      datastr >> mBodyReference(1) >> mBodyReference(2) >> mBodyReference(3);
     } else if (name == "AC_EYEPTLOC") {
       datastr >> ep(1) >> ep(2) >> ep(3);
     } else if (name == "AC_AERORP") {
       datastr >> ap(1) >> ap(2) >> ap(3);
     } else if (name == "AC_VRP") {
       datastr >> vrp(1) >> vrp(2) >> vrp(3);
+      haveVrp = true;
     } else if (name == "AC_POINTMASS") {
       Vector3 loc;
-      double mpmass;
+      real_type mpmass;
       datastr >> mpmass >> loc(1) >> loc(2) >> loc(3);
       masses.push_back(masspoint(loc, mpmass));
     }
   }
 
+  // In contrast to JSBSim, we have the possibility to simulate around a point
+  // not being the center of gravity, use that here ...
+  Vector3 cg = mBodyReference;
+  if (haveVrp)
+    mBodyReference = vrp;
+
   // Now collect all static inertia values starting with the emptyweight
   // and empty inertia together in spi.
   SpatialInertia spi(I, mass);
+  spi = inertiaFrom(structToBody(cg), spi);
   masslist::iterator it = masses.begin();
   while (it != masses.end()) {
     SpatialInertia inertia(convertFrom(uPoundSealevel, it->second));
@@ -663,7 +672,7 @@
     
     if (uctype == "AC_GEAR") {
       std::string name, type, brake, retract;
-      double x, y, z, k, d, fs, fd, rr, sa;
+      real_type x, y, z, k, d, fs, fd, rr, sa;
       datastr >> name >> x >> y >> z >> k >> d >> fs >> fd >> rr
               >> type >> brake >> sa >> retract;
 
@@ -767,7 +776,7 @@
 
     } else if (uctype == "AC_CONTACT") {
       std::string name, type, brake, retract;
-      double x, y, z, k, d, fs, fd, rr, sa;
+      real_type x, y, z, k, d, fs, fd, rr, sa;
       datastr >> name >> x >> y >> z >> k >> d >> fs >> fd >> rr
               >> type >> brake >> sa >> retract;
 
@@ -1045,7 +1054,7 @@
       break;
 
     if (token == "BIAS") {
-      double value;
+      real_type value;
       datastr >> value;
 
       std::string modelName = std::string("Output Bias for ") + name;
@@ -1057,7 +1066,7 @@
       outbias->setBias(tmp);
       
     } else if (token == "CLIPTO") {
-      double clipmin, clipmax;
+      real_type clipmin, clipmax;
       datastr >> clipmin >> clipmax;
       
       if (!saturation) {
@@ -1074,7 +1083,7 @@
       saturation->setMaxSaturation(tmp);
       
     } else if (token == "C1") {
-      double value;
+      real_type value;
       datastr >> value;
 
       if (type == "INTEGRATOR") {
@@ -1120,7 +1129,7 @@
         return error("No C1 parameter allowed for \"" + type + "\"");
       
     } else if (token == "C2") {
-      double value;
+      real_type value;
       datastr >> value;
 
       if (type == "LEAD_LAG_FILTER") {
@@ -1142,7 +1151,7 @@
         return error("No C2 parameter allowed for \"" + type + "\"");
       
     } else if (token == "C3") {
-      double value;
+      real_type value;
       datastr >> value;
 
       if (type == "LEAD_LAG_FILTER") {
@@ -1165,7 +1174,7 @@
         return error("No C3 parameter allowed for \"" + type + "\"");
       
     } else if (token == "C4") {
-      double value;
+      real_type value;
       datastr >> value;
 
       if (type == "LEAD_LAG_FILTER") {
@@ -1188,7 +1197,7 @@
         return error("No C4 parameter allowed for \"" + type + "\"");
       
     } else if (token == "C5") {
-      double value;
+      real_type value;
       datastr >> value;
 
       if (type == "SECOND_ORDER_FILTER") {
@@ -1203,7 +1212,7 @@
         return error("No C5 parameter allowed for \"" + type + "\"");
       
     } else if (token == "C6") {
-      double value;
+      real_type value;
       datastr >> value;
 
       if (type == "SECOND_ORDER_FILTER") {
@@ -1252,7 +1261,7 @@
         return error("No DETENTS parameter allowed for \"" + type + "\"");
 
     } else if (token == "GAIN") {
-      double value;
+      real_type value;
       datastr >> value;
 
       if (gain) {
@@ -1273,7 +1282,7 @@
       outInvert = true;
       
     } else if (token == "MAX") {
-      double clipmax;
+      real_type clipmax;
       datastr >> clipmax;
       
       if (type == "AEROSURFACE_SCALE") {
@@ -1295,7 +1304,7 @@
       }
       
     } else if (token == "MIN") {
-      double clipmin;
+      real_type clipmin;
       datastr >> clipmin;
       
       if (type == "AEROSURFACE_SCALE") {
@@ -1355,7 +1364,7 @@
       
     } else if (token == "WIDTH") {
       // deadband width
-      double width;
+      real_type width;
       datastr >> width;
 
       if (type == "DEADBAND") {
@@ -1573,11 +1582,11 @@
       datastr >> yaw;
       
     } else if (token == "P_FACTOR") {
-      double d;
+      real_type d;
       datastr >> d;
       
     } else if (token == "SENSE") {
-      double d;
+      real_type d;
       datastr >> d;
       
     } else
@@ -1619,7 +1628,7 @@
       datastr >> yaw;
       
     } else if (token == "FEED") {
-      double d;
+      real_type d;
       datastr >> d;
       
     } else

Modified: trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.h
===================================================================
--- trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.h	2005-10-22 14:49:18 UTC (rev 28)
+++ trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.h	2005-10-22 14:52:56 UTC (rev 29)
@@ -206,13 +206,13 @@
   // For now just copies from the prevous try ...
   Vector3 structToBody(const Vector3& v)
   {
-    Vector3 cgoff = v - mCG;
+    Vector3 cgoff = v - mBodyReference;
     return convertFrom(uInch, Vector3(-cgoff(1), cgoff(2), -cgoff(3)));
   }
   Property mPrevousFCSOutput;
   PropertyMap mExpressionTable;
   shared_ptr<AeroForce> mAeroForce;
-  Vector3 mCG;
+  Vector3 mBodyReference;
 };
 
 } // namespace OpenFDM



From frohlich at berlios.de  Sat Oct 22 20:03:11 2005
From: frohlich at berlios.de (Mathias Froehlich at BerliOS)
Date: Sat, 22 Oct 2005 20:03:11 +0200
Subject: [OpenFDM-svn] r30 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200510221803.j9MI3BvM029944@sheep.berlios.de>

Author: frohlich
Date: 2005-10-22 20:03:10 +0200 (Sat, 22 Oct 2005)
New Revision: 30

Added:
   trunk/OpenFDM/src/OpenFDM/Mutex.h
   trunk/OpenFDM/src/OpenFDM/ScopeLock.h
Modified:
   trunk/OpenFDM/src/OpenFDM/Logger.cpp
Log:
Make the logger visitor somehow more threadsafe.


Modified: trunk/OpenFDM/src/OpenFDM/Logger.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Logger.cpp	2005-10-22 14:52:56 UTC (rev 29)
+++ trunk/OpenFDM/src/OpenFDM/Logger.cpp	2005-10-22 18:03:10 UTC (rev 30)
@@ -5,17 +5,43 @@
 #include <cstdlib>
 #include <iostream>
 #include <sstream>
+
+#include "Mutex.h"
+#include "ScopeLock.h"
 #include "LogStream.h"
 
 namespace OpenFDM {
 
 namespace Log {
 
+static unsigned
+atou(const char* s)
+{
+  if (!s)
+    return 0u;
+
+  std::stringstream strstream(s);
+  unsigned value;
+  strstream >> value;
+  if (!strstream)
+    return 0u;
+
+  return value;
+}
+
 Logger::Logger(std::basic_ostream<char>* stream) :
   mStream(stream),
   mCategory(~0u),
   mPriority(Log::Error)
 {
+  // Set some defaults from the environment
+  unsigned value = atou(std::getenv("OPENFDM_DEBUG_PRIORITY"));
+  if (value)
+    mPriority = value;
+      
+  value = atou(std::getenv("OPENFDM_DEBUG_CATEGORY"));
+  if (value)
+    mCategory = value;
 }
 
 void
@@ -42,37 +68,17 @@
   logger->mPriority = priority;
 }
 
-static unsigned
-atou(const char* s)
-{
-  if (!s)
-    return 0u;
-
-  std::stringstream strstream(s);
-  unsigned value;
-  strstream >> value;
-  if (!strstream)
-    return 0u;
-
-  return value;
-}
-
 Logger*
 Logger::Instance(void)
 {
   static Logger* ptr = 0;
   if (!ptr) {
-    // Create new instance ...
-    ptr = new Logger(&std::cerr);
-    
-    // ... and set some defaults from the environment.
-    unsigned value = atou(std::getenv("OPENFDM_DEBUG_PRIORITY"));
-    if (value)
-      ptr->mPriority = value;
-
-    value = atou(std::getenv("OPENFDM_DEBUG_CATEGORY"));
-    if (value)
-      ptr->mCategory = value;
+    static Mutex mutex;
+    ScopeLock scopeLock(mutex);
+    if (!ptr) {
+      // Create new instance ...
+      ptr = new Logger(&std::cerr);
+    }
   }
   return ptr;
 }

Added: trunk/OpenFDM/src/OpenFDM/Mutex.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Mutex.h	2005-10-22 14:52:56 UTC (rev 29)
+++ trunk/OpenFDM/src/OpenFDM/Mutex.h	2005-10-22 18:03:10 UTC (rev 30)
@@ -0,0 +1,66 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_Mutex_H
+#define OpenFDM_Mutex_H
+
+#ifdef _WIN32
+#include <windows.h>
+#else
+#include <pthread.h>
+#endif
+
+namespace OpenFDM {
+
+class Mutex {
+public:
+  Mutex(void)
+  {
+#ifdef _WIN32
+    InitializeCriticalSection((LPCRITICAL_SECTION)&mCriticalSection);
+#else
+    pthread_mutex_init(&mMutex, NULL);
+#endif
+  }
+  ~Mutex(void)
+  {
+#ifdef _WIN32
+    LeaveCriticalSection((LPCRITICAL_SECTION)&mCriticalSection);
+#else
+    pthread_mutex_destroy(&mMutex);
+#endif
+  }
+
+  void lock(void)
+  {
+#ifdef _WIN32
+    EnterCriticalSection((LPCRITICAL_SECTION)&mCriticalSection);
+#else
+    pthread_mutex_lock(&mMutex);
+#endif
+  }
+
+  void unlock(void)
+  {
+#ifdef _WIN32
+    LeaveCriticalSection((LPCRITICAL_SECTION)&mCriticalSection);
+#else
+    pthread_mutex_unlock(&mMutex);
+#endif
+  }
+
+private:
+  Mutex(const Mutex&);
+  Mutex& operator=(const Mutex&);
+
+#ifdef _WIN32
+  CRITICAL_SECTION mCriticalSection;
+#else
+  pthread_mutex_t mMutex;
+#endif
+};
+
+} // namespace OpenFDM
+
+#endif


Property changes on: trunk/OpenFDM/src/OpenFDM/Mutex.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/OpenFDM/src/OpenFDM/ScopeLock.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/ScopeLock.h	2005-10-22 14:52:56 UTC (rev 29)
+++ trunk/OpenFDM/src/OpenFDM/ScopeLock.h	2005-10-22 18:03:10 UTC (rev 30)
@@ -0,0 +1,29 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_ScopeLock_H
+#define OpenFDM_ScopeLock_H
+
+#include "Mutex.h"
+
+namespace OpenFDM {
+
+class ScopeLock {
+public:
+  ScopeLock(Mutex& mutex) : mMutex(mutex)
+  { mMutex.lock(); }
+  ~ScopeLock(void)
+  { mMutex.unlock(); }
+
+private:
+  ScopeLock(void);
+  ScopeLock(const ScopeLock&);
+  ScopeLock& operator=(const ScopeLock&);
+
+  Mutex& mMutex;
+};
+
+} // namespace OpenFDM
+
+#endif


Property changes on: trunk/OpenFDM/src/OpenFDM/ScopeLock.h
___________________________________________________________________
Name: svn:eol-style
   + native



From frohlich at berlios.de  Sun Oct 23 10:34:52 2005
From: frohlich at berlios.de (Mathias Froehlich at BerliOS)
Date: Sun, 23 Oct 2005 10:34:52 +0200
Subject: [OpenFDM-svn] r31 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200510230834.j9N8YqIL015375@sheep.berlios.de>

Author: frohlich
Date: 2005-10-23 10:34:49 +0200 (Sun, 23 Oct 2005)
New Revision: 31

Modified:
   trunk/OpenFDM/src/OpenFDM/Frame.cpp
   trunk/OpenFDM/src/OpenFDM/Frame.h
   trunk/OpenFDM/src/OpenFDM/Joint.h
Log:
Limit acceleration warning to frames which are
really simulated.


Modified: trunk/OpenFDM/src/OpenFDM/Frame.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Frame.cpp	2005-10-22 18:03:10 UTC (rev 30)
+++ trunk/OpenFDM/src/OpenFDM/Frame.cpp	2005-10-23 08:34:49 UTC (rev 31)
@@ -19,7 +19,7 @@
   mDirtyPos(true),
   mDirtyInVel(true),
   mDirtyInAccel(true),
-  mDisableInAccel(true),
+  mDisableInAccel(false),
   mReferenceFrameId(0)
 {
   setPosition(Vector3::zeros());
@@ -169,7 +169,6 @@
   mDirtyPos = true;
   mDirtyInVel = true;
   mDirtyInAccel = true;
-  mDisableInAccel = true;
   
   // Mark all child dirty.
   ChildFrameList::iterator it = mChildFrames.begin();
@@ -186,7 +185,6 @@
   // Mark ourself dirty.
   mDirtyInVel = true;
   mDirtyInAccel = true;
-  mDisableInAccel = true;
   
   // Mark all child dirty.
   ChildFrameList::iterator it = mChildFrames.begin();

Modified: trunk/OpenFDM/src/OpenFDM/Frame.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Frame.h	2005-10-22 18:03:10 UTC (rev 30)
+++ trunk/OpenFDM/src/OpenFDM/Frame.h	2005-10-23 08:34:49 UTC (rev 31)
@@ -583,6 +583,11 @@
   void setAngularRelAccel(const Vector3& accel)
   { setAccelDirty(); mRelAccel.setAngular(accel); }
 
+  void disableAccel(void)
+  { mDisableInAccel = true; }
+  void enableAccel(void)
+  { mDisableInAccel = false; }
+
 protected:
   void setPosDirty(void)
   {
@@ -606,9 +611,6 @@
   }
   void setAccelDirty(void)
   {
-    // Tell that the accelerations are usable.
-    mDisableInAccel = false;
-
     // Don't bother iterating over all children if we are already dirty.
     if (mDirtyInAccel == true)
       return;

Modified: trunk/OpenFDM/src/OpenFDM/Joint.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Joint.h	2005-10-22 18:03:10 UTC (rev 30)
+++ trunk/OpenFDM/src/OpenFDM/Joint.h	2005-10-23 08:34:49 UTC (rev 31)
@@ -178,6 +178,7 @@
     if (!outboardBody)
       return;
 
+    outboardBody->disableAccel();
     outboardBody->setPosition(pos);
     outboardBody->setOrientation(orient);
     outboardBody->setRelVel(vel);
@@ -189,6 +190,7 @@
     if (!outboardBody)
       return;
 
+    outboardBody->disableAccel();
     outboardBody->setPosition(pos);
   }
   void setOutboardOrientation(const Quaternion& orient)
@@ -197,6 +199,7 @@
     if (!outboardBody)
       return;
 
+    outboardBody->disableAccel();
     outboardBody->setOrientation(orient);
   }
   void setOutboardRelVel(const Vector6& vel)
@@ -205,6 +208,7 @@
     if (!outboardBody)
       return;
 
+    outboardBody->disableAccel();
     outboardBody->setRelVel(vel);
   }
   void setOutboardRelAccel(const Vector6& accel)
@@ -213,6 +217,7 @@
     if (!outboardBody)
       return;
 
+    outboardBody->enableAccel();
     outboardBody->setRelAccel(accel);
   }
 };



From frohlich at berlios.de  Sun Oct 23 10:36:30 2005
From: frohlich at berlios.de (Mathias Froehlich at BerliOS)
Date: Sun, 23 Oct 2005 10:36:30 +0200
Subject: [OpenFDM-svn] r32 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200510230836.j9N8aUiA015613@sheep.berlios.de>

Author: frohlich
Date: 2005-10-23 10:36:29 +0200 (Sun, 23 Oct 2005)
New Revision: 32

Modified:
   trunk/OpenFDM/src/OpenFDM/SimpleGear.cpp
Log:
Make it less stiff, ie. Remove that factor 50.


Modified: trunk/OpenFDM/src/OpenFDM/SimpleGear.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/SimpleGear.cpp	2005-10-23 08:34:49 UTC (rev 31)
+++ trunk/OpenFDM/src/OpenFDM/SimpleGear.cpp	2005-10-23 08:36:29 UTC (rev 32)
@@ -171,8 +171,8 @@
   // The slip angle is the angle between the 'velocity vector' and 
   // the wheel forward direction.
   real_type slipAngle = rad2deg*atan2(wheelVel(2), fabs(wheelVel(1)));
-  if (50*fabs(wheelVel(2)) < fabs(slipAngle))
-    slipAngle = 50*wheelVel(2);
+  if (fabs(wheelVel(2)) < fabs(slipAngle))
+    slipAngle = wheelVel(2);
   
   Vector2 slip(wheelSlip, slipAngle);
 //   if (1 < norm(slip))



From frohlich at berlios.de  Sun Oct 23 11:16:08 2005
From: frohlich at berlios.de (Mathias Froehlich at BerliOS)
Date: Sun, 23 Oct 2005 11:16:08 +0200
Subject: [OpenFDM-svn] r33 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200510230916.j9N9G8eu021221@sheep.berlios.de>

Author: frohlich
Date: 2005-10-23 11:16:08 +0200 (Sun, 23 Oct 2005)
New Revision: 33

Modified:
   trunk/OpenFDM/src/OpenFDM/System.cpp
Log:
Make sure the System's continous states contain
sensible values at the beginning of the simulation.


Modified: trunk/OpenFDM/src/OpenFDM/System.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/System.cpp	2005-10-23 08:36:29 UTC (rev 32)
+++ trunk/OpenFDM/src/OpenFDM/System.cpp	2005-10-23 09:16:08 UTC (rev 33)
@@ -140,7 +140,13 @@
   // restarted. So just set it here.
   Vector state(getNumContinousStates());
   getState(state, 0);
-  mTimestepper->setState(state);
+  // Exact check is currect here, the user does not have to fiddle with
+  // the state during simulation, if the state changes despite of that,
+  // Just spend that extra effort.
+  if (state != mTimestepper->getState()) {
+    mTimestepper->setState(state);
+    evalFunction(mTimestepper->getTime(), mTimestepper->getState(), state);
+  }
 
   while (getTime() < tEnd) {
     // This is the maximum time we can step in this loop



From frohlich at berlios.de  Sun Oct 23 11:16:56 2005
From: frohlich at berlios.de (Mathias Froehlich at BerliOS)
Date: Sun, 23 Oct 2005 11:16:56 +0200
Subject: [OpenFDM-svn] r34 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200510230916.j9N9Guj0021366@sheep.berlios.de>

Author: frohlich
Date: 2005-10-23 11:16:55 +0200 (Sun, 23 Oct 2005)
New Revision: 34

Modified:
   trunk/OpenFDM/src/OpenFDM/Sensor.h
Log:
A very preliminary implementation of an acceleration sensor.


Modified: trunk/OpenFDM/src/OpenFDM/Sensor.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Sensor.h	2005-10-23 09:16:08 UTC (rev 33)
+++ trunk/OpenFDM/src/OpenFDM/Sensor.h	2005-10-23 09:16:55 UTC (rev 34)
@@ -12,86 +12,50 @@
 #include "RigidBody.h"
 #include "Visitor.h"
 #include "ConstVisitor.h"
+#include "MultiBodyModel.h"
 
 namespace OpenFDM {
 
 class Sensor
   : public MultiBodyModel {
 public:
-  Sensor(const std::string& name);
-  virtual ~Sensor(void);
-
-  virtual void accept(Visitor& visitor);
-  virtual void accept(ConstVisitor& visitor) const;
-
-//   virtual Sensor* toSensor(void);
-//   virtual const Sensor* toSensor(void) const;
-
-  Frame* getParentFrame(unsigned idx)
+  Sensor(const std::string& name) :
+    MultiBodyModel(name)
   {
-    Group* g = getParent(idx);
-    if (g)
-      return g->toFrame();
-    else
-      return 0;
+    mAccel.resize(6, 1);
+    setNumOutputPorts(1);
+    setOutputPort(0, "nz", Property(this, &Sensor::getNZ));
   }
-  const Frame* getParentFrame(unsigned idx) const
-  {
-    const Group* g = getParent(idx);
-    if (g)
-      return g->toFrame();
-    else
-      return 0;
-  }
+  virtual ~Sensor(void)
+  { }
 
-  bool setPosition(unsigned frameIdx, const Vector3& pos)
+  virtual void accept(Visitor& visitor)
+  {  visitor.apply(*this); }
+  virtual void accept(ConstVisitor& visitor) const
+  {  visitor.apply(*this); }
+
+  void output(const TaskInfo& taskInfo)
   {
-    if (NumberOfParents <= frameIdx)
-      return false;
+    if (!nonZeroIntersection(taskInfo.getSampleTimeSet(), getSampleTimeSet()))
+        return;
 
-    mPosition[frameIdx] = pos;
-    return true;
+    Frame* frame = getParentFrame(0);
+    if (!frame) {
+      mAccel = Vector6::zeros();
+      return;
+    }
+    mAccel = frame->getInAccel();
   }
 
-  const Vector3& getPosition(unsigned frameIdx) const
+  real_type getNZ(void) const
   {
-    // FIXME, somehow wrong ...
-    if (NumberOfParents <= frameIdx)
-      return mPosition[0];
-    return mPosition[frameIdx];
+    return mAccel(6, 1)/9.81;
   }
 
-  Vector3 getOffset(unsigned frameIdx) const
-  {
-    if (frameIdx == 0) {
-      const Frame* f0 = getParentFrame(0);
-      const Frame* f1 = getParentFrame(1);
-      // FIXME, somehow wrong ...
-      if (!f0 || !f1)
-        return Vector3::zeros();
-      
-      return f1->posFromRef(f0->posToRef(mPosition[0])) - mPosition[1];
-    } else if (frameIdx == 1) {
-      const Frame* f0 = getParentFrame(0);
-      const Frame* f1 = getParentFrame(1);
-      // FIXME, somehow wrong ...
-      if (!f0 || !f1)
-        return Vector3::zeros();
-      
-      return f0->posFromRef(f1->posToRef(mPosition[1])) - mPosition[0];
-    } else
-      return Vector3::zeros();
-  }
-
-  real_type getDistance(void) const
-  { return norm(getOffset(0)); }
-
 private:
- 
+  OpenFDM_NodeImplementation(1);
 
-  Vector3 mPosition[NumberOfParents];
-//   Vector3 mPosition[NumberOfParents];
-
+  Matrix mAccel;
 };
 
 } // namespace OpenFDM



From frohlich at berlios.de  Sun Oct 23 16:00:30 2005
From: frohlich at berlios.de (Mathias Froehlich at BerliOS)
Date: Sun, 23 Oct 2005 16:00:30 +0200
Subject: [OpenFDM-svn] r35 - in trunk/OpenFDM/src/OpenFDM: . LinAlg
Message-ID: <200510231400.j9NE0Uo4008284@sheep.berlios.de>

Author: frohlich
Date: 2005-10-23 16:00:21 +0200 (Sun, 23 Oct 2005)
New Revision: 35

Modified:
   trunk/OpenFDM/src/OpenFDM/AeroForce.cpp
   trunk/OpenFDM/src/OpenFDM/AtmosphereSTD1976.cpp
   trunk/OpenFDM/src/OpenFDM/Expression.h
   trunk/OpenFDM/src/OpenFDM/LinAlg/Algorithm.h
   trunk/OpenFDM/src/OpenFDM/LinAlg/IO.h
   trunk/OpenFDM/src/OpenFDM/ODESolver.cpp
   trunk/OpenFDM/src/OpenFDM/Plane.h
   trunk/OpenFDM/src/OpenFDM/Quaternion.h
   trunk/OpenFDM/src/OpenFDM/SimpleGear.cpp
   trunk/OpenFDM/src/OpenFDM/TransferFunction.cpp
   trunk/OpenFDM/src/OpenFDM/Vehicle.h
Log:
Consotently use fabs in favour of abs


Modified: trunk/OpenFDM/src/OpenFDM/AeroForce.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/AeroForce.cpp	2005-10-23 09:16:55 UTC (rev 34)
+++ trunk/OpenFDM/src/OpenFDM/AeroForce.cpp	2005-10-23 14:00:21 UTC (rev 35)
@@ -277,7 +277,7 @@
 {
   if (mDirtyAlpha) {
     Vector3 V = getAirSpeed().getLinear();
-    if (abs(V(iU)) < Limits<real_type>::min())
+    if (fabs(V(iU)) < Limits<real_type>::min())
       mAlpha = 0;
     else
       mAlpha = atan2(V(iW), V(iU));
@@ -311,7 +311,7 @@
   if (mDirtyBeta) {
     real_type Vuw = getTrueSpeedUW();
     Vector3 V = getAirSpeed().getLinear();
-    if (abs(Vuw) < Limits<real_type>::min())
+    if (fabs(Vuw) < Limits<real_type>::min())
       mBeta = 0;
     else
       mBeta = atan2(V(iV), Vuw);
@@ -401,7 +401,7 @@
 AeroForce::getWingSpanOver2Speed(void) const
 {
   real_type Vt2 = 2*getTrueSpeed();
-  if (abs(Vt2) < Limits<real_type>::min())
+  if (fabs(Vt2) < Limits<real_type>::min())
     return 0;
   else
     return getWingSpan()/Vt2;
@@ -411,7 +411,7 @@
 AeroForce::getCoordOver2Speed(void) const
 {
   real_type Vt2 = 2*getTrueSpeed();
-  if (abs(Vt2) < Limits<real_type>::min())
+  if (fabs(Vt2) < Limits<real_type>::min())
     return 0;
   else
     return getCoord()/Vt2;

Modified: trunk/OpenFDM/src/OpenFDM/AtmosphereSTD1976.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/AtmosphereSTD1976.cpp	2005-10-23 09:16:55 UTC (rev 34)
+++ trunk/OpenFDM/src/OpenFDM/AtmosphereSTD1976.cpp	2005-10-23 14:00:21 UTC (rev 35)
@@ -98,7 +98,7 @@
 #define R_HAT         8314.32    /*  J/kgmol.K (gas const.) */
 
 
-  if (abs(data.temperature) > Limits<real_type>::min())
+  if (fabs(data.temperature) > Limits<real_type>::min())
     data.density = data.pressure / ((R_HAT/MOL_WT)*data.temperature);
   else
     data.density = 0.0;

Modified: trunk/OpenFDM/src/OpenFDM/Expression.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Expression.h	2005-10-23 09:16:55 UTC (rev 34)
+++ trunk/OpenFDM/src/OpenFDM/Expression.h	2005-10-23 14:00:21 UTC (rev 35)
@@ -84,7 +84,7 @@
     public UnaryExpressionImpl<real_type> {
 private:
   virtual real_type getValue(void) const
-  { return abs(mInput.getValue()); }
+  { return fabs(mInput.getValue()); }
 };
 
 class AcosExpressionImpl :

Modified: trunk/OpenFDM/src/OpenFDM/LinAlg/Algorithm.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/LinAlg/Algorithm.h	2005-10-23 09:16:55 UTC (rev 34)
+++ trunk/OpenFDM/src/OpenFDM/LinAlg/Algorithm.h	2005-10-23 14:00:21 UTC (rev 35)
@@ -136,7 +136,7 @@
 {
   typedef typename Impl::value_type value_type;
   value_type nrm = norm(v);
-  if (abs(nrm) < Limits<real_type>::min())
+  if (fabs(nrm) < Limits<real_type>::min())
     return Vector<value_type,n>(v);
   else
     return Vector<value_type,n>((1/nrm)*v);
@@ -162,7 +162,7 @@
   for (j = 1; j <= cols; ++j) {
     value_type sum = static_cast<value_type>(0);
     for (i = 1; i <= rows; ++i)
-      sum += abs(mi(i, j));
+      sum += fabs(mi(i, j));
     if (nrm < sum)
       nrm = sum;
   }
@@ -191,7 +191,7 @@
   for (i = 1; i <= rows; ++i) {
     value_type sum = static_cast<value_type>(0);
     for (j = 1; j <= cols; ++j)
-      sum += abs(mi(i, j));
+      sum += fabs(mi(i, j));
     nrm = nrm < sum ? sum : nrm;
   }
 
@@ -214,7 +214,7 @@
   size_type rows = vi.rows();
   size_type i;
   for (i = 1; i <= rows; ++i) {
-    value_type absval = abs(vi(i, 1));
+    value_type absval = fabs(vi(i, 1));
     if (maximum < absval) {
       maximum = absval;
       idx = i;
@@ -305,7 +305,7 @@
   for (i = 1; i <= rows; ++i) {
     value_type v1 = V1i(i);
     value_type v2 = V2i(i);
-    value_type d = (v1 - v2)/(atol + rtol*max(abs(v1), abs(v2)));
+    value_type d = (v1 - v2)/(atol + rtol*max(fabs(v1), fabs(v2)));
     nrmd += d*d;
   }
 
@@ -343,7 +343,7 @@
   for (i = 1; i <= rows; ++i) {
     value_type v1 = V1i(i, 1);
     value_type v2 = V2i(i, 1);
-    value_type d = (v1 - v2)/(atol + rtol*max(abs(v1), abs(v2)));
+    value_type d = (v1 - v2)/(atol + rtol*max(fabs(v1), fabs(v2)));
     nrmd += d*d;
   }
 
@@ -381,7 +381,7 @@
   for (i = 1; i <= rows; ++i) {
     value_type s = scalei(i, 1);
     value_type e = erri(i, 1);
-    value_type d = e/(atol + rtol*max(max(abs(s), abs(s+e)), abs(s-e)));
+    value_type d = e/(atol + rtol*max(max(fabs(s), fabs(s+e)), fabs(s-e)));
     nrmd += d*d;
   }
 
@@ -603,7 +603,7 @@
       value_type Aii = A(i,i);
       // If the matrix is exactly singular, compute the solution where the
       // righthandside is projected into the image of the matrix.
-      if (abs(Aii) < Limits<value_type>::min()) {
+      if (fabs(Aii) < Limits<value_type>::min()) {
         v(i) = static_cast<value_type>(0);
       } else {
         v(i) /= Aii;
@@ -631,7 +631,7 @@
         value_type Aii = A(i,i);
         // If the matrix is exactly singular, compute the solution where the
         // righthandside is projected into the image of the matrix.
-        if (abs(Aii) < Limits<value_type>::min()) {
+        if (fabs(Aii) < Limits<value_type>::min()) {
           v(i,j) = static_cast<value_type>(0);
         } else {
           v(i,j) /= Aii;
@@ -747,7 +747,7 @@
   size_type j;
   for (j = 1; j <= n; ++j) {
     // The matrix is exactly singular.
-    if (abs(A(j,j)) < Limits<value_type>::min())
+    if (fabs(A(j,j)) < Limits<value_type>::min())
       nonsingular = false;
     else {
       if (j < n) {
@@ -782,7 +782,7 @@
     perm(j) = jp;
 
     // The matrix is exactly singular.
-    if (abs(A(jp,j)) < Limits<value_type>::min())
+    if (fabs(A(jp,j)) < Limits<value_type>::min())
       nonsingular = false;
     else {
       if (jp != j) {
@@ -869,7 +869,7 @@
     value_type eps = Limits<value_type>::epsilon();
     value_type safmin = mn/eps;
 
-    if (abs(beta) < safmin) {
+    if (fabs(beta) < safmin) {
       value_type rsafmn = 1/safmin;
       size_type knt = 0;
       do {
@@ -877,7 +877,7 @@
         x *= rsafmn;
         beta *= rsafmn;
         alpha *= rsafmn;
-      } while (abs(beta) < safmin);
+      } while (fabs(beta) < safmin);
 
       xnorm = norm(x);
       beta = sqrt(alpha*alpha + xnorm*xnorm);
@@ -923,7 +923,7 @@
 
     // Check if that thing is singular.
     value_type Ajj = A(j, j);
-    if (abs(Ajj) < Limits<value_type>::min())
+    if (fabs(Ajj) < Limits<value_type>::min())
       nonsingular = false;
 
     A(j, j) = 1;

Modified: trunk/OpenFDM/src/OpenFDM/LinAlg/IO.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/LinAlg/IO.h	2005-10-23 09:16:55 UTC (rev 34)
+++ trunk/OpenFDM/src/OpenFDM/LinAlg/IO.h	2005-10-23 14:00:21 UTC (rev 35)
@@ -47,12 +47,12 @@
 
     for (j = 1; j <= cols; ++j) {
       value_type val = A.asImpl()(i, j);
-      value_type absval = abs(val);
+      value_type absval = fabs(val);
     
       if (absval == 0.0) {
         os << std::setw(width) << '0' << ' ';
       } else {
-        int expo = static_cast<int>(floor(abs(log10(absval))));
+        int expo = static_cast<int>(floor(fabs(log10(absval))));
         
         if (expo < 100) {
           os << std::setprecision(width-7);

Modified: trunk/OpenFDM/src/OpenFDM/ODESolver.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/ODESolver.cpp	2005-10-23 09:16:55 UTC (rev 34)
+++ trunk/OpenFDM/src/OpenFDM/ODESolver.cpp	2005-10-23 14:00:21 UTC (rev 35)
@@ -24,7 +24,7 @@
 ODESolver::reached(real_type tEnd)
 {
   real_type eps = Limits<real_type>::epsilon();
-  bool reached = abs(tEnd - mTime) < 4*eps*max(abs(tEnd), abs(mTime));
+  bool reached = fabs(tEnd - mTime) < 4*eps*max(fabs(tEnd), fabs(mTime));
   if (reached)
     mTime = tEnd;
   return reached;

Modified: trunk/OpenFDM/src/OpenFDM/Plane.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Plane.h	2005-10-23 09:16:55 UTC (rev 34)
+++ trunk/OpenFDM/src/OpenFDM/Plane.h	2005-10-23 14:00:21 UTC (rev 35)
@@ -76,7 +76,7 @@
     value_type tmp = dot(ndir, mNormal);
 
     // Check if the line is parallel to the plane.
-    if (abs(tmp) < Limits<value_type>::epsilon())
+    if (fabs(tmp) < Limits<value_type>::epsilon())
       return false;
 
     ip = base - (getDist(base)/tmp)*ndir;

Modified: trunk/OpenFDM/src/OpenFDM/Quaternion.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Quaternion.h	2005-10-23 09:16:55 UTC (rev 34)
+++ trunk/OpenFDM/src/OpenFDM/Quaternion.h	2005-10-23 14:00:21 UTC (rev 35)
@@ -295,7 +295,7 @@
     Vector3 nv1 = (1/nrmv1)*v1;
     Vector3 nv2 = (1/nrmv2)*v2;
     value_type dv1v2 = dot(nv1, nv2);
-    if (abs(abs(dv1v2)-1) < Limits<value_type>::epsilon())
+    if (fabs(fabs(dv1v2)-1) < Limits<value_type>::epsilon())
       return Quaternion::unit(1);
 
     // The first rotation can be done with the usual routine.
@@ -342,9 +342,9 @@
   {
     // The vector from points to the oposite direction than to.
     // Find a vector perpandicular to the vector to.
-    value_type absv1 = abs(v(1));
-    value_type absv2 = abs(v(2));
-    value_type absv3 = abs(v(3));
+    value_type absv1 = fabs(v(1));
+    value_type absv2 = fabs(v(2));
+    value_type absv3 = fabs(v(3));
     
     Vector3 axis;
     if (absv2 < absv1 && absv3 < absv1) {

Modified: trunk/OpenFDM/src/OpenFDM/SimpleGear.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/SimpleGear.cpp	2005-10-23 09:16:55 UTC (rev 34)
+++ trunk/OpenFDM/src/OpenFDM/SimpleGear.cpp	2005-10-23 14:00:21 UTC (rev 35)
@@ -177,9 +177,9 @@
   Vector2 slip(wheelSlip, slipAngle);
 //   if (1 < norm(slip))
 //     slip = normalize(slip);
-  if (1 < abs(wheelSlip))
+  if (1 < fabs(wheelSlip))
     slip(1) = sign(wheelSlip);
-  if (1 < abs(slipAngle))
+  if (1 < fabs(slipAngle))
     slip(2) = sign(slipAngle);
   
   // The friction force for fast movement.

Modified: trunk/OpenFDM/src/OpenFDM/TransferFunction.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/TransferFunction.cpp	2005-10-23 09:16:55 UTC (rev 34)
+++ trunk/OpenFDM/src/OpenFDM/TransferFunction.cpp	2005-10-23 14:00:21 UTC (rev 35)
@@ -149,7 +149,7 @@
       /// On dimensional exponetial integrator ...
       real_type z = -dt*dot(mDenNorm, mState);
       // Well, pade approximation is the right thing, but for now ...
-      if (abs(exp(z) - 1) <= sqrt(Limits<real_type>::epsilon()))
+      if (fabs(exp(z) - 1) <= sqrt(Limits<real_type>::epsilon()))
         mState(1) += dt*(input + z);
       else
         mState(1) += dt*(exp(z)-1)/z * (input + z);

Modified: trunk/OpenFDM/src/OpenFDM/Vehicle.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Vehicle.h	2005-10-23 09:16:55 UTC (rev 34)
+++ trunk/OpenFDM/src/OpenFDM/Vehicle.h	2005-10-23 14:00:21 UTC (rev 35)
@@ -24,6 +24,7 @@
 class JSBReader;
 class System;
 
+/// FIXME: Derive that from System or something like that
 class Vehicle :
     public Object {
 public:



From frohlich at berlios.de  Mon Oct 24 20:22:19 2005
From: frohlich at berlios.de (Mathias Froehlich at BerliOS)
Date: Mon, 24 Oct 2005 20:22:19 +0200
Subject: [OpenFDM-svn] r36 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200510241822.j9OIMJmw004461@sheep.berlios.de>

Author: frohlich
Date: 2005-10-24 20:22:17 +0200 (Mon, 24 Oct 2005)
New Revision: 36

Modified:
   trunk/OpenFDM/src/OpenFDM/Referenced.h
Log:
Make sure reference counts behave well under copying


Modified: trunk/OpenFDM/src/OpenFDM/Referenced.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Referenced.h	2005-10-23 14:00:21 UTC (rev 35)
+++ trunk/OpenFDM/src/OpenFDM/Referenced.h	2005-10-24 18:22:17 UTC (rev 36)
@@ -9,7 +9,14 @@
 
 class Referenced {
 public:
-  Referenced(void) : _refcount(0u) {}
+  Referenced(void) : _refcount(0u)
+  {}
+  /// Do not copy reference counts. Each new object has it's own counter
+  Referenced(const Referenced&) : _refcount(0u)
+  {}
+  /// Do not copy reference counts. Each new object has it's own counter
+  Referenced& operator=(const Referenced&)
+  { return *this; }
 
   static unsigned get(const Referenced* ref)
   { if (ref) return ++(ref->_refcount); else return ~0u; }



From frohlich at berlios.de  Mon Oct 24 22:22:59 2005
From: frohlich at berlios.de (Mathias Froehlich at BerliOS)
Date: Mon, 24 Oct 2005 22:22:59 +0200
Subject: [OpenFDM-svn] r37 - in trunk/OpenFDM/src: JSBSim OpenFDM OpenFDM/XML
Message-ID: <200510242022.j9OKMx6W029180@sheep.berlios.de>

Author: frohlich
Date: 2005-10-24 22:22:59 +0200 (Mon, 24 Oct 2005)
New Revision: 37

Modified:
   trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
   trunk/OpenFDM/src/OpenFDM/Table.h
   trunk/OpenFDM/src/OpenFDM/XML/Tablereader.cpp
Log:
Rework the tables a bit. Fix table interpolation bug.


Modified: trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
===================================================================
--- trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2005-10-24 18:22:17 UTC (rev 36)
+++ trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2005-10-24 20:22:59 UTC (rev 37)
@@ -23,6 +23,7 @@
 #include <OpenFDM/Mass.h>
 #include <OpenFDM/Product.h>
 #include <OpenFDM/Saturation.h>
+#include <OpenFDM/Sensor.h>
 #include <OpenFDM/SimpleContact.h>
 #include <OpenFDM/SimpleGear.h>
 #include <OpenFDM/Summer.h>
@@ -534,8 +535,11 @@
 
   InertiaMatrix I(0, 0, 0, 0, 0, 0);
   real_type mass = 0;
-  Vector3 vrp, ap, ep;
+  Vector3 vrp = Vector3::zeros();
   bool haveVrp = false;
+  Vector3 ap = Vector3::zeros();
+  Vector3 ep = Vector3::zeros();
+  bool haveEp = false;
   typedef std::pair<Vector3,real_type> masspoint;
   typedef std::list<masspoint> masslist;
   masslist masses;
@@ -612,6 +616,7 @@
       datastr >> mBodyReference(1) >> mBodyReference(2) >> mBodyReference(3);
     } else if (name == "AC_EYEPTLOC") {
       datastr >> ep(1) >> ep(2) >> ep(3);
+      haveEp = true;
     } else if (name == "AC_AERORP") {
       datastr >> ap(1) >> ap(2) >> ap(3);
     } else if (name == "AC_VRP") {
@@ -630,6 +635,8 @@
   Vector3 cg = mBodyReference;
   if (haveVrp)
     mBodyReference = vrp;
+  if (!haveEp)
+    ep = cg;
 
   // Now collect all static inertia values starting with the emptyweight
   // and empty inertia together in spi.
@@ -643,15 +650,19 @@
   }
   mVehicle->getTopBody()->addMultiBodyModel(new Mass(spi));
 
-  // Attach the visual reference point.
-  FreeFrame* vrpFrame = new FreeFrame;
-  vrpFrame->setPosition(structToBody(vrp));
-  mVehicle->getTopBody()->addChildFrame(vrpFrame);
-
   // Attach the eye point.
-  FreeFrame* epFrame = new FreeFrame;
+  FreeFrame* epFrame = new FreeFrame("Eyepoint Frame");
   epFrame->setPosition(structToBody(ep));
+  epFrame->setRelVel(Vector6::zeros());
+  epFrame->setRelAccel(Vector6::zeros());
+  Sensor* accelSensor = new Sensor("Acceleration Sensor");
+  accelSensor->addSampleTime(SampleTime(1.0/120));
+  Property prop = accelSensor->getOutputPort("nz");
+  registerJSBExpression("accelerations/n-pilot-z-norm", prop);
+//   epFrame->addMultiBodyModel(accelSensor);
+  mVehicle->getTopBody()->addMultiBodyModel(accelSensor);
   mVehicle->getTopBody()->addChildFrame(epFrame);
+  addOutputModel(prop, "Normalized load value", "/accelerations/nlf");
 
   // Set the position of the aerodynamic force frame.
   mAeroForce->setPosition(structToBody(ap));
@@ -945,9 +956,9 @@
 
     table1D = new Table1D(name);
     TableLookup tl;
-    tl.addBreakPoint(-1);
-    tl.addBreakPoint(0);
-    tl.addBreakPoint(1);
+    tl.setAtIndex(1, -1);
+    tl.setAtIndex(2, 0);
+    tl.setAtIndex(3, 1);
     table1D->setTableLookup(tl);
     TableData<1>::SizeVector sv;
     sv(1) = 3;
@@ -1347,7 +1358,8 @@
       sz(1) = rows;
       TableData<1> tableData(sz);
       TableLookup lookup;
-      parseTable1D(datastr, tableData, lookup);
+      if (!parseTable1D(datastr, tableData, lookup))
+        return error("Cannot parse lookup table for \"" + type + "\"");
 
       if (table1D) {
         table1D->setTableData(tableData);
@@ -1744,7 +1756,7 @@
 {
   ProductExpressionImpl* prod = new ProductExpressionImpl;
 
-  int ndims;
+  unsigned ndims;
   if (type == "VALUE") {
     ndims = 0;
   } else if (type == "VECTOR") {
@@ -1766,13 +1778,13 @@
   datastr >> token;
 
   // The number of table entries 
-  int n[3] = { 0 };
-  for (int i = 0; i < ndims; ++i)
+  unsigned n[3] = { 0 };
+  for (unsigned i = 0; i < ndims; ++i)
     datastr >> n[i];
 
   // The table lookup values.
   Property inVal[3];
-  for (int i = 0; i < ndims; ++i) {
+  for (unsigned i = 0; i < ndims; ++i) {
     datastr >> token;
     inVal[i] = lookupJSBExpression(token);
   }
@@ -1803,7 +1815,9 @@
     size(1) = n[0];
     TableData<1> table(size);
     TableLookup lookup;
-    parseTable1D(datastr, table, lookup);
+    if (!parseTable1D(datastr, table, lookup))
+      // FIXME
+      std::cerr << "Cannot parse " + type + " table" << std::endl;
     TableExpressionImpl<1>* ti = new TableExpressionImpl<1>();
     ti->setTable(table);
     ti->setTableLookup(0, lookup);
@@ -1816,7 +1830,9 @@
     size(2) = n[1];
     TableData<2> table(size);
     TableLookup lookup[2];
-    parseTable2D(datastr, table, lookup);
+    if (!parseTable2D(datastr, table, lookup))
+      // FIXME
+      std::cerr << "Cannot parse " + type + " table" << data << std::endl;
     TableExpressionImpl<2>* ti = new TableExpressionImpl<2>();
     ti->setTable(table);
     for (unsigned i = 0; i < 2; ++i) {
@@ -1832,7 +1848,9 @@
     size(3) = n[2];
     TableData<3> table(size);
     TableLookup lookup[3];
-    parseTable3D(datastr, table, lookup);
+    if (!parseTable3D(datastr, table, lookup))
+      // FIXME
+      std::cerr << "Cannot parse " + type + " table" << std::endl;
     TableExpressionImpl<3>* ti = new TableExpressionImpl<3>();
     ti->setTable(table);
     for (unsigned i = 0; i < 3; ++i) {

Modified: trunk/OpenFDM/src/OpenFDM/Table.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Table.h	2005-10-24 18:22:17 UTC (rev 36)
+++ trunk/OpenFDM/src/OpenFDM/Table.h	2005-10-24 20:22:59 UTC (rev 37)
@@ -17,39 +17,118 @@
   InterploationData(void) {}
   InterploationData(unsigned index0, unsigned index1, real_type _theta)
   {
-    theta[0] = _theta;
-    theta[1] = 1 - _theta;
+    weight[0] = 1 - _theta;
+    weight[1] = _theta;
     index[0] = index0;
     index[1] = index1;
   }
-  real_type theta[2];
+  real_type weight[2];
   unsigned index[2];
 };
 
 class TableLookup {
-private:
-  /// FIXME may be use a std::vector for that.
-  typedef std::map<real_type,unsigned> Table;
-
+  typedef std::map<real_type, unsigned> Table;
+  typedef std::pair<real_type, unsigned> Pair;
+  
+  
 public:
   TableLookup(void)
   {}
 
-  unsigned size(void) const
-  { return mTable.size(); }
-
-  void addBreakPoint(real_type value)
+  /// Return the breakpoint at the given index i
+  /// If it does not exist in the lookup table, zero is returned
+  real_type getAtIndex(unsigned i) const
   {
-    mTable[value] = 0;
-    unsigned index = 1;
+    Table::const_iterator it;
+    for (it = mTable.begin(); it != mTable.end(); ++it) {
+      if (it->second == i)
+        return it->first;
+    }
+    return 0;
+  }
+  /// Set the breakpoint value at index i, the lookup table is extended if
+  /// required. Keep in mind, that the table lookup behaves undefined if
+  /// the sequence of indices does not increase or decrease strictly monotonic
+  /// with the values.
+  void setAtIndex(unsigned i, real_type value)
+  {
     Table::iterator it = mTable.begin();
     while (it != mTable.end()) {
-      it->second = index;
-      ++index;
-      ++it;
+      if (it->second == i) {
+        mTable.erase(it);
+        it = mTable.begin();
+      }
+      else
+        ++it;
     }
+    mTable.insert(it, Pair(value, i));
   }
 
+  /// Returns the size of the lookup table
+  unsigned size(void) const
+  {
+    unsigned sz = 0;
+    Table::const_iterator it;
+    for (it = mTable.begin(); it != mTable.end(); ++it) {
+      sz = max(sz, it->second);
+    }
+    return sz;
+  }
+
+  /// Check for consistency, that is, the breakpoint indices are strictly
+  /// ordered and there are no holes in the sequence of indices
+  bool isValid(void) const
+  {
+    Table::const_iterator it = mTable.begin();
+    if (it == mTable.end())
+      return false;
+    int indexDir = 0;
+    int valueDir = 0;
+    real_type prevValue = it->first;
+    unsigned prevIndex = it->second;
+    for (++it; it != mTable.end(); ++it) {
+      // We do not yet know which direction we should check
+      if (indexDir == 0) {
+        // Check for the direction of the indices
+        if (prevIndex + 1 == it->second) {
+          indexDir = 1;
+        } else if (prevIndex == it->second + 1) {
+          indexDir = -1;
+        } else {
+          // Duplicate index ...
+          return false;
+        }
+        
+        // Check for the direction of the lookup keys
+        if (prevValue < it->first) {
+          valueDir = 1;
+        } else if (prevValue > it->first) {
+          valueDir = -1;
+        } else {
+          // Duplicate lookup keys ...
+          return false;
+        }
+
+      } else if (indexDir == -1) {
+        // Check if the direction is still the same
+        if (prevIndex != it->second + 1)
+          return false;
+        if (prevValue*valueDir >= it->first*valueDir)
+          return false;
+      } else {
+        // Check if the direction is still the same
+        if (prevIndex + 1 != it->second)
+          return false;
+        if (prevValue*valueDir >= it->first*valueDir)
+          return false;
+      }
+
+      prevValue = it->first;
+      prevIndex = it->second;
+    }
+    return true;
+  }
+
   InterploationData lookup(real_type input) const
   {
     // Empty table??
@@ -168,11 +247,11 @@
     real_type value = 0;
 
     curIndex(indexNum) = interp(indexNum).index[0];
-    value += interp(indexNum).theta[0] *
+    value += interp(indexNum).weight[0] *
       interpolator(indexNum-1, curIndex, interp);
 
     curIndex(indexNum) = interp(indexNum).index[1];
-    value += interp(indexNum).theta[1] *
+    value += interp(indexNum).weight[1] *
       interpolator(indexNum-1, curIndex, interp);
 
     return value;

Modified: trunk/OpenFDM/src/OpenFDM/XML/Tablereader.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/XML/Tablereader.cpp	2005-10-24 18:22:17 UTC (rev 36)
+++ trunk/OpenFDM/src/OpenFDM/XML/Tablereader.cpp	2005-10-24 20:22:59 UTC (rev 37)
@@ -18,12 +18,12 @@
     real_type in = 0;
     real_type out = 0;
     s >> in >> out;
-    lookup.addBreakPoint(in);
+    lookup.setAtIndex(i, in);
     TableData<1>::Index iv;
     iv(1) = i;
     data(iv) = out;
   }
-  return lookup.size() == data.size(1) && s;
+  return lookup.isValid() && lookup.size() == data.size(1) && s;
 }
 
 bool
@@ -33,17 +33,18 @@
   for (unsigned j = 1; s && j <= data.size(2); ++j) {
     real_type in = 0;
     s >> in;
-    lookup[1].addBreakPoint(in);
+    lookup[1].setAtIndex(j, in);
   }
-  if (lookup[1].size() != data.size(2))
+
+  if (!lookup[1].isValid() || lookup[1].size() != data.size(2))
     return false;
   
   for (unsigned i = 1; s && i <= data.size(1); ++i) {
     real_type in = 0;
     s >> in;
-    
-    lookup[0].addBreakPoint(in);
 
+    lookup[0].setAtIndex(i, in);
+
     for (unsigned j = 1; s && j <= data.size(2); ++j) {
       real_type out = 0;
       s >> out;
@@ -54,7 +55,7 @@
       data(iv) = out;
     }
   }
-  return lookup[0].size() == data.size(1) && s;
+  return lookup[0].isValid() && lookup[0].size() == data.size(1) && s;
 }
 
 bool
@@ -63,21 +64,21 @@
   for (unsigned k = 1; s && k <= data.size(3); ++k) {
     real_type in = 0;
     s >> in;
-    lookup[2].addBreakPoint(in);
+    lookup[2].setAtIndex(k, in);
 
     for (unsigned j = 1; s && j <= data.size(2); ++j) {
       real_type in = 0;
       s >> in;
-      lookup[1].addBreakPoint(in);
+      lookup[1].setAtIndex(j, in);
     }
-    if (lookup[1].size() != data.size(2))
+    if (!lookup[1].isValid() || lookup[1].size() != data.size(2))
       return false;
     
     for (unsigned i = 1; s && i <= data.size(1); ++i) {
       real_type in = 0;
       s >> in;
       
-      lookup[0].addBreakPoint(in);
+      lookup[0].setAtIndex(i, in);
       
       for (unsigned j = 1; s && j <= data.size(2); ++j) {
         real_type out = 0;
@@ -91,8 +92,8 @@
       }
     }
   }
-  return lookup[0].size() == data.size(1) &&
-    lookup[2].size() == data.size(3) && s;
+  return lookup[0].isValid() && lookup[0].size() == data.size(1) &&
+    lookup[2].isValid() && lookup[2].size() == data.size(3) && s;
 }
 
 } // namespace OpenFDM



From frohlich at berlios.de  Wed Oct 26 19:54:33 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Wed, 26 Oct 2005 19:54:33 +0200
Subject: [OpenFDM-svn] r38 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200510261754.j9QHsXZM016386@sheep.berlios.de>

Author: frohlich
Date: 2005-10-26 19:53:47 +0200 (Wed, 26 Oct 2005)
New Revision: 38

Modified:
   trunk/OpenFDM/src/OpenFDM/Planet.cpp
   trunk/OpenFDM/src/OpenFDM/Quaternion.h
   trunk/OpenFDM/src/OpenFDM/Units.cpp
   trunk/OpenFDM/src/OpenFDM/Units.h
   trunk/OpenFDM/src/OpenFDM/Vehicle.cpp
Log:
Clean up Quaternions a bit.


Modified: trunk/OpenFDM/src/OpenFDM/Planet.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Planet.cpp	2005-10-24 20:22:59 UTC (rev 37)
+++ trunk/OpenFDM/src/OpenFDM/Planet.cpp	2005-10-26 17:53:47 UTC (rev 38)
@@ -55,8 +55,7 @@
 Quaternion
 Planet::getGeodHLOrientation(const Geodetic& pos) const
 {
-  return Quaternion::fromEulerSeq(3, pos.longitude,
-                                  2, -0.5*M_PI-pos.latitude);
+  return Quaternion::fromLonLat(pos.longitude, pos.latitude);
 }
 
 Quaternion
@@ -86,8 +85,7 @@
 Quaternion
 Planet::getGeocHLOrientation(const Geocentric& pos) const
 {
-  return Quaternion::fromEulerSeq(3, pos.longitude,
-                                  2, -0.5*pi-pos.latitude);
+  return Quaternion::fromLonLat(pos.longitude, pos.latitude);
 }
 
 Vector3

Modified: trunk/OpenFDM/src/OpenFDM/Quaternion.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Quaternion.h	2005-10-24 20:22:59 UTC (rev 37)
+++ trunk/OpenFDM/src/OpenFDM/Quaternion.h	2005-10-26 17:53:47 UTC (rev 38)
@@ -52,7 +52,8 @@
 
   OpenFDM_LinAlg_INLINE
   bool isIdentity(void) const
-  { return fabs(fabs((*this)(1))-1) < Limits<T>::epsilon() &&
+  {
+    return fabs(fabs((*this)(1))-1) < Limits<T>::epsilon() &&
       fabs((*this)(2)) < Limits<T>::epsilon() &&
       fabs((*this)(3)) < Limits<T>::epsilon() &&
       fabs((*this)(4)) < Limits<T>::epsilon();
@@ -106,25 +107,25 @@
 
     value_type tmp = sqrQ1 - sqrQ2 - sqrQ3 + sqrQ4;
     if (fabs(tmp) < Limits<value_type>::min())
-      angles(1) = 0.5*pi;
+      angles(1) = pi05;
     else
       angles(1) = atan2(2*(q3*q4 + q1*q2), tmp);
     
     tmp = 2*(q2*q4 - q1*q3);
     if (tmp < -1.0)
-      angles(2) = 0.5*pi;
+      angles(2) = pi05;
     else if (1.0 < tmp)
-      angles(2) = -0.5*pi;
+      angles(2) = -pi05;
     else
       angles(2) = -asin(tmp);
     
     tmp = sqrQ1 + sqrQ2 - sqrQ3 - sqrQ4;
     if (fabs(tmp) < Limits<value_type>::min())
-      angles(3) = 0.5*pi;
+      angles(3) = pi05;
     else {
       value_type psi = atan2(2*(q2*q3 + q1*q4), tmp);
       if (psi < 0.0)
-        psi += 2.0*pi;
+        psi += pi2;
       angles(3) = psi;
     }
 
@@ -227,31 +228,51 @@
     return q1*q2*q3;
   }
 
-  static Quaternion fromHeadAttBank(value_type tht, value_type psi, value_type phi)
+  static Quaternion fromEuler(value_type z, value_type y, value_type x)
   {
-    value_type thtd2 = 0.5*tht;
-    value_type psid2 = 0.5*psi;
-    value_type phid2 = 0.5*phi;
+    value_type zd2 = 0.5*z;
+    value_type yd2 = 0.5*y;
+    value_type xd2 = 0.5*x;
     
-    value_type Sthtd2 = sin(thtd2);
-    value_type Spsid2 = sin(psid2);
-    value_type Sphid2 = sin(phid2);
+    value_type Szd2 = sin(zd2);
+    value_type Syd2 = sin(yd2);
+    value_type Sxd2 = sin(xd2);
     
-    value_type Cthtd2 = cos(thtd2);
-    value_type Cpsid2 = cos(psid2);
-    value_type Cphid2 = cos(phid2);
+    value_type Czd2 = cos(zd2);
+    value_type Cyd2 = cos(yd2);
+    value_type Cxd2 = cos(xd2);
     
-    value_type Cphid2Cthtd2 = Cphid2*Cthtd2;
-    value_type Cphid2Sthtd2 = Cphid2*Sthtd2;
-    value_type Sphid2Sthtd2 = Sphid2*Sthtd2;
-    value_type Sphid2Cthtd2 = Sphid2*Cthtd2;
+    value_type Cxd2Czd2 = Cxd2*Czd2;
+    value_type Cxd2Szd2 = Cxd2*Szd2;
+    value_type Sxd2Szd2 = Sxd2*Szd2;
+    value_type Sxd2Czd2 = Sxd2*Czd2;
     
-    return Quaternion( Cphid2Cthtd2*Cpsid2 + Sphid2Sthtd2*Spsid2,
-                       Sphid2Cthtd2*Cpsid2 - Cphid2Sthtd2*Spsid2,
-                       Cphid2Cthtd2*Spsid2 + Sphid2Sthtd2*Cpsid2,
-                       Cphid2Sthtd2*Cpsid2 - Sphid2Cthtd2*Spsid2);
+    return Quaternion( Cxd2Czd2*Cyd2 + Sxd2Szd2*Syd2,
+                       Sxd2Czd2*Cyd2 - Cxd2Szd2*Syd2,
+                       Cxd2Czd2*Syd2 + Sxd2Szd2*Cyd2,
+                       Cxd2Szd2*Cyd2 - Sxd2Czd2*Syd2);
   }
 
+  static Quaternion fromYawPitchRoll(value_type y, value_type p, value_type r)
+  { return fromEuler(y, p, r); }
+
+  static Quaternion fromHeadAttBank(value_type h, value_type a, value_type b)
+  { return fromEuler(h, a, b); }
+
+  static Quaternion fromLonLat(value_type lon, value_type lat)
+  {
+    value_type zd2 = 0.5*lon;
+    value_type yd2 = - pi025 - 0.5*lat;
+    
+    value_type Szd2 = sin(zd2);
+    value_type Syd2 = sin(yd2);
+    
+    value_type Czd2 = cos(zd2);
+    value_type Cyd2 = cos(yd2);
+    
+    return Quaternion( Czd2*Cyd2, -Szd2*Syd2, Czd2*Syd2, Szd2*Cyd2);
+  }
+
   static Quaternion fromAngleAxis(value_type angle, const Vector3& axis)
   {
     value_type angle2 = 0.5*angle;
@@ -328,10 +349,10 @@
   }
 
 
+//   OpenFDM_LinAlg_INLINE
+//   static Quaternion zeros(void)
+//   { return Quaternion(Vector4<T>::zeros()); }
   OpenFDM_LinAlg_INLINE
-  static Quaternion zeros(void)
-  { return Quaternion(Vector4<T>::zeros()); }
-  OpenFDM_LinAlg_INLINE
   static Quaternion unit(unsigned i = 1)
   { return Quaternion(Vector4<T>::unit(i)); }
 

Modified: trunk/OpenFDM/src/OpenFDM/Units.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Units.cpp	2005-10-24 20:22:59 UTC (rev 37)
+++ trunk/OpenFDM/src/OpenFDM/Units.cpp	2005-10-26 17:53:47 UTC (rev 38)
@@ -14,9 +14,10 @@
 #endif
 #define PI static_cast<real_type>(3.1415926535897932384626433832795029L)
 
+const real_type pi2 = 2*PI;
 const real_type pi = PI;
-const real_type pi2 = static_cast<real_type>(0.5L)*PI;
-const real_type pi4 = static_cast<real_type>(0.25L)*PI;
+const real_type pi05 = static_cast<real_type>(0.5L)*PI;
+const real_type pi025 = static_cast<real_type>(0.25L)*PI;
 
 const real_type deg2rad = PI/static_cast<real_type>(180);
 const real_type rad2deg = static_cast<real_type>(180)/PI;

Modified: trunk/OpenFDM/src/OpenFDM/Units.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Units.h	2005-10-24 20:22:59 UTC (rev 37)
+++ trunk/OpenFDM/src/OpenFDM/Units.h	2005-10-26 17:53:47 UTC (rev 38)
@@ -129,12 +129,14 @@
 
  */
 
-/** Just pi. */
+/** Just pi*2 */
+extern const real_type pi2;
+/** Just pi */
 extern const real_type pi;
-/** Just 0.5*pi. */
-extern const real_type pi2;
-/** Just 0.25*pi. */
-extern const real_type pi4;
+/** Just pi*0.5 */
+extern const real_type pi05;
+/** Just pi*0.25 */
+extern const real_type pi025;
 
 extern const real_type deg2rad;
 extern const real_type rad2deg;

Modified: trunk/OpenFDM/src/OpenFDM/Vehicle.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Vehicle.cpp	2005-10-24 20:22:59 UTC (rev 37)
+++ trunk/OpenFDM/src/OpenFDM/Vehicle.cpp	2005-10-26 17:53:47 UTC (rev 38)
@@ -31,7 +31,7 @@
 
   // The Planet centered frame is used by the others!
   mRootFrame = new RootFrame("Planet centered frame");
-  Vector3 earthRotation(0.0, 0.0, 2.0*pi/(60*60*24));
+  Vector3 earthRotation(0.0, 0.0, pi2/(60*60*24));
   mRootFrame->setAngularRelVel(earthRotation);
 
   mTopBody = new RigidBody("Topmost rigid body");



From frohlich at berlios.de  Thu Oct 27 18:26:42 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Thu, 27 Oct 2005 18:26:42 +0200
Subject: [OpenFDM-svn] r39 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200510271626.j9RGQglQ024253@sheep.berlios.de>

Author: frohlich
Date: 2005-10-27 18:26:37 +0200 (Thu, 27 Oct 2005)
New Revision: 39

Modified:
   trunk/OpenFDM/src/OpenFDM/DefaultPlanet.cpp
Log:
Make use of pi2.


Modified: trunk/OpenFDM/src/OpenFDM/DefaultPlanet.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/DefaultPlanet.cpp	2005-10-26 17:53:47 UTC (rev 38)
+++ trunk/OpenFDM/src/OpenFDM/DefaultPlanet.cpp	2005-10-27 16:26:37 UTC (rev 39)
@@ -13,7 +13,7 @@
 namespace OpenFDM {
 
 DefaultPlanet::DefaultPlanet(void)
-  : mRotationRate(2.0*pi/(60.0*60.0*24.0))
+  : mRotationRate(pi2/(60.0*60.0*24.0))
 {
   // values taken from simgear
   setAequatorialRadius(6378137.0);



From frohlich at berlios.de  Thu Oct 27 20:20:50 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Thu, 27 Oct 2005 20:20:50 +0200
Subject: [OpenFDM-svn] r40 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200510271820.j9RIKolf009691@sheep.berlios.de>

Author: frohlich
Date: 2005-10-27 20:20:46 +0200 (Thu, 27 Oct 2005)
New Revision: 40

Modified:
   trunk/OpenFDM/src/OpenFDM/DiscreteIntegrator.cpp
   trunk/OpenFDM/src/OpenFDM/DiscreteIntegrator.h
Log:
Add Saturation to the discrete integrator.


Modified: trunk/OpenFDM/src/OpenFDM/DiscreteIntegrator.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/DiscreteIntegrator.cpp	2005-10-27 16:26:37 UTC (rev 39)
+++ trunk/OpenFDM/src/OpenFDM/DiscreteIntegrator.cpp	2005-10-27 18:20:46 UTC (rev 40)
@@ -20,6 +20,9 @@
   setOutputPort(0, "output", Property(this, &DiscreteIntegrator::getIntegralOutput));
 
   addProperty("initialValue", Property(this, &DiscreteIntegrator::getInitialValue, &DiscreteIntegrator::setInitialValue));
+  addProperty("minSaturation", Property(this, &DiscreteIntegrator::getMinSaturation, &DiscreteIntegrator::setMinSaturation));
+  addProperty("maxSaturation", Property(this, &DiscreteIntegrator::getMaxSaturation, &DiscreteIntegrator::setMaxSaturation));
+
   addProperty("output", Property(this, &DiscreteIntegrator::getIntegralOutput));
 }
 
@@ -38,6 +41,13 @@
     mInitialValue.clear();
   }
 
+  if (size(mMinSaturation) != Size(0, 0)) {
+    OpenFDMAssert(size(mMinSaturation) == size(mInitialValue));
+  }
+  if (size(mMaxSaturation) != Size(0, 0)) {
+    OpenFDMAssert(size(mMaxSaturation) == size(mInitialValue));
+  }
+
   setNumDiscreteStates(rows(mInitialValue)*cols(mInitialValue));
 
   mIntegralState = mInitialValue;
@@ -64,6 +74,22 @@
   OpenFDMAssert(size(input) == size(mIntegralState));
   if (size(input) == size(mIntegralState))
     mIntegralState += dt*input;
+
+  // Hmm, should that be done on state setting too???
+  if (size(mMaxSaturation) == size(mInitialValue)) {
+    for (unsigned j = 1; j <= cols(mIntegralState); ++j) {
+      for (unsigned i = 1; i <= rows(mIntegralState); ++i) {
+        mIntegralState(i, j) = min(mIntegralState(i, j), mMaxSaturation(i, j));
+      }
+    }
+  }
+  if (size(mMinSaturation) == size(mInitialValue)) {
+    for (unsigned j = 1; j <= cols(mIntegralState); ++j) {
+      for (unsigned i = 1; i <= rows(mIntegralState); ++i) {
+        mIntegralState(i, j) = max(mIntegralState(i, j), mMinSaturation(i, j));
+      }
+    }
+  }
 }
 
 void
@@ -101,6 +127,30 @@
 }
 
 const Matrix&
+DiscreteIntegrator::getMinSaturation(void) const
+{
+  return mMinSaturation;
+}
+
+void
+DiscreteIntegrator::setMinSaturation(const Matrix& value)
+{
+  mMinSaturation = value;
+}
+
+const Matrix&
+DiscreteIntegrator::getMaxSaturation(void) const
+{
+  return mMaxSaturation;
+}
+
+void
+DiscreteIntegrator::setMaxSaturation(const Matrix& value)
+{
+  mMaxSaturation = value;
+}
+
+const Matrix&
 DiscreteIntegrator::getIntegralOutput(void) const
 {
   return mIntegralOutput;

Modified: trunk/OpenFDM/src/OpenFDM/DiscreteIntegrator.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/DiscreteIntegrator.h	2005-10-27 16:26:37 UTC (rev 39)
+++ trunk/OpenFDM/src/OpenFDM/DiscreteIntegrator.h	2005-10-27 18:20:46 UTC (rev 40)
@@ -28,6 +28,12 @@
   const Matrix& getInitialValue(void) const;
   void setInitialValue(const Matrix& value);
 
+  const Matrix& getMinSaturation(void) const;
+  void setMinSaturation(const Matrix& value);
+
+  const Matrix& getMaxSaturation(void) const;
+  void setMaxSaturation(const Matrix& value);
+
   const Matrix& getIntegralOutput(void) const;
 
 private:
@@ -37,6 +43,10 @@
   Matrix mIntegralState;
   /// Holds the current integral initial state.
   Matrix mInitialValue;
+  /// Holds the minimum saturation
+  Matrix mMinSaturation;
+  /// Holds the maximum saturation
+  Matrix mMaxSaturation;
 };
 
 } // namespace OpenFDM



From frohlich at berlios.de  Thu Oct 27 20:21:44 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Thu, 27 Oct 2005 20:21:44 +0200
Subject: [OpenFDM-svn] r41 - in trunk/OpenFDM/src: JSBSim OpenFDM
Message-ID: <200510271821.j9RILigB011786@sheep.berlios.de>

Author: frohlich
Date: 2005-10-27 20:21:39 +0200 (Thu, 27 Oct 2005)
New Revision: 41

Modified:
   trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
   trunk/OpenFDM/src/OpenFDM/AeroForce.cpp
Log:
Rename the mach number.


Modified: trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
===================================================================
--- trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2005-10-27 18:20:46 UTC (rev 40)
+++ trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2005-10-27 18:21:39 UTC (rev 41)
@@ -224,7 +224,7 @@
 
   // If we need the negative input, just multiply with a negative gain
   if (propMinusFromJSBSim(name))
-    return addInverterModel(name.substr(name.rfind('/')), prop);
+    return addInverterModel(name.substr(name.rfind('/')+1), prop);
   else
     return prop;
 }
@@ -1876,7 +1876,7 @@
   registerJSBExpression("velocities/vt-kts", Property(c));
 
   // Mach numbers, are unitless.
-  e = mAeroForce->getProperty("mach");
+  e = mAeroForce->getProperty("machNumber");
   registerJSBExpression("velocities/mach-norm", e);
 
   // Rotational rates wrt air.

Modified: trunk/OpenFDM/src/OpenFDM/AeroForce.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/AeroForce.cpp	2005-10-27 18:20:46 UTC (rev 40)
+++ trunk/OpenFDM/src/OpenFDM/AeroForce.cpp	2005-10-27 18:21:39 UTC (rev 41)
@@ -78,6 +78,8 @@
   addProperty("betaDot",
               Property(this, &AeroForce::getBetaDot));
   addProperty("mach",
+              Property(this, &AeroForce::getMach));
+  addProperty("machNumber",
               Property(this, &AeroForce::getMachNumber));
   addProperty("trueSpeedUW",
               Property(this, &AeroForce::getTrueSpeedUW));



From frohlich at berlios.de  Thu Oct 27 20:49:44 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Thu, 27 Oct 2005 20:49:44 +0200
Subject: [OpenFDM-svn] r42 - trunk/OpenFDM/src/OpenFDM/XML
Message-ID: <200510271849.j9RIniHu026917@sheep.berlios.de>

Author: frohlich
Date: 2005-10-27 20:49:33 +0200 (Thu, 27 Oct 2005)
New Revision: 42

Modified:
   trunk/OpenFDM/src/OpenFDM/XML/Tablereader.cpp
   trunk/OpenFDM/src/OpenFDM/XML/Tablereader.h
Log:
Update required headers.


Modified: trunk/OpenFDM/src/OpenFDM/XML/Tablereader.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/XML/Tablereader.cpp	2005-10-27 18:21:39 UTC (rev 41)
+++ trunk/OpenFDM/src/OpenFDM/XML/Tablereader.cpp	2005-10-27 18:49:33 UTC (rev 42)
@@ -2,11 +2,9 @@
  *
  */
 
-#include <string>
-#include <vector>
 #include <iostream>
 
-#include <OpenFDM/Expression.h>
+#include "Tablereader.h"
 
 namespace OpenFDM {
 

Modified: trunk/OpenFDM/src/OpenFDM/XML/Tablereader.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/XML/Tablereader.h	2005-10-27 18:21:39 UTC (rev 41)
+++ trunk/OpenFDM/src/OpenFDM/XML/Tablereader.h	2005-10-27 18:49:33 UTC (rev 42)
@@ -8,7 +8,6 @@
 #include <iosfwd>
 
 #include <OpenFDM/Table.h>
-#include <OpenFDM/Expression.h>
 
 namespace OpenFDM {
 



From frohlich at berlios.de  Thu Oct 27 21:00:20 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Thu, 27 Oct 2005 21:00:20 +0200
Subject: [OpenFDM-svn] r43 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200510271900.j9RJ0Kc9027613@sheep.berlios.de>

Author: frohlich
Date: 2005-10-27 21:00:11 +0200 (Thu, 27 Oct 2005)
New Revision: 43

Modified:
   trunk/OpenFDM/src/OpenFDM/DiscreteIntegrator.cpp
   trunk/OpenFDM/src/OpenFDM/DiscreteIntegrator.h
   trunk/OpenFDM/src/OpenFDM/Integrator.cpp
   trunk/OpenFDM/src/OpenFDM/Integrator.h
   trunk/OpenFDM/src/OpenFDM/TimeDerivative.cpp
   trunk/OpenFDM/src/OpenFDM/TimeDerivative.h
   trunk/OpenFDM/src/OpenFDM/TransferFunction.cpp
   trunk/OpenFDM/src/OpenFDM/TransferFunction.h
Log:
Zap unused headers


Modified: trunk/OpenFDM/src/OpenFDM/DiscreteIntegrator.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/DiscreteIntegrator.cpp	2005-10-27 18:49:33 UTC (rev 42)
+++ trunk/OpenFDM/src/OpenFDM/DiscreteIntegrator.cpp	2005-10-27 19:00:11 UTC (rev 43)
@@ -3,9 +3,6 @@
  */
 
 #include "Assert.h"
-#include "Types.h"
-#include "Object.h"
-#include "Expression.h"
 #include "DiscreteIntegrator.h"
 
 namespace OpenFDM {

Modified: trunk/OpenFDM/src/OpenFDM/DiscreteIntegrator.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/DiscreteIntegrator.h	2005-10-27 18:49:33 UTC (rev 42)
+++ trunk/OpenFDM/src/OpenFDM/DiscreteIntegrator.h	2005-10-27 19:00:11 UTC (rev 43)
@@ -5,9 +5,7 @@
 #ifndef OpenFDM_DiscreteIntegrator_H
 #define OpenFDM_DiscreteIntegrator_H
 
-#include "Assert.h"
 #include "Types.h"
-#include "Object.h"
 #include "Model.h"
 
 namespace OpenFDM {

Modified: trunk/OpenFDM/src/OpenFDM/Integrator.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Integrator.cpp	2005-10-27 18:49:33 UTC (rev 42)
+++ trunk/OpenFDM/src/OpenFDM/Integrator.cpp	2005-10-27 19:00:11 UTC (rev 43)
@@ -3,9 +3,6 @@
  */
 
 #include "Assert.h"
-#include "Types.h"
-#include "Object.h"
-#include "Expression.h"
 #include "Integrator.h"
 
 namespace OpenFDM {

Modified: trunk/OpenFDM/src/OpenFDM/Integrator.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Integrator.h	2005-10-27 18:49:33 UTC (rev 42)
+++ trunk/OpenFDM/src/OpenFDM/Integrator.h	2005-10-27 19:00:11 UTC (rev 43)
@@ -5,9 +5,7 @@
 #ifndef OpenFDM_Integrator_H
 #define OpenFDM_Integrator_H
 
-#include "Assert.h"
 #include "Types.h"
-#include "Object.h"
 #include "Model.h"
 
 namespace OpenFDM {

Modified: trunk/OpenFDM/src/OpenFDM/TimeDerivative.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/TimeDerivative.cpp	2005-10-27 18:49:33 UTC (rev 42)
+++ trunk/OpenFDM/src/OpenFDM/TimeDerivative.cpp	2005-10-27 19:00:11 UTC (rev 43)
@@ -3,9 +3,6 @@
  */
 
 #include "Assert.h"
-#include "Types.h"
-#include "Object.h"
-#include "Expression.h"
 #include "TimeDerivative.h"
 
 namespace OpenFDM {

Modified: trunk/OpenFDM/src/OpenFDM/TimeDerivative.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/TimeDerivative.h	2005-10-27 18:49:33 UTC (rev 42)
+++ trunk/OpenFDM/src/OpenFDM/TimeDerivative.h	2005-10-27 19:00:11 UTC (rev 43)
@@ -5,11 +5,8 @@
 #ifndef OpenFDM_TimeDerivative_H
 #define OpenFDM_TimeDerivative_H
 
-#include "Assert.h"
 #include "Types.h"
-#include "Object.h"
 #include "Model.h"
-#include "Expression.h"
 
 namespace OpenFDM {
 

Modified: trunk/OpenFDM/src/OpenFDM/TransferFunction.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/TransferFunction.cpp	2005-10-27 18:49:33 UTC (rev 42)
+++ trunk/OpenFDM/src/OpenFDM/TransferFunction.cpp	2005-10-27 19:00:11 UTC (rev 43)
@@ -3,10 +3,7 @@
  */
 
 #include "Assert.h"
-#include "Types.h"
-#include "Object.h"
-#include "Vector.h"
-#include "Property.h"
+#include "LogStream.h"
 #include "TransferFunction.h"
 
 namespace OpenFDM {

Modified: trunk/OpenFDM/src/OpenFDM/TransferFunction.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/TransferFunction.h	2005-10-27 18:49:33 UTC (rev 42)
+++ trunk/OpenFDM/src/OpenFDM/TransferFunction.h	2005-10-27 19:00:11 UTC (rev 43)
@@ -5,12 +5,9 @@
 #ifndef OpenFDM_TransferFunction_H
 #define OpenFDM_TransferFunction_H
 
-#include "Assert.h"
 #include "Types.h"
-#include "Object.h"
 #include "Vector.h"
 #include "Model.h"
-#include "Expression.h"
 
 namespace OpenFDM {
 



From frohlich at berlios.de  Sat Oct 29 12:15:55 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Sat, 29 Oct 2005 12:15:55 +0200
Subject: [OpenFDM-svn] r44 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200510291015.j9TAFto7022955@sheep.berlios.de>

Author: frohlich
Date: 2005-10-29 12:15:46 +0200 (Sat, 29 Oct 2005)
New Revision: 44

Modified:
   trunk/OpenFDM/src/OpenFDM/Frame.cpp
   trunk/OpenFDM/src/OpenFDM/Frame.h
   trunk/OpenFDM/src/OpenFDM/FreeJoint.cpp
   trunk/OpenFDM/src/OpenFDM/Joint.h
   trunk/OpenFDM/src/OpenFDM/JointT.h
   trunk/OpenFDM/src/OpenFDM/RigidBody.cpp
   trunk/OpenFDM/src/OpenFDM/Sensor.h
Log:
Whow, I believe that I have understood now the differece between
spatial and 'classical' accelerations. Rename some frames functions ...


Modified: trunk/OpenFDM/src/OpenFDM/Frame.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Frame.cpp	2005-10-27 19:00:11 UTC (rev 43)
+++ trunk/OpenFDM/src/OpenFDM/Frame.cpp	2005-10-29 10:15:46 UTC (rev 44)
@@ -17,9 +17,9 @@
 Frame::Frame(const std::string& name) :
   mName(name),
   mDirtyPos(true),
-  mDirtyInVel(true),
-  mDirtyInAccel(true),
-  mDisableInAccel(false),
+  mDirtySpVel(true),
+  mDirtySpAccel(true),
+  mDisableSpAccel(false),
   mReferenceFrameId(0)
 {
   setPosition(Vector3::zeros());
@@ -31,10 +31,11 @@
   addProperty("position", Property(this, &Frame::getPosition));
   addProperty("orienatation", Property(this, &Frame::getOrientation));
   addProperty("relVel", Property(this, &Frame::getRelVel));
-  addProperty("inVel", Property(this, &Frame::getInVel));
+  addProperty("spVel", Property(this, &Frame::getSpVel));
   addProperty("refVel", Property(this, &Frame::getRefVel));
   addProperty("relAccel", Property(this, &Frame::getRelAccel));
-  addProperty("inAccel", Property(this, &Frame::getInAccel));
+  addProperty("spAccel", Property(this, &Frame::getSpAccel));
+  addProperty("classicAccel", Property(this, &Frame::getClassicAccel));
   addProperty("refPosition", Property(this, &Frame::getRefPosition));
   addProperty("refOrienatation", Property(this, &Frame::getRefOrientation));
 }
@@ -167,8 +168,8 @@
 {
   // Mark ourself dirty.
   mDirtyPos = true;
-  mDirtyInVel = true;
-  mDirtyInAccel = true;
+  mDirtySpVel = true;
+  mDirtySpAccel = true;
   
   // Mark all child dirty.
   ChildFrameList::iterator it = mChildFrames.begin();
@@ -183,8 +184,8 @@
 Frame::setVelDirtyUnconditional(void)
 {
   // Mark ourself dirty.
-  mDirtyInVel = true;
-  mDirtyInAccel = true;
+  mDirtySpVel = true;
+  mDirtySpAccel = true;
   
   // Mark all child dirty.
   ChildFrameList::iterator it = mChildFrames.begin();
@@ -199,7 +200,7 @@
 Frame::setAccelDirtyUnconditional(void)
 {
   // Mark ourself dirty.
-  mDirtyInAccel = true;
+  mDirtySpAccel = true;
   
   // Mark all child dirty.
   ChildFrameList::iterator it = mChildFrames.begin();

Modified: trunk/OpenFDM/src/OpenFDM/Frame.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Frame.h	2005-10-27 19:00:11 UTC (rev 43)
+++ trunk/OpenFDM/src/OpenFDM/Frame.h	2005-10-29 10:15:46 UTC (rev 44)
@@ -246,29 +246,29 @@
   Vector3 getAngularRelVel(void) const
   { return getRelVel().getAngular(); }
 
-  /** Inertial velocity of the parent frame.
+  /** Spatial velocity of the parent frame.
       @return The spatial velocity of the parent frame with respect to an
       inertial frame transformed to the current frame. If the current frame
-      does not have a parrent it is assumed to be an inertial frame.
+      does not have a parent it is assumed to be an inertial frame.
    */
-  const Vector6& getParentInVel(void) const
+  const Vector6& getParentSpVel(void) const
   {
-    if (mDirtyInVel)
+    if (mDirtySpVel)
       computeVelocityDep();
-    return mParentInVel;
+    return mParentSpVel;
   }
 
-  /** Inertial velocity of the current frame.
+  /** Spatial velocity of the current frame.
       @return The spatial velocity of the current frame with respect to an
-      inertial frame. If the current frame does not have a parrent it is
+      inertial frame. If the current frame does not have a parent it is
       assumed to be an inertial frame.
    */
-  Vector6 getInVel(void) const
-  { return getRelVel() + getParentInVel(); }
+  Vector6 getSpVel(void) const
+  { return getRelVel() + getParentSpVel(); }
 
   Vector6 getRefVel(void) const
   {
-    if (mDirtyInVel)
+    if (mDirtySpVel)
       computeVelocityDep();
     return mRefVel;
   }
@@ -287,29 +287,47 @@
   Vector3 getAngularRelAccel(void) const
   { return getRelAccel().getAngular(); }
 
-  /** Inertial acceleration of the parent frame.
+  /** Spatial acceleration of the parent frame.
       @return The spatial acceleration of the parent frame with respect to an
       inertial frame transformed to the current frame. If the current frame
-      does not have a parrent it is assumed to be an inertial frame.
+      does not have a parent it is assumed to be an inertial frame.
+      Note that the spatial acceleration is not the classical acceleration
+      of the moving and accelerating body (@see getClassicAccel).
    */
-  const Vector6& getParentInAccel(void) const
+  const Vector6& getParentSpAccel(void) const
   {
-    if (mDirtyInAccel)
+    if (mDirtySpAccel)
       computeAccelerationDep();
-    return mParentInAccel;
+    return mParentSpAccel;
   }
 
-  /** Inertial acceleration of the current frame.
+  /** Spatial acceleration of the current frame.
       @return The spatial acceleration of the current frame with respect to an
-      inertial frame. If the current frame does not have a parrent it is
+      inertial frame. If the current frame does not have a parent it is
       assumed to be an inertial frame.
+      Note that the spatial acceleration is not the classical acceleration
+      of the moving and accelerating body (@see getClassicAccel).
    */
-  Vector6 getInAccel(void) const
+  Vector6 getSpAccel(void) const
   {
-    OpenFDMAssert(!mDisableInAccel);
-    return getRelAccel() + getParentInAccel() + getHdot();
+    OpenFDMAssert(!mDisableSpAccel);
+    return getRelAccel() + getParentSpAccel() + getHdot();
   }
 
+  /** Classical acceleration of the current frame.
+      @return The sensed acceleration of the current frame with respect to an
+      inertial frame. If the current frame does not have a parent it is
+      assumed to be an inertial frame.
+   */
+  Vector6 getClassicAccel(void) const
+  {
+    OpenFDMAssert(!mDisableSpAccel);
+    Vector6 iv = getSpVel();
+    return getRelAccel() + getParentSpAccel() + getHdot()
+      + Vector6(Vector3::zeros(), cross(iv.getAngular(), iv.getLinear()));
+  }
+
+
   /** FIXME
    */
 //   virtual 
@@ -325,7 +343,7 @@
        transformed spatial velocity of the parent frame cross the
        relative velocity.
      */
-    Vector6 pivel = getParentInVel();
+    Vector6 pivel = getParentSpVel();
     return Vector6(cross(pivel.getAngular(), getAngularRelVel()),
                    cross(pivel.getAngular(), getLinearRelVel()) + 
                    cross(pivel.getLinear(), getAngularRelVel()));
@@ -484,27 +502,27 @@
   void computeVelocityDep(void) const
   {
     if (hasParent()) {
-      mParentInVel = motionFromParent(getParentFrame()->getInVel());
+      mParentSpVel = motionFromParent(getParentFrame()->getSpVel());
       mRefVel = getRelVel() + motionFromParent(getParentFrame()->getRefVel());
       mReferenceFrameId = getParentFrame()->getRefFrameId();
     } else {
-      mParentInVel = Vector6::zeros();
+      mParentSpVel = Vector6::zeros();
       mRefVel = Vector6::zeros();
       mReferenceFrameId = getFrameId();
     }
-    mDirtyInVel = false;
+    mDirtySpVel = false;
   }
 
   void computeAccelerationDep(void) const
   {
     if (hasParent()) {
-      mParentInAccel = motionFromParent(getParentFrame()->getInAccel());
+      mParentSpAccel = motionFromParent(getParentFrame()->getSpAccel());
       mReferenceFrameId = getParentFrame()->getRefFrameId();
     } else {
-      mParentInAccel = Vector6::zeros();
+      mParentSpAccel = Vector6::zeros();
       mReferenceFrameId = getFrameId();
     }
-    mDirtyInAccel = false;
+    mDirtySpAccel = false;
   }
 
   /** Reference orientation.
@@ -584,15 +602,15 @@
   { setAccelDirty(); mRelAccel.setAngular(accel); }
 
   void disableAccel(void)
-  { mDisableInAccel = true; }
+  { mDisableSpAccel = true; }
   void enableAccel(void)
-  { mDisableInAccel = false; }
+  { mDisableSpAccel = false; }
 
 protected:
   void setPosDirty(void)
   {
     // Don't bother iterating over all children if we are already dirty.
-    if (mDirtyPos == true && mDirtyInVel == true && mDirtyInAccel == true)
+    if (mDirtyPos == true && mDirtySpVel == true && mDirtySpAccel == true)
       return;
     // Really set ourself and all children dirty.
     // Is done in this way to help the compiler inline the fast path and
@@ -602,7 +620,7 @@
   void setVelDirty(void)
   {
     // Don't bother iterating over all children if we are already dirty.
-    if (mDirtyInVel == true && mDirtyInAccel == true)
+    if (mDirtySpVel == true && mDirtySpAccel == true)
       return;
     // Really set ourself and all children dirty.
     // Is done in this way to help the compiler inline the fast path and
@@ -612,7 +630,7 @@
   void setAccelDirty(void)
   {
     // Don't bother iterating over all children if we are already dirty.
-    if (mDirtyInAccel == true)
+    if (mDirtySpAccel == true)
       return;
     // Really set ourself and all children dirty.
     // Is done in this way to help the compiler inline the fast path and
@@ -644,8 +662,8 @@
   // True? more the relative acceleration ...
   Vector6 mRelAccel;
 
-  mutable Vector6 mParentInVel;
-  mutable Vector6 mParentInAccel;
+  mutable Vector6 mParentSpVel;
+  mutable Vector6 mParentSpAccel;
 
   mutable Rotation mRefOrient;
   mutable Vector3 mRefPos;
@@ -659,9 +677,9 @@
   // Flag which tells the frame if dependent values must
   // be recomputed or not.
   mutable bool mDirtyPos:1;
-  mutable bool mDirtyInVel:1;
-  mutable bool mDirtyInAccel:1;
-  mutable bool mDisableInAccel:1;
+  mutable bool mDirtySpVel:1;
+  mutable bool mDirtySpAccel:1;
+  mutable bool mDisableSpAccel:1;
 
   // The parent frame.
   // FIXME: May be we should store a list of all parents ???

Modified: trunk/OpenFDM/src/OpenFDM/FreeJoint.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/FreeJoint.cpp	2005-10-27 19:00:11 UTC (rev 43)
+++ trunk/OpenFDM/src/OpenFDM/FreeJoint.cpp	2005-10-29 10:15:46 UTC (rev 44)
@@ -54,12 +54,12 @@
 
   Log(ArtBody, Debug) << "grav = " << trans(grav) << endl;
   Log(ArtBody, Debug) << "solve = " << trans(solve(artI, artF)) << endl;
-  Log(ArtBody, Debug) << "parent accel = " << trans(topBody->getParentInAccel()) << endl;
+  Log(ArtBody, Debug) << "parent spatial accel = " << trans(topBody->getParentSpAccel()) << endl;
   Log(ArtBody, Debug) << "Hdot = " << trans(getHdot()) << endl;
   
 
   Vector6 accel = grav - solve(artI, artF)
-    - topBody->getParentInAccel() - getHdot();
+    - topBody->getParentSpAccel() - getHdot();
   return accel;
 }
 

Modified: trunk/OpenFDM/src/OpenFDM/Joint.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Joint.h	2005-10-27 19:00:11 UTC (rev 43)
+++ trunk/OpenFDM/src/OpenFDM/Joint.h	2005-10-29 10:15:46 UTC (rev 44)
@@ -156,9 +156,6 @@
     if (!outboardBody)
       return false;
 
-//  outboardBody->getHdot();
-//  outboardBody->getParentInAccel();
-
     // Set the local acceleration
     setOutboardRelAccel(computeRelAccel(outboardBody->getArtInertia(),
                                         outboardBody->getArtForce()));

Modified: trunk/OpenFDM/src/OpenFDM/JointT.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/JointT.h	2005-10-27 19:00:11 UTC (rev 43)
+++ trunk/OpenFDM/src/OpenFDM/JointT.h	2005-10-29 10:15:46 UTC (rev 44)
@@ -44,14 +44,14 @@
   }
   
   void computeRelAccel(const SpatialInertia& outBoardArtInertia,
-                       const Vector6& parentInAccel,
+                       const Vector6& parentSpAccel,
                        const Matrix6N& jointAxis,
                        VectorN& jointAccel) const
   {
     if (hIh.singular()) {
       jointAccel.clear();
     } else {
-      Vector6 tmp = mForcePAlpha - outBoardArtInertia*parentInAccel;
+      Vector6 tmp = mForcePAlpha - outBoardArtInertia*parentSpAccel;
       jointAccel = hIh.solve(trans(jointAxis)*tmp);
     }
   }

Modified: trunk/OpenFDM/src/OpenFDM/RigidBody.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RigidBody.cpp	2005-10-27 19:00:11 UTC (rev 43)
+++ trunk/OpenFDM/src/OpenFDM/RigidBody.cpp	2005-10-29 10:15:46 UTC (rev 44)
@@ -71,7 +71,7 @@
   
 
   // 
-  Vector6 iv = getInVel();
+  Vector6 iv = getSpVel();
   Vector6 Jiv = mArtInertia*iv;
   mArtForce = Vector6(cross(iv.getAngular(), Jiv.getAngular()) +
                       cross(iv.getLinear(), Jiv.getLinear()),

Modified: trunk/OpenFDM/src/OpenFDM/Sensor.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Sensor.h	2005-10-27 19:00:11 UTC (rev 43)
+++ trunk/OpenFDM/src/OpenFDM/Sensor.h	2005-10-29 10:15:46 UTC (rev 44)
@@ -44,7 +44,7 @@
       mAccel = Vector6::zeros();
       return;
     }
-    mAccel = frame->getInAccel();
+    mAccel = frame->getClassicAccel();
   }
 
   real_type getNZ(void) const



From frohlich at berlios.de  Sat Oct 29 12:16:16 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Sat, 29 Oct 2005 12:16:16 +0200
Subject: [OpenFDM-svn] r45 - trunk/flightgear
Message-ID: <200510291016.j9TAGGo9022984@sheep.berlios.de>

Author: frohlich
Date: 2005-10-29 12:16:13 +0200 (Sat, 29 Oct 2005)
New Revision: 45

Modified:
   trunk/flightgear/FGOpenFDM.cpp
Log:
Accumulated updates ...


Modified: trunk/flightgear/FGOpenFDM.cpp
===================================================================
--- trunk/flightgear/FGOpenFDM.cpp	2005-10-29 10:15:46 UTC (rev 44)
+++ trunk/flightgear/FGOpenFDM.cpp	2005-10-29 10:16:13 UTC (rev 45)
@@ -153,6 +153,63 @@
   SGPropertyNode_ptr mPropertyNode;
 };
 
+
+class StatePrintVisitor
+  : public ConstVisitor {
+public:
+  StatePrintVisitor(void) : _indent(3) {}
+  virtual ~StatePrintVisitor(void) {}
+  virtual void apply(const MultiBodyModel& node)
+  {
+    if (node.getName() != "Aerodynamic force")
+      return;
+    const AeroForce* aeroForce = (const AeroForce*)&node;
+    std::cout << "Alpha " << convertTo(uDegree, aeroForce->getAlpha())
+              << ", Beta " << convertTo(uDegree, aeroForce->getBeta())
+//               << ", Mach " << aeroForce->getMachNumber()
+              << ", speed " << trans(aeroForce->getAirSpeed())
+              << std::endl;
+
+//     Vector v(node.getNumContinousStates());
+//     node.getState(v, 0);
+//     std::cout << std::setw(_indent) << ""
+//               << "\"" << node.getName() << "\", "
+//               << trans(v) << endl;
+  }
+  virtual void apply(const Frame& group)
+  {
+    std::cout << std::setw(_indent) << ""
+              << "Traversing \""
+              << group.getName() << "\" ("
+              << trans(group.getRelVel().getLinear())
+              << ", "
+              << trans(group.getSpVel().getLinear())
+              << ", "
+              << trans(group.getRelAccel().getLinear())
+              << ", "
+              << trans(group.getSpAccel().getLinear())
+              << "), "
+              << endl;
+    _indent += 3;
+    traverse(group);
+    _indent -= 3;
+  }
+private:
+  unsigned _indent;
+};
+
+void printVehicle(Vehicle* vehicle)
+{
+  cout << "T = " << vehicle->getTime()
+       << ", Pos: " << vehicle->getGeodPosition()
+//        << ", Or: " << vehicle->getGeodOrientation()
+       << endl;
+
+  StatePrintVisitor spv;
+  vehicle->getTopBody()->getParentFrame()->accept(spv);
+}
+
+
 // Our local storage covers the pointer to our vehicle.
 // A list of the property to expression adaptors.
 struct FGOpenFDMData {
@@ -209,6 +266,7 @@
   // Call what needs to be done ... ;-(
   common_init();
 
+  // Hmm, twice ??
   mData->vehicle->init();
 
   set_inited(true);
@@ -281,9 +339,6 @@
     vehicle->setGeodOrientation(go);
   }
   
-  if (stateChanged)
-    SG_LOG(SG_FLIGHT, SG_INFO, "State changed ------------------------------");
-
   double acrad = vehicle->getRadius();
   double groundCacheRadius = acrad
     + 2*dt*norm(vehicle->getVelocity().getLinear());
@@ -294,43 +349,66 @@
     SG_LOG(SG_FLIGHT, SG_WARN,
            "FGInterface is beeing called without scenery below the aircraft!");
 
+  if (stateChanged) {
+    SG_LOG(SG_FLIGHT, SG_INFO, "State changed ------------------------------");
+    vehicle->init();
+  }
+
+  // Here a miracle occures :)
   vehicle->output();
   vehicle->update(dt);
 
+//   printVehicle(vehicle);
+
   // Now write the newly computed values into the interface class.
   gp = vehicle->getGeodPosition();
   _updateGeodeticPosition(gp.latitude, gp.longitude,
                           convertTo(uFoot, gp.altitude));
+//   _set_Altitude_AGL(model->getAGL() * M2FT);
 
-  euler = vehicle->getGeodOrientation().getEuler();
+  Rotation geodOr = vehicle->getGeodOrientation();
+  euler = geodOr.getEuler();
   _set_Euler_Angles(euler(1), euler(2), euler(3));
 
+  // FIXME: wrong velocities are set here ...
+  Vector3 velWrtWind = vehicle->getVelocity().getLinear();
+  _set_V_rel_wind(convertTo(uFeetPSecond, norm(velWrtWind)));
+  _set_Velocities_Wind_Body(convertTo(uFeetPSecond, velWrtWind(1)),
+                            convertTo(uFeetPSecond, velWrtWind(2)),
+                            convertTo(uFeetPSecond, velWrtWind(3)));
+  _set_V_equiv_kts(convertTo(uKnots, norm(velWrtWind)));
+  _set_V_calibrated_kts(convertTo(uKnots, norm(velWrtWind)));
+  _set_Mach_number(norm(velWrtWind)/340);
 
-  _set_V_rel_wind(convertTo(uFeetPSecond,
-                            norm(vehicle->getVelocity().getLinear())));
-
-  _set_V_equiv_kts(convertTo(uKnots,
-                             norm(vehicle->getVelocity().getLinear())));
-  
-  _set_V_calibrated_kts(convertTo(uKnots,
-                                  norm(vehicle->getVelocity().getLinear())));
-
+  Vector3 localVel = convertTo(uFeetPSecond, geodOr.backTransform(velWrtWind));
+  _set_Velocities_Local(localVel(1),localVel(2), localVel(3));
   _set_V_ground_speed(convertTo(uFeetPSecond,
-                                norm(vehicle->getVelocity().getLinear())));
+             sqrt(localVel(1)*localVel(1) + localVel(2)*localVel(2))));
+  _set_Velocities_Ground(localVel(1),localVel(2), -localVel(3));;
+  _set_Climb_Rate(-localVel(3));
 
-  // Velocities
-//   _set_Velocities_Local( Propagate->GetVel(eNorth),
-//                          Propagate->GetVel(eEast),
-//                          Propagate->GetVel(eDown) );
+  const RigidBody* topBody = vehicle->getTopBody();
+  Vector3 bodyAccel = convertTo(uFeetPSec2, topBody->getClassicAccel().getLinear());
+  _set_Accels_Body(bodyAccel(1), bodyAccel(2), bodyAccel(3));
+  _set_Accels_Pilot_Body(bodyAccel(1), bodyAccel(2), bodyAccel(3));
+  _set_Accels_CG_Body(bodyAccel(1), bodyAccel(2), bodyAccel(3));
+  // It is not clear in any way how this 'local acceleration is meant'
+  // Just provide one possible interpretation
+  Vector3 localAccel = geodOr.backTransform(bodyAccel);
+  _set_Accels_Local(localAccel(1), localAccel(2), localAccel(3));
 
-//     _set_Velocities_Wind_Body( Propagate->GetUVW(1),
-//                                Propagate->GetUVW(2),
-//                                Propagate->GetUVW(3) );
+  Vector3 nAccel = 1/convertTo(uFeetPSec2, 9.81) * bodyAccel;
+  _set_Accels_CG_Body_N(nAccel(1), nAccel(2), nAccel(3));
+  _set_Nlf(-nAccel(3));
 
-//     _set_Velocities_Ground( Propagate->GetVel(eNorth),
-//                             Propagate->GetVel(eEast),
-//                             -Propagate->GetVel(eDown) );
+  
+  Vector3 angVel = topBody->getRelVel().getAngular();
+  _set_Omega_Body(angVel(1), angVel(2), angVel(3));
+//   _set_Euler_Rates(roll, pitch, hdg);
 
+//   _set_Alpha( Auxiliary->Getalpha() );
+//   _set_Beta( Auxiliary->Getbeta() );
+//   _set_Gamma_vert_rad( Auxiliary->GetGamma() );
 }
 
 



From frohlich at berlios.de  Sat Oct 29 15:00:45 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Sat, 29 Oct 2005 15:00:45 +0200
Subject: [OpenFDM-svn] r46 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200510291300.j9TD0jKG031647@sheep.berlios.de>

Author: frohlich
Date: 2005-10-29 15:00:41 +0200 (Sat, 29 Oct 2005)
New Revision: 46

Modified:
   trunk/OpenFDM/src/OpenFDM/Frame.cpp
   trunk/OpenFDM/src/OpenFDM/Frame.h
Log:
Some cleanup.


Modified: trunk/OpenFDM/src/OpenFDM/Frame.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Frame.cpp	2005-10-29 10:16:13 UTC (rev 45)
+++ trunk/OpenFDM/src/OpenFDM/Frame.cpp	2005-10-29 13:00:41 UTC (rev 46)
@@ -164,6 +164,49 @@
 }
 
 void
+Frame::computePositionDep(void) const
+{
+  if (hasParent()) {
+    mRefOrient = getParentFrame()->getRefOrientation()*getOrientation();
+    mRefPos = getParentFrame()->posToRef(getPosition());
+    mReferenceFrameId = getParentFrame()->getRefFrameId();
+  } else {
+    mRefOrient = getOrientation();
+    mRefPos = getPosition();
+    mReferenceFrameId = getFrameId();
+  }
+  mDirtyPos = false;
+}
+
+void
+Frame::computeVelocityDep(void) const
+{
+  if (hasParent()) {
+    mParentSpVel = motionFromParent(getParentFrame()->getSpVel());
+    mRefVel = getRelVel() + motionFromParent(getParentFrame()->getRefVel());
+    mReferenceFrameId = getParentFrame()->getRefFrameId();
+  } else {
+    mParentSpVel = Vector6::zeros();
+    mRefVel = Vector6::zeros();
+    mReferenceFrameId = getFrameId();
+  }
+  mDirtySpVel = false;
+}
+
+void
+Frame::computeAccelerationDep(void) const
+{
+  if (hasParent()) {
+    mParentSpAccel = motionFromParent(getParentFrame()->getSpAccel());
+    mReferenceFrameId = getParentFrame()->getRefFrameId();
+  } else {
+    mParentSpAccel = Vector6::zeros();
+    mReferenceFrameId = getFrameId();
+  }
+  mDirtySpAccel = false;
+}
+
+void
 Frame::setPosDirtyUnconditional(void)
 {
   // Mark ourself dirty.

Modified: trunk/OpenFDM/src/OpenFDM/Frame.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Frame.h	2005-10-29 10:16:13 UTC (rev 45)
+++ trunk/OpenFDM/src/OpenFDM/Frame.h	2005-10-29 13:00:41 UTC (rev 46)
@@ -184,7 +184,7 @@
       parent frame. It is the only vector which is in the parent frames
       coordinates.
    */
-  /* virtual */ const Vector3& getPosition(void) const
+  const Vector3& getPosition(void) const
   { return mPosition; }
 
   /** Orientation of the current frame.
@@ -192,7 +192,7 @@
       parent frame. The quaternion returned here rotates vectors in the parent
       frames coordinated to vectors in current frames coordinates.
    */
-  /* virtual */ const Rotation& getOrientation(void) const
+  const Rotation& getOrientation(void) const
   { return mOrientation; }
 
 
@@ -201,7 +201,6 @@
                frames coordinates.
       @return  The vector v in the parent frames coordinates.
    */
-//   virtual 
   Vector3 rotToParent(const Vector3& v) const
   { return getOrientation().backTransform(v); }
 
@@ -210,7 +209,6 @@
                frames coordinates.
       @return  The vector v in the current frames coordinates.
    */
-//   virtual 
   Vector3 rotFromParent(const Vector3& v) const
   { return getOrientation().transform(v); }
 
@@ -220,7 +218,7 @@
               to the parent frame. The velocity is in the current frames
               coordinates.
    */
-  /* virtual */ const Vector6& getRelVel(void) const
+  const Vector6& getRelVel(void) const
   { return mRelVel; }
 
   /** Relative spatial acceleration.
@@ -228,7 +226,7 @@
               to the parent frame. The velocity is in the current frames
               coordinates.
    */
-  /* virtual */ Vector6 getRelAccel(void) const 
+  Vector6 getRelAccel(void) const 
   { return mRelAccel; }
 
 
@@ -330,7 +328,6 @@
 
   /** FIXME
    */
-//   virtual 
   Vector6 getHdot(void) const
   {
     /**
@@ -355,7 +352,6 @@
       @param v The position vector in the parent frame to be transformed.
       @return  The motion vector transformed to the current frame.
    */
-//   virtual 
   Vector3 posFromParent(const Vector3& v) const
   { return posTo(getPosition(), getOrientation(), v); }
 
@@ -365,7 +361,6 @@
       @param v The position in the current frame to be transformed.
       @return  The position transformed to the parent frame.
    */
-//   virtual 
   Vector3 posToParent(const Vector3& v) const
   { return posFrom(getPosition(), getOrientation(), v); }
 
@@ -375,7 +370,6 @@
       @param v The motion vector in the parent frame to be transformed.
       @return  The motion vector transformed to the current frame.
    */
-//   virtual 
   Vector6 motionFromParent(const Vector6& v) const
   { return motionTo(getPosition(), getOrientation(), v); }
 
@@ -385,7 +379,6 @@
       @param v The motion vector in the current frame to be transformed.
       @return  The motion vector transformed to the parent frame.
    */
-//   virtual 
   Vector6 motionToParent(const Vector6& v) const
   { return motionFrom(getPosition(), getOrientation(), v); }
 
@@ -395,7 +388,6 @@
       @param v The force vector in the parent frame to be transformed.
       @return  The force vector transformed to the current frame.
    */
-//   virtual 
   Vector6 forceFromParent(const Vector6& v) const
   { return forceTo(getPosition(), getOrientation(), v); }
 
@@ -405,7 +397,6 @@
       @param v The force vector in the current frame to be transformed.
       @return  The force vector transformed to the parent frame.
    */
-//   virtual 
   Vector6 forceToParent(const Vector6& v) const
   { return forceFrom(getPosition(), getOrientation(), v); }
 
@@ -465,7 +456,6 @@
       @param v The motion vector in the parent frame to be transformed.
       @return  The motion vector transformed to the current frame.
    */
-//   virtual 
   Vector6 motionFromRef(const Vector6& v) const
   { return motionTo(getRefPosition(), getRefOrientation(), v) - getRefVel(); }
 
@@ -475,7 +465,6 @@
       @param v The motion vector in the current frame to be transformed.
       @return  The motion vector transformed to the parent frame.
    */
-//   virtual 
   Vector6 motionToRef(const Vector6& v) const
   { return motionFrom(getRefPosition(), getRefOrientation(), v + getRefVel()); }
 
@@ -485,46 +474,6 @@
   Plane planeToRef(const Plane& plane) const
   { return planeFrom(getRefPosition(), getRefOrientation(), plane); }
 
-  void computePositionDep(void) const
-  {
-    if (hasParent()) {
-      mRefOrient = getParentFrame()->getRefOrientation()*getOrientation();
-      mRefPos = getParentFrame()->posToRef(getPosition());
-      mReferenceFrameId = getParentFrame()->getRefFrameId();
-    } else {
-      mRefOrient = getOrientation();
-      mRefPos = getPosition();
-      mReferenceFrameId = getFrameId();
-    }
-    mDirtyPos = false;
-  }
-
-  void computeVelocityDep(void) const
-  {
-    if (hasParent()) {
-      mParentSpVel = motionFromParent(getParentFrame()->getSpVel());
-      mRefVel = getRelVel() + motionFromParent(getParentFrame()->getRefVel());
-      mReferenceFrameId = getParentFrame()->getRefFrameId();
-    } else {
-      mParentSpVel = Vector6::zeros();
-      mRefVel = Vector6::zeros();
-      mReferenceFrameId = getFrameId();
-    }
-    mDirtySpVel = false;
-  }
-
-  void computeAccelerationDep(void) const
-  {
-    if (hasParent()) {
-      mParentSpAccel = motionFromParent(getParentFrame()->getSpAccel());
-      mReferenceFrameId = getParentFrame()->getRefFrameId();
-    } else {
-      mParentSpAccel = Vector6::zeros();
-      mReferenceFrameId = getFrameId();
-    }
-    mDirtySpAccel = false;
-  }
-
   /** Reference orientation.
    * Returns the reference orientation of this frame wrt the topmost frame 
    * this frame is attached to.
@@ -606,6 +555,10 @@
   void enableAccel(void)
   { mDisableSpAccel = false; }
 
+  void computePositionDep(void) const;
+  void computeVelocityDep(void) const;
+  void computeAccelerationDep(void) const;
+
 protected:
   void setPosDirty(void)
   {



From frohlich at berlios.de  Sat Oct 29 15:27:57 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Sat, 29 Oct 2005 15:27:57 +0200
Subject: [OpenFDM-svn] r47 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200510291327.j9TDRvmd002040@sheep.berlios.de>

Author: frohlich
Date: 2005-10-29 15:27:55 +0200 (Sat, 29 Oct 2005)
New Revision: 47

Modified:
   trunk/OpenFDM/src/OpenFDM/Frame.h
Log:
Return more const refs.


Modified: trunk/OpenFDM/src/OpenFDM/Frame.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Frame.h	2005-10-29 13:00:41 UTC (rev 46)
+++ trunk/OpenFDM/src/OpenFDM/Frame.h	2005-10-29 13:27:55 UTC (rev 47)
@@ -226,7 +226,7 @@
               to the parent frame. The velocity is in the current frames
               coordinates.
    */
-  Vector6 getRelAccel(void) const 
+  const Vector6& getRelAccel(void) const 
   { return mRelAccel; }
 
 
@@ -264,7 +264,7 @@
   Vector6 getSpVel(void) const
   { return getRelVel() + getParentSpVel(); }
 
-  Vector6 getRefVel(void) const
+  const Vector6& getRefVel(void) const
   {
     if (mDirtySpVel)
       computeVelocityDep();



