From frohlich at mail.berlios.de  Fri Aug  1 15:46:37 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Fri, 1 Aug 2008 15:46:37 +0200
Subject: [OpenFDM-svn] r416 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200808011346.m71DkbGt014846@sheep.berlios.de>

Author: frohlich
Date: 2008-08-01 15:46:36 +0200 (Fri, 01 Aug 2008)
New Revision: 416

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.h
Log:
Rename Leaf to LeafNode


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.h	2008-07-23 05:15:04 UTC (rev 415)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.h	2008-08-01 13:46:36 UTC (rev 416)
@@ -10,7 +10,7 @@
 class Node;
 class GroupAcceptorNode;
 class GroupProviderNode;
-class Leaf;
+class LeafNode;
 class Model;
 class Body;
 class Group;
@@ -25,12 +25,12 @@
   { apply((Node&)node); }
   virtual void apply(GroupProviderNode& node)
   { apply((Node&)node); }
-  virtual void apply(Leaf& node)
+  virtual void apply(LeafNode& node)
   { apply((Node&)node); }
   virtual void apply(Model& node)
-  { apply((Leaf&)node); }
+  { apply((LeafNode&)node); }
   virtual void apply(Body& node)
-  { apply((Leaf&)node); }
+  { apply((LeafNode&)node); }
   virtual void apply(Group& node)
   { apply((Node&)node); }
 };



From frohlich at mail.berlios.de  Fri Aug  1 15:46:54 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Fri, 1 Aug 2008 15:46:54 +0200
Subject: [OpenFDM-svn] r417 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200808011346.m71DksAA014891@sheep.berlios.de>

Author: frohlich
Date: 2008-08-01 15:46:54 +0200 (Fri, 01 Aug 2008)
New Revision: 417

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/PortValueList.h
Log:
Cleanup of methods.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/PortValueList.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/PortValueList.h	2008-08-01 13:46:36 UTC (rev 416)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/PortValueList.h	2008-08-01 13:46:54 UTC (rev 417)
@@ -25,28 +25,22 @@
 public:
 
   // Accessors for real valued ports
+  bool isConnected(const RealInputPort& port) const
+  { return port.getPortValue(mPortValueVector); }
   bool isConnected(const RealOutputPort& port) const
   { return port.getPortValue(mPortValueVector); }
 
-  const real_type& getValue(const RealInputPort& port) const
-  { return port.getPortValue(mPortValueVector)->getValue()(0, 0); }
-  void setValue(const RealOutputPort& port, const real_type& value)
-  { port.getPortValue(mPortValueVector)->getValue()(0, 0) = value; }
-
   const real_type& operator[](const RealInputPort& port) const
   { return port.getPortValue(mPortValueVector)->getValue()(0, 0); }
   real_type& operator[](const RealOutputPort& port)
   { return port.getPortValue(mPortValueVector)->getValue()(0, 0); }
 
   // Accessors for matrix valued ports
+  bool isConnected(const MatrixInputPort& port) const
+  { return port.getPortValue(mPortValueVector); }
   bool isConnected(const MatrixOutputPort& port) const
   { return port.getPortValue(mPortValueVector); }
 
-  const Matrix& getValue(const MatrixInputPort& port) const
-  { return port.getPortValue(mPortValueVector)->getValue(); }
-  void setValue(const MatrixOutputPort& port, const Matrix& matrix)
-  { port.getPortValue(mPortValueVector)->setValue(matrix); }
-
   const Matrix& operator[](const MatrixInputPort& port) const
   { return port.getPortValue(mPortValueVector)->getValue(); }
   // FIXME, make sure that the size cannot change.



From frohlich at mail.berlios.de  Fri Aug  1 16:03:18 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Fri, 1 Aug 2008 16:03:18 +0200
Subject: [OpenFDM-svn] r418 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200808011403.m71E3Ixv016605@sheep.berlios.de>

Author: frohlich
Date: 2008-08-01 16:03:17 +0200 (Fri, 01 Aug 2008)
New Revision: 418

Added:
   branches/OpenFDM-StateSeparation/src/OpenFDM/BoolStateInfo.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/ContinousStateInfo.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/ContinousStateInfoVector.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/ContinousStateValueVector.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/DiscreteStateValueVector.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/MatrixStateInfo.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/RealStateInfo.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/StateInfo.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/StateInfoVector.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/TemplateContinousStateInfo.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/TemplateDiscreteStateInfo.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/TemplateInfoVector.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/TemplateStateInfo.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/TemplateValueVector.h
Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
Log:
Add some preliminary state infrastructure. Needs cleanup.



Added: branches/OpenFDM-StateSeparation/src/OpenFDM/BoolStateInfo.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/BoolStateInfo.h	2008-08-01 13:46:54 UTC (rev 417)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/BoolStateInfo.h	2008-08-01 14:03:17 UTC (rev 418)
@@ -0,0 +1,17 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_BoolStateInfo_H
+#define OpenFDM_BoolStateInfo_H
+
+#include "TemplateDiscreteStateInfo.h"
+
+namespace OpenFDM {
+
+class BoolStateInfo : public TemplateDiscreteStateInfo<bool> {
+};
+
+} // namespace OpenFDM
+
+#endif

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/ContinousStateInfo.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ContinousStateInfo.h	2008-08-01 13:46:54 UTC (rev 417)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ContinousStateInfo.h	2008-08-01 14:03:17 UTC (rev 418)
@@ -0,0 +1,26 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_ContinousStateInfo_H
+#define OpenFDM_ContinousStateInfo_H
+
+#include "StateInfo.h"
+
+namespace OpenFDM {
+
+class LeafContext;
+
+class ContinousStateInfo : public StateInfo {
+public:
+  ContinousStateValue* newStateValue(const LeafContext& leafContext) const
+  { return newStateValueImplementation(leafContext); }
+
+protected:
+  virtual ~ContinousStateInfo() {}
+  virtual ContinousStateValue* newStateValueImplementation(const LeafContext&) const = 0;
+};
+
+} // namespace OpenFDM
+
+#endif

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/ContinousStateInfoVector.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ContinousStateInfoVector.h	2008-08-01 13:46:54 UTC (rev 417)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ContinousStateInfoVector.h	2008-08-01 14:03:17 UTC (rev 418)
@@ -0,0 +1,18 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_ContinousStateInfoVector_H
+#define OpenFDM_ContinousStateInfoVector_H
+
+#include "ContinousStateInfo.h"
+#include "TemplateInfoVector.h"
+
+namespace OpenFDM {
+
+class ContinousStateInfoVector : public TemplateInfoVector<ContinousStateInfo> {
+};
+
+} // namespace OpenFDM
+
+#endif

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/ContinousStateValueVector.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ContinousStateValueVector.h	2008-08-01 13:46:54 UTC (rev 417)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ContinousStateValueVector.h	2008-08-01 14:03:17 UTC (rev 418)
@@ -0,0 +1,21 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_ContinousStateValueVector_H
+#define OpenFDM_ContinousStateValueVector_H
+
+#include "TemplateValueVector.h"
+#include "ContinousStateInfo.h"
+#include "ContinousStateValue.h"
+
+namespace OpenFDM {
+
+class ContinousStateValueVector :
+    public TemplateValueVector<ContinousStateInfo, ContinousStateValue> {
+public:
+};
+
+} // namespace OpenFDM
+
+#endif

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/DiscreteStateValueVector.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/DiscreteStateValueVector.h	2008-08-01 13:46:54 UTC (rev 417)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/DiscreteStateValueVector.h	2008-08-01 14:03:17 UTC (rev 418)
@@ -0,0 +1,21 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_DiscreteStateValueVector_H
+#define OpenFDM_DiscreteStateValueVector_H
+
+#include "TemplateValueVector.h"
+#include "StateInfo.h"
+#include "StateValue.h"
+
+namespace OpenFDM {
+
+class DiscreteStateValueVector :
+    public TemplateValueVector<StateInfo, StateValue> {
+public:
+};
+
+} // namespace OpenFDM
+
+#endif

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-08-01 13:46:54 UTC (rev 417)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-08-01 14:03:17 UTC (rev 418)
@@ -11,9 +11,14 @@
   AcceptorPortInfo.h \
   Assert.h \
   Atomic.h \
+  BoolStateInfo.h \
   ConstFrameVisitor.h \
+  ContinousStateInfo.h \
+  ContinousStateInfoVector.h \
   ContinousStateValue.h \
+  ContinousStateValueVector.h \
   CowPtr.h \
+  DiscreteStateValueVector.h \
   DoPri5.h \
   Environment.h \
   EnvironmentObject.h \
@@ -41,6 +46,7 @@
   MatrixInputPort.h \
   MatrixOutputPort.h \
   MatrixStateValue.h \
+  MatrixStateInfo.h \
   MidpointRule.h \
   Model.h \
   ModelGroup.h \
@@ -68,16 +74,24 @@
   ReaderWriter.h \
   RealInputPort.h \
   RealOutputPort.h \
+  RealStateInfo.h \
   Referenced.h \
   Rotation.h \
   SampleTime.h \
   ScopeLock.h \
   SharedPtr.h \
   StateStream.h \
+  StateInfo.h \
+  StateInfoVector.h \
   StateValue.h \
   System.h \
   TableData.h \
   TaskInfo.h \
+  TemplateContinousStateInfo.h \
+  TemplateDiscreteStateInfo.h \
+  TemplateInfoVector.h \
+  TemplateStateInfo.h \
+  TemplateValueVector.h \
   Time.h \
   Transform.h \
   TypeInfo.h \

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/MatrixStateInfo.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MatrixStateInfo.h	2008-08-01 13:46:54 UTC (rev 417)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MatrixStateInfo.h	2008-08-01 14:03:17 UTC (rev 418)
@@ -0,0 +1,18 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_MatrixStateInfo_H
+#define OpenFDM_MatrixStateInfo_H
+
+#include "Matrix.h"
+#include "TemplateContinousStateInfo.h"
+
+namespace OpenFDM {
+
+class MatrixStateInfo : public TemplateContinousStateInfo<Matrix> {
+};
+
+} // namespace OpenFDM
+
+#endif

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/RealStateInfo.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RealStateInfo.h	2008-08-01 13:46:54 UTC (rev 417)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RealStateInfo.h	2008-08-01 14:03:17 UTC (rev 418)
@@ -0,0 +1,18 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_RealStateInfo_H
+#define OpenFDM_RealStateInfo_H
+
+#include "TemplateContinousStateInfo.h"
+#include "Types.h"
+
+namespace OpenFDM {
+
+class RealStateInfo : public TemplateContinousStateInfo<real_type> {
+};
+
+} // namespace OpenFDM
+
+#endif

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/StateInfo.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/StateInfo.h	2008-08-01 13:46:54 UTC (rev 417)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/StateInfo.h	2008-08-01 14:03:17 UTC (rev 418)
@@ -0,0 +1,49 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_StateInfo_H
+#define OpenFDM_StateInfo_H
+
+#include "Referenced.h"
+
+namespace OpenFDM {
+
+class StateValue;
+class LeafContext;
+
+template<typename T>
+class TemplateInfoVector;
+
+class StateInfo : public Referenced {
+public:
+  StateInfo(unsigned index = 0) : mIndex(index)
+  { }
+
+  unsigned getIndex() const { return mIndex; }
+
+  // FIXME: Do we need that mechanism to allocate that stuff?
+  // May be the Leaf::alloc routine does that well??
+  StateValue* newStateValue(const LeafContext& leafContext) const
+  { return newStateValueImplementation(leafContext); }
+
+  // Used for trimming, the target function should be zero, if well trimmed
+  // virtual real_type trimError(const StateValue&, const StateValue&) const
+  // { return 0; }
+
+  static void destroy(StateInfo* stateInfo)
+  { delete stateInfo; }
+
+protected:
+  virtual ~StateInfo() {}
+  virtual StateValue* newStateValueImplementation(const LeafContext&) const = 0;
+
+private:
+  template<typename T>
+  friend class TemplateInfoVector;
+  unsigned mIndex;
+};
+
+} // namespace OpenFDM
+
+#endif

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/StateInfoVector.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/StateInfoVector.h	2008-08-01 13:46:54 UTC (rev 417)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/StateInfoVector.h	2008-08-01 14:03:17 UTC (rev 418)
@@ -0,0 +1,18 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_StateInfoVector_H
+#define OpenFDM_StateInfoVector_H
+
+#include "StateInfo.h"
+#include "TemplateInfoVector.h"
+
+namespace OpenFDM {
+
+class StateInfoVector : public TemplateInfoVector<StateInfo> {
+};
+
+} // namespace OpenFDM
+
+#endif

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/TemplateContinousStateInfo.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/TemplateContinousStateInfo.h	2008-08-01 13:46:54 UTC (rev 417)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/TemplateContinousStateInfo.h	2008-08-01 14:03:17 UTC (rev 418)
@@ -0,0 +1,21 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_TemplateContinousStateInfo_H
+#define OpenFDM_TemplateContinousStateInfo_H
+
+#include "ContinousStateInfo.h"
+#include "ContinousStateValue.h"
+#include "TemplateStateInfo.h"
+
+namespace OpenFDM {
+
+template<typename T>
+class TemplateContinousStateInfo : 
+    public TemplateStateInfo<T, ContinousStateInfo, ContinousStateValue> {
+};
+
+} // namespace OpenFDM
+
+#endif

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/TemplateDiscreteStateInfo.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/TemplateDiscreteStateInfo.h	2008-08-01 13:46:54 UTC (rev 417)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/TemplateDiscreteStateInfo.h	2008-08-01 14:03:17 UTC (rev 418)
@@ -0,0 +1,21 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_TemplateDiscreteStateInfo_H
+#define OpenFDM_TemplateDiscreteStateInfo_H
+
+#include "StateInfo.h"
+#include "StateValue.h"
+#include "TemplateStateInfo.h"
+
+namespace OpenFDM {
+
+template<typename T>
+class TemplateDiscreteStateInfo :
+    public TemplateStateInfo<T, StateInfo, StateValue> {
+};
+
+} // namespace OpenFDM
+
+#endif

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/TemplateInfoVector.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/TemplateInfoVector.h	2008-08-01 13:46:54 UTC (rev 417)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/TemplateInfoVector.h	2008-08-01 14:03:17 UTC (rev 418)
@@ -0,0 +1,59 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_TemplateInfoVector_H
+#define OpenFDM_TemplateInfoVector_H
+
+#include <vector>
+#include "SharedPtr.h"
+
+namespace OpenFDM {
+
+template<typename Info>
+class TemplateInfoVector {
+public:
+  Info* getStateInfo(unsigned index)
+  {
+    if (mStateInfoVector.size() <= index)
+      return 0;
+    return mStateInfoVector[index];
+  }
+  const Info* getStateInfo(unsigned index) const // ???
+  {
+    if (mStateInfoVector.size() <= index)
+      return 0;
+    return mStateInfoVector[index];
+  }
+  unsigned size() const
+  { return mStateInfoVector.size(); }
+  void addStateInfo(Info* stateInfo)
+  {
+    if (!stateInfo)
+      return;
+    stateInfo->mIndex = mStateInfoVector.size();
+    mStateInfoVector.push_back(stateInfo);
+  }
+  void removeStateInfo(Info* stateInfo)
+  {
+    if (!stateInfo)
+      return;
+    
+    typename StateInfoVector::iterator i;
+    i = std::find(mStateInfoVector.begin(), mStateInfoVector.end(), stateInfo);
+    if (i == mStateInfoVector.end())
+      return;
+    unsigned index = (*i)->mIndex;
+    i = mStateInfoVector.erase(i);
+    for (;i != mStateInfoVector.end(); ++i, ++index)
+      (*i)->mIndex = index;
+  }
+private:
+  typedef std::vector<SharedPtr<Info> > StateInfoVector;
+  StateInfoVector mStateInfoVector;
+};
+
+
+} // namespace OpenFDM
+
+#endif

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/TemplateStateInfo.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/TemplateStateInfo.h	2008-08-01 13:46:54 UTC (rev 417)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/TemplateStateInfo.h	2008-08-01 14:03:17 UTC (rev 418)
@@ -0,0 +1,49 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_TemplateStateInfo_H
+#define OpenFDM_TemplateStateInfo_H
+
+namespace OpenFDM {
+
+template<typename T, typename I, typename V>
+class TemplateStateInfo : public I {
+public:
+  typedef T value_type;
+
+  typedef value_type& reference;
+  typedef const value_type& const_reference;
+
+//   reference getValueReference(V* value) const
+  reference getValueReference(StateValue* value) const
+  {
+    OpenFDMAssert(value);
+    OpenFDMAssert(dynamic_cast<Value*>(value));
+    return static_cast<Value*>(value)->mValue;
+  }
+//   const_reference getValueReference(const V* value) const
+  const_reference getValueReference(const StateValue* value) const
+  {
+    OpenFDMAssert(value);
+    OpenFDMAssert(dynamic_cast<const Value*>(value));
+    return static_cast<const Value*>(value)->mValue;
+  }
+
+  reference getValue(TemplateValueVector<I,V>& valueVector) const
+  { return getValueReference(valueVector.getValue(*this)); }
+  const_reference getValue(const TemplateValueVector<I,V>& valueVector) const
+  { return getValueReference(valueVector.getValue(*this)); }
+
+// protected:
+  struct Value : public V {
+    value_type mValue;
+  };
+
+  virtual Value* newStateValueImplementation(const LeafContext&) const
+  { return new Value; }
+};
+
+} // namespace OpenFDM
+
+#endif

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/TemplateValueVector.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/TemplateValueVector.h	2008-08-01 13:46:54 UTC (rev 417)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/TemplateValueVector.h	2008-08-01 14:03:17 UTC (rev 418)
@@ -0,0 +1,58 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_TemplateValueVector_H
+#define OpenFDM_TemplateValueVector_H
+
+#include <vector>
+#include "SharedPtr.h"
+
+namespace OpenFDM {
+
+template<typename Info, typename Value>
+class TemplateValueVector {
+public:
+  Value* getValue(const Info& info)
+  {
+    if (mValueVector.size() <= info.getIndex())
+      return 0;
+    return mValueVector[info.getIndex()];
+  }
+  const Value* getValue(const Info& info) const
+  {
+    if (mValueVector.size() <= info.getIndex())
+      return 0;
+    return mValueVector[info.getIndex()];
+  }
+
+  // FIXME: can I avoid that in this class??,
+  void setValue(const Info& info, const LeafContext& leafContext)
+  {
+    if (mValueVector.size() <= info.getIndex())
+      mValueVector.resize(info.getIndex()+1);
+    mValueVector[info.getIndex()] = info.newStateValue(leafContext);
+  }
+
+  void setValue(const Info& info, Value* value)
+  {
+    if (mValueVector.size() <= info.getIndex())
+      mValueVector.resize(info.getIndex()+1);
+    mValueVector[info.getIndex()] = value;
+  }
+
+  template<typename T>
+  typename T::reference operator[](const T& info)
+  { return info.getValueReference(getValue(info)); }
+  template<typename T>
+  typename T::const_reference operator[](const T& info) const
+  { return info.getValueReference(getValue(info)); }
+
+protected:
+  typedef std::vector<SharedPtr<Value> > ValueVector;
+  ValueVector mValueVector;
+};
+
+} // namespace OpenFDM
+
+#endif



From frohlich at mail.berlios.de  Fri Aug  1 16:24:16 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Fri, 1 Aug 2008 16:24:16 +0200
Subject: [OpenFDM-svn] r419 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200808011424.m71EOGvH018782@sheep.berlios.de>

Author: frohlich
Date: 2008-08-01 16:24:16 +0200 (Fri, 01 Aug 2008)
New Revision: 419

Added:
   branches/OpenFDM-StateSeparation/src/OpenFDM/LeafNode.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/LeafNode.h
Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/ContinousStateInfo.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
   branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.h
Log:
Add LeafNode implementation.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/ContinousStateInfo.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ContinousStateInfo.h	2008-08-01 14:03:17 UTC (rev 418)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ContinousStateInfo.h	2008-08-01 14:24:16 UTC (rev 419)
@@ -5,6 +5,7 @@
 #ifndef OpenFDM_ContinousStateInfo_H
 #define OpenFDM_ContinousStateInfo_H
 
+#include "ContinousStateValue.h"
 #include "StateInfo.h"
 
 namespace OpenFDM {

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/LeafNode.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/LeafNode.cpp	2008-08-01 14:03:17 UTC (rev 418)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/LeafNode.cpp	2008-08-01 14:24:16 UTC (rev 419)
@@ -0,0 +1,25 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
+ *
+ */
+
+#include "LeafNode.h"
+#include "NodeVisitor.h"
+
+namespace OpenFDM {
+
+LeafNode::LeafNode(const std::string& name) :
+  Node(name)
+{
+}
+
+LeafNode::~LeafNode()
+{
+}
+
+void
+LeafNode::accept(NodeVisitor& visitor)
+{
+  visitor.apply(*this);
+}
+
+} // namespace OpenFDM

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/LeafNode.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/LeafNode.h	2008-08-01 14:03:17 UTC (rev 418)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/LeafNode.h	2008-08-01 14:24:16 UTC (rev 419)
@@ -0,0 +1,71 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_LeafNode_H
+#define OpenFDM_LeafNode_H
+
+#include <string>
+#include "Node.h"
+#include "ContinousStateInfoVector.h"
+#include "StateInfoVector.h"
+
+namespace OpenFDM {
+
+class LeafContext;
+class NodeVisitor;
+class ContinousStateValueVector;
+class DiscreteStateValueVector;
+
+class LeafNode : public Node {
+public:
+  LeafNode(const std::string& name);
+
+  virtual void accept(NodeVisitor& visitor);
+
+  // Is done once before a model starts to live
+  // Should have connect information here, can setup memory allocations and
+  // sizes. Then the PortValueList does not need to have resizable stuff.
+  // The same goes for the states.
+  virtual bool alloc(LeafContext&) const // = 0;
+  { return true; }
+
+  virtual void init(DiscreteStateValueVector&, ContinousStateValueVector&) const // = 0;
+  { }
+
+  // for dependency analysis
+  virtual bool dependsOn(const PortId& in, const PortId& out) const = 0;
+
+  unsigned getNumContinousStateValues() const
+  { return mContinousStateInfoVector.size(); }
+  const ContinousStateInfo* getContinousStateInfo(unsigned index) const
+  { return mContinousStateInfoVector.getStateInfo(index); }
+
+  unsigned getNumDiscreteStateValues() const
+  { return mDiscreteStateInfoVector.size(); }
+  const StateInfo* getDiscreteStateInfo(unsigned index) const
+  { return mDiscreteStateInfoVector.getStateInfo(index); }
+
+protected:
+  virtual ~LeafNode();
+
+  void addContinousStateInfo(ContinousStateInfo* stateInfo)
+  { mContinousStateInfoVector.addStateInfo(stateInfo); }
+  void removeContinousStateInfo(ContinousStateInfo* stateInfo)
+  { mContinousStateInfoVector.removeStateInfo(stateInfo); }
+
+  void addDiscreteStateInfo(StateInfo* stateInfo)
+  { mDiscreteStateInfoVector.addStateInfo(stateInfo); }
+  void removeDiscreteStateInfo(StateInfo* stateInfo)
+  { mDiscreteStateInfoVector.removeStateInfo(stateInfo); }
+
+private:
+  
+  // FIXME ???
+  ContinousStateInfoVector mContinousStateInfoVector;
+  StateInfoVector mDiscreteStateInfoVector;
+};
+
+} // namespace OpenFDM
+
+#endif

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-08-01 14:03:17 UTC (rev 418)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-08-01 14:24:16 UTC (rev 419)
@@ -31,6 +31,7 @@
   GroupOutput.h \
   ImplicitEuler.h \
   Inertia.h \
+  LeafNode.h \
   Limits.h \
   LinAlg/Algorithm.h \
   LinAlg/Array.h \
@@ -109,6 +110,7 @@
   Atomic.cpp \
   ContinousStateValue.cpp \
   Frame.cpp \
+  LeafNode.cpp \
   Logger.cpp \
   MatrixStateValue.cpp \
   Node.cpp \

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.cpp	2008-08-01 14:03:17 UTC (rev 418)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.cpp	2008-08-01 14:24:16 UTC (rev 419)
@@ -4,10 +4,23 @@
 
 #include "NodeVisitor.h"
 
+#include "LeafNode.h"
+
 namespace OpenFDM {
 
 NodeVisitor::~NodeVisitor()
 {
 }
 
+void
+NodeVisitor::apply(Node&)
+{
+}
+
+void
+NodeVisitor::apply(LeafNode& leafNode)
+{
+  apply(static_cast<Node&>(leafNode));
+}
+
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.h	2008-08-01 14:03:17 UTC (rev 418)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.h	2008-08-01 14:24:16 UTC (rev 419)
@@ -19,14 +19,12 @@
 public:
   virtual ~NodeVisitor();
 
-  virtual void apply(Node& node)
-  { }
+  virtual void apply(Node& node);
   virtual void apply(GroupAcceptorNode& node)
   { apply((Node&)node); }
   virtual void apply(GroupProviderNode& node)
   { apply((Node&)node); }
-  virtual void apply(LeafNode& node)
-  { apply((Node&)node); }
+  virtual void apply(LeafNode& node);
   virtual void apply(Model& node)
   { apply((LeafNode&)node); }
   virtual void apply(Body& node)



From frohlich at mail.berlios.de  Fri Aug  1 22:05:35 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Fri, 1 Aug 2008 22:05:35 +0200
Subject: [OpenFDM-svn] r420 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200808012005.m71K5ZRa009244@sheep.berlios.de>

Author: frohlich
Date: 2008-08-01 22:05:34 +0200 (Fri, 01 Aug 2008)
New Revision: 420

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Node.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Node.h
Log:
Add Object defines.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Node.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Node.cpp	2008-08-01 14:24:16 UTC (rev 419)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Node.cpp	2008-08-01 20:05:34 UTC (rev 420)
@@ -7,6 +7,9 @@
 
 namespace OpenFDM {
 
+BEGIN_OPENFDM_OBJECT_DEF(Node, Object)
+  END_OPENFDM_OBJECT_DEF
+
 Node::Node(const std::string& name) :
   Object(name)
 {

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Node.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Node.h	2008-08-01 14:24:16 UTC (rev 419)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Node.h	2008-08-01 20:05:34 UTC (rev 420)
@@ -17,6 +17,7 @@
 class NodeVisitor;
 
 class Node : public Object {
+  OPENFDM_OBJECT(Node, Object);
 public:
   Node(const std::string& name = std::string());
   virtual ~Node();



From frohlich at mail.berlios.de  Fri Aug  1 22:08:15 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Fri, 1 Aug 2008 22:08:15 +0200
Subject: [OpenFDM-svn] r421 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200808012008.m71K8FO1009339@sheep.berlios.de>

Author: frohlich
Date: 2008-08-01 22:08:15 +0200 (Fri, 01 Aug 2008)
New Revision: 421

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/LeafNode.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/LeafNode.h
Log:
Add Object defines.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/LeafNode.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/LeafNode.cpp	2008-08-01 20:05:34 UTC (rev 420)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/LeafNode.cpp	2008-08-01 20:08:15 UTC (rev 421)
@@ -7,6 +7,9 @@
 
 namespace OpenFDM {
 
+BEGIN_OPENFDM_OBJECT_DEF(LeafNode, Node)
+  END_OPENFDM_OBJECT_DEF
+
 LeafNode::LeafNode(const std::string& name) :
   Node(name)
 {

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/LeafNode.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/LeafNode.h	2008-08-01 20:05:34 UTC (rev 420)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/LeafNode.h	2008-08-01 20:08:15 UTC (rev 421)
@@ -18,6 +18,7 @@
 class DiscreteStateValueVector;
 
 class LeafNode : public Node {
+  OPENFDM_OBJECT(LeafNode, Node);
 public:
   LeafNode(const std::string& name);
 



From frohlich at mail.berlios.de  Sun Aug  3 14:56:10 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 3 Aug 2008 14:56:10 +0200
Subject: [OpenFDM-svn] r422 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200808031256.m73CuAK2002892@sheep.berlios.de>

Author: frohlich
Date: 2008-08-03 14:56:09 +0200 (Sun, 03 Aug 2008)
New Revision: 422

Removed:
   branches/OpenFDM-StateSeparation/src/OpenFDM/ModelVisitor.h
Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
Log:
Remove ModelVisitor


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-08-01 20:08:15 UTC (rev 421)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-08-03 12:56:09 UTC (rev 422)
@@ -51,7 +51,6 @@
   MidpointRule.h \
   Model.h \
   ModelGroup.h \
-  ModelVisitor.h \
   Mutex.h \
   MPFRFloat.h \
   Newton.h \

Deleted: branches/OpenFDM-StateSeparation/src/OpenFDM/ModelVisitor.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ModelVisitor.h	2008-08-01 20:08:15 UTC (rev 421)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ModelVisitor.h	2008-08-03 12:56:09 UTC (rev 422)
@@ -1,84 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
- *
- */
-
-#ifndef OpenFDM_ModelVisitor_H
-#define OpenFDM_ModelVisitor_H
-
-#include "Model.h"
-#include "Output.h"
-#include "Input.h"
-#include "ModelGroup.h"
-#include "RigidBody.h"
-#include "MobileRootJoint.h"
-#include "System.h"
-
-namespace OpenFDM {
-
-class ModelVisitor {
-public:
-  virtual ~ModelVisitor(void)
-  { }
-
-  virtual void apply(Node& node)
-  { }
-
-  virtual void apply(Model& model)
-  { apply(static_cast<Node&>(model)); }
-  virtual void apply(ModelGroup& modelGroup)
-  { apply(static_cast<Node&>(modelGroup)); }
-
-  virtual void apply(Output& output)
-  { apply(static_cast<Model&>(output)); }
-  virtual void apply(Input& input)
-  { apply(static_cast<Model&>(input)); }
-  virtual void apply(Interact& interact)
-  { apply(static_cast<Model&>(interact)); }
-
-  virtual void apply(System& system)
-  { apply(static_cast<ModelGroup&>(system)); }
-
-  virtual void apply(Joint& joint)
-  { apply(static_cast<Interact&>(joint)); }
-
-  virtual void apply(MobileRootJoint& mobileRootJoint)
-  { apply(static_cast<Joint&>(mobileRootJoint)); }
-
-
-  const Node::Path& getNodePath() const
-  { return mNodePath; }
-
-protected:
-  /// Call this in the apply(ModelGroup&) method if you want to
-  /// traverse downward
-  inline void traverse(ModelGroup& modelGroup)
-  {
-    for (unsigned i = 0; i < modelGroup.getNumModels(); ++i) {
-      SharedPtr<Node> node = modelGroup.getModel(i);
-      mNodePath.push_back(node);
-      node->accept(*this);
-      mNodePath.pop_back();
-    }
-  }
-  /// Call this in the apply(ModelGroup&) method if you want to
-  /// traverse upward
-  inline void ascend(Node& node)
-  {
-    for (unsigned i = 0; i < node.getNumParents(); ++i) {
-      SharedPtr<ModelGroup> group = node.getParent(i).lock();
-      if (!group)
-        continue;
-      mNodePath.insert(mNodePath.begin(), group);
-      group->accept(*this);
-      mNodePath.erase(mNodePath.begin());
-    }
-  }
-
-private:
-  // The path that visitor has passed
-  Node::Path mNodePath;
-};
-
-} // namespace OpenFDM
-
-#endif



From frohlich at mail.berlios.de  Sat Aug 30 13:38:31 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 30 Aug 2008 13:38:31 +0200
Subject: [OpenFDM-svn] r423 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200808301138.m7UBcVu3006760@sheep.berlios.de>

Author: frohlich
Date: 2008-08-30 13:38:31 +0200 (Sat, 30 Aug 2008)
New Revision: 423

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
   branches/OpenFDM-StateSeparation/src/OpenFDM/Model.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Model.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.h
Log:
Model base class - now in svn.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-08-03 12:56:09 UTC (rev 422)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-08-30 11:38:31 UTC (rev 423)
@@ -112,6 +112,7 @@
   LeafNode.cpp \
   Logger.cpp \
   MatrixStateValue.cpp \
+  Model.cpp \
   Node.cpp \
   NodeVisitor.cpp \
   NumericPortValue.cpp \
@@ -136,7 +137,6 @@
 #   ImplicitEuler.cpp \
 #   Newton.cpp \
 #   MidpointRule.cpp \
-#   Model.cpp \
 #   ModelGroup.cpp \
 #   ReaderWriter.cpp \
 #   ODESolver.cpp \

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Model.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Model.cpp	2008-08-03 12:56:09 UTC (rev 422)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Model.cpp	2008-08-30 11:38:31 UTC (rev 423)
@@ -4,401 +4,27 @@
 
 #include "Model.h"
 
-#include <algorithm>
-
 #include "LogStream.h"
-#include "ModelVisitor.h"
+#include "NodeVisitor.h"
 
 namespace OpenFDM {
 
-BEGIN_OPENFDM_OBJECT_DEF(Node, Object)
+BEGIN_OPENFDM_OBJECT_DEF(Model, LeafNode)
   END_OPENFDM_OBJECT_DEF
 
-Node::Node(const std::string& name) :
-  Object(name)
-{
-}
-
-Node::~Node(void)
-{
-}
-
-void
-Node::accept(ModelVisitor& visitor)
-{
-  visitor.apply(*this);
-}
-
-const Model*
-Node::toModel(void) const
-{
-  return 0;
-}
-
-Model*
-Node::toModel(void)
-{
-  return 0;
-}
-
-const ModelGroup*
-Node::toModelGroup(void) const
-{
-  return 0;
-}
-
-ModelGroup*
-Node::toModelGroup(void)
-{
-  return 0;
-}
-
-unsigned
-Node::getNumParents(void) const
-{
-  return mParents.size();
-}
-
-WeakPtr<const ModelGroup>
-Node::getParent(unsigned idx) const
-{
-  if (mParents.size() <= idx)
-    return WeakPtr<const ModelGroup>(0);
-  return mParents[idx];
-}
-
-WeakPtr<ModelGroup>
-Node::getParent(unsigned idx)
-{
-  if (mParents.size() <= idx)
-    return WeakPtr<ModelGroup>(0);
-  return mParents[idx];
-}
-
-class Node::PathListCollector :
-    public ModelVisitor {
-public:
-  virtual void apply(Node& node)
-  {
-    // First go up and collect the path above.
-    // When we are back here append this.
-    if (0 < node.getNumParents())
-      ascend(node);
-    else
-      pathList.push_back(getNodePath());
-  }
-  Node::PathList pathList;
-};
-
-Node::GroupPath
-Node::getPath()
-{
-  PathList pathList = getParentPathList();
-  GroupPath path;
-  if (!pathList.empty()) {
-    Path::iterator i;
-    for (i = pathList.back().begin(); i != pathList.back().end(); ++i) {
-      ModelGroup* modelGroup = (*i)->toModelGroup();
-      OpenFDMAssert(modelGroup);
-      path.push_back(modelGroup);
-    }
-  }
-  return path;
-}
-
-Node::PathList
-Node::getParentPathList()
-{
-  PathListCollector pathListCollector;
-  accept(pathListCollector);
-  return pathListCollector.pathList;
-}
-
-unsigned
-Node::addParent(ModelGroup* model)
-{
-  if (!model)
-    return ~0u;
-  mParents.push_back(WeakPtr<ModelGroup>(model));
-  return mParents.size() - 1;
-}
-
-void
-Node::removeParent(unsigned idx)
-{
-  if (mParents.size() <= idx)
-    return;
-  ParentList::iterator i = mParents.begin();
-  std::advance(i, idx);
-  mParents.erase(i);
-}
-
-void
-Node::setNumInputPorts(unsigned num)
-{
-  // Ok, strange, but required ...
-  unsigned oldSize = mInputPorts.size();
-  mInputPorts.resize(num);
-  for (; oldSize < mInputPorts.size(); ++oldSize) {
-    mInputPorts[oldSize] = new NumericPortAcceptor(this);
-  }
-}
-
-void
-Node::setNumOutputPorts(unsigned num)
-{
-  // Ok, strange, but required ...
-  unsigned oldSize = mOutputPorts.size();
-  mOutputPorts.resize(num);
-  for (; oldSize < mOutputPorts.size(); ++oldSize) {
-    mOutputPorts[oldSize] = new NumericPortProvider(this);
-  }
-}
-
-
-
-
-
-
-
-BEGIN_OPENFDM_OBJECT_DEF(Model, Node)
-  DEF_OPENFDM_ROPROP(Unsigned, NumContinousStates)
-  DEF_OPENFDM_ROPROP(Unsigned, NumDiscreteStates)
-  DEF_OPENFDM_ROPROP(Bool, DirectFeedThrough)
-  END_OPENFDM_OBJECT_DEF
-
 Model::Model(const std::string& name) :
-  Node(name),
-  mNumContinousStates(0l),
-  mNumDiscreteStates(0l),
-  mDirectFeedThrough(false),
-  mEnabled(true),
-  mNextEnabled(true),
-  mEnablePort(new NumericPortAcceptor(this)),
-  mDisableMode(Hold)
+  LeafNode(name)
 {
 }
 
-Model::~Model(void)
+Model::~Model()
 {
 }
 
 void
-Model::accept(ModelVisitor& visitor)
+Model::accept(NodeVisitor& visitor)
 {
   visitor.apply(*this);
 }
 
-const Input*
-Model::toInput(void) const
-{
-  return 0;
-}
-
-Input*
-Model::toInput(void)
-{
-  return 0;
-}
-
-const Output*
-Model::toOutput(void) const
-{
-  return 0;
-}
-
-Output*
-Model::toOutput(void)
-{
-  return 0;
-}
-
-const Interact*
-Model::toInteract(void) const
-{
-  return 0;
-}
-
-Interact*
-Model::toInteract(void)
-{
-  return 0;
-}
-
-bool
-Model::init(void)
-{
-  if (mEnablePort)
-    mEnablePortHandle = mEnablePort->toRealPortHandle();
-  else
-    mEnablePortHandle = 0;
-  return true;
-}
-
-void
-Model::output(const TaskInfo&)
-{
-}
-
-void
-Model::update(const TaskInfo&)
-{
-}
-
-void
-Model::setState(const StateStream& state)
-{
-}
-
-void
-Model::getState(StateStream& state) const
-{
-}
-
-void
-Model::getStateDeriv(StateStream& stateDeriv)
-{
-}
-
-void
-Model::setDiscreteState(const StateStream& state)
-{
-}
-
-void
-Model::getDiscreteState(StateStream& state) const
-{
-}
-
-bool
-Model::dependsDirectOn(Model* model)
-{
-  if (!mDirectFeedThrough)
-    return false;
-
-  // FIXME HACK, outputs of interacts only depend on its state ...
-  // FIXME is this always true??
-  Interact* interact = model->toInteract();
-  if (interact)
-    return false;
-
-  // return true if any output of model is connected to any input of this
-  for (unsigned i = 0; i < getNumInputPorts(); ++i) {
-    for (unsigned j = 0; j < model->getNumOutputPorts(); ++j) {
-      if (getInputPort(i)->getPortInterface() ==
-          model->getOutputPort(j)->getPortInterface())
-        return true;
-    }
-  }
-
-  return false;
-}
-
-const std::string&
-Model::getInputPortName(unsigned i) const
-{
-  OpenFDMAssert(i < mInputPorts.size());
-  return mInputPorts[i]->getName();
-}
-
-NumericPortAcceptor*
-Model::getInputPort(const std::string& name)
-{
-  // Check if this one exists and return its value.
-  InputPortVector::iterator it = mInputPorts.begin();
-  while (it != mInputPorts.end()) {
-    if ((*it)->getName() == name)
-      return *it;
-    ++it;
-  }
-  return 0;
-}
-
-NumericPortProvider*
-Model::getOutputPort(const std::string& name)
-{
-  // Check if this one exists and return its value.
-  OutputPortVector::iterator it = mOutputPorts.begin();
-  while (it != mOutputPorts.end()) {
-    if ((*it)->getName() == name)
-      return *it;
-    ++it;
-  }
-
-  Log(Model, Error) << "Output port name \"" << name << "\" not found in \""
-                    << getName() << "\"" << endl;
-  return 0;
-}
-
-const std::string&
-Model::getOutputPortName(unsigned i) const
-{
-  OpenFDMAssert(i < mOutputPorts.size());
-  return mOutputPorts[i]->getName();
-}
-
-void
-Model::setInputPortName(unsigned i, const std::string& name)
-{
-  OpenFDMAssert(i < mInputPorts.size());
-  mInputPorts[i]->setName(name);
-}
-
-void
-Model::setOutputPort(unsigned i, const std::string& name,
-                     PortInterface* portInterface)
-{
-  OpenFDMAssert(i < mOutputPorts.size());
-
-  NumericPortProvider* portProvider = new NumericPortProvider(this);
-  portProvider->setPortInterface(portInterface);
-  portProvider->setName(name);
-  mOutputPorts[i] = portProvider;
-}
-
-void
-Model::setNumContinousStates(unsigned numContinousStates)
-{
-  mNumContinousStates = numContinousStates;
-}
-
-void
-Model::setNumDiscreteStates(unsigned numDiscreteStates)
-{
-  mNumDiscreteStates = numDiscreteStates;
-}
-
-void
-Model::setEnvironment(Environment* environment)
-{
-}
-
-void
-Model::setEnabledUnconditional(bool enabled)
-{
-  if (mEnabled) {
-    switch (mDisableMode) {
-    case ResetHold:
-      /// If disabled, the models output/state is initialized
-      init();
-      break;
-    default:
-      break;
-    }
-  } else {
-    switch (mDisableMode) {
-    case HoldReset:
-      /// If disabled, the models output/state is just held. On reenable, the
-      /// the model is initialized
-      /// If disabled, the models output/state is initialized
-      init();
-      break;
-    default:
-      break;
-    }
-  }
-
-  mEnabled = enabled;
-}
-
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Model.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Model.h	2008-08-03 12:56:09 UTC (rev 422)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Model.h	2008-08-30 11:38:31 UTC (rev 423)
@@ -6,326 +6,57 @@
 #define OpenFDM_Model_H
 
 #include <string>
-#include <vector>
-#include <list>
-#include <algorithm>
 
 #include "OpenFDMConfig.h"
 #include "Assert.h"
-#include "LogStream.h"
-#include "Object.h"
-#include "Variant.h"
-#include "Vector.h"
-#include "SampleTime.h"
-#include "TaskInfo.h"
-#include "StateStream.h"
-#include "Connection.h"
-#include "Port.h"
-#include "NumericPortProvider.h"
-#include "NumericPortAcceptor.h"
+#include "LeafNode.h"
+#include "MatrixInputPort.h"
+#include "MatrixOutputPort.h"
+#include "RealInputPort.h"
+#include "RealOutputPort.h"
 
 namespace OpenFDM {
 
-class ModelGroup;
-class Environment;
-class GroupInput;
-class GroupOutput;
-class System;
-class Model;
+class DiscreteStateValueVector;
+class ContinousStateValueVector;
+class PortValueList;
+class ContinousStateValueVector;
 
-class Input;
-class Output;
-class Interact;
-class Joint;
-class MobileRootJoint;
-
-class ModelVisitor;
-class TaskInfo;
-
-class Node : public Object {
-  OPENFDM_OBJECT(Node, Object);
+class Model : public LeafNode {
+  OPENFDM_OBJECT(Model, LeafNode);
 public:
-  // FIXME
-  typedef std::list<SharedPtr<ModelGroup> > GroupPath;
-
-  // FIXME vector??
-  typedef std::vector<SharedPtr<Node> > Path;
-  typedef std::vector<Path> PathList;
-
-  Node(const std::string& name);
-  virtual ~Node(void);
-
-  /// Double dispatch helper for the system visitor
-  virtual void accept(ModelVisitor& visitor);
-  /// Double dispatch helper for the system visitor
-//   virtual void accept(ConstModelVisitor& visitor) const;
-
-  virtual const Model* toModel(void) const;
-  virtual Model* toModel(void);
-
-  virtual const ModelGroup* toModelGroup(void) const;
-  virtual ModelGroup* toModelGroup(void);
-
-  unsigned getNumParents(void) const;
-  WeakPtr<const ModelGroup> getParent(unsigned idx) const;
-  WeakPtr<ModelGroup> getParent(unsigned idx);
-
-  GroupPath getPath() OpenFDM_DEPRECATED;
-  /// Returns the list of paths leading to this Node.
-  PathList getParentPathList();
-
-  /// Returns the number of input properties.
-  unsigned getNumInputPorts(void) const
-  { return mInputPorts.size(); }
-  unsigned getNumOutputPorts(void) const
-  { return mOutputPorts.size(); }
-
-protected:
-  // Sets the parent model.
-  // FIXME: remove virtual here ...
-  virtual unsigned addParent(ModelGroup* model);
-  virtual void removeParent(unsigned idx);
-
-public:
-  /// FIXME
-  /// Sets the number of input properties.
-  void setNumInputPorts(unsigned num);
-  NumericPortAcceptor* getInputPort(unsigned i)
-  {
-    OpenFDMAssert(i < mInputPorts.size());
-    return mInputPorts[i];
-  }
-  void addInputPort(NumericPortAcceptor* port)
-  {
-    unsigned num = getNumInputPorts();
-    setNumInputPorts(num+1);
-    mInputPorts[num] = port;
-  }
-  void removeInputPort(NumericPortAcceptor* port)
-  {
-    InputPortVector::iterator i = std::find(mInputPorts.begin(),
-                                            mInputPorts.end(), port);
-    if (i == mInputPorts.end()) {
-      Log(Model,Error) << "Trying to remove foreign port" << endl;
-      return;
-    }
-    (*i)->invalidate();
-    mInputPorts.erase(i);
-  }
-
-  /// Sets the number of output properties.
-  void setNumOutputPorts(unsigned num);
-  NumericPortProvider* getOutputPort(unsigned i)
-  {
-    OpenFDMAssert(i < mOutputPorts.size());
-    return mOutputPorts[i];
-  }
-
-  /// Convenience shortcuts
-  void addOutputPort(NumericPortProvider* port)
-  {
-    unsigned num = getNumOutputPorts();
-    setNumOutputPorts(num+1);
-    mOutputPorts[num] = port;
-  }
-  void removeOutputPort(NumericPortProvider* port)
-  {
-    OutputPortVector::iterator i = std::find(mOutputPorts.begin(),
-                                             mOutputPorts.end(), port);
-    if (i == mOutputPorts.end()) {
-      Log(Model,Error) << "Trying to remove foreign port" << endl;
-      return;
-    }
-    (*i)->invalidate();
-    mOutputPorts.erase(i);
-  }
-
-protected:
-  typedef std::vector<SharedPtr<NumericPortAcceptor> > InputPortVector;
-  typedef std::vector<SharedPtr<NumericPortProvider> > OutputPortVector;
-  InputPortVector mInputPorts;
-  OutputPortVector mOutputPorts;
-  friend class GroupInput;
-  friend class GroupOutput;
-
-private:
-  class PathListCollector;
-
-  typedef std::vector<WeakPtr<ModelGroup> > ParentList;
-  ParentList mParents;
-
-  // FIXME
-  friend class ModelGroup;
-};
-
-
-class Model : public Node {
-  OPENFDM_OBJECT(Model, Node);
-public:
-  enum DisableMode {
-    /// If disabled, the models output/state is just held.
-    /// On reenable, the model just continues to work
-    Hold,
-    /// If disabled, the models output/state is just held.
-    /// On reenable, the model is initialized
-    HoldReset,
-    /// If disabled, the models output/state is initialized
-    ResetHold
-  };
-
   Model(const std::string& name);
-  virtual ~Model(void);
+  virtual ~Model();
 
-  /// Double dispatch helper for the system visitor
-  virtual void accept(ModelVisitor& visitor);
-  /// Double dispatch helper for the system visitor
-//   virtual void accept(ConstModelVisitor& visitor) const;
+  virtual void accept(NodeVisitor& visitor);
 
-  virtual const Input* toInput(void) const;
-  virtual Input* toInput(void);
+  // FIXME: May be we want to collapse all state values in one
+  // argument? May be it is sufficient to have a const and non const version??
+  // FIXME???
+  // const TaskInfo& taskInfo
+  virtual void update(DiscreteStateValueVector&, ContinousStateValueVector&,
+                      const PortValueList&) const { }
+  virtual void output(const DiscreteStateValueVector&,
+                      const ContinousStateValueVector&,
+                      PortValueList&) const { }
+  virtual void derivative(const DiscreteStateValueVector&,
+                          const ContinousStateValueVector&,
+                          const PortValueList&,
+                          ContinousStateValueVector&) const { }
 
-  virtual const Output* toOutput(void) const;
-  virtual Output* toOutput(void);
-
-  virtual const Interact* toInteract(void) const;
-  virtual Interact* toInteract(void);
-
-  /// Called on each system initialization.
-  virtual bool init(void);
-  /// Called when the outputs need to be prepared for the next step.
-  /// Note that this is called *before* update() is called.
-  virtual void output(const TaskInfo& taskInfo /*const TaskSet& ??*/);
-  /// Called whenever discrete states need to be updated.
-  virtual void update(const TaskInfo& taskInfo /*const Task& ??*/);
-
-  /// Convinience functions may make the virtuals protected ...
-  void outputIfEnabled(const TaskInfo& taskInfo)
-  {
-    /// FIXME: should that only be checked for discrete tasks???
-    /// May be with a special list in System to know which ones need to recheck
-    /// the enable ports ???
-    setEnabled(mNextEnabled);
-    if (mEnabled)
-      output(taskInfo);
-  }
-  void updateIfEnabled(const TaskInfo& taskInfo)
-  {
-    if (mEnabled)
-      update(taskInfo);
-    if (mEnablePortHandle.isConnected()) {
-      /// FIXME bool!!!!
-      mNextEnabled = 0.5 < fabs(mEnablePortHandle.getRealValue());
-    }
-  }
-
-  virtual void setState(const StateStream& state);
-  virtual void getState(StateStream& state) const;
-  virtual void getStateDeriv(StateStream& stateDeriv);
-
-  virtual void setDiscreteState(const StateStream& state);
-  virtual void getDiscreteState(StateStream& state) const;
-
-  /// Must return true if the model given in the argument must be scheduled
-  /// before this one because of input data dependencies
-  virtual bool dependsDirectOn(Model* model);
-
-  /// Return the number of continous states
-  unsigned getNumContinousStates(void) const
-  { return mNumContinousStates; }
-  /// Return the number of discrete states
-  unsigned getNumDiscreteStates(void) const
-  { return mNumDiscreteStates; }
-  /// Return if the outputs containe a direct dependency on an input
-  bool getDirectFeedThrough(void) const
-  { return mDirectFeedThrough; }
-  /// Return if the outputs containe a direct dependency on an input
-  bool getEnabled(void) const
-  { return mEnabled; }
-  void setEnabled(bool enabled)
-  { if (mEnabled != enabled) setEnabledUnconditional(enabled); }
-  DisableMode getDisableMode(void) const
-  { return mDisableMode; }
-  void setDisableMode(DisableMode disableMode)
-  { mDisableMode = disableMode; }
-
-  bool addSampleTime(const SampleTime& sampleTime)
-  { return mSampleTimeSet.addSampleTime(sampleTime); }
-  bool removeSampleTime(const SampleTime& sampleTime)
-  { return mSampleTimeSet.removeSampleTime(sampleTime); }
-  const SampleTimeSet& getSampleTimeSet(void) const
-  { return mSampleTimeSet; }
-  
-
-  /// Returns the name of the i-th input property.
-  const std::string& getInputPortName(unsigned i) const;
-
-  /// Sets the i-th input property.
-  NumericPortAcceptor* getInputPort(const std::string& name);
-  NumericPortAcceptor* getEnablePort(void)
-  { return mEnablePort; }
-  using Node::getInputPort;
-
-  NumericPortProvider* getOutputPort(const std::string& name);
-  const std::string& getOutputPortName(unsigned i) const;
-  using Node::getOutputPort;
-
 protected:
-  void setNumContinousStates(unsigned numContinousStates);
-  void setNumDiscreteStates(unsigned numDiscreteStates);
-  void setDirectFeedThrough(bool directFeedThrough)
-  { mDirectFeedThrough = directFeedThrough; }
-
-  /// Sets the name of the i-th input property.
-  void setInputPortName(unsigned i, const std::string& name);
-
-  /// Sets the name of the i-th output property.
-  void setOutputPort(unsigned i, const std::string& name,
-                     PortInterface* portInterface);
-  /// the real used interface
-  template<typename M>
-  void setOutputPort(unsigned i, const std::string& name, M* model,
-                     const real_type& (M::*getter)(void) const)
-  { setOutputPort(i, name, new RealGetterPortInterface<M>(model, getter)); }
-  template<typename M>
-  void setOutputPort(unsigned i, const std::string& name, M* model,
-                     const Matrix& (M::*getter)(void) const)
-  { setOutputPort(i, name, new MatrixGetterPortInterface<M>(model, getter)); }
-
-  void addOutputPort(const std::string& name, PortInterface* portInterface)
-  {
-    unsigned num = getNumOutputPorts();
-    setNumOutputPorts(num+1);
-    setOutputPort(num, name, portInterface);
-  }
-  template<typename M>
-  void addOutputPort(const std::string& name, M* model,
-                     const real_type& (M::*getter)(void) const)
-  { addOutputPort(name, new RealGetterPortInterface<M>(model, getter)); }
-  template<typename M>
-  void addOutputPort(const std::string& name, M* model,
-                     const Matrix& (M::*getter)(void) const)
-  { addOutputPort(name, new MatrixGetterPortInterface<M>(model, getter)); }
-
-  // FIXME
-  friend class System;
-  virtual void setEnvironment(Environment* environment);
-
-private:
-  void setEnabledUnconditional(bool enabled);
-
-  unsigned mNumContinousStates;
-  unsigned mNumDiscreteStates;
-  bool mDirectFeedThrough;
-  /// True if the Model is enabled
-  bool mEnabled;
-  bool mNextEnabled;
-  SharedPtr<NumericPortAcceptor> mEnablePort;
-  RealPortHandle mEnablePortHandle;
-  DisableMode mDisableMode;
-  SampleTimeSet mSampleTimeSet;
-
-  // FIXME
-  friend class ModelGroup;
+  MatrixOutputPort
+  newMatrixOutputPort(const std::string& name, const Size& size = Size(0, 0))
+  { return MatrixOutputPort(this, name, size); }
+  MatrixInputPort
+  newMatrixInputPort(const std::string& name, const Size& size = Size(0, 0))
+  { return MatrixInputPort(this, name, size); }
+  RealOutputPort
+  newRealOutputPort(const std::string& name)
+  { return RealOutputPort(this, name); }
+  RealInputPort
+  newRealInputPort(const std::string& name)
+  { return RealInputPort(this, name); }
 };
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.cpp	2008-08-03 12:56:09 UTC (rev 422)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.cpp	2008-08-30 11:38:31 UTC (rev 423)
@@ -5,6 +5,7 @@
 #include "NodeVisitor.h"
 
 #include "LeafNode.h"
+#include "Model.h"
 
 namespace OpenFDM {
 
@@ -23,4 +24,10 @@
   apply(static_cast<Node&>(leafNode));
 }
 
+void
+NodeVisitor::apply(Model& node)
+{
+  apply(static_cast<LeafNode&>(node));
+}
+
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.h	2008-08-03 12:56:09 UTC (rev 422)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.h	2008-08-30 11:38:31 UTC (rev 423)
@@ -19,14 +19,13 @@
 public:
   virtual ~NodeVisitor();
 
-  virtual void apply(Node& node);
+  virtual void apply(Node&);
   virtual void apply(GroupAcceptorNode& node)
   { apply((Node&)node); }
   virtual void apply(GroupProviderNode& node)
   { apply((Node&)node); }
-  virtual void apply(LeafNode& node);
-  virtual void apply(Model& node)
-  { apply((LeafNode&)node); }
+  virtual void apply(LeafNode&);
+  virtual void apply(Model&);
   virtual void apply(Body& node)
   { apply((LeafNode&)node); }
   virtual void apply(Group& node)



From frohlich at mail.berlios.de  Sat Aug 30 14:17:08 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 30 Aug 2008 14:17:08 +0200
Subject: [OpenFDM-svn] r424 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200808301217.m7UCH83N008823@sheep.berlios.de>

Author: frohlich
Date: 2008-08-30 14:17:08 +0200 (Sat, 30 Aug 2008)
New Revision: 424

Added:
   branches/OpenFDM-StateSeparation/src/OpenFDM/LeafContext.h
Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Gain.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Gain.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
Log:
Implement a gain Model.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Gain.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Gain.cpp	2008-08-30 11:38:31 UTC (rev 423)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Gain.cpp	2008-08-30 12:17:08 UTC (rev 424)
@@ -9,8 +9,9 @@
 
 #include "Assert.h"
 #include "Object.h"
-#include "Vector.h"
+#include "LeafContext.h"
 #include "Model.h"
+#include "Vector.h"
 
 namespace OpenFDM {
 
@@ -20,41 +21,39 @@
 
 Gain::Gain(const std::string& name) :
   Model(name),
+  mInputPort(newMatrixInputPort("input")),
+  mOutputPort(newMatrixOutputPort("output")),
   mGain(1)
 {
-  setDirectFeedThrough(true);
-  
-  setNumInputPorts(1);
-  setInputPortName(0, "input");
-  
-  setNumOutputPorts(1);
-  setOutputPort(0, "output", this, &Gain::getOutput);
 }
 
 Gain::~Gain(void)
 {
 }
-  
+
 bool
-Gain::init(void)
+Gain::alloc(LeafContext& leafContext) const
 {
-  mInputPort = getInputPort(0)->toMatrixPortHandle();
-  if (!mInputPort.isConnected()) {
-    Log(Model, Error) << "Initialization of Gain model \"" << getName()
-                      << "\" failed: Input port \"" << getInputPortName(0)
-                      << "\" is not connected!" << endl;
-    return false;
-  }
-  mOutput.resize(mInputPort.getMatrixValue());
+  Size sz = size(leafContext.mPortValueList[mInputPort]);
+  leafContext.mPortValueList.setPortSize(mOutputPort, sz);
+  return true;
+}
 
-  return Model::init();
+void
+Gain::output(const DiscreteStateValueVector&, const ContinousStateValueVector&,
+             PortValueList& portValues) const
+{
+  portValues[mOutputPort] = mGain*portValues[mInputPort];
 }
 
-void Gain::output(const TaskInfo&)
+bool
+Gain::dependsOn(const PortId& in, const PortId& out) const
 {
-  OpenFDMAssert(mInputPort.isConnected());
-  mOutput = mInputPort.getMatrixValue();
-  mOutput *= mGain;
+  if (in != getPortId(mInputPort.getPortIndex()))
+    return false;
+  if (out != getPortId(mOutputPort.getPortIndex()))
+    return false;
+  return true;
 }
 
 const real_type&
@@ -69,10 +68,4 @@
   mGain = gain;
 }
 
-const Matrix&
-Gain::getOutput(void) const
-{
-  return mOutput;
-}
-
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Gain.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Gain.h	2008-08-30 11:38:31 UTC (rev 423)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Gain.h	2008-08-30 12:17:08 UTC (rev 424)
@@ -6,11 +6,7 @@
 #define OpenFDM_Gain_H
 
 #include <string>
-#include <vector>
 
-#include "Assert.h"
-#include "Object.h"
-#include "Vector.h"
 #include "Model.h"
 
 namespace OpenFDM {
@@ -20,19 +16,20 @@
 public:
   Gain(const std::string& name);
   virtual ~Gain(void);
-  
-  virtual bool init(void);
-  virtual void output(const TaskInfo&);
 
+  virtual bool alloc(LeafContext& leafContext) const;
+  virtual void output(const DiscreteStateValueVector&,
+                      const ContinousStateValueVector&,
+                      PortValueList& portValues) const;
+  virtual bool dependsOn(const PortId& in, const PortId& out) const;
+
   const real_type& getGain(void) const;
   void setGain(const real_type& gain);
 
-  const Matrix& getOutput(void) const;
-
 private:
+  MatrixInputPort mInputPort;
+  MatrixOutputPort mOutputPort;
   real_type mGain;
-  Matrix mOutput;
-  MatrixPortHandle mInputPort;
 };
 
 } // namespace OpenFDM

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/LeafContext.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/LeafContext.h	2008-08-30 11:38:31 UTC (rev 423)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/LeafContext.h	2008-08-30 12:17:08 UTC (rev 424)
@@ -0,0 +1,36 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_LeafContext_H
+#define OpenFDM_LeafContext_H
+
+#include "ContinousStateValueVector.h"
+#include "DiscreteStateValueVector.h"
+#include "PortValueList.h"
+
+namespace OpenFDM {
+
+class LeafContext {
+public:
+  // PortValues
+  PortValueList mPortValueList;
+  // Hmm, port connect information?? How to store??
+  
+  // Continous States
+  ContinousStateValueVector mContinousState;
+  // Discrete States
+  DiscreteStateValueVector mDiscreteState;
+
+  // Task id's ???
+
+  // Output Watch, used to monitor outputs during simulation
+
+  // May be complete path in the system?
+
+  // functors to the operations to do??
+};
+
+} // namespace OpenFDM
+
+#endif

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-08-30 11:38:31 UTC (rev 423)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-08-30 12:17:08 UTC (rev 424)
@@ -31,6 +31,7 @@
   GroupOutput.h \
   ImplicitEuler.h \
   Inertia.h \
+  LeafContext.h \
   LeafNode.h \
   Limits.h \
   LinAlg/Algorithm.h \
@@ -206,58 +207,57 @@
   Wind.h
 
 OpenFDMModelsSOURCES = \
-  AeroForce.cpp \
-  AirSpring.cpp \
-  Atmosphere.cpp \
-  AtmosphereSTD1976.cpp \
-  Bias.cpp \
-  BinaryFunctionModel.cpp \
-  ConstModel.cpp \
-  Contact.cpp \
-  DeadBand.cpp \
-  DefaultGravity.cpp \
-  DefaultGround.cpp \
-  DefaultPlanet.cpp \
-  DiscBrake.cpp \
-  DiscreteIntegrator.cpp \
-  ExternalForceModel.cpp \
-  FixedRootJoint.cpp \
-  Force.cpp \
-  Gain.cpp \
-  Gravity.cpp \
-  Ground.cpp \
-  Input.cpp \
-  Integrator.cpp \
-  Interact.cpp \
-  Joint.cpp \
-  Launchbar.cpp \
-  LinearSpringDamper.cpp \
-  Mass.cpp \
-  MaxModel.cpp \
-  MinModel.cpp \
-  MobileRootJoint.cpp \
-  Output.cpp \
-  Product.cpp \
-  PrismaticJoint.cpp \
-  RevoluteActuator.cpp \
-  RevoluteJoint.cpp \
-  RigidBody.cpp \
-  RootFrame.cpp \
-  Saturation.cpp \
-  SimpleContact.cpp \
-  SimpleGear.cpp \
-  SimulationTime.cpp \
-  Summer.cpp \
-  Table.cpp \
-  Tailhook.cpp \
-  Tank.cpp \
-  TimeDerivative.cpp \
-  TransferFunction.cpp \
-  UnaryFunctionModel.cpp \
-  Vehicle.cpp \
-  WheelContact.cpp
+  Gain.cpp
 
-# nobase_OpenFDMinclude_HEADERS = $(OpenFDMCoreHEADERS) $(OpenFDMModelsHEADERS)
-nobase_OpenFDMinclude_HEADERS = $(OpenFDMCoreHEADERS)
-# libOpenFDM_la_SOURCES = $(OpenFDMCoreSOURCES) $(OpenFDMModelsSOURCES)
-libOpenFDM_la_SOURCES = $(OpenFDMCoreSOURCES)
+#   AeroForce.cpp \
+#   AirSpring.cpp \
+#   Atmosphere.cpp \
+#   AtmosphereSTD1976.cpp \
+#   Bias.cpp \
+#   BinaryFunctionModel.cpp \
+#   ConstModel.cpp \
+#   Contact.cpp \
+#   DeadBand.cpp \
+#   DefaultGravity.cpp \
+#   DefaultGround.cpp \
+#   DefaultPlanet.cpp \
+#   DiscBrake.cpp \
+#   DiscreteIntegrator.cpp \
+#   ExternalForceModel.cpp \
+#   FixedRootJoint.cpp \
+#   Force.cpp \
+#   Gravity.cpp \
+#   Ground.cpp \
+#   Input.cpp \
+#   Integrator.cpp \
+#   Interact.cpp \
+#   Joint.cpp \
+#   Launchbar.cpp \
+#   LinearSpringDamper.cpp \
+#   Mass.cpp \
+#   MaxModel.cpp \
+#   MinModel.cpp \
+#   MobileRootJoint.cpp \
+#   Output.cpp \
+#   Product.cpp \
+#   PrismaticJoint.cpp \
+#   RevoluteActuator.cpp \
+#   RevoluteJoint.cpp \
+#   RigidBody.cpp \
+#   RootFrame.cpp \
+#   Saturation.cpp \
+#   SimpleContact.cpp \
+#   SimpleGear.cpp \
+#   SimulationTime.cpp \
+#   Summer.cpp \
+#   Table.cpp \
+#   Tailhook.cpp \
+#   Tank.cpp \
+#   TimeDerivative.cpp \
+#   TransferFunction.cpp \
+#   UnaryFunctionModel.cpp \
+#   Vehicle.cpp \
+#   WheelContact.cpp
+
+nobase_OpenFDMinclude_HEADERS = $(OpenFDMCoreHEADERS) $(OpenFDMModelsHEADERS)
+libOpenFDM_la_SOURCES = $(OpenFDMCoreSOURCES) $(OpenFDMModelsSOURCES)



From frohlich at mail.berlios.de  Sat Aug 30 14:52:01 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 30 Aug 2008 14:52:01 +0200
Subject: [OpenFDM-svn] r425 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200808301252.m7UCq1D2010761@sheep.berlios.de>

Author: frohlich
Date: 2008-08-30 14:52:00 +0200 (Sat, 30 Aug 2008)
New Revision: 425

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Integrator.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Integrator.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
   branches/OpenFDM-StateSeparation/src/OpenFDM/TemplateStateInfo.h
Log:
Implement an Integrator.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Integrator.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Integrator.cpp	2008-08-30 12:17:08 UTC (rev 424)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Integrator.cpp	2008-08-30 12:52:00 UTC (rev 425)
@@ -5,6 +5,7 @@
 #include "Integrator.h"
 
 #include "Assert.h"
+#include "LeafContext.h"
 
 namespace OpenFDM {
 
@@ -12,16 +13,14 @@
   DEF_OPENFDM_PROPERTY(Matrix, InitialValue, Serialized)
   END_OPENFDM_OBJECT_DEF
 
-Integrator::Integrator(const std::string& name) :
-  Model(name)
+Integrator::Integrator(const std::string& name = std::string()) :
+  Model(name),
+  mInputPort(newMatrixInputPort("input")),
+  mOutputPort(newMatrixOutputPort("output")),
+  mInitialValuePort(newMatrixInputPort("initialValue"))
 {
-  addSampleTime(SampleTime::Continous);
-
-  setNumInputPorts(1);
-  setInputPortName(0, "derivatirve");
-
-  setNumOutputPorts(1);
-  setOutputPort(0, "output", this, &Integrator::getIntegralOutput);
+  mMatrixStateInfo = new MatrixStateInfo;
+  addContinousStateInfo(mMatrixStateInfo);
 }
 
 Integrator::~Integrator(void)
@@ -29,69 +28,64 @@
 }
 
 bool
-Integrator::init(void)
+Integrator::alloc(LeafContext& leafContext) const
 {
-  mDerivativeHandle = getInputPort(0)->toMatrixPortHandle();
-  if (!mDerivativeHandle.isConnected())
-    return false;
-
-  // The initial value defaults to zero
-  if (rows(mInitialValue) == 0 || cols(mInitialValue) == 0) {
-    mInitialValue.resize(mDerivativeHandle.getMatrixValue());
-    mInitialValue.clear();
-  }
-
-  setNumContinousStates(rows(mInitialValue)*cols(mInitialValue));
-
-  mIntegralState = mInitialValue;
-  mIntegralOutput = mIntegralState;
-  return Model::init();
+  Size sz = size(leafContext.mPortValueList[mInputPort]);
+  leafContext.mPortValueList.setPortSize(mOutputPort, sz);
+  leafContext.mContinousState.setValue(*mMatrixStateInfo, leafContext);
+  return true;
 }
 
 void
-Integrator::output(const TaskInfo&)
+Integrator::init(DiscreteStateValueVector& discreteState,
+                 ContinousStateValueVector& continousState) const
 {
-  mIntegralOutput = mIntegralState;
+  // Needs to be done here. Need port values???
+  // FIXME, can I ensure that at least the direct dependent ones are
+  // available and the other ones are inaccessible at compile time?
+//     if (portValues.isConnected(mInitialValuePort)) {
+//       // external initial condition
+//       continousState[*mMatrixStateInfo] = portValues[mInitialValuePort];
+//     } else {
+    // internal initial condition
+    continousState[*mMatrixStateInfo].clear(); // FIXME
+//     }
 }
 
 void
-Integrator::setState(const StateStream& state)
+Integrator::output(const DiscreteStateValueVector&,
+                   const ContinousStateValueVector& continousState,
+                   PortValueList& portValues) const
 {
-  state.readSubState(mIntegralState);
+  portValues[mOutputPort] = continousState[*mMatrixStateInfo];
 }
 
 void
-Integrator::getState(StateStream& state) const
+Integrator::derivative(const DiscreteStateValueVector&,
+                       const ContinousStateValueVector& state,
+                       const PortValueList& portValues,
+                       ContinousStateValueVector& deriv) const
 {
-  state.writeSubState(mIntegralState);
+  deriv[*mMatrixStateInfo] = portValues[mInputPort];
 }
 
-void
-Integrator::getStateDeriv(StateStream& stateDeriv)
+bool
+Integrator::dependsOn(const PortId&, const PortId&) const
 {
-  // Just return the derivative
-  OpenFDMAssert(mDerivativeHandle.isConnected());
-  const Matrix& input = mDerivativeHandle.getMatrixValue();
-  OpenFDMAssert(size(input) == size(mIntegralState));
-  stateDeriv.writeSubState(input);
+  // FIXME, make the initial value port depend here ...
+  return false;
 }
 
-const Matrix&
-Integrator::getInitialValue(void) const
-{
-  return mInitialValue;
-}
-
 void
-Integrator::setInitialValue(const Matrix& value)
+Integrator::setInitialValue(const Matrix& initialValue)
 {
-  mInitialValue = value;
+  mInitialValue = initialValue;
 }
 
 const Matrix&
-Integrator::getIntegralOutput(void) const
+Integrator::getInitialValue() const
 {
-  return mIntegralOutput;
+  return mInitialValue;
 }
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Integrator.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Integrator.h	2008-08-30 12:17:08 UTC (rev 424)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Integrator.h	2008-08-30 12:52:00 UTC (rev 425)
@@ -7,6 +7,7 @@
 
 #include "Types.h"
 #include "Model.h"
+#include "MatrixStateInfo.h"
 
 namespace OpenFDM {
 
@@ -16,27 +17,26 @@
   Integrator(const std::string& name);
   virtual ~Integrator(void);
 
-  virtual bool init(void);
-  virtual void output(const TaskInfo&);
+  virtual bool alloc(LeafContext& leafContext) const;
+  virtual void init(DiscreteStateValueVector& discreteState,
+                    ContinousStateValueVector& continousState) const;
 
-  virtual void setState(const StateStream& state);
-  virtual void getState(StateStream& state) const;
-  virtual void getStateDeriv(StateStream& stateDeriv);
+  virtual void output(const DiscreteStateValueVector&, const ContinousStateValueVector& continousState, PortValueList& portValues) const;
+  virtual void derivative(const DiscreteStateValueVector&, const ContinousStateValueVector& state, const PortValueList& portValues, ContinousStateValueVector& deriv) const;
 
-  const Matrix& getInitialValue(void) const;
-  void setInitialValue(const Matrix& value);
+  virtual bool dependsOn(const PortId&, const PortId&) const;
 
-  const Matrix& getIntegralOutput(void) const;
+  void setInitialValue(const Matrix& initialValue);
+  const Matrix& getInitialValue() const;
 
 private:
-  /// The handle to the input port
-  MatrixPortHandle mDerivativeHandle;
-  /// Holds the current output.
-  Matrix mIntegralOutput;
-  /// Holds the current integral state.
-  Matrix mIntegralState;
-  /// Holds the current integral initial state.
+  MatrixInputPort mInputPort;
+  MatrixOutputPort mOutputPort;
+  MatrixInputPort mInitialValuePort;
   Matrix mInitialValue;
+
+  // FIXME
+  SharedPtr<MatrixStateInfo> mMatrixStateInfo;
 };
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-08-30 12:17:08 UTC (rev 424)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-08-30 12:52:00 UTC (rev 425)
@@ -207,7 +207,8 @@
   Wind.h
 
 OpenFDMModelsSOURCES = \
-  Gain.cpp
+  Gain.cpp \
+  Integrator.cpp
 
 #   AeroForce.cpp \
 #   AirSpring.cpp \
@@ -229,7 +230,6 @@
 #   Gravity.cpp \
 #   Ground.cpp \
 #   Input.cpp \
-#   Integrator.cpp \
 #   Interact.cpp \
 #   Joint.cpp \
 #   Launchbar.cpp \

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/TemplateStateInfo.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/TemplateStateInfo.h	2008-08-30 12:17:08 UTC (rev 424)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/TemplateStateInfo.h	2008-08-30 12:52:00 UTC (rev 425)
@@ -5,6 +5,8 @@
 #ifndef OpenFDM_TemplateStateInfo_H
 #define OpenFDM_TemplateStateInfo_H
 
+#include "TemplateValueVector.h"
+
 namespace OpenFDM {
 
 template<typename T, typename I, typename V>



From frohlich at mail.berlios.de  Sun Aug 31 08:43:18 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 31 Aug 2008 08:43:18 +0200
Subject: [OpenFDM-svn] r426 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200808310643.m7V6hIu0005741@sheep.berlios.de>

Author: frohlich
Date: 2008-08-31 08:43:16 +0200 (Sun, 31 Aug 2008)
New Revision: 426

Added:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.h
Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
Log:
Implement a typical discrete Delay model.


Added: branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.cpp	2008-08-30 12:52:00 UTC (rev 425)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.cpp	2008-08-31 06:43:16 UTC (rev 426)
@@ -0,0 +1,103 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
+ *
+ */
+
+#include "Delay.h"
+
+#include <string>
+#include <vector>
+
+#include "Assert.h"
+#include "Object.h"
+#include "LeafContext.h"
+#include "Model.h"
+#include "Vector.h"
+
+namespace OpenFDM {
+
+BEGIN_OPENFDM_OBJECT_DEF(Delay, Model)
+  DEF_OPENFDM_PROPERTY(Unsigned, Delay, Serialized)
+  END_OPENFDM_OBJECT_DEF
+
+Delay::Delay(const std::string& name) :
+  Model(name),
+  mInputPort(newMatrixInputPort("input")),
+  mOutputPort(newMatrixOutputPort("output")),
+  mDelay(0)
+{
+  mMatrixStateInfo = new MatrixListStateInfo;
+  addDiscreteStateInfo(mMatrixStateInfo);
+}
+
+Delay::~Delay()
+{
+}
+
+bool
+Delay::alloc(LeafContext& leafContext) const
+{
+  Size sz = size(leafContext.mPortValueList[mInputPort]);
+  leafContext.mPortValueList.setPortSize(mOutputPort, sz);
+  leafContext.mDiscreteState.setValue(*mMatrixStateInfo, leafContext);
+  return true;
+}
+
+void
+Delay::init(DiscreteStateValueVector& discreteState,
+            ContinousStateValueVector&) const
+{
+  discreteState[*mMatrixStateInfo].clear();
+  for (unsigned i = 0; i <= mDelay; ++i)
+    discreteState[*mMatrixStateInfo].push_back(mInitialValue);
+}
+
+void
+Delay::output(const DiscreteStateValueVector& discreteState,
+              const ContinousStateValueVector&,
+              PortValueList& portValues) const
+{
+  portValues[mOutputPort] = discreteState[*mMatrixStateInfo].front();
+}
+
+void
+Delay::update(DiscreteStateValueVector& discreteState,
+              ContinousStateValueVector&,
+              const PortValueList& portValues) const
+{
+  discreteState[*mMatrixStateInfo].rotate(portValues[mInputPort]);
+}
+
+bool
+Delay::dependsOn(const PortId& in, const PortId& out) const
+{
+  if (mDelay != 0)
+    return false;
+  return in == getPortId(mInputPort.getPortIndex())
+    && out == getPortId(mOutputPort.getPortIndex());
+}
+
+unsigned
+Delay::getDelay(void) const
+{
+  return mDelay;
+}
+
+void
+Delay::setDelay(unsigned delay)
+{
+  mDelay = delay;
+}
+
+const Matrix&
+Delay::getInitialValue() const
+{
+  return mInitialValue;
+}
+
+void
+Delay::setInitialValue(const Matrix& initialValue)
+{
+  mInitialValue = initialValue;
+}
+
+} // namespace OpenFDM

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.h	2008-08-30 12:52:00 UTC (rev 425)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.h	2008-08-31 06:43:16 UTC (rev 426)
@@ -0,0 +1,71 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_Delay_H
+#define OpenFDM_Delay_H
+
+#include <string>
+
+#include "Model.h"
+#include "TemplateDiscreteStateInfo.h"
+
+namespace OpenFDM {
+
+class Delay : public Model {
+  OPENFDM_OBJECT(Delay, Model);
+public:
+  Delay(const std::string& name);
+  virtual ~Delay();
+
+  virtual bool alloc(LeafContext& leafContext) const;
+  virtual void init(DiscreteStateValueVector& discreteState,
+                    ContinousStateValueVector&) const;
+  virtual void output(const DiscreteStateValueVector& discreteState,
+                      const ContinousStateValueVector&,
+                      PortValueList& portValues) const;
+  virtual void update(DiscreteStateValueVector& discreteState,
+                      ContinousStateValueVector&,
+                      const PortValueList& portValues) const;
+
+  virtual bool dependsOn(const PortId& in, const PortId& out) const;
+
+  /// The delay number of timeslices
+  unsigned getDelay(void) const;
+  void setDelay(unsigned delay);
+
+  /// The initial output values on the output until input values are available.
+  const Matrix& getInitialValue() const;
+  void setInitialValue(const Matrix& initialValue);
+
+private:
+
+  class MatrixList : public std::list<Matrix> {
+  public:
+    MatrixList() {}
+    MatrixList(size_type n, const Matrix& matrix)
+    {
+      while (0 < n--)
+        push_back(matrix);
+    }
+    void rotate(const Matrix& matrix)
+    {
+      // splice is O(1)
+      splice(end(), *this, begin());
+      // append new value
+      back() = matrix;
+    }
+  };
+
+  typedef  TemplateDiscreteStateInfo<MatrixList> MatrixListStateInfo;
+
+  MatrixInputPort mInputPort;
+  MatrixOutputPort mOutputPort;
+  unsigned mDelay;
+  Matrix mInitialValue;
+  SharedPtr<MatrixListStateInfo> mMatrixStateInfo;
+};
+
+} // namespace OpenFDM
+
+#endif

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-08-30 12:52:00 UTC (rev 425)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-08-31 06:43:16 UTC (rev 426)
@@ -159,6 +159,7 @@
   DefaultGravity.h \
   DefaultGround.h \
   DefaultPlanet.h \
+  Delay.h \
   DiscBrake.h \
   DiscreteIntegrator.h \
   ExternalForceModel.h \
@@ -207,6 +208,7 @@
   Wind.h
 
 OpenFDMModelsSOURCES = \
+  Delay.cpp \
   Gain.cpp \
   Integrator.cpp
 



From frohlich at mail.berlios.de  Sun Aug 31 10:38:16 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 31 Aug 2008 10:38:16 +0200
Subject: [OpenFDM-svn] r427 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200808310838.m7V8cGX5012398@sheep.berlios.de>

Author: frohlich
Date: 2008-08-31 10:38:15 +0200 (Sun, 31 Aug 2008)
New Revision: 427

Added:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Group.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Group.h
Removed:
   branches/OpenFDM-StateSeparation/src/OpenFDM/GroupInput.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/GroupInput.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/GroupOutput.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/GroupOutput.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/ModelGroup.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/ModelGroup.h
Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
   branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.h
Log:
Hackish Group implementation - now in svn.


Added: branches/OpenFDM-StateSeparation/src/OpenFDM/Group.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Group.cpp	2008-08-31 06:43:16 UTC (rev 426)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Group.cpp	2008-08-31 08:38:15 UTC (rev 427)
@@ -0,0 +1,23 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
+ *
+ */
+
+#include "Group.h"
+#include "NodeVisitor.h"
+
+namespace OpenFDM {
+
+BEGIN_OPENFDM_OBJECT_DEF(Group, Node)
+  END_OPENFDM_OBJECT_DEF
+
+GroupAcceptorNode::GroupAcceptorNode() :
+  _groupInternalPort(new ProxyProviderPortInfo(this, "output"))
+{
+}
+
+GroupProviderNode::GroupProviderNode() :
+  _groupInternalPort(new ProxyAcceptorPortInfo(this, "input"))
+{
+}
+
+} // namespace OpenFDM

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/Group.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Group.h	2008-08-31 06:43:16 UTC (rev 426)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Group.h	2008-08-31 08:38:15 UTC (rev 427)
@@ -0,0 +1,449 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_Group_H
+#define OpenFDM_Group_H
+
+#include <string>
+#include <vector>
+#include <sstream>
+#include "AcceptorPortInfo.h"
+#include "Node.h"
+#include "NodeVisitor.h"
+#include "Object.h"
+#include "PortId.h"
+#include "PortInfo.h"
+#include "ProviderPortInfo.h"
+#include "SharedPtr.h"
+
+namespace OpenFDM {
+
+class ProxyAcceptorPortInfo;
+class ProxyProviderPortInfo;
+
+class GroupAcceptorNode : public Node {
+public:
+  GroupAcceptorNode();
+  virtual void accept(NodeVisitor& visitor)
+  { visitor.apply(*this); }
+// private:
+  SharedPtr<ProxyProviderPortInfo> _groupInternalPort;
+//   WeakPtr<ProxyAcceptorPortInfo> _groupExternalPort;
+};
+
+class GroupProviderNode : public Node {
+public:
+  GroupProviderNode();
+  virtual void accept(NodeVisitor& visitor)
+  { visitor.apply(*this); }
+// private:
+  SharedPtr<ProxyAcceptorPortInfo> _groupInternalPort;
+//   WeakPtr<ProxyProviderPortInfo> _groupExternalPort;
+//   MatrixInputPort mInputPort;
+};
+
+class ProxyAcceptorPortInfo : public AcceptorPortInfo {
+public:
+  ProxyAcceptorPortInfo(Node* node, const std::string& name = std::string()) :
+    AcceptorPortInfo(node, name) {}
+  SharedPtr<GroupAcceptorNode> mGroupPort;
+  virtual ProxyAcceptorPortInfo* toProxyAcceptorPortInfo()
+  { return this; }
+  virtual const ProxyAcceptorPortInfo* toProxyAcceptorPortInfo() const
+  { return this; }
+};
+
+class ProxyProviderPortInfo : public ProviderPortInfo {
+public:
+  ProxyProviderPortInfo(Node* node, const std::string& name = std::string()) :
+    ProviderPortInfo(node, name) {}
+  virtual PortValue* newValueImplementation() const
+  { return 0; } //FIXME
+  virtual ProxyProviderPortInfo* toProxyProviderPortInfo()
+  { return this; }
+  virtual const ProxyProviderPortInfo* toProxyProviderPortInfo() const
+  { return this; }
+  SharedPtr<GroupProviderNode> mGroupPort;
+};
+
+class Group : public Node {
+  OPENFDM_OBJECT(Group, Node);
+public:
+  Group(const std::string& name) : Node(name) {}
+  virtual ~Group() {}
+
+  virtual void accept(NodeVisitor& visitor)
+  { visitor.apply(*this); }
+
+  class NodeId;
+
+  NodeId addChild(const SharedPtr<Node>& node)
+  {
+    std::string identifier = getUniqueIdentifier(node->getName());
+    _childList.push_back(new Child(this, node, identifier));
+    return NodeId(_childList.back());
+  }
+  unsigned getNumChildren() const
+  { return _childList.size(); }
+  NodeId getNodeId(unsigned i) const
+  {
+    if (_childList.size() <= i)
+      return NodeId();
+    return NodeId(_childList[i]);
+  }
+  unsigned getChildNumber(const NodeId& nodeId) const
+  {
+    SharedPtr<Child> child = nodeId._child.lock();
+    if (!child)
+      return ~0u;
+    if (child->group.lock() != this)
+      return ~0u;
+    ChildList::const_iterator i;
+    i = std::find(_childList.begin(), _childList.end(), child);
+    if (i == _childList.end())
+      return ~0u;
+    return std::distance(_childList.begin(), i);
+  }
+
+  SharedPtr<Node> getChild(unsigned i)
+  {
+    if (_childList.size() <= i)
+      return 0;
+    return _childList[i]->node;
+  }
+  SharedPtr<const Node> getChild(unsigned i) const
+  {
+    if (_childList.size() <= i)
+      return 0;
+    return _childList[i]->node;
+  }
+  SharedPtr<Node> getChild(const NodeId& nodeId)
+  {
+    SharedPtr<Child> child = nodeId._child.lock();
+    if (!child)
+      return 0;
+    /// Check if it belongs to this current group
+    if (child->group.lock() != this)
+      return 0;
+    return child->node;
+  }
+  SharedPtr<const Node> getChild(const NodeId& nodeId) const
+  {
+    SharedPtr<Child> child = nodeId._child.lock();
+    if (!child)
+      return 0;
+    /// Check if it belongs to this current group
+    SharedPtr<Group> group = child->group.lock();
+    if (group != this)
+      return 0;
+    return child->node;
+  }
+
+  NodeId getGroupAcceptorNode(const PortId& portId) const
+  {
+    SharedPtr<const PortInfo> port = getPort(portId);
+    if (!port)
+      return NodeId();
+    const ProxyAcceptorPortInfo* proxyAcceptorPort = port->toProxyAcceptorPortInfo();
+    if (!proxyAcceptorPort)
+      return NodeId();
+
+    SharedPtr<GroupAcceptorNode> groupPort = proxyAcceptorPort->mGroupPort;
+    ChildList::const_iterator i;
+    for (i = _childList.begin(); i != _childList.end(); ++i) {
+      if ((*i)->node == groupPort)
+        return NodeId(*i);
+    }
+    return NodeId();
+  }
+  NodeId getGroupProviderNode(const PortId& portId) const
+  {
+    SharedPtr<const PortInfo> port = getPort(portId);
+    if (!port)
+      return NodeId();
+    const ProxyProviderPortInfo* proxyProviderPort = port->toProxyProviderPortInfo();
+    if (!proxyProviderPort)
+      return NodeId();
+
+    SharedPtr<GroupProviderNode> groupPort = proxyProviderPort->mGroupPort;
+    ChildList::const_iterator i;
+    for (i = _childList.begin(); i != _childList.end(); ++i) {
+      if ((*i)->node == groupPort)
+        return NodeId(*i);
+    }
+    return NodeId();
+  }
+  NodeId getGroupPortNode(const PortId& portId) const
+  {
+    NodeId nodeId = getGroupProviderNode(portId);
+    if (getChild(nodeId)) // FIXME!!
+      return nodeId;
+    return getGroupAcceptorNode(portId);
+  }
+
+  PortId getGroupPort(const NodeId& nodeId) const
+  {
+    // FIXME horrible algorithm
+    unsigned numPorts = getNumPorts();
+    for (unsigned i = 0; i < numPorts; ++i) {
+      NodeId thisId = getGroupPortNode(getPortId(i));
+      if (getChildNumber(nodeId) == getChildNumber(thisId))
+        return getPortId(i);
+    }
+    return PortId();
+  }
+
+  // add a new group port to the group
+  NodeId addAcceptorPort()
+  {
+    GroupAcceptorNode *groupAcceptorNode = new GroupAcceptorNode;
+    NodeId nodeId = addChild(groupAcceptorNode);
+    ProxyAcceptorPortInfo* proxyPort = new ProxyAcceptorPortInfo(this, "ProxyPort");
+    proxyPort->mGroupPort = groupAcceptorNode;
+    return nodeId;
+  }
+  NodeId addProviderPort()
+  {
+    GroupProviderNode *groupProviderNode = new GroupProviderNode;
+    NodeId nodeId = addChild(groupProviderNode);
+    ProxyProviderPortInfo* proxyPort = new ProxyProviderPortInfo(this, "ProxyPort");
+    proxyPort->mGroupPort = groupProviderNode;
+    return nodeId;
+  }
+
+  bool connect(const NodeId& nodeId0, const std::string& portName0,
+               const NodeId& nodeId1, const std::string& portName1)
+  { return connect(nodeId0, nodeId0.getPortId(portName0),
+                   nodeId1, nodeId1.getPortId(portName1)); }
+  bool connect(const NodeId& nodeId0, unsigned portNum0,
+               const NodeId& nodeId1, unsigned portNum1)
+  { return connect(nodeId0, nodeId0.getPortId(portNum0),
+                   nodeId1, nodeId1.getPortId(portNum1)); }
+
+  bool connect(const NodeId& nodeId0, const PortId& portId0,
+               const NodeId& nodeId1, const PortId& portId1)
+  {
+    // Make sure the models belong to this group
+    if (!getChild(nodeId0))
+      return false;
+    if (!getChild(nodeId1))
+      return false;
+
+    SharedPtr<const PortInfo> port0 = nodeId0.getPortPtr(portId0);
+    if (!port0)
+      return false;
+    SharedPtr<const PortInfo> port1 = nodeId1.getPortPtr(portId1);
+    if (!port1)
+      return false;
+
+    if (port0->toProviderPortInfo() && port1->toAcceptorPortInfo()) {
+      SharedPtr<Connect> connect = new Connect;
+      if (!connect->setProvider(nodeId0, portId0))
+        return false;
+      if (!connect->addAcceptor(nodeId1, portId1))
+        return false;
+      _connectList.push_back(connect);
+      return true;
+    } else if (port1->toProviderPortInfo() && port0->toAcceptorPortInfo()) {
+      SharedPtr<Connect> connect = new Connect;
+      if (!connect->setProvider(nodeId1, portId1))
+        return false;
+      if (!connect->addAcceptor(nodeId0, portId0))
+        return false;
+      _connectList.push_back(connect);
+      return true;
+    } else {
+      return false;
+    }
+  }
+
+
+  unsigned getNumConnects() const
+  { return _connectList.size(); }
+  
+  NodeId getConnectAcceptorNodeId(unsigned i) const
+  {
+    if (getNumConnects() <= i)
+      return NodeId();
+    return _connectList[i]->_acceptorNodeId;
+  }
+  NodeId getConnectProviderNodeId(unsigned i) const
+  {
+    if (getNumConnects() <= i)
+      return NodeId();
+    return _connectList[i]->_providerNodeId;
+  }
+
+  SharedPtr<const AcceptorPortInfo>
+  getConnectAcceptorPortInfo(unsigned i) const
+  {
+    if (getNumConnects() <= i)
+      return 0;
+    return _connectList[i]->_acceptorPort.lock();
+  }
+  SharedPtr<const ProviderPortInfo>
+  getConnectProviderPortInfo(unsigned i) const
+  {
+    if (getNumConnects() <= i)
+      return 0;
+    return _connectList[i]->_providerPort.lock();
+  }
+
+  PortId getConnectAcceptorPortId(unsigned i) const
+  { return PortId(SharedPtr<const PortInfo>(getConnectAcceptorPortInfo(i))); }
+  PortId getConnectProviderPortId(unsigned i) const
+  { return PortId(SharedPtr<const PortInfo>(getConnectProviderPortInfo(i))); }
+
+private:
+  class Child;
+public:
+  class NodeId {
+    // FIXME a node ID has an associated name and that is unique. That should
+    // be the blocks name where it can be referenced. May be the NodeId should
+    // just contain that string??
+    // A serialized group can refere these names.
+    // May be the same should happen with portid's???
+    //
+    // Remove the name from the Object.
+    // Store Connects as seperate objects
+  public:
+    NodeId() {}
+    PortId getPortId(unsigned i) const
+    {
+      SharedPtr<Child> child = _child.lock();
+      if (!child)
+        return PortId();
+      SharedPtr<Node> node = child->node;
+      if (!node)
+        return PortId();
+      return node->getPortId(i);
+    }
+    PortId getPortId(const std::string& name) const
+    {
+      SharedPtr<Child> child = _child.lock();
+      if (!child)
+        return PortId();
+      SharedPtr<Node> node = child->node;
+      if (!node)
+        return PortId();
+      return node->getPortId(name);
+    }
+
+    const PortInfo* getPortPtr(const PortId& portId) const // FIXME??
+    {
+      SharedPtr<Child> child = _child.lock();
+      if (!child)
+        return 0;
+      SharedPtr<Node> node = child->node;
+      if (!node)
+        return 0;
+      return node->getPort(portId);
+    }
+
+    std::string getId() const
+    {
+      SharedPtr<Child> child = _child.lock();
+      if (!child)
+        return std::string();
+      return _child.lock()->identifier;
+    }
+
+    // FIXME, do I need ???
+    bool operator<(const NodeId& nodeId) const
+    { return _child < nodeId._child; }
+
+  private:
+    friend class Group;
+    NodeId(const SharedPtr<Child>& child) : _child(child) {}
+    WeakPtr<Child> _child;
+  };
+
+private:
+
+  struct Child : public WeakReferenced {
+    Child(Group* _group, Node* _node, std::string& id) :
+      group(_group), node(_node), identifier(id)
+    { }
+    WeakPtr<Group> group;
+    SharedPtr<Node> node;
+    // what happens if the nodes name changes ?? FIXME
+    std::string identifier;
+  };
+
+  std::string getUniqueIdentifier(const std::string& name) const
+  {
+    if (isUniqueIdentifier(name))
+      return name;
+    unsigned counter = 0;
+    std::string identifier;
+    do {
+      std::stringstream ss;
+      ss << name << '(' << ++counter << ')';
+      identifier = ss.str();
+    } while (!isUniqueIdentifier(identifier));
+    OpenFDMAssert(!identifier.empty());
+    return identifier;
+  }
+
+  // Tells true if the identifier is not yet used
+  bool isUniqueIdentifier(const std::string& identifier) const
+  {
+    for (ChildList::const_iterator i = _childList.begin();
+         i != _childList.end(); ++i) {
+      if ((*i)->identifier == identifier)
+        return false;
+    }
+    return true;
+  }
+
+  struct Connect : public WeakReferenced {
+    bool setProvider(const NodeId& node, const PortId& portId)
+    {
+      SharedPtr<const PortInfo> port = node.getPortPtr(portId);
+      if (!port)
+        return false;
+      const ProviderPortInfo* providerPort = port->toProviderPortInfo();
+      if (!providerPort)
+        return false;
+      _providerNodeId = node;
+      _providerPortId = portId;
+      _providerPort = providerPort;
+      return true;
+    }
+    bool addAcceptor(const NodeId& node, const PortId& portId)
+    {
+      SharedPtr<const PortInfo> port = node.getPortPtr(portId);
+      if (!port)
+        return false;
+      const AcceptorPortInfo* acceptorPort = port->toAcceptorPortInfo();
+      if (!acceptorPort)
+        return false;
+      _acceptorNodeId = node;
+      _acceptorPortId = portId;
+      _acceptorPort = acceptorPort;
+      return true;
+    }
+
+    NodeId _providerNodeId;
+    PortId _providerPortId;
+    WeakPtr<const ProviderPortInfo> _providerPort;
+
+    NodeId _acceptorNodeId;
+    PortId _acceptorPortId;
+    WeakPtr<const AcceptorPortInfo> _acceptorPort;
+
+    // Where the line in the gui will be ...??
+    // std::list<Vector2> _positions;
+  };
+
+  typedef std::vector<SharedPtr<Connect> > ConnectList;
+  ConnectList _connectList;
+
+  typedef std::vector<SharedPtr<Child> > ChildList;
+  ChildList _childList;
+};
+
+} // namespace OpenFDM
+
+#endif

Deleted: branches/OpenFDM-StateSeparation/src/OpenFDM/GroupInput.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/GroupInput.cpp	2008-08-31 06:43:16 UTC (rev 426)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/GroupInput.cpp	2008-08-31 08:38:15 UTC (rev 427)
@@ -1,50 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
- *
- */
-
-#include "GroupInput.h"
-
-namespace OpenFDM {
-
-BEGIN_OPENFDM_OBJECT_DEF(GroupInput, Model)
-  END_OPENFDM_OBJECT_DEF
-
-GroupInput::GroupInput(const std::string& name) :
-  Model(name)
-{
-  setNumOutputPorts(1);
-  getOutputPort(0)->setName("output");
-}
-
-GroupInput::~GroupInput()
-{
-}
-
-unsigned
-GroupInput::addParent(ModelGroup* group)
-{
-  unsigned parentIndex = Model::addParent(group);
-  if (parentIndex == ~0u)
-    return parentIndex;
-    
-  mPortProxy = new NumericPortProxy(group, getOutputPort(0));
-  mPortProxy->setName(getName());
-  group->addInputPort(mPortProxy);
-
-  return parentIndex;
-}
-
-void
-GroupInput::removeParent(unsigned idx)
-{
-  SharedPtr<ModelGroup> oldParent = getParent(idx).lock();
-  if (oldParent) {
-    // detach from a ModelGroup
-    oldParent->removeInputPort(mPortProxy);
-    mPortProxy = 0;
-  }
-  
-  Model::removeParent(idx);
-}
-
-} // namespace OpenFDM

Deleted: branches/OpenFDM-StateSeparation/src/OpenFDM/GroupInput.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/GroupInput.h	2008-08-31 06:43:16 UTC (rev 426)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/GroupInput.h	2008-08-31 08:38:15 UTC (rev 427)
@@ -1,32 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
- *
- */
-
-#ifndef OpenFDM_GroupInput_H
-#define OpenFDM_GroupInput_H
-
-#include "Model.h"
-#include "ModelGroup.h"
-#include "NumericPortProxy.h"
-
-namespace OpenFDM {
-
-class GroupInput : public Model {
-  OPENFDM_OBJECT(GroupInput, Model);
-public:
-  GroupInput(const std::string& name);
-  virtual ~GroupInput();
-  
-  virtual unsigned addParent(ModelGroup* model);
-  virtual void removeParent(unsigned idx);
-
-  NumericPortAcceptor* getGroupInput()
-  { return mPortProxy; }
-
-private:
-  SharedPtr<NumericPortProxy> mPortProxy;
-};
-
-} // namespace OpenFDM
-
-#endif

Deleted: branches/OpenFDM-StateSeparation/src/OpenFDM/GroupOutput.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/GroupOutput.cpp	2008-08-31 06:43:16 UTC (rev 426)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/GroupOutput.cpp	2008-08-31 08:38:15 UTC (rev 427)
@@ -1,51 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
- *
- */
-
-#include "GroupOutput.h"
-
-namespace OpenFDM {
-
-BEGIN_OPENFDM_OBJECT_DEF(GroupOutput, Model)
-  END_OPENFDM_OBJECT_DEF
-
-GroupOutput::GroupOutput(const std::string& name) :
-  Model(name)
-{
-  mPortProxy = new NumericPortProxy(this, 0);
-  mPortProxy->setName("input");
-  addInputPort(mPortProxy);
-}
-
-GroupOutput::~GroupOutput()
-{
-}
-
-unsigned
-GroupOutput::addParent(ModelGroup* group)
-{
-  unsigned parentIndex = Model::addParent(group);
-  if (parentIndex == ~0u)
-    return parentIndex;
-
-  // attach to a ModelGroup
-  mPortProxy->setPortProvider(new NumericPortProvider(group));
-  mPortProxy->getPortProvider()->setName(getName());
-  group->addOutputPort(mPortProxy->getPortProvider());
-
-  return parentIndex;
-}
-
-void
-GroupOutput::removeParent(unsigned idx)
-{
-  SharedPtr<ModelGroup> oldParent = getParent(idx).lock();
-  if (oldParent) {
-    // detach from a ModelGroup
-    oldParent->removeOutputPort(mPortProxy->getPortProvider());
-  }
-
-  Model::removeParent(idx);
-}
-
-} // namespace OpenFDM

Deleted: branches/OpenFDM-StateSeparation/src/OpenFDM/GroupOutput.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/GroupOutput.h	2008-08-31 06:43:16 UTC (rev 426)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/GroupOutput.h	2008-08-31 08:38:15 UTC (rev 427)
@@ -1,32 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
- *
- */
-
-#ifndef OpenFDM_GroupOutput_H
-#define OpenFDM_GroupOutput_H
-
-#include "Model.h"
-#include "ModelGroup.h"
-#include "NumericPortProxy.h"
-
-namespace OpenFDM {
-
-class GroupOutput : public Model {
-  OPENFDM_OBJECT(GroupOutput, Model);
-public:
-  GroupOutput(const std::string& name);
-  virtual ~GroupOutput();
-
-  virtual unsigned addParent(ModelGroup* model);
-  virtual void removeParent(unsigned idx);
-
-  PortProvider* getGroupOutput()
-  { return mPortProxy->getPortProvider(); }
-
-private:
-  SharedPtr<NumericPortProxy> mPortProxy;
-};
-
-} // namespace OpenFDM
-
-#endif

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-08-31 06:43:16 UTC (rev 426)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-08-31 08:38:15 UTC (rev 427)
@@ -27,8 +27,7 @@
   Frame.h \
   FrameVisitor.h \
   Function.h \
-  GroupInput.h \
-  GroupOutput.h \
+  Group.h \
   ImplicitEuler.h \
   Inertia.h \
   LeafContext.h \
@@ -51,7 +50,6 @@
   MatrixStateInfo.h \
   MidpointRule.h \
   Model.h \
-  ModelGroup.h \
   Mutex.h \
   MPFRFloat.h \
   Newton.h \
@@ -110,6 +108,7 @@
   Atomic.cpp \
   ContinousStateValue.cpp \
   Frame.cpp \
+  Group.cpp \
   LeafNode.cpp \
   Logger.cpp \
   MatrixStateValue.cpp \
@@ -133,12 +132,9 @@
 #   ExplicitAdams.cpp \
 #   ExplicitEuler.cpp \
 #   Function.cpp \
-#   GroupInput.cpp \
-#   GroupOutput.cpp \
 #   ImplicitEuler.cpp \
 #   Newton.cpp \
 #   MidpointRule.cpp \
-#   ModelGroup.cpp \
 #   ReaderWriter.cpp \
 #   ODESolver.cpp \
 #   System.cpp \

Deleted: branches/OpenFDM-StateSeparation/src/OpenFDM/ModelGroup.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ModelGroup.cpp	2008-08-31 06:43:16 UTC (rev 426)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ModelGroup.cpp	2008-08-31 08:38:15 UTC (rev 427)
@@ -1,249 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
- *
- */
-
-#include "ModelGroup.h"
-
-#include "Object.h"
-#include "Model.h"
-#include "Vector.h"
-#include "LogStream.h"
-#include "ModelVisitor.h"
-
-namespace OpenFDM {
-
-BEGIN_OPENFDM_OBJECT_DEF(ModelGroup, Node)
-  END_OPENFDM_OBJECT_DEF
-
-ModelGroup::ModelGroup(const std::string& name) :
-  Node(name)
-{
-}
-
-ModelGroup::~ModelGroup(void)
-{
-  // Remove all references to this group.
-  while (!mModels.empty())
-    removeModel(mModels.front());
-}
-
-void
-ModelGroup::accept(ModelVisitor& visitor)
-{
-  visitor.apply(*this);
-}
-
-const ModelGroup*
-ModelGroup::toModelGroup(void) const
-{
-  return this;
-}
-
-ModelGroup*
-ModelGroup::toModelGroup(void)
-{
-  return this;
-}
-
-const Node*
-ModelGroup::getModel(unsigned idx) const
-{
-  if (idx < mModels.size())
-    return mModels[idx];
-  else
-    return 0;
-}
-
-Node*
-ModelGroup::getModel(unsigned idx)
-{
-  if (idx < mModels.size())
-    return mModels[idx];
-  else
-    return 0;
-}
-
-const Node*
-ModelGroup::getModel(const std::string& name) const
-{
-  return getModel(getModelIndex(name));
-}
-
-Node*
-ModelGroup::getModel(const std::string& name)
-{
-  return getModel(getModelIndex(name));
-}
-
-unsigned
-ModelGroup::getModelIndex(const std::string& name) const
-{
-  unsigned idx = 0u;
-  ModelList::const_iterator it = mModels.begin();
-  while (it != mModels.end()) {
-    if ((*it)->getName() == name)
-      return idx;
-    ++it;
-    ++idx;
-  }
-  return idx;
-}
-
-unsigned
-ModelGroup::getModelIndex(const Node* const model) const
-{
-  unsigned idx = 0u;
-  ModelList::const_iterator it = mModels.begin();
-  while (it != mModels.end()) {
-    if ((*it) == model)
-      return idx;
-    ++it;
-    ++idx;
-  }
-  return idx;
-}
-
-unsigned
-ModelGroup::addModel(Node* model, bool allowRename)
-{
-  // cannot add no model ...
-  if (!model) {
-    Log(Model, Warning)
-      << "Trying to add zero OpenFDM::Model pointer "
-      "to OpenFDM::ModelGroup \"" << getName() << "\"" << endl;
-    return ~0u;
-  }
-
-  // cannot add a model to two groups. FIXME, will not be true in the future
-  if (0 < model->getNumParents()) {
-    Log(Model, Warning)
-      << "While adding the OpenFDM::Model \"" << model->getName()
-      << "\" to OpenFDM::ModelGroup \"" << getName()
-      << "\": Model is already attached!" << endl;
-    return ~0u;
-  }
-
-  // Check if we already have a model with the same name
-  /// FIXME: we need to make sure that duplicate names cannot occure
-  /// by attaching and than setting the duplicate name!
-  for (unsigned i = 0; i < mModels.size(); ++i) {
-    if (model->getName() == mModels[i]->getName()) {
-      if (allowRename) {
-        model->setName(model->getName() + "r");
-        return addModel(model, allowRename);
-      } else {
-        Log(Model, Warning)
-          << "While adding the OpenFDM::Model \"" << model->getName()
-          << "\" to OpenFDM::ModelGroup \"" << getName()
-          << "\": Model with the same name is already attached!" << endl;
-        return ~0u;
-      }
-    }
-  }
-
-  // Update the number of states.
-  model->addParent(this);
-
-  // add to the model list.
-  mModels.push_back(model);
-
-  return mModels.size()-1;
-}
-
-void
-ModelGroup::removeModel(Node* model)
-{
-  // cannot remove no model ...
-  if (!model) {
-    Log(Model, Warning)
-      << "Trying to remove zero OpenFDM::Model pointer "
-      "from OpenFDM::ModelGroup \"" << getName() << "\"" << endl;
-    return;
-  }
-
-  for (;;) {
-    ModelList::iterator it = mModels.begin();
-    while (it != mModels.end()) {
-      if ((*it) == model)
-        break;
-      ++it;
-    }
-    // Termination condition ...
-    if (it == mModels.end())
-      return;
-
-    // cannot remove if we are not its parent.
-    unsigned parentIdx = 0;
-    for (; parentIdx < model->getNumParents(); ++parentIdx) {
-      SharedPtr<Node> parentNode = model->getParent(parentIdx).lock();
-      if (parentNode == this)
-        break;
-    }
-    OpenFDMAssert(parentIdx < model->getNumParents());
-
-    // remove the backreference to this group
-    // this also updates the number of states
-    model->removeParent(parentIdx);
-  
-    // remove from the model list.
-    // note that erasing might delete the model object, thus delete it past
-    // correction of the number of states.
-    mModels.erase(it);
-  }
-}
-
-void
-ModelGroup::addConnection(Connection* connection)
-{
-  ConnectionList::iterator i;
-  i = std::find(mConnections.begin(), mConnections.end(), connection);
-  if (i != mConnections.end())
-    return;
-  mConnections.push_back(connection);
-}
-
-void
-ModelGroup::removeConnection(Connection* connection)
-{
-  ConnectionList::iterator i;
-  i = std::find(mConnections.begin(), mConnections.end(), connection);
-  if (i == mConnections.end())
-    return;
-  mConnections.erase(i);
-}
-
-unsigned
-ModelGroup::getConnectionIndex(const Connection* const connection) const
-{
-  for (unsigned i = 0; i < mConnections.size(); ++i) {
-    if (mConnections[i] == connection)
-      return i;
-  }
-  return ~0u;
-}
-
-Connection*
-ModelGroup::getConnection(unsigned i)
-{
-  if (mConnections.size() <= i)
-    return 0;
-  return mConnections[i];
-}
-
-const Connection*
-ModelGroup::getConnection(unsigned i) const
-{
-  if (mConnections.size() <= i)
-    return 0;
-  return mConnections[i];
-}
-
-Model::GroupPath
-ModelGroup::getGroupPath()
-{
-  GroupPath path = getPath();
-  path.push_back(this);
-  return path;
-}
-
-} // namespace OpenFDM

Deleted: branches/OpenFDM-StateSeparation/src/OpenFDM/ModelGroup.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ModelGroup.h	2008-08-31 06:43:16 UTC (rev 426)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ModelGroup.h	2008-08-31 08:38:15 UTC (rev 427)
@@ -1,76 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
- *
- */
-
-#ifndef OpenFDM_ModelGroup_H
-#define OpenFDM_ModelGroup_H
-
-#include <vector>
-
-#include "Object.h"
-#include "Model.h"
-#include "NumericPortProxy.h"
-
-namespace OpenFDM {
-
-class Joint;
-
-class ModelGroup : public Node {
-  OPENFDM_OBJECT(ModelGroup, Node);
-public:
-  ModelGroup(const std::string& name);
-  virtual ~ModelGroup(void);
-
-  /// Double dispatch helper for the ModelVisitor
-  virtual void accept(ModelVisitor& visitor);
-  /// Double dispatch helper for the multibody system visitor
-//   virtual void accept(ConstModelVisitor& visitor) const;
-
-  virtual const ModelGroup* toModelGroup(void) const;
-  virtual ModelGroup* toModelGroup(void);
-
-  /// Interfaces to gain access to the Models contained in this ModelGroup
-  unsigned getNumModels(void) const { return mModels.size(); }
-  const Node* getModel(unsigned idx) const;
-  Node* getModel(unsigned idx);
-  const Node* getModel(const std::string& name) const;
-  Node* getModel(const std::string& name);
-  unsigned getModelIndex(const std::string& name) const;
-  unsigned getModelIndex(const Node* const model) const;
-  unsigned addModel(Node* model, bool allowRename = false);
-  void removeModel(Node* model);
-
-  /// Interfaces to gain access to the Connections contained in this ModelGroup
-  void addConnection(Connection* connection);
-  void removeConnection(Connection* connection);
-  unsigned getConnectionIndex(const Connection* const connection) const;
-  unsigned getNumConnections(void) const { return mConnections.size(); }
-  Connection* getConnection(unsigned i);
-  const Connection* getConnection(unsigned i) const;
-
-  /// Returns the path of this ModelGroup. In contrast to getPath this returns
-  /// the path including the current ModelGroup.
-  GroupPath getGroupPath() OpenFDM_DEPRECATED;
-
-  bool addSampleTime(const SampleTime& sampleTime)
-  { return mSampleTimeSet.addSampleTime(sampleTime); }
-  bool removeSampleTime(const SampleTime& sampleTime)
-  { return mSampleTimeSet.removeSampleTime(sampleTime); }
-  const SampleTimeSet& getSampleTimeSet(void) const
-  { return mSampleTimeSet; }
-
-private:
-
-  typedef std::vector<SharedPtr<Node> > ModelList;
-  typedef std::vector<SharedPtr<Connection> > ConnectionList;
-
-  /// The List of models contained in this group.
-  ModelList mModels;
-  SampleTimeSet mSampleTimeSet;
-  /// The list of connections lines within this model group
-  ConnectionList mConnections;
-};
-
-} // namespace OpenFDM
-
-#endif

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.cpp	2008-08-31 06:43:16 UTC (rev 426)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.cpp	2008-08-31 08:38:15 UTC (rev 427)
@@ -6,6 +6,7 @@
 
 #include "LeafNode.h"
 #include "Model.h"
+#include "Group.h"
 
 namespace OpenFDM {
 
@@ -30,4 +31,22 @@
   apply(static_cast<LeafNode&>(node));
 }
 
+void
+NodeVisitor::apply(Group& node)
+{
+  apply(static_cast<Node&>(node));
+}
+
+void
+NodeVisitor::apply(GroupAcceptorNode& node)
+{
+  apply(static_cast<Node&>(node));
+}
+
+void
+NodeVisitor::apply(GroupProviderNode& node)
+{
+  apply(static_cast<Node&>(node));
+}
+
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.h	2008-08-31 06:43:16 UTC (rev 426)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.h	2008-08-31 08:38:15 UTC (rev 427)
@@ -20,16 +20,13 @@
   virtual ~NodeVisitor();
 
   virtual void apply(Node&);
-  virtual void apply(GroupAcceptorNode& node)
-  { apply((Node&)node); }
-  virtual void apply(GroupProviderNode& node)
-  { apply((Node&)node); }
+  virtual void apply(GroupAcceptorNode& node);
+  virtual void apply(GroupProviderNode& node);
   virtual void apply(LeafNode&);
   virtual void apply(Model&);
   virtual void apply(Body& node)
   { apply((LeafNode&)node); }
-  virtual void apply(Group& node)
-  { apply((Node&)node); }
+  virtual void apply(Group& node);
 };
 
 } // namespace OpenFDM



From frohlich at mail.berlios.de  Sun Aug 31 10:39:16 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 31 Aug 2008 10:39:16 +0200
Subject: [OpenFDM-svn] r428 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200808310839.m7V8dGcF012475@sheep.berlios.de>

Author: frohlich
Date: 2008-08-31 10:39:16 +0200 (Sun, 31 Aug 2008)
New Revision: 428

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.h
Log:
Reorder members.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.cpp	2008-08-31 08:38:15 UTC (rev 427)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.cpp	2008-08-31 08:39:16 UTC (rev 428)
@@ -20,33 +20,33 @@
 }
 
 void
-NodeVisitor::apply(LeafNode& leafNode)
+NodeVisitor::apply(Group& node)
 {
-  apply(static_cast<Node&>(leafNode));
+  apply(static_cast<Node&>(node));
 }
 
 void
-NodeVisitor::apply(Model& node)
+NodeVisitor::apply(GroupAcceptorNode& node)
 {
-  apply(static_cast<LeafNode&>(node));
+  apply(static_cast<Node&>(node));
 }
 
 void
-NodeVisitor::apply(Group& node)
+NodeVisitor::apply(GroupProviderNode& node)
 {
   apply(static_cast<Node&>(node));
 }
 
 void
-NodeVisitor::apply(GroupAcceptorNode& node)
+NodeVisitor::apply(LeafNode& leafNode)
 {
-  apply(static_cast<Node&>(node));
+  apply(static_cast<Node&>(leafNode));
 }
 
 void
-NodeVisitor::apply(GroupProviderNode& node)
+NodeVisitor::apply(Model& node)
 {
-  apply(static_cast<Node&>(node));
+  apply(static_cast<LeafNode&>(node));
 }
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.h	2008-08-31 08:38:15 UTC (rev 427)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.h	2008-08-31 08:39:16 UTC (rev 428)
@@ -20,13 +20,13 @@
   virtual ~NodeVisitor();
 
   virtual void apply(Node&);
+  virtual void apply(Group& node);
   virtual void apply(GroupAcceptorNode& node);
   virtual void apply(GroupProviderNode& node);
   virtual void apply(LeafNode&);
   virtual void apply(Model&);
   virtual void apply(Body& node)
   { apply((LeafNode&)node); }
-  virtual void apply(Group& node);
 };
 
 } // namespace OpenFDM



From frohlich at mail.berlios.de  Sun Aug 31 10:40:23 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 31 Aug 2008 10:40:23 +0200
Subject: [OpenFDM-svn] r429 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200808310840.m7V8eNHd012637@sheep.berlios.de>

Author: frohlich
Date: 2008-08-31 10:40:23 +0200 (Sun, 31 Aug 2008)
New Revision: 429

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.h
Log:
Remove methods for not yet existing classes.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.h	2008-08-31 08:39:16 UTC (rev 428)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.h	2008-08-31 08:40:23 UTC (rev 429)
@@ -12,7 +12,6 @@
 class GroupProviderNode;
 class LeafNode;
 class Model;
-class Body;
 class Group;
 
 class NodeVisitor {
@@ -20,13 +19,11 @@
   virtual ~NodeVisitor();
 
   virtual void apply(Node&);
-  virtual void apply(Group& node);
-  virtual void apply(GroupAcceptorNode& node);
-  virtual void apply(GroupProviderNode& node);
+  virtual void apply(Group&);
+  virtual void apply(GroupAcceptorNode&);
+  virtual void apply(GroupProviderNode&);
   virtual void apply(LeafNode&);
   virtual void apply(Model&);
-  virtual void apply(Body& node)
-  { apply((LeafNode&)node); }
 };
 
 } // namespace OpenFDM



From frohlich at mail.berlios.de  Sun Aug 31 11:46:30 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 31 Aug 2008 11:46:30 +0200
Subject: [OpenFDM-svn] r430 - trunk/OpenFDM/src/test
Message-ID: <200808310946.m7V9kUNX017754@sheep.berlios.de>

Author: frohlich
Date: 2008-08-31 11:46:30 +0200 (Sun, 31 Aug 2008)
New Revision: 430

Modified:
   trunk/OpenFDM/src/test/unitstest.cpp
Log:
Make make check compile again.


Modified: trunk/OpenFDM/src/test/unitstest.cpp
===================================================================
--- trunk/OpenFDM/src/test/unitstest.cpp	2008-08-31 08:40:23 UTC (rev 429)
+++ trunk/OpenFDM/src/test/unitstest.cpp	2008-08-31 09:46:30 UTC (rev 430)
@@ -305,7 +305,7 @@
   } else if (first == stream.widen('K')) {
     // K elvin
     stream.get();
-    u = Unit::temperature();
+    u = Unit::thermodynamicTemperature();
     return stream;
   } else if (first == stream.widen('M')) {
     // M must be mega = 1e6



From frohlich at mail.berlios.de  Sun Aug 31 11:47:40 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 31 Aug 2008 11:47:40 +0200
Subject: [OpenFDM-svn] r431 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200808310947.m7V9lekr017809@sheep.berlios.de>

Author: frohlich
Date: 2008-08-31 11:47:40 +0200 (Sun, 31 Aug 2008)
New Revision: 431

Modified:
   branches/OpenFDM-StateSeparation/src/test/unitstest.cpp
Log:
Merge Changeset 430 from trunk


Modified: branches/OpenFDM-StateSeparation/src/test/unitstest.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/unitstest.cpp	2008-08-31 09:46:30 UTC (rev 430)
+++ branches/OpenFDM-StateSeparation/src/test/unitstest.cpp	2008-08-31 09:47:40 UTC (rev 431)
@@ -305,7 +305,7 @@
   } else if (first == stream.widen('K')) {
     // K elvin
     stream.get();
-    u = Unit::temperature();
+    u = Unit::thermodynamicTemperature();
     return stream;
   } else if (first == stream.widen('M')) {
     // M must be mega = 1e6



From frohlich at mail.berlios.de  Sun Aug 31 12:01:31 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 31 Aug 2008 12:01:31 +0200
Subject: [OpenFDM-svn] r432 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200808311001.m7VA1VHA021739@sheep.berlios.de>

Author: frohlich
Date: 2008-08-31 12:01:31 +0200 (Sun, 31 Aug 2008)
New Revision: 432

Added:
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Modified:
   branches/OpenFDM-StateSeparation/src/test/Makefile.am
Log:
Dump remaining test program into svn.


Modified: branches/OpenFDM-StateSeparation/src/test/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/Makefile.am	2008-08-31 09:47:40 UTC (rev 431)
+++ branches/OpenFDM-StateSeparation/src/test/Makefile.am	2008-08-31 10:01:31 UTC (rev 432)
@@ -2,9 +2,10 @@
 
 # define some util programs
 # bin_PROGRAMS = tiretestrig
+bin_PROGRAMS = structure
 
 # define some unit tests
-#check_PROGRAMS = quattest unitstest simulationtime constintegral harmonic limit
+#check_PROGRAMS = quattest unitstest structure simulationtime constintegral harmonic limit
 check_PROGRAMS = quattest unitstest limit
 TESTS          = $(check_PROGRAMS)
 
@@ -17,6 +18,9 @@
 quattest_SOURCES = quattest.cpp
 quattest_LDADD = ../OpenFDM/libOpenFDM.la
 
+structure_SOURCES = structure.cpp
+structure_LDADD = ../OpenFDM/libOpenFDM.la
+
 # simulationtime_SOURCES = simulationtime.cpp
 # simulationtime_LDADD = ../OpenFDM/libOpenFDM.la
 

Added: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-08-31 09:47:40 UTC (rev 431)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-08-31 10:01:31 UTC (rev 432)
@@ -0,0 +1,445 @@
+#include <OpenFDM/Matrix.h>
+#include <OpenFDM/Object.h>
+#include <OpenFDM/SharedPtr.h>
+#include <OpenFDM/WeakPtr.h>
+#include <OpenFDM/Rotation.h>
+#include <OpenFDM/Inertia.h>
+#include <OpenFDM/PortValue.h>
+#include <OpenFDM/PortValueList.h>
+#include <OpenFDM/PortId.h>
+#include <OpenFDM/PortInfo.h>
+#include <OpenFDM/AcceptorPortInfo.h>
+#include <OpenFDM/ProviderPortInfo.h>
+#include <OpenFDM/NumericPortValue.h>
+#include <OpenFDM/Node.h>
+#include <OpenFDM/NodeVisitor.h>
+#include <OpenFDM/NumericAcceptorPortInfo.h>
+#include <OpenFDM/NumericProviderPortInfo.h>
+#include <OpenFDM/MatrixInputPort.h>
+#include <OpenFDM/MatrixOutputPort.h>
+#include <OpenFDM/RealInputPort.h>
+#include <OpenFDM/RealOutputPort.h>
+
+#include <OpenFDM/StateInfo.h>
+#include <OpenFDM/StateValue.h>
+#include <OpenFDM/ContinousStateValue.h>
+#include <OpenFDM/MatrixStateValue.h>
+
+#include <OpenFDM/StateInfoVector.h>
+#include <OpenFDM/ContinousStateInfoVector.h>
+
+#include <OpenFDM/ContinousStateValueVector.h>
+#include <OpenFDM/DiscreteStateValueVector.h>
+
+#include <OpenFDM/BoolStateInfo.h>
+#include <OpenFDM/RealStateInfo.h>
+#include <OpenFDM/MatrixStateInfo.h>
+
+#include <OpenFDM/LeafContext.h>
+
+#include <OpenFDM/Gain.h>
+#include <OpenFDM/Integrator.h>
+#include <OpenFDM/Delay.h>
+
+#include <OpenFDM/Group.h>
+
+#include <iterator>
+#include <algorithm>
+#include <sstream>
+
+namespace OpenFDM {
+
+/// Evaluation orders:
+///
+/// Initialization:
+///  init
+///  output(t = t0)
+/// Now the values in the ports belong to t = t0
+///
+/// Loop
+///  while (t0 < tEnd)
+///   output(t0) // Only if port values are not already at t0
+///   update // prepare model's state for time interval [t0, t0+h]
+///   Continous // do time integration
+///    output(t0+s)
+///    derivative(t0+s)
+///
+///  output(tEnd)
+/// Now the values in the ports belong to t = tEnd
+///  
+/// Update discrete states based on ports at time t to discrete states for
+/// the next timestep, that may just set state for t = t+h so that output can
+/// now return values for the next timestep.
+/// Then evaluate ports for time t = t+h.
+///
+/// Note that we can also outputs for the desired simulation time at the end.
+/// Then we just reevaluate outputs when we get asked for a time within the
+/// current integration timestep. If we need to start a new timestep,
+/// reevaluate outputs for that particular timesteps start time.
+/// In the best case this time matches the alread present output time.
+/// FIXME: IMO THIS MUST WORK THIS WAY
+///
+
+class Print : public Model {
+public:
+  Print(const std::string& name = std::string()) :
+    Model(name),
+    mInputPort(newRealInputPort("input"))
+  { }
+  virtual void output(const DiscreteStateValueVector&, const ContinousStateValueVector&, PortValueList& portValues) const
+  { std::cout << portValues[mInputPort] << std::endl; }
+  virtual bool dependsOn(const PortId&, const PortId&) const
+  { return false; }
+private:
+  RealInputPort mInputPort;
+};
+
+class LeafInstance : public WeakReferenced {
+public:
+  struct AcceptorPortData;
+  struct ProviderPortData;
+
+  LeafInstance(const LeafNode* leaf) :
+    _leaf(leaf)
+  { allocPorts(leaf); }
+
+  void allocPorts(const Node* node)
+  {
+    for (unsigned i = 0; i < node->getNumPorts(); ++i) {
+      SharedPtr<const PortInfo> port = node->getPort(i);
+      const ProviderPortInfo* providerPort = port->toProviderPortInfo();
+      if (providerPort) {
+        _providerPortData.push_back(new ProviderPortData(this, providerPort));
+      }
+      const AcceptorPortInfo* acceptorPort = port->toAcceptorPortInfo();
+      if (acceptorPort) {
+        _acceptorPortData.push_back(new AcceptorPortData(this, acceptorPort));
+      }
+    }
+  }
+
+  // The subsystem leaf node
+  SharedPtr<const LeafNode> _leaf;
+
+  struct ProviderPortData : public WeakReferenced {
+    ProviderPortData(LeafInstance* leafInstance,
+                     const ProviderPortInfo* providerPort) :
+      _leafInstance(leafInstance),
+      _providerPort(providerPort)
+    {}
+    WeakPtr<LeafInstance> _leafInstance;
+    SharedPtr<const ProviderPortInfo> _providerPort;
+    std::vector<WeakPtr<const AcceptorPortData> > _acceptorPortDataList;
+  };
+  struct AcceptorPortData : public WeakReferenced {
+    AcceptorPortData(LeafInstance* leafInstance,
+                     const AcceptorPortInfo* acceptorPort) :
+      _leafInstance(leafInstance)
+    { _acceptorPortList.push_back(acceptorPort); }
+    WeakPtr<LeafInstance> _leafInstance;
+    std::vector<SharedPtr<const AcceptorPortInfo> > _acceptorPortList;
+    WeakPtr<const ProviderPortData> _providerPortData;
+  };
+  typedef std::vector<SharedPtr<AcceptorPortData> > AcceptorPortDataList;
+  AcceptorPortDataList _acceptorPortData;
+  typedef std::vector<SharedPtr<ProviderPortData> > ProviderPortDataList;
+  ProviderPortDataList _providerPortData;
+
+  AcceptorPortData* getAcceptorPortData(const AcceptorPortInfo* acceptorPort)
+  {
+    AcceptorPortDataList::const_iterator i;
+    for (i = _acceptorPortData.begin(); i != _acceptorPortData.end(); ++i) {
+      for (unsigned j = 0; j < (*i)->_acceptorPortList.size(); ++j) {
+        if ((*i)->_acceptorPortList[j] == acceptorPort)
+          return *i;
+      }
+    }
+    return 0;
+  }
+  ProviderPortData* getProviderPortData(const ProviderPortInfo* providerPort)
+  {
+    ProviderPortDataList::const_iterator i;
+    for (i = _providerPortData.begin(); i != _providerPortData.end(); ++i) {
+      if ((*i)->_providerPort == providerPort)
+        return *i;
+    }
+    return 0;
+  }
+
+  AcceptorPortData* getAcceptorPortData(const PortId& portId)
+  {
+    AcceptorPortDataList::const_iterator i;
+    for (i = _acceptorPortData.begin(); i != _acceptorPortData.end(); ++i) {
+      for (unsigned j = 0; j < (*i)->_acceptorPortList.size(); ++j) {
+        if (PortId(SharedPtr<const PortInfo>((*i)->_acceptorPortList[j])) == portId)
+          return *i;
+      }
+    }
+    return 0;
+  }
+  ProviderPortData* getProviderPortData(const PortId& portId)
+  {
+    ProviderPortDataList::const_iterator i;
+    for (i = _providerPortData.begin(); i != _providerPortData.end(); ++i) {
+      if (PortId(SharedPtr<const PortInfo>((*i)->_providerPort)) == portId)
+        return *i;
+    }
+    return 0;
+  }
+};
+
+class LeafInstanceCollector : public NodeVisitor {
+public:
+
+  virtual void apply(Node& node)
+  {
+    std::cerr << __PRETTY_FUNCTION__ << std::endl;
+  }
+
+  // Aussen acceptor, innen provider
+  virtual void apply(GroupAcceptorNode& leaf)
+  {
+    OpenFDMAssert(leaf.getPort(0));
+    PortId portId = leaf.getPortId(0);
+    _leafPortDataMap[getCurrentNodeId()][portId]._acceptorPortData = 0;
+    LeafInstance::ProviderPortData* pd
+      = new LeafInstance::ProviderPortData(0, leaf._groupInternalPort);
+    _leafPortDataMap[getCurrentNodeId()][portId]._providerPortData = pd;
+  }
+  // Aussen provider, innen acceptor
+  virtual void apply(GroupProviderNode& leaf)
+  {
+    OpenFDMAssert(leaf.getPort(0));
+    PortId portId = leaf.getPortId(0);
+    LeafInstance::AcceptorPortData* ad
+      = new LeafInstance::AcceptorPortData(0, leaf._groupInternalPort);
+    _leafPortDataMap[getCurrentNodeId()][portId]._acceptorPortData = ad;
+    _leafPortDataMap[getCurrentNodeId()][portId]._providerPortData = 0;
+  }
+  virtual void apply(LeafNode& leaf)
+  {
+    // FIXME: assert that the current node id is something valid ...
+
+    LeafInstance* leafInstance = new LeafInstance(&leaf);
+    _leafInstanceList.push_back(leafInstance);
+
+    for (unsigned i = 0; i < leaf.getNumPorts(); ++i) {
+      PortId portId = leaf.getPortId(i);
+      _leafPortDataMap[getCurrentNodeId()][portId]._acceptorPortData
+        = leafInstance->getAcceptorPortData(portId);
+      _leafPortDataMap[getCurrentNodeId()][portId]._providerPortData
+        = leafInstance->getProviderPortData(portId);
+    }
+  }
+  virtual void apply(Group& group)
+  {
+    // Prepare a new leaf map for the child group
+    LeafPortDataMap parentLeafPortDataMap;
+    parentLeafPortDataMap.swap(_leafPortDataMap);
+
+    // Walk the children
+#if 0
+    group.traverse(*this);
+#else
+    for (unsigned i = 0; i < group.getNumChildren(); ++i) {
+      pushNodeId(group.getNodeId(i));
+      group.getChild(i)->accept(*this);
+      popNodeId();
+    }
+#endif
+
+    // Apply the group internal connections to the instances
+    unsigned numConnects = group.getNumConnects();
+    for (unsigned i = 0; i < numConnects; ++i) {
+      Group::NodeId acceptorNodeId = group.getConnectAcceptorNodeId(i);
+      Group::NodeId providerNodeId = group.getConnectProviderNodeId(i);
+
+      if (!group.getChild(acceptorNodeId)) {
+        std::cerr << "Cannot find acceptor node from nodeId" << std::endl;
+        continue;
+      }
+      if (!group.getChild(acceptorNodeId)) {
+        std::cerr << "Cannot find provider node from nodeId" << std::endl;
+        continue;
+      }
+
+      SharedPtr<const AcceptorPortInfo> acceptorPort;
+      acceptorPort = group.getConnectAcceptorPortInfo(i);
+      PortId acceptorPortId = SharedPtr<const PortInfo>(acceptorPort);
+      SharedPtr<const ProviderPortInfo> providerPort;
+      providerPort = group.getConnectProviderPortInfo(i);
+      PortId providerPortId = SharedPtr<const PortInfo>(providerPort);
+
+      if (!acceptorPort) {
+        std::cerr << "Cannot find acceptor Port data node "
+                  << group.getChild(acceptorNodeId)->getName() << std::endl;
+        continue;
+      }
+      if (!providerPort) {
+        std::cerr << "Cannot find provider Port data node "
+                  << group.getChild(providerNodeId)->getName() << std::endl;
+        continue;
+      }
+
+      LeafInstance::AcceptorPortData* acceptorPortData =
+        _leafPortDataMap[acceptorNodeId][acceptorPortId]._acceptorPortData;
+      LeafInstance::ProviderPortData* providerPortData =
+        _leafPortDataMap[providerNodeId][providerPortId]._providerPortData;
+
+      if (!acceptorPortData) {
+        std::cout << "Cannot find acceptor Port data" << std::endl;
+        continue;
+      }
+      if (!providerPortData) {
+        std::cout << "Cannot find provider Port data" << std::endl;
+        continue;
+      }
+
+      // FIXME Error message ??? and abort visiting???
+      if (acceptorPortData->_providerPortData.lock())
+        std::cerr << "??? already have a provider port????" << std::endl;
+      acceptorPortData->_providerPortData = providerPortData;
+      providerPortData->_acceptorPortDataList.push_back(acceptorPortData);
+    }
+
+    // Add a proxy LeafInstance that holds this groups ports, will be removed
+    // when merged into the parent
+    // FIXME: how to tell the parent group which connections need to be done??
+    // FIXME:
+    // add group connect routings
+    // merge child list into the global list of instances
+    for (unsigned i = 0; i < group.getNumPorts(); ++i) {
+      PortId portId = group.getPortId(i);
+      Group::NodeId nodeId = group.getGroupPortNode(portId);
+      if (group.getPort(i)->toAcceptorPortInfo())
+        parentLeafPortDataMap[getCurrentNodeId()][portId]._acceptorPortData
+          = new LeafInstance::AcceptorPortData(0, group.getPort(i)->toAcceptorPortInfo());
+      if (group.getPort(i)->toProviderPortInfo())
+        parentLeafPortDataMap[getCurrentNodeId()][portId]._providerPortData
+          = new LeafInstance::ProviderPortData(0, group.getPort(i)->toProviderPortInfo());
+
+      if (_leafPortDataMap[nodeId].empty()) {
+        // FIXME, is this an internal error ???
+        std::cerr << "Hmm, cannot find GroupPortNode for external port "
+                  << i << std::endl;
+        continue;
+      }
+      parentLeafPortDataMap[getCurrentNodeId()][portId].
+        merge(_leafPortDataMap[nodeId].begin()->second);
+    }
+
+    parentLeafPortDataMap.swap(_leafPortDataMap);
+  }
+
+  ////////////////////////////////////////////////////////////////////////////
+  // The final list of leafs we have in the system
+  typedef std::list<SharedPtr<LeafInstance> > LeafInstanceList;
+  LeafInstanceList _leafInstanceList;
+
+  ////////////////////////////////////////////////////////////////////////////
+  // Used to map connections in groups ...
+  struct PortData {
+    SharedPtr<LeafInstance::ProviderPortData> _providerPortData;
+    SharedPtr<LeafInstance::AcceptorPortData> _acceptorPortData;
+
+    // Merge the argument from the child group into the current groups data
+    void merge(const PortData& portData)
+    {
+      if (_providerPortData) {
+        OpenFDMAssert(portData._acceptorPortData);
+        SharedPtr<const LeafInstance::ProviderPortData> providerPortData =
+          portData._acceptorPortData->_providerPortData.lock();
+        OpenFDMAssert(providerPortData);
+        _providerPortData->_providerPort = providerPortData->_providerPort;
+      }
+
+      if (_acceptorPortData) {
+        OpenFDMAssert(portData._providerPortData);
+        for (unsigned i = 0;
+             i < portData._providerPortData->_acceptorPortDataList.size();
+             ++i) {
+          SharedPtr<const LeafInstance::AcceptorPortData> acceptorPortData =
+            portData._providerPortData->_acceptorPortDataList[i].lock();
+          
+          OpenFDMAssert(acceptorPortData);
+          for (unsigned j = 0;
+               j < acceptorPortData->_acceptorPortList.size(); ++j) {
+            _acceptorPortData->_acceptorPortList.
+              push_back(acceptorPortData->_acceptorPortList[j]);
+          }
+        }
+      }
+    }
+  };
+  typedef std::map<PortId, PortData> NodePortDataMap;
+  typedef std::map<Group::NodeId, NodePortDataMap> LeafPortDataMap;
+  LeafPortDataMap _leafPortDataMap;
+
+
+  void pushNodeId(const Group::NodeId& nodeId)
+  { _nodeIdStack.push_back(nodeId); }
+  void popNodeId()
+  { _nodeIdStack.pop_back(); }
+  Group::NodeId getCurrentNodeId() const
+  {
+    if (_nodeIdStack.empty())
+      return Group::NodeId();
+    return _nodeIdStack.back();
+  }
+
+private:
+  typedef std::list<Group::NodeId> NodeIdStack;
+  NodeIdStack _nodeIdStack;
+};
+
+} // namespace OpenFDM
+
+using namespace OpenFDM;
+
+int main()
+{
+  SharedPtr<Group> group = new Group("G0");
+  Group::NodeId gain = group->addChild(new Gain("gain"));
+  Group::NodeId integrator1 = group->addChild(new Integrator("I1"));
+  Group::NodeId integrator2 = group->addChild(new Integrator("I2"));
+  Group::NodeId print = group->addChild(new Print("P"));
+  Group::NodeId delay = group->addChild(new Delay("D"));
+  Group::NodeId printDelay = group->addChild(new Print("PD"));
+
+  group->connect(integrator1, "output", integrator2, "input");
+  group->connect(integrator2, "output", gain, "input");
+  group->connect(gain, "output", integrator1, "input");
+  group->connect(integrator2, "output", print, "input");
+  group->connect(gain, "output", delay, "input");
+  group->connect(delay, "output", printDelay, "input");
+
+  //FIXME: broken naming
+//   Group::NodeId groupOutputNode = group->addAcceptorPort();
+  Group::NodeId groupOutputNode = group->addProviderPort();
+  group->connect(integrator2, "output", groupOutputNode, "input");
+
+  SharedPtr<Group> topGroup = new Group("G1");
+  Group::NodeId child0 = topGroup->addChild(group);
+  Group::NodeId child1 = topGroup->addChild(group);
+
+  Group::NodeId print0 = topGroup->addChild(new Print("P2"));
+  topGroup->connect(child0, 0, print0, 0);
+  Group::NodeId print1 = topGroup->addChild(new Print("P3"));
+  topGroup->connect(child1, 0, print1, 0);
+
+  /////////////////////////////////////////////////
+
+  LeafInstanceCollector nodeInstanceCollector;
+  topGroup->accept(nodeInstanceCollector);
+  
+  std::cout << nodeInstanceCollector._leafInstanceList.size() << std::endl;
+
+  LeafInstanceCollector::LeafInstanceList::const_iterator i;
+  for (i = nodeInstanceCollector._leafInstanceList.begin();
+       i != nodeInstanceCollector._leafInstanceList.end();
+       ++i) {
+    std::cout << "Node: " << (*i)->_leaf->getName() << std::endl;
+  }
+
+  return 0;
+}



From frohlich at mail.berlios.de  Sun Aug 31 12:12:25 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 31 Aug 2008 12:12:25 +0200
Subject: [OpenFDM-svn] r433 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200808311012.m7VACPbG022541@sheep.berlios.de>

Author: frohlich
Date: 2008-08-31 12:12:25 +0200 (Sun, 31 Aug 2008)
New Revision: 433

Modified:
   trunk/OpenFDM/src/OpenFDM/Time.cpp
Log:
Make it compile with gcc-4.4.0


Modified: trunk/OpenFDM/src/OpenFDM/Time.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Time.cpp	2008-08-31 10:01:31 UTC (rev 432)
+++ trunk/OpenFDM/src/OpenFDM/Time.cpp	2008-08-31 10:12:25 UTC (rev 433)
@@ -6,6 +6,7 @@
 
 #include <time.h>
 #include <cerrno>
+#include <cstdio>
 #include <cmath>
 
 namespace OpenFDM {



From frohlich at mail.berlios.de  Sun Aug 31 12:13:00 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 31 Aug 2008 12:13:00 +0200
Subject: [OpenFDM-svn] r434 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200808311013.m7VAD0Cm022587@sheep.berlios.de>

Author: frohlich
Date: 2008-08-31 12:12:59 +0200 (Sun, 31 Aug 2008)
New Revision: 434

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Time.cpp
Log:
Merge changeset 433.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Time.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Time.cpp	2008-08-31 10:12:25 UTC (rev 433)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Time.cpp	2008-08-31 10:12:59 UTC (rev 434)
@@ -6,6 +6,7 @@
 
 #include <time.h>
 #include <cerrno>
+#include <cstdio>
 #include <cmath>
 
 namespace OpenFDM {



From frohlich at mail.berlios.de  Sun Aug 31 12:24:50 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 31 Aug 2008 12:24:50 +0200
Subject: [OpenFDM-svn] r435 - branches/OpenFDM-StateSeparation
Message-ID: <200808311024.m7VAOobc023653@sheep.berlios.de>

Author: frohlich
Date: 2008-08-31 12:24:50 +0200 (Sun, 31 Aug 2008)
New Revision: 435

Added:
   branches/OpenFDM-StateSeparation/MERGE-REVISION
Log:
Note the last merged revision here.


Added: branches/OpenFDM-StateSeparation/MERGE-REVISION
===================================================================
--- branches/OpenFDM-StateSeparation/MERGE-REVISION	2008-08-31 10:12:59 UTC (rev 434)
+++ branches/OpenFDM-StateSeparation/MERGE-REVISION	2008-08-31 10:24:50 UTC (rev 435)
@@ -0,0 +1 @@
+434
\ No newline at end of file



