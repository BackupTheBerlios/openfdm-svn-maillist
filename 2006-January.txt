From frohlich at berlios.de  Mon Jan  2 09:38:06 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Mon, 2 Jan 2006 09:38:06 +0100
Subject: [OpenFDM-svn] r151 - trunk/OpenFDM/src/JSBSim
Message-ID: <200601020838.k028c6GC018585@sheep.berlios.de>

Author: frohlich
Date: 2006-01-02 09:38:03 +0100 (Mon, 02 Jan 2006)
New Revision: 151

Modified:
   trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
Log:
Make the gear parts weaker ...


Modified: trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
===================================================================
--- trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2005-12-31 13:24:02 UTC (rev 150)
+++ trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2006-01-02 08:38:03 UTC (rev 151)
@@ -737,8 +737,9 @@
                                 RigidBody* parent)
 {
   RigidBody* wheel = new RigidBody(name + " Wheel");
-  InertiaMatrix wheelInertia(10, 0, 0, 100, 0, 10);
-  wheel->addInteract(new Mass(name + " Wheel Inertia", SpatialInertia(wheelInertia, 50)));
+  InertiaMatrix wheelInertia(10, 0, 0, 30, 0, 10);
+  wheel->addInteract(new Mass(name + " Wheel Inertia",
+                              SpatialInertia(wheelInertia, 30)));
   mVehicle->getMultiBodySystem()->addRigidBody(wheel);
   
   RevoluteJoint* wj = new RevoluteJoint(name + " Wheel Joint");
@@ -750,10 +751,10 @@
   wj->setJointPos(0);
   wj->setJointVel(0);
 
-  // Add an brake force
+  // Add a brake force
   if (brake == "LEFT" || brake == "RIGHT") {
     DiscBrake* brakeF = new DiscBrake(name + " Brake Force");
-    brakeF->setFrictionConstant(-1e4);
+    brakeF->setFrictionConstant(-2e3);
     if (brake == "LEFT") {
       Port* port = lookupJSBExpression("gear/left-brake-pos-norm");
       brakeF->getInputPort(0)->connect(port);
@@ -939,7 +940,7 @@
       // This is the movable part of the strut, doing the compression
       RigidBody* arm = new RigidBody(name + " Arm");
       mVehicle->getMultiBodySystem()->addRigidBody(arm);
-      arm->addInteract(new Mass(name + " Strut Mass", inertiaFrom(Vector3(-1, 0, 0), SpatialInertia(200))));
+      arm->addInteract(new Mass(name + " Strut Mass", inertiaFrom(Vector3(-1, 0, 0), SpatialInertia(100))));
 
       // Connect that with a revolute joint to the main body
       RevoluteJoint* rj = new RevoluteJoint(name + " Arm Joint");
@@ -1056,7 +1057,7 @@
       // Now the compressible part of the strut
       RigidBody* arm = new RigidBody(name + " Strut");
       mVehicle->getMultiBodySystem()->addRigidBody(arm);
-      arm->addInteract(new Mass(name + " Strut Mass", inertiaFrom(Vector3(0, 0, 1), SpatialInertia(200))));
+      arm->addInteract(new Mass(name + " Strut Mass", inertiaFrom(Vector3(0, 0, 1), SpatialInertia(100))));
 
       // This time it is a prismatic joint
       PrismaticJoint* pj = new PrismaticJoint(name + " Compress Joint");



From frohlich at berlios.de  Mon Jan  2 10:18:43 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Mon, 2 Jan 2006 10:18:43 +0100
Subject: [OpenFDM-svn] r152 - in trunk/OpenFDM/src: JSBSim OpenFDM
Message-ID: <200601020918.k029IhZg022107@sheep.berlios.de>

Author: frohlich
Date: 2006-01-02 10:18:40 +0100 (Mon, 02 Jan 2006)
New Revision: 152

Modified:
   trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
   trunk/OpenFDM/src/OpenFDM/DiscBrake.cpp
   trunk/OpenFDM/src/OpenFDM/DiscBrake.h
Log:
Experiment with a dahl friction model


Modified: trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
===================================================================
--- trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2006-01-02 08:38:03 UTC (rev 151)
+++ trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2006-01-02 09:18:40 UTC (rev 152)
@@ -754,7 +754,8 @@
   // Add a brake force
   if (brake == "LEFT" || brake == "RIGHT") {
     DiscBrake* brakeF = new DiscBrake(name + " Brake Force");
-    brakeF->setFrictionConstant(-2e3);
+    brakeF->setMinForce(8e1);
+    brakeF->setMaxForce(1e4);
     if (brake == "LEFT") {
       Port* port = lookupJSBExpression("gear/left-brake-pos-norm");
       brakeF->getInputPort(0)->connect(port);

Modified: trunk/OpenFDM/src/OpenFDM/DiscBrake.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/DiscBrake.cpp	2006-01-02 08:38:03 UTC (rev 151)
+++ trunk/OpenFDM/src/OpenFDM/DiscBrake.cpp	2006-01-02 09:18:40 UTC (rev 152)
@@ -10,10 +10,13 @@
 
 DiscBrake::DiscBrake(const std::string& name) :
   Model(name),
-  mFrictionConstant(-1)
+  mMinForce(0),
+  mMaxForce(1)
 {
   setDirectFeedThrough(true);
 
+  setNumContinousStates(1);
+
   setNumInputPorts(2);
   setInputPortName(0, "brakePressure");
   setInputPortName(1, "velocity");
@@ -45,34 +48,76 @@
   }
   mVelocityPort = getInputPort(1)->toRealPortHandle();
 
+  // start with zero friction force
+  mZ = 0;
+
   return true;
 }
 
 void
 DiscBrake::output(const TaskInfo& taskInfo)
 {
+  real_type sigma = 100;
   real_type brakeInput = mBrakePressurePort.getRealValue();
   real_type vel = mVelocityPort.getRealValue();
-  /// Hmm, this seems to be an intermediate model for a disc brake ...
-  mForce = vel*(-1e1 + brakeInput*mFrictionConstant);
+  // with this sigma the model is already very crisp and reaches the
+  // maximum force relatively fast, thus we do not need to make it even faster
+  // with higher speeds
+  vel = sign(vel)*min(1.0, fabs(vel));
+  // the time derivative of the friction state
+  mZDeriv = vel - sigma*fabs(vel)*mZ;
+  // this is to limit the stiffness of this model
+  mZDeriv = sign(mZDeriv)*min(10.0, fabs(mZDeriv));
+  // now the output force, modulate with the brake input
+  mForce = -interpolate(brakeInput, 0.0, mMinForce, 1.0, mMaxForce)*sigma*mZ;
 }
 
+void
+DiscBrake::setState(const StateStream& state)
+{
+  state.readSubState(mZ);
+}
+
+void
+DiscBrake::getState(StateStream& state) const
+{
+  state.writeSubState(mZ);
+}
+
+void
+DiscBrake::getStateDeriv(StateStream& stateDeriv)
+{
+  stateDeriv.writeSubState(mZDeriv);
+}
+
 const real_type&
 DiscBrake::getForce(void) const
 {
   return mForce;
 }
 
-real_type
-DiscBrake::getFrictionConstant(void) const
+const real_type&
+DiscBrake::getMinForce(void) const
 {
-  return mFrictionConstant;
+  return mMinForce;
 }
 
 void
-DiscBrake::setFrictionConstant(real_type frictionConstant)
+DiscBrake::setMinForce(const real_type& minForce)
 {
-  mFrictionConstant = frictionConstant;
+  mMinForce = minForce;
 }
 
+const real_type&
+DiscBrake::getMaxForce(void) const
+{
+  return mMaxForce;
+}
+
+void
+DiscBrake::setMaxForce(const real_type& maxForce)
+{
+  mMaxForce = maxForce;
+}
+
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/DiscBrake.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/DiscBrake.h	2006-01-02 08:38:03 UTC (rev 151)
+++ trunk/OpenFDM/src/OpenFDM/DiscBrake.h	2006-01-02 09:18:40 UTC (rev 152)
@@ -12,7 +12,7 @@
 
 namespace OpenFDM {
 
-/// Linear spring damper model
+/// A modified Dahl fricion model
 class DiscBrake :
     public Model {
 public:
@@ -22,17 +22,29 @@
   virtual bool init(void);
   virtual void output(const TaskInfo& taskInfo);
 
+  virtual void setState(const StateStream& state);
+  virtual void getState(StateStream& state) const;
+  virtual void getStateDeriv(StateStream& stateDeriv);
+
   const real_type& getForce(void) const;
 
-  real_type getFrictionConstant(void) const;
-  void setFrictionConstant(real_type frictionConstant);
+  const real_type& getMinForce(void) const;
+  void setMinForce(const real_type& minForce);
 
+  const real_type& getMaxForce(void) const;
+  void setMaxForce(const real_type& maxForce);
+
 private:
-  /// The friction constant for that viscosous friction model
-  real_type mFrictionConstant;
-
   /// The output brake force
   real_type mForce;
+  /// The frictions state
+  real_type mZ;
+  /// The frictions stes derivative
+  real_type mZDeriv;
+  /// The maximum force when brakes are applied
+  real_type mMaxForce;
+  /// The maximum force when brakes are not applied
+  real_type mMinForce;
 
   /// The intput port which must provide the position
   RealPortHandle mBrakePressurePort;



From frohlich at berlios.de  Mon Jan  2 13:25:31 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Mon, 2 Jan 2006 13:25:31 +0100
Subject: [OpenFDM-svn] r153 - in trunk/OpenFDM/src: JSBSim OpenFDM
Message-ID: <200601021225.k02CPVBP006394@sheep.berlios.de>

Author: frohlich
Date: 2006-01-02 13:25:24 +0100 (Mon, 02 Jan 2006)
New Revision: 153

Modified:
   trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
   trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.h
   trunk/OpenFDM/src/OpenFDM/AeroForce.cpp
   trunk/OpenFDM/src/OpenFDM/AeroForce.h
Log:
Move aerodynamic force evaluation away from the
old Expression based approach.


Modified: trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
===================================================================
--- trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2006-01-02 09:18:40 UTC (rev 152)
+++ trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2006-01-02 12:25:24 UTC (rev 153)
@@ -16,7 +16,6 @@
 #include <OpenFDM/ConstSystem.h>
 #include <OpenFDM/DeadBand.h>
 #include <OpenFDM/DiscreteIntegrator.h>
-#include <OpenFDM/Expression.h>
 #include <OpenFDM/TransferFunction.h>
 #include <OpenFDM/DirectForce.h>
 #include <OpenFDM/Gain.h>
@@ -94,9 +93,6 @@
   // Default discrete stepsize of JSBSim
   mVehicle->getModelGroup()->addSampleTime(SampleTime(1.0/120));
 
-  // Create the aerodynamic properties of JSBSim.
-  makeAeroprops();
-
   // Try to find the given file on the given search path
   std::ifstream acFileStream;
   if (!openFile(mAircraftPath, acFileName, acFileStream))
@@ -222,13 +218,18 @@
   Port* port;
   if (mExpressionTable.count(propName) <= 0) {
     // Not yet available, so look and see if it is an input
-    port = createAndScheduleInput(propName);
+    port = createAndScheduleAeroProp(propName);
 
-    // Ok, still not available, create a constant zero thing and bail out ...
     if (!port || !port->isConnected()) {
-      std::cerr << "Creating expression \"" << propName << "\"" << std::endl;
-
-      return addConstModel(propName + " constant", 0);
+      // Not yet available, so look and see if it is an input
+      port = createAndScheduleInput(propName);
+      
+      // Ok, still not available, create a constant zero thing and bail out ...
+      if (!port || !port->isConnected()) {
+        std::cerr << "Creating expression \"" << propName << "\"" << std::endl;
+        
+        return addConstModel(propName + " constant", 0);
+      }
     }
     
   } else {
@@ -458,6 +459,172 @@
 }
 
 Port*
+LegacyJSBSimReader::createAndScheduleAeroProp(const std::string& propName)
+{
+  // This routine checks if the given propName is a aerodynamic reference
+  // point property. If so, it schedules and registers a discrete input model.
+  Port* port = 0;
+  if (propName == "fdm/jsbsim/velocities/vt-mps") {
+    port = mAeroForce->getOutputPort("trueSpeed");
+  } else if (propName == "fdm/jsbsim/velocities/vt-fps") {
+    port = mAeroForce->getOutputPort("trueSpeed");
+    port = addMultiBodyToUnit("True Speed fps", uFeetPSecond, port);
+  } else if (propName == "fdm/jsbsim/velocities/vt-kts") {
+    port = mAeroForce->getOutputPort("trueSpeed");
+    port = addMultiBodyToUnit("True Speed kts", uKnots, port);
+
+  } else if (propName == "fdm/jsbsim/velocities/mach-norm" ||
+             propName == "fdm/jsbsim/velocities/mach") {
+    port = mAeroForce->getOutputPort("machNumber");
+
+  } else if (propName == "fdm/jsbsim/velocities/p-rad_sec") {
+    port = mAeroForce->getOutputPort("p");
+  } else if (propName == "fdm/jsbsim/velocities/p-deg_sec") {
+    port = mAeroForce->getOutputPort("p");
+    port = addMultiBodyToUnit("P deg_sec", uDegree, port);
+
+  } else if (propName == "fdm/jsbsim/velocities/q-rad_sec") {
+    port = mAeroForce->getOutputPort("q");
+  } else if (propName == "fdm/jsbsim/velocities/q-deg_sec") {
+    port = mAeroForce->getOutputPort("q");
+    port = addMultiBodyToUnit("Q deg_sec", uDegree, port);
+
+  } else if (propName == "fdm/jsbsim/velocities/r-rad_sec") {
+    port = mAeroForce->getOutputPort("r");
+  } else if (propName == "fdm/jsbsim/velocities/r-deg_sec") {
+    port = mAeroForce->getOutputPort("r");
+    port = addMultiBodyToUnit("R deg_sec", uDegree, port);
+
+    /// FIXME: the aero stuff is yet missing!!!
+  } else if (propName == "fdm/jsbsim/velocities/p-aero-rad_sec") {
+    port = mAeroForce->getOutputPort("p");
+  } else if (propName == "fdm/jsbsim/velocities/p-aero-deg_sec") {
+    port = mAeroForce->getOutputPort("p");
+    port = addMultiBodyToUnit("P-aero deg_sec", uDegree, port);
+
+  } else if (propName == "fdm/jsbsim/velocities/q-aero-rad_sec") {
+    port = mAeroForce->getOutputPort("q");
+  } else if (propName == "fdm/jsbsim/velocities/q-aero-deg_sec") {
+    port = mAeroForce->getOutputPort("q");
+    port = addMultiBodyToUnit("Q-aero deg_sec", uDegree, port);
+
+  } else if (propName == "fdm/jsbsim/velocities/r-aero-rad_sec") {
+    port = mAeroForce->getOutputPort("r");
+  } else if (propName == "fdm/jsbsim/velocities/r-aero-deg_sec") {
+    port = mAeroForce->getOutputPort("r");
+    port = addMultiBodyToUnit("R-aero deg_sec", uDegree, port);
+
+  } else if (propName == "fdm/jsbsim/velocities/u-aero-mps") {
+    port = mAeroForce->getOutputPort("u");
+  } else if (propName == "fdm/jsbsim/velocities/u-aero-fps") {
+    port = mAeroForce->getOutputPort("u");
+    port = addMultiBodyToUnit("U-aero fps", uFeetPSecond, port);
+
+  } else if (propName == "fdm/jsbsim/velocities/v-aero-mps") {
+    port = mAeroForce->getOutputPort("v");
+  } else if (propName == "fdm/jsbsim/velocities/v-aero-fps") {
+    port = mAeroForce->getOutputPort("v");
+    port = addMultiBodyToUnit("V-aero fps", uFeetPSecond, port);
+
+  } else if (propName == "fdm/jsbsim/velocities/w-aero-mps") {
+    port = mAeroForce->getOutputPort("w");
+  } else if (propName == "fdm/jsbsim/velocities/w-aero-fps") {
+    port = mAeroForce->getOutputPort("w");
+    port = addMultiBodyToUnit("W-aero fps", uFeetPSecond, port);
+
+  } else if (propName == "fdm/jsbsim/aero/qbar-pa") {
+    port = mAeroForce->getOutputPort("dynamicPressure");
+  } else if (propName == "fdm/jsbsim/aero/qbar-psf") {
+    port = mAeroForce->getOutputPort("dynamicPressure");
+    port = addMultiBodyToUnit("Dynamic pressure psf", uPoundPFt2, port);
+
+  } else if (propName == "fdm/jsbsim/velocities/tat-r") {
+    port = mAeroForce->getOutputPort("temperature");
+    port = addMultiBodyToUnit("Temperature Rankine", uRankine, port);
+  } else if (propName == "fdm/jsbsim/velocities/tat-f") {
+    port = mAeroForce->getOutputPort("temperature");
+    port = addMultiBodyToUnit("Degree Fahrenheit", uFahrenheit, port);
+
+    // Braindead: a pressure value in velocities ...
+  } else if (propName == "fdm/jsbsim/velocities/pt-pa") {
+    port = mAeroForce->getOutputPort("pressure");
+  } else if (propName == "fdm/jsbsim/velocities/pt-lbs_sqft") {
+    port = mAeroForce->getOutputPort("temperature");
+    port = addMultiBodyToUnit("Static pressure psf", uPoundPFt2, port);
+
+  } else if (propName == "fdm/jsbsim/aero/alpha-rad") {
+    port = mAeroForce->getOutputPort("alpha");
+  } else if (propName == "fdm/jsbsim/aero/mag-alpha-rad") {
+    port = mAeroForce->getOutputPort("alpha");
+    port = addMultiBodyAbsModel("Angle of attack mag", port);
+  } else if (propName == "fdm/jsbsim/aero/alpha-deg") {
+    port = mAeroForce->getOutputPort("alpha");
+    port = addMultiBodyToUnit("Angle of attack deg", uDegree, port);
+  } else if (propName == "fdm/jsbsim/aero/mag-alpha-deg") {
+    port = lookupJSBExpression("aero/alpha-deg");
+    port = addMultiBodyAbsModel("Angle of attack mag deg", port);
+
+  } else if (propName == "fdm/jsbsim/aero/beta-rad") {
+    port = mAeroForce->getOutputPort("beta");
+  } else if (propName == "fdm/jsbsim/aero/mag-beta-rad") {
+    port = mAeroForce->getOutputPort("beta");
+    port = addMultiBodyAbsModel("Angle of attack mag", port);
+  } else if (propName == "fdm/jsbsim/aero/beta-deg") {
+    port = mAeroForce->getOutputPort("beta");
+    port = addMultiBodyToUnit("Angle of attack deg", uDegree, port);
+  } else if (propName == "fdm/jsbsim/aero/mag-beta-deg") {
+    port = lookupJSBExpression("aero/beta-deg");
+    port = addMultiBodyAbsModel("Angle of attack mag deg", port);
+
+  } else if (propName == "fdm/jsbsim/aero/alphadot-rad_sec") {
+    port = mAeroForce->getOutputPort("alphaDot");
+  } else if (propName == "fdm/jsbsim/aero/alphadot-deg_sec") {
+    port = mAeroForce->getOutputPort("alphaDot");
+    port = addMultiBodyToUnit("Angle of attack deriv deg_sec", uDegree, port);
+
+  } else if (propName == "fdm/jsbsim/aero/betadot-rad_sec") {
+    port = mAeroForce->getOutputPort("betaDot");
+  } else if (propName == "fdm/jsbsim/aero/betadot-deg_sec") {
+    port = mAeroForce->getOutputPort("betaDot");
+    port = addMultiBodyToUnit("Angle of attack deriv deg_sec", uDegree, port);
+
+  } else if (propName == "fdm/jsbsim/metrics/bw-ft") {
+    /// FIXME, just schedule a constant block for that??
+    port = mAeroForce->getOutputPort("wingSpan");
+    port = addMultiBodyToUnit("Wingspan ft", uFoot, port);
+
+  } else if (propName == "fdm/jsbsim/metrics/Sw-sqft") {
+    /// FIXME, just schedule a constant block for that??
+    port = mAeroForce->getOutputPort("wingArea");
+    port = addMultiBodyToUnit("Wingarea ft", uFoot2, port);
+
+  } else if (propName == "fdm/jsbsim/metrics/cbarw-ft") {
+    /// FIXME, just schedule a constant block for that??
+    port = mAeroForce->getOutputPort("coord");
+    port = addMultiBodyToUnit("Coord ft", uFoot, port);
+
+  } else if (propName == "fdm/jsbsim/aero/bi2vel") {
+    port = mAeroForce->getOutputPort("wingSpanOver2Speed");
+
+  } else if (propName == "fdm/jsbsim/aero/ci2vel") {
+    port = mAeroForce->getOutputPort("coordOver2Speed");
+
+  } else if (propName == "fdm/jsbsim/aero/h_b-cg-ft") {
+    port = mAeroForce->getOutputPort("hOverWingSpan");
+
+  } else if (propName == "fdm/jsbsim/aero/h_b-mac-ft") {
+    /// Hmmm, FIXME
+    port = lookupJSBExpression("aero/h_b-cg-ft");
+
+  }
+
+  if (port && port->isConnected())
+    registerExpression(propName, port);
+  
+  return port;
+}
+
+Port*
 LegacyJSBSimReader::addInputModel(const std::string& name,
                                   const std::string& propName, real_type gain)
 {
@@ -521,6 +688,51 @@
   }
 }
 
+Port*
+LegacyJSBSimReader::addMultiBodyToUnit(const std::string& name, Unit u,
+                                       Port* in)
+{
+  if (!in)
+    return 0;
+  UnitConversionModel* unitConv
+    = new UnitConversionModel(name, UnitConversionModel::SiToUnit, u);
+  addMultiBodyModel(unitConv);
+  unitConv->getInputPort(0)->connect(in);
+  return unitConv->getOutputPort(0);
+}
+
+Port*
+LegacyJSBSimReader::addMultiBodyFromUnit(const std::string& name, Unit u,
+                                         Port* in)
+{
+  if (!in)
+    return 0;
+  UnitConversionModel* unitConv
+    = new UnitConversionModel(name, UnitConversionModel::UnitToSi, u);
+  addMultiBodyModel(unitConv);
+  unitConv->getInputPort(0)->connect(in);
+  return unitConv->getOutputPort(0);
+}
+
+Port*
+LegacyJSBSimReader::addMultiBodyAbsModel(const std::string& name, Port* in)
+{
+  UnaryFunctionModel *unary
+    = new UnaryFunctionModel(name + " Abs", UnaryFunctionModel::Abs);
+  unary->getInputPort(0)->connect(in);
+  addMultiBodyModel(unary);
+  return unary->getOutputPort(0);
+}
+
+void
+LegacyJSBSimReader::addMultiBodyModel(Model* model)
+{
+  // FIXME
+  while (mVehicle->getMultiBodySystem()->addModel(model) == ~0u) {
+    model->setName(model->getName() + "x");
+  }
+}
+
 bool
 LegacyJSBSimReader::convertDocument(const XMLDocument* jsbDoc)
 {
@@ -1882,44 +2094,40 @@
   for (it = elems.begin(); it != elems.end(); ++it) {
     std::string axisname = (*it)->getAttribute("NAME");
 
-    SharedPtr<UnitToSiExpressionImpl> toNewton
-      = new UnitToSiExpressionImpl(uPoundForce);
-    SharedPtr<UnitToSiExpressionImpl> toNewtonMeter
-      = new UnitToSiExpressionImpl(uPoundForceFt);
-    SharedPtr<SumExpressionImpl> sum = new SumExpressionImpl;
-    toNewtonMeter->setInputProperty(TypedProperty<real_type>(sum));
-    toNewton->setInputProperty(TypedProperty<real_type>(sum));
+    SharedPtr<Summer> sum = new Summer(axisname + " Sum");
+    sum->setNumSummands(0);
+
+    // Now parse the summands
+    if (!convertAEROSummands(*it, sum, 0))
+      return error("Cannot convert aerodynamic summands for axis \"" + 
+                   axisname  + "\"");
+    if (!sum->getNumSummands())
+      continue;
+    addMultiBodyModel(sum);
+    Port* port = sum->getOutputPort(0);
+
     if (axisname == "LIFT") {
-      SharedPtr<MinusExpressionImpl> minus = new MinusExpressionImpl;
-      minus->setInputProperty(TypedProperty<real_type>(toNewton));
-      mAeroForce->addStabilityAxisSummand(AeroForce::LiftAxis,
-                                          TypedProperty<real_type>(minus));
+      port = addMultiBodyFromUnit("LIFT unit converter", uPoundForce, port);
+      mAeroForce->getInputPort("lift")->connect(port);
     }
     else if (axisname == "DRAG") {
-      SharedPtr<MinusExpressionImpl> minus = new MinusExpressionImpl;
-      minus->setInputProperty(TypedProperty<real_type>(toNewton));
-      mAeroForce->addStabilityAxisSummand(AeroForce::DragAxis,
-                                          TypedProperty<real_type>(minus));
+      port = addMultiBodyFromUnit("DRAG unit converter", uPoundForce, port);
+      mAeroForce->getInputPort("drag")->connect(port);
     }
     else if (axisname == "SIDE") {
-      mAeroForce->addBodyAxisSummand(AeroForce::SideAxis,
-                                     TypedProperty<real_type>(toNewton));
+      port = addMultiBodyFromUnit("SIDE unit converter", uPoundForce, port);
+      mAeroForce->getInputPort("side")->connect(port);
     } else if (axisname == "ROLL") {
-      mAeroForce->addBodyAxisSummand(AeroForce::RollAxis,
-                                     TypedProperty<real_type>(toNewtonMeter));
+      port = addMultiBodyFromUnit("ROLL unit converter", uPoundForceFt, port);
+      mAeroForce->getInputPort("roll")->connect(port);
     } else if (axisname == "PITCH") {
-      mAeroForce->addBodyAxisSummand(AeroForce::PitchAxis,
-                                     TypedProperty<real_type>(toNewtonMeter));
+      port = addMultiBodyFromUnit("PITCH unit converter", uPoundForceFt, port);
+      mAeroForce->getInputPort("pitch")->connect(port);
     } else if (axisname == "YAW") {
-      mAeroForce->addBodyAxisSummand(AeroForce::YawAxis,
-                                     TypedProperty<real_type>(toNewtonMeter));
+      port = addMultiBodyFromUnit("YAW unit converter", uPoundForceFt, port);
+      mAeroForce->getInputPort("yaw")->connect(port);
     } else
       return error("Unknown aerodynamic axis!");
-
-    // Now parse the summands
-    if (!convertAEROSummands(*it, sum, 0))
-      return error("Cannot convert aerodynamic summands for axis \"" + 
-                   axisname  + "\"");
   }
 
   return true;
@@ -1927,19 +2135,26 @@
 
 bool
 LegacyJSBSimReader::convertAEROSummands(const XMLElement* aeroSummands,
-                                        SumExpressionImpl* sum,
-                                        ProductExpressionImpl* prod)
+                                        Summer* sum, Product* prod)
 {
   std::list<SharedPtr<XMLElement> > elems = aeroSummands->getElements();
   std::list<SharedPtr<XMLElement> >::const_iterator it;
   for (it = elems.begin(); it != elems.end(); ++it) {
     if ((*it)->getName() == "GROUP") {
      
-      SharedPtr<ProductExpressionImpl> newProd = new ProductExpressionImpl;
-      sum->addInputProperty(TypedProperty<real_type>(newProd));
-      SharedPtr<SumExpressionImpl> newSum = new SumExpressionImpl;
-      newProd->addInputProperty(TypedProperty<real_type>(newSum));
+      SharedPtr<Product> newProd = new Product("blub FIXME Product");
+      addMultiBodyModel(newProd);
+      Port* port = newProd->getOutputPort(0);
+      unsigned ns = sum->getNumSummands();
+      sum->setNumSummands(ns+1);
+      sum->getInputPort(ns)->connect(port);
 
+      SharedPtr<Summer> newSum = new Summer("blub FIXME Summer");
+      newSum->setNumSummands(0);
+      newProd->setNumFactors(1);
+      newProd->getInputPort(0)->connect(newSum->getOutputPort(0));
+      addMultiBodyModel(newSum);
+      
       if (!convertAEROSummands(*it, newSum, newProd))
         return error("Error parsing aerodynamic tables");
     }
@@ -1948,27 +2163,27 @@
         return error("Error parsing aerodynamic tables, FACTOR without GROUP");
 
       std::string type = (*it)->getAttribute("TYPE");
-      TypedProperty<real_type> prop
-        = convertCoefficient((*it)->getData(), type);
-      prod->addInputProperty(prop);
+      Port* port = convertCoefficient((*it)->getData(), type);
+      unsigned nf = prod->getNumFactors();
+      prod->setNumFactors(nf+1);
+      prod->getInputPort(nf)->connect(port);
     }
     else if ((*it)->getName() == "COEFFICIENT") {
       std::string type = (*it)->getAttribute("TYPE");
-      TypedProperty<real_type> prop
-        = convertCoefficient((*it)->getData(), type);
-      sum->addInputProperty(prop);
+      Port* port = convertCoefficient((*it)->getData(), type);
+      unsigned ns = sum->getNumSummands();
+      sum->setNumSummands(ns+1);
+      sum->getInputPort(ns)->connect(port);
     }
   }
 
   return true;
 }
 
-TypedProperty<real_type>
+Port*
 LegacyJSBSimReader::convertCoefficient(const std::string& data,
                                        const std::string& type)
 {
-  ProductExpressionImpl* prod = new ProductExpressionImpl;
-
   unsigned ndims;
   if (type == "VALUE") {
     ndims = 0;
@@ -1981,25 +2196,29 @@
   } else {
     std::cerr << "Unknown TYPE attribute \"" << type
               << "\" for COEFFICIENT tag! Ignoring!" << std::endl;
-    return TypedProperty<real_type>(prod);
+    return 0;
   }
 
   std::stringstream datastr(data);
 
   std::string token;
-  // The fist token is some useless string.
+  // The fist token is some name string ...
   datastr >> token;
 
+  SharedPtr<Product> prod = new Product(token);
+  prod->setNumFactors(0);
+  addMultiBodyModel(prod);
+
   // The number of table entries 
   unsigned n[3] = { 0 };
   for (unsigned i = 0; i < ndims; ++i)
     datastr >> n[i];
 
   // The table lookup values.
-  Property inVal[3];
+  SharedPtr<Port> inVal[3];
   for (unsigned i = 0; i < ndims; ++i) {
     datastr >> token;
-    inVal[i] = lookupJSBExpression(token)->getProperty();
+    inVal[i] = lookupJSBExpression(token);
   }
 
   // The other factors in this product.
@@ -2014,14 +2233,22 @@
   while (linestream >> token) {
     if (token.empty() || token == "none")
       break;
-    prod->addInputProperty(lookupJSBExpression(token)->getProperty());
+    unsigned nf = prod->getNumFactors();
+    prod->setNumFactors(nf+1);
+    prod->getInputPort(nf)->connect(lookupJSBExpression(token));
   }
  
   // The lookup table values.
   if (ndims == 0) {
-    real_type value;
-    datastr >> value;
-    prod->addInputProperty(Property(new ConstExpressionPropertyImpl<real_type>(value)));
+    Matrix value(1, 1);
+    datastr >> value(1, 1);
+    ConstSystem* constModel
+      = new ConstSystem(prod->getName() + " Factor", value);
+    addMultiBodyModel(constModel);
+
+    unsigned nf = prod->getNumFactors();
+    prod->setNumFactors(nf+1);
+    prod->getInputPort(nf)->connect(constModel->getOutputPort(0));
   }
   else if (ndims == 1) {
     TableData<1>::SizeVector size;
@@ -2031,11 +2258,17 @@
     if (!parseTable1D(datastr, table, lookup))
       // FIXME
       std::cerr << "Cannot parse " + type + " table" << std::endl;
-    TableExpressionImpl<1>* ti = new TableExpressionImpl<1>();
-    ti->setTable(table);
-    ti->setTableLookup(0, lookup);
-    ti->setInputProperty(0, inVal[0]);
-    prod->addInputProperty(Property(ti));
+
+    Table1D* table1D
+      = new Table1D(prod->getName() + " Table");
+    addMultiBodyModel(table1D);
+    table1D->setTableData(table);
+    table1D->setTableLookup(lookup);
+    table1D->getInputPort(0)->connect(inVal[0]);
+
+    unsigned nf = prod->getNumFactors();
+    prod->setNumFactors(nf+1);
+    prod->getInputPort(nf)->connect(table1D->getOutputPort(0));
   }
   else if (ndims == 2) {
     TableData<2>::SizeVector size;
@@ -2046,13 +2279,19 @@
     if (!parseTable2D(datastr, table, lookup))
       // FIXME
       std::cerr << "Cannot parse " + type + " table" << data << std::endl;
-    TableExpressionImpl<2>* ti = new TableExpressionImpl<2>();
-    ti->setTable(table);
+
+    Table2D* table2D
+      = new Table2D(prod->getName() + " Table");
+    addMultiBodyModel(table2D);
+    table2D->setTableData(table);
     for (unsigned i = 0; i < 2; ++i) {
-      ti->setTableLookup(i, lookup[i]);
-      ti->setInputProperty(i, inVal[i]);
+      table2D->setTableLookup(i, lookup[i]);
+      table2D->getInputPort(i)->connect(inVal[i]);
     }
-    prod->addInputProperty(Property(ti));
+
+    unsigned nf = prod->getNumFactors();
+    prod->setNumFactors(nf+1);
+    prod->getInputPort(nf)->connect(table2D->getOutputPort(0));
   }
   else if (ndims == 3) {
     TableData<3>::SizeVector size;
@@ -2064,254 +2303,22 @@
     if (!parseTable3D(datastr, table, lookup))
       // FIXME
       std::cerr << "Cannot parse " + type + " table" << std::endl;
-    TableExpressionImpl<3>* ti = new TableExpressionImpl<3>();
-    ti->setTable(table);
+
+    Table3D* table3D
+      = new Table3D(prod->getName() + " Table");
+    addMultiBodyModel(table3D);
+    table3D->setTableData(table);
     for (unsigned i = 0; i < 3; ++i) {
-      ti->setTableLookup(i, lookup[i]);
-      ti->setInputProperty(i, inVal[i]);
+      table3D->setTableLookup(i, lookup[i]);
+      table3D->getInputPort(i)->connect(inVal[i]);
     }
-    prod->addInputProperty(Property(ti));
+
+    unsigned nf = prod->getNumFactors();
+    prod->setNumFactors(nf+1);
+    prod->getInputPort(nf)->connect(table3D->getOutputPort(0));
   }
 
-  return TypedProperty<real_type>(prod);
+  return prod->getOutputPort(0);
 }
 
-void
-LegacyJSBSimReader::makeAeroprops(void)
-{
-  Property e = mAeroForce->getProperty("trueSpeed");
-  Port* port = new Port;
-  port->setProperty(e);
-  registerJSBExpression("velocities/vt-mps", port);
-  SiToUnitExpressionImpl* c = new SiToUnitExpressionImpl(uFeetPSecond);
-  c->setInputProperty(e);
-  port = new Port;
-  port->setProperty(Property(c));
-  registerJSBExpression("velocities/vt-fps", port);
-  c = new SiToUnitExpressionImpl(uKnots);
-  c->setInputProperty(e);
-  port = new Port;
-  port->setProperty(Property(c));
-  registerJSBExpression("velocities/vt-kts", port);
-
-  // Mach numbers, are unitless.
-  e = mAeroForce->getProperty("machNumber");
-  port = new Port;
-  port->setProperty(e);
-  registerJSBExpression("velocities/mach-norm", port);
-  registerJSBExpression("velocities/mach", port);
-
-  // Rotational rates wrt air.
-  e = mAeroForce->getProperty("p");
-  port = new Port;
-  port->setProperty(e);
-  registerJSBExpression("velocities/p-rad_sec", port);
-  port = new Port;
-  port->setProperty(e);
-  registerJSBExpression("velocities/p-aero-rad_sec", port);
-  c = new SiToUnitExpressionImpl(uDegree);
-  c->setInputProperty(e);
-  port = new Port;
-  port->setProperty(Property(c));
-  registerJSBExpression("velocities/p-aero-deg_sec", port);
-  e = mAeroForce->getProperty("q");
-  port = new Port;
-  port->setProperty(e);
-  registerJSBExpression("velocities/q-rad_sec", port);
-  port = new Port;
-  port->setProperty(e);
-  registerJSBExpression("velocities/q-aero-rad_sec", port);
-  c = new SiToUnitExpressionImpl(uDegree);
-  c->setInputProperty(e);
-  port = new Port;
-  port->setProperty(Property(c));
-  registerJSBExpression("velocities/q-aero-deg_sec", port);
-  e = mAeroForce->getProperty("r");
-  port = new Port;
-  port->setProperty(e);
-  registerJSBExpression("velocities/r-rad_sec", port);
-  port = new Port;
-  port->setProperty(e);
-  registerJSBExpression("velocities/r-aero-rad_sec", port);
-  c = new SiToUnitExpressionImpl(uDegree);
-  c->setInputProperty(e);
-  port = new Port;
-  port->setProperty(Property(c));
-  registerJSBExpression("velocities/r-aero-deg_sec", port);
-
-
-  e = mAeroForce->getProperty("u");
-  port = new Port;
-  port->setProperty(e);
-  registerJSBExpression("velocities/u-aero-mps", port);
-  c = new SiToUnitExpressionImpl(uFeetPSecond);
-  c->setInputProperty(e);
-  port = new Port;
-  port->setProperty(Property(c));
-  registerJSBExpression("velocities/u-aero-fps", port);
-  e = mAeroForce->getProperty("v");
-  port = new Port;
-  port->setProperty(e);
-  registerJSBExpression("velocities/v-aero-mps", port);
-  c = new SiToUnitExpressionImpl(uFeetPSecond);
-  c->setInputProperty(e);
-  port = new Port;
-  port->setProperty(Property(c));
-  registerJSBExpression("velocities/v-aero-fps", port);
-  e = mAeroForce->getProperty("w");
-  port = new Port;
-  port->setProperty(e);
-  registerJSBExpression("velocities/w-aero-mps", port);
-  c = new SiToUnitExpressionImpl(uFeetPSecond);
-  c->setInputProperty(e);
-  port = new Port;
-  port->setProperty(Property(c));
-  registerJSBExpression("velocities/w-aero-fps", port);
-
-
-  // Dynamic pressure values.
-  e = mAeroForce->getProperty("dynamicPressure");
-  port = new Port;
-  port->setProperty(e);
-  registerJSBExpression("aero/qbar-pa", port);
-  c = new SiToUnitExpressionImpl(uPoundPFt2);
-  c->setInputProperty(e);
-  port = new Port;
-  port->setProperty(Property(c));
-  registerJSBExpression("aero/qbar-psf", port);
-
-  // Temperature.
-  e = mAeroForce->getProperty("temperature");
-  c = new SiToUnitExpressionImpl(uRankine);
-  c->setInputProperty(e);
-  port = new Port;
-  port->setProperty(Property(c));
-  registerJSBExpression("velocities/tat-r", port);
-  c = new SiToUnitExpressionImpl(uFahrenheit);
-  c->setInputProperty(e);
-  port = new Port;
-  port->setProperty(Property(c));
-  registerJSBExpression("velocities/tat-f", port);
-
-  // Braindead: a pressure value in velocities ...
-  e = mAeroForce->getProperty("pressure");
-  port = new Port;
-  port->setProperty(e);
-  registerJSBExpression("velocities/pt-pascal", port);
-  c = new SiToUnitExpressionImpl(uPoundPFt2);
-  c->setInputProperty(e);
-  port = new Port;
-  port->setProperty(Property(c));
-  registerJSBExpression("velocities/pt-lbs_sqft", port);
-
-
-
-  e = mAeroForce->getProperty("wingSpan");
-  c = new SiToUnitExpressionImpl(uFoot);
-  c->setInputProperty(e);
-  port = new Port;
-  port->setProperty(Property(c));
-  registerJSBExpression("metrics/bw-ft", port);
-
-  e = mAeroForce->getProperty("wingArea");
-  c = new SiToUnitExpressionImpl(uFoot2);
-  c->setInputProperty(e);
-  port = new Port;
-  port->setProperty(Property(c));
-  registerJSBExpression("metrics/Sw-sqft", port);
-
-  e = mAeroForce->getProperty("coord");
-  c = new SiToUnitExpressionImpl(uFoot);
-  c->setInputProperty(e);
-  port = new Port;
-  port->setProperty(Property(c));
-  registerJSBExpression("metrics/cbarw-ft", port);
-
-  e = mAeroForce->getProperty("wingSpanOver2Speed");
-  port = new Port;
-  port->setProperty(e);
-  registerJSBExpression("aero/bi2vel", port);
-  e = mAeroForce->getProperty("coordOver2Speed");
-  port = new Port;
-  port->setProperty(e);
-  registerJSBExpression("aero/ci2vel", port);
-
-  // Angle of attack.
-  e = mAeroForce->getProperty("alpha");
-  port = new Port;
-  port->setProperty(e);
-  registerJSBExpression("aero/alpha-rad", port);
-  AbsExpressionImpl* a = new AbsExpressionImpl();
-  a->setInputProperty(e);
-  port = new Port;
-  port->setProperty(Property(a));
-  registerJSBExpression("aero/mag-alpha-rad", port);
-  c = new SiToUnitExpressionImpl(uDegree);
-  c->setInputProperty(e);
-  port = new Port;
-  port->setProperty(Property(c));
-  registerJSBExpression("aero/alpha-deg", port);
-  a = new AbsExpressionImpl();
-  a->setInputProperty(Property(c));
-  port = new Port;
-  port->setProperty(Property(a));
-  registerJSBExpression("aero/mag-alpha-deg", port);
-
-  // Angle of sideslip.
-  e = mAeroForce->getProperty("beta");
-  port = new Port;
-  port->setProperty(e);
-  registerJSBExpression("aero/beta-rad", port);
-  a = new AbsExpressionImpl();
-  a->setInputProperty(e);
-  port = new Port;
-  port->setProperty(Property(a));
-  registerJSBExpression("aero/mag-beta-rad", port);
-  c = new SiToUnitExpressionImpl(uDegree);
-  c->setInputProperty(e);
-  port = new Port;
-  port->setProperty(Property(c));
-  registerJSBExpression("aero/beta-deg", port);
-  a = new AbsExpressionImpl();
-  a->setInputProperty(Property(c));
-  port = new Port;
-  port->setProperty(Property(a));
-  registerJSBExpression("aero/mag-beta-deg", port);
-
-
-  // Time derivative of alpha.
-  e = mAeroForce->getProperty("alphaDot");
-  port = new Port;
-  port->setProperty(e);
-  registerJSBExpression("aero/alphadot-rad_sec", port);
-  c = new SiToUnitExpressionImpl(uDegree);
-  c->setInputProperty(e);
-  port = new Port;
-  port->setProperty(Property(c));
-  registerJSBExpression("aero/alphadot-deg", port);
-
-  // Time derivative of beta.
-  e = mAeroForce->getProperty("betaDot");
-  port = new Port;
-  port->setProperty(e);
-  registerJSBExpression("aero/betadot-rad_sec", port);
-  c = new SiToUnitExpressionImpl(uDegree);
-  c->setInputProperty(e);
-  port = new Port;
-  port->setProperty(Property(c));
-  registerJSBExpression("aero/betadot-deg", port);
-
-  // The quotient agl/wingspan
-  e = mAeroForce->getProperty("hOverWingSpan");
-  c = new SiToUnitExpressionImpl(uFoot);
-  c->setInputProperty(e);
-  port = new Port;
-  port->setProperty(Property(c));
-  registerJSBExpression("aero/h_b-cg-ft", port);
-  port = new Port;
-  port->setProperty(Property(c));
-  registerJSBExpression("aero/h_b-mac-ft", port);
-}
-
-
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.h
===================================================================
--- trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.h	2006-01-02 09:18:40 UTC (rev 152)
+++ trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.h	2006-01-02 12:25:24 UTC (rev 153)
@@ -20,6 +20,9 @@
 class XMLDocument;
 class XMLElement;
 
+class Summer;
+class Product;
+
 // Implements a SimGear SGProperty compatible 'path' to 'expression'
 // mapping.
 // It is used to map the value names occuring in JSBSim configuration files
@@ -148,6 +151,7 @@
   void registerExpression(const std::string& name, Port* expr);
   void registerJSBExpression(const std::string& name, Port* expr);
 
+  Port* createAndScheduleAeroProp(const std::string& name);
   Port* createAndScheduleInput(const std::string& name);
 
   Port* addInputModel(const std::string& name, const std::string& propName,
@@ -160,6 +164,11 @@
   Port* addConstModel(const std::string& name, real_type value);
 
   void addFCSModel(Model* model);
+
+  Port* addMultiBodyToUnit(const std::string& name, Unit u, Port* in);
+  Port* addMultiBodyFromUnit(const std::string& name, Unit u, Port* in);
+  Port* addMultiBodyAbsModel(const std::string& name, Port* in);
+  void addMultiBodyModel(Model* model);
   /// </FIXME> document and rethink
 
 
@@ -195,12 +204,9 @@
   bool convertAerodynamics(const XMLElement* aerodynamics);
   /// converts recursively AERODYNAMICS summands, factors and grooups
   bool convertAEROSummands(const XMLElement* aeroSummands,
-                           SumExpressionImpl* sum,
-                           ProductExpressionImpl* prod);
+                           Summer* sum, Product* prod);
 
-  TypedProperty<real_type> convertCoefficient(const std::string& data,
-                                              const std::string& type);
-  void makeAeroprops(void);
+  Port* convertCoefficient(const std::string& data, const std::string& type);
 
 
 

Modified: trunk/OpenFDM/src/OpenFDM/AeroForce.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/AeroForce.cpp	2006-01-02 09:18:40 UTC (rev 152)
+++ trunk/OpenFDM/src/OpenFDM/AeroForce.cpp	2006-01-02 12:25:24 UTC (rev 153)
@@ -7,7 +7,6 @@
 #include "Vector.h"
 #include "Frame.h"
 #include "Force.h"
-#include "Expression.h"
 #include "Atmosphere.h"
 #include "AeroForce.h"
 
@@ -16,12 +15,6 @@
 AeroForce::AeroForce(const std::string& name)
   : ExternalForce(name)
 {
-  // Initialize all the expression nodes we will need.
-  for (unsigned i = 0; i < 6; ++i) {
-    mStabilityAxisSummers[i] = new SumExpressionImpl;
-    mBodyAxisSummers[i] = new SumExpressionImpl;
-  }
-
   setPosition(Vector3::zeros());
   setOrientation(Quaternion::unit());
 
@@ -93,6 +86,46 @@
               Property(this, &AeroForce::getBodyQ));
   addProperty("r",
               Property(this, &AeroForce::getBodyR));
+
+  addOutputPort("wingSpan", this, &AeroForce::getWingSpan);
+  addOutputPort("wingArea", this, &AeroForce::getWingArea);
+  addOutputPort("coord", this, &AeroForce::getCoord);
+
+  addOutputPort("altitude", this, &AeroForce::getAltitude);
+  addOutputPort("aboveGroundLevel", this, &AeroForce::getAboveGroundLevel);
+
+  addOutputPort("trueSpeed", this, &AeroForce::getTrueSpeed);
+  addOutputPort("dynamicPressure", this, &AeroForce::getDynamicPressure);
+  addOutputPort("alpha", this, &AeroForce::getAlpha);
+  addOutputPort("alphaDot", this, &AeroForce::getAlphaDot);
+  addOutputPort("beta", this, &AeroForce::getBeta);
+  addOutputPort("betaDot", this, &AeroForce::getBetaDot);
+//   addOutputPort("mach", this, &AeroForce::getMach);
+  addOutputPort("machNumber", this, &AeroForce::getMachNumber);
+  addOutputPort("trueSpeedUW", this, &AeroForce::getTrueSpeedUW);
+  addOutputPort("wingSpanOver2Speed", this, &AeroForce::getWingSpanOver2Speed);
+  addOutputPort("coordOver2Speed", this, &AeroForce::getCoordOver2Speed);
+  addOutputPort("hOverWingSpan", this, &AeroForce::getHOverWingSpan);
+
+  addOutputPort("pressure", this, &AeroForce::getPressure);
+  addOutputPort("density", this, &AeroForce::getDensity);
+  addOutputPort("soundSpeed", this, &AeroForce::getSoundSpeed);
+  addOutputPort("temperature", this, &AeroForce::getTemperature);
+
+  addOutputPort("u", this, &AeroForce::getBodyU);
+  addOutputPort("v", this, &AeroForce::getBodyV);
+  addOutputPort("w", this, &AeroForce::getBodyW);
+  addOutputPort("p", this, &AeroForce::getBodyP);
+  addOutputPort("q", this, &AeroForce::getBodyQ);
+  addOutputPort("r", this, &AeroForce::getBodyR);
+
+  setNumInputPorts(6);
+  setInputPortName(0, "roll");
+  setInputPortName(1, "pitch");
+  setInputPortName(2, "yaw");
+  setInputPortName(3, "drag");
+  setInputPortName(4, "side");
+  setInputPortName(5, "lift");
 }
 
 AeroForce::~AeroForce(void)
@@ -105,6 +138,33 @@
   mEnvironment = getEnvironment();
   if (!mEnvironment)
     return false;
+
+  if (getInputPort("roll")->isConnected())
+    mBodyAxisTorque[0] = getInputPort("roll")->toRealPortHandle();
+  else
+    mBodyAxisTorque[0] = 0;
+  if (getInputPort("pitch")->isConnected())
+    mBodyAxisTorque[1] = getInputPort("pitch")->toRealPortHandle();
+  else
+    mBodyAxisTorque[1] = 0;
+  if (getInputPort("yaw")->isConnected())
+    mBodyAxisTorque[2] = getInputPort("yaw")->toRealPortHandle();
+  else
+    mBodyAxisTorque[2] = 0;
+
+  if (getInputPort("drag")->isConnected())
+    mStabilityAxisForce[0] = getInputPort("drag")->toRealPortHandle();
+  else
+    mStabilityAxisForce[0] = 0;
+  if (getInputPort("side")->isConnected())
+    mStabilityAxisForce[1] = getInputPort("side")->toRealPortHandle();
+  else
+    mStabilityAxisForce[1] = 0;
+  if (getInputPort("lift")->isConnected())
+    mStabilityAxisForce[2] = getInputPort("lift")->toRealPortHandle();
+  else
+    mStabilityAxisForce[2] = 0;
+
   return ExternalForce::init();
 }
 
@@ -609,14 +669,22 @@
 
   // This is simple here. Just collect all summands ...
   Vector6 force = Vector6::zeros();
-  for (int i = 0; i < 6; ++i)
-    force(i+1) = mStabilityAxisSummers[i]->getValue();
+  /// Lift points upward
+  /// Drag points backward
+  /// FIXME: may be we can put that already into the rotation matrix?
+  if (mStabilityAxisForce[0].isConnected())
+    force(4) -= mStabilityAxisForce[0].getRealValue();
+  if (mStabilityAxisForce[1].isConnected())
+    force(5) += mStabilityAxisForce[1].getRealValue();
+  if (mStabilityAxisForce[2].isConnected())
+    force(6) -= mStabilityAxisForce[2].getRealValue();
 
   force.setAngular(Ts2b*force.getAngular());
   force.setLinear(Ts2b*force.getLinear());
 
-  for (int i = 0; i < 6; ++i)
-    force(i+1) += mBodyAxisSummers[i]->getValue();
+  for (int i = 0; i < 3; ++i)
+    if (mBodyAxisTorque[i].isConnected())
+      force(i+1) += mBodyAxisTorque[i].getRealValue();
 
   Log(ArtBody, Debug3) << "AeroForce::computeForce() "
                        << trans(force) << endl;

Modified: trunk/OpenFDM/src/OpenFDM/AeroForce.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/AeroForce.h	2006-01-02 09:18:40 UTC (rev 152)
+++ trunk/OpenFDM/src/OpenFDM/AeroForce.h	2006-01-02 12:25:24 UTC (rev 153)
@@ -14,7 +14,6 @@
 #include "Ground.h"
 #include "Wind.h"
 #include "Planet.h"
-#include "Expression.h"
 #include "Environment.h"
 
 namespace OpenFDM {
@@ -98,23 +97,6 @@
   const Vector3& getUnitDown(void) const;
   const Plane& getLocalGroundPlane(void) const;
 
-  void addStabilityAxisSummand(ForceAxis axis, const RealProperty& prop)
-  {
-    mStabilityAxisSummers[axis-1]->addInputProperty(prop);
-  }
-  void addStabilityAxisSummand(ForceAxis axis, const Property& prop)
-  {
-    mStabilityAxisSummers[axis-1]->addInputProperty(prop);
-  }
-  void addBodyAxisSummand(ForceAxis axis, const RealProperty& prop)
-  {
-    mBodyAxisSummers[axis-1]->addInputProperty(prop);
-  }
-  void addBodyAxisSummand(ForceAxis axis, const Property& prop)
-  {
-    mBodyAxisSummers[axis-1]->addInputProperty(prop);
-  }
-
   // The interface to the mechanical system.
   virtual void computeForce(void);
 
@@ -124,8 +106,8 @@
   void computeSLAtmosphere(void) const;
   void computeCalEquAirspeed(void) const;
 
-  SharedPtr<SumExpressionImpl> mStabilityAxisSummers[6];
-  SharedPtr<SumExpressionImpl> mBodyAxisSummers[6];
+  RealPortHandle mStabilityAxisForce[3];
+  RealPortHandle mBodyAxisTorque[3];
 
   const Atmosphere* getAtmosphere(void) const
   { return mEnvironment->getAtmosphere(); }



From frohlich at berlios.de  Mon Jan  2 13:26:13 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Mon, 2 Jan 2006 13:26:13 +0100
Subject: [OpenFDM-svn] r154 - trunk/flightgear
Message-ID: <200601021226.k02CQDfb006607@sheep.berlios.de>

Author: frohlich
Date: 2006-01-02 13:26:10 +0100 (Mon, 02 Jan 2006)
New Revision: 154

Modified:
   trunk/flightgear/FGOpenFDM.cpp
Log:
An additional property name preparation


Modified: trunk/flightgear/FGOpenFDM.cpp
===================================================================
--- trunk/flightgear/FGOpenFDM.cpp	2006-01-02 12:25:24 UTC (rev 153)
+++ trunk/flightgear/FGOpenFDM.cpp	2006-01-02 12:26:10 UTC (rev 154)
@@ -491,6 +491,12 @@
   while ((pos = pName.find('>')) != std::string::npos) {
     pName.replace(pos, 1, 1, ']');
   }
+  while ((pos = pName.find('(')) != std::string::npos) {
+    pName.replace(pos, 1, 1, '_');
+  }
+  while ((pos = pName.find(')')) != std::string::npos) {
+    pName.replace(pos, 1, 1, '_');
+  }
   return pName;
 }
 



From frohlich at berlios.de  Mon Jan  2 13:33:47 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Mon, 2 Jan 2006 13:33:47 +0100
Subject: [OpenFDM-svn] r155 - in trunk/OpenFDM/src: JSBSim OpenFDM
Message-ID: <200601021233.k02CXluB010084@sheep.berlios.de>

Author: frohlich
Date: 2006-01-02 13:33:33 +0100 (Mon, 02 Jan 2006)
New Revision: 155

Removed:
   trunk/OpenFDM/src/OpenFDM/Expression.cpp
   trunk/OpenFDM/src/OpenFDM/Expression.h
Modified:
   trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.h
   trunk/OpenFDM/src/OpenFDM/Makefile.am
   trunk/OpenFDM/src/OpenFDM/Port.h
   trunk/OpenFDM/src/OpenFDM/main.cpp
Log:
Remove now obsolete Expression/Port adapters.


Modified: trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.h
===================================================================
--- trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.h	2006-01-02 12:26:10 UTC (rev 154)
+++ trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.h	2006-01-02 12:33:33 UTC (rev 155)
@@ -11,7 +11,6 @@
 #include <iosfwd>
 
 #include <OpenFDM/AeroForce.h>
-#include <OpenFDM/Expression.h>
 #include <OpenFDM/Vehicle.h>
 #include <OpenFDM/ReaderWriter.h>
 

Deleted: trunk/OpenFDM/src/OpenFDM/Expression.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Expression.cpp	2006-01-02 12:26:10 UTC (rev 154)
+++ trunk/OpenFDM/src/OpenFDM/Expression.cpp	2006-01-02 12:33:33 UTC (rev 155)
@@ -1,14 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
- *
- */
-
-#include "Assert.h"
-#include "Types.h"
-#include "Math.h"
-#include "Units.h"
-#include "Object.h"
-#include "Expression.h"
-
-namespace OpenFDM {
-
-} // namespace OpenFDM

Deleted: trunk/OpenFDM/src/OpenFDM/Expression.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Expression.h	2006-01-02 12:26:10 UTC (rev 154)
+++ trunk/OpenFDM/src/OpenFDM/Expression.h	2006-01-02 12:33:33 UTC (rev 155)
@@ -1,256 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
- *
- */
-
-#ifndef OpenFDM_Expression_H
-#define OpenFDM_Expression_H
-
-#include <list>
-#include <vector>
-#include <map>
-
-#include "Assert.h"
-#include "LogStream.h"
-#include "Types.h"
-#include "Units.h"
-#include "Object.h"
-#include "Property.h"
-#include "Table.h"
-
-namespace OpenFDM {
-
-template<typename T>
-class ConstExpressionPropertyImpl : public PropertyImpl<T> {
-public:
-  ConstExpressionPropertyImpl(const T& value) : mValue(value) {}
-  virtual void setValue(const T& value) { mValue = value; }
-  virtual const Object* getObject(void) const { return 0; }
-  virtual Object* getObject(void) { return 0; }
-  virtual bool isValid(void) const { return true; }
-  virtual T getValue(void) const { return mValue; }
-private:
-  T mValue;
-};
-
-class RealCastExpressionPropertyImpl : public PropertyImpl<real_type> {
-public:
-  RealCastExpressionPropertyImpl(const Property& prop) : mProperty(prop) {}
-  virtual void setValue(const real_type& value) { mProperty.setValue(value); }
-  virtual const Object* getObject(void) const { return 0; }
-  virtual Object* getObject(void) { return 0; }
-  virtual bool isValid(void) const { return mProperty.isValid(); }
-  virtual real_type getValue(void) const { return mProperty.getValue().toReal(); }
-private:
-  mutable Property mProperty;
-};
-
-template<typename T>
-class ExpressionPropertyImpl : public PropertyImpl<T> {
-public:
-  virtual void setValue(const T&) { }
-  virtual const Object* getObject(void) const { return 0; }
-  virtual Object* getObject(void) { return 0; }
-};
-
-template<typename T>
-class UnaryExpressionImpl :
-    public ExpressionPropertyImpl<T> {
-public:
-  UnaryExpressionImpl(void) {}
-  virtual ~UnaryExpressionImpl(void) {}
-
-  virtual bool isValid(void) const { return mInput.isValid(); }
-
-  void setInputProperty(const Property& prop)
-  {
-    Property tmpHack(prop);
-    TypedProperty<T> tProp = tmpHack.toTypedProperty<T>();
-    if (tProp.isValid())
-      setInputProperty(tProp);
-    else {
-      Property prop2(new RealCastExpressionPropertyImpl(tmpHack));
-      setInputProperty(prop2.toTypedProperty<T>());
-    }
-  }
-  void setInputProperty(const TypedProperty<T>& prop)
-  { mInput = prop; }
-
-protected:
-  mutable TypedProperty<T> mInput;
-};
-
-/// Implementations of various similar functions.
-class AbsExpressionImpl :
-    public UnaryExpressionImpl<real_type> {
-private:
-  virtual real_type getValue(void) const
-  { return fabs(mInput.getValue()); }
-};
-
-class MinusExpressionImpl :
-    public UnaryExpressionImpl<real_type> {
-private:
-  virtual real_type getValue(void) const
-  { return -mInput.getValue(); }
-};
-
-class UnitToSiExpressionImpl :
-    public UnaryExpressionImpl<real_type> {
-public:
-  UnitToSiExpressionImpl(Unit unit) : mUnit(unit) {}
-private:
-  virtual real_type getValue(void) const
-  { return convertFrom(mUnit, mInput.getValue()); }
-  Unit mUnit;
-};
-
-class SiToUnitExpressionImpl :
-    public UnaryExpressionImpl<real_type> {
-public:
-  SiToUnitExpressionImpl(Unit unit) : mUnit(unit) {}
-private:
-  virtual real_type getValue(void) const
-  { return convertTo(mUnit, mInput.getValue()); }
-  Unit mUnit;
-};
-
-template<typename T>
-class MultiExpressionImpl :
-    public ExpressionPropertyImpl<T> {
-public:
-  MultiExpressionImpl(void) {}
-  virtual ~MultiExpressionImpl(void) {}
-
-  virtual bool isValid(void) const
-  {
-    for (unsigned i = 0; i < mInputs.size(); ++i)
-      if (!mInputs[i].isValid())
-        return false;
-    return true;
-  }
-  
-  void setNumInputs(unsigned numInputs)
-  { mInputs.resize(numInputs); }
-  unsigned getNumInputs(void) const
-  { return mInputs.size(); }
-
-  void setInputProperty(unsigned idx, const Property& prop)
-  {
-    Property tmpHack(prop);
-    TypedProperty<T> tProp = tmpHack.toTypedProperty<T>();
-    if (tProp.isValid())
-      setInputProperty(idx, tProp);
-    else {
-      Property prop2(new RealCastExpressionPropertyImpl(tmpHack));
-      setInputProperty(idx, prop2.toTypedProperty<T>());
-    }
-  }
-  void setInputProperty(unsigned idx, const TypedProperty<T>& prop)
-  { mInputs[idx%mInputs.size()] = prop; }
-
-  void addInputProperty(const Property& prop)
-  {
-    Property tmpHack(prop);
-    TypedProperty<T> tProp = tmpHack.toTypedProperty<T>();
-    if (tProp.isValid())
-      addInputProperty(tProp);
-    else {
-      Property prop2(new RealCastExpressionPropertyImpl(tmpHack));
-      addInputProperty(prop2.toTypedProperty<T>());
-    }
-  }
-  void addInputProperty(const TypedProperty<T>& prop)
-  { mInputs.push_back(prop); }
-
-protected:
-  mutable std::vector<TypedProperty<T> > mInputs;
-};
-
-class SumExpressionImpl :
-    public MultiExpressionImpl<real_type> {
-public:
-  virtual real_type getValue(void) const
-  {
-    real_type sum = 0;
-    for (unsigned i = 0; i < mInputs.size(); ++i)
-      sum += mInputs[i].getValue();
-    return sum;
-  }
-};
-
-class ProductExpressionImpl :
-    public MultiExpressionImpl<real_type> {
-public:
-  virtual real_type getValue(void) const
-  {
-    real_type prod = 1;
-    for (unsigned i = 0; i < mInputs.size(); ++i)
-      prod *= mInputs[i].getValue();
-    return prod;
-  }
-};
-
-template<unsigned numDims>
-class TableExpressionImpl :
-    public ExpressionPropertyImpl<real_type> {
-public:
-  TableExpressionImpl(void) {}
-  virtual ~TableExpressionImpl(void) {}
-
-  void setTable(const TableData<numDims>& table)
-  { mTableData = table; }
-
-  const TableData<numDims>& getTable(void) const 
-  { return mTableData; }
-  TableData<numDims>& getTable(void)
-  { return mTableData; }
-
-  virtual bool isValid(void) const
-  {
-    for (unsigned i = 0; i < numDims; ++i)
-      if (!mInputs[i].isValid())
-        return false;
-    return true;
-  }
-
-  void setInputProperty(unsigned idx, const Property& prop)
-  {
-    Property tmpHack(prop);
-    TypedProperty<real_type> tProp = tmpHack.toTypedProperty<real_type>();
-    if (tProp.isValid())
-      setInputProperty(idx, tProp);
-    else {
-      Property prop2(new RealCastExpressionPropertyImpl(tmpHack));
-      setInputProperty(idx, prop2.toTypedProperty<real_type>());
-    }
-  }
-  void setInputProperty(unsigned idx, const TypedProperty<real_type>& prop)
-  { mInputs[idx%numDims] = prop; }
-
-  void setTableLookup(unsigned idx, const TableLookup& tl)
-  {
-    OpenFDMAssert(idx < numDims);
-    typename TableData<numDims>::SizeVector sz = mTableData.size();
-    OpenFDMAssert(sz(idx+1) == tl.size());
-    mTableLookups[idx] = tl;
-  }
-
-  virtual real_type getValue(void) const
-  {
-    typename TableData<numDims>::InterpVector interpVec;
-    for (unsigned i = 0; i < numDims; ++i) {
-      real_type iv = mInputs[i].getValue();
-      interpVec(i+1) = mTableLookups[i].lookup(iv);
-    }
-    return mTableData.interpolate(interpVec);
-  }
-
-protected:
-  mutable TypedProperty<real_type> mInputs[numDims]; /*FIXME*/
-  TableLookup mTableLookups[numDims];
-  TableData<numDims> mTableData;
-};
-
-} // namespace OpenFDM
-
-#endif

Modified: trunk/OpenFDM/src/OpenFDM/Makefile.am
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Makefile.am	2006-01-02 12:26:10 UTC (rev 154)
+++ trunk/OpenFDM/src/OpenFDM/Makefile.am	2006-01-02 12:33:33 UTC (rev 155)
@@ -50,7 +50,6 @@
   EnvironmentObject.h \
   ExplicitAdams.h \
   ExplicitEuler.h \
-  Expression.h \
   Force.h \
   Frame.h \
   MobileRootJoint.h \
@@ -157,7 +156,6 @@
   EnvironmentObject.cpp \
   ExplicitAdams.cpp \
   ExplicitEuler.cpp \
-  Expression.cpp \
   Force.cpp \
   Frame.cpp \
   MobileRootJoint.cpp \

Modified: trunk/OpenFDM/src/OpenFDM/Port.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Port.h	2006-01-02 12:26:10 UTC (rev 154)
+++ trunk/OpenFDM/src/OpenFDM/Port.h	2006-01-02 12:33:33 UTC (rev 155)
@@ -11,7 +11,6 @@
 
 #include "LogStream.h"
 #include "Object.h"
-#include "Property.h"
 #include "Variant.h"
 
 namespace OpenFDM {
@@ -55,28 +54,6 @@
 };
 
 
-/// FIXME adapter to be somehow backwards compatible
-/// Should vanish
-class PropertyPortInterface : public MatrixPortInterface {
-public:
-  PropertyPortInterface(const Property& property) : mProperty(property)
-  { }
-  virtual void evaluate(void)
-  {
-    if (mProperty.isRealProperty()) {
-      RealProperty rp = mProperty.toRealProperty();
-      mValue.resize(1, 1);
-      mValue(1, 1) = rp.getValue();
-    } else if (mProperty.isMatrixProperty()) {
-      MatrixProperty mp = mProperty.toMatrixProperty();
-      mValue = mp.getValue();
-    }
-  }
-  virtual bool isConnected(void) const
-  { return mProperty.isValid(); }
-private:
-  mutable Property mProperty;
-};
 /// Just a getter used for now
 template<typename M>
 class RealGetterPortInterface : public MatrixPortInterface {
@@ -139,23 +116,6 @@
   SharedPtr<MatrixPortInterface> mMatrixPortInterface;
 };
 
-// should vanish, just an adaptor for smoother migration
-class RealPortExpression : public PropertyImpl<real_type> {
-public:
-  RealPortExpression(const RealPortHandle& rph) :
-    mRealPortHandle(rph)
-  { }
-  real_type getValue(void) const
-  { return mRealPortHandle.getRealValue(); }
-  void setValue(const real_type&)
-  {  }
-  bool isValid(void) const { return mRealPortHandle.isConnected(); }
-  const Object* getObject(void) const { return 0; }
-  Object* getObject(void) { return 0; }
-private:
-  mutable RealPortHandle mRealPortHandle;
-};
-
 /// Class for an input or output port of a Model.
 /// Ports can be connected together. This means in effect that the reader
 /// gains access to value at the source model.
@@ -166,16 +126,8 @@
 public:
   virtual ~Port(void);
 
-  /// Just use the Properties for now. In this phase it might be a good idea.
-  void setProperty(const Property& property)
-  { setPortInterface(new PropertyPortInterface(property)); }
   void setPortInterface(PortInterface* portInterface);
 
-  /// Just use the Properties for now. In this phase it might be a good idea.
-  Property getProperty(void) const
-  { return Property(new RealPortExpression(((Port*)(this))->toRealPortHandle())); }
-
-
   /// returns true if this port has a source port connected to it
   bool isConnected() const
   { return mPortInterface && mPortInterface->isConnected(); }

Modified: trunk/OpenFDM/src/OpenFDM/main.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/main.cpp	2006-01-02 12:26:10 UTC (rev 154)
+++ trunk/OpenFDM/src/OpenFDM/main.cpp	2006-01-02 12:33:33 UTC (rev 155)
@@ -16,7 +16,6 @@
 #include <OpenFDM/Matrix.h>
 #include <OpenFDM/Quaternion.h>
 #include <OpenFDM/Frame.h>
-#include <OpenFDM/Expression.h>
 #include <OpenFDM/Friction2D.h>
 #include <OpenFDM/Units.h>
 #include <OpenFDM/Planet.h>



From frohlich at berlios.de  Mon Jan  2 13:42:31 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Mon, 2 Jan 2006 13:42:31 +0100
Subject: [OpenFDM-svn] r156 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200601021242.k02CgVVt014109@sheep.berlios.de>

Author: frohlich
Date: 2006-01-02 13:42:16 +0100 (Mon, 02 Jan 2006)
New Revision: 156

Modified:
   trunk/OpenFDM/src/OpenFDM/Product.cpp
   trunk/OpenFDM/src/OpenFDM/Product.h
Log:
Make products only work on scalars. Was undefined
before anyway.


Modified: trunk/OpenFDM/src/OpenFDM/Product.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Product.cpp	2006-01-02 12:33:33 UTC (rev 155)
+++ trunk/OpenFDM/src/OpenFDM/Product.cpp	2006-01-02 12:42:16 UTC (rev 156)
@@ -24,7 +24,6 @@
   setOutputPort(0, "output", this, &Product::getProduct);
 
   addProperty("output", Property(this, &Product::getProduct));
-
   addProperty("numFactors", Property(this, &Product::getNumFactors, &Product::setNumFactors));
 }
 
@@ -35,36 +34,28 @@
 bool
 Product::init(void)
 {
-  for (unsigned i = 0; i < getNumInputPorts(); ++i)
-    OpenFDMAssert(getInputPort(i)->isConnected());
-  
-  // Make sure it is invalid if sizes do not match.
-  mProduct.resize(0, 0);
-  // Check if the sizes match.
+  mFactorPorts.resize(getNumFactors());
   for (unsigned i = 0; i < getNumInputPorts(); ++i) {
-    Matrix a = getInputPort(i)->getValue().toMatrix();
-    if (Size(1,1) != size(a))
+    if (!getInputPort(i)->isConnected()) {
+      Log(Model, Error) << "Found unconnected input Port for Product \""
+                        << getName() << "\"" << endl;
       return false;
+    }
+    mFactorPorts[i] = getInputPort(i)->toRealPortHandle();
   }
-  mProduct.resize(getInputPort(0)->getValue().toMatrix());
+
   return true;
 }
 
 void
 Product::output(const TaskInfo&)
 {
-  MatrixPortHandle mh = getInputPort(0)->toMatrixPortHandle();
-  mProduct = mh.getMatrixValue();
-  for (unsigned i = 1; i < getNumInputPorts(); ++i) {
-    RealPortHandle rh = getInputPort(i)->toRealPortHandle();
-    if (getInputPortName(i) == "*")
-      mProduct *= rh.getRealValue();
-    else
-      mProduct *= 1/rh.getRealValue();
-  }
+  mProduct = 1;
+  for (unsigned i = 0; i < getNumInputPorts(); ++i)
+    mProduct *= mFactorPorts[i].getRealValue();
 }
 
-const Matrix&
+const real_type&
 Product::getProduct(void) const
 {
   return mProduct;

Modified: trunk/OpenFDM/src/OpenFDM/Product.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Product.h	2006-01-02 12:33:33 UTC (rev 155)
+++ trunk/OpenFDM/src/OpenFDM/Product.h	2006-01-02 12:42:16 UTC (rev 156)
@@ -21,13 +21,14 @@
   virtual bool init(void);
   virtual void output(const TaskInfo&);
 
-  const Matrix& getProduct(void) const;
+  const real_type& getProduct(void) const;
 
   unsigned getNumFactors(void) const;
   void setNumFactors(const unsigned& num);
 
 private:
-  Matrix mProduct;
+  real_type mProduct;
+  std::vector<RealPortHandle> mFactorPorts;
 };
 
 } // namespace OpenFDM



From frohlich at berlios.de  Mon Jan  2 13:52:48 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Mon, 2 Jan 2006 13:52:48 +0100
Subject: [OpenFDM-svn] r157 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200601021252.k02CqmbE020917@sheep.berlios.de>

Author: frohlich
Date: 2006-01-02 13:52:37 +0100 (Mon, 02 Jan 2006)
New Revision: 157

Modified:
   trunk/OpenFDM/src/OpenFDM/Summer.cpp
   trunk/OpenFDM/src/OpenFDM/Summer.h
Log:
Overhaul the Summer a bit.


Modified: trunk/OpenFDM/src/OpenFDM/Summer.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Summer.cpp	2006-01-02 12:42:16 UTC (rev 156)
+++ trunk/OpenFDM/src/OpenFDM/Summer.cpp	2006-01-02 12:52:37 UTC (rev 157)
@@ -36,19 +36,34 @@
 bool
 Summer::init(void)
 {
-  for (unsigned i = 0; i < getNumInputPorts(); ++i)
-    OpenFDMAssert(getInputPort(i)->isConnected());
-  
   // Make sure it is invalid if sizes do not match.
   mSum.resize(0, 0);
-  // Check if the sizes match.
-  Matrix a0 = getInputPort(0)->getValue().toMatrix();
-  for (unsigned i = 1; i < getNumInputPorts(); ++i) {
+
+  mPositiveSummandPorts.clear();
+  mNegativeSummandPorts.clear();
+  for (unsigned i = 0; i < getNumInputPorts(); ++i) {
+    if (!getInputPort(i)->isConnected()) {
+      Log(Model, Error) << "Found unconnected input Port for Summer \""
+                        << getName() << "\"" << endl;
+      return false;
+    }
+    if (getInputPortName(i) == "-") {
+      mNegativeSummandPorts.push_back(getInputPort(i)->toMatrixPortHandle());
+    } else {
+      mPositiveSummandPorts.push_back(getInputPort(i)->toMatrixPortHandle());
+    }
+
     Matrix a = getInputPort(i)->getValue().toMatrix();
-    if (size(a0) != size(a))
-      return false;
+    if (i == 0) {
+      mSum.resize(a);
+    } else {
+      if (size(mSum) != size(a)) {
+        Log(Model, Error) << "Input port sizes for Summer \""
+                          << getName() << "\" do not match." << endl;
+        return false;
+      }
+    }
   }
-  mSum.resize(a0);
   return true;
 }
 
@@ -56,14 +71,17 @@
 Summer::output(const TaskInfo&)
 {
   mSum.clear();
-  for (unsigned i = 0; i < getNumInputPorts(); ++i) {
-    /// FIXME could be preevaluated
-    MatrixPortHandle ph = getInputPort(i)->toMatrixPortHandle();
-    if (getInputPortName(i) == "-")
-      mSum -= ph.getMatrixValue();
-    else
-      mSum += ph.getMatrixValue();
+
+  std::vector<MatrixPortHandle>::iterator it = mNegativeSummandPorts.begin();
+  while (it != mNegativeSummandPorts.end()) {
+    mSum -= (*it).getMatrixValue();
+    ++it;
   }
+  it = mPositiveSummandPorts.begin();
+  while (it != mPositiveSummandPorts.end()) {
+    mSum += (*it).getMatrixValue();
+    ++it;
+  }
 }
 
 const Matrix&

Modified: trunk/OpenFDM/src/OpenFDM/Summer.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Summer.h	2006-01-02 12:42:16 UTC (rev 156)
+++ trunk/OpenFDM/src/OpenFDM/Summer.h	2006-01-02 12:52:37 UTC (rev 157)
@@ -28,6 +28,8 @@
 
 private:
   Matrix mSum;
+  std::vector<MatrixPortHandle> mPositiveSummandPorts;
+  std::vector<MatrixPortHandle> mNegativeSummandPorts;
 };
 
 } // namespace OpenFDM



From frohlich at berlios.de  Mon Jan  2 16:07:18 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Mon, 2 Jan 2006 16:07:18 +0100
Subject: [OpenFDM-svn] r158 - in trunk/OpenFDM/src: JSBSim OpenFDM
Message-ID: <200601021507.k02F7IPn026031@sheep.berlios.de>

Author: frohlich
Date: 2006-01-02 16:07:11 +0100 (Mon, 02 Jan 2006)
New Revision: 158

Modified:
   trunk/OpenFDM/src/JSBSim/JSBSimAerosurfaceScale.cpp
   trunk/OpenFDM/src/JSBSim/JSBSimScheduledGain.cpp
   trunk/OpenFDM/src/JSBSim/JSBSimScheduledGain.h
   trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
   trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.h
   trunk/OpenFDM/src/OpenFDM/Port.cpp
   trunk/OpenFDM/src/OpenFDM/Port.h
   trunk/OpenFDM/src/OpenFDM/Table.h
Log:
Seperate table index lookups from index interpolations.


Modified: trunk/OpenFDM/src/JSBSim/JSBSimAerosurfaceScale.cpp
===================================================================
--- trunk/OpenFDM/src/JSBSim/JSBSimAerosurfaceScale.cpp	2006-01-02 12:52:37 UTC (rev 157)
+++ trunk/OpenFDM/src/JSBSim/JSBSimAerosurfaceScale.cpp	2006-01-02 15:07:11 UTC (rev 158)
@@ -21,7 +21,7 @@
 {
   // Such a component is a simple table lookup
   //
-  // -|InputSaturation|-|TableLookup|-
+  // -|InputSaturation|-|TablePreLookup|-|Table1D|-
   //
 
   Saturation* inputSaturation = new Saturation("Input Saturation");
@@ -32,12 +32,16 @@
   tmp(1, 1) = 1;
   inputSaturation->setMaxSaturation(tmp);
 
-  mTable = new Table1D("Table");
+  TablePreLookup* tablePreLookup = new TablePreLookup("Table Lookup");
   TableLookup tl;
   tl.setAtIndex(1, -1);
   tl.setAtIndex(2, 0);
   tl.setAtIndex(3, 1);
-  mTable->setTableLookup(tl);
+  tablePreLookup->setTableLookup(tl);
+  tablePreLookup->getInputPort(0)->connect(inputSaturation->getOutputPort(0));
+  getModelGroup()->addModel(tablePreLookup);
+
+  mTable = new Table1D("Table");
   TableData<1>::SizeVector sv;
   sv(1) = 3;
   TableData<1> tableData(sv);
@@ -49,7 +53,7 @@
   iv(1) = 3;
   tableData(iv) = 1;
   mTable->setTableData(tableData);
-  mTable->getInputPort(0)->connect(inputSaturation->getOutputPort(0));
+  mTable->getInputPort(0)->connect(tablePreLookup->getOutputPort(0));
   getModelGroup()->addModel(mTable);
 
   // Now connect the input and the output to this groups in and outputs

Modified: trunk/OpenFDM/src/JSBSim/JSBSimScheduledGain.cpp
===================================================================
--- trunk/OpenFDM/src/JSBSim/JSBSimScheduledGain.cpp	2006-01-02 12:52:37 UTC (rev 157)
+++ trunk/OpenFDM/src/JSBSim/JSBSimScheduledGain.cpp	2006-01-02 15:07:11 UTC (rev 158)
@@ -15,21 +15,25 @@
 {
   // Such a component is a simple product and a table lookup
   //
-  // -----------|
-  // --|Table|-|Product|-
+  // -------------------------------|
+  // --|TablePreLookup|-|Table|-|Product|-
   //
 
   Product* product = new Product("Product");
   getModelGroup()->addModel(product);
 
+  mTablePreLookup = new TablePreLookup("Table Lookup");
+  getModelGroup()->addModel(mTablePreLookup);
+
   mTable = new Table1D("Table");
   getModelGroup()->addModel(mTable);
   product->getInputPort(0)->connect(mTable->getOutputPort(0));
+  mTable->getInputPort(0)->connect(mTablePreLookup->getOutputPort(0));
 
   // Now connect the input and the output to this groups in and outputs
   getModelGroup()->setNumInputPorts(2);
   getModelGroup()->getInputPort(1)->setName("Schedule Input");
-  mTable->getInputPort(0)->connect(getModelGroup()->getInputPort(1));
+  mTablePreLookup->getInputPort(0)->connect(getModelGroup()->getInputPort(1));
 
   getModelGroup()->getInputPort(0)->setName("Input");
   product->getInputPort(1)->connect(getModelGroup()->getInputPort(0));
@@ -47,7 +51,7 @@
                                   const TableLookup& lookup)
 {
   mTable->setTableData(tableData);
-  mTable->setTableLookup(lookup);
+  mTablePreLookup->setTableLookup(lookup);
 }
 
 } //namespace OpenFDM

Modified: trunk/OpenFDM/src/JSBSim/JSBSimScheduledGain.h
===================================================================
--- trunk/OpenFDM/src/JSBSim/JSBSimScheduledGain.h	2006-01-02 12:52:37 UTC (rev 157)
+++ trunk/OpenFDM/src/JSBSim/JSBSimScheduledGain.h	2006-01-02 15:07:11 UTC (rev 158)
@@ -25,6 +25,7 @@
   void setTableData(const TableData<1>& tableData, const TableLookup& lookup);
 
 private:
+  SharedPtr<TablePreLookup> mTablePreLookup;
   SharedPtr<Table1D> mTable;
 };
 

Modified: trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
===================================================================
--- trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2006-01-02 12:52:37 UTC (rev 157)
+++ trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2006-01-02 15:07:11 UTC (rev 158)
@@ -2263,8 +2263,8 @@
       = new Table1D(prod->getName() + " Table");
     addMultiBodyModel(table1D);
     table1D->setTableData(table);
-    table1D->setTableLookup(lookup);
-    table1D->getInputPort(0)->connect(inVal[0]);
+    Port* lPort = getTablePrelookup(prod->getName(), inVal[0], lookup);
+    table1D->getInputPort(0)->connect(lPort);
 
     unsigned nf = prod->getNumFactors();
     prod->setNumFactors(nf+1);
@@ -2285,8 +2285,8 @@
     addMultiBodyModel(table2D);
     table2D->setTableData(table);
     for (unsigned i = 0; i < 2; ++i) {
-      table2D->setTableLookup(i, lookup[i]);
-      table2D->getInputPort(i)->connect(inVal[i]);
+      Port* lPort = getTablePrelookup(prod->getName(), inVal[i], lookup[i]);
+      table2D->getInputPort(i)->connect(lPort);
     }
 
     unsigned nf = prod->getNumFactors();
@@ -2309,8 +2309,8 @@
     addMultiBodyModel(table3D);
     table3D->setTableData(table);
     for (unsigned i = 0; i < 3; ++i) {
-      table3D->setTableLookup(i, lookup[i]);
-      table3D->getInputPort(i)->connect(inVal[i]);
+      Port* lPort = getTablePrelookup(prod->getName(), inVal[i], lookup[i]);
+      table3D->getInputPort(i)->connect(lPort);
     }
 
     unsigned nf = prod->getNumFactors();
@@ -2321,4 +2321,28 @@
   return prod->getOutputPort(0);
 }
 
+Port*
+LegacyJSBSimReader::getTablePrelookup(const std::string& name, Port* in,
+                                      const TableLookup& tl)
+{
+  // First check if we already have a table lookup for this port/brakepoint
+  // combination. If so return that output port
+  std::vector<SharedPtr<TablePreLookup> >::iterator it;
+  for (it = mTableLookups.begin(); it != mTableLookups.end(); ++it) {
+    if (tl == (*it)->getTableLookup() &&
+        in->hasSameSource((*it)->getInputPort(0))) {
+      return (*it)->getOutputPort(0);
+    }
+  }
+
+  // No sharable table lookup found, we need to create a new one
+  TablePreLookup* tablePreLookup
+    = new TablePreLookup(name + " Table Prelookup");
+  addMultiBodyModel(tablePreLookup);
+  tablePreLookup->setTableLookup(tl);
+  tablePreLookup->getInputPort(0)->connect(in);
+  mTableLookups.push_back(tablePreLookup);
+  return tablePreLookup->getOutputPort(0);
+}
+
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.h
===================================================================
--- trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.h	2006-01-02 12:52:37 UTC (rev 157)
+++ trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.h	2006-01-02 15:07:11 UTC (rev 158)
@@ -13,6 +13,7 @@
 #include <OpenFDM/AeroForce.h>
 #include <OpenFDM/Vehicle.h>
 #include <OpenFDM/ReaderWriter.h>
+#include <OpenFDM/Table.h>
 
 namespace OpenFDM {
 
@@ -207,6 +208,7 @@
 
   Port* convertCoefficient(const std::string& data, const std::string& type);
 
+  Port* getTablePrelookup(const std::string& name, Port* in, const TableLookup& tl);
 
 
   /// List for the aircraft search path.
@@ -225,6 +227,7 @@
   PropertyMap mExpressionTable;
   SharedPtr<AeroForce> mAeroForce;
   Vector3 mBodyReference;
+  std::vector<SharedPtr<TablePreLookup> > mTableLookups;
 };
 
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/Port.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Port.cpp	2006-01-02 12:52:37 UTC (rev 157)
+++ trunk/OpenFDM/src/OpenFDM/Port.cpp	2006-01-02 15:07:11 UTC (rev 158)
@@ -41,19 +41,29 @@
   return false;
 }
 
+bool
+Port::hasSameSource(const Port* otherPort) const
+{
+  OpenFDMAssert(mPortInterface);
+  return otherPort && otherPort->mPortInterface == mPortInterface;
+}
+
 Variant
 Port::getValue(void)
 {
-  if (mPortInterface) {
-    RealPortInterface* realPortInterface
-      = mPortInterface->toRealPortInterface();
-    if (realPortInterface)
-      return Variant(realPortInterface->getRealValue());
-    MatrixPortInterface* matrixPortInterface
-      = mPortInterface->toMatrixPortInterface();
-    if (matrixPortInterface)
-      return Variant(matrixPortInterface->getMatrixValue());
-  }
+  if (!mPortInterface)
+    return Variant();
+
+  RealPortInterface* realPortInterface
+    = mPortInterface->toRealPortInterface();
+  if (realPortInterface)
+    return Variant(realPortInterface->getRealValue());
+
+  MatrixPortInterface* matrixPortInterface
+    = mPortInterface->toMatrixPortInterface();
+  if (matrixPortInterface)
+    return Variant(matrixPortInterface->getMatrixValue());
+
   return Variant();
 }
 

Modified: trunk/OpenFDM/src/OpenFDM/Port.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Port.h	2006-01-02 12:52:37 UTC (rev 157)
+++ trunk/OpenFDM/src/OpenFDM/Port.h	2006-01-02 15:07:11 UTC (rev 158)
@@ -136,6 +136,10 @@
   /// current port
   bool isConnectedTo(const Port* sourcePort) const;
 
+  /// returns true if the source port sourcePort is the value source for the
+  /// current port
+  bool hasSameSource(const Port* otherPort) const;
+
   RealPortHandle toRealPortHandle(void)
   { return RealPortHandle(mPortInterface->toRealPortInterface()); }
   MatrixPortHandle toMatrixPortHandle(void)

Modified: trunk/OpenFDM/src/OpenFDM/Table.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Table.h	2006-01-02 12:52:37 UTC (rev 157)
+++ trunk/OpenFDM/src/OpenFDM/Table.h	2006-01-02 15:07:11 UTC (rev 158)
@@ -146,6 +146,11 @@
     return loIdx + theta;
   }
 
+  bool operator==(const TableLookup& tl) const
+  {
+    mTable == tl.mTable;
+  }
+
 private:
   Table mTable;
 };
@@ -269,6 +274,55 @@
   SizeVector mSize;
 };
 
+class TablePreLookup : public Model {
+public:
+  TablePreLookup(const std::string& name) :
+    Model(name)
+  {
+    setDirectFeedThrough(true);
+
+    setNumInputPorts(1);
+    setInputPortName(0, "input");
+    
+    setNumOutputPorts(1);
+    setOutputPort(0, "output", this, &TablePreLookup::getOutput);
+
+    addProperty("output", Property(this, &TablePreLookup::getOutput));
+  }
+  virtual ~TablePreLookup(void)
+  { }
+
+  virtual bool init(void)
+  {
+    mInputPortHandle = getInputPort(0)->toRealPortHandle();
+    if (!mInputPortHandle.isConnected()) {
+      Log(Model,Error) << "Input port to TablePreLookup Model \""
+                       << getName() << "\" is not connected" << endl;
+      return false;
+    }
+    return true;
+  }
+
+  virtual void output(const TaskInfo&)
+  {
+    OpenFDMAssert(mInputPortHandle.isConnected());
+    mOutput = mTableLookup.lookup(mInputPortHandle.getRealValue());
+  }
+
+  const real_type& getOutput(void) const
+  { return mOutput; }
+
+  void setTableLookup(const TableLookup& tl)
+  { mTableLookup = tl; }
+  const TableLookup& getTableLookup(void) const
+  { return mTableLookup; }
+
+private:
+  real_type mOutput;
+  TableLookup mTableLookup;
+  RealPortHandle mInputPortHandle;
+};
+
 class Table1D : public Model {
 public:
   Table1D(const std::string& name) :
@@ -288,17 +342,20 @@
   
   virtual bool init(void)
   {
-    OpenFDMAssert(getInputPort(0)->isConnected());
-  
-    return getInputPort(0)->isConnected();
+    mInputPortHandle = getInputPort(0)->toRealPortHandle();
+    if (!mInputPortHandle.isConnected()) {
+      Log(Model,Error) << "Input port to Table1D Model \""
+                       << getName() << "\" is not connected" << endl;
+      return false;
+    }
+    return true;
   }
 
   virtual void output(const TaskInfo&)
   {
-    OpenFDMAssert(getInputPort(0)->isConnected());
+    OpenFDMAssert(mInputPortHandle.isConnected());
     TableData<1>::InterpVector interpVec;
-    RealPortHandle rh = getInputPort(0)->toRealPortHandle();
-    interpVec(1) = mTableLookup.lookup(rh.getRealValue());
+    interpVec(1) = mInputPortHandle.getRealValue();
     mOutput = mTableData.interpolate(interpVec);
   }
 
@@ -312,13 +369,10 @@
   TableData<1>& getTableData(void)
   { return mTableData; }
 
-  void setTableLookup(const TableLookup& tl)
-  { mTableLookup = tl; }
-
 private:
   real_type mOutput;
   TableData<1> mTableData;
-  TableLookup mTableLookup;
+  RealPortHandle mInputPortHandle;
 };
 
 class Table2D : public Model {
@@ -341,19 +395,24 @@
   
   virtual bool init(void)
   {
-    OpenFDMAssert(getInputPort(0)->isConnected());
-    OpenFDMAssert(getInputPort(1)->isConnected());
-    return getInputPort(0)->isConnected() && getInputPort(1)->isConnected();
+    for (unsigned idx = 0; idx < 2; ++idx) {
+      mInputPortHandle[idx] = getInputPort(idx)->toRealPortHandle();
+      if (!mInputPortHandle[idx].isConnected()) {
+        Log(Model,Error) << "Input port to Table2D Model \""
+                         << getName() << "\" is not connected" << endl;
+        return false;
+      }
+    }
+    return true;
   }
 
   virtual void output(const TaskInfo&)
   {
-    OpenFDMAssert(getInputPort(0)->isConnected());
+    OpenFDMAssert(mInputPortHandle[0].isConnected());
+    OpenFDMAssert(mInputPortHandle[1].isConnected());
     TableData<2>::InterpVector interpVec;
-    RealPortHandle rh = getInputPort(0)->toRealPortHandle();
-    interpVec(1) = mTableLookup[0].lookup(rh.getRealValue());
-    rh = getInputPort(1)->toRealPortHandle();
-    interpVec(2) = mTableLookup[1].lookup(rh.getRealValue());
+    interpVec(1) = mInputPortHandle[0].getRealValue();
+    interpVec(2) = mInputPortHandle[1].getRealValue();
     mOutput = mTableData.interpolate(interpVec);
   }
 
@@ -367,13 +426,10 @@
   TableData<2>& getTableData(void)
   { return mTableData; }
 
-  void setTableLookup(unsigned idx, const TableLookup& tl)
-  { mTableLookup[idx] = tl; }
-
 private:
   real_type mOutput;
   TableData<2> mTableData;
-  TableLookup mTableLookup[2];
+  RealPortHandle mInputPortHandle[2];
 };
 
 class Table3D : public Model {
@@ -397,23 +453,26 @@
   
   virtual bool init(void)
   {
-    OpenFDMAssert(getInputPort(0)->isConnected());
-    OpenFDMAssert(getInputPort(1)->isConnected());
-    OpenFDMAssert(getInputPort(3)->isConnected());
-    return getInputPort(0)->isConnected() && getInputPort(1)->isConnected()
-      && getInputPort(2)->isConnected();
+    for (unsigned idx = 0; idx < 3; ++idx) {
+      mInputPortHandle[idx] = getInputPort(idx)->toRealPortHandle();
+      if (!mInputPortHandle[idx].isConnected()) {
+        Log(Model,Error) << "Input port to Table3D Model \""
+                         << getName() << "\" is not connected" << endl;
+        return false;
+      }
+    }
+    return true;
   }
 
   virtual void output(const TaskInfo&)
   {
-    OpenFDMAssert(getInputPort(0)->isConnected());
+    OpenFDMAssert(mInputPortHandle[0].isConnected());
+    OpenFDMAssert(mInputPortHandle[1].isConnected());
+    OpenFDMAssert(mInputPortHandle[2].isConnected());
     TableData<3>::InterpVector interpVec;
-    RealPortHandle rh = getInputPort(0)->toRealPortHandle();
-    interpVec(1) = mTableLookup[0].lookup(rh.getRealValue());
-    rh = getInputPort(1)->toRealPortHandle();
-    interpVec(2) = mTableLookup[1].lookup(rh.getRealValue());
-    rh = getInputPort(2)->toRealPortHandle();
-    interpVec(3) = mTableLookup[2].lookup(rh.getRealValue());
+    interpVec(1) = mInputPortHandle[0].getRealValue();
+    interpVec(2) = mInputPortHandle[1].getRealValue();
+    interpVec(3) = mInputPortHandle[2].getRealValue();
     mOutput = mTableData.interpolate(interpVec);
   }
 
@@ -427,13 +486,10 @@
   TableData<3>& getTableData(void)
   { return mTableData; }
 
-  void setTableLookup(unsigned idx, const TableLookup& tl)
-  { mTableLookup[idx] = tl; }
-
 private:
   real_type mOutput;
   TableData<3> mTableData;
-  TableLookup mTableLookup[3];
+  RealPortHandle mInputPortHandle[3];
 };
 
 } // namespace OpenFDM



From frohlich at berlios.de  Mon Jan  2 16:16:52 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Mon, 2 Jan 2006 16:16:52 +0100
Subject: [OpenFDM-svn] r159 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200601021516.k02FGqHT027778@sheep.berlios.de>

Author: frohlich
Date: 2006-01-02 16:16:50 +0100 (Mon, 02 Jan 2006)
New Revision: 159

Modified:
   trunk/OpenFDM/src/OpenFDM/DiscreteIntegrator.cpp
Log:
Fix typo


Modified: trunk/OpenFDM/src/OpenFDM/DiscreteIntegrator.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/DiscreteIntegrator.cpp	2006-01-02 15:07:11 UTC (rev 158)
+++ trunk/OpenFDM/src/OpenFDM/DiscreteIntegrator.cpp	2006-01-02 15:16:50 UTC (rev 159)
@@ -11,7 +11,7 @@
   Model(name)
 {
   setNumInputPorts(1);
-  setInputPortName(0, "derivatirve");
+  setInputPortName(0, "derivative");
 
   setNumOutputPorts(1);
   setOutputPort(0, "output", this, &DiscreteIntegrator::getIntegralOutput);



From frohlich at berlios.de  Mon Jan  2 17:21:18 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Mon, 2 Jan 2006 17:21:18 +0100
Subject: [OpenFDM-svn] r160 - trunk/OpenFDM/src/OpenFDM/LinAlg
Message-ID: <200601021621.k02GLIPe003451@sheep.berlios.de>

Author: frohlich
Date: 2006-01-02 17:21:14 +0100 (Mon, 02 Jan 2006)
New Revision: 160

Modified:
   trunk/OpenFDM/src/OpenFDM/LinAlg/IO.h
Log:
Fix integer vector output.


Modified: trunk/OpenFDM/src/OpenFDM/LinAlg/IO.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/LinAlg/IO.h	2006-01-02 15:16:50 UTC (rev 159)
+++ trunk/OpenFDM/src/OpenFDM/LinAlg/IO.h	2006-01-02 16:21:14 UTC (rev 160)
@@ -47,12 +47,11 @@
 
     for (j = 1; j <= cols; ++j) {
       value_type val = A.asImpl()(i, j);
-      value_type absval = fabs(val);
     
-      if (absval == 0.0) {
+      if (val == 0) {
         os << std::setw(width) << '0' << ' ';
       } else {
-        int expo = static_cast<int>(floor(fabs(log10(absval))));
+        int expo = static_cast<int>(floor(fabs(log10(fabs(val)))));
         
         if (expo < 100) {
           os << std::setprecision(width-7);



From frohlich at berlios.de  Mon Jan  2 17:26:36 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Mon, 2 Jan 2006 17:26:36 +0100
Subject: [OpenFDM-svn] r161 - in trunk/OpenFDM/src: JSBSim OpenFDM
Message-ID: <200601021626.k02GQa0a003993@sheep.berlios.de>

Author: frohlich
Date: 2006-01-02 17:26:32 +0100 (Mon, 02 Jan 2006)
New Revision: 161

Modified:
   trunk/OpenFDM/src/JSBSim/JSBSimKinemat.cpp
   trunk/OpenFDM/src/OpenFDM/DiscreteIntegrator.cpp
   trunk/OpenFDM/src/OpenFDM/DiscreteIntegrator.h
Log:
Update DiscreteIntegrator


Modified: trunk/OpenFDM/src/JSBSim/JSBSimKinemat.cpp
===================================================================
--- trunk/OpenFDM/src/JSBSim/JSBSimKinemat.cpp	2006-01-02 16:21:14 UTC (rev 160)
+++ trunk/OpenFDM/src/JSBSim/JSBSimKinemat.cpp	2006-01-02 16:26:32 UTC (rev 161)
@@ -63,6 +63,8 @@
   Matrix tmp(1, 1);
   tmp(1, 1) = 1;
   integrator->setInitialValue(tmp);
+  /// FIXME: should happen in this way, fix when ports are reworked
+//   integrator->getInputPort(1)->connect(mInputSaturation->getOutputPort(0));
   
   Gain* feedbackGain = new Gain("Feedback Gain");
   getModelGroup()->addModel(feedbackGain);

Modified: trunk/OpenFDM/src/OpenFDM/DiscreteIntegrator.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/DiscreteIntegrator.cpp	2006-01-02 16:21:14 UTC (rev 160)
+++ trunk/OpenFDM/src/OpenFDM/DiscreteIntegrator.cpp	2006-01-02 16:26:32 UTC (rev 161)
@@ -10,8 +10,9 @@
 DiscreteIntegrator::DiscreteIntegrator(const std::string& name) :
   Model(name)
 {
-  setNumInputPorts(1);
+  setNumInputPorts(2);
   setInputPortName(0, "derivative");
+  setInputPortName(1, "initialValue");
 
   setNumOutputPorts(1);
   setOutputPort(0, "output", this, &DiscreteIntegrator::getIntegralOutput);
@@ -30,26 +31,35 @@
 bool
 DiscreteIntegrator::init(void)
 {
-  OpenFDMAssert(getInputPort(0)->isConnected());
+  mDerivativePort = getInputPort(0)->toMatrixPortHandle();
+  if (!mDerivativePort.isConnected()) {
+    Log(Model,Error) << "Input port to DiscreteIntegrator Model \""
+                     << getName() << "\" is not connected" << endl;
+    return false;
+  }
 
   // The initial value defaults to zero
-  if (rows(mInitialValue) == 0 || cols(mInitialValue) == 0) {
-    mInitialValue.resize(getInputPort(0)->getValue().toMatrix());
-    mInitialValue.clear();
+  if (getInputPort(1)->isConnected()) {
+    MatrixPortHandle mh = getInputPort(1)->toMatrixPortHandle();
+    mIntegralState = mh.getMatrixValue();
+  } else {
+    if (rows(mInitialValue) == 0 || cols(mInitialValue) == 0) {
+      mInitialValue.resize(getInputPort(0)->getValue().toMatrix());
+      mInitialValue.clear();
+    }
+    mIntegralState = mInitialValue;
   }
+  mIntegralOutput = mIntegralState;
 
   if (size(mMinSaturation) != Size(0, 0)) {
-    OpenFDMAssert(size(mMinSaturation) == size(mInitialValue));
+    OpenFDMAssert(size(mMinSaturation) == size(mIntegralState));
   }
   if (size(mMaxSaturation) != Size(0, 0)) {
-    OpenFDMAssert(size(mMaxSaturation) == size(mInitialValue));
+    OpenFDMAssert(size(mMaxSaturation) == size(mIntegralState));
   }
 
-  setNumDiscreteStates(rows(mInitialValue)*cols(mInitialValue));
-
-  mIntegralState = mInitialValue;
-  mIntegralOutput = mIntegralState;
-
+  setNumDiscreteStates(rows(mIntegralState)*cols(mIntegralState));
+  
   return true;
 }
 
@@ -62,19 +72,17 @@
 void
 DiscreteIntegrator::update(const TaskInfo& taskInfo)
 {
-  OpenFDMAssert(getInputPort(0)->isConnected());
+  OpenFDMAssert(mDerivativePort.isConnected());
 
   // Just compute the integral.
   // FIXME: make sure this is the only dt ...
   real_type dt = (*taskInfo.getSampleTimeSet().begin()).getSampleTime();
-  MatrixPortHandle mh = getInputPort(0)->toMatrixPortHandle();
-  if (size(mh.getMatrixValue()) == size(mIntegralState))
-    mIntegralState += dt*mh.getMatrixValue();
+  mIntegralState += dt*mDerivativePort.getMatrixValue();
 
   // Hmm, should that be done on state setting too???
-  if (size(mMaxSaturation) == size(mInitialValue))
+  if (size(mMaxSaturation) == size(mIntegralState))
     mIntegralState = LinAlg::min(mIntegralState, mMaxSaturation);
-  if (size(mMinSaturation) == size(mInitialValue))
+  if (size(mMinSaturation) == size(mIntegralState))
     mIntegralState = LinAlg::max(mIntegralState, mMinSaturation);
 }
 

Modified: trunk/OpenFDM/src/OpenFDM/DiscreteIntegrator.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/DiscreteIntegrator.h	2006-01-02 16:21:14 UTC (rev 160)
+++ trunk/OpenFDM/src/OpenFDM/DiscreteIntegrator.h	2006-01-02 16:26:32 UTC (rev 161)
@@ -45,6 +45,8 @@
   Matrix mMinSaturation;
   /// Holds the maximum saturation
   Matrix mMaxSaturation;
+  /// Holds a matrix handle to the integrators input
+  MatrixPortHandle mDerivativePort;
 };
 
 } // namespace OpenFDM



From frohlich at berlios.de  Mon Jan  2 18:23:15 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Mon, 2 Jan 2006 18:23:15 +0100
Subject: [OpenFDM-svn] r162 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200601021723.k02HNFga001089@sheep.berlios.de>

Author: frohlich
Date: 2006-01-02 18:23:10 +0100 (Mon, 02 Jan 2006)
New Revision: 162

Modified:
   trunk/OpenFDM/src/OpenFDM/DiscBrake.cpp
   trunk/OpenFDM/src/OpenFDM/Math.h
   trunk/OpenFDM/src/OpenFDM/RevoluteActuator.cpp
   trunk/OpenFDM/src/OpenFDM/SimpleGear.cpp
   trunk/OpenFDM/src/OpenFDM/WheelContact.cpp
Log:
Add some handy saturation functions and use it


Modified: trunk/OpenFDM/src/OpenFDM/DiscBrake.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/DiscBrake.cpp	2006-01-02 16:26:32 UTC (rev 161)
+++ trunk/OpenFDM/src/OpenFDM/DiscBrake.cpp	2006-01-02 17:23:10 UTC (rev 162)
@@ -63,11 +63,13 @@
   // with this sigma the model is already very crisp and reaches the
   // maximum force relatively fast, thus we do not need to make it even faster
   // with higher speeds
-  vel = sign(vel)*min(1.0, fabs(vel));
+//   vel = saturate(vel, 1.0);
+  vel = smoothSaturate(vel, 1.0);
   // the time derivative of the friction state
   mZDeriv = vel - sigma*fabs(vel)*mZ;
   // this is to limit the stiffness of this model
-  mZDeriv = sign(mZDeriv)*min(10.0, fabs(mZDeriv));
+//   mZDeriv = saturate(mZDeriv, 10.0);
+  mZDeriv = smoothSaturate(mZDeriv, 10.0);
   // now the output force, modulate with the brake input
   mForce = -interpolate(brakeInput, 0.0, mMinForce, 1.0, mMaxForce)*sigma*mZ;
 }

Modified: trunk/OpenFDM/src/OpenFDM/Math.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Math.h	2006-01-02 16:26:32 UTC (rev 161)
+++ trunk/OpenFDM/src/OpenFDM/Math.h	2006-01-02 17:23:10 UTC (rev 162)
@@ -53,7 +53,7 @@
 
 template<typename T>
 inline int
-sign(T val)
+sign(const T& val)
 {
   if (val <= -Limits<T>::min())
     return -1;
@@ -62,9 +62,33 @@
   return 0;
 }
 
+template<typename T>
+inline T
+saturate(const T& val, const T& saturation)
+{
+  if (val <= -saturation)
+    return -saturation;
+  if (saturation <= val)
+    return saturation;
+  return val;
+}
+
+template<typename T>
+inline T
+smoothSaturate(const T& val, const T& saturation)
+{
+  /// FIXME
+#define PI static_cast<real_type>(3.1415926535897932384626433832795029L)
+  if (saturation < Limits<T>::min())
+    return 0;
+  else
+    return atan(val*0.5*PI/saturation)*2*saturation/PI;
+#undef PI
+}
+
 template<typename S, typename T>
 inline S
-interpolate(T x, T x0, const S& y0, T x1, const S& y1)
+interpolate(const T& x, const T& x0, const S& y0, T x1, const S& y1)
 {
   // If called in the wrong order, simply call with the correct order ...
   if (x1 < x0)

Modified: trunk/OpenFDM/src/OpenFDM/RevoluteActuator.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RevoluteActuator.cpp	2006-01-02 16:26:32 UTC (rev 161)
+++ trunk/OpenFDM/src/OpenFDM/RevoluteActuator.cpp	2006-01-02 17:23:10 UTC (rev 162)
@@ -118,7 +118,8 @@
 
   real_type posErr = desiredPos - mRevoluteActuatorFrame->getJointPos();
 
-  real_type desiredVel = mVelGain*sign(posErr)*min(fabs(posErr), mMaxVel);
+//   real_type desiredVel = saturate(mVelGain*posErr, mMaxVel);
+  real_type desiredVel = smoothSaturate(mVelGain*posErr, mMaxVel);
 
   real_type velErr = desiredVel - mRevoluteActuatorFrame->getJointVel();
 

Modified: trunk/OpenFDM/src/OpenFDM/SimpleGear.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/SimpleGear.cpp	2006-01-02 16:26:32 UTC (rev 161)
+++ trunk/OpenFDM/src/OpenFDM/SimpleGear.cpp	2006-01-02 17:23:10 UTC (rev 162)
@@ -174,16 +174,13 @@
   // The slip angle is the angle between the 'velocity vector' and 
   // the wheel forward direction.
   real_type slipAngle = rad2deg*atan2(wheelVel(2), fabs(wheelVel(1)));
-  if (fabs(wheelVel(2)) < fabs(slipAngle))
-    slipAngle = wheelVel(2);
+//   slipAngle = saturate(slipAngle, 10*fabs(wheelVel(2)));
+  slipAngle = smoothSaturate(slipAngle, 10*fabs(wheelVel(2)));
   
-  Vector2 slip(wheelSlip, slipAngle);
+//   Vector2 slip(wheelSlip, slipAngle);
 //   if (1 < norm(slip))
 //     slip = normalize(slip);
-  if (1 < fabs(wheelSlip))
-    slip(1) = sign(wheelSlip);
-  if (1 < fabs(slipAngle))
-    slip(2) = sign(slipAngle);
+  Vector2 slip(smoothSaturate(wheelSlip, 1.0), smoothSaturate(slipAngle, 1.0));
   
   // The friction force for fast movement.
   Vector2 fricForce = (-friction*mFrictionCoef*normForce)*slip;

Modified: trunk/OpenFDM/src/OpenFDM/WheelContact.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/WheelContact.cpp	2006-01-02 16:26:32 UTC (rev 161)
+++ trunk/OpenFDM/src/OpenFDM/WheelContact.cpp	2006-01-02 17:23:10 UTC (rev 162)
@@ -150,16 +150,13 @@
   // The slip angle is the angle between the 'velocity vector' and 
   // the wheel forward direction.
   real_type slipAngle = rad2deg*atan2(vel(2), fabs(vel(1)));
-  if (10*fabs(vel(2)) < fabs(slipAngle))
-    slipAngle = 10*vel(2);
+//   slipAngle = saturate(slipAngle, 10*fabs(vel(2)));
+  slipAngle = smoothSaturate(slipAngle, 10*fabs(vel(2)));
   
-  Vector2 slip(wheelSlip, slipAngle);
+//   Vector2 slip(wheelSlip, slipAngle);
 //   if (1 < norm(slip))
 //     slip = normalize(slip);
-  if (1 < fabs(wheelSlip))
-    slip(1) = sign(wheelSlip);
-  if (1 < fabs(slipAngle))
-    slip(2) = sign(slipAngle);
+  Vector2 slip(smoothSaturate(wheelSlip, 1.0), smoothSaturate(slipAngle, 1.0));
   
   // The friction force for fast movement.
   return (-friction*mFrictionCoeficient*normForce)*slip;



From frohlich at berlios.de  Mon Jan  2 18:47:38 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Mon, 2 Jan 2006 18:47:38 +0100
Subject: [OpenFDM-svn] r163 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200601021747.k02Hlctr025057@sheep.berlios.de>

Author: frohlich
Date: 2006-01-02 18:47:24 +0100 (Mon, 02 Jan 2006)
New Revision: 163

Modified:
   trunk/OpenFDM/src/OpenFDM/ModelGroup.cpp
Log:
Fix missing return


Modified: trunk/OpenFDM/src/OpenFDM/ModelGroup.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/ModelGroup.cpp	2006-01-02 17:23:10 UTC (rev 162)
+++ trunk/OpenFDM/src/OpenFDM/ModelGroup.cpp	2006-01-02 17:47:24 UTC (rev 163)
@@ -118,6 +118,7 @@
         << "While adding the OpenFDM::Model \"" << model->getName()
         << "\" to OpenFDM::ModelGroup \"" << getName()
         << "\": Model with the same name is already attached!" << endl;
+      return ~0u;
     }
   }
 



From frohlich at berlios.de  Mon Jan  2 18:49:40 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Mon, 2 Jan 2006 18:49:40 +0100
Subject: [OpenFDM-svn] r164 - in trunk/OpenFDM/src: JSBSim OpenFDM
Message-ID: <200601021749.k02HneVv026601@sheep.berlios.de>

Author: frohlich
Date: 2006-01-02 18:49:35 +0100 (Mon, 02 Jan 2006)
New Revision: 164

Modified:
   trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
   trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.h
   trunk/OpenFDM/src/OpenFDM/ModelGroup.cpp
Log:
Fix name handling with tables


Modified: trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
===================================================================
--- trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2006-01-02 17:47:24 UTC (rev 163)
+++ trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2006-01-02 17:49:35 UTC (rev 164)
@@ -979,7 +979,7 @@
     brakeF->getInputPort(1)->connect(wj->getOutputPort(1));
     // ... and provides an output force
     wj->getInputPort(0)->connect(brakeF->getOutputPort(0));
-    mVehicle->getMultiBodySystem()->addModel(brakeF);
+    addMultiBodyModel(brakeF);
   } else {
     // Just some 'rolloing friction' FIXME: does this belong here?
     Gain* rollingFric = new Gain(name + " Rolling Friction Force");
@@ -987,7 +987,7 @@
     rollingFric->getInputPort(0)->connect(wj->getOutputPort(1));
     // ... and provides an output force
     wj->getInputPort(0)->connect(rollingFric->getOutputPort(0));
-    mVehicle->getMultiBodySystem()->addModel(rollingFric);
+    addMultiBodyModel(rollingFric);
   }
   
   WheelContact* wc = new WheelContact(name + " Wheel Contact");
@@ -1180,7 +1180,7 @@
       aoDamp->getInputPort(1)->connect(rj->getOutputPort(1));
       // ... and provides an output force
       rj->getInputPort(0)->connect(aoDamp->getOutputPort(0));
-      mVehicle->getMultiBodySystem()->addModel(aoDamp);
+      addMultiBodyModel(aoDamp);
 
       // Attach a wheel to that strut part.
       attachWheel(name, Vector3(-armLength, 0, 0), brake, numStr, wheelDiam,
@@ -1294,7 +1294,7 @@
       pj->getInputPort(0)->connect(aoDamp->getOutputPort(0));
       aoDamp->getInputPort(0)->connect(pj->getOutputPort(0));
       aoDamp->getInputPort(1)->connect(pj->getOutputPort(1));
-      mVehicle->getMultiBodySystem()->addModel(aoDamp);
+      addMultiBodyModel(aoDamp);
 
       // Attach a wheel to that strut part.
       attachWheel(name, Vector3::zeros(), brake, numStr, wheelDiam,
@@ -2163,14 +2163,16 @@
         return error("Error parsing aerodynamic tables, FACTOR without GROUP");
 
       std::string type = (*it)->getAttribute("TYPE");
-      Port* port = convertCoefficient((*it)->getData(), type);
+      std::string name = (*it)->getAttribute("NAME");
+      Port* port = convertCoefficient((*it)->getData(), type, name);
       unsigned nf = prod->getNumFactors();
       prod->setNumFactors(nf+1);
       prod->getInputPort(nf)->connect(port);
     }
     else if ((*it)->getName() == "COEFFICIENT") {
       std::string type = (*it)->getAttribute("TYPE");
-      Port* port = convertCoefficient((*it)->getData(), type);
+      std::string name = (*it)->getAttribute("NAME");
+      Port* port = convertCoefficient((*it)->getData(), type, name);
       unsigned ns = sum->getNumSummands();
       sum->setNumSummands(ns+1);
       sum->getInputPort(ns)->connect(port);
@@ -2182,8 +2184,13 @@
 
 Port*
 LegacyJSBSimReader::convertCoefficient(const std::string& data,
-                                       const std::string& type)
+                                       const std::string& type,
+                                       const std::string& name)
 {
+  SharedPtr<Product> prod = new Product(name);
+  prod->setNumFactors(0);
+  addMultiBodyModel(prod);
+
   unsigned ndims;
   if (type == "VALUE") {
     ndims = 0;
@@ -2205,10 +2212,6 @@
   // The fist token is some name string ...
   datastr >> token;
 
-  SharedPtr<Product> prod = new Product(token);
-  prod->setNumFactors(0);
-  addMultiBodyModel(prod);
-
   // The number of table entries 
   unsigned n[3] = { 0 };
   for (unsigned i = 0; i < ndims; ++i)
@@ -2263,7 +2266,8 @@
       = new Table1D(prod->getName() + " Table");
     addMultiBodyModel(table1D);
     table1D->setTableData(table);
-    Port* lPort = getTablePrelookup(prod->getName(), inVal[0], lookup);
+    Port* lPort = getTablePrelookup(prod->getName() + " PreLookup",
+                                    inVal[0], lookup);
     table1D->getInputPort(0)->connect(lPort);
 
     unsigned nf = prod->getNumFactors();
@@ -2285,7 +2289,8 @@
     addMultiBodyModel(table2D);
     table2D->setTableData(table);
     for (unsigned i = 0; i < 2; ++i) {
-      Port* lPort = getTablePrelookup(prod->getName(), inVal[i], lookup[i]);
+      Port* lPort = getTablePrelookup(prod->getName() + " PreLookup",
+                                      inVal[i], lookup[i]);
       table2D->getInputPort(i)->connect(lPort);
     }
 
@@ -2309,7 +2314,8 @@
     addMultiBodyModel(table3D);
     table3D->setTableData(table);
     for (unsigned i = 0; i < 3; ++i) {
-      Port* lPort = getTablePrelookup(prod->getName(), inVal[i], lookup[i]);
+      Port* lPort = getTablePrelookup(prod->getName() + " PreLookup",
+                                      inVal[i], lookup[i]);
       table3D->getInputPort(i)->connect(lPort);
     }
 

Modified: trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.h
===================================================================
--- trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.h	2006-01-02 17:47:24 UTC (rev 163)
+++ trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.h	2006-01-02 17:49:35 UTC (rev 164)
@@ -206,7 +206,8 @@
   bool convertAEROSummands(const XMLElement* aeroSummands,
                            Summer* sum, Product* prod);
 
-  Port* convertCoefficient(const std::string& data, const std::string& type);
+  Port* convertCoefficient(const std::string& data, const std::string& type,
+                           const std::string& name);
 
   Port* getTablePrelookup(const std::string& name, Port* in, const TableLookup& tl);
 

Modified: trunk/OpenFDM/src/OpenFDM/ModelGroup.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/ModelGroup.cpp	2006-01-02 17:47:24 UTC (rev 163)
+++ trunk/OpenFDM/src/OpenFDM/ModelGroup.cpp	2006-01-02 17:49:35 UTC (rev 164)
@@ -118,7 +118,6 @@
         << "While adding the OpenFDM::Model \"" << model->getName()
         << "\" to OpenFDM::ModelGroup \"" << getName()
         << "\": Model with the same name is already attached!" << endl;
-      return ~0u;
     }
   }
 



From frohlich at berlios.de  Tue Jan  3 08:48:07 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Tue, 3 Jan 2006 08:48:07 +0100
Subject: [OpenFDM-svn] r165 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200601030748.k037m7Lg007137@sheep.berlios.de>

Author: frohlich
Date: 2006-01-03 08:48:02 +0100 (Tue, 03 Jan 2006)
New Revision: 165

Modified:
   trunk/OpenFDM/src/OpenFDM/Joint.cpp
   trunk/OpenFDM/src/OpenFDM/Joint.h
   trunk/OpenFDM/src/OpenFDM/MobileRootJoint.cpp
   trunk/OpenFDM/src/OpenFDM/MobileRootJoint.h
   trunk/OpenFDM/src/OpenFDM/ModelVisitor.h
Log:
Extend the ModelVisitor with morr classes


Modified: trunk/OpenFDM/src/OpenFDM/Joint.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Joint.cpp	2006-01-02 17:49:35 UTC (rev 164)
+++ trunk/OpenFDM/src/OpenFDM/Joint.cpp	2006-01-03 07:48:02 UTC (rev 165)
@@ -12,6 +12,7 @@
 #include "Interact.h"
 #include "Frame.h"
 #include "LogStream.h"
+#include "ModelVisitor.h"
 #include "Joint.h"
 
 namespace OpenFDM {
@@ -25,6 +26,12 @@
 {
 }
 
+void
+Joint::accept(ModelVisitor& visitor)
+{
+  visitor.apply(*this);
+}
+
 const Joint*
 Joint::toJoint(void) const
 {

Modified: trunk/OpenFDM/src/OpenFDM/Joint.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Joint.h	2006-01-02 17:49:35 UTC (rev 164)
+++ trunk/OpenFDM/src/OpenFDM/Joint.h	2006-01-03 07:48:02 UTC (rev 165)
@@ -21,12 +21,19 @@
 /// FIXME: joint's should be lockable, which means trylock == true and
 /// velocity small enough - keep position ...
 
+class ModelVisitor;
+
 class Joint
   : public Interact {
 public:
   Joint(const std::string& name);
   virtual ~Joint(void);
 
+  /// Double dispatch helper for the multibody system visitor
+  virtual void accept(ModelVisitor& visitor);
+  /// Double dispatch helper for the multibody system visitor
+//   virtual void accept(ConstModelVisitor& visitor) const;
+
   virtual const Joint* toJoint(void) const;
   virtual Joint* toJoint(void);
 

Modified: trunk/OpenFDM/src/OpenFDM/MobileRootJoint.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/MobileRootJoint.cpp	2006-01-02 17:49:35 UTC (rev 164)
+++ trunk/OpenFDM/src/OpenFDM/MobileRootJoint.cpp	2006-01-03 07:48:02 UTC (rev 165)
@@ -12,6 +12,7 @@
 #include "Gravity.h"
 #include "Frame.h"
 #include "RigidBody.h"
+#include "ModelVisitor.h"
 #include "RootFrame.h"
 #include "MobileRootJointFrame.h"
 #include "MobileRootJoint.h"
@@ -30,6 +31,12 @@
 {
 }
 
+void
+MobileRootJoint::accept(ModelVisitor& visitor)
+{
+  visitor.apply(*this);
+}
+
 const MobileRootJoint*
 MobileRootJoint::toMobileRootJoint(void) const
 {
@@ -126,18 +133,49 @@
   mFrame->setAngularRelVel(vel);
 }
 
+const Vector3&
+MobileRootJoint::getRefPosition(void) const
+{
+  return mFrame->getRefPosition();
+}
+
 void
 MobileRootJoint::setRefPosition(const Vector3& p)
 {
   mFrame->setRefPosition(p);
 }
 
+const Quaternion&
+MobileRootJoint::getRefOrientation(void) const
+{
+  return mFrame->getRefOrientation();
+}
+
 void
 MobileRootJoint::setRefOrientation(const Quaternion& o)
 {
   mFrame->setRefOrientation(o);
 }
 
+Geodetic
+MobileRootJoint::getGeodPosition(void) const
+{
+  Environment* env = getEnvironment();
+  if (!env)
+    return Geodetic();
+  return env->getPlanet()->toGeod(getRefPosition());
+}
+
+Quaternion
+MobileRootJoint::getGeodOrientation(void) const
+{
+  Environment* env = getEnvironment();
+  if (!env)
+    return Quaternion::unit();
+  Quaternion hlOr = env->getPlanet()->getGeodHLOrientation(getRefPosition());
+  return inverse(hlOr)*getRefOrientation();
+}
+
 void
 MobileRootJoint::jointArticulation(SpatialInertia& artI, Vector6& artF,
                              const SpatialInertia& outI,

Modified: trunk/OpenFDM/src/OpenFDM/MobileRootJoint.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/MobileRootJoint.h	2006-01-02 17:49:35 UTC (rev 164)
+++ trunk/OpenFDM/src/OpenFDM/MobileRootJoint.h	2006-01-03 07:48:02 UTC (rev 165)
@@ -13,11 +13,13 @@
 #include "Inertia.h"
 #include "Frame.h"
 #include "RigidBody.h"
+#include "Planet.h"
 #include "Joint.h"
 #include "Environment.h"
 
 namespace OpenFDM {
 
+class ModelVisitor;
 class MobileRootJointFrame;
 
 class MobileRootJoint
@@ -26,6 +28,11 @@
   MobileRootJoint(const std::string& name);
   virtual ~MobileRootJoint(void);
 
+  /// Double dispatch helper for the multibody system visitor
+  virtual void accept(ModelVisitor& visitor);
+  /// Double dispatch helper for the multibody system visitor
+//   virtual void accept(ConstModelVisitor& visitor) const;
+
   virtual const MobileRootJoint* toMobileRootJoint(void) const;
   virtual MobileRootJoint* toMobileRootJoint(void);
 
@@ -41,11 +48,21 @@
   /// Set the relative velocity.
   void setAngularRelVel(const Vector3& vel);
 
+  /// Get the reference position.
+  const Vector3& getRefPosition(void) const;
   /// Set the reference position.
   void setRefPosition(const Vector3& p);
+
+  /// Get the reference orientation.
+  const Quaternion& getRefOrientation(void) const;
   /// Set the reference orientation.
   void setRefOrientation(const Quaternion& o);
 
+  /// Get the geodetic position.
+  Geodetic getGeodPosition(void) const;
+  /// Get orientation wrt the geodetic hl frame.
+  Quaternion getGeodOrientation(void) const;
+
 private:
   /** Plugin function for the articulated body algorithm.
    */

Modified: trunk/OpenFDM/src/OpenFDM/ModelVisitor.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/ModelVisitor.h	2006-01-02 17:49:35 UTC (rev 164)
+++ trunk/OpenFDM/src/OpenFDM/ModelVisitor.h	2006-01-03 07:48:02 UTC (rev 165)
@@ -24,6 +24,10 @@
   { apply((ModelGroup&)multiBodySystem); }
   virtual void apply(Interact& interact)
   { apply((Model&)interact); }
+  virtual void apply(Joint& joint)
+  { apply((Interact&)joint); }
+  virtual void apply(MobileRootJoint& mobileRootJoint)
+  { apply((Joint&)mobileRootJoint); }
 protected:
   /// Call this in the apply(ModelGroup&) method if you want to
   /// traverse downward



From frohlich at berlios.de  Tue Jan  3 08:48:49 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Tue, 3 Jan 2006 08:48:49 +0100
Subject: [OpenFDM-svn] r166 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200601030748.k037mnGa007219@sheep.berlios.de>

Author: frohlich
Date: 2006-01-03 08:48:47 +0100 (Tue, 03 Jan 2006)
New Revision: 166

Modified:
   trunk/OpenFDM/src/OpenFDM/Force.h
Log:
Make if compiel with out NDEBUG defined.


Modified: trunk/OpenFDM/src/OpenFDM/Force.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Force.h	2006-01-03 07:48:02 UTC (rev 165)
+++ trunk/OpenFDM/src/OpenFDM/Force.h	2006-01-03 07:48:47 UTC (rev 166)
@@ -53,13 +53,11 @@
   /// FIXME remove
   const Frame* getParentFrame(unsigned id = 0) const
   {
-    OpenFDMAssert(id < mParents.size() && mParents[id]);
     return getParentRigidBody(id)->getFrame();
   }
   /// FIXME remove
   Frame* getParentFrame(unsigned id = 0)
   {
-    OpenFDMAssert(id < mParents.size() && mParents[id]);
     return getParentRigidBody(id)->getFrame();
   }
 



From frohlich at berlios.de  Tue Jan  3 08:49:28 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Tue, 3 Jan 2006 08:49:28 +0100
Subject: [OpenFDM-svn] r167 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200601030749.k037nSxu007353@sheep.berlios.de>

Author: frohlich
Date: 2006-01-03 08:49:26 +0100 (Tue, 03 Jan 2006)
New Revision: 167

Modified:
   trunk/OpenFDM/src/OpenFDM/ModelGroup.cpp
Log:
Fix scheduling for interacts


Modified: trunk/OpenFDM/src/OpenFDM/ModelGroup.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/ModelGroup.cpp	2006-01-03 07:48:47 UTC (rev 166)
+++ trunk/OpenFDM/src/OpenFDM/ModelGroup.cpp	2006-01-03 07:49:26 UTC (rev 167)
@@ -383,7 +383,7 @@
   }
 
   // If the model in question does not have dependencies, stop.
-  if (model->getDirectFeedThrough() || joint) {
+  if (model->getDirectFeedThrough() || joint || interact) {
 
     // Check, all inputs for dependencies.
     unsigned numInputs = model->getNumInputPorts();
@@ -427,6 +427,7 @@
     }
   }
 
+  Log(Model, Debug) << "Scheduling: \"" << model->getName() << "\"" << endl;
   newList.push_back(model);
   return true;
 }



From frohlich at berlios.de  Tue Jan  3 08:52:22 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Tue, 3 Jan 2006 08:52:22 +0100
Subject: [OpenFDM-svn] r168 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200601030752.k037qMlx007553@sheep.berlios.de>

Author: frohlich
Date: 2006-01-03 08:52:18 +0100 (Tue, 03 Jan 2006)
New Revision: 168

Modified:
   trunk/OpenFDM/src/OpenFDM/Product.cpp
   trunk/OpenFDM/src/OpenFDM/Summer.cpp
   trunk/OpenFDM/src/OpenFDM/Table.h
Log:
Add some debug log.


Modified: trunk/OpenFDM/src/OpenFDM/Product.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Product.cpp	2006-01-03 07:49:26 UTC (rev 167)
+++ trunk/OpenFDM/src/OpenFDM/Product.cpp	2006-01-03 07:52:18 UTC (rev 168)
@@ -53,6 +53,8 @@
   mProduct = 1;
   for (unsigned i = 0; i < getNumInputPorts(); ++i)
     mProduct *= mFactorPorts[i].getRealValue();
+  Log(Model,Debug3) << "Output of Product \"" << getName() << "\" "
+                    << mProduct << endl;
 }
 
 const real_type&

Modified: trunk/OpenFDM/src/OpenFDM/Summer.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Summer.cpp	2006-01-03 07:49:26 UTC (rev 167)
+++ trunk/OpenFDM/src/OpenFDM/Summer.cpp	2006-01-03 07:52:18 UTC (rev 168)
@@ -82,6 +82,9 @@
     mSum += (*it).getMatrixValue();
     ++it;
   }
+
+  Log(Model,Debug3) << "Output of Summer \"" << getName() << "\" "
+                    << mSum << endl;
 }
 
 const Matrix&

Modified: trunk/OpenFDM/src/OpenFDM/Table.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Table.h	2006-01-03 07:49:26 UTC (rev 167)
+++ trunk/OpenFDM/src/OpenFDM/Table.h	2006-01-03 07:52:18 UTC (rev 168)
@@ -307,6 +307,8 @@
   {
     OpenFDMAssert(mInputPortHandle.isConnected());
     mOutput = mTableLookup.lookup(mInputPortHandle.getRealValue());
+    Log(Model,Debug3) << "Output of TablePreLookup \"" << getName() << "\" "
+                      << mOutput << endl;
   }
 
   const real_type& getOutput(void) const
@@ -357,6 +359,8 @@
     TableData<1>::InterpVector interpVec;
     interpVec(1) = mInputPortHandle.getRealValue();
     mOutput = mTableData.interpolate(interpVec);
+    Log(Model,Debug3) << "Output of Table1D \"" << getName() << "\" "
+                      << mOutput << endl;
   }
 
   const real_type& getOutput(void) const
@@ -414,6 +418,8 @@
     interpVec(1) = mInputPortHandle[0].getRealValue();
     interpVec(2) = mInputPortHandle[1].getRealValue();
     mOutput = mTableData.interpolate(interpVec);
+    Log(Model, Debug3) << "Output of Table2D \"" << getName() << "\" "
+                       << mOutput << endl;
   }
 
   const real_type& getOutput(void) const
@@ -474,6 +480,8 @@
     interpVec(2) = mInputPortHandle[1].getRealValue();
     interpVec(3) = mInputPortHandle[2].getRealValue();
     mOutput = mTableData.interpolate(interpVec);
+    Log(Model, Debug3) << "Output of Table3D \"" << getName() << "\" "
+                       << mOutput << endl;
   }
 
   const real_type& getOutput(void) const



From frohlich at berlios.de  Tue Jan  3 09:31:03 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Tue, 3 Jan 2006 09:31:03 +0100
Subject: [OpenFDM-svn] r169 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200601030831.k038V3m8011592@sheep.berlios.de>

Author: frohlich
Date: 2006-01-03 09:31:00 +0100 (Tue, 03 Jan 2006)
New Revision: 169

Modified:
   trunk/OpenFDM/src/OpenFDM/AeroForce.h
Log:
Remove obsolete enum.


Modified: trunk/OpenFDM/src/OpenFDM/AeroForce.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/AeroForce.h	2006-01-03 07:52:18 UTC (rev 168)
+++ trunk/OpenFDM/src/OpenFDM/AeroForce.h	2006-01-03 08:31:00 UTC (rev 169)
@@ -21,14 +21,6 @@
 class AeroForce
   : public ExternalForce {
 public:
-  enum ForceAxis {
-    RollAxis = 1,
-    PitchAxis = 2,
-    YawAxis = 3,
-    DragAxis = 4,
-    SideAxis = 5,
-    LiftAxis = 6
-  };
   AeroForce(const std::string&);
   virtual ~AeroForce(void);
 



From frohlich at berlios.de  Tue Jan  3 11:52:22 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Tue, 3 Jan 2006 11:52:22 +0100
Subject: [OpenFDM-svn] r170 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200601031052.k03AqMAh025889@sheep.berlios.de>

Author: frohlich
Date: 2006-01-03 11:52:20 +0100 (Tue, 03 Jan 2006)
New Revision: 170

Modified:
   trunk/OpenFDM/src/OpenFDM/WheelContact.cpp
Log:
Zap a FIXME: yippie!!


Modified: trunk/OpenFDM/src/OpenFDM/WheelContact.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/WheelContact.cpp	2006-01-03 08:31:00 UTC (rev 169)
+++ trunk/OpenFDM/src/OpenFDM/WheelContact.cpp	2006-01-03 10:52:20 UTC (rev 170)
@@ -46,7 +46,7 @@
                           SampleTime::PerTimestep)) {
     Log(Model, Debug) << "WheelContact::output(): \"" << getName()
                       << "\" computing ground plane below" << endl;
-    getGround(0 /*FIXME*/);
+    getGround(taskInfo.getTime());
   }
 }
 



From frohlich at berlios.de  Tue Jan  3 11:53:48 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Tue, 3 Jan 2006 11:53:48 +0100
Subject: [OpenFDM-svn] r171 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200601031053.k03ArmOu026073@sheep.berlios.de>

Author: frohlich
Date: 2006-01-03 11:53:45 +0100 (Tue, 03 Jan 2006)
New Revision: 171

Modified:
   trunk/OpenFDM/src/OpenFDM/MobileRootJoint.cpp
   trunk/OpenFDM/src/OpenFDM/MobileRootJoint.h
Log:
More preparations for trimming.


Modified: trunk/OpenFDM/src/OpenFDM/MobileRootJoint.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/MobileRootJoint.cpp	2006-01-03 10:52:20 UTC (rev 170)
+++ trunk/OpenFDM/src/OpenFDM/MobileRootJoint.cpp	2006-01-03 10:53:45 UTC (rev 171)
@@ -115,6 +115,12 @@
   }
 }
 
+const Vector6&
+MobileRootJoint::getRelVel(void) const
+{
+  return mFrame->getRelVel();
+}
+
 void
 MobileRootJoint::setRelVel(const Vector6& vel)
 {
@@ -133,6 +139,12 @@
   mFrame->setAngularRelVel(vel);
 }
 
+const Vector6&
+MobileRootJoint::getRelVelDot(void) const
+{
+  return mFrame->getRelVelDot();
+}
+
 const Vector3&
 MobileRootJoint::getRefPosition(void) const
 {
@@ -166,6 +178,15 @@
   return env->getPlanet()->toGeod(getRefPosition());
 }
 
+void
+MobileRootJoint::setGeodPosition(const Geodetic& geod)
+{
+  Environment* env = getEnvironment();
+  if (!env)
+    return;
+  setRefPosition(env->getPlanet()->toCart(geod));
+}
+
 Quaternion
 MobileRootJoint::getGeodOrientation(void) const
 {

Modified: trunk/OpenFDM/src/OpenFDM/MobileRootJoint.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/MobileRootJoint.h	2006-01-03 10:52:20 UTC (rev 170)
+++ trunk/OpenFDM/src/OpenFDM/MobileRootJoint.h	2006-01-03 10:53:45 UTC (rev 171)
@@ -41,6 +41,8 @@
 
   virtual void recheckTopology(void);
 
+  /// Gets the relative velocity.
+  const Vector6& getRelVel(void) const;
   /// Set the relative velocity.
   void setRelVel(const Vector6& vel);
   /// Set the relative velocity.
@@ -48,6 +50,9 @@
   /// Set the relative velocity.
   void setAngularRelVel(const Vector3& vel);
 
+  /// Gets the relative velocity derivative.
+  const Vector6& getRelVelDot(void) const;
+
   /// Get the reference position.
   const Vector3& getRefPosition(void) const;
   /// Set the reference position.
@@ -60,6 +65,8 @@
 
   /// Get the geodetic position.
   Geodetic getGeodPosition(void) const;
+  /// Set the geodetic position.
+  void setGeodPosition(const Geodetic& geod);
   /// Get orientation wrt the geodetic hl frame.
   Quaternion getGeodOrientation(void) const;
 



From frohlich at berlios.de  Tue Jan  3 11:54:27 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Tue, 3 Jan 2006 11:54:27 +0100
Subject: [OpenFDM-svn] r172 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200601031054.k03AsRit026124@sheep.berlios.de>

Author: frohlich
Date: 2006-01-03 11:54:24 +0100 (Tue, 03 Jan 2006)
New Revision: 172

Modified:
   trunk/OpenFDM/src/OpenFDM/Math.h
Log:
Add some handy deadBand functions


Modified: trunk/OpenFDM/src/OpenFDM/Math.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Math.h	2006-01-03 10:53:45 UTC (rev 171)
+++ trunk/OpenFDM/src/OpenFDM/Math.h	2006-01-03 10:54:24 UTC (rev 172)
@@ -75,10 +75,21 @@
 
 template<typename T>
 inline T
+deadBand(const T& val, const T& saturation)
+{
+  if (val <= -saturation)
+    return val + saturation;
+  if (saturation <= val)
+    return val - saturation;
+  return T(0);
+}
+
+template<typename T>
+inline T
 smoothSaturate(const T& val, const T& saturation)
 {
   /// FIXME
-#define PI static_cast<real_type>(3.1415926535897932384626433832795029L)
+#define PI static_cast<T>(3.1415926535897932384626433832795029L)
   if (saturation < Limits<T>::min())
     return 0;
   else
@@ -86,6 +97,13 @@
 #undef PI
 }
 
+template<typename T>
+inline T
+smoothDeadBand(const T& val, const T& saturation)
+{
+  return val - smoothSaturate(val, saturation);
+}
+
 template<typename S, typename T>
 inline S
 interpolate(const T& x, const T& x0, const S& y0, T x1, const S& y1)



From frohlich at berlios.de  Tue Jan  3 12:25:43 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Tue, 3 Jan 2006 12:25:43 +0100
Subject: [OpenFDM-svn] r173 - trunk/OpenFDM/src/JSBSim
Message-ID: <200601031125.k03BPgfM029744@sheep.berlios.de>

Author: frohlich
Date: 2006-01-03 12:25:40 +0100 (Tue, 03 Jan 2006)
New Revision: 173

Modified:
   trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
Log:
Reindent


Modified: trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
===================================================================
--- trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2006-01-03 10:54:24 UTC (rev 172)
+++ trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2006-01-03 11:25:40 UTC (rev 173)
@@ -2262,8 +2262,7 @@
       // FIXME
       std::cerr << "Cannot parse " + type + " table" << std::endl;
 
-    Table1D* table1D
-      = new Table1D(prod->getName() + " Table");
+    Table1D* table1D = new Table1D(prod->getName() + " Table");
     addMultiBodyModel(table1D);
     table1D->setTableData(table);
     Port* lPort = getTablePrelookup(prod->getName() + " PreLookup",
@@ -2284,8 +2283,7 @@
       // FIXME
       std::cerr << "Cannot parse " + type + " table" << data << std::endl;
 
-    Table2D* table2D
-      = new Table2D(prod->getName() + " Table");
+    Table2D* table2D = new Table2D(prod->getName() + " Table");
     addMultiBodyModel(table2D);
     table2D->setTableData(table);
     for (unsigned i = 0; i < 2; ++i) {
@@ -2309,8 +2307,7 @@
       // FIXME
       std::cerr << "Cannot parse " + type + " table" << std::endl;
 
-    Table3D* table3D
-      = new Table3D(prod->getName() + " Table");
+    Table3D* table3D = new Table3D(prod->getName() + " Table");
     addMultiBodyModel(table3D);
     table3D->setTableData(table);
     for (unsigned i = 0; i < 3; ++i) {



From frohlich at berlios.de  Tue Jan  3 14:36:25 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Tue, 3 Jan 2006 14:36:25 +0100
Subject: [OpenFDM-svn] r174 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200601031336.k03DaP5U007675@sheep.berlios.de>

Author: frohlich
Date: 2006-01-03 14:36:18 +0100 (Tue, 03 Jan 2006)
New Revision: 174

Modified:
   trunk/OpenFDM/src/OpenFDM/MobileRootJoint.cpp
   trunk/OpenFDM/src/OpenFDM/MobileRootJoint.h
   trunk/OpenFDM/src/OpenFDM/Newton.cpp
   trunk/OpenFDM/src/OpenFDM/Newton.h
   trunk/OpenFDM/src/OpenFDM/System.cpp
Log:
Some beginning of trimming


Modified: trunk/OpenFDM/src/OpenFDM/MobileRootJoint.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/MobileRootJoint.cpp	2006-01-03 11:25:40 UTC (rev 173)
+++ trunk/OpenFDM/src/OpenFDM/MobileRootJoint.cpp	2006-01-03 13:36:18 UTC (rev 174)
@@ -197,6 +197,24 @@
   return inverse(hlOr)*getRefOrientation();
 }
 
+Vector4
+MobileRootJoint::getQDot(void) const
+{
+  // Compute the derivative term originating from the angular velocity.
+  // Correction term to keep the quaternion normalized.
+  // That is if |q| < 1 add a little radial component outward,
+  // if |q| > 1 add a little radial component inward
+  Quaternion q = mFrame->getOrientation();
+  Vector3 angVel = mFrame->getRelVel().getAngular();
+  Vector4 qderiv = derivative(q, angVel) + 0.1*(normalize(q) - q);
+  return qderiv;
+}
+
+Vector3 MobileRootJoint::getPosDot(void) const
+{
+  return mFrame->rotToParent(mFrame->getRelVel().getLinear());
+}
+
 void
 MobileRootJoint::jointArticulation(SpatialInertia& artI, Vector6& artF,
                              const SpatialInertia& outI,
@@ -234,18 +252,9 @@
 void
 MobileRootJoint::getStateDeriv(StateStream& stateDeriv)
 {
-  Quaternion q = mFrame->getOrientation();
-  Vector3 angVel = mFrame->getRelVel().getAngular();
-  Vector3 vel = mFrame->rotToParent(mFrame->getRelVel().getLinear());
-
-  // Compute the derivative term originating from the angular velocity.
-  // Correction term to keep the quaternion normalized.
-  // That is if |q| < 1 add a little radial component outward,
-  // if |q| > 1 add a little radial component inward
-  Vector4 qderiv = derivative(q, angVel) + 0.1*(normalize(q) - q);
-  stateDeriv.writeSubState(qderiv);
-  stateDeriv.writeSubState(vel);
-  stateDeriv.writeSubState(mFrame->getRelVelDot());
+  stateDeriv.writeSubState(getQDot());
+  stateDeriv.writeSubState(getPosDot());
+  stateDeriv.writeSubState(getRelVelDot());
 }
 
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/MobileRootJoint.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/MobileRootJoint.h	2006-01-03 11:25:40 UTC (rev 173)
+++ trunk/OpenFDM/src/OpenFDM/MobileRootJoint.h	2006-01-03 13:36:18 UTC (rev 174)
@@ -70,7 +70,9 @@
   /// Get orientation wrt the geodetic hl frame.
   Quaternion getGeodOrientation(void) const;
 
-private:
+  Vector4 getQDot(void) const;
+  Vector3 getPosDot(void) const;
+
   /** Plugin function for the articulated body algorithm.
    */
   virtual void jointArticulation(SpatialInertia& artI, Vector6& artF,
@@ -88,6 +90,7 @@
    */
   virtual void getStateDeriv(StateStream& state);
 
+private:
   /// The commonly used gravity model from the environment class
   /// It is initialized at the init() call
   SharedPtr<const Gravity> mGravity;

Modified: trunk/OpenFDM/src/OpenFDM/Newton.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Newton.cpp	2006-01-03 11:25:40 UTC (rev 173)
+++ trunk/OpenFDM/src/OpenFDM/Newton.cpp	2006-01-03 13:36:18 UTC (rev 174)
@@ -2,6 +2,8 @@
  *
  */
 
+#undef NDEBUG
+
 #include "Assert.h"
 #include "LogStream.h"
 #include "Object.h"
@@ -192,7 +194,6 @@
                       itCount, maxit, maxjac, lambdamin);
 }
 
-static
 Vector
 LineSearch(Function& f, real_type t, const Vector& xk, const Vector& dk,
            real_type maxWide, real_type thresh)
@@ -202,33 +203,29 @@
 
   thresh = fabs(maxWide)*thresh;
 
+  Vector fx;
+
   Vector v = xk;
+  f.eval(t, v, fx);
+  real_type fv = norm(fx);
+
   Vector w = xk + maxWide*dk;
+  f.eval(t, w, fx);
+  real_type fw = norm(fx);
 
-  Vector fx;
   while (norm1(v - w) > thresh) {
-    f.eval(t, v, fx);
-    real_type fv = dot(fx, fx);
-    f.eval(t, w, fx);
-    real_type fw = dot(fx, fx);
     Log(NewtonMethod, Debug2) << " Line Search: errv = " << fv
-                             << ", errw = " << fw << endl;
-  
+                              << ", errw = " << fw << endl;
     // check for isfinite ...
-//   if failv
-//     v = v + vfac*(w-v);
-//   elseif failw
-//     w = v + wfac*(w-v);
-//   elseif fv > fw
-//     v = v + vfac*(w-v);
-//   else
-//     w = v + wfac*(w-v);
-//   end
-
-    if (fv > fw)
+    if (fv > fw) {
       v = v + vfac*(w-v);
-    else
+      f.eval(t, v, fx);
+      fv = norm(fx);
+    } else {
       w = v + wfac*(w-v);
+      f.eval(t, w, fx);
+      fw = norm(fx);
+    }
   }
 
   return 0.5*(v+w);
@@ -246,28 +243,49 @@
 {
   Vector err, dx;
   Matrix J;
+#define USE_QR
+#ifdef USE_QR
+  LinAlg::MatrixFactors<real_type,0,0,LinAlg::QRTag> jacFactors;
+#else
   LinAlg::MatrixFactors<real_type,0,0,LinAlg::LUTag> jacFactors;
-//   LinAlg::MatrixFactors<real_type,0,0,LinAlg::QRTag> jacFactors;
+#endif
 
   bool converged;
   do {
     // Compute in each step a new jacobian
     f.jac(t, x, J);
+    Log(NewtonMethod, Debug) << "Jacobian is:\n" << J << endl;
+#ifdef USE_QR
+    jacFactors = J;
+#else
     jacFactors = trans(J)*J;
-    
+#endif
+    Log(NewtonMethod, Debug) << "Jacobian is "
+                             << (jacFactors.singular() ? "singular" : "ok")
+                             << endl;
+   
     // Compute the actual error
     f.eval(t, x, err);
 
     // Compute the search direction
+#ifdef USE_QR
+    dx = jacFactors.solve(err);
+#else
     dx = jacFactors.solve(trans(J)*err);
+#endif
+    Log(NewtonMethod, Debug) << "dx residual "
+                             << trans(J*dx - err) << endl
+                             << trans(J*dx - err)*J
+                             << endl;
 
     // Get a better search guess
-//     if (1 < norm(dx))
-//       dx = normalize(dx);
+    if (1 < norm(dx))
+      dx = normalize(dx);
     Vector xnew = LineSearch(f, t, x, -dx, 1.0, atol);
 
     // check convergence
     converged = norm1(xnew - x) < atol;
+    
 
     Log(NewtonMethod, Debug) << "Convergence test: |dx| = " << norm(xnew - x)
                              << ", converged = " << converged << endl;
@@ -278,4 +296,82 @@
   return converged;
 }
 
+bool
+LevenbergMarquart(Function& f,
+                  real_type t,
+                  Vector& x,
+                  real_type atol, real_type rtol,
+                  unsigned *itCount,
+                  unsigned maxit)
+{
+  Matrix J;
+  LinAlg::MatrixFactors<real_type,0,0,LinAlg::LUTag> jacFactors;
+
+  bool converged;
+  real_type tau = 1e-3;
+  real_type nu = 2;
+
+  // Compute in each step a new jacobian
+  f.jac(t, x, J);
+  Log(NewtonMethod, Debug3) << "Jacobian is:\n" << J << endl;
+  real_type mu = tau*norm1(J);
+
+  Vector fx;
+  // Compute the actual error
+  f.eval(t, x, fx);
+  Vector g = trans(J)*fx;
+
+  do {
+    jacFactors = trans(J)*J + mu*LinAlg::Eye<real_type,0,0>(rows(x), rows(x));
+    Log(NewtonMethod, Debug) << "Jacobian is "
+                             << (jacFactors.singular() ? "singular" : "ok")
+                             << endl;
+   
+    // Compute the search direction
+    Vector h = jacFactors.solve(-g);
+    Log(NewtonMethod, Debug) << "Solve Residual "
+                             << norm(trans(J)*J*h + mu*h + g)/norm(g) << endl;
+
+    // check convergence
+    converged = norm1(h) < atol;
+    Log(NewtonMethod, Debug) << "Convergence test: ||h||_1 = " << norm1(h)
+                             << ", converged = " << converged << endl;
+    if (converged)
+      break;
+
+    // Get a better search guess
+    Vector xnew = x + h;
+    f.eval(t, x, fx);
+    real_type Fx = norm(fx);
+    f.eval(t, xnew, fx);
+    real_type Fxnew = norm(fx);
+    real_type rho = (Fx - Fxnew)/(0.5*dot(h, mu*h - g));
+    Log(NewtonMethod, Debug) << "Rho = " << rho
+                             << ", Fxnew = " << Fxnew 
+                             << ", Fx = " << Fx
+                             << endl;
+    if (0 < rho) {
+      // New guess is the better one
+      x = xnew;
+
+      f.jac(t, x, J);
+      Log(NewtonMethod, Debug3) << "Jacobian is:\n" << J << endl;
+      // Compute the actual error
+      f.eval(t, x, fx);
+      g = trans(J)*fx;
+      converged = norm1(g) < atol;
+      Log(NewtonMethod, Debug) << "||g||_1 = " << norm1(g) << endl;
+
+      mu = mu * max(1.0/3, 1-pow(2*rho-1, 3));
+      mu = 2;
+
+    } else {
+      mu = mu * nu;
+      nu = 2 * nu;
+    }
+  } while (!converged);
+
+  return converged;
+}
+
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/Newton.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Newton.h	2006-01-03 11:25:40 UTC (rev 173)
+++ trunk/OpenFDM/src/OpenFDM/Newton.h	2006-01-03 13:36:18 UTC (rev 174)
@@ -22,6 +22,10 @@
        unsigned maxjac = 2,
        real_type lambdamin = 1e-3);
 
+Vector
+LineSearch(Function& f, real_type t, const Vector& xk, const Vector& dk,
+           real_type maxWide, real_type thresh);
+
 bool
 GaussNewton(Function& f,
             real_type t,
@@ -32,6 +36,14 @@
             unsigned maxjac = 20,
             real_type lambdamin = 1e-5);
 
+bool
+LevenbergMarquart(Function& f,
+                  real_type t,
+                  Vector& x,
+                  real_type atol, real_type rtol,
+                  unsigned *itCount = 0,
+                  unsigned maxit = 50);
+
 } // namespace OpenFDM
 
 #endif

Modified: trunk/OpenFDM/src/OpenFDM/System.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/System.cpp	2006-01-03 11:25:40 UTC (rev 173)
+++ trunk/OpenFDM/src/OpenFDM/System.cpp	2006-01-03 13:36:18 UTC (rev 174)
@@ -12,6 +12,7 @@
 #include "ExplicitEuler.h"
 #include "Function.h"
 #include "Newton.h"
+#include "ModelVisitor.h"
 #include "System.h"
 
 namespace OpenFDM {
@@ -235,48 +236,183 @@
   return true;
 }
 
-class TrimFunction
-  : public Function {
+class TrimCollectorVisitor :
+    public ModelVisitor {
 public:
-  TrimFunction(System& system, const Vector& state)
-    : mSystem(system), mState(state) {}
+  TrimCollectorVisitor(unsigned nStates) :
+    mStateStream(nStates)
+  { }
+  virtual ~TrimCollectorVisitor(void)
+  { }
+  virtual void apply(Model& model)
+  { model.getStateDeriv(mStateStream); }
+  virtual void apply(ModelGroup& modelGroup)
+  { traverse(modelGroup); }
+  virtual void apply(MobileRootJoint& mobileRootJoint)
+  {
+    mGeodPos = mobileRootJoint.getGeodPosition();
+    mGeodOr = mobileRootJoint.getGeodOrientation();
+    mVel = mobileRootJoint.getRelVel();
+    mVelDot = mobileRootJoint.getRelVelDot();
+    mPosDot = mobileRootJoint.getPosDot();
+    mQDot = mobileRootJoint.getQDot();
+    mMobileRootJoint = &mobileRootJoint;
+  }
+  Geodetic mGeodPos;
+  Quaternion mGeodOr;
+  Vector6 mVel;
+  Vector6 mVelDot;
+  Vector3 mPosDot;
+  Vector4 mQDot;
+  StateStream mStateStream;
+  MobileRootJoint* mMobileRootJoint;
+};
+
+class TrimFunction :
+    public Function {
+public:
+  TrimFunction(System& system) :
+    mSystem(system)
+  {
+    unsigned nStates = mSystem.getNumContinousStates();
+    TrimCollectorVisitor tcv(nStates);
+    mSystem.accept(tcv);
+    mGeodPos = tcv.mGeodPos;
+    mGeodOr = tcv.mGeodOr;
+    mVel = tcv.mVel;
+    mVelDot = tcv.mVelDot;
+    mPosDot = tcv.mPosDot;
+    mQDot = tcv.mQDot;
+  }
   virtual unsigned inSize(void) const
   { return mSystem.getNumContinousStates(); }
-#if 1
   virtual unsigned outSize(void) const
-  { return 2*mSystem.getNumContinousStates(); }
+  { return mSystem.getNumContinousStates(); }
   virtual void eval(real_type t, const Vector& v, Vector& out)
   {
     unsigned nStates = mSystem.getNumContinousStates();
     Vector deriv(nStates);
     mSystem.evalFunction(t, v, deriv);
 
-    out.resize(2*nStates);
-    out(Range(1, nStates)) = 1e-1*(mState - v);
-    out(Range(nStates + 1, 2*nStates)) = deriv;
+    TrimCollectorVisitor tcv(nStates);
+    mSystem.accept(tcv);
+    Vector3 eo = mGeodOr.getEuler();
+    Vector3 en = tcv.mGeodOr.getEuler();
+
+    /// 3 dof for the position
+    real_type tmp = 1e6*(mGeodPos.longitude - tcv.mGeodPos.longitude);
+    tcv.mStateStream.writeSubState(tmp);
+    tmp = 1e6*(mGeodPos.latitude - tcv.mGeodPos.latitude);
+    tcv.mStateStream.writeSubState(tmp);
+    tmp = smoothDeadBand(mGeodPos.altitude - tcv.mGeodPos.altitude, 10.0);
+    tcv.mStateStream.writeSubState(tmp);
+
+    // The orientation
+    tmp = 1e2*smoothDeadBand(eo(1) - en(1), 20*deg2rad);
+    tcv.mStateStream.writeSubState(tmp);
+    tmp = 1e2*smoothDeadBand(eo(2) - en(2), 20*deg2rad);
+    tcv.mStateStream.writeSubState(tmp);
+    tmp = 1e2*(eo(3) - en(3));
+    tcv.mStateStream.writeSubState(tmp);
+
+    tcv.mStateStream.writeSubState(1e2*norm(tcv.mQDot) + norm(tcv.mPosDot - mPosDot));
+//     tcv.mStateStream.writeSubState(1e2*tcv.mQDot);
+//     tcv.mStateStream.writeSubState(tcv.mPosDot);
+    tcv.mStateStream.writeSubState(1e6*tcv.mVelDot);
+
+    out = tcv.mStateStream.getState();
   }
-#else
+private:
+  System& mSystem;
+  Geodetic mGeodPos;
+  Quaternion mGeodOr;
+  Vector6 mVel;
+  Vector6 mVelDot;
+  Vector3 mPosDot;
+  Vector4 mQDot;
+};
+
+class AltitudeFinderTrimFunction :
+    public Function {
+public:
+  AltitudeFinderTrimFunction(System& system, real_type range) :
+    mSystem(system),
+    mRange(range)
+  {
+    unsigned nStates = mSystem.getNumContinousStates();
+    TrimCollectorVisitor tcv(nStates);
+    mSystem.accept(tcv);
+    mGeodPos = tcv.mGeodPos;
+    mGeodOr = tcv.mGeodOr;
+    mVel = tcv.mVel;
+    mVelDot = tcv.mVelDot;
+    mMobileRootJoint = tcv.mMobileRootJoint;
+  }
+  virtual unsigned inSize(void) const
+  { return 1; }
   virtual unsigned outSize(void) const
-  { return mSystem.getNumContinousStates(); }
+  { return 7; }
   virtual void eval(real_type t, const Vector& v, Vector& out)
   {
-    mSystem.evalFunction(t, v, out);
+    Geodetic geod = mGeodPos;
+    geod.altitude = mGeodPos.altitude - mRange*0.5 + v(1);
+    mMobileRootJoint->setGeodPosition(geod);
+    
+    unsigned nStates = mSystem.getNumContinousStates();
+    StateStream vv(nStates);
+    mSystem.getState(vv);
+    Vector deriv(nStates);
+    mSystem.evalFunction(t, vv.getState(), deriv);
+
+    TrimCollectorVisitor tcv(nStates + 6);
+    mSystem.accept(tcv);
+
+    /// The line search algorithm sees that the gravitation
+    /// is less in higher regions, thus we need to add a 'minimum altitude'
+    /// criterion
+    out.resize(7, 1);
+    out(Range(1, 6)) = tcv.mVelDot;
+//     out(7) = 1e-1*v(1);
+    out(7) = smoothDeadBand(v(1), mRange);
+    
+//     Log(Model,Error) << trans(v) << endl;
+//     Log(Model,Error) << trans(out) << endl;
+//     Log(Model,Error) << mGeodPos << geod << endl << endl;
   }
-#endif
 private:
   System& mSystem;
-  Vector mState;
+  real_type mRange;
+  Geodetic mGeodPos;
+  Quaternion mGeodOr;
+  Vector6 mVel;
+  Vector6 mVelDot;
+  MobileRootJoint* mMobileRootJoint;
 };
 
 bool
 System::trim(void)
 {
   // need to prepare the System especially for the per step tasks
-  TaskInfo taskInfo;
+  TaskInfo taskInfo = mDiscreteTaskList[0];
+//   taskInfo.setTime(getTime());
   taskInfo.addSampleTime(SampleTime::Continous);
   taskInfo.addSampleTime(SampleTime::PerTimestep);
   output(taskInfo);
 
+  /// First try to find an altitude where the acceleration is minimal,
+  /// this is most likely a good starting point for the subsequent total trim
+  real_type range = 20;
+  AltitudeFinderTrimFunction altTrim(*this, range);
+
+  Vector altV(1);
+  altV(1) = 0;
+  Vector dk(1);
+  dk(1) = 1;
+  Vector res = LineSearch(altTrim, getTime(), altV, dk, range, 1e-3);
+  altTrim.eval(getTime(), res, dk /*dummy*/);
+  output(taskInfo);
+
+
   // Get the current state
   StateStream stateStream(getNumContinousStates());
   getState(stateStream);
@@ -284,12 +420,13 @@
 
   Vector trimState = stateStream.getState();
   // Buld up the trim function
-  TrimFunction trimFunction(*this, trimState);
+  TrimFunction trimFunction(*this);
 
   // Try to find a minimum
-  real_type atol = 1e-3;
+  real_type atol = 1e-7;
   real_type rtol = 1e-8;
   bool ret = GaussNewton(trimFunction, getTime(), trimState, atol, rtol);
+//   bool ret = LevenbergMarquart(trimFunction, getTime(), trimState, atol, rtol);
   if (ret) {
     stateStream.setState(trimState);
     setState(stateStream);



From frohlich at berlios.de  Tue Jan  3 15:57:23 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Tue, 3 Jan 2006 15:57:23 +0100
Subject: [OpenFDM-svn] r175 - in trunk/OpenFDM/src: JSBSim OpenFDM
Message-ID: <200601031457.k03EvNaB020585@sheep.berlios.de>

Author: frohlich
Date: 2006-01-03 15:57:16 +0100 (Tue, 03 Jan 2006)
New Revision: 175

Added:
   trunk/OpenFDM/src/OpenFDM/LinearSpringDamper.cpp
   trunk/OpenFDM/src/OpenFDM/LinearSpringDamper.h
Removed:
   trunk/OpenFDM/src/OpenFDM/LinearSpring.cpp
   trunk/OpenFDM/src/OpenFDM/LinearSpring.h
Modified:
   trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
   trunk/OpenFDM/src/OpenFDM/Makefile.am
Log:
Rename LinearSpring to LinearSpringDamper


Modified: trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
===================================================================
--- trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2006-01-03 13:36:18 UTC (rev 174)
+++ trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2006-01-03 14:57:16 UTC (rev 175)
@@ -21,7 +21,7 @@
 #include <OpenFDM/Gain.h>
 #include <OpenFDM/Input.h>
 #include <OpenFDM/Mass.h>
-#include <OpenFDM/LinearSpring.h>
+#include <OpenFDM/LinearSpringDamper.h>
 #include <OpenFDM/MaxModel.h>
 #include <OpenFDM/AirSpring.h>
 #include <OpenFDM/PrismaticJoint.h>

Deleted: trunk/OpenFDM/src/OpenFDM/LinearSpring.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/LinearSpring.cpp	2006-01-03 13:36:18 UTC (rev 174)
+++ trunk/OpenFDM/src/OpenFDM/LinearSpring.cpp	2006-01-03 14:57:16 UTC (rev 175)
@@ -1,96 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
- *
- */
-
-#include "Model.h"
-#include "Vector.h"
-#include "LinearSpring.h"
-
-namespace OpenFDM {
-
-LinearSpring::LinearSpring(const std::string& name) :
-  Model(name),
-  mSpringReference(0),
-  mSpringConstant(0),
-  mDamperConstant(0)
-{
-}
-
-LinearSpring::~LinearSpring(void)
-{
-}
-
-bool
-LinearSpring::init(void)
-{
-  if (!getInputPort(0)->isConnected()) {
-    Log(Model, Error) << "Initialization of AirSpring model \"" << getName()
-                      << "\" failed: Input port \"" << getInputPortName(0)
-                      << "\" is not connected!" << endl;
-    return false;
-  }
-  mPositionPort = getInputPort(0)->toRealPortHandle();
-
-  if (!getInputPort(1)->isConnected()) {
-    Log(Model, Error) << "Initialization of AirSpring model \"" << getName()
-                      << "\" failed: Input port \"" << getInputPortName(1)
-                      << "\" is not connected!" << endl;
-    return false;
-  }
-  mVelocityPort = getInputPort(1)->toRealPortHandle();
-
-  return true;
-}
-
-void
-LinearSpring::output(const TaskInfo& taskInfo)
-{
-  real_type position = mPositionPort.getRealValue();
-  real_type vel = mVelocityPort.getRealValue();
-  real_type displacement = position - mSpringReference;
-  mForce = mSpringConstant*displacement + vel*mDamperConstant;
-}
-
-const real_type&
-LinearSpring::getForce(void) const
-{
-  return mForce;
-}
-
-real_type
-LinearSpring::getSpringReference(void) const
-{
-  return mSpringReference;
-}
-
-void
-LinearSpring::setSpringReference(real_type springReference)
-{
-  mSpringReference = springReference;
-}
-
-real_type
-LinearSpring::getSpringConstant(void) const
-{
-  return mSpringConstant;
-}
-
-void
-LinearSpring::setSpringConstant(real_type springConstant)
-{
-  mSpringConstant = springConstant;
-}
-
-real_type
-LinearSpring::getDamperConstant(void) const
-{
-  return mDamperConstant;
-}
-
-void
-LinearSpring::setDamperConstant(real_type damperConstant)
-{
-  mDamperConstant = damperConstant;
-}
-
-} // namespace OpenFDM

Deleted: trunk/OpenFDM/src/OpenFDM/LinearSpring.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/LinearSpring.h	2006-01-03 13:36:18 UTC (rev 174)
+++ trunk/OpenFDM/src/OpenFDM/LinearSpring.h	2006-01-03 14:57:16 UTC (rev 175)
@@ -1,51 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
- *
- */
-
-#ifndef OpenFDM_LinearSpring_H
-#define OpenFDM_LinearSpring_H
-
-#include <string>
-
-#include "Types.h"
-#include "Model.h"
-
-namespace OpenFDM {
-
-/// Linear spring damper model
-class LinearSpring :
-    public Model {
-public:
-  LinearSpring(const std::string& name);
-  virtual ~LinearSpring(void);
-
-  virtual bool init(void);
-  virtual void output(const TaskInfo& taskInfo);
-
-  const real_type& getForce(void) const;
-
-  real_type getSpringReference(void) const;
-  void setSpringReference(real_type springReference);
-
-  real_type getSpringConstant(void) const;
-  void setSpringConstant(real_type springConstant);
-
-  real_type getDamperConstant(void) const;
-  void setDamperConstant(real_type damperConstant);
-
-private:
-  real_type mSpringReference;
-  real_type mSpringConstant;
-  real_type mDamperConstant;
-
-  real_type mForce;
-
-  /// The intput port which must provide the position
-  RealPortHandle mPositionPort;
-  /// The intput port which must provide the velocity
-  RealPortHandle mVelocityPort;
-};
-
-} // namespace OpenFDM
-
-#endif

Copied: trunk/OpenFDM/src/OpenFDM/LinearSpringDamper.cpp (from rev 174, trunk/OpenFDM/src/OpenFDM/LinearSpring.cpp)
===================================================================
--- trunk/OpenFDM/src/OpenFDM/LinearSpring.cpp	2006-01-03 13:36:18 UTC (rev 174)
+++ trunk/OpenFDM/src/OpenFDM/LinearSpringDamper.cpp	2006-01-03 14:57:16 UTC (rev 175)
@@ -0,0 +1,96 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
+ *
+ */
+
+#include "Model.h"
+#include "Vector.h"
+#include "LinearSpringDamper.h"
+
+namespace OpenFDM {
+
+LinearSpringDamper::LinearSpringDamper(const std::string& name) :
+  Model(name),
+  mSpringReference(0),
+  mSpringConstant(0),
+  mDamperConstant(0)
+{
+}
+
+LinearSpringDamper::~LinearSpringDamper(void)
+{
+}
+
+bool
+LinearSpringDamper::init(void)
+{
+  if (!getInputPort(0)->isConnected()) {
+    Log(Model, Error) << "Initialization of AirSpring model \"" << getName()
+                      << "\" failed: Input port \"" << getInputPortName(0)
+                      << "\" is not connected!" << endl;
+    return false;
+  }
+  mPositionPort = getInputPort(0)->toRealPortHandle();
+
+  if (!getInputPort(1)->isConnected()) {
+    Log(Model, Error) << "Initialization of AirSpring model \"" << getName()
+                      << "\" failed: Input port \"" << getInputPortName(1)
+                      << "\" is not connected!" << endl;
+    return false;
+  }
+  mVelocityPort = getInputPort(1)->toRealPortHandle();
+
+  return true;
+}
+
+void
+LinearSpringDamper::output(const TaskInfo& taskInfo)
+{
+  real_type position = mPositionPort.getRealValue();
+  real_type vel = mVelocityPort.getRealValue();
+  real_type displacement = position - mSpringReference;
+  mForce = mSpringConstant*displacement + vel*mDamperConstant;
+}
+
+const real_type&
+LinearSpringDamper::getForce(void) const
+{
+  return mForce;
+}
+
+real_type
+LinearSpringDamper::getSpringReference(void) const
+{
+  return mSpringReference;
+}
+
+void
+LinearSpringDamper::setSpringReference(real_type springReference)
+{
+  mSpringReference = springReference;
+}
+
+real_type
+LinearSpringDamper::getSpringConstant(void) const
+{
+  return mSpringConstant;
+}
+
+void
+LinearSpringDamper::setSpringConstant(real_type springConstant)
+{
+  mSpringConstant = springConstant;
+}
+
+real_type
+LinearSpringDamper::getDamperConstant(void) const
+{
+  return mDamperConstant;
+}
+
+void
+LinearSpringDamper::setDamperConstant(real_type damperConstant)
+{
+  mDamperConstant = damperConstant;
+}
+
+} // namespace OpenFDM

Copied: trunk/OpenFDM/src/OpenFDM/LinearSpringDamper.h (from rev 174, trunk/OpenFDM/src/OpenFDM/LinearSpring.h)
===================================================================
--- trunk/OpenFDM/src/OpenFDM/LinearSpring.h	2006-01-03 13:36:18 UTC (rev 174)
+++ trunk/OpenFDM/src/OpenFDM/LinearSpringDamper.h	2006-01-03 14:57:16 UTC (rev 175)
@@ -0,0 +1,51 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_LinearSpringDamper_H
+#define OpenFDM_LinearSpringDamper_H
+
+#include <string>
+
+#include "Types.h"
+#include "Model.h"
+
+namespace OpenFDM {
+
+/// Linear spring damper model
+class LinearSpringDamper :
+    public Model {
+public:
+  LinearSpringDamper(const std::string& name);
+  virtual ~LinearSpringDamper(void);
+
+  virtual bool init(void);
+  virtual void output(const TaskInfo& taskInfo);
+
+  const real_type& getForce(void) const;
+
+  real_type getSpringReference(void) const;
+  void setSpringReference(real_type springReference);
+
+  real_type getSpringConstant(void) const;
+  void setSpringConstant(real_type springConstant);
+
+  real_type getDamperConstant(void) const;
+  void setDamperConstant(real_type damperConstant);
+
+private:
+  real_type mSpringReference;
+  real_type mSpringConstant;
+  real_type mDamperConstant;
+
+  real_type mForce;
+
+  /// The intput port which must provide the position
+  RealPortHandle mPositionPort;
+  /// The intput port which must provide the velocity
+  RealPortHandle mVelocityPort;
+};
+
+} // namespace OpenFDM
+
+#endif

Modified: trunk/OpenFDM/src/OpenFDM/Makefile.am
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Makefile.am	2006-01-03 13:36:18 UTC (rev 174)
+++ trunk/OpenFDM/src/OpenFDM/Makefile.am	2006-01-03 14:57:16 UTC (rev 175)
@@ -72,7 +72,7 @@
   LinAlg/IO.h \
   LinAlg/Misc.h \
   LinAlg/Proxy.h \
-  LinearSpring.h \
+  LinearSpringDamper.h \
   LogStream.h \
   Mass.h \
   Math.h \
@@ -168,7 +168,7 @@
   Interact.cpp \
   ImplicitEuler.cpp \
   Joint.cpp \
-  LinearSpring.cpp \
+  LinearSpringDamper.cpp \
   Logger.cpp \
   Mass.cpp \
   MaxModel.cpp \



From frohlich at berlios.de  Tue Jan  3 16:52:57 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Tue, 3 Jan 2006 16:52:57 +0100
Subject: [OpenFDM-svn] r176 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200601031552.k03FqvBp030056@sheep.berlios.de>

Author: frohlich
Date: 2006-01-03 16:52:53 +0100 (Tue, 03 Jan 2006)
New Revision: 176

Modified:
   trunk/OpenFDM/src/OpenFDM/AeroForce.cpp
   trunk/OpenFDM/src/OpenFDM/Contact.cpp
   trunk/OpenFDM/src/OpenFDM/Force.h
   trunk/OpenFDM/src/OpenFDM/WheelContact.cpp
Log:
Zap an other FIXME


Modified: trunk/OpenFDM/src/OpenFDM/AeroForce.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/AeroForce.cpp	2006-01-03 14:57:16 UTC (rev 175)
+++ trunk/OpenFDM/src/OpenFDM/AeroForce.cpp	2006-01-03 15:52:53 UTC (rev 176)
@@ -245,12 +245,16 @@
 AeroForce::getRefPosition(void) const
 {
   if (mDirtyRefPosition) {
-    const Frame* frame = getParentFrame(0);
-    OpenFDMAssert(frame);
-    if (frame) {
-      // Get the position in the earth centered coordinate frame.
-      mRefPosition = frame->posToRef(getPosition());
-      mDirtyRefPosition = false;
+    const RigidBody* body = getParentRigidBody(0);
+    OpenFDMAssert(body);
+    if (body) {
+      const Frame* frame = body->getFrame();
+      OpenFDMAssert(frame);
+      if (frame) {
+        // Get the position in the earth centered coordinate frame.
+        mRefPosition = frame->posToRef(getPosition());
+        mDirtyRefPosition = false;
+      }
     }
   }
   Log(ArtBody, Debug3) << "AeroForce::getRefPosition()"
@@ -262,22 +266,26 @@
 AeroForce::getAirSpeed(void) const
 {
   if (mDirtyAirSpeed) {
-    const Frame* frame = getParentFrame(0);
-    OpenFDMAssert(frame);
-    if (frame) {
-      // FIXME temporary workaround
-      if (!mEnvironment) {
-        const_cast<AeroForce*>(this)->mEnvironment = getEnvironment();
+    const RigidBody* body = getParentRigidBody(0);
+    OpenFDMAssert(body);
+    if (body) {
+      const Frame* frame = body->getFrame();
+      OpenFDMAssert(frame);
+      if (frame) {
+        // FIXME temporary workaround
+        if (!mEnvironment) {
+          const_cast<AeroForce*>(this)->mEnvironment = getEnvironment();
+        }
+        // Get the position in the earth centered coordinate frame.
+        Vector3 pos = frame->posToRef(getPosition());
+        Vector3 windVel = mEnvironment->getWind()->getWindVel(pos);
+        windVel = frame->rotFromRef(windVel);
+        Vector6 sAirSpeed = Vector6(Vector3::zeros(), windVel)
+          - frame->motionFromRef(Vector6::zeros());
+        mAirSpeed = motionTo(getPosition(), getOrientation(), sAirSpeed);
+        
+        mDirtyAirSpeed = false;
       }
-      // Get the position in the earth centered coordinate frame.
-      Vector3 pos = frame->posToRef(getPosition());
-      Vector3 windVel = mEnvironment->getWind()->getWindVel(pos);
-      windVel = frame->rotFromRef(windVel);
-      Vector6 sAirSpeed = Vector6(Vector3::zeros(), windVel)
-        - frame->motionFromRef(Vector6::zeros());
-      mAirSpeed = motionTo(getPosition(), getOrientation(), sAirSpeed);
-      
-      mDirtyAirSpeed = false;
     }
   }
   Log(ArtBody, Debug3) << "AeroForce::getAirSpeed()"
@@ -625,16 +633,20 @@
 AeroForce::getUnitDown(void) const
 {
   if (mDirtyUnitDown) {
-    const Frame* frame = getParentFrame(0);
-    OpenFDMAssert(frame);
-    if (frame) {
-      // Compute the geodetic unit down vector at our current position.
-      // So we will need the orientation of the horizontal local frame at our
-      // current position.
-      Quaternion gcHL = getPlanet()->getGeocHLOrientation(getRefPosition());
-      // Transform that unit down vector to the current frame.
-      mUnitDown = frame->rotFromRef(gcHL.backTransform(Vector3::unit(3)));
-      mDirtyUnitDown = false;
+    const RigidBody* body = getParentRigidBody(0);
+    OpenFDMAssert(body);
+    if (body) {
+      const Frame* frame = body->getFrame();
+      OpenFDMAssert(frame);
+      if (frame) {
+        // Compute the geodetic unit down vector at our current position.
+        // So we will need the orientation of the horizontal local frame at our
+        // current position.
+        Quaternion gcHL = getPlanet()->getGeocHLOrientation(getRefPosition());
+        // Transform that unit down vector to the current frame.
+        mUnitDown = frame->rotFromRef(gcHL.backTransform(Vector3::unit(3)));
+        mDirtyUnitDown = false;
+      }
     }
   }
   return mUnitDown;
@@ -644,12 +656,16 @@
 AeroForce::getLocalGroundPlane(void) const
 {
   if (mDirtyLocalGroundPlane) {
-    const Frame* frame = getParentFrame(0);
-    OpenFDMAssert(frame);
-    if (frame) {
-      // Transform the plane equation to the local frame.
-      mLocalGroundPlane = frame->planeFromRef(mGroundVal.plane);
-      mDirtyLocalGroundPlane = false;
+    const RigidBody* body = getParentRigidBody(0);
+    OpenFDMAssert(body);
+    if (body) {
+      const Frame* frame = body->getFrame();
+      OpenFDMAssert(frame);
+      if (frame) {
+        // Transform the plane equation to the local frame.
+        mLocalGroundPlane = frame->planeFromRef(mGroundVal.plane);
+        mDirtyLocalGroundPlane = false;
+      }
     }
   }
   return mLocalGroundPlane;

Modified: trunk/OpenFDM/src/OpenFDM/Contact.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Contact.cpp	2006-01-03 14:57:16 UTC (rev 175)
+++ trunk/OpenFDM/src/OpenFDM/Contact.cpp	2006-01-03 15:52:53 UTC (rev 176)
@@ -61,9 +61,20 @@
 void
 Contact::computeForce(void)
 {
-  const Frame* frame = getParentFrame(0);
+  if (!mEnabled) {
+    applyForce(Vector6::zeros());
+    return;
+  }
+
+  const RigidBody* body = getParentRigidBody(0);
+  OpenFDMAssert(body);
+  if (!body) {
+    applyForce(Vector6::zeros());
+    return;
+  }
+  const Frame* frame = body->getFrame();
   OpenFDMAssert(frame);
-  if (!frame || !mEnabled) {
+  if (!frame) {
     applyForce(Vector6::zeros());
     return;
   }
@@ -127,7 +138,11 @@
 void
 Contact::getGround(real_type t)
 {
-  const Frame* frame = getParentFrame(0);
+  const RigidBody* body = getParentRigidBody(0);
+  OpenFDMAssert(body);
+  if (!body)
+    return;
+  const Frame* frame = body->getFrame();
   OpenFDMAssert(frame);
   if (!frame)
     return;

Modified: trunk/OpenFDM/src/OpenFDM/Force.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Force.h	2006-01-03 14:57:16 UTC (rev 175)
+++ trunk/OpenFDM/src/OpenFDM/Force.h	2006-01-03 15:52:53 UTC (rev 176)
@@ -50,17 +50,6 @@
     mForce = force;
   }
 
-  /// FIXME remove
-  const Frame* getParentFrame(unsigned id = 0) const
-  {
-    return getParentRigidBody(id)->getFrame();
-  }
-  /// FIXME remove
-  Frame* getParentFrame(unsigned id = 0)
-  {
-    return getParentRigidBody(id)->getFrame();
-  }
-
 private:
   Vector6 mForce;
 };

Modified: trunk/OpenFDM/src/OpenFDM/WheelContact.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/WheelContact.cpp	2006-01-03 14:57:16 UTC (rev 175)
+++ trunk/OpenFDM/src/OpenFDM/WheelContact.cpp	2006-01-03 15:52:53 UTC (rev 176)
@@ -55,7 +55,13 @@
 {
   // FIXME: check all signs here, I get the feeling that we have
   // just even much minuses here instead of exactly the right ones ...
-  const Frame* frame = getParentFrame(0);
+  const RigidBody* body = getParentRigidBody(0);
+  OpenFDMAssert(body);
+  if (!body) {
+    applyForce(Vector6::zeros());
+    return;
+  }
+  const Frame* frame = body->getFrame();
   OpenFDMAssert(frame);
   if (!frame) {
     applyForce(Vector6::zeros());
@@ -165,7 +171,11 @@
 void
 WheelContact::getGround(real_type t)
 {
-  const Frame* frame = getParentFrame(0);
+  const RigidBody* body = getParentRigidBody(0);
+  OpenFDMAssert(body);
+  if (!body)
+    return;
+  const Frame* frame = body->getFrame();
   OpenFDMAssert(frame);
   if (!frame)
     return;



From frohlich at berlios.de  Tue Jan  3 17:03:42 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Tue, 3 Jan 2006 17:03:42 +0100
Subject: [OpenFDM-svn] r177 - trunk/flightgear
Message-ID: <200601031603.k03G3gQb031242@sheep.berlios.de>

Author: frohlich
Date: 2006-01-03 17:03:39 +0100 (Tue, 03 Jan 2006)
New Revision: 177

Modified:
   trunk/flightgear/FGOpenFDM.cpp
   trunk/flightgear/FGPropertyAdapter.h
Log:
Make use of the trim routines,
fix a crash on reset


Modified: trunk/flightgear/FGOpenFDM.cpp
===================================================================
--- trunk/flightgear/FGOpenFDM.cpp	2006-01-03 15:52:53 UTC (rev 176)
+++ trunk/flightgear/FGOpenFDM.cpp	2006-01-03 16:03:39 UTC (rev 177)
@@ -304,8 +304,8 @@
   if (stateChanged) {
     SG_LOG(SG_FLIGHT, SG_INFO, "State changed ------------------------------");
 //     printVehicle(vehicle);
-//     vehicle->init();
-//     vehicle->trim();
+    vehicle->init();
+    vehicle->trim();
 //     printVehicle(vehicle);
   }
 

Modified: trunk/flightgear/FGPropertyAdapter.h
===================================================================
--- trunk/flightgear/FGPropertyAdapter.h	2006-01-03 15:52:53 UTC (rev 176)
+++ trunk/flightgear/FGPropertyAdapter.h	2006-01-03 16:03:39 UTC (rev 177)
@@ -170,7 +170,10 @@
   virtual ~InputChangeUserData(void)
   {
     // Also deregisters itself at the SGPropertyNode.
-    delete mListener;
+    // is deleted in the property system, don't do here
+    // FIXME: this might be a place where we can use the new refcounting thing
+    // of flightgear
+//     delete mListener;
   }
 private:
   InputChangeListener* mListener;



From frohlich at berlios.de  Tue Jan  3 18:15:49 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Tue, 3 Jan 2006 18:15:49 +0100
Subject: [OpenFDM-svn] r178 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200601031715.k03HFnn7007422@sheep.berlios.de>

Author: frohlich
Date: 2006-01-03 18:15:46 +0100 (Tue, 03 Jan 2006)
New Revision: 178

Modified:
   trunk/OpenFDM/src/OpenFDM/AeroForce.cpp
Log:
Use real stability frame instead of negating
lift and drag


Modified: trunk/OpenFDM/src/OpenFDM/AeroForce.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/AeroForce.cpp	2006-01-03 16:03:39 UTC (rev 177)
+++ trunk/OpenFDM/src/OpenFDM/AeroForce.cpp	2006-01-03 17:15:46 UTC (rev 178)
@@ -679,32 +679,26 @@
   real_type sa = sin(getAlpha());
   real_type cb = cos(getBeta());
   real_type sb = sin(getBeta());
-  Matrix33 Ts2b(ca*cb, -ca*sb, -sa,
-                   sb,     cb,   0,
-                sa*cb, -sa*sb,  ca);
+  Matrix33 Ts2b(-ca*cb, -ca*sb,  sa,
+                   -sb,     cb,   0,
+                -sa*cb, -sa*sb, -ca);
 
   // This is simple here. Just collect all summands ...
-  Vector6 force = Vector6::zeros();
+  Vector3 stabilityForce = Vector3::zeros();
   /// Lift points upward
   /// Drag points backward
-  /// FIXME: may be we can put that already into the rotation matrix?
-  if (mStabilityAxisForce[0].isConnected())
-    force(4) -= mStabilityAxisForce[0].getRealValue();
-  if (mStabilityAxisForce[1].isConnected())
-    force(5) += mStabilityAxisForce[1].getRealValue();
-  if (mStabilityAxisForce[2].isConnected())
-    force(6) -= mStabilityAxisForce[2].getRealValue();
+  for (int i = 0; i < 3; ++i)
+    if (mStabilityAxisForce[i].isConnected())
+      stabilityForce(i+1) = mStabilityAxisForce[i].getRealValue();
 
-  force.setAngular(Ts2b*force.getAngular());
-  force.setLinear(Ts2b*force.getLinear());
-
+  Vector3 bodyTorque = Vector3::zeros();
   for (int i = 0; i < 3; ++i)
     if (mBodyAxisTorque[i].isConnected())
-      force(i+1) += mBodyAxisTorque[i].getRealValue();
+      bodyTorque(i+1) = mBodyAxisTorque[i].getRealValue();
 
+  Vector6 force(bodyTorque, Ts2b*stabilityForce);
   Log(ArtBody, Debug3) << "AeroForce::computeForce() "
                        << trans(force) << endl;
-
   applyForce(forceFrom(mPosition, mOrientation, force));
 }
 



From frohlich at berlios.de  Wed Jan  4 13:04:05 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Wed, 4 Jan 2006 13:04:05 +0100
Subject: [OpenFDM-svn] r179 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200601041204.k04C459c005668@sheep.berlios.de>

Author: frohlich
Date: 2006-01-04 13:04:02 +0100 (Wed, 04 Jan 2006)
New Revision: 179

Modified:
   trunk/OpenFDM/src/OpenFDM/AirSpring.cpp
Log:
Check for a real value not only for connectivity


Modified: trunk/OpenFDM/src/OpenFDM/AirSpring.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/AirSpring.cpp	2006-01-03 17:15:46 UTC (rev 178)
+++ trunk/OpenFDM/src/OpenFDM/AirSpring.cpp	2006-01-04 12:04:02 UTC (rev 179)
@@ -36,21 +36,21 @@
 bool
 AirSpring::init(void)
 {
-  if (!getInputPort(0)->isConnected()) {
+  mPositionPort = getInputPort(0)->toRealPortHandle();
+  if (!mPositionPort.isConnected()) {
     Log(Model, Error) << "Initialization of AirSpring model \"" << getName()
                       << "\" failed: Input port \"" << getInputPortName(0)
                       << "\" is not connected!" << endl;
     return false;
   }
-  mPositionPort = getInputPort(0)->toRealPortHandle();
 
-  if (!getInputPort(1)->isConnected()) {
+  mVelocityPort = getInputPort(1)->toRealPortHandle();
+  if (!mVelocityPort.isConnected()) {
     Log(Model, Error) << "Initialization of AirSpring model \"" << getName()
                       << "\" failed: Input port \"" << getInputPortName(1)
                       << "\" is not connected!" << endl;
     return false;
   }
-  mVelocityPort = getInputPort(1)->toRealPortHandle();
 
   return true;
 }



From frohlich at berlios.de  Wed Jan  4 14:38:28 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Wed, 4 Jan 2006 14:38:28 +0100
Subject: [OpenFDM-svn] r180 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200601041338.k04DcSqE019521@sheep.berlios.de>

Author: frohlich
Date: 2006-01-04 14:38:25 +0100 (Wed, 04 Jan 2006)
New Revision: 180

Modified:
   trunk/OpenFDM/src/OpenFDM/Frame.h
Log:
Fix relative position computation


Modified: trunk/OpenFDM/src/OpenFDM/Frame.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Frame.h	2006-01-04 12:04:02 UTC (rev 179)
+++ trunk/OpenFDM/src/OpenFDM/Frame.h	2006-01-04 13:38:25 UTC (rev 180)
@@ -468,7 +468,7 @@
   Vector3 getRelPosition(const Frame* frame) const
   {
     OpenFDMAssert(frame->getRefFrameId() == getRefFrameId());
-    return getRelOrientation(frame).backTransform(frame->getRefPosition());
+    return posFromRef(frame->getRefPosition());
   }
   Vector6 getRelVel(const Frame* frame) const
   {



From frohlich at berlios.de  Wed Jan  4 14:38:54 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Wed, 4 Jan 2006 14:38:54 +0100
Subject: [OpenFDM-svn] r181 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200601041338.k04DcsMQ019631@sheep.berlios.de>

Author: frohlich
Date: 2006-01-04 14:38:48 +0100 (Wed, 04 Jan 2006)
New Revision: 181

Modified:
   trunk/OpenFDM/src/OpenFDM/LinearSpringDamper.cpp
Log:
Add missing input/ouput port definitions


Modified: trunk/OpenFDM/src/OpenFDM/LinearSpringDamper.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/LinearSpringDamper.cpp	2006-01-04 13:38:25 UTC (rev 180)
+++ trunk/OpenFDM/src/OpenFDM/LinearSpringDamper.cpp	2006-01-04 13:38:48 UTC (rev 181)
@@ -14,6 +14,14 @@
   mSpringConstant(0),
   mDamperConstant(0)
 {
+  setDirectFeedThrough(true);
+
+  setNumInputPorts(2);
+  setInputPortName(0, "position");
+  setInputPortName(1, "velocity");
+  
+  setNumOutputPorts(1);
+  setOutputPort(0, "force", this, &LinearSpringDamper::getForce);
 }
 
 LinearSpringDamper::~LinearSpringDamper(void)



From frohlich at berlios.de  Thu Jan  5 00:22:07 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Thu, 5 Jan 2006 00:22:07 +0100
Subject: [OpenFDM-svn] r182 - in trunk/OpenFDM/src: JSBSim OpenFDM
Message-ID: <200601042322.k04NM7OH014303@sheep.berlios.de>

Author: frohlich
Date: 2006-01-05 00:21:57 +0100 (Thu, 05 Jan 2006)
New Revision: 182

Modified:
   trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
   trunk/OpenFDM/src/OpenFDM/AeroForce.cpp
   trunk/OpenFDM/src/OpenFDM/Contact.cpp
   trunk/OpenFDM/src/OpenFDM/Force.h
   trunk/OpenFDM/src/OpenFDM/Frame.h
   trunk/OpenFDM/src/OpenFDM/LinearSpringDamper.cpp
   trunk/OpenFDM/src/OpenFDM/LinearSpringDamper.h
   trunk/OpenFDM/src/OpenFDM/MobileRootJoint.cpp
   trunk/OpenFDM/src/OpenFDM/RigidBody.h
   trunk/OpenFDM/src/OpenFDM/WheelContact.cpp
Log:
Updates for support of internal forces.
Fixes of the frame codes and model scheduling.


Modified: trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
===================================================================
--- trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2006-01-04 13:38:48 UTC (rev 181)
+++ trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2006-01-04 23:21:57 UTC (rev 182)
@@ -1153,7 +1153,7 @@
       // This is the movable part of the strut, doing the compression
       RigidBody* arm = new RigidBody(name + " Arm");
       mVehicle->getMultiBodySystem()->addRigidBody(arm);
-      arm->addInteract(new Mass(name + " Strut Mass", inertiaFrom(Vector3(-1, 0, 0), SpatialInertia(100))));
+      arm->addInteract(new Mass(name + " Strut Mass", inertiaFrom(Vector3(-1, 0, 0), SpatialInertia(80))));
 
       // Connect that with a revolute joint to the main body
       RevoluteJoint* rj = new RevoluteJoint(name + " Arm Joint");

Modified: trunk/OpenFDM/src/OpenFDM/AeroForce.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/AeroForce.cpp	2006-01-04 13:38:48 UTC (rev 181)
+++ trunk/OpenFDM/src/OpenFDM/AeroForce.cpp	2006-01-04 23:21:57 UTC (rev 182)
@@ -281,7 +281,7 @@
         Vector3 windVel = mEnvironment->getWind()->getWindVel(pos);
         windVel = frame->rotFromRef(windVel);
         Vector6 sAirSpeed = Vector6(Vector3::zeros(), windVel)
-          - frame->motionFromRef(Vector6::zeros());
+          + frame->getRefVel();
         mAirSpeed = motionTo(getPosition(), getOrientation(), sAirSpeed);
         
         mDirtyAirSpeed = false;

Modified: trunk/OpenFDM/src/OpenFDM/Contact.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Contact.cpp	2006-01-04 13:38:48 UTC (rev 181)
+++ trunk/OpenFDM/src/OpenFDM/Contact.cpp	2006-01-04 23:21:57 UTC (rev 182)
@@ -92,7 +92,9 @@
   }
   
   // The velocity of the ground patch in the current frame.
-  Vector6 groundVel = frame->motionFromRef(mGroundVal.vel);
+  Vector6 groundVel(frame->rotFromRef(mGroundVal.vel.getAngular()),
+                    frame->rotFromRef(mGroundVal.vel.getLinear()));
+  groundVel -= frame->getRefVel();
   // Now get the relative velocity of the ground wrt the contact point
   Vector3 relVel = - motionTo(getPosition(), groundVel).getLinear();
 

Modified: trunk/OpenFDM/src/OpenFDM/Force.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Force.h	2006-01-04 13:38:48 UTC (rev 181)
+++ trunk/OpenFDM/src/OpenFDM/Force.h	2006-01-04 23:21:57 UTC (rev 182)
@@ -22,24 +22,53 @@
 
 };
 
-class ExternalForce
-  : public Force {
+class ExternalForce :
+    public Force {
 public:
-  ExternalForce(const std::string& name)
-    : Force(name, 1), mForce(0, 0, 0, 0, 0, 0)
-  {}
+  ExternalForce(const std::string& name) :
+    Force(name, 1),
+    mForce(0, 0, 0, 0, 0, 0)
+  {
+    mMountFrame = new FreeFrame(name);
+
+    addProperty("position", Property(this, &ExternalForce::getPosition, &ExternalForce::setPosition));
+    addProperty("orientation", Property(this, &ExternalForce::getOrientation, &ExternalForce::setOrientation));
+  }
   virtual ~ExternalForce(void) {}
 
+  virtual void recheckTopology(void)
+  {
+    if (!getParentRigidBody(0))
+      return;
+  
+    // check for the frames
+    Frame* frame = getParentRigidBody(0)->getFrame();
+    if (!frame)
+      return;
+    if (!mMountFrame->isDirectChildFrameOf(frame))
+      frame->addChildFrame(mMountFrame);
+  }
+
   // Needs to call applyForce once ...
   virtual void interactWith(RigidBody* rigidBody)
   {
     computeForce();
-    rigidBody->contributeForce(-mForce);
+    rigidBody->applyForce(mForce);
   }
 
   /// FIXME here for compatibility
   virtual void computeForce(void) = 0;
 
+  const Vector3& getPosition(void) const
+  { return mMountFrame->getPosition(); }
+  void setPosition(const Vector3& pos)
+  { mMountFrame->setPosition(pos); }
+
+  const Quaternion& getOrientation(void) const
+  { return mMountFrame->getOrientation(); }
+  void setOrientation(const Quaternion& pos)
+  { mMountFrame->setOrientation(pos); }
+
 protected:
   /** Sets the force contribution of this force element.
    * Sets the force contribution of this current force element to
@@ -51,9 +80,190 @@
   }
 
 private:
+  SharedPtr<FreeFrame> mMountFrame;
   Vector6 mForce;
 };
 
+class InternalForce :
+    public Force {
+public:
+  InternalForce(const std::string& name) :
+    Force(name, 2),
+    mForce(0, 0, 0, 0, 0, 0)
+  {
+    mMountFrame[0] = new FreeFrame(name  + "<0>");
+    mMountFrame[1] = new FreeFrame(name  + "<1>");
+
+    addProperty("position0", Property(this, &InternalForce::getPosition0, &InternalForce::setPosition0));
+    addProperty("orientation0", Property(this, &InternalForce::getOrientation0, &InternalForce::setOrientation0));
+    addProperty("position1", Property(this, &InternalForce::getPosition1, &InternalForce::setPosition1));
+    addProperty("orientation1", Property(this, &InternalForce::getOrientation1, &InternalForce::setOrientation1));
+
+  }
+  virtual ~InternalForce(void) {}
+
+  virtual void recheckTopology(void)
+  {
+    if (!getParentRigidBody(0) || !getParentRigidBody(1))
+      return;
+  
+    // check for the frames
+    Frame* frame0 = getParentRigidBody(0)->getFrame();
+    if (!frame0)
+      return;
+    if (!mMountFrame[0]->isDirectChildFrameOf(frame0))
+      frame0->addChildFrame(mMountFrame[0]);
+    Frame* frame1 = getParentRigidBody(1)->getFrame();
+    if (!frame1)
+      return;
+    if (!mMountFrame[1]->isDirectChildFrameOf(frame1))
+      frame1->addChildFrame(mMountFrame[1]);
+  }
+
+  // Needs to call applyForce once ...
+  virtual void interactWith(RigidBody* rigidBody)
+  {
+#if 1
+    /// ORIG
+//     Log(Model,Error) << "InternalForce \"" << getName() << "\""
+//                      << " interacting with RigidBody \""
+//                      << rigidBody->getName() << "\"" << endl;
+//     Log(Model,Error) << trans(mForce) << endl;
+
+    if (rigidBody->getFrame()->isDirectParentFrameOf(mMountFrame[0])) {
+      Vector6 parentForce = mMountFrame[0]->forceToParent(mForce);
+      //       Log(Model,Error) << trans(parentForce) << endl;
+      rigidBody->applyForce(parentForce);
+    } else if (rigidBody->getFrame()->isDirectParentFrameOf(mMountFrame[1])) {
+      Rotation relOr = mMountFrame[0]->getRelOrientation(mMountFrame[1]);
+//       Log(Model,Error) << relOr << rigidBody->getFrame()->getOrientation() << endl;
+      Vector6 force2(relOr.transform(mForce.getAngular()),
+                     relOr.transform(mForce.getLinear()));
+      Vector6 parentForce = mMountFrame[1]->forceToParent(force2);
+      //      Log(Model,Error) << trans(parentForce) << endl;
+      rigidBody->applyForce(-parentForce);
+    }
+#else
+    if (rigidBody->getFrame()->isDirectParentFrameOf(mMountFrame[1])) {
+      Vector6 parentForce = mMountFrame[1]->forceToParent(mForce);
+      rigidBody->applyForce(parentForce);
+    } else if (rigidBody->getFrame()->isDirectParentFrameOf(mMountFrame[0])) {
+      Rotation relOr = mMountFrame[1]->getRelOrientation(mMountFrame[0]);
+      Vector6 force2(relOr.backTransform(mForce.getAngular()),
+                     relOr.backTransform(mForce.getLinear()));
+      Vector6 parentForce = mMountFrame[0]->forceToParent(mForce);
+      rigidBody->applyForce(parentForce);
+    }
+#endif
+  }
+
+  const Vector3& getPosition0(void) const
+  { return mMountFrame[0]->getPosition(); }
+  void setPosition0(const Vector3& pos)
+  { mMountFrame[0]->setPosition(pos); }
+
+  const Quaternion& getOrientation0(void) const
+  { return mMountFrame[0]->getOrientation(); }
+  void setOrientation0(const Quaternion& pos)
+  { mMountFrame[0]->setOrientation(pos); }
+
+  const Vector3& getPosition1(void) const
+  { return mMountFrame[1]->getPosition(); }
+  void setPosition1(const Vector3& pos)
+  { mMountFrame[1]->setPosition(pos); }
+
+  const Quaternion& getOrientation1(void) const
+  { return mMountFrame[1]->getOrientation(); }
+  void setOrientation1(const Quaternion& pos)
+  { mMountFrame[1]->setOrientation(pos); }
+
+protected:
+  SharedPtr<FreeFrame> mMountFrame[2];
+  Vector6 mForce;
+};
+
+class LineForce :
+    public InternalForce {
+public:
+  LineForce(const std::string& name) :
+    InternalForce(name)
+  {
+    addProperty("relPos", Property(this, &LineForce::getRelPos));
+    addProperty("relVel", Property(this, &LineForce::getRelVel));
+
+    addOutputPort("relPos", this, &LineForce::getRelPos);
+    addOutputPort("relVel", this, &LineForce::getRelVel);
+
+    setNumInputPorts(1);
+    setInputPortName(0, "force");
+  }
+  virtual ~LineForce(void) {}
+
+  virtual bool init(void)
+  {
+    mForcePort = getInputPort("force")->toRealPortHandle();
+    if (!mForcePort.isConnected()) {
+      Log(Model, Error) << "Initialization of LineForce model \"" << getName()
+                        << "\" failed: Input port \"" << getInputPortName(0)
+                        << "\" is not connected!" << endl;
+      return false;
+    }
+    return InternalForce::init();
+  }
+  virtual void output(const TaskInfo& taskInfo)
+  {
+    Vector3 dir;
+    // FIXME: this is costly, must do something aprioriate with
+    // models/ports
+    Vector3 relPos = mMountFrame[0]->getRelPosition(mMountFrame[1]);
+    // if we have really reached the zero position, we must have the full
+    // speed in exactly the relPos direction.
+    real_type nrmRelPos = norm(relPos);
+    if (nrmRelPos < Limits<real_type>::min()) {
+      Vector6 relVel6 = mMountFrame[0]->getRelVel(mMountFrame[1]);
+      dir = normalize(relVel6.getLinear());
+    } else
+      dir = (1/nrmRelPos)*relPos;
+    mForce = Vector6(Vector3::zeros(), dir*mForcePort.getRealValue());
+//     Log(Model,Error)
+//       << trans(relPos)
+//       << trans(mMountFrame[0]->getRelVel(mMountFrame[1])) << " "
+//       << mRelPos << " "
+//       << mRelVel
+//       << endl;
+  }
+
+  const real_type& getRelPos(void) const
+  {
+    // FIXME: this is costly, must do something aprioriate with
+    // models/ports
+    mRelPos = norm(mMountFrame[0]->getRelPosition(mMountFrame[1]));
+    return mRelPos;
+  }
+  const real_type& getRelVel(void) const
+  {
+    // FIXME: this is costly, must do something aprioriate with
+    // models/ports
+    Vector3 relPos = mMountFrame[0]->getRelPosition(mMountFrame[1]);
+    Vector6 relVel6 = mMountFrame[0]->getRelVel(mMountFrame[1]);
+    // if we have really reached the zero position, we must have the full
+    // speed in exactly the relPos direction.
+    real_type nrmRelPos = norm(relPos);
+    if (nrmRelPos < Limits<real_type>::min())
+      mRelVel = norm(relVel6.getLinear());
+    else
+      mRelVel = dot(relPos, relVel6.getLinear())/nrmRelPos;
+    return mRelVel;
+  }
+
+private:
+  mutable real_type mRelPos;
+  mutable real_type mRelVel;
+
+  /// The intput port which must provide the position
+  RealPortHandle mForcePort;
+};
+
 } // namespace OpenFDM
 
 #endif

Modified: trunk/OpenFDM/src/OpenFDM/Frame.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Frame.h	2006-01-04 13:38:48 UTC (rev 181)
+++ trunk/OpenFDM/src/OpenFDM/Frame.h	2006-01-04 23:21:57 UTC (rev 182)
@@ -401,7 +401,7 @@
       @return  The motion vector transformed to the current frame.
    */
   Vector6 motionFromRef(const Vector6& v) const
-  { return motionTo(getRefPosition(), getRefOrientation(), v) - getRefVel(); }
+  { return motionTo(getRefPosition(), getRefOrientation(), v); }
 
   /** Spatial motion vector transform.
       Transforms a spatial motion vector from the current frame to the parent
@@ -410,7 +410,7 @@
       @return  The motion vector transformed to the parent frame.
    */
   Vector6 motionToRef(const Vector6& v) const
-  { return motionFrom(getRefPosition(), getRefOrientation(), v + getRefVel()); }
+  { return motionFrom(getRefPosition(), getRefOrientation(), v); }
 
   Plane planeFromRef(const Plane& plane) const
   { return planeTo(getRefPosition(), getRefOrientation(), plane); }
@@ -463,7 +463,7 @@
   Quaternion getRelOrientation(const Frame* frame) const
   {
     OpenFDMAssert(frame->getRefFrameId() == getRefFrameId());
-    return conjugate(getRefOrientation())*frame->getRefOrientation();
+    return inverse(getRefOrientation())*frame->getRefOrientation();
   }
   Vector3 getRelPosition(const Frame* frame) const
   {
@@ -473,7 +473,7 @@
   Vector6 getRelVel(const Frame* frame) const
   {
     OpenFDMAssert(frame->getRefFrameId() == getRefFrameId());
-    return motionFromRef(frame->motionToRef(frame->getRefVel()));
+    return motionFromRef(frame->motionToRef(frame->getRefVel())) - getRefVel();
   }
 
 protected:

Modified: trunk/OpenFDM/src/OpenFDM/LinearSpringDamper.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/LinearSpringDamper.cpp	2006-01-04 13:38:48 UTC (rev 181)
+++ trunk/OpenFDM/src/OpenFDM/LinearSpringDamper.cpp	2006-01-04 23:21:57 UTC (rev 182)
@@ -16,6 +16,10 @@
 {
   setDirectFeedThrough(true);
 
+  addProperty("springReference", Property(this, &LinearSpringDamper::getSpringReference, &LinearSpringDamper::setSpringReference));
+  addProperty("springConstant", Property(this, &LinearSpringDamper::getSpringConstant, &LinearSpringDamper::setSpringConstant));
+  addProperty("damperConstant", Property(this, &LinearSpringDamper::getDamperConstant, &LinearSpringDamper::setDamperConstant));
+
   setNumInputPorts(2);
   setInputPortName(0, "position");
   setInputPortName(1, "velocity");
@@ -65,38 +69,38 @@
   return mForce;
 }
 
-real_type
+const real_type&
 LinearSpringDamper::getSpringReference(void) const
 {
   return mSpringReference;
 }
 
 void
-LinearSpringDamper::setSpringReference(real_type springReference)
+LinearSpringDamper::setSpringReference(const real_type& springReference)
 {
   mSpringReference = springReference;
 }
 
-real_type
+const real_type&
 LinearSpringDamper::getSpringConstant(void) const
 {
   return mSpringConstant;
 }
 
 void
-LinearSpringDamper::setSpringConstant(real_type springConstant)
+LinearSpringDamper::setSpringConstant(const real_type& springConstant)
 {
   mSpringConstant = springConstant;
 }
 
-real_type
+const real_type&
 LinearSpringDamper::getDamperConstant(void) const
 {
   return mDamperConstant;
 }
 
 void
-LinearSpringDamper::setDamperConstant(real_type damperConstant)
+LinearSpringDamper::setDamperConstant(const real_type& damperConstant)
 {
   mDamperConstant = damperConstant;
 }

Modified: trunk/OpenFDM/src/OpenFDM/LinearSpringDamper.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/LinearSpringDamper.h	2006-01-04 13:38:48 UTC (rev 181)
+++ trunk/OpenFDM/src/OpenFDM/LinearSpringDamper.h	2006-01-04 23:21:57 UTC (rev 182)
@@ -24,14 +24,14 @@
 
   const real_type& getForce(void) const;
 
-  real_type getSpringReference(void) const;
-  void setSpringReference(real_type springReference);
+  const real_type& getSpringReference(void) const;
+  void setSpringReference(const real_type& springReference);
 
-  real_type getSpringConstant(void) const;
-  void setSpringConstant(real_type springConstant);
+  const real_type& getSpringConstant(void) const;
+  void setSpringConstant(const real_type& springConstant);
 
-  real_type getDamperConstant(void) const;
-  void setDamperConstant(real_type damperConstant);
+  const real_type& getDamperConstant(void) const;
+  void setDamperConstant(const real_type& damperConstant);
 
 private:
   real_type mSpringReference;

Modified: trunk/OpenFDM/src/OpenFDM/MobileRootJoint.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/MobileRootJoint.cpp	2006-01-04 13:38:48 UTC (rev 181)
+++ trunk/OpenFDM/src/OpenFDM/MobileRootJoint.cpp	2006-01-04 23:21:57 UTC (rev 182)
@@ -109,7 +109,7 @@
     Environment* environment = getEnvironment();
     if (environment) {
       Frame* rootFrame = environment->getRootFrame();
-      if (rootFrame)
+      if (rootFrame && !rootFrame->isDirectParentFrameOf(mFrame))
         rootFrame->addChildFrame(mFrame);
     }
   }

Modified: trunk/OpenFDM/src/OpenFDM/RigidBody.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RigidBody.h	2006-01-04 13:38:48 UTC (rev 181)
+++ trunk/OpenFDM/src/OpenFDM/RigidBody.h	2006-01-04 23:21:57 UTC (rev 182)
@@ -58,11 +58,15 @@
   const Vector6& getArtForce(void) const
   { return mArtForce; }
 
-  /// Contribute articulated force
+  /// Apply a force to that rigid body
+  void applyForce(const Vector6& force)
+  { mArtForce -= force; }
+
+  /// Contribute articulated force as used in the articulated body algorithm
   void contributeForce(const Vector6& force)
   { mArtForce += force; }
 
-  /// Contribute articulated inertia
+  /// Contribute articulated inertia as used in the articulated body algorithm
   void contributeInertia(const SpatialInertia& inertia)
   { mArtInertia += inertia; }
 

Modified: trunk/OpenFDM/src/OpenFDM/WheelContact.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/WheelContact.cpp	2006-01-04 13:38:48 UTC (rev 181)
+++ trunk/OpenFDM/src/OpenFDM/WheelContact.cpp	2006-01-04 23:21:57 UTC (rev 182)
@@ -84,7 +84,9 @@
   Vector3 contactPoint = distHubGround*lp.getNormal();
   
   // The velocity of the ground patch in the current frame.
-  Vector6 groundVel = frame->motionFromRef(mGroundVal.vel);
+  Vector6 groundVel(frame->rotFromRef(mGroundVal.vel.getAngular()),
+                    frame->rotFromRef(mGroundVal.vel.getLinear()));
+  groundVel -= frame->getRefVel();
   // Now get the relative velocity of the ground wrt the hub
   Vector6 relVel = - groundVel;
 //   Log(Model,Error) << trans(frame->getRelVel()) << " "



From frohlich at berlios.de  Thu Jan  5 11:46:26 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Thu, 5 Jan 2006 11:46:26 +0100
Subject: [OpenFDM-svn] r183 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200601051046.k05AkQiD024279@sheep.berlios.de>

Author: frohlich
Date: 2006-01-05 11:46:18 +0100 (Thu, 05 Jan 2006)
New Revision: 183

Modified:
   trunk/OpenFDM/src/OpenFDM/AirSpring.cpp
Log:
Add a chance to change the polarity of the output


Modified: trunk/OpenFDM/src/OpenFDM/AirSpring.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/AirSpring.cpp	2006-01-04 23:21:57 UTC (rev 182)
+++ trunk/OpenFDM/src/OpenFDM/AirSpring.cpp	2006-01-05 10:46:18 UTC (rev 183)
@@ -75,11 +75,14 @@
   real_type pullPressure = mPullPressure/(1-pow(pullDispRatio, mGamma));
   real_type pushPressure = mPushPressure/(1-pow(pushDispRatio, mGamma));
   
+  // The output force is the pressure difference times the piston area
   mForce = sign(maxDisp)*mArea*(pullPressure - pushPressure);
   // Add a position dependent damping force
-  mForce += vel*interpolate(position,
-                            mMinCompression, mMinDamperConstant,
-                            mMaxCompression, mMaxDamperConstant);
+  // That sign of the area is just a handy hack to determine
+  // the polarity of the output value
+  mForce += sign(mArea)*vel*interpolate(position,
+                                        mMinCompression, mMinDamperConstant,
+                                        mMaxCompression, mMaxDamperConstant);
 }
 
 const real_type&



From frohlich at berlios.de  Thu Jan  5 11:47:29 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Thu, 5 Jan 2006 11:47:29 +0100
Subject: [OpenFDM-svn] r185 - trunk/OpenFDM/src/JSBSim
Message-ID: <200601051047.k05AlTa1024391@sheep.berlios.de>

Author: frohlich
Date: 2006-01-05 11:47:27 +0100 (Thu, 05 Jan 2006)
New Revision: 185

Modified:
   trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
Log:
Make use of that LineForce component


Modified: trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
===================================================================
--- trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2006-01-05 10:46:58 UTC (rev 184)
+++ trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2006-01-05 10:47:27 UTC (rev 185)
@@ -1165,6 +1165,7 @@
       rj->setPosition(structToBody(compressJointPos));
       rj->setOrientation(Quaternion::unit());
 
+#if 0
       // Well, we use an air spring for that. It is directly in the
       // revolute joint. That is wring, but at the moment aprioriate.
       AirSpring* aoDamp = new AirSpring(name + " Air Spring Force");
@@ -1181,7 +1182,31 @@
       // ... and provides an output force
       rj->getInputPort(0)->connect(aoDamp->getOutputPort(0));
       addMultiBodyModel(aoDamp);
+#else
+      LineForce* lineForce = new LineForce(name + " Air Spring LineForce");
+      /// FIXME that ordering in attachment is messy!
+      lineForce->setPosition0(structToBody(compressJointPos) - Vector3(0.1, 0, 0.5));
+      lineForce->setPosition1(Vector3(-0.5, 0, 0));
+      mVehicle->getTopBody()->addInteract(lineForce);
+      arm->addInteract(lineForce);
 
+      AirSpring* aoDamp = new AirSpring(name + " Air Spring Force");
+      aoDamp->setPullPressure(pullPress);
+      aoDamp->setPushPressure(pushPress);
+      aoDamp->setArea(area);
+      aoDamp->setMinCompression(minCompr);
+      aoDamp->setMaxCompression(maxCompr);
+      aoDamp->setMinDamperConstant(minDamp);
+      aoDamp->setMaxDamperConstant(maxDamp);
+      addMultiBodyModel(aoDamp);
+
+      // That one reads the joint position and velocity ...
+      aoDamp->getInputPort(0)->connect(lineForce->getOutputPort(0));
+      aoDamp->getInputPort(1)->connect(lineForce->getOutputPort(1));
+      // ... and provides an output force
+      lineForce->getInputPort(0)->connect(aoDamp->getOutputPort(0));
+#endif
+
       // Attach a wheel to that strut part.
       attachWheel(name, Vector3(-armLength, 0, 0), brake, numStr, wheelDiam,
                   tireSpring, tireDamp, arm);



From frohlich at berlios.de  Thu Jan  5 11:47:01 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Thu, 5 Jan 2006 11:47:01 +0100
Subject: [OpenFDM-svn] r184 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200601051047.k05Al168024331@sheep.berlios.de>

Author: frohlich
Date: 2006-01-05 11:46:58 +0100 (Thu, 05 Jan 2006)
New Revision: 184

Modified:
   trunk/OpenFDM/src/OpenFDM/Force.h
Log:
Fix the direction of the resulting force


Modified: trunk/OpenFDM/src/OpenFDM/Force.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Force.h	2006-01-05 10:46:18 UTC (rev 183)
+++ trunk/OpenFDM/src/OpenFDM/Force.h	2006-01-05 10:46:58 UTC (rev 184)
@@ -123,8 +123,6 @@
   // Needs to call applyForce once ...
   virtual void interactWith(RigidBody* rigidBody)
   {
-#if 1
-    /// ORIG
 //     Log(Model,Error) << "InternalForce \"" << getName() << "\""
 //                      << " interacting with RigidBody \""
 //                      << rigidBody->getName() << "\"" << endl;
@@ -143,18 +141,6 @@
       //      Log(Model,Error) << trans(parentForce) << endl;
       rigidBody->applyForce(-parentForce);
     }
-#else
-    if (rigidBody->getFrame()->isDirectParentFrameOf(mMountFrame[1])) {
-      Vector6 parentForce = mMountFrame[1]->forceToParent(mForce);
-      rigidBody->applyForce(parentForce);
-    } else if (rigidBody->getFrame()->isDirectParentFrameOf(mMountFrame[0])) {
-      Rotation relOr = mMountFrame[1]->getRelOrientation(mMountFrame[0]);
-      Vector6 force2(relOr.backTransform(mForce.getAngular()),
-                     relOr.backTransform(mForce.getLinear()));
-      Vector6 parentForce = mMountFrame[0]->forceToParent(mForce);
-      rigidBody->applyForce(parentForce);
-    }
-#endif
   }
 
   const Vector3& getPosition0(void) const
@@ -224,13 +210,10 @@
       dir = normalize(relVel6.getLinear());
     } else
       dir = (1/nrmRelPos)*relPos;
-    mForce = Vector6(Vector3::zeros(), dir*mForcePort.getRealValue());
-//     Log(Model,Error)
-//       << trans(relPos)
-//       << trans(mMountFrame[0]->getRelVel(mMountFrame[1])) << " "
-//       << mRelPos << " "
-//       << mRelVel
-//       << endl;
+    // Since we assume positive input forces to push the two attached
+    // RigidBodies, we need that minus sign to negate the current position
+    // offset
+    mForce = Vector6(Vector3::zeros(), (-mForcePort.getRealValue())*dir);
   }
 
   const real_type& getRelPos(void) const



From frohlich at berlios.de  Thu Jan  5 12:11:09 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Thu, 5 Jan 2006 12:11:09 +0100
Subject: [OpenFDM-svn] r186 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200601051111.k05BB9O4027333@sheep.berlios.de>

Author: frohlich
Date: 2006-01-05 12:11:06 +0100 (Thu, 05 Jan 2006)
New Revision: 186

Modified:
   trunk/OpenFDM/src/OpenFDM/Force.h
Log:
Adjust some comments


Modified: trunk/OpenFDM/src/OpenFDM/Force.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Force.h	2006-01-05 10:47:27 UTC (rev 185)
+++ trunk/OpenFDM/src/OpenFDM/Force.h	2006-01-05 11:11:06 UTC (rev 186)
@@ -120,25 +120,18 @@
       frame1->addChildFrame(mMountFrame[1]);
   }
 
-  // Needs to call applyForce once ...
   virtual void interactWith(RigidBody* rigidBody)
   {
-//     Log(Model,Error) << "InternalForce \"" << getName() << "\""
-//                      << " interacting with RigidBody \""
-//                      << rigidBody->getName() << "\"" << endl;
-//     Log(Model,Error) << trans(mForce) << endl;
-
+    // We assume that the given force is a positive force in the
+    // frame 0's coordinates
     if (rigidBody->getFrame()->isDirectParentFrameOf(mMountFrame[0])) {
       Vector6 parentForce = mMountFrame[0]->forceToParent(mForce);
-      //       Log(Model,Error) << trans(parentForce) << endl;
       rigidBody->applyForce(parentForce);
     } else if (rigidBody->getFrame()->isDirectParentFrameOf(mMountFrame[1])) {
       Rotation relOr = mMountFrame[0]->getRelOrientation(mMountFrame[1]);
-//       Log(Model,Error) << relOr << rigidBody->getFrame()->getOrientation() << endl;
       Vector6 force2(relOr.transform(mForce.getAngular()),
                      relOr.transform(mForce.getLinear()));
       Vector6 parentForce = mMountFrame[1]->forceToParent(force2);
-      //      Log(Model,Error) << trans(parentForce) << endl;
       rigidBody->applyForce(-parentForce);
     }
   }



From frohlich at berlios.de  Thu Jan  5 13:41:46 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Thu, 5 Jan 2006 13:41:46 +0100
Subject: [OpenFDM-svn] r187 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200601051241.k05CfkNa008145@sheep.berlios.de>

Author: frohlich
Date: 2006-01-05 13:41:34 +0100 (Thu, 05 Jan 2006)
New Revision: 187

Modified:
   trunk/OpenFDM/src/OpenFDM/AeroForce.cpp
   trunk/OpenFDM/src/OpenFDM/AeroForce.h
   trunk/OpenFDM/src/OpenFDM/ConstantForce.cpp
   trunk/OpenFDM/src/OpenFDM/ConstantForce.h
   trunk/OpenFDM/src/OpenFDM/Contact.cpp
   trunk/OpenFDM/src/OpenFDM/Contact.h
   trunk/OpenFDM/src/OpenFDM/DirectForce.cpp
   trunk/OpenFDM/src/OpenFDM/DirectForce.h
   trunk/OpenFDM/src/OpenFDM/Force.h
   trunk/OpenFDM/src/OpenFDM/WheelContact.cpp
   trunk/OpenFDM/src/OpenFDM/WheelContact.h
Log:
Clean unp force and external force models


Modified: trunk/OpenFDM/src/OpenFDM/AeroForce.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/AeroForce.cpp	2006-01-05 11:11:06 UTC (rev 186)
+++ trunk/OpenFDM/src/OpenFDM/AeroForce.cpp	2006-01-05 12:41:34 UTC (rev 187)
@@ -15,19 +15,12 @@
 AeroForce::AeroForce(const std::string& name)
   : ExternalForce(name)
 {
-  setPosition(Vector3::zeros());
-  setOrientation(Quaternion::unit());
-
   mWingSpan = 0.0;
   mWingArea = 0.0;
   mCoord = 0.0;
 
   dirtyAll();
 
-  addProperty("position",
-              Property(this, &AeroForce::getPosition, &AeroForce::setPosition));
-//   addProperty("orientation", Property(this, &AeroForce::getOrientation, &AeroForce::setOrientation));
-
   addProperty("wingSpan",
               Property(this, &AeroForce::getWingSpan, &AeroForce::setWingSpan));
   addProperty("wingArea",
@@ -179,30 +172,33 @@
     mGroundVal = mEnvironment->getGround()->getGroundPlane(t, getRefPosition());
   }
   dirtyAll();
-}
 
-void
-AeroForce::setPosition(const Vector3& p)
-{
-  mPosition = p;
-}
+  // FIXME: they can be computed cheaper ...
+  real_type ca = cos(getAlpha());
+  real_type sa = sin(getAlpha());
+  real_type cb = cos(getBeta());
+  real_type sb = sin(getBeta());
+  Matrix33 Ts2b(-ca*cb, -ca*sb,  sa,
+                   -sb,     cb,   0,
+                -sa*cb, -sa*sb, -ca);
 
-const Vector3&
-AeroForce::getPosition(void) const
-{
-  return mPosition;
-}
+  // This is simple here. Just collect all summands ...
+  Vector3 stabilityForce = Vector3::zeros();
+  /// Lift points upward
+  /// Drag points backward
+  for (int i = 0; i < 3; ++i)
+    if (mStabilityAxisForce[i].isConnected())
+      stabilityForce(i+1) = mStabilityAxisForce[i].getRealValue();
 
-void
-AeroForce::setOrientation(const Quaternion& o)
-{
-  mOrientation = o;
-}
+  Vector3 bodyTorque = Vector3::zeros();
+  for (int i = 0; i < 3; ++i)
+    if (mBodyAxisTorque[i].isConnected())
+      bodyTorque(i+1) = mBodyAxisTorque[i].getRealValue();
 
-const Rotation&
-AeroForce::getOrientation(void) const
-{
-  return mOrientation;
+  Vector6 force(bodyTorque, Ts2b*stabilityForce);
+  Log(ArtBody, Debug3) << "AeroForce::output() "
+                       << trans(force) << endl;
+  setForce(force);
 }
 
 void
@@ -245,17 +241,9 @@
 AeroForce::getRefPosition(void) const
 {
   if (mDirtyRefPosition) {
-    const RigidBody* body = getParentRigidBody(0);
-    OpenFDMAssert(body);
-    if (body) {
-      const Frame* frame = body->getFrame();
-      OpenFDMAssert(frame);
-      if (frame) {
-        // Get the position in the earth centered coordinate frame.
-        mRefPosition = frame->posToRef(getPosition());
-        mDirtyRefPosition = false;
-      }
-    }
+    // Get the position in the earth centered coordinate frame.
+    mRefPosition = mMountFrame->getRefPosition();
+    mDirtyRefPosition = false;
   }
   Log(ArtBody, Debug3) << "AeroForce::getRefPosition()"
                        << trans(mRefPosition) << endl;
@@ -266,27 +254,15 @@
 AeroForce::getAirSpeed(void) const
 {
   if (mDirtyAirSpeed) {
-    const RigidBody* body = getParentRigidBody(0);
-    OpenFDMAssert(body);
-    if (body) {
-      const Frame* frame = body->getFrame();
-      OpenFDMAssert(frame);
-      if (frame) {
-        // FIXME temporary workaround
-        if (!mEnvironment) {
-          const_cast<AeroForce*>(this)->mEnvironment = getEnvironment();
-        }
-        // Get the position in the earth centered coordinate frame.
-        Vector3 pos = frame->posToRef(getPosition());
-        Vector3 windVel = mEnvironment->getWind()->getWindVel(pos);
-        windVel = frame->rotFromRef(windVel);
-        Vector6 sAirSpeed = Vector6(Vector3::zeros(), windVel)
-          + frame->getRefVel();
-        mAirSpeed = motionTo(getPosition(), getOrientation(), sAirSpeed);
-        
-        mDirtyAirSpeed = false;
-      }
+    // FIXME temporary workaround
+    if (!mEnvironment) {
+      const_cast<AeroForce*>(this)->mEnvironment = getEnvironment();
     }
+    // Get the position in the earth centered coordinate frame.
+    Vector3 windVel = mEnvironment->getWind()->getWindVel(getRefPosition());
+    windVel = mMountFrame->rotFromRef(windVel);
+    mAirSpeed = Vector6(Vector3::zeros(), windVel) + mMountFrame->getRefVel();
+    mDirtyAirSpeed = false;
   }
   Log(ArtBody, Debug3) << "AeroForce::getAirSpeed()"
                        << trans(mAirSpeed) << endl;
@@ -633,21 +609,13 @@
 AeroForce::getUnitDown(void) const
 {
   if (mDirtyUnitDown) {
-    const RigidBody* body = getParentRigidBody(0);
-    OpenFDMAssert(body);
-    if (body) {
-      const Frame* frame = body->getFrame();
-      OpenFDMAssert(frame);
-      if (frame) {
-        // Compute the geodetic unit down vector at our current position.
-        // So we will need the orientation of the horizontal local frame at our
-        // current position.
-        Quaternion gcHL = getPlanet()->getGeocHLOrientation(getRefPosition());
-        // Transform that unit down vector to the current frame.
-        mUnitDown = frame->rotFromRef(gcHL.backTransform(Vector3::unit(3)));
-        mDirtyUnitDown = false;
-      }
-    }
+    // Compute the geodetic unit down vector at our current position.
+    // So we will need the orientation of the horizontal local frame at our
+    // current position.
+    Quaternion gcHL = getPlanet()->getGeocHLOrientation(getRefPosition());
+    // Transform that unit down vector to the current frame.
+    mUnitDown = mMountFrame->rotFromRef(gcHL.backTransform(Vector3::unit(3)));
+    mDirtyUnitDown = false;
   }
   return mUnitDown;
 }
@@ -656,53 +624,14 @@
 AeroForce::getLocalGroundPlane(void) const
 {
   if (mDirtyLocalGroundPlane) {
-    const RigidBody* body = getParentRigidBody(0);
-    OpenFDMAssert(body);
-    if (body) {
-      const Frame* frame = body->getFrame();
-      OpenFDMAssert(frame);
-      if (frame) {
-        // Transform the plane equation to the local frame.
-        mLocalGroundPlane = frame->planeFromRef(mGroundVal.plane);
-        mDirtyLocalGroundPlane = false;
-      }
-    }
+    // Transform the plane equation to the local frame.
+    mLocalGroundPlane = mMountFrame->planeFromRef(mGroundVal.plane);
+    mDirtyLocalGroundPlane = false;
   }
   return mLocalGroundPlane;
 }
 
 void
-AeroForce::computeForce(void)
-{
-  // FIXME: they can be computed cheaper ...
-  real_type ca = cos(getAlpha());
-  real_type sa = sin(getAlpha());
-  real_type cb = cos(getBeta());
-  real_type sb = sin(getBeta());
-  Matrix33 Ts2b(-ca*cb, -ca*sb,  sa,
-                   -sb,     cb,   0,
-                -sa*cb, -sa*sb, -ca);
-
-  // This is simple here. Just collect all summands ...
-  Vector3 stabilityForce = Vector3::zeros();
-  /// Lift points upward
-  /// Drag points backward
-  for (int i = 0; i < 3; ++i)
-    if (mStabilityAxisForce[i].isConnected())
-      stabilityForce(i+1) = mStabilityAxisForce[i].getRealValue();
-
-  Vector3 bodyTorque = Vector3::zeros();
-  for (int i = 0; i < 3; ++i)
-    if (mBodyAxisTorque[i].isConnected())
-      bodyTorque(i+1) = mBodyAxisTorque[i].getRealValue();
-
-  Vector6 force(bodyTorque, Ts2b*stabilityForce);
-  Log(ArtBody, Debug3) << "AeroForce::computeForce() "
-                       << trans(force) << endl;
-  applyForce(forceFrom(mPosition, mOrientation, force));
-}
-
-void
 AeroForce::dirtyAll(void)
 {
   // Dirty everything.

Modified: trunk/OpenFDM/src/OpenFDM/AeroForce.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/AeroForce.h	2006-01-05 11:11:06 UTC (rev 186)
+++ trunk/OpenFDM/src/OpenFDM/AeroForce.h	2006-01-05 12:41:34 UTC (rev 187)
@@ -27,12 +27,6 @@
   virtual bool init(void);
   virtual void output(const TaskInfo&);
 
-  void setPosition(const Vector3& p);
-  const Vector3& getPosition(void) const;
-
-  void setOrientation(const Quaternion& o);
-  const Rotation& getOrientation(void) const;
-
   void setWingSpan(const real_type& winSpan);
   const real_type& getWingSpan(void) const;
 
@@ -89,9 +83,6 @@
   const Vector3& getUnitDown(void) const;
   const Plane& getLocalGroundPlane(void) const;
 
-  // The interface to the mechanical system.
-  virtual void computeForce(void);
-
 private:
   void dirtyAll(void);
   void computeAtmosphere(void) const;
@@ -108,9 +99,6 @@
 
   SharedPtr<Environment> mEnvironment;
 
-  Vector3 mPosition;
-  Rotation mOrientation;
-
   real_type mWingSpan;
   real_type mWingArea;
   real_type mCoord;

Modified: trunk/OpenFDM/src/OpenFDM/ConstantForce.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/ConstantForce.cpp	2006-01-05 11:11:06 UTC (rev 186)
+++ trunk/OpenFDM/src/OpenFDM/ConstantForce.cpp	2006-01-05 12:41:34 UTC (rev 187)
@@ -8,19 +8,13 @@
 namespace OpenFDM {
 
 ConstantForce::ConstantForce(const std::string& name, const Vector6& force)
-  : ExternalForce(name), mForce(force)
+  : ExternalForce(name)
 {
+  setForce(force);
 }
 
 ConstantForce::~ConstantForce(void)
 {
 }
 
-void
-ConstantForce::computeForce(void)
-{
-  // FIXME: do once ...
-  applyForce(forceFrom(mPosition, mOrientation, mForce));
-}
-
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/ConstantForce.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/ConstantForce.h	2006-01-05 11:11:06 UTC (rev 186)
+++ trunk/OpenFDM/src/OpenFDM/ConstantForce.h	2006-01-05 12:41:34 UTC (rev 187)
@@ -20,28 +20,7 @@
                 const Vector6& force = Vector6::zeros());
   virtual ~ConstantForce(void);
 
-  void setPosition(const Vector3& p)
-  { mPosition = p; }
-  const Vector3& getPosition(void) const
-  { return mPosition; }
-
-  void setOrientation(const Quaternion& o)
-  { mOrientation = o; }
-  const Rotation& getOrientation(void) const
-  { return mOrientation; }
-
-  void setForce(const Vector6& force)
-  { mForce = force; }
-
-protected:
-  /**
-   */
-  virtual void computeForce(void);
-
-private:
-  Vector3 mPosition;
-  Rotation mOrientation;
-  Vector6 mForce;
+  using ExternalForce::setForce;
 };
 
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/Contact.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Contact.cpp	2006-01-05 11:11:06 UTC (rev 186)
+++ trunk/OpenFDM/src/OpenFDM/Contact.cpp	2006-01-05 12:41:34 UTC (rev 187)
@@ -17,8 +17,6 @@
   : ExternalForce(name)
 {
   mEnabled = true;
-  setPosition(Vector3::zeros());
-
   unsigned inputPortBase = getNumInputPorts();
   setNumInputPorts(inputPortBase + 1);
   setInputPortName(inputPortBase + 0, "enabled");
@@ -56,47 +54,30 @@
       mEnabled = 0.5 < rh.getRealValue();
     }
   }
-}
 
-void
-Contact::computeForce(void)
-{
   if (!mEnabled) {
-    applyForce(Vector6::zeros());
+    setForce(Vector6::zeros());
     return;
   }
 
-  const RigidBody* body = getParentRigidBody(0);
-  OpenFDMAssert(body);
-  if (!body) {
-    applyForce(Vector6::zeros());
-    return;
-  }
-  const Frame* frame = body->getFrame();
-  OpenFDMAssert(frame);
-  if (!frame) {
-    applyForce(Vector6::zeros());
-    return;
-  }
-
   // Transform the plane equation to the local frame.
-  Plane lp = frame->planeFromRef(mGroundVal.plane);
+  Plane lp = mMountFrame->planeFromRef(mGroundVal.plane);
   
   // Get the intersection length.
-  real_type compressLength = lp.getDist(getPosition());
+  real_type compressLength = lp.getDist(Vector3::zeros());
   
   // Don't bother if we do not intersect the ground.
   if (compressLength < 0) {
-    applyForce(Vector6::zeros());
+    setForce(Vector6::zeros());
     return;
   }
   
   // The velocity of the ground patch in the current frame.
-  Vector6 groundVel(frame->rotFromRef(mGroundVal.vel.getAngular()),
-                    frame->rotFromRef(mGroundVal.vel.getLinear()));
-  groundVel -= frame->getRefVel();
+  Vector6 groundVel(mMountFrame->rotFromRef(mGroundVal.vel.getAngular()),
+                    mMountFrame->rotFromRef(mGroundVal.vel.getLinear()));
+  groundVel -= mMountFrame->getRefVel();
   // Now get the relative velocity of the ground wrt the contact point
-  Vector3 relVel = - motionTo(getPosition(), groundVel).getLinear();
+  Vector3 relVel = - groundVel.getLinear();
 
   // The velocity perpandicular to the plane.
   // Positive when the contact spring is compressed,
@@ -120,7 +101,7 @@
   Vector3 force = fricForce - normForce*lp.getNormal();
   
   // We don't have an angular moment.
-  applyForce(forceFrom(getPosition(), force));
+  setForce(Vector6(Vector3::zeros(), force));
 }
 
 real_type
@@ -140,22 +121,13 @@
 void
 Contact::getGround(real_type t)
 {
-  const RigidBody* body = getParentRigidBody(0);
-  OpenFDMAssert(body);
-  if (!body)
-    return;
-  const Frame* frame = body->getFrame();
-  OpenFDMAssert(frame);
-  if (!frame)
-    return;
-
   // FIXME
   if (!mEnvironment) {
     mEnvironment = getEnvironment();
   }
 
   // Get the position of the contact in the reference system.
-  Vector3 pos = frame->posToRef(getPosition());
+  Vector3 pos = mMountFrame->getRefPosition();
   // Query for the ground parameters at this point.
   mGroundVal = mEnvironment->getGround()->getGroundPlane(t, pos);
 }

Modified: trunk/OpenFDM/src/OpenFDM/Contact.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Contact.h	2006-01-05 11:11:06 UTC (rev 186)
+++ trunk/OpenFDM/src/OpenFDM/Contact.h	2006-01-05 12:41:34 UTC (rev 187)
@@ -24,14 +24,6 @@
   virtual bool init(void);
   virtual void output(const TaskInfo&);
 
-  Vector3 mPosition;
-  void setPosition(const Vector3& p)
-  { mPosition = p; }
-  const Vector3& getPosition(void) const
-  { return mPosition; }
-
-  virtual void computeForce(void);
-
   // Compute the plane normal force.
   virtual real_type
   computeNormalForce(real_type compressLen, real_type compressVel) const;

Modified: trunk/OpenFDM/src/OpenFDM/DirectForce.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/DirectForce.cpp	2006-01-05 11:11:06 UTC (rev 186)
+++ trunk/OpenFDM/src/OpenFDM/DirectForce.cpp	2006-01-05 12:41:34 UTC (rev 187)
@@ -9,24 +9,16 @@
 
 DirectForce::DirectForce(const std::string& name, const Vector6& direction) :
   ExternalForce(name),
-  mPosition(Vector3::zeros()),
-  mOrientation(Quaternion::unit()),
   mDirection(direction),
-  mForce(Vector6::zeros()),
   mMagnitude(0)
 {
-  addProperty("position", Property(this, &DirectForce::getPosition, &DirectForce::setPosition));
-  addProperty("orientation", Property(this, &DirectForce::getOrientation, &DirectForce::setOrientation));
   addProperty("direction", Property(this, &DirectForce::getDirection, &DirectForce::setDirection));
   addProperty("magnitude", Property(this, &DirectForce::getMagnitude));
-  addProperty("force", Property(this, &DirectForce::getForce));
 
   setDirectFeedThrough(true);
 
   setNumInputPorts(1);
   setInputPortName(0, "magnitude");
-//   setNumOutputPorts(1);
-//   setOutputPort(0, "force", this, &DirectForce::getForce);
 }
 
 DirectForce::~DirectForce(void)
@@ -34,30 +26,6 @@
 }
 
 void
-DirectForce::setPosition(const Vector3& p)
-{
-  mPosition = p;
-}
-
-const Vector3&
-DirectForce::getPosition(void) const
-{
-  return mPosition;
-}
-
-void
-DirectForce::setOrientation(const Quaternion& o)
-{
-  mOrientation = o;
-}
-
-const Quaternion&
-DirectForce::getOrientation(void) const
-{
-  return mOrientation;
-}
-
-void
 DirectForce::setDirection(const Vector6& direction)
 {
   mDirection = direction;
@@ -75,12 +43,6 @@
   return mMagnitude;
 }
 
-const Vector6&
-DirectForce::getForce(void) const
-{
-  return mForce;
-}
-
 bool
 DirectForce::init(void)
 {
@@ -92,13 +54,7 @@
 {
   RealPortHandle rh = getInputPort(0)->toRealPortHandle();
   mMagnitude = rh.getRealValue();
-  mForce = mMagnitude*mDirection;
+  setForce(mMagnitude*mDirection);
 }
 
-void
-DirectForce::computeForce(void)
-{
-  applyForce(forceFrom(mPosition, mOrientation, mForce));
-}
-
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/DirectForce.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/DirectForce.h	2006-01-05 11:11:06 UTC (rev 186)
+++ trunk/OpenFDM/src/OpenFDM/DirectForce.h	2006-01-05 12:41:34 UTC (rev 187)
@@ -20,32 +20,16 @@
               const Vector6& direction = Vector6::unit(4));
   virtual ~DirectForce(void);
 
-  void setPosition(const Vector3& p);
-  const Vector3& getPosition(void) const;
-
-  void setOrientation(const Quaternion& o);
-  const Quaternion& getOrientation(void) const;
-  const Rotation& getRotation(void) const;
-
   void setDirection(const Vector6& direction);
   const Vector6& getDirection(void) const;
 
   real_type getMagnitude(void) const;
-  const Vector6& getForce(void) const;
 
   virtual bool init(void);
   virtual void output(const TaskInfo&);
 
-protected:
-  /**
-   */
-  virtual void computeForce(void);
-
 private:
-  Vector3 mPosition;
-  Rotation mOrientation;
   Vector6 mDirection;
-  Vector6 mForce;
   real_type mMagnitude;
 };
 

Modified: trunk/OpenFDM/src/OpenFDM/Force.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Force.h	2006-01-05 11:11:06 UTC (rev 186)
+++ trunk/OpenFDM/src/OpenFDM/Force.h	2006-01-05 12:41:34 UTC (rev 187)
@@ -52,13 +52,10 @@
   // Needs to call applyForce once ...
   virtual void interactWith(RigidBody* rigidBody)
   {
-    computeForce();
-    rigidBody->applyForce(mForce);
+    OpenFDMAssert(rigidBody->getFrame()->isDirectParentFrameOf(mMountFrame));
+    rigidBody->applyForce(mMountFrame->forceToParent(mForce));
   }
 
-  /// FIXME here for compatibility
-  virtual void computeForce(void) = 0;
-
   const Vector3& getPosition(void) const
   { return mMountFrame->getPosition(); }
   void setPosition(const Vector3& pos)
@@ -69,18 +66,20 @@
   void setOrientation(const Quaternion& pos)
   { mMountFrame->setOrientation(pos); }
 
+  const Vector6& getForce(void) const
+  { return mForce; }
+
 protected:
   /** Sets the force contribution of this force element.
    * Sets the force contribution of this current force element to
    * the parent rigid body to force.
    */
-  void applyForce(const Vector6& force)
-  {
-    mForce = force;
-  }
+  void setForce(const Vector6& force)
+  { mForce = force; }
 
-private:
   SharedPtr<FreeFrame> mMountFrame;
+
+private:
   Vector6 mForce;
 };
 

Modified: trunk/OpenFDM/src/OpenFDM/WheelContact.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/WheelContact.cpp	2006-01-05 11:11:06 UTC (rev 186)
+++ trunk/OpenFDM/src/OpenFDM/WheelContact.cpp	2006-01-05 12:41:34 UTC (rev 187)
@@ -48,28 +48,9 @@
                       << "\" computing ground plane below" << endl;
     getGround(taskInfo.getTime());
   }
-}
 
-void
-WheelContact::computeForce(void)
-{
-  // FIXME: check all signs here, I get the feeling that we have
-  // just even much minuses here instead of exactly the right ones ...
-  const RigidBody* body = getParentRigidBody(0);
-  OpenFDMAssert(body);
-  if (!body) {
-    applyForce(Vector6::zeros());
-    return;
-  }
-  const Frame* frame = body->getFrame();
-  OpenFDMAssert(frame);
-  if (!frame) {
-    applyForce(Vector6::zeros());
-    return;
-  }
-
   // Transform the plane equation to the local frame.
-  Plane lp = frame->planeFromRef(mGroundVal.plane);
+  Plane lp = mMountFrame->planeFromRef(mGroundVal.plane);
   
   // Get the intersection length.
   real_type distHubGround = fabs(lp.getDist(Vector3::zeros()));
@@ -77,21 +58,21 @@
   
   // Don't bother if we do not intersect the ground.
   if (compressLength < 0) {
-    applyForce(Vector6::zeros());
+    setForce(Vector6::zeros());
     return;
   }
 
   Vector3 contactPoint = distHubGround*lp.getNormal();
   
   // The velocity of the ground patch in the current frame.
-  Vector6 groundVel(frame->rotFromRef(mGroundVal.vel.getAngular()),
-                    frame->rotFromRef(mGroundVal.vel.getLinear()));
-  groundVel -= frame->getRefVel();
+  Vector6 groundVel(mMountFrame->rotFromRef(mGroundVal.vel.getAngular()),
+                    mMountFrame->rotFromRef(mGroundVal.vel.getLinear()));
+  groundVel -= mMountFrame->getRefVel();
   // Now get the relative velocity of the ground wrt the hub
   Vector6 relVel = - groundVel;
-//   Log(Model,Error) << trans(frame->getRelVel()) << " "
+//   Log(Model,Error) << trans(mMountFrame->getRelVel()) << " "
 //                    << trans(groundVel) << " "
-//                    << trans(frame->motionToParent(relVel)) << endl;
+//                    << trans(mMountFrame->motionToParent(relVel)) << endl;
 
 
   // The velocity perpandicular to the plane.
@@ -138,7 +119,7 @@
     - normForce*lp.getNormal();
   
   // We don't have an angular moment.
-  applyForce(forceFrom(contactPoint, force));
+  setForce(forceFrom(contactPoint, force));
 }
 
 real_type
@@ -173,22 +154,13 @@
 void
 WheelContact::getGround(real_type t)
 {
-  const RigidBody* body = getParentRigidBody(0);
-  OpenFDMAssert(body);
-  if (!body)
-    return;
-  const Frame* frame = body->getFrame();
-  OpenFDMAssert(frame);
-  if (!frame)
-    return;
-
   // FIXME
   if (!mEnvironment) {
     mEnvironment = getEnvironment();
   }
 
   // Get the position of the contact in the reference system.
-  Vector3 pos = frame->posToRef(Vector3::zeros());
+  Vector3 pos = mMountFrame->posToRef(Vector3::zeros());
   // Query for the ground parameters at this point.
   mGroundVal = mEnvironment->getGround()->getGroundPlane(t, pos);
 }

Modified: trunk/OpenFDM/src/OpenFDM/WheelContact.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/WheelContact.h	2006-01-05 11:11:06 UTC (rev 186)
+++ trunk/OpenFDM/src/OpenFDM/WheelContact.h	2006-01-05 12:41:34 UTC (rev 187)
@@ -24,8 +24,6 @@
   virtual bool init(void);
   virtual void output(const TaskInfo&);
 
-  virtual void computeForce(void);
-
   // Compute the plane normal force.
   virtual real_type
   computeNormalForce(real_type compressLen, real_type compressVel) const;



From frohlich at berlios.de  Thu Jan  5 15:35:58 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Thu, 5 Jan 2006 15:35:58 +0100
Subject: [OpenFDM-svn] r188 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200601051435.k05EZwij018884@sheep.berlios.de>

Author: frohlich
Date: 2006-01-05 15:35:55 +0100 (Thu, 05 Jan 2006)
New Revision: 188

Modified:
   trunk/OpenFDM/src/OpenFDM/Gain.cpp
   trunk/OpenFDM/src/OpenFDM/Gain.h
Log:
Preevaluate the inputs of the Gain model


Modified: trunk/OpenFDM/src/OpenFDM/Gain.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Gain.cpp	2006-01-05 12:41:34 UTC (rev 187)
+++ trunk/OpenFDM/src/OpenFDM/Gain.cpp	2006-01-05 14:35:55 UTC (rev 188)
@@ -37,19 +37,22 @@
 bool
 Gain::init(void)
 {
-  OpenFDMAssert(getInputPort(0)->isConnected());
-  
-  // Make sure it is invalid if sizes do not match.
-  mOutput.resize(getInputPort(0)->getValue().toMatrix());
+  mInputPort = getInputPort(0)->toMatrixPortHandle();
+  if (!mInputPort.isConnected()) {
+    Log(Model, Error) << "Initialization of Gain model \"" << getName()
+                      << "\" failed: Input port \"" << getInputPortName(0)
+                      << "\" is not connected!" << endl;
+    return false;
+  }
+  mOutput.resize(mInputPort.getMatrixValue());
 
   return true;
 }
 
 void Gain::output(const TaskInfo&)
 {
-  OpenFDMAssert(getInputPort(0)->isConnected());
-  MatrixPortHandle mh = getInputPort(0)->toMatrixPortHandle();
-  mOutput = mh.getMatrixValue();
+  OpenFDMAssert(mInputPort.isConnected());
+  mOutput = mInputPort.getMatrixValue();
   mOutput *= mGain;
 }
 

Modified: trunk/OpenFDM/src/OpenFDM/Gain.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Gain.h	2006-01-05 12:41:34 UTC (rev 187)
+++ trunk/OpenFDM/src/OpenFDM/Gain.h	2006-01-05 14:35:55 UTC (rev 188)
@@ -32,6 +32,7 @@
 private:
   real_type mGain;
   Matrix mOutput;
+  MatrixPortHandle mInputPort;
 };
 
 } // namespace OpenFDM



From frohlich at berlios.de  Thu Jan  5 16:01:34 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Thu, 5 Jan 2006 16:01:34 +0100
Subject: [OpenFDM-svn] r189 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200601051501.k05F1YdL028253@sheep.berlios.de>

Author: frohlich
Date: 2006-01-05 16:01:25 +0100 (Thu, 05 Jan 2006)
New Revision: 189

Added:
   trunk/OpenFDM/src/OpenFDM/ConstFrameVisitor.h
   trunk/OpenFDM/src/OpenFDM/FrameVisitor.h
Removed:
   trunk/OpenFDM/src/OpenFDM/ConstVisitor.h
   trunk/OpenFDM/src/OpenFDM/Visitor.h
Modified:
   trunk/OpenFDM/src/OpenFDM/Frame.cpp
   trunk/OpenFDM/src/OpenFDM/Frame.h
   trunk/OpenFDM/src/OpenFDM/Makefile.am
   trunk/OpenFDM/src/OpenFDM/MultiBodySystem.cpp
   trunk/OpenFDM/src/OpenFDM/main.cpp
Log:
Rename Visitor to FrameVisitor
and ConstVisitor to ConstFrameVisitor


Copied: trunk/OpenFDM/src/OpenFDM/ConstFrameVisitor.h (from rev 187, trunk/OpenFDM/src/OpenFDM/ConstVisitor.h)
===================================================================
--- trunk/OpenFDM/src/OpenFDM/ConstVisitor.h	2006-01-05 12:41:34 UTC (rev 187)
+++ trunk/OpenFDM/src/OpenFDM/ConstFrameVisitor.h	2006-01-05 15:01:25 UTC (rev 189)
@@ -0,0 +1,24 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_ConstFrameVisitor_H
+#define OpenFDM_ConstFrameVisitor_H
+
+#include "Frame.h"
+
+namespace OpenFDM {
+
+class ConstFrameVisitor {
+public:
+  virtual ~ConstFrameVisitor(void)
+  {}
+  virtual void apply(const Frame& frame)
+  { traverse(frame); }
+  inline void traverse(const Frame& frame)
+  { frame.traverse(*this); }
+};
+
+} // namespace OpenFDM
+
+#endif

Deleted: trunk/OpenFDM/src/OpenFDM/ConstVisitor.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/ConstVisitor.h	2006-01-05 14:35:55 UTC (rev 188)
+++ trunk/OpenFDM/src/OpenFDM/ConstVisitor.h	2006-01-05 15:01:25 UTC (rev 189)
@@ -1,28 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
- *
- */
-
-#ifndef OpenFDM_ConstVisitor_H
-#define OpenFDM_ConstVisitor_H
-
-#include "Frame.h"
-
-namespace OpenFDM {
-
-class RigidBody;
-
-class ConstVisitor {
-public:
-  virtual ~ConstVisitor(void)
-  {}
-  virtual void apply(const Frame& frame)
-  { traverse(frame); }
-  virtual void apply(const RigidBody& rigidBody)
-  { apply((const Frame&)rigidBody); }
-  inline void traverse(const Frame& frame)
-  { frame.traverse(*this); }
-};
-
-} // namespace OpenFDM
-
-#endif

Modified: trunk/OpenFDM/src/OpenFDM/Frame.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Frame.cpp	2006-01-05 14:35:55 UTC (rev 188)
+++ trunk/OpenFDM/src/OpenFDM/Frame.cpp	2006-01-05 15:01:25 UTC (rev 189)
@@ -10,8 +10,8 @@
 #include "Quaternion.h"
 #include "Inertia.h"
 #include "Frame.h"
-#include "Visitor.h"
-#include "ConstVisitor.h"
+#include "FrameVisitor.h"
+#include "ConstFrameVisitor.h"
 
 namespace OpenFDM {
 
@@ -43,13 +43,13 @@
 }
 
 void
-Frame::accept(Visitor& visitor)
+Frame::accept(FrameVisitor& visitor)
 {
   visitor.apply(*this);
 }
 
 void
-Frame::traverse(Visitor& visitor)
+Frame::traverse(FrameVisitor& visitor)
 {
   ChildFrameList::iterator it = mChildFrames.begin();
   ChildFrameList::iterator iEnd = mChildFrames.end();
@@ -60,13 +60,13 @@
 }
 
 void
-Frame::accept(ConstVisitor& visitor) const
+Frame::accept(ConstFrameVisitor& visitor) const
 {
   visitor.apply(*this);
 }
 
 void
-Frame::traverse(ConstVisitor& visitor) const
+Frame::traverse(ConstFrameVisitor& visitor) const
 {
   ChildFrameList::const_iterator it = mChildFrames.begin();
   ChildFrameList::const_iterator iEnd = mChildFrames.end();
@@ -142,24 +142,12 @@
   return mChildFrames[i];
 }
 
-// class PrintVisitor : public ConstVisitor {
-// public:
-//   virtual void apply(const Frame& frame)
-//   {
-//     Log(Model,Error) << frame.getName() << endl;
-//     traverse(frame);
-//   }
-// };
-
 void
 Frame::reparentChildren(Frame* frame)
 {
   if (!frame)
     return;
 
-//   PrintVisitor pv;
-//   frame->accept(pv);
-
   ChildFrameList::iterator it = frame->mChildFrames.begin();
   while (it != frame->mChildFrames.end()) {
     Log(Model,Error) << "Moving Frame " << (*it)->getName() << " from "
@@ -168,8 +156,6 @@
     mChildFrames.push_back(*it);
     it = frame->mChildFrames.erase(it);
   }
-
-//   frame->accept(pv);
 }
 
 void

Modified: trunk/OpenFDM/src/OpenFDM/Frame.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Frame.h	2006-01-05 14:35:55 UTC (rev 188)
+++ trunk/OpenFDM/src/OpenFDM/Frame.h	2006-01-05 15:01:25 UTC (rev 189)
@@ -25,8 +25,8 @@
 class Joint;
 class Interact;
 
-class Visitor;
-class ConstVisitor;
+class FrameVisitor;
+class ConstFrameVisitor;
 
 /** 
 The \ref Frame class is the basic tool to model a tree of moving and
@@ -56,13 +56,13 @@
   virtual ~Frame(void);
 
   /// Double dispatch helper for the multibody system visitor
-  virtual void accept(Visitor& visitor);
+  virtual void accept(FrameVisitor& visitor);
   /// Double dispatch helper for the multibody system visitor
-  virtual void traverse(Visitor& visitor);
+  virtual void traverse(FrameVisitor& visitor);
   /// Double dispatch helper for the multibody system visitor
-  virtual void accept(ConstVisitor& visitor) const;
+  virtual void accept(ConstFrameVisitor& visitor) const;
   /// Double dispatch helper for the multibody system visitor
-  virtual void traverse(ConstVisitor& visitor) const;
+  virtual void traverse(ConstFrameVisitor& visitor) const;
 
   /// Return the parent frame.
   Frame* getParentFrame(void)

Copied: trunk/OpenFDM/src/OpenFDM/FrameVisitor.h (from rev 187, trunk/OpenFDM/src/OpenFDM/Visitor.h)
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Visitor.h	2006-01-05 12:41:34 UTC (rev 187)
+++ trunk/OpenFDM/src/OpenFDM/FrameVisitor.h	2006-01-05 15:01:25 UTC (rev 189)
@@ -0,0 +1,24 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_FrameVisitor_H
+#define OpenFDM_FrameVisitor_H
+
+#include "Frame.h"
+
+namespace OpenFDM {
+
+class FrameVisitor {
+public:
+  virtual ~FrameVisitor(void)
+  {}
+  virtual void apply(Frame& frame)
+  { traverse(frame); }
+  inline void traverse(Frame& frame)
+  { frame.traverse(*this); }
+};
+
+} // namespace OpenFDM
+
+#endif

Modified: trunk/OpenFDM/src/OpenFDM/Makefile.am
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Makefile.am	2006-01-05 14:35:55 UTC (rev 188)
+++ trunk/OpenFDM/src/OpenFDM/Makefile.am	2006-01-05 15:01:25 UTC (rev 189)
@@ -36,7 +36,7 @@
   Contact.h \
   ConstantForce.h \
   ConstSystem.h \
-  ConstVisitor.h \
+  ConstFrameVisitor.h \
   CowPtr.h \
   DeadBand.h \
   DefaultGravity.h \
@@ -52,7 +52,7 @@
   ExplicitEuler.h \
   Force.h \
   Frame.h \
-  MobileRootJoint.h \
+  FrameVisitor.h \
   Function.h \
   Gain.h \
   Gravity.h \
@@ -80,6 +80,7 @@
   MaxModel.h \
   MidpointRule.h \
   MinModel.h \
+  MobileRootJoint.h \
   MobileRootJointFrame.h \
   Model.h \
   ModelGroup.h \
@@ -127,7 +128,6 @@
   Variant.h \
   Vector.h \
   Vehicle.h \
-  Visitor.h \
   WheelContact.h \
   Wind.h \
   XML/Tablereader.h \
@@ -158,7 +158,6 @@
   ExplicitEuler.cpp \
   Force.cpp \
   Frame.cpp \
-  MobileRootJoint.cpp \
   Function.cpp \
   Gain.cpp \
   Gravity.cpp \
@@ -174,6 +173,7 @@
   MaxModel.cpp \
   MidpointRule.cpp \
   MinModel.cpp \
+  MobileRootJoint.cpp \
   Model.cpp \
   ModelGroup.cpp \
   MultiBodySystem.cpp \

Modified: trunk/OpenFDM/src/OpenFDM/MultiBodySystem.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/MultiBodySystem.cpp	2006-01-05 14:35:55 UTC (rev 188)
+++ trunk/OpenFDM/src/OpenFDM/MultiBodySystem.cpp	2006-01-05 15:01:25 UTC (rev 189)
@@ -10,7 +10,6 @@
 #include "Inertia.h"
 #include "Frame.h"
 #include "RigidBody.h"
-#include "ConstVisitor.h"
 #include "ModelVisitor.h"
 #include "Mass.h"
 #include "Force.h"

Deleted: trunk/OpenFDM/src/OpenFDM/Visitor.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Visitor.h	2006-01-05 14:35:55 UTC (rev 188)
+++ trunk/OpenFDM/src/OpenFDM/Visitor.h	2006-01-05 15:01:25 UTC (rev 189)
@@ -1,28 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
- *
- */
-
-#ifndef OpenFDM_Visitor_H
-#define OpenFDM_Visitor_H
-
-#include "Frame.h"
-
-namespace OpenFDM {
-
-class RigidBody;
-
-class Visitor {
-public:
-  virtual ~Visitor(void)
-  {}
-  virtual void apply(Frame& frame)
-  { traverse(frame); }
-  virtual void apply(RigidBody& rigidBody)
-  { apply((Frame&)rigidBody); }
-  inline void traverse(Frame& frame)
-  { frame.traverse(*this); }
-};
-
-} // namespace OpenFDM
-
-#endif

Modified: trunk/OpenFDM/src/OpenFDM/main.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/main.cpp	2006-01-05 14:35:55 UTC (rev 188)
+++ trunk/OpenFDM/src/OpenFDM/main.cpp	2006-01-05 15:01:25 UTC (rev 189)
@@ -39,8 +39,6 @@
 #include <OpenFDM/LogStream.h>
 #include <OpenFDM/Variant.h>
 #include <OpenFDM/Property.h>
-#include <OpenFDM/Visitor.h>
-#include <OpenFDM/ConstVisitor.h>
 
 // Model includes
 #include <OpenFDM/Model.h>



From frohlich at berlios.de  Thu Jan  5 16:36:02 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Thu, 5 Jan 2006 16:36:02 +0100
Subject: [OpenFDM-svn] r191 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200601051536.k05Fa2BS000290@sheep.berlios.de>

Author: frohlich
Date: 2006-01-05 16:35:57 +0100 (Thu, 05 Jan 2006)
New Revision: 191

Modified:
   trunk/OpenFDM/src/OpenFDM/Bias.cpp
   trunk/OpenFDM/src/OpenFDM/Bias.h
   trunk/OpenFDM/src/OpenFDM/DeadBand.cpp
   trunk/OpenFDM/src/OpenFDM/DeadBand.h
   trunk/OpenFDM/src/OpenFDM/UnaryFunctionModel.cpp
   trunk/OpenFDM/src/OpenFDM/UnaryFunctionModel.h
Log:
Preevaluate more inputs


Modified: trunk/OpenFDM/src/OpenFDM/Bias.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Bias.cpp	2006-01-05 15:11:24 UTC (rev 190)
+++ trunk/OpenFDM/src/OpenFDM/Bias.cpp	2006-01-05 15:35:57 UTC (rev 191)
@@ -38,32 +38,31 @@
 {
   // Invalidate outputs
   mOutput.resize(0, 0);
-  
-  // Minimal check of the input port 
-  if (!getInputPort(0)->isConnected()) {
-    Log(Model, Error) << "Input port of \"" << getName()
-                   << "\", is not valid" << endl;
+
+  mInputPort = getInputPort(0)->toMatrixPortHandle();
+  if (!mInputPort.isConnected()) {
+    Log(Model, Error) << "Initialization of Bias model \"" << getName()
+                      << "\" failed: Input port \"" << getInputPortName(0)
+                      << "\" is not connected!" << endl;
     return false;
   }
 
   // Size compatibility check
-  if (size(getInputPort(0)->getValue().toMatrix()) != size(mBias)) {
+  if (size(mInputPort.getMatrixValue()) != size(mBias)) {
     Log(Model, Error) << "Input port of \"" << getName() << "\", does not "
                       << "match the size of the bias property" << endl;
     return false;
   }
+  mOutput.resize(mInputPort.getMatrixValue());
 
-  // Make sure it is invalid if sizes do not match.
-  mOutput.resize(getInputPort(0)->getValue().toMatrix());
   return true;
 }
 
 void
 Bias::output(const TaskInfo&)
 {
-  OpenFDMAssert(getInputPort(0)->isConnected());
-  MatrixPortHandle mh = getInputPort(0)->toMatrixPortHandle();
-  mOutput = mh.getMatrixValue();
+  OpenFDMAssert(mInputPort.isConnected());
+  mOutput = mInputPort.getMatrixValue();
   mOutput += mBias;
 }
 

Modified: trunk/OpenFDM/src/OpenFDM/Bias.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Bias.h	2006-01-05 15:11:24 UTC (rev 190)
+++ trunk/OpenFDM/src/OpenFDM/Bias.h	2006-01-05 15:35:57 UTC (rev 191)
@@ -32,6 +32,7 @@
 private:
   Matrix mBias;
   Matrix mOutput;
+  MatrixPortHandle mInputPort;
 };
 
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/DeadBand.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/DeadBand.cpp	2006-01-05 15:11:24 UTC (rev 190)
+++ trunk/OpenFDM/src/OpenFDM/DeadBand.cpp	2006-01-05 15:35:57 UTC (rev 191)
@@ -34,17 +34,23 @@
 bool
 DeadBand::init(void)
 {
-  OpenFDMAssert(getInputPort(0)->isConnected());
-  return getInputPort(0)->isConnected();
+  mInputPort = getInputPort(0)->toRealPortHandle();
+  if (!mInputPort.isConnected()) {
+    Log(Model, Error) << "Initialization of DeadBand model \"" << getName()
+                      << "\" failed: Input port \"" << getInputPortName(0)
+                      << "\" is not connected!" << endl;
+    return false;
+  }
+
+  return true;
 }
 
 void
 DeadBand::output(const TaskInfo&)
 {
-  OpenFDMAssert(getInputPort(0)->isConnected());
+  OpenFDMAssert(mInputPort.isConnected());
   
-  RealPortHandle rh = getInputPort(0)->toRealPortHandle();
-  mOutput = rh.getRealValue();
+  mOutput = mInputPort.getRealValue();
   if (mOutput < -mWidth)
     mOutput += mWidth;
   else if (mWidth < mOutput)

Modified: trunk/OpenFDM/src/OpenFDM/DeadBand.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/DeadBand.h	2006-01-05 15:11:24 UTC (rev 190)
+++ trunk/OpenFDM/src/OpenFDM/DeadBand.h	2006-01-05 15:35:57 UTC (rev 191)
@@ -31,6 +31,7 @@
 private:
   real_type mWidth;
   real_type mOutput;
+  RealPortHandle mInputPort;
 };
 
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/UnaryFunctionModel.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/UnaryFunctionModel.cpp	2006-01-05 15:11:24 UTC (rev 190)
+++ trunk/OpenFDM/src/OpenFDM/UnaryFunctionModel.cpp	2006-01-05 15:35:57 UTC (rev 191)
@@ -243,12 +243,23 @@
 bool
 UnitConversionModel::init(void)
 {
+  mInputPort = getInputPort(0)->toRealPortHandle();
+  if (!mInputPort.isConnected()) {
+    Log(Model, Error) << "Initialization of UnitConversion model \""
+                      << getName()
+                      << "\" failed: Input port \"" << getInputPortName(0)
+                      << "\" is not connected!" << endl;
+    return false;
+  }
+
+  return true;
 }
 
 void
 UnitConversionModel::output(const TaskInfo&)
 {
-  real_type value = getInputPort(0)->toRealPortHandle().getRealValue();
+  OpenFDMAssert(mInputPort.isConnected());
+  real_type value = mInputPort.getRealValue();
   if (mType == UnitToSi) {
     mValue = convertFrom(mUnit, value);
   } else {

Modified: trunk/OpenFDM/src/OpenFDM/UnaryFunctionModel.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/UnaryFunctionModel.h	2006-01-05 15:11:24 UTC (rev 190)
+++ trunk/OpenFDM/src/OpenFDM/UnaryFunctionModel.h	2006-01-05 15:35:57 UTC (rev 191)
@@ -78,6 +78,7 @@
   Type mType;
   Unit mUnit;
   real_type mValue;
+  RealPortHandle mInputPort;
 };
 
 } // namespace OpenFDM



From frohlich at berlios.de  Thu Jan  5 17:52:47 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Thu, 5 Jan 2006 17:52:47 +0100
Subject: [OpenFDM-svn] r192 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200601051652.k05Gqll7010235@sheep.berlios.de>

Author: frohlich
Date: 2006-01-05 17:52:41 +0100 (Thu, 05 Jan 2006)
New Revision: 192

Added:
   trunk/OpenFDM/src/OpenFDM/Tank.cpp
   trunk/OpenFDM/src/OpenFDM/Tank.h
Modified:
   trunk/OpenFDM/src/OpenFDM/Makefile.am
   trunk/OpenFDM/src/OpenFDM/Mass.cpp
   trunk/OpenFDM/src/OpenFDM/Mass.h
Log:
Add a first cut of a Tank


Modified: trunk/OpenFDM/src/OpenFDM/Makefile.am
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Makefile.am	2006-01-05 15:35:57 UTC (rev 191)
+++ trunk/OpenFDM/src/OpenFDM/Makefile.am	2006-01-05 16:52:41 UTC (rev 192)
@@ -117,6 +117,7 @@
   Summer.h \
   System.h \
   Table.h \
+  Tank.h \
   TaskInfo.h \
   TimeDerivative.h \
   TransferFunction.h \
@@ -195,6 +196,7 @@
   SimpleGear.cpp \
   Summer.cpp \
   System.cpp \
+  Tank.cpp \
   TimeDerivative.cpp \
   TransferFunction.cpp \
   UnaryFunctionModel.cpp \

Modified: trunk/OpenFDM/src/OpenFDM/Mass.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Mass.cpp	2006-01-05 15:35:57 UTC (rev 191)
+++ trunk/OpenFDM/src/OpenFDM/Mass.cpp	2006-01-05 16:52:41 UTC (rev 192)
@@ -8,8 +8,11 @@
 
 Mass::Mass(const std::string& name, const SpatialInertia& inertia) :
   Interact(name, 1),
-  mInertia(inertia)
+  mInertia(inertia),
+  mUntransformedInertia(inertia),
+  mPosition(Vector3::zeros())
 {
+  addProperty("posoition", Property(this, &Mass::getPosition, &Mass::setPosition));
 }
 
 Mass::~Mass(void)
@@ -25,19 +28,33 @@
 void
 Mass::setInertia(real_type mass)
 {
-  mInertia = SpatialInertia(mass);
+  setInertia(SpatialInertia(mass));
 }
 
 void
 Mass::setInertia(real_type mass, const InertiaMatrix& inertia)
 {
-  mInertia = SpatialInertia(inertia, mass);
+  setInertia(SpatialInertia(inertia, mass));
 }
 
 void
 Mass::setInertia(const SpatialInertia& I)
 {
-  mInertia = I;
+  mUntransformedInertia = I;
+  mInertia = inertiaFrom(mPosition, mUntransformedInertia);
 }
 
+const Vector3&
+Mass::getPosition(void) const
+{
+  return mPosition;
+}
+
+void
+Mass::setPosition(const Vector3& position)
+{
+  mPosition = position;
+  mInertia = inertiaFrom(mPosition, mUntransformedInertia);
+}
+
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/Mass.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Mass.h	2006-01-05 15:35:57 UTC (rev 191)
+++ trunk/OpenFDM/src/OpenFDM/Mass.h	2006-01-05 16:52:41 UTC (rev 192)
@@ -46,8 +46,13 @@
    */
   void setInertia(const SpatialInertia& I);
 
+  const Vector3& getPosition(void) const;
+  void setPosition(const Vector3& position);
+
 private:
   SpatialInertia mInertia;
+  SpatialInertia mUntransformedInertia;
+  Vector3 mPosition;
 };
 
 } // namespace OpenFDM

Added: trunk/OpenFDM/src/OpenFDM/Tank.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Tank.cpp	2006-01-05 15:35:57 UTC (rev 191)
+++ trunk/OpenFDM/src/OpenFDM/Tank.cpp	2006-01-05 16:52:41 UTC (rev 192)
@@ -0,0 +1,90 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2006 Mathias Froehlich 
+ *
+ */
+
+#include "Tank.h"
+
+namespace OpenFDM {
+
+Tank::Tank(const std::string& name) :
+  Mass(name),
+  mContent(0),
+  mNextContent(0),
+  mCapacity(0),
+  mIsEmpty(true)
+{
+  setNumInputPorts(1);
+  setInputPortName(0, "fuelFlow");
+
+  setNumOutputPorts(1);
+  setOutputPort(0, "content", this, &Tank::getContent);
+
+  addProperty("content", Property(this, &Tank::getContent, &Tank::setContent));
+  addProperty("capacity", Property(this, &Tank::getCapacity, &Tank::setCapacity));
+}
+
+Tank::~Tank(void)
+{
+}
+
+bool
+Tank::init(void)
+{
+  mInputPort = getInputPort(0)->toRealPortHandle();
+  return true;
+}
+
+void
+Tank::output(const TaskInfo& taskInfo)
+{
+  if (!nonZeroIntersection(taskInfo.getSampleTimeSet(),
+                           SampleTime::PerTimestep))
+    return;
+  mContent = mNextContent;
+  setInertia(mContent);
+  mIsEmpty = (mContent == 0);
+}
+
+void
+Tank::update(const TaskInfo& taskInfo)
+{
+  if (!nonZeroIntersection(taskInfo.getSampleTimeSet(),
+                           SampleTime::PerTimestep))
+    return;
+
+  if (!mInputPort.isConnected())
+    return;
+
+  // Modify the tank's content by the requested fluel flow (kg/s)
+  // FIXME
+  real_type dt = (*taskInfo.getSampleTimeSet().begin()).getSampleTime();
+  mNextContent = mContent + dt*mInputPort.getRealValue();
+  mNextContent = min(mNextContent, mCapacity);
+  mNextContent = max(mNextContent, real_type(0));
+}
+
+void
+Tank::setDiscreteState(const StateStream& state)
+{
+  state.readSubState(mContent);
+}
+
+void
+Tank::getDiscreteState(StateStream& state) const
+{
+  state.writeSubState(mContent);
+}
+
+const real_type&
+Tank::getContent(void) const
+{
+  return mContent;
+}
+
+void
+Tank::setContent(const real_type& content)
+{
+  mContent = content;
+}
+
+} // namespace OpenFDM


Property changes on: trunk/OpenFDM/src/OpenFDM/Tank.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/OpenFDM/src/OpenFDM/Tank.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Tank.h	2006-01-05 15:35:57 UTC (rev 191)
+++ trunk/OpenFDM/src/OpenFDM/Tank.h	2006-01-05 16:52:41 UTC (rev 192)
@@ -0,0 +1,48 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2006 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_Tank_H
+#define OpenFDM_Tank_H
+
+#include "Mass.h"
+
+namespace OpenFDM {
+
+class Tank :
+    public Mass {
+public:
+  Tank(const std::string& name);
+  virtual ~Tank(void);
+
+  virtual bool init(void);
+  virtual void output(const TaskInfo&);
+  virtual void update(const TaskInfo&);
+
+  virtual void setDiscreteState(const StateStream& state);
+  virtual void getDiscreteState(StateStream& state) const;
+
+  /// get the actual content of the tank in kg
+  const real_type& getContent(void) const;
+  /// set the actual content of the tank in kg
+  void setContent(const real_type& content);
+
+  /// get the capacity of the tank in kg(FIXME:use m^3 and fiddle wiht density)
+  const real_type& getCapacity(void) const;
+  /// set the capacity of the tank in kg(FIXME:use m^3 and fiddle wiht density)
+  void setCapacity(const real_type& capacity);
+
+  /// return nonzero if the tank is empty
+  const unsigned& getIsEmpty(void) const;
+
+private:
+  real_type mContent;
+  real_type mNextContent;
+  real_type mCapacity;
+  unsigned mIsEmpty;
+  RealPortHandle mInputPort;
+};
+
+} // namespace OpenFDM
+
+#endif


Property changes on: trunk/OpenFDM/src/OpenFDM/Tank.h
___________________________________________________________________
Name: svn:eol-style
   + native



From frohlich at berlios.de  Thu Jan  5 17:57:19 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Thu, 5 Jan 2006 17:57:19 +0100
Subject: [OpenFDM-svn] r193 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200601051657.k05GvJGS010783@sheep.berlios.de>

Author: frohlich
Date: 2006-01-05 17:57:16 +0100 (Thu, 05 Jan 2006)
New Revision: 193

Modified:
   trunk/OpenFDM/src/OpenFDM/Mass.cpp
Log:
Fix typo


Modified: trunk/OpenFDM/src/OpenFDM/Mass.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Mass.cpp	2006-01-05 16:52:41 UTC (rev 192)
+++ trunk/OpenFDM/src/OpenFDM/Mass.cpp	2006-01-05 16:57:16 UTC (rev 193)
@@ -12,7 +12,7 @@
   mUntransformedInertia(inertia),
   mPosition(Vector3::zeros())
 {
-  addProperty("posoition", Property(this, &Mass::getPosition, &Mass::setPosition));
+  addProperty("position", Property(this, &Mass::getPosition, &Mass::setPosition));
 }
 
 Mass::~Mass(void)



From frohlich at berlios.de  Fri Jan  6 09:18:10 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Fri, 6 Jan 2006 09:18:10 +0100
Subject: [OpenFDM-svn] r194 - trunk/OpenFDM/src/OpenFDM/LinAlg
Message-ID: <200601060818.k068IAtF019108@sheep.berlios.de>

Author: frohlich
Date: 2006-01-06 09:18:07 +0100 (Fri, 06 Jan 2006)
New Revision: 194

Modified:
   trunk/OpenFDM/src/OpenFDM/LinAlg/Container.h
Log:
Vectors can be assigned from matrices


Modified: trunk/OpenFDM/src/OpenFDM/LinAlg/Container.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/LinAlg/Container.h	2006-01-05 16:57:16 UTC (rev 193)
+++ trunk/OpenFDM/src/OpenFDM/LinAlg/Container.h	2006-01-06 08:18:07 UTC (rev 194)
@@ -165,6 +165,10 @@
   OpenFDM_FORCE_INLINE
   Vector(const Vector& A)
   { directAssign(A); }
+  template<typename Impl2, size_type m2, size_type n2>
+  OpenFDM_FORCE_INLINE
+  Vector(const MatrixRValue<Impl2,m2,n2>& A)
+  { directAssign(A); }
   template<typename Impl2, size_type m2>
   OpenFDM_FORCE_INLINE
   Vector(const MatrixRValue<Impl2,m2,1>& A)
@@ -849,6 +853,11 @@
   Vector2(const Vector2& v)
     : Vector<T,2>(v)
   { }
+  template<typename Impl, size_type m, size_type n>
+  OpenFDM_FORCE_INLINE
+  Vector2(const MatrixRValue<Impl,m,n>& A)
+    : Vector<T,2>(A)
+  { }
   template<typename Impl, size_type m>
   OpenFDM_FORCE_INLINE
   Vector2(const MatrixRValue<Impl,m,1>& v)
@@ -873,6 +882,11 @@
   Vector3(const Vector3& v)
     : Vector<T,3>(v)
   { }
+  template<typename Impl, size_type m, size_type n>
+  OpenFDM_FORCE_INLINE
+  Vector3(const MatrixRValue<Impl,m,n>& A)
+    : Vector<T,3>(A)
+  { }
   template<typename Impl, size_type m>
   OpenFDM_FORCE_INLINE
   Vector3(const MatrixRValue<Impl,m,1>& v)
@@ -897,6 +911,11 @@
   Vector4(const Vector4& v)
     : Vector<T,4>(v)
   { }
+  template<typename Impl, size_type m, size_type n>
+  OpenFDM_FORCE_INLINE
+  Vector4(const MatrixRValue<Impl,m,n>& A)
+    : Vector<T,4>(A)
+  { }
   template<typename Impl, size_type m>
   OpenFDM_FORCE_INLINE
   Vector4(const MatrixRValue<Impl,m,1>& v)
@@ -930,6 +949,11 @@
   Vector6(const Vector6& v)
     : Vector<T,6>(v)
   { }
+  template<typename Impl, size_type m, size_type n>
+  OpenFDM_FORCE_INLINE
+  Vector6(const MatrixRValue<Impl,m,n>& A)
+    : Vector<T,6>(A)
+  { }
   template<typename Impl, size_type m>
   OpenFDM_FORCE_INLINE
   Vector6(const MatrixRValue<Impl,m,1>& v)



From frohlich at berlios.de  Fri Jan  6 10:12:06 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Fri, 6 Jan 2006 10:12:06 +0100
Subject: [OpenFDM-svn] r195 - in trunk/OpenFDM/src: JSBSim OpenFDM
Message-ID: <200601060912.k069C64d023385@sheep.berlios.de>

Author: frohlich
Date: 2006-01-06 10:11:46 +0100 (Fri, 06 Jan 2006)
New Revision: 195

Added:
   trunk/OpenFDM/src/OpenFDM/ConstModel.cpp
   trunk/OpenFDM/src/OpenFDM/ConstModel.h
   trunk/OpenFDM/src/OpenFDM/ExternalForceModel.cpp
   trunk/OpenFDM/src/OpenFDM/ExternalForceModel.h
Removed:
   trunk/OpenFDM/src/OpenFDM/ConstSystem.cpp
   trunk/OpenFDM/src/OpenFDM/ConstSystem.h
   trunk/OpenFDM/src/OpenFDM/ConstantForce.cpp
   trunk/OpenFDM/src/OpenFDM/ConstantForce.h
   trunk/OpenFDM/src/OpenFDM/DirectForce.cpp
   trunk/OpenFDM/src/OpenFDM/DirectForce.h
Modified:
   trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
   trunk/OpenFDM/src/OpenFDM/Makefile.am
   trunk/OpenFDM/src/OpenFDM/Port.h
   trunk/OpenFDM/src/OpenFDM/Product.cpp
   trunk/OpenFDM/src/OpenFDM/Product.h
   trunk/OpenFDM/src/OpenFDM/main.cpp
Log:
clean up external force system


Modified: trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
===================================================================
--- trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2006-01-06 08:18:07 UTC (rev 194)
+++ trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2006-01-06 09:11:46 UTC (rev 195)
@@ -13,11 +13,11 @@
 
 #include <OpenFDM/AeroForce.h>
 #include <OpenFDM/Bias.h>
-#include <OpenFDM/ConstSystem.h>
+#include <OpenFDM/ConstModel.h>
 #include <OpenFDM/DeadBand.h>
 #include <OpenFDM/DiscreteIntegrator.h>
+#include <OpenFDM/ExternalForceModel.h>
 #include <OpenFDM/TransferFunction.h>
-#include <OpenFDM/DirectForce.h>
 #include <OpenFDM/Gain.h>
 #include <OpenFDM/Input.h>
 #include <OpenFDM/Mass.h>
@@ -674,7 +674,7 @@
 {
   Matrix m(1, 1);
   m(1, 1) = 0;
-  ConstSystem* cModel = new ConstSystem(name, m);
+  ConstModel* cModel = new ConstModel(name, m);
   addFCSModel(cModel);
   return cModel->getOutputPort(0);
 }
@@ -2097,14 +2097,24 @@
       return error("Unknown parameter in engine configuration");
   }
 
+
+
   std::string namestr = "Engine<" + number + ">";
-  DirectForce* engineForce = new DirectForce(namestr);
-  engineForce->setDirection(Vector6(0, 0, 0, 4.4*1.5e4, 0, 0));
+  ConstModel* fullForce = new ConstModel(namestr + " full",
+                                         Vector6(0, 0, 0, 4.4*1.5e4, 0, 0));
+  addMultiBodyModel(fullForce);
+
+  Product* prod = new Product(namestr + " modulation");
+  std::string throttlename = "fcs/throttle-cmd-norm[" + number + "]";
+  prod->getInputPort(0)->connect(lookupJSBExpression(throttlename));
+  prod->getInputPort(1)->connect(fullForce->getOutputPort(0));
+  addMultiBodyModel(prod);
+
+  ExternalForceModel* engineForce = new ExternalForceModel(namestr);
   engineForce->setPosition(structToBody(loc));
   engineForce->setOrientation(Quaternion::fromHeadAttBank(pitch, 0, yaw));
 
-  std::string throttlename = "fcs/throttle-cmd-norm[" + number + "]";
-  engineForce->getInputPort(0)->connect(lookupJSBExpression(throttlename));
+  engineForce->getInputPort(0)->connect(prod->getOutputPort(0));
 
   mVehicle->getTopBody()->addInteract(engineForce);
 
@@ -2270,8 +2280,8 @@
   if (ndims == 0) {
     Matrix value(1, 1);
     datastr >> value(1, 1);
-    ConstSystem* constModel
-      = new ConstSystem(prod->getName() + " Factor", value);
+    ConstModel* constModel
+      = new ConstModel(prod->getName() + " Factor", value);
     addMultiBodyModel(constModel);
 
     unsigned nf = prod->getNumFactors();

Copied: trunk/OpenFDM/src/OpenFDM/ConstModel.cpp (from rev 190, trunk/OpenFDM/src/OpenFDM/ConstSystem.cpp)
===================================================================
--- trunk/OpenFDM/src/OpenFDM/ConstSystem.cpp	2006-01-05 15:11:24 UTC (rev 190)
+++ trunk/OpenFDM/src/OpenFDM/ConstModel.cpp	2006-01-06 09:11:46 UTC (rev 195)
@@ -0,0 +1,34 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2006 Mathias Froehlich 
+ *
+ */
+
+#include "ConstModel.h"
+
+namespace OpenFDM {
+
+ConstModel::ConstModel(const std::string& name, const Matrix& value) :
+  Model(name), mValue(value)
+{
+  addProperty("value", Property(this, &ConstModel::getValue, &ConstModel::setValue));
+
+  setNumOutputPorts(1);
+  setOutputPort(0, "output", this, &ConstModel::getValue);
+}
+
+ConstModel::~ConstModel(void)
+{
+}
+
+const Matrix&
+ConstModel::getValue(void) const
+{
+  return mValue;
+}
+
+void
+ConstModel::setValue(const Matrix& value)
+{
+  mValue = value;
+}
+
+} // namespace OpenFDM

Copied: trunk/OpenFDM/src/OpenFDM/ConstModel.h (from rev 190, trunk/OpenFDM/src/OpenFDM/ConstSystem.h)
===================================================================
--- trunk/OpenFDM/src/OpenFDM/ConstSystem.h	2006-01-05 15:11:24 UTC (rev 190)
+++ trunk/OpenFDM/src/OpenFDM/ConstModel.h	2006-01-06 09:11:46 UTC (rev 195)
@@ -0,0 +1,28 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2006 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_ConstModel_H
+#define OpenFDM_ConstModel_H
+
+#include "Model.h"
+#include "Matrix.h"
+
+namespace OpenFDM {
+
+class ConstModel
+  : public Model {
+public:
+  ConstModel(const std::string& name, const Matrix& value);
+  virtual ~ConstModel(void);
+
+  const Matrix& getValue(void) const;
+  void setValue(const Matrix& value);
+
+private:
+  Matrix mValue;
+};
+
+} // namespace OpenFDM
+
+#endif

Deleted: trunk/OpenFDM/src/OpenFDM/ConstSystem.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/ConstSystem.cpp	2006-01-06 08:18:07 UTC (rev 194)
+++ trunk/OpenFDM/src/OpenFDM/ConstSystem.cpp	2006-01-06 09:11:46 UTC (rev 195)
@@ -1,34 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2006 Mathias Froehlich 
- *
- */
-
-#include "ConstSystem.h"
-
-namespace OpenFDM {
-
-ConstSystem::ConstSystem(const std::string& name, const Matrix& value) :
-  Model(name), mValue(value)
-{
-  addProperty("value", Property(this, &ConstSystem::getValue, &ConstSystem::setValue));
-
-  setNumOutputPorts(1);
-  setOutputPort(0, "output", this, &ConstSystem::getValue);
-}
-
-ConstSystem::~ConstSystem(void)
-{
-}
-
-const Matrix&
-ConstSystem::getValue(void) const
-{
-  return mValue;
-}
-
-void
-ConstSystem::setValue(const Matrix& value)
-{
-  mValue = value;
-}
-
-} // namespace OpenFDM

Deleted: trunk/OpenFDM/src/OpenFDM/ConstSystem.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/ConstSystem.h	2006-01-06 08:18:07 UTC (rev 194)
+++ trunk/OpenFDM/src/OpenFDM/ConstSystem.h	2006-01-06 09:11:46 UTC (rev 195)
@@ -1,28 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2006 Mathias Froehlich 
- *
- */
-
-#ifndef OpenFDM_ConstSystem_H
-#define OpenFDM_ConstSystem_H
-
-#include "Model.h"
-#include "Matrix.h"
-
-namespace OpenFDM {
-
-class ConstSystem
-  : public Model {
-public:
-  ConstSystem(const std::string& name, const Matrix& value);
-  virtual ~ConstSystem(void);
-
-  const Matrix& getValue(void) const;
-  void setValue(const Matrix& value);
-
-private:
-  Matrix mValue;
-};
-
-} // namespace OpenFDM
-
-#endif

Deleted: trunk/OpenFDM/src/OpenFDM/ConstantForce.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/ConstantForce.cpp	2006-01-06 08:18:07 UTC (rev 194)
+++ trunk/OpenFDM/src/OpenFDM/ConstantForce.cpp	2006-01-06 09:11:46 UTC (rev 195)
@@ -1,20 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2006 Mathias Froehlich 
- *
- */
-
-#include "Vector.h"
-#include "ConstantForce.h"
-
-namespace OpenFDM {
-
-ConstantForce::ConstantForce(const std::string& name, const Vector6& force)
-  : ExternalForce(name)
-{
-  setForce(force);
-}
-
-ConstantForce::~ConstantForce(void)
-{
-}
-
-} // namespace OpenFDM

Deleted: trunk/OpenFDM/src/OpenFDM/ConstantForce.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/ConstantForce.h	2006-01-06 08:18:07 UTC (rev 194)
+++ trunk/OpenFDM/src/OpenFDM/ConstantForce.h	2006-01-06 09:11:46 UTC (rev 195)
@@ -1,28 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2006 Mathias Froehlich 
- *
- */
-
-#ifndef OpenFDM_ConstantForce_H
-#define OpenFDM_ConstantForce_H
-
-#include "Assert.h"
-#include "Object.h"
-#include "Vector.h"
-#include "Frame.h"
-#include "Force.h"
-
-namespace OpenFDM {
-
-class ConstantForce
-  : public ExternalForce {
-public:
-  ConstantForce(const std::string& name,
-                const Vector6& force = Vector6::zeros());
-  virtual ~ConstantForce(void);
-
-  using ExternalForce::setForce;
-};
-
-} // namespace OpenFDM
-
-#endif

Deleted: trunk/OpenFDM/src/OpenFDM/DirectForce.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/DirectForce.cpp	2006-01-06 08:18:07 UTC (rev 194)
+++ trunk/OpenFDM/src/OpenFDM/DirectForce.cpp	2006-01-06 09:11:46 UTC (rev 195)
@@ -1,60 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2006 Mathias Froehlich 
- *
- */
-
-#include "Vector.h"
-#include "DirectForce.h"
-
-namespace OpenFDM {
-
-DirectForce::DirectForce(const std::string& name, const Vector6& direction) :
-  ExternalForce(name),
-  mDirection(direction),
-  mMagnitude(0)
-{
-  addProperty("direction", Property(this, &DirectForce::getDirection, &DirectForce::setDirection));
-  addProperty("magnitude", Property(this, &DirectForce::getMagnitude));
-
-  setDirectFeedThrough(true);
-
-  setNumInputPorts(1);
-  setInputPortName(0, "magnitude");
-}
-
-DirectForce::~DirectForce(void)
-{
-}
-
-void
-DirectForce::setDirection(const Vector6& direction)
-{
-  mDirection = direction;
-}
-
-const Vector6&
-DirectForce::getDirection(void) const
-{
-  return mDirection;
-}
-
-real_type
-DirectForce::getMagnitude(void) const
-{
-  return mMagnitude;
-}
-
-bool
-DirectForce::init(void)
-{
-  return true;
-}
-
-void
-DirectForce::output(const TaskInfo&)
-{
-  RealPortHandle rh = getInputPort(0)->toRealPortHandle();
-  mMagnitude = rh.getRealValue();
-  setForce(mMagnitude*mDirection);
-}
-
-} // namespace OpenFDM

Deleted: trunk/OpenFDM/src/OpenFDM/DirectForce.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/DirectForce.h	2006-01-06 08:18:07 UTC (rev 194)
+++ trunk/OpenFDM/src/OpenFDM/DirectForce.h	2006-01-06 09:11:46 UTC (rev 195)
@@ -1,38 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2006 Mathias Froehlich 
- *
- */
-
-#ifndef OpenFDM_DirectForce_H
-#define OpenFDM_DirectForce_H
-
-#include "Assert.h"
-#include "Object.h"
-#include "Vector.h"
-#include "Frame.h"
-#include "Force.h"
-
-namespace OpenFDM {
-
-class DirectForce
-  : public ExternalForce {
-public:
-  DirectForce(const std::string& name,
-              const Vector6& direction = Vector6::unit(4));
-  virtual ~DirectForce(void);
-
-  void setDirection(const Vector6& direction);
-  const Vector6& getDirection(void) const;
-
-  real_type getMagnitude(void) const;
-
-  virtual bool init(void);
-  virtual void output(const TaskInfo&);
-
-private:
-  Vector6 mDirection;
-  real_type mMagnitude;
-};
-
-} // namespace OpenFDM
-
-#endif

Added: trunk/OpenFDM/src/OpenFDM/ExternalForceModel.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/ExternalForceModel.cpp	2006-01-06 08:18:07 UTC (rev 194)
+++ trunk/OpenFDM/src/OpenFDM/ExternalForceModel.cpp	2006-01-06 09:11:46 UTC (rev 195)
@@ -0,0 +1,51 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2006 Mathias Froehlich 
+ *
+ */
+
+#include "Vector.h"
+#include "ExternalForceModel.h"
+
+namespace OpenFDM {
+
+ExternalForceModel::ExternalForceModel(const std::string& name)
+  : ExternalForce(name)
+{
+  setDirectFeedThrough(true);
+
+  setNumInputPorts(1);
+  setInputPortName(0, "forceInput");
+}
+
+ExternalForceModel::~ExternalForceModel(void)
+{
+}
+
+bool
+ExternalForceModel::init(void)
+{
+  mInputPort = getInputPort(0)->toMatrixPortHandle();
+  if (!mInputPort.isConnected()) {
+    Log(Model, Error) << "Initialization of ExternalForceModel model \""
+                      << getName() << "\" failed: Input port \""
+                      << getInputPortName(0) << "\" is not connected!" << endl;
+    return false;
+  }
+  if (size(mInputPort.getMatrixValue()) != Size(6, 1)) {
+    Log(Model, Error) << "Initialization of ExternalForceModel model \""
+                      << getName() << "\" failed: Input port \""
+                      << getInputPortName(0) << "\" is not of size [6, 1]!"
+                      << endl;
+    return false;
+  }
+
+  return true;
+}
+
+void
+ExternalForceModel::output(const TaskInfo&)
+{
+  OpenFDMAssert(mInputPort.isConnected());
+  setForce(mInputPort.getMatrixValue());
+}
+
+} // namespace OpenFDM


Property changes on: trunk/OpenFDM/src/OpenFDM/ExternalForceModel.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/OpenFDM/src/OpenFDM/ExternalForceModel.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/ExternalForceModel.h	2006-01-06 08:18:07 UTC (rev 194)
+++ trunk/OpenFDM/src/OpenFDM/ExternalForceModel.h	2006-01-06 09:11:46 UTC (rev 195)
@@ -0,0 +1,31 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2006 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_ExternalForceModel_H
+#define OpenFDM_ExternalForceModel_H
+
+#include "Assert.h"
+#include "Object.h"
+#include "Vector.h"
+#include "Frame.h"
+#include "Force.h"
+
+namespace OpenFDM {
+
+class ExternalForceModel
+  : public ExternalForce {
+public:
+  ExternalForceModel(const std::string& name);
+  virtual ~ExternalForceModel(void);
+
+  virtual bool init(void);
+  virtual void output(const TaskInfo&);
+
+private:
+  MatrixPortHandle mInputPort;
+};
+
+} // namespace OpenFDM
+
+#endif


Property changes on: trunk/OpenFDM/src/OpenFDM/ExternalForceModel.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/OpenFDM/src/OpenFDM/Makefile.am
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Makefile.am	2006-01-06 08:18:07 UTC (rev 194)
+++ trunk/OpenFDM/src/OpenFDM/Makefile.am	2006-01-06 09:11:46 UTC (rev 195)
@@ -34,15 +34,13 @@
   CartesianActuatorFrame.h \
   CartesianJointFrame.h \
   Contact.h \
-  ConstantForce.h \
-  ConstSystem.h \
+  ConstModel.h \
   ConstFrameVisitor.h \
   CowPtr.h \
   DeadBand.h \
   DefaultGravity.h \
   DefaultGround.h \
   DefaultPlanet.h \
-  DirectForce.h \
   DiscBrake.h \
   DiscreteIntegrator.h \
   DoPri5.h \
@@ -50,6 +48,7 @@
   EnvironmentObject.h \
   ExplicitAdams.h \
   ExplicitEuler.h \
+  ExternalForceModel.h \
   Force.h \
   Frame.h \
   FrameVisitor.h \
@@ -143,13 +142,11 @@
   Bias.cpp \
   BinaryFunctionModel.cpp \
   Contact.cpp \
-  ConstantForce.cpp \
-  ConstSystem.cpp \
+  ConstModel.cpp \
   DeadBand.cpp \
   DefaultGravity.cpp \
   DefaultGround.cpp \
   DefaultPlanet.cpp \
-  DirectForce.cpp \
   DiscBrake.cpp \
   DiscreteIntegrator.cpp \
   DoPri5.cpp \
@@ -157,6 +154,7 @@
   EnvironmentObject.cpp \
   ExplicitAdams.cpp \
   ExplicitEuler.cpp \
+  ExternalForceModel.cpp \
   Force.cpp \
   Frame.cpp \
   Function.cpp \

Modified: trunk/OpenFDM/src/OpenFDM/Port.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Port.h	2006-01-06 08:18:07 UTC (rev 194)
+++ trunk/OpenFDM/src/OpenFDM/Port.h	2006-01-06 09:11:46 UTC (rev 195)
@@ -33,6 +33,7 @@
   RealPortInterface(unsigned m = 1, unsigned n = 1) : mValue(m, n) {}
   virtual RealPortInterface* toRealPortInterface(void)
   {
+    evaluate();
     if (Size(1, 1) == size(mValue))
       return this;
     else

Modified: trunk/OpenFDM/src/OpenFDM/Product.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Product.cpp	2006-01-06 08:18:07 UTC (rev 194)
+++ trunk/OpenFDM/src/OpenFDM/Product.cpp	2006-01-06 09:11:46 UTC (rev 195)
@@ -34,15 +34,39 @@
 bool
 Product::init(void)
 {
-  mFactorPorts.resize(getNumFactors());
+  mScalarFactorPorts.clear();
+  mMatrixFactorPorts.clear();
   for (unsigned i = 0; i < getNumInputPorts(); ++i) {
-    if (!getInputPort(i)->isConnected()) {
-      Log(Model, Error) << "Found unconnected input Port for Product \""
-                        << getName() << "\"" << endl;
-      return false;
+    RealPortHandle scalarHandle = getInputPort(i)->toRealPortHandle();
+    if (scalarHandle.isConnected())
+      mScalarFactorPorts.push_back(scalarHandle);
+    else {
+      MatrixPortHandle matrixHandle = getInputPort(i)->toMatrixPortHandle();
+      if (matrixHandle.isConnected()) {
+        if (!mMatrixFactorPorts.empty()) {
+          unsigned lastCols = cols(mMatrixFactorPorts.back().getMatrixValue());
+          unsigned thisRows = rows(matrixHandle.getMatrixValue());
+          if (lastCols != thisRows) {
+            Log(Model, Error) << "Dimensions for Product \""
+                              << getName() << "\" do not agree!" << endl;
+            return false;
+          }
+        }
+
+        mMatrixFactorPorts.push_back(matrixHandle);
+      } else {
+        Log(Model, Error) << "Found unconnected input Port for Product \""
+                          << getName() << "\"" << endl;
+        return false;
+      }
     }
-    mFactorPorts[i] = getInputPort(i)->toRealPortHandle();
   }
+  if (mMatrixFactorPorts.empty()) {
+    mProduct.resize(1, 1);
+  } else {
+    mProduct.resize(rows(mMatrixFactorPorts.front().getMatrixValue()),
+                    cols(mMatrixFactorPorts.back().getMatrixValue()));
+  }
 
   return true;
 }
@@ -50,14 +74,22 @@
 void
 Product::output(const TaskInfo&)
 {
-  mProduct = 1;
-  for (unsigned i = 0; i < getNumInputPorts(); ++i)
-    mProduct *= mFactorPorts[i].getRealValue();
+  real_type scalarFac = 1;
+  for (unsigned i = 0; i < mScalarFactorPorts.size(); ++i)
+    scalarFac *= mScalarFactorPorts[i].getRealValue();
+  if (mMatrixFactorPorts.empty()) {
+    mProduct(1, 1) = scalarFac;
+  } else {
+    mProduct = mMatrixFactorPorts[0].getMatrixValue();
+    for (unsigned i = 1; i < mMatrixFactorPorts.size(); ++i)
+      mProduct = mProduct*mMatrixFactorPorts[i].getMatrixValue();
+    mProduct *= scalarFac;
+  }
   Log(Model,Debug3) << "Output of Product \"" << getName() << "\" "
                     << mProduct << endl;
 }
 
-const real_type&
+const Matrix&
 Product::getProduct(void) const
 {
   return mProduct;

Modified: trunk/OpenFDM/src/OpenFDM/Product.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Product.h	2006-01-06 08:18:07 UTC (rev 194)
+++ trunk/OpenFDM/src/OpenFDM/Product.h	2006-01-06 09:11:46 UTC (rev 195)
@@ -21,14 +21,15 @@
   virtual bool init(void);
   virtual void output(const TaskInfo&);
 
-  const real_type& getProduct(void) const;
+  const Matrix& getProduct(void) const;
 
   unsigned getNumFactors(void) const;
   void setNumFactors(const unsigned& num);
 
 private:
-  real_type mProduct;
-  std::vector<RealPortHandle> mFactorPorts;
+  Matrix mProduct;
+  std::vector<RealPortHandle> mScalarFactorPorts;
+  std::vector<MatrixPortHandle> mMatrixFactorPorts;
 };
 
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/main.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/main.cpp	2006-01-06 08:18:07 UTC (rev 194)
+++ trunk/OpenFDM/src/OpenFDM/main.cpp	2006-01-06 09:11:46 UTC (rev 195)
@@ -44,7 +44,7 @@
 #include <OpenFDM/Model.h>
 #include <OpenFDM/ModelGroup.h>
 #include <OpenFDM/Bias.h>
-#include <OpenFDM/ConstSystem.h>
+#include <OpenFDM/ConstModel.h>
 #include <OpenFDM/DeadBand.h>
 #include <OpenFDM/DiscreteIntegrator.h>
 #include <OpenFDM/Gain.h>
@@ -308,7 +308,7 @@
     if (type == "Bias") {
       model = new Bias(name);
     } else if (type == "Const") {
-      model = new ConstSystem(name, Matrix()); // FIXME
+      model = new ConstModel(name, Matrix()); // FIXME
     } else if (type == "DeadBand") {
       model = new DeadBand(name);
     } else if (type == "DiscreteIntegrator") {



From frohlich at berlios.de  Fri Jan  6 18:29:45 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Fri, 6 Jan 2006 18:29:45 +0100
Subject: [OpenFDM-svn] r196 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200601061729.k06HTjC5011369@sheep.berlios.de>

Author: frohlich
Date: 2006-01-06 18:29:28 +0100 (Fri, 06 Jan 2006)
New Revision: 196

Modified:
   trunk/OpenFDM/src/OpenFDM/MobileRootJoint.cpp
Log:
Increase the renormalization term


Modified: trunk/OpenFDM/src/OpenFDM/MobileRootJoint.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/MobileRootJoint.cpp	2006-01-06 09:11:46 UTC (rev 195)
+++ trunk/OpenFDM/src/OpenFDM/MobileRootJoint.cpp	2006-01-06 17:29:28 UTC (rev 196)
@@ -206,7 +206,7 @@
   // if |q| > 1 add a little radial component inward
   Quaternion q = mFrame->getOrientation();
   Vector3 angVel = mFrame->getRelVel().getAngular();
-  Vector4 qderiv = derivative(q, angVel) + 0.1*(normalize(q) - q);
+  Vector4 qderiv = derivative(q, angVel) + 1e1*(normalize(q) - q);
   return qderiv;
 }
 



From frohlich at berlios.de  Fri Jan  6 18:31:02 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Fri, 6 Jan 2006 18:31:02 +0100
Subject: [OpenFDM-svn] r197 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200601061731.k06HV2O2012575@sheep.berlios.de>

Author: frohlich
Date: 2006-01-06 18:30:35 +0100 (Fri, 06 Jan 2006)
New Revision: 197

Modified:
   trunk/OpenFDM/src/OpenFDM/Newton.cpp
Log:
Fix levenberg-marquart


Modified: trunk/OpenFDM/src/OpenFDM/Newton.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Newton.cpp	2006-01-06 17:29:28 UTC (rev 196)
+++ trunk/OpenFDM/src/OpenFDM/Newton.cpp	2006-01-06 17:30:35 UTC (rev 197)
@@ -304,11 +304,13 @@
                   unsigned *itCount,
                   unsigned maxit)
 {
+  Log(NewtonMethod, Debug3) << "Start guess\nx = " << trans(x) << endl;
+
   Matrix J;
   LinAlg::MatrixFactors<real_type,0,0,LinAlg::LUTag> jacFactors;
 
-  bool converged;
-  real_type tau = 1e-3;
+  bool converged = false;
+  real_type tau = 1e-1;
   real_type nu = 2;
 
   // Compute in each step a new jacobian
@@ -332,15 +334,16 @@
     Log(NewtonMethod, Debug) << "Solve Residual "
                              << norm(trans(J)*J*h + mu*h + g)/norm(g) << endl;
 
+    // Get a better search guess
+    Vector xnew = x + h;
+
     // check convergence
-    converged = norm1(h) < atol;
+    converged = equal(x, xnew, atol, rtol);
     Log(NewtonMethod, Debug) << "Convergence test: ||h||_1 = " << norm1(h)
                              << ", converged = " << converged << endl;
     if (converged)
       break;
 
-    // Get a better search guess
-    Vector xnew = x + h;
     f.eval(t, x, fx);
     real_type Fx = norm(fx);
     f.eval(t, xnew, fx);
@@ -351,6 +354,10 @@
                              << ", Fx = " << Fx
                              << endl;
     if (0 < rho) {
+      Log(NewtonMethod, Debug) << "Accepted step!" << endl;
+      Log(NewtonMethod, Debug3) << "xnew = " << trans(xnew) << endl;
+      Log(NewtonMethod, Debug3) << "h    = " << trans(h) << endl;
+
       // New guess is the better one
       x = xnew;
 
@@ -363,7 +370,7 @@
       Log(NewtonMethod, Debug) << "||g||_1 = " << norm1(g) << endl;
 
       mu = mu * max(1.0/3, 1-pow(2*rho-1, 3));
-      mu = 2;
+      nu = 2;
 
     } else {
       mu = mu * nu;



From frohlich at berlios.de  Fri Jan  6 18:32:01 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Fri, 6 Jan 2006 18:32:01 +0100
Subject: [OpenFDM-svn] r198 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200601061732.k06HW19V014430@sheep.berlios.de>

Author: frohlich
Date: 2006-01-06 18:31:41 +0100 (Fri, 06 Jan 2006)
New Revision: 198

Modified:
   trunk/OpenFDM/src/OpenFDM/System.cpp
Log:
Use levenberg marquart


Modified: trunk/OpenFDM/src/OpenFDM/System.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/System.cpp	2006-01-06 17:30:35 UTC (rev 197)
+++ trunk/OpenFDM/src/OpenFDM/System.cpp	2006-01-06 17:31:41 UTC (rev 198)
@@ -287,14 +287,14 @@
   virtual unsigned inSize(void) const
   { return mSystem.getNumContinousStates(); }
   virtual unsigned outSize(void) const
-  { return mSystem.getNumContinousStates(); }
+  { return mSystem.getNumContinousStates() + 6; }
   virtual void eval(real_type t, const Vector& v, Vector& out)
   {
     unsigned nStates = mSystem.getNumContinousStates();
     Vector deriv(nStates);
     mSystem.evalFunction(t, v, deriv);
 
-    TrimCollectorVisitor tcv(nStates);
+    TrimCollectorVisitor tcv(nStates + 6);
     mSystem.accept(tcv);
     Vector3 eo = mGeodOr.getEuler();
     Vector3 en = tcv.mGeodOr.getEuler();
@@ -315,14 +315,14 @@
     tmp = 1e2*(eo(3) - en(3));
     tcv.mStateStream.writeSubState(tmp);
 
-    tcv.mStateStream.writeSubState(1e2*norm(tcv.mQDot) + norm(tcv.mPosDot - mPosDot));
-//     tcv.mStateStream.writeSubState(1e2*tcv.mQDot);
-//     tcv.mStateStream.writeSubState(tcv.mPosDot);
+//     tcv.mStateStream.writeSubState(1e2*norm(tcv.mQDot) + norm(tcv.mPosDot - mPosDot));
+    tcv.mStateStream.writeSubState(1e8*tcv.mQDot);
+    tcv.mStateStream.writeSubState(tcv.mPosDot - mPosDot);
     tcv.mStateStream.writeSubState(1e6*tcv.mVelDot);
 
     out = tcv.mStateStream.getState();
   }
-private:
+// private:
   System& mSystem;
   Geodetic mGeodPos;
   Quaternion mGeodOr;
@@ -379,7 +379,7 @@
 //     Log(Model,Error) << trans(out) << endl;
 //     Log(Model,Error) << mGeodPos << geod << endl << endl;
   }
-private:
+// private:
   System& mSystem;
   real_type mRange;
   Geodetic mGeodPos;
@@ -404,6 +404,9 @@
   real_type range = 20;
   AltitudeFinderTrimFunction altTrim(*this, range);
 
+  // Buld up the trim function
+  TrimFunction trimFunction(*this);
+
   Vector altV(1);
   altV(1) = 0;
   Vector dk(1);
@@ -412,6 +415,7 @@
   altTrim.eval(getTime(), res, dk /*dummy*/);
   output(taskInfo);
 
+  trimFunction.mGeodPos.altitude = altTrim.mGeodPos.altitude;
 
   // Get the current state
   StateStream stateStream(getNumContinousStates());
@@ -419,18 +423,18 @@
   Vector state = stateStream.getState();
 
   Vector trimState = stateStream.getState();
-  // Buld up the trim function
-  TrimFunction trimFunction(*this);
 
   // Try to find a minimum
-  real_type atol = 1e-7;
-  real_type rtol = 1e-8;
-  bool ret = GaussNewton(trimFunction, getTime(), trimState, atol, rtol);
-//   bool ret = LevenbergMarquart(trimFunction, getTime(), trimState, atol, rtol);
+  real_type atol = 1e-10;
+  real_type rtol = 1e-13;
+//   bool ret = GaussNewton(trimFunction, getTime(), trimState, atol, rtol);
+  bool ret = LevenbergMarquart(trimFunction, getTime(), trimState, atol, rtol);
   if (ret) {
+    Log(Model, Debug) << "Trim did converge" << endl;
     stateStream.setState(trimState);
     setState(stateStream);
   } else {
+    Log(Model, Warning) << "Trim did NOT converge" << endl;
     stateStream.setState(state);
     setState(stateStream);
   }



From frohlich at berlios.de  Sun Jan  8 12:51:34 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Sun, 8 Jan 2006 12:51:34 +0100
Subject: [OpenFDM-svn] r199 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200601081151.k08BpYuo020013@sheep.berlios.de>

Author: frohlich
Date: 2006-01-08 12:51:24 +0100 (Sun, 08 Jan 2006)
New Revision: 199

Modified:
   trunk/OpenFDM/src/OpenFDM/Units.cpp
Log:
Fix unit conversion for rankine


Modified: trunk/OpenFDM/src/OpenFDM/Units.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Units.cpp	2006-01-06 17:31:41 UTC (rev 198)
+++ trunk/OpenFDM/src/OpenFDM/Units.cpp	2006-01-08 11:51:24 UTC (rev 199)
@@ -186,10 +186,10 @@
   case uDegC:
     return value - static_cast<real_type>(273.15);
   case uRankine:
-    return value*(static_cast<real_type>(5)/static_cast<real_type>(9));
+    return value*(static_cast<real_type>(9)/static_cast<real_type>(5));
   case uFahrenheit:
-    return value*(static_cast<real_type>(5)/static_cast<real_type>(9))
-      - static_cast<real_type>(5*27315)/static_cast<real_type>(900)
+    return value*(static_cast<real_type>(9)/static_cast<real_type>(5))
+      - static_cast<real_type>(9*27315)/static_cast<real_type>(500)
       + static_cast<real_type>(32);
 
     // Spring stiffness.
@@ -304,11 +304,11 @@
   case uDegC:
     return value + static_cast<real_type>(273.15);
   case uRankine:
-    return value*(static_cast<real_type>(9)/static_cast<real_type>(5));
+    return value*(static_cast<real_type>(5)/static_cast<real_type>(9));
   case uFahrenheit:
-    return value*(static_cast<real_type>(9)/static_cast<real_type>(5))
+    return value*(static_cast<real_type>(5)/static_cast<real_type>(9))
       + static_cast<real_type>(273.15)
-      - static_cast<real_type>(32*9)/static_cast<real_type>(5);
+      - static_cast<real_type>(32*5)/static_cast<real_type>(9);
 
     // Spring stiffness.
   case uNewtonPMeter:



From frohlich at berlios.de  Sun Jan  8 21:45:03 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Sun, 8 Jan 2006 21:45:03 +0100
Subject: [OpenFDM-svn] r200 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200601082045.k08Kj3b6027706@sheep.berlios.de>

Author: frohlich
Date: 2006-01-08 21:44:55 +0100 (Sun, 08 Jan 2006)
New Revision: 200

Modified:
   trunk/OpenFDM/src/OpenFDM/AeroForce.cpp
   trunk/OpenFDM/src/OpenFDM/Atmosphere.cpp
   trunk/OpenFDM/src/OpenFDM/Atmosphere.h
   trunk/OpenFDM/src/OpenFDM/AtmosphereSTD1976.cpp
Log:
Clean up atmosphere computations a bit


Modified: trunk/OpenFDM/src/OpenFDM/AeroForce.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/AeroForce.cpp	2006-01-08 11:51:24 UTC (rev 199)
+++ trunk/OpenFDM/src/OpenFDM/AeroForce.cpp	2006-01-08 20:44:55 UTC (rev 200)
@@ -564,8 +564,8 @@
 {
   computeAtmosphere();
   Log(ArtBody, Debug3) << "AeroForce::getSoundSpeed() "
-                       << mAtmos.soundspeed << endl;
-  return mAtmos.soundspeed;
+                       << mSoundSpeed << endl;
+  return mSoundSpeed;
 }
 
 const real_type&
@@ -595,7 +595,7 @@
 AeroForce::getSoundSpeedSeaLevel(void) const
 {
   computeSLAtmosphere();
-  return mSLAtmos.soundspeed;
+  return mSLSoundSpeed;
 }
 
 const real_type&
@@ -665,6 +665,7 @@
   if (mDirtyAtmosphere) {
     // Get the Athmosphere information at this position and the given time.
     mAtmos = getAtmosphere()->getData(getAltitude());
+    mSoundSpeed = getAtmosphere()->getSoundSpeed(mAtmos.temperature);
     mDirtyAtmosphere = false;
   }
 }
@@ -675,6 +676,7 @@
   if (mDirtySLAtmosphere) {
     // Hmm, may be this does not need to be computed each time???
     mSLAtmos = getAtmosphere()->getData(0);
+    mSLSoundSpeed = getAtmosphere()->getSoundSpeed(mSLAtmos.temperature);
     mDirtySLAtmosphere = false;
   }
 }

Modified: trunk/OpenFDM/src/OpenFDM/Atmosphere.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Atmosphere.cpp	2006-01-08 11:51:24 UTC (rev 199)
+++ trunk/OpenFDM/src/OpenFDM/Atmosphere.cpp	2006-01-08 20:44:55 UTC (rev 200)
@@ -6,7 +6,9 @@
 
 namespace OpenFDM {
 
-Atmosphere::Atmosphere(void)
+Atmosphere::Atmosphere(real_type gasConstant, real_type specificHeatRatio) :
+  mGasConstant(gasConstant),
+  mSpecificHeatRatio(specificHeatRatio)
 {
 }
 

Modified: trunk/OpenFDM/src/OpenFDM/Atmosphere.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Atmosphere.h	2006-01-08 11:51:24 UTC (rev 199)
+++ trunk/OpenFDM/src/OpenFDM/Atmosphere.h	2006-01-08 20:44:55 UTC (rev 200)
@@ -13,18 +13,47 @@
 struct AtmosphereData {
   real_type pressure;
   real_type density;
-  real_type soundspeed;
   real_type temperature;
 };
 
 class Atmosphere
   : public EnvironmentObject {
 public:
-  Atmosphere(void);
   virtual ~Atmosphere(void);
 
+  /// Returns the gas constant for that current atmosphere gas often refered
+  /// as R. The unit is as usual in the SI system m^2/(s^2 K)
+  real_type getGasConstant(void) const
+  { return mGasConstant; }
+  real_type getR(void) const
+  { return mGasConstant; }
+
+  /// Returns the soundspeed for the given temperature
+  real_type getSoundSpeed(real_type temperature) const
+  { return sqrt(getGamma(temperature)*temperature*getGasConstant()); }
+
+  /// Returns the specific heat ratio
+  real_type getSpecificHeatRatio(real_type temperature) const
+  { return mSpecificHeatRatio; }
+  real_type getGamma(real_type temperature) const
+  { return mSpecificHeatRatio; }
+
+  /// Returns the specific heat constant
+  real_type getCp(real_type temperature) const
+  {
+    real_type gamma = getGamma(temperature);
+    return getGasConstant()*gamma/(gamma-1);
+  }
+
   // Get the atmosphere data for a given altitude alt.
   virtual AtmosphereData getData(real_type alt) const = 0;
+
+protected:
+  Atmosphere(real_type gasConstant, real_type specificHeatRatio);
+
+private:
+  real_type mGasConstant;
+  real_type mSpecificHeatRatio;
 };
 
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/AtmosphereSTD1976.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/AtmosphereSTD1976.cpp	2006-01-08 11:51:24 UTC (rev 199)
+++ trunk/OpenFDM/src/OpenFDM/AtmosphereSTD1976.cpp	2006-01-08 20:44:55 UTC (rev 200)
@@ -22,7 +22,12 @@
 // Radius of the Earth (km)
 const real_type AtmosphereSTD1976::mEarthRadius = 6369.0;
 
-AtmosphereSTD1976::AtmosphereSTD1976(void)
+#define MOL_WT          28.9644  // kg/kgmol (air)
+#define R_HAT           8314.32  // J/kgmol.K (gas const.)
+#define GAMMA           1.4
+
+AtmosphereSTD1976::AtmosphereSTD1976(void) :
+  Atmosphere(R_HAT/MOL_WT, GAMMA)
 {
   mTable[0.0] = TableData(288.15, 1.0, -6.5);
   mTable[11.0] = TableData(216.65, 2.233611e-1, 0.0);
@@ -92,23 +97,14 @@
   // Temperature in kelvin
   data.temperature = slTemperature*theta;
 
-const real_type specific_heat_ratio = 1.4;
-
-#define MOL_WT          28.9644  /*  kg/kgmol (air)         */
-#define R_HAT         8314.32    /*  J/kgmol.K (gas const.) */
-
-
   if (fabs(data.temperature) > Limits<real_type>::min())
-    data.density = data.pressure / ((R_HAT/MOL_WT)*data.temperature);
+    data.density = data.pressure / (getGasConstant()*data.temperature);
   else
     data.density = 0.0;
-  data.soundspeed = sqrt(specific_heat_ratio*data.temperature*(R_HAT/MOL_WT));
 
-
   Log(Environment, Debug) << "p = " << data.pressure << ", T = "
                           << data.temperature << ", rho = "
-                          << data.density << ", soundspeed = "
-                          << data.soundspeed << endl;
+                          << data.density << endl;
   
   return data;
 }



From frohlich at berlios.de  Sun Jan  8 21:45:26 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Sun, 8 Jan 2006 21:45:26 +0100
Subject: [OpenFDM-svn] r201 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200601082045.k08KjQn7027766@sheep.berlios.de>

Author: frohlich
Date: 2006-01-08 21:45:24 +0100 (Sun, 08 Jan 2006)
New Revision: 201

Modified:
   trunk/OpenFDM/src/OpenFDM/AeroForce.h
Log:
.. well, belongs to past checkin.


Modified: trunk/OpenFDM/src/OpenFDM/AeroForce.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/AeroForce.h	2006-01-08 20:44:55 UTC (rev 200)
+++ trunk/OpenFDM/src/OpenFDM/AeroForce.h	2006-01-08 20:45:24 UTC (rev 201)
@@ -129,7 +129,9 @@
   mutable Vector3 mUnitDown;
   mutable Plane mLocalGroundPlane;
   mutable AtmosphereData mAtmos;
+  mutable real_type mSoundSpeed;
   mutable AtmosphereData mSLAtmos;
+  mutable real_type mSLSoundSpeed;
   mutable Vector6 mAirSpeed;
   mutable Vector3 mMach;
   mutable real_type mMachNumber;



From frohlich at berlios.de  Mon Jan 16 19:18:19 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Mon, 16 Jan 2006 19:18:19 +0100
Subject: [OpenFDM-svn] r202 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200601161818.k0GIIJQv026125@sheep.berlios.de>

Author: frohlich
Date: 2006-01-16 19:18:15 +0100 (Mon, 16 Jan 2006)
New Revision: 202

Modified:
   trunk/OpenFDM/src/OpenFDM/Tank.cpp
Log:
Add missing functions


Modified: trunk/OpenFDM/src/OpenFDM/Tank.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Tank.cpp	2006-01-08 20:45:24 UTC (rev 201)
+++ trunk/OpenFDM/src/OpenFDM/Tank.cpp	2006-01-16 18:18:15 UTC (rev 202)
@@ -87,4 +87,16 @@
   mContent = content;
 }
 
+const real_type&
+Tank::getCapacity(void) const
+{
+  return mCapacity;
+}
+
+void
+Tank::setCapacity(const real_type& capacity)
+{
+  mCapacity = capacity;
+}
+
 } // namespace OpenFDM



From frohlich at berlios.de  Mon Jan 16 19:18:50 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Mon, 16 Jan 2006 19:18:50 +0100
Subject: [OpenFDM-svn] r203 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200601161818.k0GIIo7A026291@sheep.berlios.de>

Author: frohlich
Date: 2006-01-16 19:18:36 +0100 (Mon, 16 Jan 2006)
New Revision: 203

Modified:
   trunk/OpenFDM/src/OpenFDM/ConstModel.h
Log:
Add default argument


Modified: trunk/OpenFDM/src/OpenFDM/ConstModel.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/ConstModel.h	2006-01-16 18:18:15 UTC (rev 202)
+++ trunk/OpenFDM/src/OpenFDM/ConstModel.h	2006-01-16 18:18:36 UTC (rev 203)
@@ -13,7 +13,7 @@
 class ConstModel
   : public Model {
 public:
-  ConstModel(const std::string& name, const Matrix& value);
+  ConstModel(const std::string& name, const Matrix& value = Matrix());
   virtual ~ConstModel(void);
 
   const Matrix& getValue(void) const;



From frohlich at berlios.de  Mon Jan 16 19:19:14 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Mon, 16 Jan 2006 19:19:14 +0100
Subject: [OpenFDM-svn] r204 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200601161819.k0GIJEGR026465@sheep.berlios.de>

Author: frohlich
Date: 2006-01-16 19:19:05 +0100 (Mon, 16 Jan 2006)
New Revision: 204

Modified:
   trunk/OpenFDM/src/OpenFDM/UnaryFunctionModel.h
Log:
Add default argument


Modified: trunk/OpenFDM/src/OpenFDM/UnaryFunctionModel.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/UnaryFunctionModel.h	2006-01-16 18:18:36 UTC (rev 203)
+++ trunk/OpenFDM/src/OpenFDM/UnaryFunctionModel.h	2006-01-16 18:19:05 UTC (rev 204)
@@ -35,7 +35,7 @@
     Tan
   };
 
-  UnaryFunctionModel(const std::string& name, Type type);
+  UnaryFunctionModel(const std::string& name, Type type = Abs /*FIXME*/);
   virtual ~UnaryFunctionModel(void);
 
   virtual bool init(void);



From frohlich at berlios.de  Mon Jan 16 20:47:29 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Mon, 16 Jan 2006 20:47:29 +0100
Subject: [OpenFDM-svn] r205 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200601161947.k0GJlT5t004124@sheep.berlios.de>

Author: frohlich
Date: 2006-01-16 20:46:50 +0100 (Mon, 16 Jan 2006)
New Revision: 205

Modified:
   trunk/OpenFDM/src/OpenFDM/AirSpring.cpp
   trunk/OpenFDM/src/OpenFDM/AirSpring.h
Log:
Add some properties


Modified: trunk/OpenFDM/src/OpenFDM/AirSpring.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/AirSpring.cpp	2006-01-16 18:19:05 UTC (rev 204)
+++ trunk/OpenFDM/src/OpenFDM/AirSpring.cpp	2006-01-16 19:46:50 UTC (rev 205)
@@ -17,10 +17,18 @@
   mMaxCompression(0),
   mMinDamperConstant(0),
   mMaxDamperConstant(0),
-  mGamma(1.3)
+  mGamma(1.4)
 {
   setDirectFeedThrough(true);
 
+  addProperty("pushPressure", Property(this, &AirSpring::getPushPressure, &AirSpring::setPushPressure));
+  addProperty("pullPressure", Property(this, &AirSpring::getPullPressure, &AirSpring::setPullPressure));
+  addProperty("area", Property(this, &AirSpring::getArea, &AirSpring::setArea));
+  addProperty("maxCompression", Property(this, &AirSpring::getMaxCompression, &AirSpring::setMaxCompression));
+  addProperty("minCompression", Property(this, &AirSpring::getMinCompression, &AirSpring::setMinCompression));
+  addProperty("maxDamperConstant", Property(this, &AirSpring::getMaxDamperConstant, &AirSpring::setMaxDamperConstant));
+  addProperty("minDamperConstant", Property(this, &AirSpring::getMinDamperConstant, &AirSpring::setMinDamperConstant));
+
   setNumInputPorts(2);
   setInputPortName(0, "position");
   setInputPortName(1, "velocity");
@@ -91,86 +99,86 @@
   return mForce;
 }
 
-real_type
+const real_type&
 AirSpring::getPushPressure(void) const
 {
   return mPushPressure;
 }
 
 void
-AirSpring::setPushPressure(real_type pushPressure)
+AirSpring::setPushPressure(const real_type& pushPressure)
 {
   mPushPressure = pushPressure;
 }
 
-real_type
+const real_type&
 AirSpring::getPullPressure(void) const
 {
   return mPullPressure;
 }
 
 void
-AirSpring::setPullPressure(real_type pullPressure)
+AirSpring::setPullPressure(const real_type& pullPressure)
 {
   mPullPressure = pullPressure;
 }
 
-real_type
+const real_type&
 AirSpring::getArea(void) const
 {
   return mArea;
 }
 
 void
-AirSpring::setArea(real_type area)
+AirSpring::setArea(const real_type& area)
 {
   mArea = area;
 }
 
-real_type
+const real_type&
 AirSpring::getMaxCompression(void) const
 {
   return mMaxCompression;
 }
 
 void
-AirSpring::setMaxCompression(real_type maxCompression)
+AirSpring::setMaxCompression(const real_type& maxCompression)
 {
   mMaxCompression = maxCompression;
 }
 
-real_type
+const real_type&
 AirSpring::getMinCompression(void) const
 {
   return mMinCompression;
 }
 
 void
-AirSpring::setMinCompression(real_type minCompression)
+AirSpring::setMinCompression(const real_type& minCompression)
 {
   mMinCompression = minCompression;
 }
 
-real_type
+const real_type&
 AirSpring::getMaxDamperConstant(void) const
 {
   return mMaxDamperConstant;
 }
 
 void
-AirSpring::setMaxDamperConstant(real_type maxDamperConstant)
+AirSpring::setMaxDamperConstant(const real_type& maxDamperConstant)
 {
   mMaxDamperConstant = maxDamperConstant;
 }
 
-real_type
+const real_type&
 AirSpring::getMinDamperConstant(void) const
 {
   return mMinDamperConstant;
 }
 
 void
-AirSpring::setMinDamperConstant(real_type minDamperConstant)
+AirSpring::setMinDamperConstant(const real_type& minDamperConstant)
 {
   mMinDamperConstant = minDamperConstant;
 }

Modified: trunk/OpenFDM/src/OpenFDM/AirSpring.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/AirSpring.h	2006-01-16 18:19:05 UTC (rev 204)
+++ trunk/OpenFDM/src/OpenFDM/AirSpring.h	2006-01-16 19:46:50 UTC (rev 205)
@@ -22,26 +22,26 @@
 
   const real_type& getForce(void) const;
 
-  real_type getPushPressure(void) const;
-  void setPushPressure(real_type pushPressure);
+  const real_type& getPushPressure(void) const;
+  void setPushPressure(const real_type& pushPressure);
 
-  real_type getPullPressure(void) const;
-  void setPullPressure(real_type pullPressure);
+  const real_type& getPullPressure(void) const;
+  void setPullPressure(const real_type& pullPressure);
 
-  real_type getArea(void) const;
-  void setArea(real_type area);
+  const real_type& getArea(void) const;
+  void setArea(const real_type& area);
 
-  real_type getMaxCompression(void) const;
-  void setMaxCompression(real_type maxCompression);
+  const real_type& getMaxCompression(void) const;
+  void setMaxCompression(const real_type& maxCompression);
 
-  real_type getMinCompression(void) const;
-  void setMinCompression(real_type minCompression);
+  const real_type& getMinCompression(void) const;
+  void setMinCompression(const real_type& minCompression);
 
-  real_type getMaxDamperConstant(void) const;
-  void setMaxDamperConstant(real_type maxDamperConstant);
+  const real_type& getMaxDamperConstant(void) const;
+  void setMaxDamperConstant(const real_type& maxDamperConstant);
 
-  real_type getMinDamperConstant(void) const;
-  void setMinDamperConstant(real_type minDamperConstant);
+  const real_type& getMinDamperConstant(void) const;
+  void setMinDamperConstant(const real_type& minDamperConstant);
 
   real_type getGamma(void) const;
   void setGamma(real_type gamma);



From frohlich at berlios.de  Mon Jan 16 20:48:19 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Mon, 16 Jan 2006 20:48:19 +0100
Subject: [OpenFDM-svn] r206 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200601161948.k0GJmJTC004397@sheep.berlios.de>

Author: frohlich
Date: 2006-01-16 20:48:11 +0100 (Mon, 16 Jan 2006)
New Revision: 206

Modified:
   trunk/OpenFDM/src/OpenFDM/Object.cpp
   trunk/OpenFDM/src/OpenFDM/Object.h
Log:
Remove an other part of an obsolete interface


Modified: trunk/OpenFDM/src/OpenFDM/Object.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Object.cpp	2006-01-16 19:46:50 UTC (rev 205)
+++ trunk/OpenFDM/src/OpenFDM/Object.cpp	2006-01-16 19:48:11 UTC (rev 206)
@@ -28,16 +28,6 @@
   return 0;
 }
 
-Property
-Object::getProperty(const std::string& name)
-{
-  // Check if this one exists and return its value.
-  if (0 < mProperties.count(name))
-    return mProperties[name];
-  else
-    return Property();
-}
-
 std::list<std::string>
 Object::listProperties(void) const
 {
@@ -53,22 +43,33 @@
 Variant
 Object::getPropertyValue(const std::string& name) const
 {
-  // Just use the current property system for now
-
   // Return an empty variant if this property does not exist.
   if (mProperties.count(name) <= 0)
     return Variant();
 
+  // safety check
+  Property property = mProperties.find(name)->second;
+  if (!property.isValid())
+    return Variant();
+
   // Return the value of the property
-  // FIXME: properties, like they are now, do not preserve constness
-  return ((Property&)(mProperties.find(name)->second)).getValue();
+  return property.getValue();
 }
 
 void
 Object::setPropertyValue(const std::string& name, const Variant& value)
 {
   // Just use the current property system for now
-  getProperty(name).setValue(value);
+  if (mProperties.count(name) <= 0)
+    return;
+
+  // safety check
+  Property property = mProperties[name];
+  if (!property.isValid())
+    return;
+
+  // set the property by the setter
+  property.setValue(value);
 }
 
 void

Modified: trunk/OpenFDM/src/OpenFDM/Object.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Object.h	2006-01-16 19:46:50 UTC (rev 205)
+++ trunk/OpenFDM/src/OpenFDM/Object.h	2006-01-16 19:48:11 UTC (rev 206)
@@ -34,7 +34,6 @@
   /// Return the typeinfo for that Object.
   virtual const TypeInfo* const getTypeInfo(void) const;
   
-  Property getProperty(const std::string& name);
   std::list<std::string> listProperties(void) const;
 
   /// Returns the objects property named name



From frohlich at berlios.de  Mon Jan 16 20:49:27 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Mon, 16 Jan 2006 20:49:27 +0100
Subject: [OpenFDM-svn] r207 - trunk/OpenFDM/src/JSBSim
Message-ID: <200601161949.k0GJnRHl004711@sheep.berlios.de>

Author: frohlich
Date: 2006-01-16 20:49:24 +0100 (Mon, 16 Jan 2006)
New Revision: 207

Modified:
   trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
   trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.h
Log:
Ok, just safe the current state of the legacy JSBSim reader


Modified: trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
===================================================================
--- trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2006-01-16 19:48:11 UTC (rev 206)
+++ trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2006-01-16 19:49:24 UTC (rev 207)
@@ -1167,7 +1167,7 @@
 
 #if 0
       // Well, we use an air spring for that. It is directly in the
-      // revolute joint. That is wring, but at the moment aprioriate.
+      // revolute joint. That is wrong, but at the moment aprioriate.
       AirSpring* aoDamp = new AirSpring(name + " Air Spring Force");
       aoDamp->setPullPressure(pullPress);
       aoDamp->setPushPressure(pushPress);
@@ -1938,21 +1938,10 @@
   std::list<SharedPtr<XMLElement> >::const_iterator it;
   for (it = elems.begin(); it != elems.end(); ++it) {
     if ((*it)->getName() == "AC_ENGINE") {
-//       std::string engineFile = mEnginePath+(*it)->getAttribute("FILE")+".xml";
-//       std::ifstream infile;
-//       infile.open(engineFile.c_str());
-//       if (!infile.is_open())
-//         return;
-
-//       XMLDomParser parser;
-//       if (!parser.parseXML(infile))
-//         return;
-//       infile.close();
-
       std::stringstream sstr;
       sstr << engineNumber;
       ++engineNumber;
-      if (!convertEngine((*it)->getData(), (*it)->getName(), sstr.str()))
+      if (!convertEngine(*it, sstr.str()))
         return error("Cannot parse engine");
     }
     else if ((*it)->getName() == "AC_TANK") {
@@ -2058,12 +2047,10 @@
 }
 
 bool
-LegacyJSBSimReader::convertEngine(const std::string& data,
-                                  const std::string& type,
+LegacyJSBSimReader::convertEngine(const XMLElement* engine,
                                   const std::string& number)
 {
-  std::stringstream datastr(data);
-
+  std::stringstream datastr(engine->getData());
   Vector3 loc = Vector3::zeros();
   real_type pitch = 0;
   real_type yaw = 0;
@@ -2096,12 +2083,224 @@
     } else
       return error("Unknown parameter in engine configuration");
   }
+  loc = structToBody(loc);
+  Quaternion orientation = Quaternion::fromHeadAttBank(pitch, 0, yaw);
 
 
+  // Engines are distinguished between that turbine model which effectively
+  // moslty produces thrust by itself and the ones having a propeller and an
+  // engine driving that.
+  // The first one has its own single model.
+  // For the second, the engine is modelled with a joint force/driver
+  // the propeller with an aerodynamic table lookup system.
+  std::string engineName = engine->getAttribute("FILE");
+  std::string eFileName = engineName + ".xml";
+  std::ifstream eFileStream;
+  if (!openFile(mEnginePath, eFileName, eFileStream))
+    return error("Can not find engine \"" + engineName + "\"");
 
+  XMLDomParser eParser;
+  if (!eParser.parseXML(eFileStream))
+    return error("Error parsing engine \"" + engineName + "\"");
+  eFileStream.close();
+
+  const XMLDocument* engineDoc = eParser.getDocument();
+  // Be paranoid ...
+  if (!engineDoc)
+    return error("Error reading engine \"" + engineName + "\"");
+
+  const XMLElement* engineTopElem = engineDoc->getElement();
+  if (!engineTopElem)
+    return error("No toplevel xml element found for engine \""
+                 + engineName + "\"");
+
+  if (engineTopElem->getName() == "FG_TURBINE") {
+    if (!convertTurbine(engineTopElem, number, loc, orientation, 0))
+      return error("Error readinge turbine configuration");
+    
+  } else if (engineTopElem->getName() == "FG_PISTON") {
+    if (!convertPiston(engineTopElem, number, 0))
+      return error("Error readinge piston configuration");
+
+  } else if (engineTopElem->getName() == "FG_ROCKET") {
+    return error("FG_ROCKET's are not (yet?) supported!");
+
+  } else if (engineTopElem->getName() == "FG_ELECTRIC") {
+    if (!convertElectric(engineTopElem, number, 0))
+      return error("Error readinge electric configuration");
+
+  } else
+    return error("Unknown toplevel xml element for engine file \""
+                 + eFileName + "\"");
+
+
+  // Thruster
+  const XMLElement* thruster = engine->getElement("AC_THRUSTER");
+  std::string thrusterName = thruster->getAttribute("FILE");
+  std::string tFileName = thrusterName + ".xml";
+  std::ifstream tFileStream;
+  if (!openFile(mEnginePath, tFileName, tFileStream))
+    return error("Can not find thruster \"" + thrusterName + "\"");
+
+  XMLDomParser tParser;
+  if (!tParser.parseXML(tFileStream))
+    return error("Error parsing thruster \"" + thrusterName + "\"");
+  tFileStream.close();
+
+  const XMLDocument* thrusterDoc = tParser.getDocument();
+  // Be paranoid ...
+  if (!thrusterDoc)
+    return error("Error reading thruster \"" + thrusterName + "\"");
+
+  const XMLElement* thrusterTopElem = thrusterDoc->getElement();
+  if (!thrusterTopElem)
+    return error("No toplevel xml element found for thruster \""
+                 + thrusterName + "\"");
+
+  if (thrusterTopElem->getName() == "FG_DIRECT") {
+  } else if (thrusterTopElem->getName() == "FG_NOZZLE") {
+  } else if (thrusterTopElem->getName() == "FG_PROPELLER") {
+  } else
+    return error("Unknown toplevel xml element for thruster file \""
+                 + tFileName + "\"");
+
+
+
+
+
+
+
+
+
+
+
+
+
+//   RevoluteJoint* wj = new RevoluteJoint(name + " Wheel Joint");
+//   parent->addInteract(wj);
+//   wheel->setInLDoboardJoint(wj);
+//   wj->setJointAxis(Vector3(0, 1, 0));
+//   wj->setPosition(pos);
+//   wj->setOrientation(Quaternion::unit());
+//   wj->setJointPos(0);
+//   wj->setJointVel(0);
+
+//     DiscBrake* brakeF = new DiscBrake(name + " Brake Force");
+//     brakeF->setMinForce(8e1);
+//     brakeF->setMaxForce(1e4);
+//     if (brake == "LEFT") {
+//       Port* port = lookupJSBExpression("gear/left-brake-pos-norm");
+//       brakeF->getInputPort(0)->connect(port);
+//     } else if (brake == "RIGHT") {
+//       Port* port = lookupJSBExpression("gear/right-brake-pos-norm");
+//       brakeF->getInputPort(0)->connect(port);
+//     }
+//     // That one reads the joint position and velocity ...
+//     brakeF->getInputPort(1)->connect(wj->getOutputPort(1));
+//     // ... and provides an output force
+//     wj->getInputPort(0)->connect(brakeF->getOutputPort(0));
+//     addMultiBodyModel(brakeF);
+
+
+
+
+
+
+//   std::string namestr = "Engine<" + number + ">";
+//   ConstModel* fullForce = new ConstModel(namestr + " full",
+//                                          Vector6(0, 0, 0, 4.4*1.5e4, 0, 0));
+//   addMultiBodyModel(fullForce);
+
+//   Product* prod = new Product(namestr + " modulation");
+//   std::string throttlename = "fcs/throttle-cmd-norm[" + number + "]";
+//   prod->getInputPort(0)->connect(lookupJSBExpression(throttlename));
+//   prod->getInputPort(1)->connect(fullForce->getOutputPort(0));
+//   addMultiBodyModel(prod);
+
+//   ExternalForceModel* engineForce = new ExternalForceModel(namestr);
+//   engineForce->setPosition(structToBody(loc));
+//   engineForce->setOrientation(orientation);
+
+//   engineForce->getInputPort(0)->connect(prod->getOutputPort(0));
+
+//   mVehicle->getTopBody()->addInteract(engineForce);
+
+//   return true;
+}
+
+bool
+LegacyJSBSimReader::convertTurbine(const XMLElement* turbine,
+                                   const std::string& number,
+                                   const Vector3& pos,
+                                   const Quaternion& orientation,
+                                   Port* thrusterDriver)
+{
+  // Undercarriage parsing.
+  std::stringstream datastr(turbine->getData());
+
+  // At the moment we have a *very* insufficient engine, just modulate the
+  // thrust between 0 and max
+  real_type maxThrust = 0;
+
+  while (datastr) {
+    std::string token;
+    datastr >> token;
+    if (token.empty())
+      continue;
+
+    if (token == "MILTHRUST") {
+      real_type value;
+      datastr >> value;
+      maxThrust = max(maxThrust, value);
+    } else if (token == "MAXTHRUST") {
+      real_type value;
+      datastr >> value;
+      maxThrust = max(maxThrust, value);
+    } else if (token == "BYPASSRATIO") {
+      real_type value;
+      datastr >> value;
+    } else if (token == "BLEED") {
+      real_type value;
+      datastr >> value;
+    } else if (token == "TSFC") {
+      real_type value;
+      datastr >> value;
+    } else if (token == "ATSFC") {
+      real_type value;
+      datastr >> value;
+    } else if (token == "IDLEN1") {
+      real_type value;
+      datastr >> value;
+    } else if (token == "IDLEN2") {
+      real_type value;
+      datastr >> value;
+    } else if (token == "MAXN1") {
+      real_type value;
+      datastr >> value;
+    } else if (token == "MAXN2") {
+      real_type value;
+      datastr >> value;
+    } else if (token == "AUGMENTED") {
+      real_type value;
+      datastr >> value;
+    } else if (token == "AUGMETHOD") {
+      real_type value;
+      datastr >> value;
+    } else if (token == "INJECTED") {
+      real_type value;
+      datastr >> value;
+    } else if (token == "MINTHROTTLE") {
+      real_type value;
+      datastr >> value;
+    } else
+      return error("unknown tubine configuration token \"" + token + "\"");
+  }
+
+  
+
   std::string namestr = "Engine<" + number + ">";
-  ConstModel* fullForce = new ConstModel(namestr + " full",
-                                         Vector6(0, 0, 0, 4.4*1.5e4, 0, 0));
+  ConstModel* fullForce = new ConstModel(namestr + " full");
+  fullForce->setValue(Vector6(0, 0, 0, convertFrom(uPoundForce, maxThrust), 0, 0));
   addMultiBodyModel(fullForce);
 
   Product* prod = new Product(namestr + " modulation");
@@ -2111,8 +2310,8 @@
   addMultiBodyModel(prod);
 
   ExternalForceModel* engineForce = new ExternalForceModel(namestr);
-  engineForce->setPosition(structToBody(loc));
-  engineForce->setOrientation(Quaternion::fromHeadAttBank(pitch, 0, yaw));
+  engineForce->setPosition(pos);
+  engineForce->setOrientation(orientation);
 
   engineForce->getInputPort(0)->connect(prod->getOutputPort(0));
 
@@ -2122,6 +2321,22 @@
 }
 
 bool
+LegacyJSBSimReader::convertElectric(const XMLElement* turbine,
+                                    const std::string& number,
+                                    Port* thrusterDriver)
+{
+  return true;
+}
+
+bool
+LegacyJSBSimReader::convertPiston(const XMLElement* turbine,
+                                  const std::string& number,
+                                  Port* thrusterDriver)
+{
+  return true;
+}
+
+bool
 LegacyJSBSimReader::convertAerodynamics(const XMLElement* aerodynamics)
 {
   std::list<SharedPtr<XMLElement> > elems = aerodynamics->getElements();
@@ -2295,7 +2510,7 @@
     TableLookup lookup;
     if (!parseTable1D(datastr, table, lookup))
       // FIXME
-      std::cerr << "Cannot parse " + type + " table" << std::endl;
+      std::cerr << "Cannot parse " + type + " table" << data << std::endl;
 
     Table1D* table1D = new Table1D(prod->getName() + " Table");
     addMultiBodyModel(table1D);
@@ -2340,7 +2555,7 @@
     TableLookup lookup[3];
     if (!parseTable3D(datastr, table, lookup))
       // FIXME
-      std::cerr << "Cannot parse " + type + " table" << std::endl;
+      std::cerr << "Cannot parse " + type + " table" << data << std::endl;
 
     Table3D* table3D = new Table3D(prod->getName() + " Table");
     addMultiBodyModel(table3D);

Modified: trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.h
===================================================================
--- trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.h	2006-01-16 19:48:11 UTC (rev 206)
+++ trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.h	2006-01-16 19:49:24 UTC (rev 207)
@@ -198,8 +198,17 @@
   bool convertThruster(const std::string& data, const std::string& type,
                        const std::string& number);
   /// converts FG_ENGINE data
-  bool convertEngine(const std::string& data, const std::string& type,
-                     const std::string& number);
+  bool convertEngine(const XMLElement* engine, const std::string& number);
+  /// converts FG_TURBINE data
+  bool convertTurbine(const XMLElement* turbine, const std::string& number,
+                      const Vector3& pos, const Quaternion& orientation,
+                      Port* thrusterDriver);
+  /// converts FG_PISTON data
+  bool convertPiston(const XMLElement* turbine, const std::string& number,
+                      Port* thrusterDriver);
+  /// converts FG_ELECTRIC data
+  bool convertElectric(const XMLElement* turbine, const std::string& number,
+                      Port* thrusterDriver);
   /// converts AERODYNAMICS elements
   bool convertAerodynamics(const XMLElement* aerodynamics);
   /// converts recursively AERODYNAMICS summands, factors and grooups



From frohlich at berlios.de  Sat Jan 21 12:06:20 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Sat, 21 Jan 2006 12:06:20 +0100
Subject: [OpenFDM-svn] r210 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200601211106.k0LB6KxG026892@sheep.berlios.de>

Author: frohlich
Date: 2006-01-21 12:06:16 +0100 (Sat, 21 Jan 2006)
New Revision: 210

Modified:
   trunk/OpenFDM/src/OpenFDM/Property.cpp
   trunk/OpenFDM/src/OpenFDM/Property.h
   trunk/OpenFDM/src/OpenFDM/Variant.h
Log:
Move the burden of value conversion completly into Variant


Modified: trunk/OpenFDM/src/OpenFDM/Property.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Property.cpp	2006-01-21 09:33:33 UTC (rev 209)
+++ trunk/OpenFDM/src/OpenFDM/Property.cpp	2006-01-21 11:06:16 UTC (rev 210)
@@ -14,223 +14,4 @@
 {
 }
 
-Variant
-UntypedPropertyImpl::getValue(void) /*const*/
-{
-  IntegerPropertyImpl* integerProperty = toIntegerPropertyImpl();
-  if (integerProperty)
-    return Variant(integerProperty->getValue());
-
-  UnsignedPropertyImpl* unsignedProperty = toUnsignedPropertyImpl();
-  if (unsignedProperty)
-    return Variant(unsignedProperty->getValue());
-
-  RealPropertyImpl* realProperty = toRealPropertyImpl();
-  if (realProperty)
-    return Variant(realProperty->getValue());
-
-  Vector2PropertyImpl* vector2Property = toVector2PropertyImpl();
-  if (vector2Property)
-    return Variant(vector2Property->getValue());
-
-  Vector3PropertyImpl* vector3Property = toVector3PropertyImpl();
-  if (vector3Property)
-    return Variant(vector3Property->getValue());
-
-  QuaternionPropertyImpl* quaternionProperty = toQuaternionPropertyImpl();
-  if (quaternionProperty)
-    return Variant(quaternionProperty->getValue());
-
-  PlanePropertyImpl* planeProperty = toPlanePropertyImpl();
-  if (planeProperty) {
-    Plane plane = planeProperty->getValue();
-    Vector3 normal = plane.getNormal();
-    return Variant(Vector4(normal(1), normal(2), normal(3), plane.getDist()));
-  }
-
-  Vector6PropertyImpl* vector6Property = toVector6PropertyImpl();
-  if (vector6Property)
-    return Variant(vector6Property->getValue());
-
-  MatrixPropertyImpl* matrixProperty = toMatrixPropertyImpl();
-  if (matrixProperty)
-    return Variant(matrixProperty->getValue());
-
-  StringPropertyImpl* stringProperty = toStringPropertyImpl();
-  if (stringProperty)
-    return Variant(stringProperty->getValue());
-
-  TableLookupPropertyImpl* tlProperty = toTableLookupPropertyImpl();
-  if (tlProperty)
-    return Variant(tlProperty->getValue());
-  Table1DPropertyImpl* t1Property = toTable1DPropertyImpl();
-  if (t1Property)
-    return Variant(t1Property->getValue());
-  Table2DPropertyImpl* t2Property = toTable2DPropertyImpl();
-  if (t2Property)
-    return Variant(t2Property->getValue());
-  Table3DPropertyImpl* t3Property = toTable3DPropertyImpl();
-  if (t3Property)
-    return Variant(t3Property->getValue());
-
-  return Variant();
-}
-
-void
-UntypedPropertyImpl::setValue(const Variant& value)
-{
-  IntegerPropertyImpl* integerProperty = toIntegerPropertyImpl();
-  if (integerProperty)
-    integerProperty->setValue(value.toInteger());
-
-  UnsignedPropertyImpl* unsignedProperty = toUnsignedPropertyImpl();
-  if (unsignedProperty)
-    unsignedProperty->setValue(value.toUnsigned());
-
-  RealPropertyImpl* realProperty = toRealPropertyImpl();
-  if (realProperty)
-    realProperty->setValue(value.toReal());
-
-  Vector2PropertyImpl* vector2Property = toVector2PropertyImpl();
-  if (vector2Property) {
-    Matrix m = value.toMatrix();
-    if (m.rows() == 2 && m.cols() == 1)
-      vector2Property->setValue(Vector2(m(1,1), m(1,2)));
-  }
-
-  Vector3PropertyImpl* vector3Property = toVector3PropertyImpl();
-  if (vector3Property) {
-    Matrix m = value.toMatrix();
-    if (m.rows() == 3 && m.cols() == 1)
-      vector3Property->setValue(Vector3(m(1,1), m(1,2), m(1,3)));
-  }
-
-  QuaternionPropertyImpl* quaternionProperty = toQuaternionPropertyImpl();
-  if (quaternionProperty) {
-    Matrix m = value.toMatrix();
-    if (m.rows() == 4 && m.cols() == 1)
-      quaternionProperty->setValue(Vector4(m(1,1), m(1,2), m(1,3), m(1,4)));
-  }
-
-  PlanePropertyImpl* planeProperty = toPlanePropertyImpl();
-  if (planeProperty) {
-    Matrix m = value.toMatrix();
-    if (m.rows() == 4 && m.cols() == 1)
-      planeProperty->setValue(Plane(Vector3(m(1,1), m(1,2), m(1,3)), m(1,4)));
-  }
-
-  Vector6PropertyImpl* vector6Property = toVector6PropertyImpl();
-  if (vector6Property) {
-    Matrix m = value.toMatrix();
-    if (m.rows() == 6 && m.cols() == 1)
-      vector6Property->setValue(Vector6(m(1,1), m(1,2), m(1,3),
-                                        m(1,4), m(1,5), m(1,6)));
-  }
-
-  MatrixPropertyImpl* matrixProperty = toMatrixPropertyImpl();
-  if (matrixProperty)
-    matrixProperty->setValue(value.toMatrix());
-
-  StringPropertyImpl* stringProperty = toStringPropertyImpl();
-  if (stringProperty)
-    stringProperty->setValue(value.toString());
-
-  TableLookupPropertyImpl* tlProperty = toTableLookupPropertyImpl();
-  if (tlProperty)
-    tlProperty->setValue(value.toTableLookup());
-  Table1DPropertyImpl* t1Property = toTable1DPropertyImpl();
-  if (t1Property)
-    t1Property->setValue(value.toTable1D());
-  Table2DPropertyImpl* t2Property = toTable2DPropertyImpl();
-  if (t2Property)
-    t2Property->setValue(value.toTable2D());
-  Table3DPropertyImpl* t3Property = toTable3DPropertyImpl();
-  if (t3Property)
-    t3Property->setValue(value.toTable3D());
-}
-
-IntegerPropertyImpl*
-UntypedPropertyImpl::toIntegerPropertyImpl(void)
-{
-  return 0;
-}
-
-UnsignedPropertyImpl*
-UntypedPropertyImpl::toUnsignedPropertyImpl(void)
-{
-  return 0;
-}
-
-RealPropertyImpl*
-UntypedPropertyImpl::toRealPropertyImpl(void)
-{
-  return 0;
-}
-
-Vector2PropertyImpl*
-UntypedPropertyImpl::toVector2PropertyImpl(void)
-{
-  return 0;
-}
-
-Vector3PropertyImpl*
-UntypedPropertyImpl::toVector3PropertyImpl(void)
-{
-  return 0;
-}
-
-QuaternionPropertyImpl*
-UntypedPropertyImpl::toQuaternionPropertyImpl(void)
-{
-  return 0;
-}
-
-PlanePropertyImpl*
-UntypedPropertyImpl::toPlanePropertyImpl(void)
-{
-  return 0;
-}
-
-Vector6PropertyImpl*
-UntypedPropertyImpl::toVector6PropertyImpl(void)
-{
-  return 0;
-}
-
-MatrixPropertyImpl*
-UntypedPropertyImpl::toMatrixPropertyImpl(void)
-{
-  return 0;
-}
-
-StringPropertyImpl*
-UntypedPropertyImpl::toStringPropertyImpl(void)
-{
-  return 0;
-}
-
-TableLookupPropertyImpl*
-UntypedPropertyImpl::toTableLookupPropertyImpl(void)
-{
-  return 0;
-}
-
-Table1DPropertyImpl*
-UntypedPropertyImpl::toTable1DPropertyImpl(void)
-{
-  return 0;
-}
-
-Table2DPropertyImpl*
-UntypedPropertyImpl::toTable2DPropertyImpl(void)
-{
-  return 0;
-}
-
-Table3DPropertyImpl*
-UntypedPropertyImpl::toTable3DPropertyImpl(void)
-{
-  return 0;
-}
-
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/Property.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Property.h	2006-01-21 09:33:33 UTC (rev 209)
+++ trunk/OpenFDM/src/OpenFDM/Property.h	2006-01-21 11:06:16 UTC (rev 210)
@@ -18,138 +18,32 @@
 
 class Object;
 
-template<typename T>
-class PropertyImpl;
-
-typedef PropertyImpl<int> IntegerPropertyImpl;
-typedef PropertyImpl<unsigned> UnsignedPropertyImpl;
-typedef PropertyImpl<real_type> RealPropertyImpl;
-typedef PropertyImpl<Vector2> Vector2PropertyImpl;
-typedef PropertyImpl<Vector3> Vector3PropertyImpl;
-typedef PropertyImpl<Quaternion> QuaternionPropertyImpl;
-typedef PropertyImpl<Plane> PlanePropertyImpl;
-typedef PropertyImpl<Vector6> Vector6PropertyImpl;
-typedef PropertyImpl<Matrix> MatrixPropertyImpl;
-typedef PropertyImpl<std::string> StringPropertyImpl;
-
-typedef PropertyImpl<TableLookup> TableLookupPropertyImpl;
-typedef PropertyImpl<TableData<1> > Table1DPropertyImpl;
-typedef PropertyImpl<TableData<2> > Table2DPropertyImpl;
-typedef PropertyImpl<TableData<3> > Table3DPropertyImpl;
-
-class UntypedPropertyImpl :
+class PropertyImpl :
     public Referenced {
 public:
-  UntypedPropertyImpl(bool isStored = false) : mIsStored(isStored) {}
-  virtual ~UntypedPropertyImpl(void);
+  PropertyImpl(bool isStored = false) : mIsStored(isStored) {}
+  virtual ~PropertyImpl(void);
 
-  /// Can always do that via Variants.
-  /// Take care that this is costly ...
-  Variant getValue(void) /*const FIXME*/;
-  void setValue(const Variant& value);
+  virtual Variant getValue(void) = 0;
+  virtual void setValue(const Variant& value) = 0;
 
+  virtual bool isValid(void) const = 0;
+
   void setStoredProperty(bool isStored)
   { mIsStored = isStored; }
   bool isStoredProperty(void) const
   { return mIsStored; }
 
-  virtual bool isValid(void) const = 0;
-
-  virtual IntegerPropertyImpl* toIntegerPropertyImpl(void);
-  virtual UnsignedPropertyImpl* toUnsignedPropertyImpl(void);
-  virtual RealPropertyImpl* toRealPropertyImpl(void);
-  virtual Vector2PropertyImpl* toVector2PropertyImpl(void);
-  virtual Vector3PropertyImpl* toVector3PropertyImpl(void);
-  virtual QuaternionPropertyImpl* toQuaternionPropertyImpl(void);
-  virtual PlanePropertyImpl* toPlanePropertyImpl(void);
-  virtual Vector6PropertyImpl* toVector6PropertyImpl(void);
-  virtual MatrixPropertyImpl* toMatrixPropertyImpl(void);
-  virtual StringPropertyImpl* toStringPropertyImpl(void);
-
-  virtual TableLookupPropertyImpl* toTableLookupPropertyImpl(void);
-  virtual Table1DPropertyImpl* toTable1DPropertyImpl(void);
-  virtual Table2DPropertyImpl* toTable2DPropertyImpl(void);
-  virtual Table3DPropertyImpl* toTable3DPropertyImpl(void);
-
 private:
   bool mIsStored;
 
   /// Properties are not assignable.
-  UntypedPropertyImpl(const UntypedPropertyImpl&);
-  UntypedPropertyImpl& operator=(const UntypedPropertyImpl&);
+  PropertyImpl(const PropertyImpl&);
+  PropertyImpl& operator=(const PropertyImpl&);
 };
 
-template<typename T>
-class PropertyImplInterface : public UntypedPropertyImpl {
-public:
-  /// Retrieve property from the given object.
-  virtual T getValue(void) const = 0;
-  /// Set property of the given object.
-  virtual void setValue(const T&) = 0;
-};
-
-template<typename T>
-class PropertyImpl : public PropertyImplInterface<T> {};
-template<>
-class PropertyImpl<int> : public PropertyImplInterface<int> {
-  virtual IntegerPropertyImpl* toIntegerPropertyImpl(void) { return this; }
-};
-template<>
-class PropertyImpl<unsigned> : public PropertyImplInterface<unsigned> {
-  virtual UnsignedPropertyImpl* toUnsignedPropertyImpl(void) { return this; }
-};
-template<>
-class PropertyImpl<real_type> : public PropertyImplInterface<real_type> {
-  virtual RealPropertyImpl* toRealPropertyImpl(void) { return this; }
-};
-template<>
-class PropertyImpl<Vector2> : public PropertyImplInterface<Vector2> {
-  virtual Vector2PropertyImpl* toVector2PropertyImpl(void) { return this; }
-};
-template<>
-class PropertyImpl<Vector3> : public PropertyImplInterface<Vector3> {
-  virtual Vector3PropertyImpl* toVector3PropertyImpl(void) { return this; }
-};
-template<>
-class PropertyImpl<Quaternion> : public PropertyImplInterface<Quaternion> {
-  virtual QuaternionPropertyImpl* toQuaternionPropertyImpl(void) { return this; }
-};
-template<>
-class PropertyImpl<Plane> : public PropertyImplInterface<Plane> {
-  virtual PlanePropertyImpl* toPlanePropertyImpl(void) { return this; }
-};
-template<>
-class PropertyImpl<Vector6> : public PropertyImplInterface<Vector6> {
-  virtual Vector6PropertyImpl* toVector6PropertyImpl(void) { return this; }
-};
-template<>
-class PropertyImpl<Matrix> : public PropertyImplInterface<Matrix> {
-  virtual MatrixPropertyImpl* toMatrixPropertyImpl(void) { return this; }
-};
-template<>
-class PropertyImpl<std::string> : public PropertyImplInterface<std::string> {
-  virtual StringPropertyImpl* toStringPropertyImpl(void) { return this; }
-};
-
-template<>
-class PropertyImpl<TableLookup> : public PropertyImplInterface<TableLookup> {
-  virtual TableLookupPropertyImpl* toTableLookupPropertyImpl(void) { return this; }
-};
-template<>
-class PropertyImpl<TableData<1> > : public PropertyImplInterface<TableData<1> > {
-  virtual Table1DPropertyImpl* toTable1DPropertyImpl(void) { return this; }
-};
-template<>
-class PropertyImpl<TableData<2> > : public PropertyImplInterface<TableData<2> > {
-  virtual Table2DPropertyImpl* toTable2DPropertyImpl(void) { return this; }
-};
-template<>
-class PropertyImpl<TableData<3> > : public PropertyImplInterface<TableData<3> > {
-  virtual Table3DPropertyImpl* toTable3DPropertyImpl(void) { return this; }
-};
-
 template<typename O, typename T>
-class ObjectPropertyImpl : public PropertyImpl<T> {
+class ObjectPropertyImpl : public PropertyImpl {
 public:
   typedef const T& (O::*GetRefMethod)(void) const;
   typedef T (O::*GetMethod)(void) const;
@@ -177,25 +71,27 @@
   {}
 
   /// Retrieve property from the given object.
-  virtual T getValue(void) const
+  virtual Variant getValue(void)
   {
     const O* object = mObject;
     OpenFDMAssert(object);
     if (mGetRefMethod && object)
-      return (object->*mGetRefMethod)();
+      return Variant((object->*mGetRefMethod)());
     else if (mGetMethod && object)
-      return (object->*mGetMethod)();
+      return Variant((object->*mGetMethod)());
     else
-      return T();
+      return Variant();
   }
 
   /// Set property to the given object.
-  virtual void setValue(const T& value)
+  virtual void setValue(const Variant& value)
   {
+    T typedValue;
+    variant_copy(value, typedValue);
     O* object = mObject;
     OpenFDMAssert(object);
     if (mSetMethod && object)
-      (object->*mSetMethod)(value);
+      (object->*mSetMethod)(typedValue);
   }
 
   virtual bool isValid(void) const { return mObject; }
@@ -207,77 +103,10 @@
   SetMethod mSetMethod;
 };
 
-template<typename T>
-class TypedProperty {
-public:
-  typedef PropertyImpl<T> implementation_t;
-
-  TypedProperty(implementation_t* propertyImpl = 0) :
-    mPropertyImpl(propertyImpl)
-  {}
-  template<typename O>
-  TypedProperty(O* object, T (O::*getter) () const) :
-    mPropertyImpl(new ObjectPropertyImpl<O,T>(object, getter))
-  {}
-  template<typename O>
-  TypedProperty(O* object, const T& (O::*getter) () const) :
-    mPropertyImpl(new ObjectPropertyImpl<O,T>(object, getter))
-  {}
-  template<typename O>
-  TypedProperty(O* object, void (O::*setter) (const T&)) :
-    mPropertyImpl(new ObjectPropertyImpl<O,T>(object, setter))
-  {}
-  template<typename O>
-  TypedProperty(O* object, T (O::*getter) () const, void (O::*setter) (const T&)) :
-    mPropertyImpl(new ObjectPropertyImpl<O,T>(object, getter, setter))
-  {}
-  template<typename O>
-  TypedProperty(O* object, const T& (O::*getter) () const, void (O::*setter) (const T&)) :
-    mPropertyImpl(new ObjectPropertyImpl<O,T>(object, getter, setter))
-  {}
-
-  /// Returns if the property contains a valid property reference and
-  /// references an existing object.
-  bool isValid(void) const
-  { return mPropertyImpl && mPropertyImpl->isValid(); }
-
-  T getValue(void) /*const FIXME*/
-  {
-    if (mPropertyImpl)
-      return mPropertyImpl->getValue();
-    else
-      return T();
-  }
-  void setValue(const T& value)
-  {
-    if (mPropertyImpl)
-      mPropertyImpl->setValue(value);
-  }
-
-private:
-  SharedPtr<implementation_t> mPropertyImpl;
-};
-
-typedef TypedProperty<int> IntegerProperty;
-typedef TypedProperty<unsigned> UnsignedProperty;
-typedef TypedProperty<real_type> RealProperty;
-typedef TypedProperty<Vector2> Vector2Property;
-typedef TypedProperty<Vector3> Vector3Property;
-typedef TypedProperty<Quaternion> QuaternionProperty;
-typedef TypedProperty<Plane> PlaneProperty;
-typedef TypedProperty<Vector6> Vector6Property;
-typedef TypedProperty<Matrix> MatrixProperty;
-typedef TypedProperty<std::string> StringProperty;
-
-typedef TypedProperty<TableLookup> TableLookupProperty;
-typedef TypedProperty<TableData<1> > Table1DProperty;
-typedef TypedProperty<TableData<2> > Table2DProperty;
-typedef TypedProperty<TableData<3> > Table3DProperty;
-
 class Property {
 public:
   Property(void) {}
-  Property(UntypedPropertyImpl* propertyImpl) :
+  Property(PropertyImpl* propertyImpl) :
     mPropertyImpl(propertyImpl)
   {}
   template<typename O, typename T>
@@ -303,7 +132,7 @@
 
   /// Can always do that via Variants.
   /// Take care that this is costly ...
-  Variant getValue(void) /*const FIXME*/
+  Variant getValue(void)
   {
     if (mPropertyImpl)
       return mPropertyImpl->getValue();
@@ -326,83 +155,8 @@
   bool isStoredProperty(void) const
   { return mPropertyImpl && mPropertyImpl->isStoredProperty(); }
 
-  bool isIntegerProperty(void)
-  { return mPropertyImpl->toIntegerPropertyImpl(); }
-  TypedProperty<int> toIntegerProperty(void)
-  { return TypedProperty<int>(mPropertyImpl->toIntegerPropertyImpl()); }
-
-  bool isUnsignedProperty(void)
-  { return mPropertyImpl->toUnsignedPropertyImpl(); }
-  TypedProperty<unsigned> toUnsignedProperty(void)
-  { return TypedProperty<unsigned>(mPropertyImpl->toUnsignedPropertyImpl()); }
-
-  bool isRealProperty(void)
-  { return mPropertyImpl->toRealPropertyImpl(); }
-  TypedProperty<real_type> toRealProperty(void)
-  { return TypedProperty<real_type>(mPropertyImpl->toRealPropertyImpl()); }
-
-  bool isVector2Property(void)
-  { return mPropertyImpl->toVector2PropertyImpl(); }
-  TypedProperty<Vector2> toVector2Property(void)
-  { return TypedProperty<Vector2>(mPropertyImpl->toVector2PropertyImpl()); }
-
-  bool isVector3Property(void)
-  { return mPropertyImpl->toVector3PropertyImpl(); }
-  TypedProperty<Vector3> toVector3Property(void)
-  { return TypedProperty<Vector3>(mPropertyImpl->toVector3PropertyImpl()); }
-
-  bool isQuaternionProperty(void)
-  { return mPropertyImpl->toQuaternionPropertyImpl(); }
-  TypedProperty<Quaternion> toQuaternionProperty(void)
-  { return TypedProperty<Quaternion>(mPropertyImpl->toQuaternionPropertyImpl()); }
-
-  bool isPlaneProperty(void)
-  { return mPropertyImpl->toPlanePropertyImpl(); }
-  TypedProperty<Plane> toPlaneProperty(void)
-  { return TypedProperty<Plane>(mPropertyImpl->toPlanePropertyImpl()); }
-
-  bool isVector6Property(void)
-  { return mPropertyImpl->toVector6PropertyImpl(); }
-  TypedProperty<Vector6> toVector6Property(void)
-  { return TypedProperty<Vector6>(mPropertyImpl->toVector6PropertyImpl()); }
-
-  bool isMatrixProperty(void)
-  { return mPropertyImpl->toMatrixPropertyImpl(); }
-  TypedProperty<Matrix> toMatrixProperty(void)
-  { return TypedProperty<Matrix>(mPropertyImpl->toMatrixPropertyImpl()); }
-
-  bool isStringProperty(void)
-  { return mPropertyImpl->toStringPropertyImpl(); }
-  TypedProperty<std::string> toStringProperty(void)
-  { return TypedProperty<std::string>(mPropertyImpl->toStringPropertyImpl()); }
-
-  bool isTableLookupProperty(void)
-  { return mPropertyImpl->toTableLookupPropertyImpl(); }
-  TypedProperty<TableLookup> toTableLookupProperty(void)
-  { return TypedProperty<TableLookup>(mPropertyImpl->toTableLookupPropertyImpl()); }
-
-  bool isTable1DProperty(void)
-  { return mPropertyImpl->toTable1DPropertyImpl(); }
-  TypedProperty<TableData<1> > toTable1DProperty(void)
-  { return TypedProperty<TableData<1> >(mPropertyImpl->toTable1DPropertyImpl()); }
-  bool isTable2DProperty(void)
-  { return mPropertyImpl->toTable2DPropertyImpl(); }
-  TypedProperty<TableData<2> > toTable2DProperty(void)
-  { return TypedProperty<TableData<2> >(mPropertyImpl->toTable2DPropertyImpl()); }
-  bool isTable3DProperty(void)
-  { return mPropertyImpl->toTable3DPropertyImpl(); }
-  TypedProperty<TableData<3> > toTable3DProperty(void)
-  { return TypedProperty<TableData<3> >(mPropertyImpl->toTable3DPropertyImpl()); }
-
-  template<typename T>
-  TypedProperty<T> toTypedProperty(void)
-  {
-    UntypedPropertyImpl* impl = mPropertyImpl;
-    return TypedProperty<T>(dynamic_cast<PropertyImpl<T>*>(impl));
-  }
-
 private:
-  SharedPtr<UntypedPropertyImpl> mPropertyImpl;
+  SharedPtr<PropertyImpl> mPropertyImpl;
 };
 
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/Variant.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Variant.h	2006-01-21 09:33:33 UTC (rev 209)
+++ trunk/OpenFDM/src/OpenFDM/Variant.h	2006-01-21 11:06:16 UTC (rev 210)
@@ -263,6 +263,55 @@
   return mData && mData->toTable3DVariant();
 }
 
+/// Hmmm, .... FIXME
+template<typename T>
+inline void
+variant_copy(const Variant& variant, T& value)
+{}
+
+template<>
+inline void
+variant_copy(const Variant& variant, std::string& value)
+{ value = variant.toString(); }
+
+template<>
+inline void
+variant_copy(const Variant& variant, real_type& value)
+{ value = variant.toReal(); }
+
+template<>
+inline void
+variant_copy(const Variant& variant, int& value)
+{ value = variant.toInteger(); }
+
+template<>
+inline void
+variant_copy(const Variant& variant, unsigned& value)
+{ value = variant.toUnsigned(); }
+
+template<typename Impl, LinAlg::size_type m, LinAlg::size_type n> 
+inline void
+variant_copy(const Variant& variant, LinAlg::MatrixLValue<Impl,m,n>& value)
+{ value = variant.toMatrix(); }
+
+template<> 
+inline void
+variant_copy(const Variant& variant, TableLookup& value)
+{ value = variant.toTableLookup(); }
+
+template<> 
+inline void
+variant_copy(const Variant& variant, TableData<1>& value)
+{ value = variant.toTable1D(); }
+template<> 
+inline void
+variant_copy(const Variant& variant, TableData<2>& value)
+{ value = variant.toTable2D(); }
+template<> 
+inline void
+variant_copy(const Variant& variant, TableData<3>& value)
+{ value = variant.toTable3D(); }
+
 } // namespace OpenFDM
 
 #endif



From frohlich at berlios.de  Sat Jan 21 12:48:43 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Sat, 21 Jan 2006 12:48:43 +0100
Subject: [OpenFDM-svn] r211 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200601211148.k0LBmhCt015335@sheep.berlios.de>

Author: frohlich
Date: 2006-01-21 12:48:39 +0100 (Sat, 21 Jan 2006)
New Revision: 211

Modified:
   trunk/OpenFDM/src/OpenFDM/Property.cpp
Log:
Oops, compile fix ...


Modified: trunk/OpenFDM/src/OpenFDM/Property.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Property.cpp	2006-01-21 11:06:16 UTC (rev 210)
+++ trunk/OpenFDM/src/OpenFDM/Property.cpp	2006-01-21 11:48:39 UTC (rev 211)
@@ -10,7 +10,7 @@
 
 namespace OpenFDM {
 
-UntypedPropertyImpl::~UntypedPropertyImpl(void)
+PropertyImpl::~PropertyImpl(void)
 {
 }
 



From frohlich at berlios.de  Sat Jan 21 12:49:23 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Sat, 21 Jan 2006 12:49:23 +0100
Subject: [OpenFDM-svn] r212 - trunk/flightgear
Message-ID: <200601211149.k0LBnNdq015844@sheep.berlios.de>

Author: frohlich
Date: 2006-01-21 12:49:15 +0100 (Sat, 21 Jan 2006)
New Revision: 212

Modified:
   trunk/flightgear/FGOpenFDM.cpp
   trunk/flightgear/FGPropertyAdapter.h
Log:
Huge update. Longe time since the past checkin here ...


Modified: trunk/flightgear/FGOpenFDM.cpp
===================================================================
--- trunk/flightgear/FGOpenFDM.cpp	2006-01-21 11:48:39 UTC (rev 211)
+++ trunk/flightgear/FGOpenFDM.cpp	2006-01-21 11:49:15 UTC (rev 212)
@@ -15,8 +15,10 @@
 #include <OpenFDM/Vehicle.h>
 #include <OpenFDM/Input.h>
 #include <OpenFDM/Ground.h>
+#include <OpenFDM/MobileRootJoint.h>
 #include <OpenFDM/Model.h>
 #include <OpenFDM/ModelGroup.h>
+#include <OpenFDM/XMLDumpModelVisitor.h>
 
 #include "FGPropertyAdapter.h"
 
@@ -140,19 +142,6 @@
 //     turbulence_rate = fgGetNode("/environment/turbulence/rate-hz",true);
 
 
-
-class FGPropertyImpl : public PropertyImpl<real_type> {
-public:
-  FGPropertyImpl(SGPropertyNode* ptr) : mPropertyNode(ptr) {}
-  virtual void setValue(const real_type& value) { if (mPropertyNode.valid()) mPropertyNode->setDoubleValue(value); }
-  virtual const Object* getObject(void) const { return 0; }
-  virtual Object* getObject(void) { return 0; }
-  virtual bool isValid(void) const { return true; }
-  virtual real_type getValue(void) const { if (mPropertyNode.valid()) return mPropertyNode->getDoubleValue(); else return 0; }
-private:
-  SGPropertyNode_ptr mPropertyNode;
-};
-
 void printVehicle(Vehicle* vehicle)
 {
   cout << "T = " << vehicle->getTime()
@@ -197,7 +186,7 @@
   LegacyJSBSimReader reader;
   reader.addAircraftPath(fgGetString("/sim/aircraft-dir"));
   reader.addEnginePath(std::string(fgGetString("/sim/aircraft-dir"))
-                       + "/Engine");
+                       + "/Engines");
   reader.loadAircraft(std::string(fgGetString("/sim/aero")) + ".xml");
   if (reader.getErrorState()) {
     SG_LOG(SG_FLIGHT, SG_ALERT, "FGOpenFDM::init() cannot read aircraft!");
@@ -210,17 +199,59 @@
   }
 
   mData->vehicle = reader.getVehicle();
+  Vehicle* vehicle = mData->vehicle;
   mData->ground = new FGGround(this);
-  mData->vehicle->setGround(mData->ground);
-  mData->vehicle->setPlanet(new FGPlanet);
-  mData->vehicle->setWind(new FGWind);
+  vehicle->setGround(mData->ground);
+  vehicle->setPlanet(new FGPlanet);
+  vehicle->setWind(new FGWind);
 
-  // Call what needs to be done ... ;-(
+  // Call what needs to be done ... ;-)
   common_init();
 
   // Hmm, twice ??
-  mData->vehicle->init();
+  vehicle->init();
 
+  MobileRootJoint* mobileRootJoint = vehicle->getMobileRootJoint();
+  // Check the position
+  Geodetic gp = Geodetic(get_Latitude(),
+                         get_Longitude(),
+                         convertFrom(uFoot, get_Altitude()));
+  SG_LOG(SG_FLIGHT, SG_INFO, "Geod Pos " << gp << " set.");
+  mobileRootJoint->setGeodPosition(gp);
+
+  // Orientation
+  Quaternion go = Quaternion::fromHeadAttBank(get_Psi(),
+                                              get_Theta(),
+                                              get_Phi());
+  SG_LOG(SG_FLIGHT, SG_INFO, "Geod Orientation " << go << " set!");
+  vehicle->setGeodOrientation(go);
+
+  // Velocity
+  std::string speed_set = fgGetString("/sim/presets/speed-set", "UVW");
+  if (speed_set == "UVW") {
+    Vector3 bodyVel(get_uBody(), get_vBody(), get_wBody());
+    mobileRootJoint->setAngularRelVel(Vector3::zeros());
+    mobileRootJoint->setLinearRelVel(convertFrom(uFeetPSecond, bodyVel));
+//   } else if (speed_set == "NED") {
+//   } else if (speed_set == "KNOTS") {
+//   } else if (speed_set == "MACH") {
+  } else {
+    mobileRootJoint->setRelVel(Vector6::zeros());
+  }
+
+  // Try to find a stable set of states
+  if (!vehicle->trim())
+    SG_LOG(SG_FLIGHT, SG_WARN, "Trimming failed!");
+
+  // Copy the trim results back
+  gp = vehicle->getGeodPosition();
+  _updateGeodeticPosition(gp.latitude, gp.longitude,
+                          convertTo(uFoot, gp.altitude));
+
+  Rotation geodOr = vehicle->getGeodOrientation();
+  Vector3 euler = geodOr.getEuler();
+  _set_Euler_Angles(euler(1), euler(2), euler(3));
+
   set_inited(true);
 }
 
@@ -245,30 +276,25 @@
   FGInterface::unbind();
 }
 
-void FGOpenFDM::update(double dt)
+void
+FGOpenFDM::update(double dt)
 {
   if (is_suspended() || dt == 0)
     return;
 
   // Get a local vehicle pointer
   Vehicle* vehicle = mData->vehicle;
-
   if (!vehicle) {
     SG_LOG(SG_FLIGHT, SG_ALERT,
            "FGOpenFDM::update(double) is called without an aircraft loaded!");
     return;
   }
 
-
-  // Check if somebody has fiddled with the state values since the past step...
-  bool stateChanged = false;
-
   // Check the position
   Geodetic gp = Geodetic(get_Latitude(),
                          get_Longitude(),
                          convertFrom(uFoot, get_Altitude()));
   if (!equal(vehicle->getPlanet()->toCart(gp), vehicle->getCartPosition())) {
-    stateChanged = true;
     SG_LOG(SG_FLIGHT, SG_INFO,
            "Geod Pos set, error = "
            << norm(vehicle->getPlanet()->toCart(gp)-vehicle->getCartPosition())
@@ -280,7 +306,6 @@
   // Check the orientation 
   Vector3 euler = vehicle->getGeodOrientation().getEuler();
   if (!equal(euler, Vector3(get_Phi(), get_Theta(), get_Psi()))) {
-    stateChanged = true;
     Quaternion
       go = Quaternion::fromHeadAttBank(get_Psi(), get_Theta(), get_Phi());
     SG_LOG(SG_FLIGHT, SG_INFO,
@@ -301,20 +326,10 @@
     SG_LOG(SG_FLIGHT, SG_WARN,
            "FGInterface is beeing called without scenery below the aircraft!");
 
-  if (stateChanged) {
-    SG_LOG(SG_FLIGHT, SG_INFO, "State changed ------------------------------");
-//     printVehicle(vehicle);
-    vehicle->init();
-    vehicle->trim();
-//     printVehicle(vehicle);
-  }
-
   // Here a miracle occures :)
   vehicle->output();
   vehicle->update(dt);
 
-//   printVehicle(vehicle);
-
   // Now write the newly computed values into the interface class.
   gp = vehicle->getGeodPosition();
   _updateGeodeticPosition(gp.latitude, gp.longitude,
@@ -376,7 +391,7 @@
   if (outputModel) {
     std::string pName = outputModel->getOutputName();
     SGPropertyNode* sgProp = mAircraftRootNode->getNode(pName.c_str(), true);
-    sgProp->tie(FGRealPropertyAdapter(outputModel, "value"));
+    sgProp->tie(FGOutputReflector(outputModel));
   }
 
   // Check for input models
@@ -392,6 +407,17 @@
     inputModel->setUserData(new InputChangeUserData(inputModel, sgProp));
   }
 
+  // Reflect all output ports
+  Model* model = dynamic_cast<Model*>(object);
+  if (model && model->getNumOutputPorts()) {
+    SGPropertyNode* outputBase = base->getNode("outputs", true);
+    for (unsigned i = 0; i < model->getNumOutputPorts(); ++i) {
+      std::string name = model->getOutputPortName(i);
+      SGPropertyNode* sgProp = outputBase->getNode(name.c_str(), true);
+      sgProp->tie(FGRealPortReflector(model->getOutputPort(i)));
+    }
+  }
+
   // The usual, whole object reflection so that one can take a look into
   // OpenFDM's internal modules ...
   std::list<std::string> propertyList = object->listProperties();

Modified: trunk/flightgear/FGPropertyAdapter.h
===================================================================
--- trunk/flightgear/FGPropertyAdapter.h	2006-01-21 11:48:39 UTC (rev 211)
+++ trunk/flightgear/FGPropertyAdapter.h	2006-01-21 11:49:15 UTC (rev 212)
@@ -80,8 +80,8 @@
   virtual bool setValue(double value)
   {
     Matrix m = getPropertyValue().toMatrix();
-    unsigned r = mIndex % rows(m);
-    unsigned c = mIndex / rows(m);
+    unsigned r = mIndex % rows(m) + 1;
+    unsigned c = mIndex / rows(m) + 1;
     if (r < 1 || rows(m) < r)
       return false;
     if (c < 1 || cols(m) < c)
@@ -97,8 +97,8 @@
       return getPropertyValue().toReal();
     else {
       Matrix m = getPropertyValue().toMatrix();
-      unsigned r = mIndex % rows(m);
-      unsigned c = mIndex / rows(m);
+      unsigned r = mIndex % rows(m) + 1;
+      unsigned c = mIndex / rows(m) + 1;
       if (r < 1 || rows(m) < r)
         return 0;
       if (c < 1 || cols(m) < c)
@@ -179,6 +179,80 @@
   InputChangeListener* mListener;
 };
 
+class FGOutputReflector :
+    public SGRawValue<double> {
+public:
+  FGOutputReflector(Output* output) :
+    mOutputModel(output)
+  {}
+
+  virtual bool setValue(double value)
+  { return false; }
+  
+  virtual double getValue(void) const
+  {
+    if (!mOutputModel)
+      return 0;
+    return mOutputModel->getValue();
+  }
+
+  virtual FGOutputReflector* clone(void) const
+  { return new FGOutputReflector(*this); }
+
+private:
+  // Holds the output model where it should write the value
+  // Note that this shal not be a SharedPtr, since we get a recursive
+  // ref count loop in that case.
+  WeakPtr<Output> mOutputModel;
+};
+
+class FGRealPortReflector :
+    public SGRawValue<double> {
+public:
+  FGRealPortReflector(Port* port, unsigned index = 1u) :
+    mPort(port), mIndex(index)
+  {}
+
+  /// Implements the SimGear property interface.
+  virtual bool setValue(double value)
+  { return false; }
+  /// Implements the SimGear property interface.
+  virtual double getValue(void) const
+  {
+    if (!mPort)
+      return 0;
+    if (mIndex == 1) {
+      const Port* port = mPort;
+      RealPortHandle realPortHandle = const_cast<Port*>(port)->toRealPortHandle();
+      if (realPortHandle.isConnected())
+        return realPortHandle.getRealValue();
+      else
+        return 0;
+    } else {
+      const Port* port = mPort;
+      MatrixPortHandle matrixPortHandle = const_cast<Port*>(port)->toMatrixPortHandle();
+      if (matrixPortHandle.isConnected()) {
+        Matrix m = matrixPortHandle.getMatrixValue();
+        unsigned r = mIndex % rows(m) + 1;
+        unsigned c = mIndex / rows(m) + 1;
+        if (r < 1 || rows(m) < r)
+          return 0;
+        if (c < 1 || cols(m) < c)
+          return 0;
+        return m(r, c);
+      } else
+        return 0;
+    }
+  }
+  
+  virtual FGRealPortReflector* clone(void) const
+  { return new FGRealPortReflector(*this); }
+
+private:
+  unsigned mIndex;
+  WeakPtr<Port> mPort;
+};
+
 } // namespace OpenFDM
 
 #endif



From frohlich at berlios.de  Sat Jan 21 12:57:17 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Sat, 21 Jan 2006 12:57:17 +0100
Subject: [OpenFDM-svn] r213 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200601211157.k0LBvHLQ018045@sheep.berlios.de>

Author: frohlich
Date: 2006-01-21 12:56:51 +0100 (Sat, 21 Jan 2006)
New Revision: 213

Modified:
   trunk/OpenFDM/src/OpenFDM/Bias.cpp
   trunk/OpenFDM/src/OpenFDM/DiscreteIntegrator.cpp
   trunk/OpenFDM/src/OpenFDM/Gain.cpp
   trunk/OpenFDM/src/OpenFDM/Integrator.cpp
   trunk/OpenFDM/src/OpenFDM/MaxModel.cpp
   trunk/OpenFDM/src/OpenFDM/MinModel.cpp
   trunk/OpenFDM/src/OpenFDM/Product.cpp
   trunk/OpenFDM/src/OpenFDM/Saturation.cpp
   trunk/OpenFDM/src/OpenFDM/Summer.cpp
   trunk/OpenFDM/src/OpenFDM/Table.cpp
   trunk/OpenFDM/src/OpenFDM/TimeDerivative.cpp
   trunk/OpenFDM/src/OpenFDM/TransferFunction.cpp
Log:
Remove some output properties, since we have outputs
reflected in fg in a generic way.


Modified: trunk/OpenFDM/src/OpenFDM/Bias.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Bias.cpp	2006-01-21 11:49:15 UTC (rev 212)
+++ trunk/OpenFDM/src/OpenFDM/Bias.cpp	2006-01-21 11:56:51 UTC (rev 213)
@@ -28,7 +28,6 @@
   setNumOutputPorts(1);
   setOutputPort(0, "output", this, &Bias::getOutput);
 
-  addProperty("output", Property(this, &Bias::getOutput));
   addStoredProperty("bias", Property(this, &Bias::getBias, &Bias::setBias));
 }
 

Modified: trunk/OpenFDM/src/OpenFDM/DiscreteIntegrator.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/DiscreteIntegrator.cpp	2006-01-21 11:49:15 UTC (rev 212)
+++ trunk/OpenFDM/src/OpenFDM/DiscreteIntegrator.cpp	2006-01-21 11:56:51 UTC (rev 213)
@@ -23,8 +23,6 @@
   addProperty("initialValue", Property(this, &DiscreteIntegrator::getInitialValue, &DiscreteIntegrator::setInitialValue));
   addProperty("minSaturation", Property(this, &DiscreteIntegrator::getMinSaturation, &DiscreteIntegrator::setMinSaturation));
   addProperty("maxSaturation", Property(this, &DiscreteIntegrator::getMaxSaturation, &DiscreteIntegrator::setMaxSaturation));
-
-  addProperty("output", Property(this, &DiscreteIntegrator::getIntegralOutput));
 }
 
 DiscreteIntegrator::~DiscreteIntegrator(void)

Modified: trunk/OpenFDM/src/OpenFDM/Gain.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Gain.cpp	2006-01-21 11:49:15 UTC (rev 212)
+++ trunk/OpenFDM/src/OpenFDM/Gain.cpp	2006-01-21 11:56:51 UTC (rev 213)
@@ -28,8 +28,6 @@
   setNumOutputPorts(1);
   setOutputPort(0, "output", this, &Gain::getOutput);
 
-  addProperty("output", Property(this, &Gain::getOutput));
-  
   addStoredProperty("gain", Property(this, &Gain::getGain, &Gain::setGain));
 }
 

Modified: trunk/OpenFDM/src/OpenFDM/Integrator.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Integrator.cpp	2006-01-21 11:49:15 UTC (rev 212)
+++ trunk/OpenFDM/src/OpenFDM/Integrator.cpp	2006-01-21 11:56:51 UTC (rev 213)
@@ -21,11 +21,9 @@
   setNumOutputPorts(1);
   setOutputPort(0, "output", this, &Integrator::getIntegralOutput);
 
-  addProperty("initialValue",
-              Property(this, &Integrator::getInitialValue,
-                       &Integrator::setInitialValue));
-  addProperty("output",
-              Property(this, &Integrator::getIntegralOutput));
+  addStoredProperty("initialValue",
+                    Property(this, &Integrator::getInitialValue,
+                             &Integrator::setInitialValue));
 }
 
 Integrator::~Integrator(void)

Modified: trunk/OpenFDM/src/OpenFDM/MaxModel.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/MaxModel.cpp	2006-01-21 11:49:15 UTC (rev 212)
+++ trunk/OpenFDM/src/OpenFDM/MaxModel.cpp	2006-01-21 11:56:51 UTC (rev 213)
@@ -27,9 +27,7 @@
   setNumOutputPorts(1);
   setOutputPort(0, "output", this, &MaxModel::getMax);
 
-  addProperty("output", Property(this, &MaxModel::getMax));
-
-  addProperty("numMaxInputs", Property(this, &MaxModel::getNumMaxInputs, &MaxModel::setNumMaxInputs));
+  addStoredProperty("numMaxInputs", Property(this, &MaxModel::getNumMaxInputs, &MaxModel::setNumMaxInputs));
 }
 
 MaxModel::~MaxModel(void)

Modified: trunk/OpenFDM/src/OpenFDM/MinModel.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/MinModel.cpp	2006-01-21 11:49:15 UTC (rev 212)
+++ trunk/OpenFDM/src/OpenFDM/MinModel.cpp	2006-01-21 11:56:51 UTC (rev 213)
@@ -27,9 +27,7 @@
   setNumOutputPorts(1);
   setOutputPort(0, "output", this, &MinModel::getMin);
 
-  addProperty("output", Property(this, &MinModel::getMin));
-
-  addProperty("numMinInputs", Property(this, &MinModel::getNumMinInputs, &MinModel::setNumMinInputs));
+  addStoredProperty("numMinInputs", Property(this, &MinModel::getNumMinInputs, &MinModel::setNumMinInputs));
 }
 
 MinModel::~MinModel(void)

Modified: trunk/OpenFDM/src/OpenFDM/Product.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Product.cpp	2006-01-21 11:49:15 UTC (rev 212)
+++ trunk/OpenFDM/src/OpenFDM/Product.cpp	2006-01-21 11:56:51 UTC (rev 213)
@@ -26,8 +26,7 @@
   setNumOutputPorts(1);
   setOutputPort(0, "output", this, &Product::getProduct);
 
-  addProperty("output", Property(this, &Product::getProduct));
-  addProperty("numFactors", Property(this, &Product::getNumFactors, &Product::setNumFactors));
+  addStoredProperty("numFactors", Property(this, &Product::getNumFactors, &Product::setNumFactors));
 }
 
 Product::~Product(void)

Modified: trunk/OpenFDM/src/OpenFDM/Saturation.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Saturation.cpp	2006-01-21 11:49:15 UTC (rev 212)
+++ trunk/OpenFDM/src/OpenFDM/Saturation.cpp	2006-01-21 11:56:51 UTC (rev 213)
@@ -28,10 +28,8 @@
   setNumOutputPorts(1);
   setOutputPort(0, "output", this, &Saturation::getOutput);
 
-  addProperty("output", Property(this, &Saturation::getOutput));
-
-  addProperty("minSaturation", Property(this, &Saturation::getMinSaturation, &Saturation::setMinSaturation));
-  addProperty("maxSaturation", Property(this, &Saturation::getMaxSaturation, &Saturation::setMaxSaturation));
+  addStoredProperty("minSaturation", Property(this, &Saturation::getMinSaturation, &Saturation::setMinSaturation));
+  addStoredProperty("maxSaturation", Property(this, &Saturation::getMaxSaturation, &Saturation::setMaxSaturation));
 }
 
 Saturation::~Saturation(void)

Modified: trunk/OpenFDM/src/OpenFDM/Summer.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Summer.cpp	2006-01-21 11:49:15 UTC (rev 212)
+++ trunk/OpenFDM/src/OpenFDM/Summer.cpp	2006-01-21 11:56:51 UTC (rev 213)
@@ -27,9 +27,7 @@
   setNumOutputPorts(1);
   setOutputPort(0, "output", this, &Summer::getSum);
 
-  addProperty("output", Property(this, &Summer::getSum));
-
-  addProperty("numSummands", Property(this, &Summer::getNumSummands, &Summer::setNumSummands));
+  addStoredProperty("numSummands", Property(this, &Summer::getNumSummands, &Summer::setNumSummands));
 }
 
 Summer::~Summer(void)

Modified: trunk/OpenFDM/src/OpenFDM/Table.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Table.cpp	2006-01-21 11:49:15 UTC (rev 212)
+++ trunk/OpenFDM/src/OpenFDM/Table.cpp	2006-01-21 11:56:51 UTC (rev 213)
@@ -25,7 +25,6 @@
   setNumOutputPorts(1);
   setOutputPort(0, "output", this, &TablePreLookup::getOutput);
   
-  addProperty("output", Property(this, &TablePreLookup::getOutput));
   addStoredProperty("lookupVector", Property(this, &TablePreLookup::getTableLookup, &TablePreLookup::setTableLookup));
 }
 
@@ -74,7 +73,6 @@
   setNumOutputPorts(1);
   setOutputPort(0, "output", this, &Table1D::getOutput);
   
-  addProperty("output", Property(this, &Table1D::getOutput));
   addStoredProperty("data", Property(this, &Table1D::getTableData, &Table1D::setTableData));
 }
 
@@ -126,7 +124,6 @@
   setNumOutputPorts(1);
   setOutputPort(0, "output", this, &Table2D::getOutput);
   
-  addProperty("output", Property(this, &Table2D::getOutput));
   addStoredProperty("data", Property(this, &Table2D::getTableData, &Table2D::setTableData));
 }
 
@@ -183,7 +180,6 @@
   setNumOutputPorts(1);
   setOutputPort(0, "output", this, &Table3D::getOutput);
   
-  addProperty("output", Property(this, &Table3D::getOutput));
   addStoredProperty("data", Property(this, &Table3D::getTableData, &Table3D::setTableData));
 }
 

Modified: trunk/OpenFDM/src/OpenFDM/TimeDerivative.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/TimeDerivative.cpp	2006-01-21 11:49:15 UTC (rev 212)
+++ trunk/OpenFDM/src/OpenFDM/TimeDerivative.cpp	2006-01-21 11:56:51 UTC (rev 213)
@@ -18,8 +18,6 @@
 
   setNumOutputPorts(1);
   setOutputPort(0, "output", this, &TimeDerivative::getDerivativeOutput);
-
-  addProperty("output", Property(this, &TimeDerivative::getDerivativeOutput));
 }
 
 TimeDerivative::~TimeDerivative(void)

Modified: trunk/OpenFDM/src/OpenFDM/TransferFunction.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/TransferFunction.cpp	2006-01-21 11:49:15 UTC (rev 212)
+++ trunk/OpenFDM/src/OpenFDM/TransferFunction.cpp	2006-01-21 11:56:51 UTC (rev 213)
@@ -19,9 +19,8 @@
   mNum(1) = 1;
   mDen(1) = 1;
 
-  addProperty("numerator", Property(this, &DiscreteTransferFunction::getNumerator, &DiscreteTransferFunction::setNumerator));
-  addProperty("denominator", Property(this, &DiscreteTransferFunction::getDenominator, &DiscreteTransferFunction::setDenominator));
-  addProperty("output", Property(this, &DiscreteTransferFunction::getOutput));
+  addStoredProperty("numerator", Property(this, &DiscreteTransferFunction::getNumerator, &DiscreteTransferFunction::setNumerator));
+  addStoredProperty("denominator", Property(this, &DiscreteTransferFunction::getDenominator, &DiscreteTransferFunction::setDenominator));
 
   setDirectFeedThrough(true);
 



From frohlich at berlios.de  Sat Jan 21 13:44:37 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Sat, 21 Jan 2006 13:44:37 +0100
Subject: [OpenFDM-svn] r214 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200601211244.k0LCibvC010180@sheep.berlios.de>

Author: frohlich
Date: 2006-01-21 13:44:27 +0100 (Sat, 21 Jan 2006)
New Revision: 214

Modified:
   trunk/OpenFDM/src/OpenFDM/AeroForce.cpp
   trunk/OpenFDM/src/OpenFDM/AirSpring.cpp
   trunk/OpenFDM/src/OpenFDM/DiscreteIntegrator.cpp
   trunk/OpenFDM/src/OpenFDM/Force.cpp
   trunk/OpenFDM/src/OpenFDM/Force.h
   trunk/OpenFDM/src/OpenFDM/Input.cpp
   trunk/OpenFDM/src/OpenFDM/RevoluteActuator.cpp
   trunk/OpenFDM/src/OpenFDM/SimpleContact.cpp
   trunk/OpenFDM/src/OpenFDM/SimpleContact.h
   trunk/OpenFDM/src/OpenFDM/SimpleGear.cpp
   trunk/OpenFDM/src/OpenFDM/WheelContact.cpp
   trunk/OpenFDM/src/OpenFDM/WheelContact.h
Log:
Review some properties if they should be stored


Modified: trunk/OpenFDM/src/OpenFDM/AeroForce.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/AeroForce.cpp	2006-01-21 11:56:51 UTC (rev 213)
+++ trunk/OpenFDM/src/OpenFDM/AeroForce.cpp	2006-01-21 12:44:27 UTC (rev 214)
@@ -30,59 +30,6 @@
                     Property(this, &AeroForce::getWingArea, &AeroForce::setWingArea));
   addStoredProperty("coord",
                     Property(this, &AeroForce::getCoord, &AeroForce::setCoord));
-
-  addProperty("altitude",
-              Property(this, &AeroForce::getAltitude));
-  addProperty("aboveGroundLevel",
-              Property(this, &AeroForce::getAboveGroundLevel));
-
-  addProperty("trueSpeed",
-              Property(this, &AeroForce::getTrueSpeed));
-  addProperty("dynamicPressure",
-              Property(this, &AeroForce::getDynamicPressure));
-  addProperty("alpha",
-              Property(this, &AeroForce::getAlpha));
-  addProperty("alphaDot",
-              Property(this, &AeroForce::getAlphaDot));
-  addProperty("beta",
-              Property(this, &AeroForce::getBeta));
-  addProperty("betaDot",
-              Property(this, &AeroForce::getBetaDot));
-  addProperty("mach",
-              Property(this, &AeroForce::getMach));
-  addProperty("machNumber",
-              Property(this, &AeroForce::getMachNumber));
-  addProperty("trueSpeedUW",
-              Property(this, &AeroForce::getTrueSpeedUW));
-  addProperty("wingSpanOver2Speed",
-              Property(this, &AeroForce::getWingSpanOver2Speed));
-  addProperty("coordOver2Speed",
-              Property(this, &AeroForce::getCoordOver2Speed));
-  addProperty("hOverWingSpan",
-              Property(this, &AeroForce::getHOverWingSpan));
-
-  addProperty("pressure",
-              Property(this, &AeroForce::getPressure));
-  addProperty("density",
-              Property(this, &AeroForce::getDensity));
-  addProperty("soundSpeed",
-              Property(this, &AeroForce::getSoundSpeed));
-  addProperty("temperature",
-              Property(this, &AeroForce::getTemperature));
-
-  addProperty("u",
-              Property(this, &AeroForce::getBodyU));
-  addProperty("v",
-              Property(this, &AeroForce::getBodyV));
-  addProperty("w",
-              Property(this, &AeroForce::getBodyW));
-  addProperty("p",
-              Property(this, &AeroForce::getBodyP));
-  addProperty("q",
-              Property(this, &AeroForce::getBodyQ));
-  addProperty("r",
-              Property(this, &AeroForce::getBodyR));
-
   addOutputPort("wingSpan", this, &AeroForce::getWingSpan);
   addOutputPort("wingArea", this, &AeroForce::getWingArea);
   addOutputPort("coord", this, &AeroForce::getCoord);

Modified: trunk/OpenFDM/src/OpenFDM/AirSpring.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/AirSpring.cpp	2006-01-21 11:56:51 UTC (rev 213)
+++ trunk/OpenFDM/src/OpenFDM/AirSpring.cpp	2006-01-21 12:44:27 UTC (rev 214)
@@ -30,7 +30,7 @@
   addStoredProperty("maxCompression", Property(this, &AirSpring::getMaxCompression, &AirSpring::setMaxCompression));
   addStoredProperty("minCompression", Property(this, &AirSpring::getMinCompression, &AirSpring::setMinCompression));
   addStoredProperty("maxDamperConstant", Property(this, &AirSpring::getMaxDamperConstant, &AirSpring::setMaxDamperConstant));
-  addProperty("minDamperConstant", Property(this, &AirSpring::getMinDamperConstant, &AirSpring::setMinDamperConstant));
+  addStoredProperty("minDamperConstant", Property(this, &AirSpring::getMinDamperConstant, &AirSpring::setMinDamperConstant));
 
   setNumInputPorts(2);
   setInputPortName(0, "position");

Modified: trunk/OpenFDM/src/OpenFDM/DiscreteIntegrator.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/DiscreteIntegrator.cpp	2006-01-21 11:56:51 UTC (rev 213)
+++ trunk/OpenFDM/src/OpenFDM/DiscreteIntegrator.cpp	2006-01-21 12:44:27 UTC (rev 214)
@@ -20,9 +20,9 @@
   setNumOutputPorts(1);
   setOutputPort(0, "output", this, &DiscreteIntegrator::getIntegralOutput);
 
-  addProperty("initialValue", Property(this, &DiscreteIntegrator::getInitialValue, &DiscreteIntegrator::setInitialValue));
-  addProperty("minSaturation", Property(this, &DiscreteIntegrator::getMinSaturation, &DiscreteIntegrator::setMinSaturation));
-  addProperty("maxSaturation", Property(this, &DiscreteIntegrator::getMaxSaturation, &DiscreteIntegrator::setMaxSaturation));
+  addStoredProperty("initialValue", Property(this, &DiscreteIntegrator::getInitialValue, &DiscreteIntegrator::setInitialValue));
+  addStoredProperty("minSaturation", Property(this, &DiscreteIntegrator::getMinSaturation, &DiscreteIntegrator::setMinSaturation));
+  addStoredProperty("maxSaturation", Property(this, &DiscreteIntegrator::getMaxSaturation, &DiscreteIntegrator::setMaxSaturation));
 }
 
 DiscreteIntegrator::~DiscreteIntegrator(void)

Modified: trunk/OpenFDM/src/OpenFDM/Force.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Force.cpp	2006-01-21 11:56:51 UTC (rev 213)
+++ trunk/OpenFDM/src/OpenFDM/Force.cpp	2006-01-21 12:44:27 UTC (rev 214)
@@ -14,6 +14,8 @@
   END_OPENFDM_OBJECT_DEF
 BEGIN_OPENFDM_OBJECT_DEF(InternalForce)
   END_OPENFDM_OBJECT_DEF
+BEGIN_OPENFDM_OBJECT_DEF(LineForce)
+  END_OPENFDM_OBJECT_DEF
 
 Force::Force(const std::string& name, unsigned numParents) :
   Interact(name, numParents)

Modified: trunk/OpenFDM/src/OpenFDM/Force.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Force.h	2006-01-21 11:56:51 UTC (rev 213)
+++ trunk/OpenFDM/src/OpenFDM/Force.h	2006-01-21 12:44:27 UTC (rev 214)
@@ -31,8 +31,8 @@
   {
     mMountFrame = new FreeFrame(name);
 
-    addProperty("position", Property(this, &ExternalForce::getPosition, &ExternalForce::setPosition));
-    addProperty("orientation", Property(this, &ExternalForce::getOrientation, &ExternalForce::setOrientation));
+    addStoredProperty("position", Property(this, &ExternalForce::getPosition, &ExternalForce::setPosition));
+    addStoredProperty("orientation", Property(this, &ExternalForce::getOrientation, &ExternalForce::setOrientation));
   }
   virtual ~ExternalForce(void) {}
 
@@ -93,10 +93,10 @@
     mMountFrame[0] = new FreeFrame(name  + "<0>");
     mMountFrame[1] = new FreeFrame(name  + "<1>");
 
-    addProperty("position0", Property(this, &InternalForce::getPosition0, &InternalForce::setPosition0));
-    addProperty("orientation0", Property(this, &InternalForce::getOrientation0, &InternalForce::setOrientation0));
-    addProperty("position1", Property(this, &InternalForce::getPosition1, &InternalForce::setPosition1));
-    addProperty("orientation1", Property(this, &InternalForce::getOrientation1, &InternalForce::setOrientation1));
+    addStoredProperty("position0", Property(this, &InternalForce::getPosition0, &InternalForce::setPosition0));
+    addStoredProperty("orientation0", Property(this, &InternalForce::getOrientation0, &InternalForce::setOrientation0));
+    addStoredProperty("position1", Property(this, &InternalForce::getPosition1, &InternalForce::setPosition1));
+    addStoredProperty("orientation1", Property(this, &InternalForce::getOrientation1, &InternalForce::setOrientation1));
 
   }
   virtual ~InternalForce(void) {}
@@ -160,15 +160,12 @@
   Vector6 mForce;
 };
 
-class LineForce :
-    public InternalForce {
+class LineForce : public InternalForce {
+  OPENFDM_OBJECT(LineForce, InternalForce);
 public:
   LineForce(const std::string& name) :
     InternalForce(name)
   {
-    addProperty("relPos", Property(this, &LineForce::getRelPos));
-    addProperty("relVel", Property(this, &LineForce::getRelVel));
-
     addOutputPort("relPos", this, &LineForce::getRelPos);
     addOutputPort("relVel", this, &LineForce::getRelVel);
 

Modified: trunk/OpenFDM/src/OpenFDM/Input.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Input.cpp	2006-01-21 11:56:51 UTC (rev 213)
+++ trunk/OpenFDM/src/OpenFDM/Input.cpp	2006-01-21 12:44:27 UTC (rev 214)
@@ -16,8 +16,6 @@
   setNumOutputPorts(1);
   setOutputPort(0, "output", this, &Input::getOutputValue);
 
-  addProperty("inputValue",
-              Property(this, &Input::getInputValue, &Input::setInputValue));
   addStoredProperty("inputGain",
                     Property(this, &Input::getInputGain, &Input::setInputGain));
   addStoredProperty("inputName",
@@ -109,7 +107,6 @@
   setNumInputPorts(1);
   setInputPortName(0, "input");
 
-  addProperty("value", Property(this, &Output::getValue));
   addStoredProperty("outputGain",
                     Property(this, &Output::getOutputGain, &Output::setOutputGain));
   addStoredProperty("outputName",

Modified: trunk/OpenFDM/src/OpenFDM/RevoluteActuator.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RevoluteActuator.cpp	2006-01-21 11:56:51 UTC (rev 213)
+++ trunk/OpenFDM/src/OpenFDM/RevoluteActuator.cpp	2006-01-21 12:44:27 UTC (rev 214)
@@ -25,7 +25,7 @@
 
 RevoluteActuator::RevoluteActuator(const std::string& name) :
   Joint(name),
-  mMaxVel(1),
+  mMaxVel(10),
   mVelGain(1e2),
   mVelDotGain(1e2)
 {

Modified: trunk/OpenFDM/src/OpenFDM/SimpleContact.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/SimpleContact.cpp	2006-01-21 11:56:51 UTC (rev 213)
+++ trunk/OpenFDM/src/OpenFDM/SimpleContact.cpp	2006-01-21 12:44:27 UTC (rev 214)
@@ -21,6 +21,10 @@
   mSpringConst = 0;
   mSpringDamp = 0;
   mFrictionCoef = 0;
+
+  addStoredProperty("springConstant", Property(this, &SimpleContact::getSpringConstant, &SimpleContact::setSpringConstant));
+  addStoredProperty("springDamping", Property(this, &SimpleContact::getSpringDamping, &SimpleContact::setSpringDamping));
+  addStoredProperty("frictionCoeficient", Property(this, &SimpleContact::getFrictionCoeficient, &SimpleContact::setFrictionCoeficient));
 }
 
 SimpleContact::~SimpleContact(void)

Modified: trunk/OpenFDM/src/OpenFDM/SimpleContact.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/SimpleContact.h	2006-01-21 11:56:51 UTC (rev 213)
+++ trunk/OpenFDM/src/OpenFDM/SimpleContact.h	2006-01-21 12:44:27 UTC (rev 214)
@@ -20,19 +20,19 @@
   SimpleContact(const std::string& name);
   virtual ~SimpleContact(void);
 
-  real_type getSpringConstant(void) const
+  const real_type& getSpringConstant(void) const
   { return mSpringConst; }
-  void setSpringConstant(real_type springConst)
+  void setSpringConstant(const real_type& springConst)
   { mSpringConst = springConst; }
 
-  real_type getSpringDamping(void) const
+  const real_type& getSpringDamping(void) const
   { return mSpringDamp; }
-  void setSpringDamping(real_type springDamp)
+  void setSpringDamping(const real_type& springDamp)
   { mSpringDamp = springDamp; }
 
-  real_type getFrictionCoeficient(void) const
+  const real_type& getFrictionCoeficient(void) const
   { return mFrictionCoef; }
-  void setFrictionCoeficient(real_type frictionCoef)
+  void setFrictionCoeficient(const real_type& frictionCoef)
   { mFrictionCoef = frictionCoef; }
 
   // Compute the plane normal force.

Modified: trunk/OpenFDM/src/OpenFDM/SimpleGear.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/SimpleGear.cpp	2006-01-21 11:56:51 UTC (rev 213)
+++ trunk/OpenFDM/src/OpenFDM/SimpleGear.cpp	2006-01-21 12:44:27 UTC (rev 214)
@@ -26,21 +26,24 @@
   mSpringDamp = 0;
   mFrictionCoef = 0;
 
+  // ??? FIXME
   addProperty("steeringAngle",
               Property(this, &SimpleGear::getSteeringAngle,
                        &SimpleGear::setSteeringAngle));
   addProperty("brake",
               Property(this, &SimpleGear::getBrake, &SimpleGear::setBrake));
-  addProperty("springConstant",
-              Property(this, &SimpleGear::getSpringConstant,
-                       &SimpleGear::setSpringConstant));
-  addProperty("springDamping",
-              Property(this, &SimpleGear::getSpringDamping,
-                       &SimpleGear::setSpringDamping));
-  addProperty("frictionCoeficient",
-              Property(this, &SimpleGear::getFrictionCoeficient,
-                       &SimpleGear::setFrictionCoeficient));
 
+
+  addStoredProperty("springConstant",
+                    Property(this, &SimpleGear::getSpringConstant,
+                             &SimpleGear::setSpringConstant));
+  addStoredProperty("springDamping",
+                    Property(this, &SimpleGear::getSpringDamping,
+                             &SimpleGear::setSpringDamping));
+  addStoredProperty("frictionCoeficient",
+                    Property(this, &SimpleGear::getFrictionCoeficient,
+                             &SimpleGear::setFrictionCoeficient));
+
   unsigned inputPortBase = getNumInputPorts();
   setNumInputPorts(inputPortBase + 2);
   setInputPortName(inputPortBase + 0, "brakeCommand");

Modified: trunk/OpenFDM/src/OpenFDM/WheelContact.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/WheelContact.cpp	2006-01-21 11:56:51 UTC (rev 213)
+++ trunk/OpenFDM/src/OpenFDM/WheelContact.cpp	2006-01-21 12:44:27 UTC (rev 214)
@@ -24,6 +24,11 @@
   mSpringDamping = 0;
   mFrictionCoeficient = 0.8;
 
+  addStoredProperty("wheelRadius", Property(this, &WheelContact::getWheelRadius, &WheelContact::setWheelRadius));
+  addStoredProperty("springConstant", Property(this, &WheelContact::getSpringConstant, &WheelContact::setSpringConstant));
+  addStoredProperty("springDamping", Property(this, &WheelContact::getSpringDamping, &WheelContact::setSpringDamping));
+  addStoredProperty("frictionCoeficient", Property(this, &WheelContact::getFrictionCoeficient, &WheelContact::setFrictionCoeficient));
+
   // FIXME??
   addSampleTime(SampleTime::PerTimestep);
   addSampleTime(SampleTime::Continous);

Modified: trunk/OpenFDM/src/OpenFDM/WheelContact.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/WheelContact.h	2006-01-21 11:56:51 UTC (rev 213)
+++ trunk/OpenFDM/src/OpenFDM/WheelContact.h	2006-01-21 12:44:27 UTC (rev 214)
@@ -33,24 +33,24 @@
   computeFrictionForce(real_type normForce, const Vector2& vel,
                        real_type omegaR, real_type friction) const;
 
-  void setWheelRadius(real_type wheelRadius)
+  void setWheelRadius(const real_type& wheelRadius)
   { mWheelRadius = wheelRadius; }
-  real_type getWheelRadius(void) const
+  const real_type& getWheelRadius(void) const
   { return mWheelRadius; }
 
-  void setSpringConstant(real_type springConstant)
+  void setSpringConstant(const real_type& springConstant)
   { mSpringConstant = springConstant; }
-  real_type getSpringConstant(void) const
+  const real_type& getSpringConstant(void) const
   { return mSpringConstant; }
 
-  void setSpringDamping(real_type springDamping)
+  void setSpringDamping(const real_type& springDamping)
   { mSpringDamping = springDamping; }
-  real_type getSpringDamping(void) const
+  const real_type& getSpringDamping(void) const
   { return mSpringDamping; }
 
-  void setFrictionCoeficient(real_type frictionCoeficient)
+  void setFrictionCoeficient(const real_type& frictionCoeficient)
   { mFrictionCoeficient = frictionCoeficient; }
-  real_type getFrictionCoeficient(void) const
+  const real_type& getFrictionCoeficient(void) const
   { return mFrictionCoeficient; }
 private:
   void getGround(real_type t);



From frohlich at berlios.de  Sun Jan 22 09:54:31 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Sun, 22 Jan 2006 09:54:31 +0100
Subject: [OpenFDM-svn] r215 - trunk/OpenFDM/src/JSBSim
Message-ID: <200601220854.k0M8sVcs012372@sheep.berlios.de>

Author: frohlich
Date: 2006-01-22 09:54:23 +0100 (Sun, 22 Jan 2006)
New Revision: 215

Modified:
   trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
Log:
Make parsing again deterministic :-/


Modified: trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
===================================================================
--- trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2006-01-21 12:44:27 UTC (rev 214)
+++ trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2006-01-22 08:54:23 UTC (rev 215)
@@ -108,8 +108,11 @@
 
   // Parse the file and generate a dom like representation of it
   XMLDomParser parser;
-  if (!parser.parseXML(fixedAcStream))
+  if (!parser.parseXML(fixedAcStream)) {
+    std::cerr << "Parsing XML failed:" << std::endl;
+    std::cerr << parser.getErrorMessage() << std::endl;
     return false;
+  }
 
   return convertDocument(parser.getDocument());
 }
@@ -2101,7 +2104,8 @@
 
   XMLDomParser eParser;
   if (!eParser.parseXML(eFileStream))
-    return error("Error parsing engine \"" + engineName + "\"");
+    return error("Error parsing engine \"" + engineName + "\":"
+                 + eParser.getErrorMessage());
   eFileStream.close();
 
   const XMLDocument* engineDoc = eParser.getDocument();
@@ -2225,7 +2229,7 @@
 
 //   mVehicle->getTopBody()->addInteract(engineForce);
 
-//   return true;
+  return true;
 }
 
 bool



From frohlich at berlios.de  Sun Jan 22 16:05:43 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Sun, 22 Jan 2006 16:05:43 +0100
Subject: [OpenFDM-svn] r216 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200601221505.k0MF5hBi030135@sheep.berlios.de>

Author: frohlich
Date: 2006-01-22 16:05:40 +0100 (Sun, 22 Jan 2006)
New Revision: 216

Removed:
   trunk/OpenFDM/src/OpenFDM/main.cpp
Modified:
   trunk/OpenFDM/src/OpenFDM/Makefile.am
Log:
Remove main.cpp


Modified: trunk/OpenFDM/src/OpenFDM/Makefile.am
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Makefile.am	2006-01-22 08:54:23 UTC (rev 215)
+++ trunk/OpenFDM/src/OpenFDM/Makefile.am	2006-01-22 15:05:40 UTC (rev 216)
@@ -1,15 +1,12 @@
 
 INCLUDES = -I$(srcdir)/..
 
-noinst_PROGRAMS = main units
+noinst_PROGRAMS = units
 
 # define some unit tests
 check_PROGRAMS = quattest
 TESTS          = $(check_PROGRAMS)
 
-main_SOURCES = main.cpp
-main_LDADD = libOpenFDM.la
-
 units_SOURCES = units.cpp
 units_LDADD = libOpenFDM.la
 

Deleted: trunk/OpenFDM/src/OpenFDM/main.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/main.cpp	2006-01-22 08:54:23 UTC (rev 215)
+++ trunk/OpenFDM/src/OpenFDM/main.cpp	2006-01-22 15:05:40 UTC (rev 216)
@@ -1,669 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2006 Mathias Froehlich 
- *
- */
-
-#include <iostream>
-#include <fstream>
-#include <sstream>
-#include <iomanip>
-#include <vector>
-#include <list>
-#include <string>
-using namespace std;
-
-#include <OpenFDM/Object.h>
-#include <OpenFDM/Vector.h>
-#include <OpenFDM/Matrix.h>
-#include <OpenFDM/Quaternion.h>
-#include <OpenFDM/Frame.h>
-#include <OpenFDM/Friction2D.h>
-#include <OpenFDM/Units.h>
-#include <OpenFDM/Planet.h>
-#include <OpenFDM/DefaultPlanet.h>
-#include <OpenFDM/RigidBody.h>
-#include <OpenFDM/MobileRootJoint.h>
-#include <OpenFDM/AeroForce.h>
-#include <OpenFDM/SimpleContact.h>
-#include <OpenFDM/SimpleGear.h>
-#include <OpenFDM/ExplicitEuler.h>
-#include <OpenFDM/ExplicitAdams.h>
-#include <OpenFDM/ImplicitEuler.h>
-#include <OpenFDM/MidpointRule.h>
-#include <OpenFDM/DoPri5.h>
-#include <OpenFDM/Newton.h>
-#include <OpenFDM/Mass.h>
-#include <OpenFDM/Vehicle.h>
-#include <OpenFDM/RevoluteJoint.h>
-#include <OpenFDM/PrismaticJoint.h>
-#include <OpenFDM/ReaderWriter.h>
-#include <OpenFDM/LogStream.h>
-#include <OpenFDM/Variant.h>
-#include <OpenFDM/Property.h>
-
-// Model includes
-#include <OpenFDM/Model.h>
-#include <OpenFDM/ModelGroup.h>
-#include <OpenFDM/Bias.h>
-#include <OpenFDM/ConstModel.h>
-#include <OpenFDM/DeadBand.h>
-#include <OpenFDM/DiscreteIntegrator.h>
-#include <OpenFDM/Gain.h>
-#include <OpenFDM/Integrator.h>
-#include <OpenFDM/TimeDerivative.h>
-#include <OpenFDM/UnaryFunctionModel.h>
-#include <OpenFDM/BinaryFunctionModel.h>
-#include <OpenFDM/Product.h>
-#include <OpenFDM/Saturation.h>
-#include <OpenFDM/Summer.h>
-
-#include "XML/XMLReader.h"
-
-using namespace OpenFDM;
-
-namespace OpenFDM {
-
-class OpenFDMReader :
-    public ReaderWriter {
-public:
-  OpenFDMReader(void) {}
-  virtual ~OpenFDMReader(void) {}
-
-//   void setInputFile(const std::string& inputFile)
-//   { mInputFile = inputFile; }
-//   const std::string& getInputFile(void) const
-//   { return mInputFile; }
-
-//   // FIXME
-//   std::string mInputFile;
-
-
-  // FIXME
-  virtual void reset(void)
-  {}
-
-  /** Read scalar value element from dom tree.
-   * 
-   */
-  template<typename T>
-  bool
-  readScalar(const XMLElement* element, T& scalar)
-  {
-    if (!element)
-      return error("Error reading scalar: no such element!");
-    
-    // FIXME handle units!!!
-
-    std::stringstream stream(element->getData());
-    stream >> scalar;
-    if (stream.fail())
-      return error("Error reading scalar: Could not read scalar data!");
-
-    return true;
-  }
-  
-  /** Read scalar value element from dom tree.
-   * 
-   */
-  bool
-  readVector3(const XMLElement* element, Vector3& v)
-  {
-    if (!element || element->getName() != "Vector")
-      return error("Error reading Vector: no such element!");
-    
-    // FIXME handle units!!!
-    std::stringstream stream(element->getData());
-    stream >> v(1) >> v(2) >> v(3);
-    if (stream.fail())
-      return error("Error reading Vector: Could not read vector data!");
-
-    return true;
-  }
-  
-  bool
-  readQuaternion(const XMLElement* element, Quaternion& q)
-  {
-    if (!element || element->getName() != "quaternion")
-      return error("Error reading Quternion: no such element!");
-    
-    std::stringstream stream(element->getData());
-    stream >> q(1) >> q(2) >> q(3) >> q(4);
-    if (stream.fail())
-      return error("Error reading Quaternion: Could not read vector data!");
-    
-    // Check if the norm is properly normalized
-    bool normalized = (norm(q)-1) < 8*Limits<Quaternion::value_type>::epsilon();
-    if (!normalized)
-      return error("Error reading Quaternion: Quaternion is not normalized!");
-
-    return true;
-  }
-
-  bool
-  readMatrix(const XMLElement* element, Matrix& m)
-  {
-    if (!element || element->getName() != "matrix")
-      return error("Error reading Vector: no such element!");
-    
-    unsigned columns = 1;
-    std::string columnsStr = element->getAttribute("columns");
-    if (!columnsStr.empty()) {
-      std::stringstream stream(columnsStr);
-      stream >> columns;
-      if (stream.fail())
-        error("Error reading matrix: cannot read Columns attribute!");
-    }
-    
-    unsigned rows = 1;
-    std::string rowsStr = element->getAttribute("rows");
-    if (!rowsStr.empty()) {
-      std::stringstream stream(rowsStr);
-      stream >> rows;
-      if (stream.fail())
-        error("Error Reading Matrix: cannot read Rows attribute!");
-    }
-
-    m.resize(rows, columns);
-    // FIXME handle units!!!
-    std::stringstream stream(element->getData());
-    for (unsigned i = 1; i <= rows; ++i)
-      for (unsigned j = 1; j <= columns; ++j)
-        stream >> m(i, j);
-
-    if (stream.fail())
-      return error("Error reading Matrix: Could not read matrix data!");
-
-    return true;
-  }
-
-  bool
-  readOrientation(const XMLElement* element, Quaternion& q)
-  {
-    if (!element || element->getName() != "Orientation")
-      return error("Error reading Orientation: no such element!");
-    
-    // Check if the orientation is present in a quaternion.
-    std::list<XMLElement::const_pointer> qs = element->getElements("quaternion");
-    // Fail if there are multiple elements.
-    if (1 < qs.size())
-      return error("Error reading Orientation: Multiple Quaternion elements!");
-    if (1 == qs.size()) {
-      if (!readQuaternion(qs.front(), q))
-        return error("Error reading Orientation: Could not read Quaternion!");
-      else
-        return true;
-    }
-    
-    // Check if the orientation is present in angle axis representation.
-    std::list<XMLElement::const_pointer> angs = element->getElements("Angle");
-    std::list<XMLElement::const_pointer> axs = element->getElements("Axis");
-    if (0 < angs.size() || 0 < axs.size()) {
-      // Fail if there are multiple elements.
-      if (1 < angs.size())
-        return error("Error reading Orientation: Multiple Angle elements!");
-      if (0 == angs.size())
-        return error("Error reading Orientation: No Angle element where Axis element is present!");
-      if (1 < axs.size())
-        return error("Error reading Orientation: Multiple Axis elements!");
-      if (0 == axs.size())
-        return error("Error reading Orientation: No Axis element where Angle is present!");
-      
-      // Read angle.
-      real_type angle;
-      if (!readScalar(angs.front(), angle))
-        return error("Error reading Orientation: Could not read Angle!");
-      
-      // Read axis.
-      Vector3 axis;
-      if (!readVector3(axs.front(), axis))
-        return error("Error reading Orientation: Could not read Axis!");
-      
-      q = Quaternion::fromAngleAxis(angle, axis);
-      return true;
-    }
-    
-    // Check if the orientation is present in euler angle representation.
-    std::list<XMLElement::const_pointer> rll = element->getElements("Roll");
-    std::list<XMLElement::const_pointer> att = element->getElements("Attitude");
-    std::list<XMLElement::const_pointer> hdng = element->getElements("Heading");
-    if (0 < rll.size() || 0 < att.size() || 0 < hdng.size()) {
-      // Fail if there are multiple elements.
-      if (1 < rll.size())
-        return error("Error reading Orientation: Multiple Roll elements!");
-      if (1 < att.size())
-        return error("Error reading Orientation: Multiple Attitude elements!");
-      if (1 < hdng.size())
-        return error("Error reading Orientation: Multiple Heading elements!");
-      
-      // Read the roll angle.
-      real_type roll = 0;
-      if (0 < rll.size() && !readScalar(rll.front(), roll))
-        return error("Error reading Orientation: Could not read Roll!");
-      
-      // Read the pitch angle.
-      real_type attitude = 0;
-      if (0 < att.size() && !readScalar(att.front(), attitude))
-        return error("Error reading Orientation: Could not read Attitude!");
-      
-      // Read the heading angle.
-      real_type heading = 0;
-      if (0 < hdng.size() && !readScalar(hdng.front(), heading))
-        return error("Error reading Orientation: Could not read Heading!");
-      
-      // FIXME: verify ...
-      q = Quaternion::fromHeadAttBank(attitude, heading, roll);
-      
-      return true;
-    }
-    
-    return error("Error reading Orientation: No Orientation data found!");
-  }
-
-  bool
-  readPort(const XMLElement* element, std::string& name, unsigned& number)
-  {
-    name = element->getAttribute("name");
-    if (name.empty())
-      return error("Port found without or with empty name attribute!");
-    if (!readScalar(element, number))
-      return error("Can not read port number!");
-    return true;
-  }
-
-  bool
-  readObjectProperties(const XMLElement* element, Object* object)
-  {
-    std::list<std::string> props = object->listProperties();
-    std::list<std::string>::iterator it = props.begin();
-    while (it != props.end()) {
-      if (1 < element->getNumElements(*it))
-        return error(std::string("Error loading Model: More than one \"")
-                     + *it + "\" Property tag in model definition!");
-
-      const XMLElement* propElement = element->getElement(*it);
-      if (propElement) {
-        if (1 != propElement->getNumElements("matrix"))
-          return error("InitialValue tag found without content!");
-
-        Matrix m;
-        if (!readMatrix(propElement->getElement("matrix"), m))
-          return error("Cannot read InitialValue Matrix!");
-
-        object->setPropertyValue(*it, Variant(m));
-
-        // FIXME add more here
-      }
-      ++it;
-    }
-  }
-
-  bool
-  readModel(const XMLElement* modelElement, ModelGroup* group)
-  {
-   std::string name = modelElement->getAttribute("name");
-    if (name.empty())
-      return error("Error loading Models: Empty name!");
-
-    std::string type = modelElement->getAttribute("type");
-    SharedPtr<Model> model;
-    if (type == "Bias") {
-      model = new Bias(name);
-    } else if (type == "Const") {
-      model = new ConstModel(name, Matrix()); // FIXME
-    } else if (type == "DeadBand") {
-      model = new DeadBand(name);
-    } else if (type == "DiscreteIntegrator") {
-      model = new DiscreteIntegrator(name);
-    } else if (type == "Gain") {
-      model = new Gain(name);
-    } else if (type == "Integrator") {
-      model = new Integrator(name);
-    } else if (type == "Product") {
-      model = new Product(name);
-    } else if (type == "Saturation") {
-      model = new Saturation(name);
-    } else if (type == "TimeDerivative") {
-      model = new TimeDerivative(name);
-    } else
-      return error(std::string("Error loading Models: Unknown Model type \"")
-                   + type + "\" !");
-
-    if (!readObjectProperties(modelElement, model))
-      return error("Error loading Models: Error reading properties !");
-
-    group->addModel(model);
-
-    return true;
-  }
-
-  bool
-  readModelGroup(const XMLElement* controlSystem, ModelGroup* group)
-  {
-    // Read all Models.
-    std::list<XMLElement::const_pointer> models
-      = controlSystem->getElements("model");
-    if (0 == models.size())
-      return error("Error loading Vehicle: No Model found");
-
-    std::list<XMLElement::const_pointer>::iterator it = models.begin();
-    while (it != models.end()) {
-      if (!readModel(*it, group))
-        return false;
-      ++it;
-    }
-
-    std::list<XMLElement::const_pointer> connections
-      = controlSystem->getElements("connect");
-    it = connections.begin();
-    while (it != connections.end()) {
-      if (1 != (*it)->getNumElements("src"))
-        return error("No src element found in connect element!");
-      std::string name;
-      unsigned number;
-      if (!readPort((*it)->getElement("src"), name, number))
-        return false;
-
-      Model* srcModel = group->getModel(name);
-      if (!srcModel)
-        return error("Can not find src model named \"" + name + "\" !");
-      if (srcModel->getNumOutputPorts() <= number)
-        return error("Model \"" + name + "\" has not enough output ports!");
-      Port* srcPort = srcModel->getOutputPort(number);
-      if (!srcPort)
-        return error("Model \"" + name + "\" returns invalid output port!");
-
-      if (1 != (*it)->getNumElements("dst"))
-        return error("No dst element found in connect element!");
-      if (!readPort((*it)->getElement("dst"), name, number))
-        return false;
-
-      Model* dstModel = group->getModel(name);
-      if (!dstModel)
-        return error("Can not find dst model named \"" + name + "\" !");
-      if (dstModel->getNumInputPorts() <= number)
-        return error("Model \"" + name + "\" has not enough input ports!");
-
-      Port* dstPort = dstModel->getInputPort(number);
-      if (!dstPort)
-        return error("Model \"" + name + "\" returns invalid input port!");
-      dstPort->connect(srcPort);
-
-      // FIXME
-      ++it;
-    }
-
-    return true;
-  }
-
-  bool
-  readRigidBodies(const XMLElement* mechanicalSystem)
-  {
-    // Read all rigid bodies.
-    std::list<XMLElement::const_pointer> rigidBodies
-      = mechanicalSystem->getElements("RigidBody");
-    if (0 == rigidBodies.size())
-      return error("Error loading Vehicle: No RigidBody found");
-
-    std::list<XMLElement::const_pointer>::iterator it = rigidBodies.begin();
-    while (it != rigidBodies.end()) {
-      RigidBody* rigidBody = new RigidBody("rigid body");
-      rigidBody->setName((*it)->getAttribute("Name"));
-      
-//       if (mVehicle->getRigidBody((*it)->getAttribute("Name")))
-//         return error(std::string("Error loading RigidBodies: Duplicate Rigid Body Name \"")
-//                      + (*it)->getAttribute("Name") + "\" !");
-      
-//       mVehicle->addRigidBody(rigidBody);
-      ++it;
-    }
-    return true;
-  }
-
-  bool
-  readJoints(const XMLElement* mechanicalSystem)
-  {
-    // Read all joints bodies.
-    std::list<XMLElement::const_pointer> joints
-      = mechanicalSystem->getElements("Joint");
-    std::list<XMLElement::const_pointer>::iterator it = joints.begin();
-    while (it != joints.end()) {
-      Joint* joint = 0;
-      std::string name = (*it)->getAttribute("Name");
-      if ((*it)->getAttribute("Type") == "Revolute")
-        joint = new RevoluteJoint(name);
-      else if ((*it)->getAttribute("Type") == "Prismatic")
-        joint = new PrismaticJoint(name);
-      if (!joint)
-        return error(std::string("Error loading Vehicle: Unknown Joint type \"")
-                     + (*it)->getAttribute("Type") + "\" !");
-      
-      
-//       if (mVehicle->getJoint((*it)->getAttribute("Name")))
-//         return error(std::string("Error loading Vehicle: Duplicate Name \"")
-//                      + (*it)->getAttribute("Name") + "\" !");
-//       mVehicle->addJoint(joint);
-      
-      
-      // Connect the joints to the rigid bodies.
-      std::list<XMLElement::const_pointer> mounts
-        = (*it)->getElements("Mount");
-      if (mounts.size() != 2)
-        return error("Error loading Vehicle: More or less then 2 Mounts!");
-      std::list<XMLElement::const_pointer>::iterator mit = mounts.begin();
-      for (unsigned idx = 0; mit != mounts.end(); ++idx, ++mit) {
-        std::string mountAttrName = (*mit)->getAttribute("Name");
-//         RigidBody* body = mVehicle->getRigidBody(mountAttrName);
-//         if (!body)
-//           return error(std::string("Error loading Vehicle:") +
-//                        " Can not find RigidBody \"" + mountAttrName +
-//                        "\" for Mount of Joint \"" + joint->getName() + "\"!");
-       
-//         joint->setParentFrame(body, idx);
-        
-        // Read the orientation. No orientation element means unit orientation.
-        // Multiple orientations is an error.
-        std::list<XMLElement::const_pointer> orients
-          = (*mit)->getElements("Orientation");
-        Quaternion orientation = Quaternion::unit();
-        if (0 < orients.size()) {
-          if (1 < orients.size())
-            return error("Error loading Vehicle: More than one Orientation!");
-          if (!readOrientation(orients.front(), orientation))
-            return error("Error loading Vehicle: Could not read Orientation!");
-        }
-        
-        // Read the position. No position element means unit position.
-        // Multiple positions is an error.
-        std::list<XMLElement::const_pointer> positions
-          = (*mit)->getElements("Position");
-        Vector3 position = Vector3::zeros();
-        if (0 < positions.size()) {
-          if (1 < positions.size())
-            return error("Error loading Vehicle: More than one Position!");
-          
-          std::list<XMLElement::const_pointer> vectors
-            = positions.front()->getElements("Vector");
-          if (vectors.size() != 1)
-            return error("Error loading Vehicle: More than 1 Vector!");
-          if (!readVector3(vectors.front(), position))
-            return error("Error loading Vehicle: Could not read Position!");
-        }
-        
-      }
-      ++it;
-    }
-
-    return true;
-  }
-
-  bool
-  loadVehicle(const std::string& acFile)
-  {
-    std::ifstream infile;
-    infile.open(acFile.c_str());
-    if (!infile.is_open())
-      return 0;
-    
-    XMLDomParser parser;
-    if (!parser.parseXML(infile))
-      return error("Error loading Vehicle: Could not parse xml data!");
-    
-    infile.close();
-    
-    XMLDocument* doc = parser.getDocument();
-    if (!doc)
-      return error("Error loading Vehicle: Could not parse xml data!");
-    XMLElement* openFDM = doc->getElement();
-    if (!openFDM)
-      return error("Error loading Vehicle: Could not get toplevel element!");
-    if (openFDM->getName() != "OpenFDM")
-      return error("Error loading Vehicle: Toplevel element is not an "
-                   "OpenFDM element!");
-    if (openFDM->getAttribute("version") != "1")
-      return error("Error loading Vehicle: Invalid OpenFDM version!");
-    
-    XMLElement* mechanicalSystem = openFDM->getElement("MechanicalSystem");
-    if (!mechanicalSystem)
-      return error("Error loading Vehicle: Cannot find a MechanicalSystem "
-                   "element!");
-    
-    XMLElement* controlSystem = openFDM->getElement("ControlSystem");
-    if (!controlSystem)
-      return error("Error loading Vehicle: Cannot find a MechanicalSystem "
-                   "element!");
-
-
-    mVehicle = new Vehicle;
-    
-    if (!readModelGroup(controlSystem, mVehicle->getModelGroup()))
-      return error("Error loading Vehicle: Can not load Model elements!");
-
-    if (!readRigidBodies(mechanicalSystem))
-      return error("Error loading Vehicle: Can not load RigidBody elements!");
-    
-    if (!readJoints(mechanicalSystem))
-      return error("Error loading Vehicle: Can not load Joint elements!");
-
-    mVehicle->setGeodPosition(Geodetic(0.0, 0.0, 0.0));
-
-    return true;
-  }
-};
-  
-} // namespace OpenFDM
-
-void printVehicle(Vehicle* vehicle)
-{
-  cout << "T = " << vehicle->getTime()
-       << ", Pos: " << vehicle->getGeodPosition()
-//        << ", Or: " << vehicle->getGeodOrientation()
-       << endl;
-
-}
-
-int main(int argc, char *argv[])
-{
-#if 1
-  if (argc < 2)
-    return 1;
-  
-  OpenFDMReader reader;
-  reader.loadVehicle(argv[1]);
-  SharedPtr<Vehicle> vehicle = reader.getVehicle();
-
-  if (reader.getErrorState()) {
-    std::cerr << "Could not read vehicle:" << std::endl;
-    const ReaderWriter::StringList errors = reader.getErrors();
-    ReaderWriter::StringList::const_iterator it = errors.begin();
-    while (it != errors.end()) {
-      std::cerr << *it << std::endl;
-      ++it;
-    }
-    return 1;
-  }
-
-  if (!vehicle) {
-    std::cerr << "could not read vehicle" << std::endl;
-    return 1;
-  }
-
-  printVehicle(vehicle);
-
-  System* system = vehicle->getSystem();
-  bool initOk = system->init();
-  if (!initOk) {
-    cout << "Error  in init" << endl;
-    return -17;
-  }
-  ModelGroup* modelGroup = vehicle->getModelGroup();
-  for (unsigned i = 0; i < modelGroup->getNumModels(); ++i) {
-    cout << modelGroup->getModel(i)->getName() << endl;
-  }
-  for (unsigned j = 0; j < 1000; ++j) {
-    system->simulate(j*0.01);
-
-    for (unsigned i = 0; i < modelGroup->getNumModels(); ++i)
-      cout << modelGroup->getModel(i)->getOutputPort("output")->getValue().toMatrix() << " ";
-
-    cout << endl;
-  }
-
-#else
-  SharedPtr<Vehicle> vehicle = new Vehicle();
-
-  Geodetic geod;
-  geod.longitude = -81.636*deg2rad;
-  geod.latitude = 28.594*deg2rad;
-  geod.altitude = convertFrom(uFoot, 918720.0);
-  vehicle->setGeodPosition(geod);
-
-  real_type heading = 90*deg2rad;
-  Quaternion q = Quaternion::fromAngleAxis(heading, Vector3::unit(3));
-  vehicle->setGeodOrientation(q);
-
-  vehicle->getMobileRootJoint()->setRelVel(Vector6::zeros());
-  Vector3 vel(convertFrom(uFeetPSecond, 23900.0), 0, 0);
-  vehicle->getMobileRootJoint()->setLinearRelVel(vel);
-  vehicle->getTopBody()->addMultiBodyModel(new Mass("Testmass", SpatialInertia(InertiaMatrix(100,0,0,100,0,100), 100), "Mass"));
-
-
-  RigidBody* body = new RigidBody;
-  body->setName("Body am revolute Joint");
-  body->addMultiBodyModel(new Mass("Testmass", SpatialInertia(InertiaMatrix(1,0,0,1,0,1), 1), "Mass"));
-  vehicle->getTopBody()->addChildFrame(body);
-  PrismaticJoint* joint = new PrismaticJoint("Prismatic Joint 1");
-  // FIXME, seem to have a poblem with the 2*pi periodicity,
-  // use some type of quaternion ...
-//   RevoluteJoint* joint = new RevoluteJoint("Revolute Joint 1");
-  joint->setJointAxis(Vector3(1, 0, 0));
-  vehicle->getTopBody()->addMultiBodyModel(joint);
-  body->addMultiBodyModel(joint, 1);
-
-
-  RigidBody* body2 = new RigidBody;
-  body2->setName("Body2 am prismatic Joint");
-  body2->addMultiBodyModel(new Mass("Testmass", SpatialInertia(InertiaMatrix(1,0,0,1,0,1), 1), "Mass"));
-  body->addChildFrame(body2);
-//   PrismaticJoint* joint2 = new PrismaticJoint("Prismatic Joint 1");
-  RevoluteJoint* joint2 = new RevoluteJoint("Revolute Joint 2");
-  joint2->setJointAxis(Vector3(0, 1, 0));
-  body->addMultiBodyModel(joint2);
-  body2->addMultiBodyModel(joint2, 1);
-
-  vehicle->init();
-
-  printVehicle(vehicle);
-
-
-  real_type tEnd = 200;
-  real_type dt = 10;
-//   dt = 1.0/128;
-  while (vehicle->getTime() < tEnd) {
-    vehicle->output();
-    vehicle->update(dt);
-    printVehicle(vehicle);
-  }
-#endif
-
-  return 0;
-}
-



From frohlich at berlios.de  Sun Jan 22 16:18:11 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Sun, 22 Jan 2006 16:18:11 +0100
Subject: [OpenFDM-svn] r217 - in trunk/OpenFDM/src: JSBSim OpenFDM OpenFDM/XML
Message-ID: <200601221518.k0MFIBJJ031789@sheep.berlios.de>

Author: frohlich
Date: 2006-01-22 16:17:59 +0100 (Sun, 22 Jan 2006)
New Revision: 217

Added:
   trunk/OpenFDM/src/JSBSim/Tablereader.cpp
   trunk/OpenFDM/src/JSBSim/Tablereader.h
   trunk/OpenFDM/src/JSBSim/XMLReader.cpp
   trunk/OpenFDM/src/JSBSim/XMLReader.h
Removed:
   trunk/OpenFDM/src/OpenFDM/XML/Tablereader.cpp
   trunk/OpenFDM/src/OpenFDM/XML/Tablereader.h
   trunk/OpenFDM/src/OpenFDM/XML/XMLReader.cpp
   trunk/OpenFDM/src/OpenFDM/XML/XMLReader.h
Modified:
   trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
   trunk/OpenFDM/src/JSBSim/Makefile.am
   trunk/OpenFDM/src/OpenFDM/Makefile.am
Log:
Move XML code into JSB directory


Modified: trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
===================================================================
--- trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2006-01-22 15:05:40 UTC (rev 216)
+++ trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2006-01-22 15:17:59 UTC (rev 217)
@@ -41,8 +41,8 @@
 #include <OpenFDM/DiscBrake.h>
 
 #include <OpenFDM/ReaderWriter.h>
-#include <OpenFDM/XML/Tablereader.h>
-#include <OpenFDM/XML/XMLReader.h>
+#include "Tablereader.h"
+#include "XMLReader.h"
 
 #include "JSBSimAerosurfaceScale.h"
 #include "JSBSimKinemat.h"

Modified: trunk/OpenFDM/src/JSBSim/Makefile.am
===================================================================
--- trunk/OpenFDM/src/JSBSim/Makefile.am	2006-01-22 15:05:40 UTC (rev 216)
+++ trunk/OpenFDM/src/JSBSim/Makefile.am	2006-01-22 15:17:59 UTC (rev 217)
@@ -13,7 +13,9 @@
   JSBSimAerosurfaceScale.h \
   JSBSimKinemat.h \
   JSBSimScheduledGain.h \
-  LegacyJSBSimReader.h
+  LegacyJSBSimReader.h \
+  Tablereader.h \
+  XMLReader.h
 
 lib_LTLIBRARIES = libJSBReader.la
 libJSBReader_la_SOURCES = \
@@ -21,4 +23,6 @@
   JSBSimAerosurfaceScale.cpp \
   JSBSimKinemat.cpp \
   JSBSimScheduledGain.cpp \
-  LegacyJSBSimReader.cpp
+  LegacyJSBSimReader.cpp \
+  Tablereader.cpp \
+  XMLReader.cpp

Copied: trunk/OpenFDM/src/JSBSim/Tablereader.cpp (from rev 198, trunk/OpenFDM/src/OpenFDM/XML/Tablereader.cpp)

Copied: trunk/OpenFDM/src/JSBSim/Tablereader.h (from rev 198, trunk/OpenFDM/src/OpenFDM/XML/Tablereader.h)

Copied: trunk/OpenFDM/src/JSBSim/XMLReader.cpp (from rev 198, trunk/OpenFDM/src/OpenFDM/XML/XMLReader.cpp)

Copied: trunk/OpenFDM/src/JSBSim/XMLReader.h (from rev 198, trunk/OpenFDM/src/OpenFDM/XML/XMLReader.h)

Modified: trunk/OpenFDM/src/OpenFDM/Makefile.am
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Makefile.am	2006-01-22 15:05:40 UTC (rev 216)
+++ trunk/OpenFDM/src/OpenFDM/Makefile.am	2006-01-22 15:17:59 UTC (rev 217)
@@ -128,9 +128,7 @@
   Vehicle.h \
   WheelContact.h \
   Wind.h \
-  XMLDumpModelVisitor.h \
-  XML/Tablereader.h \
-  XML/XMLReader.h
+  XMLDumpModelVisitor.h
 
 libOpenFDM_la_SOURCES = \
   AeroForce.cpp \
@@ -201,6 +199,4 @@
   Units.cpp \
   Variant.cpp \
   Vehicle.cpp \
-  WheelContact.cpp \
-  XML/Tablereader.cpp \
-  XML/XMLReader.cpp
+  WheelContact.cpp

Deleted: trunk/OpenFDM/src/OpenFDM/XML/Tablereader.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/XML/Tablereader.cpp	2006-01-22 15:05:40 UTC (rev 216)
+++ trunk/OpenFDM/src/OpenFDM/XML/Tablereader.cpp	2006-01-22 15:17:59 UTC (rev 217)
@@ -1,97 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2006 Mathias Froehlich 
- *
- */
-
-#include <iostream>
-
-#include "Tablereader.h"
-
-namespace OpenFDM {
-
-bool
-parseTable1D(std::istream& s, TableData<1>& data, TableLookup& lookup)
-{
-  /// FIXME error handling
-  for (unsigned i = 1; s && i <= data.size(1); ++i) {
-    real_type in = 0;
-    real_type out = 0;
-    s >> in >> out;
-    lookup.setAtIndex(i, in);
-    TableData<1>::Index iv;
-    iv(1) = i;
-    data(iv) = out;
-  }
-  return lookup.isValid() && lookup.size() == data.size(1) && s;
-}
-
-bool
-parseTable2D(std::istream& s, TableData<2>& data, TableLookup lookup[2])
-{
-  /// FIXME error handling
-  for (unsigned j = 1; s && j <= data.size(2); ++j) {
-    real_type in = 0;
-    s >> in;
-    lookup[1].setAtIndex(j, in);
-  }
-
-  if (!lookup[1].isValid() || lookup[1].size() != data.size(2))
-    return false;
-  
-  for (unsigned i = 1; s && i <= data.size(1); ++i) {
-    real_type in = 0;
-    s >> in;
-
-    lookup[0].setAtIndex(i, in);
-
-    for (unsigned j = 1; s && j <= data.size(2); ++j) {
-      real_type out = 0;
-      s >> out;
-
-      TableData<2>::Index iv;
-      iv(1) = i;
-      iv(2) = j;
-      data(iv) = out;
-    }
-  }
-  return lookup[0].isValid() && lookup[0].size() == data.size(1) && s;
-}
-
-bool
-parseTable3D(std::istream& s, TableData<3>& data, TableLookup lookup[3])
-{
-  for (unsigned k = 1; s && k <= data.size(3); ++k) {
-    real_type in = 0;
-    s >> in;
-    lookup[2].setAtIndex(k, in);
-
-    for (unsigned j = 1; s && j <= data.size(2); ++j) {
-      real_type in = 0;
-      s >> in;
-      lookup[1].setAtIndex(j, in);
-    }
-    if (!lookup[1].isValid() || lookup[1].size() != data.size(2))
-      return false;
-    
-    for (unsigned i = 1; s && i <= data.size(1); ++i) {
-      real_type in = 0;
-      s >> in;
-      
-      lookup[0].setAtIndex(i, in);
-      
-      for (unsigned j = 1; s && j <= data.size(2); ++j) {
-        real_type out = 0;
-        s >> out;
-        
-        TableData<3>::Index iv;
-        iv(1) = i;
-        iv(2) = j;
-        iv(3) = k;
-        data(iv) = out;
-      }
-    }
-  }
-  return lookup[0].isValid() && lookup[0].size() == data.size(1) &&
-    lookup[2].isValid() && lookup[2].size() == data.size(3) && s;
-}
-
-} // namespace OpenFDM

Deleted: trunk/OpenFDM/src/OpenFDM/XML/Tablereader.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/XML/Tablereader.h	2006-01-22 15:05:40 UTC (rev 216)
+++ trunk/OpenFDM/src/OpenFDM/XML/Tablereader.h	2006-01-22 15:17:59 UTC (rev 217)
@@ -1,25 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2006 Mathias Froehlich 
- *
- */
-
-#ifndef OpenFDM_Tablereader_H
-#define OpenFDM_Tablereader_H
-
-#include <iosfwd>
-
-#include <OpenFDM/Table.h>
-
-namespace OpenFDM {
-
-bool
-parseTable1D(std::istream& s, TableData<1>& data, TableLookup& lookup);
-
-bool
-parseTable2D(std::istream& s, TableData<2>& data, TableLookup lookup[2]);
-
-bool
-parseTable3D(std::istream& s, TableData<3>& data, TableLookup lookup[3]);
-
-} // namespace OpenFDM
-
-#endif

Deleted: trunk/OpenFDM/src/OpenFDM/XML/XMLReader.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/XML/XMLReader.cpp	2006-01-22 15:05:40 UTC (rev 216)
+++ trunk/OpenFDM/src/OpenFDM/XML/XMLReader.cpp	2006-01-22 15:17:59 UTC (rev 217)
@@ -1,280 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2006 Mathias Froehlich 
- *
- */
-
-#include <string>
-#include <iostream>
-#include <iomanip>
-#include <list>
-#include <map>
-#include <stack>
-
-#include "XMLReader.h"
-
-namespace OpenFDM {
-
-XMLElement::XMLElement(const std::string& name)
-  : mName(name)
-{
-}
-
-XMLElement::~XMLElement(void)
-{
-}
-
-void
-XMLElement::setName(const std::string& name)
-{
-  mName = name;
-}
-
-const std::string&
-XMLElement::getName(void) const
-{
-  return mName;
-}
-
-void
-XMLElement::setAttribute(const std::string& name, const std::string& val)
-{
-  mAttributes[name] = val;
-}
-
-std::string
-XMLElement::getAttribute(const std::string& name) const
-{
-  if (0 < mAttributes.count(name))
-    return mAttributes.find(name)->second;
-  else
-    return std::string();
-}
-
-void
-XMLElement::removeAttribute(const std::string& name)
-{
-  mAttributes.erase(name);
-}
-
-const std::map<std::string,std::string>&
-XMLElement::getAttributes(void) const
-{
-  return mAttributes;
-}
-
-const std::string&
-XMLElement::getData(void) const
-{
-  return mData;
-}
-
-void
-XMLElement::setData(const std::string& data)
-{
-  mData = data;
-}
-
-XMLElement*
-XMLElement::getElement(const std::string& tagName)
-{
-  std::list<pointer>::iterator it = mChildEntities.begin();
-  while (it != mChildEntities.end()) {
-    if ((*it)->mName == tagName) {
-      return *it;
-    }
-    ++it;
-  }
-  return 0;
-}
-
-const XMLElement*
-XMLElement::getElement(const std::string& tagName) const
-{
-  std::list<pointer>::const_iterator it = mChildEntities.begin();
-  while (it != mChildEntities.end()) {
-    if ((*it)->mName == tagName) {
-      return *it;
-    }
-    ++it;
-  }
-  return 0;
-}
-
-unsigned
-XMLElement::getNumElements(const std::string& tagName) const
-{
-  unsigned num = 0;
-  std::list<pointer>::const_iterator it = mChildEntities.begin();
-  while (it != mChildEntities.end()) {
-    if ((*it)->mName == tagName) {
-      ++num;
-    }
-    ++it;
-  }
-  return num;
-}
-
-std::list<XMLElement::const_pointer>
-XMLElement::getElements(const std::string& tagName) const
-{
-  std::list<const_pointer> ret;
-  std::list<pointer>::const_iterator it = mChildEntities.begin();
-  while (it != mChildEntities.end()) {
-    if ((*it)->mName == tagName) {
-      ret.push_back(*it);
-    }
-    ++it;
-  }
-  return ret;
-}
-
-std::list<XMLElement::pointer>
-XMLElement::getElements(const std::string& tagName)
-{
-  std::list<pointer> ret;
-  std::list<pointer>::iterator it = mChildEntities.begin();
-  while (it != mChildEntities.end()) {
-    if ((*it)->mName == tagName) {
-      ret.push_back(*it);
-    }
-    ++it;
-  }
-  return ret;
-}
-
-const std::list<XMLElement::pointer>&
-XMLElement::getElements(void) const
-{
-  return mChildEntities;
-}
-
-void
-XMLElement::appendChild(XMLElement* child)
-{
-  mChildEntities.push_back(child);
-}
-
-XMLElement*
-XMLDocument::getElement(void)
-{
-  return mTop;
-}
-
-const XMLElement*
-XMLDocument::getElement(void) const
-{
-  return mTop;
-}
-
-void
-XMLDocument::setElement(XMLElement* top)
-{
-  mTop = top;
-}
-
-XMLDomParser::XMLDomParser(void)
-{
-}
-
-XMLDomParser::~XMLDomParser(void)
-{
-}
-
-void
-XMLDomParser::startElement(const char *name, const XMLAttributes& atts)
-{
-  XMLElement::pointer element(new XMLElement(name));
-
-  // Set the attributes.
-  int size = atts.size();
-  for (int i = 0; i < size; ++i)
-    element->setAttribute(atts.getName(i), atts.getValue(i));
-
-  // Attach to this tag.
-  if (mElementStack.empty()) {
-    if (mDoc)
-      std::cerr << "Warning more than one toplevel entity!!!" << std::endl;
-    mDoc = XMLDocument::pointer(new XMLDocument);
-    mDoc->setElement(element);
-  } else
-    mElementStack.top()->appendChild(element);
-  
-  // Push on top of the stack.
-  mElementStack.push(element);
-}
-
-void
-XMLDomParser::endElement(const char *name)
-{
-  mElementStack.pop();
-}
-
-void
-XMLDomParser::data(const char *s, int length)
-{
-  mElementStack.top()->mData += std::string(s, length);
-}
-
-bool
-XMLDomParser::parseXML(std::istream& is)
-{
-  bool success = false;
-  try {
-    readXML(is, *this);
-    mErrorMessage = std::string();
-    success = true;
-  } catch (const sg_exception& e) {
-    mErrorMessage = e.getOrigin() + ": " + e.getFormattedMessage();
-  }
-  return success;
-}
-
-const std::string&
-XMLDomParser::getErrorMessage(void) const
-{
-  return mErrorMessage;
-}
-
-static std::ostream&
-printElement(std::ostream& os, XMLElement::const_pointer element, int indent = 0)
-{
-  bool emptyData = element->getData() == "";
-
-  os << '<' << element->getName();
-  std::map<std::string,std::string>::const_iterator
-    mit = element->getAttributes().begin();
-  while (mit != element->getAttributes().end()) {
-    os << ' ' << (*mit).first << "=\"" << (*mit).second << "\"";
-    ++mit;
-  }
-  os << '>';
-
-  if (emptyData)
-    os << std::endl;
-
-  std::list<XMLElement::pointer>::const_iterator
-    it = element->getElements().begin();
-  while (it != element->getElements().end()) {
-    if (emptyData)
-      os << std::setw(indent+2) << "";
-    printElement(os, *it, indent + 2);
-    if (emptyData)
-      os << std::endl;
-    ++it;
-  }
-  
-  if (emptyData)
-    os << std::setw(indent) << "";
-
-  os << element->getData() << "</" << element->getName() << '>';
-
-  return os;
-}
-
-std::ostream&
-operator<<(std::ostream& os, const XMLDocument& doc)
-{
-  os << "<?xml version=\"1.0\"?>" << std::endl;
-  return printElement(os, doc.getElement()) << std::endl;
-}
-
-} // namespace OpenFDM

Deleted: trunk/OpenFDM/src/OpenFDM/XML/XMLReader.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/XML/XMLReader.h	2006-01-22 15:05:40 UTC (rev 216)
+++ trunk/OpenFDM/src/OpenFDM/XML/XMLReader.h	2006-01-22 15:17:59 UTC (rev 217)
@@ -1,111 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2006 Mathias Froehlich 
- *
- */
-
-#ifndef OpenFDM_XMLReader_H
-#define OpenFDM_XMLReader_H
-
-#include <string>
-#include <iostream>
-#include <list>
-#include <stack>
-#include <map>
-
-#include <simgear/xml/easyxml.hxx>
-
-#include <OpenFDM/Object.h>
-
-namespace OpenFDM {
-
-class XMLDomParser;
-
-class XMLElement
-  : public Object {
-public:
-  typedef SharedPtr<XMLElement> pointer;
-  typedef SharedPtr<const XMLElement> const_pointer;
-
-  XMLElement(const std::string& name);
-  virtual ~XMLElement(void);
-
-  void setName(const std::string& name);
-  const std::string& getName(void) const;
-
-  void setAttribute(const std::string& name, const std::string& val);
-  std::string getAttribute(const std::string& name) const;
-  void removeAttribute(const std::string& name);
-  const std::map<std::string,std::string>& getAttributes(void) const;
-
-  const std::string& getData(void) const;
-  void setData(const std::string& data);
-
-  XMLElement* getElement(const std::string& tagName);
-  const XMLElement* getElement(const std::string& tagName) const;
-
-
-  /// Returns the number if child elements with the given tagName.
-  unsigned getNumElements(const std::string& tagName) const;
-
-  std::list<const_pointer> getElements(const std::string& tagName) const;
-
-  std::list<pointer> getElements(const std::string& tagName);
-
-  const std::list<pointer>& getElements(void) const;
-
-  void appendChild(XMLElement* child);
-
-private:
-  std::string mName;
-  std::string mData;
-  std::map<std::string,std::string> mAttributes;
-  std::list<pointer> mChildEntities;
-
-  friend class XMLDomParser;
-};
-
-class XMLDocument
-  : public Object {
-public:
-  typedef SharedPtr<XMLDocument> pointer;
-  typedef SharedPtr<const XMLDocument> const_pointer;
-
-  XMLElement* getElement(void);
-  const XMLElement* getElement(void) const;
-  void setElement(XMLElement* top);
-
-private:
-  SharedPtr<XMLElement> mTop;
-
-  friend class XMLDomParser;
-};
-
-class XMLDomParser
-  : public XMLVisitor {
-public:
-  XMLDomParser(void);
-  virtual ~XMLDomParser(void);
-
-  virtual void startElement(const char *name, const XMLAttributes& atts);
-  virtual void endElement(const char *name);
-  virtual void data(const char *s, int length);
-
-  XMLDocument* getDocument(void)
-  { return mDoc; }
-
-  bool parseXML(std::istream& is);
-
-  const std::string& getErrorMessage(void) const;
-
-private:
-  SharedPtr<XMLDocument> mDoc;
-  std::stack<XMLElement::pointer> mElementStack;
-
-  std::string mErrorMessage;
-};
-
-std::ostream&
-operator<<(std::ostream& os, const XMLDocument& doc);
-
-} // namespace OpenFDM
-
-#endif



From frohlich at berlios.de  Sun Jan 22 19:50:05 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Sun, 22 Jan 2006 19:50:05 +0100
Subject: [OpenFDM-svn] r218 - in trunk/OpenFDM: . src src/JSBSim src/OpenFDM src/OpenFDM/XML
Message-ID: <200601221850.k0MIo5rs003226@sheep.berlios.de>

Author: frohlich
Date: 2006-01-22 19:49:31 +0100 (Sun, 22 Jan 2006)
New Revision: 218

Added:
   trunk/OpenFDM/src/OpenFDM/XML/Attributes.cpp
   trunk/OpenFDM/src/OpenFDM/XML/Attributes.h
   trunk/OpenFDM/src/OpenFDM/XML/ContentHandler.cpp
   trunk/OpenFDM/src/OpenFDM/XML/ContentHandler.h
   trunk/OpenFDM/src/OpenFDM/XML/EasyXMLReader.cpp
   trunk/OpenFDM/src/OpenFDM/XML/EasyXMLReader.h
   trunk/OpenFDM/src/OpenFDM/XML/ErrorHandler.cpp
   trunk/OpenFDM/src/OpenFDM/XML/ErrorHandler.h
   trunk/OpenFDM/src/OpenFDM/XML/ExpatXMLReader.cpp
   trunk/OpenFDM/src/OpenFDM/XML/ExpatXMLReader.h
   trunk/OpenFDM/src/OpenFDM/XML/Makefile.am
   trunk/OpenFDM/src/OpenFDM/XML/XMLReader.cpp
   trunk/OpenFDM/src/OpenFDM/XML/XMLReader.h
Removed:
   trunk/OpenFDM/src/OpenFDM/config.h.in
Modified:
   trunk/OpenFDM/configure.ac
   trunk/OpenFDM/src/JSBSim/Makefile.am
   trunk/OpenFDM/src/Makefile.am
   trunk/OpenFDM/src/OpenFDM/Makefile.am
   trunk/OpenFDM/src/OpenFDM/OpenFDMConfig.h.in
Log:
A subset of a SAX2 infrastructure


Modified: trunk/OpenFDM/configure.ac
===================================================================
--- trunk/OpenFDM/configure.ac	2006-01-22 15:17:59 UTC (rev 217)
+++ trunk/OpenFDM/configure.ac	2006-01-22 18:49:31 UTC (rev 218)
@@ -42,18 +42,54 @@
 ]
 AC_SUBST(enable_range_checking)
 
+dnl Since OpenFDM is c++ ...
+AC_LANG_PUSH(C++)
+
 dnl Check for headers and symbols required for better speaking backtraces ...
 AC_CHECK_HEADERS([execinfo.h cxxabi.h])
 AC_CHECK_FUNCS([backtrace backtrace_symbols])
 
-AM_CONFIG_HEADER([src/OpenFDM/config.h])
+dnl Choice of used xml parsers
+dnl Check for expat
+AC_CHECK_HEADERS([expat.h],
+  [AC_CHECK_LIB([expat],[XML_ExpatVersion],
+     [openfdm_expat_enabled="1"])
+  ])
+AC_CHECK_FUNC([XML_SetSkippedEntityHandler])
+AM_CONDITIONAL([ENABLE_EXPAT], [test "x$openfdm_expat_enabled" = "x1"])
+AC_SUBST(openfdm_expat_enabled)
 
+dnl Check for SimGear and easyxml
+AC_CHECK_HEADERS([simgear/xml/easyxml.hxx],[openfdm_easyxml_enabled="1"])
+AM_CONDITIONAL([ENABLE_EASYXML], [test "x$openfdm_easyxml_enabled" = "x1"])
+AC_SUBST(openfdm_easyxml_enabled)
+
+dnl Check for libxml2 - this is the prefered one, since it does validation
+dnl not yet implemented
+AM_CONDITIONAL([ENABLE_LIBXML2], [test "x$openfdm_libxml2_enabled" = "x1"])
+AC_SUBST(openfdm_libxml2_enabled)
+
+dnl simple check for qt4
+AC_CHECK_HEADERS([Qt/QtGlobal],[openfdm_have_qt4="yes"])
+dnl simple check for osg
+AC_CHECK_HEADERS([osg/Object],[openfdm_have_osg="yes"])
+dnl avoid trying to build the editor if qt4 or osg is missing
+if test "x$openfdm_have_qt4" = "xyes" && test "x$openfdm_have_osg" = "xyes"
+then
+  openfdm_builder_enabled="yes"
+else
+  openfdm_builder_enabled="no"
+fi
+AM_CONDITIONAL([ENABLE_BUILDER], [test "x$openfdm_builder_enabled" = "xyes"])
+
 dnl write makefiles and config.h
+AM_CONFIG_HEADER([src/OpenFDM/config.h])
 AC_OUTPUT([
   src/OpenFDM/OpenFDMConfig.h
   Makefile
   src/Makefile
   src/OpenFDM/Makefile
+  src/OpenFDM/XML/Makefile
   src/JSBSim/Makefile
   src/builder/Makefile
   share/Makefile

Modified: trunk/OpenFDM/src/JSBSim/Makefile.am
===================================================================
--- trunk/OpenFDM/src/JSBSim/Makefile.am	2006-01-22 15:17:59 UTC (rev 217)
+++ trunk/OpenFDM/src/JSBSim/Makefile.am	2006-01-22 18:49:31 UTC (rev 218)
@@ -26,3 +26,4 @@
   LegacyJSBSimReader.cpp \
   Tablereader.cpp \
   XMLReader.cpp
+libJSBReader_la_LIBADD = -lsgxml -lsgstructure

Modified: trunk/OpenFDM/src/Makefile.am
===================================================================
--- trunk/OpenFDM/src/Makefile.am	2006-01-22 15:17:59 UTC (rev 217)
+++ trunk/OpenFDM/src/Makefile.am	2006-01-22 18:49:31 UTC (rev 218)
@@ -1 +1,4 @@
-SUBDIRS = OpenFDM JSBSim builder
+SUBDIRS = OpenFDM JSBSim
+if ENABLE_BUILDER
+SUBDIRS += builder
+endif

Modified: trunk/OpenFDM/src/OpenFDM/Makefile.am
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Makefile.am	2006-01-22 15:17:59 UTC (rev 217)
+++ trunk/OpenFDM/src/OpenFDM/Makefile.am	2006-01-22 18:49:31 UTC (rev 218)
@@ -1,3 +1,4 @@
+SUBDIRS = XML
 
 INCLUDES = -I$(srcdir)/..
 
@@ -19,7 +20,6 @@
 lib_LTLIBRARIES = libOpenFDM.la
 
 # Will need these at the moment ...
-libOpenFDM_la_LIBADD = -lsgxml -lsgstructure
 nobase_OpenFDMinclude_HEADERS = \
   AeroForce.h \
   AirSpring.h \

Modified: trunk/OpenFDM/src/OpenFDM/OpenFDMConfig.h.in
===================================================================
--- trunk/OpenFDM/src/OpenFDM/OpenFDMConfig.h.in	2006-01-22 15:17:59 UTC (rev 217)
+++ trunk/OpenFDM/src/OpenFDM/OpenFDMConfig.h.in	2006-01-22 18:49:31 UTC (rev 218)
@@ -1,4 +1,10 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2006 Mathias Froehlich 
+ *
+ */
 
+#ifndef OpenFDM_Config_H
+#define OpenFDM_Config_H
+
 #ifdef OpenFDM_ENABLE_DEBUG
 #undef OpenFDM_ENABLE_DEBUG
 #endif
@@ -8,3 +14,20 @@
 #undef OpenFDM_ENABLE_RANGE_CHECKING
 #endif
 #define OpenFDM_ENABLE_RANGE_CHECKING @enable_range_checking@
+
+#ifdef OpenFDM_HAVE_EXPAT_XMLREADER
+#undef OpenFDM_HAVE_EXPAT_XMLREADER
+#endif
+#define OpenFDM_HAVE_EXPAT_XMLREADER @openfdm_expat_enabled@
+
+#ifdef OpenFDM_HAVE_EASYXML_XMLREADER
+#undef OpenFDM_HAVE_EASYXML_XMLREADER
+#endif
+#define OpenFDM_HAVE_EASYXML_XMLREADER @openfdm_easyxml_enabled@
+
+#ifdef OpenFDM_HAVE_LIBXML2_XMLREADER
+#undef OpenFDM_HAVE_LIBXML2_XMLREADER
+#endif
+#define OpenFDM_HAVE_LIBXML2_XMLREADER @openfdm_libxml2_enabled@
+
+#endif

Added: trunk/OpenFDM/src/OpenFDM/XML/Attributes.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/XML/Attributes.cpp	2006-01-22 15:17:59 UTC (rev 217)
+++ trunk/OpenFDM/src/OpenFDM/XML/Attributes.cpp	2006-01-22 18:49:31 UTC (rev 218)
@@ -0,0 +1,15 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2006 Mathias Froehlich 
+ *
+ */
+
+#include "Attributes.h"
+
+namespace OpenFDM {
+namespace XML {
+
+Attributes::~Attributes(void)
+{
+}
+
+} // namespace XML
+} // namespace OpenFDM


Property changes on: trunk/OpenFDM/src/OpenFDM/XML/Attributes.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/OpenFDM/src/OpenFDM/XML/Attributes.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/XML/Attributes.h	2006-01-22 15:17:59 UTC (rev 217)
+++ trunk/OpenFDM/src/OpenFDM/XML/Attributes.h	2006-01-22 18:49:31 UTC (rev 218)
@@ -0,0 +1,44 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2006 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_XML_Attributes_H
+#define OpenFDM_XML_Attributes_H
+
+namespace OpenFDM {
+namespace XML {
+
+enum Type {
+  CDATA,
+  ID,
+  IDREF,
+  IDREFS,
+  NMTOKEN,
+  NMTOKENS,
+  ENTITY,
+  ENTITIES,
+  NOTATION
+};
+
+class Attributes {
+public:
+  virtual ~Attributes(void);
+
+  virtual int getIndex(const char* qName) const = 0;
+//   virtual int getIndex(const char* uri, const char* localName) = 0;
+  virtual int getLength(void) const = 0;
+  virtual const char* getLocalName(int index) const = 0;
+//   virtual const char* getQName(int index) const = 0;
+  virtual Type getType(int index) const = 0;
+  virtual Type getType(const char* qName) const = 0;
+//   virtual Type getType(const char* uri, const char* localName) const = 0;
+//   virtual const char* getURI(int index) const = 0;
+  virtual const char* getValue(int index) const = 0;
+  virtual const char* getValue(const char* qName) const = 0;
+//   virtual const char* getValue(const char* uri, const char* localName) const = 0;
+};
+
+} // namespace XML
+} // namespace OpenFDM
+
+#endif


Property changes on: trunk/OpenFDM/src/OpenFDM/XML/Attributes.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/OpenFDM/src/OpenFDM/XML/ContentHandler.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/XML/ContentHandler.cpp	2006-01-22 15:17:59 UTC (rev 217)
+++ trunk/OpenFDM/src/OpenFDM/XML/ContentHandler.cpp	2006-01-22 18:49:31 UTC (rev 218)
@@ -0,0 +1,56 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2006 Mathias Froehlich 
+ *
+ */
+
+#include "ContentHandler.h"
+
+namespace OpenFDM {
+namespace XML {
+
+ContentHandler::~ContentHandler(void)
+{
+}
+
+void
+ContentHandler::characters(const char* data, unsigned length)
+{
+}
+
+void
+ContentHandler::comment(const char* commentData, unsigned length)
+{
+}
+
+void
+ContentHandler::startDocument(void)
+{
+}
+
+void
+ContentHandler::endDocument(void)
+{
+}
+
+void
+ContentHandler::startElement(const char*, const char*, const char*,
+                             const Attributes*)
+{
+}
+
+void
+ContentHandler::endElement(const char*, const char*, const char*)
+{
+}
+
+void
+ContentHandler::skippedEntity(const char* name)
+{
+}
+
+void
+ContentHandler::processingInstruction(const char*, const char*)
+{
+}
+
+} // namespace XML
+} // namespace OpenFDM


Property changes on: trunk/OpenFDM/src/OpenFDM/XML/ContentHandler.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/OpenFDM/src/OpenFDM/XML/ContentHandler.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/XML/ContentHandler.h	2006-01-22 15:17:59 UTC (rev 217)
+++ trunk/OpenFDM/src/OpenFDM/XML/ContentHandler.h	2006-01-22 18:49:31 UTC (rev 218)
@@ -0,0 +1,44 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2006 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_XML_ContentHandler_H
+#define OpenFDM_XML_ContentHandler_H
+
+#include <OpenFDM/Referenced.h>
+
+namespace OpenFDM {
+namespace XML {
+
+class Attributes;
+
+class ContentHandler : public Referenced {
+public:
+  virtual ~ContentHandler(void);
+
+  virtual void characters(const char* data, unsigned length);
+/*   virtual void ignorableWhitespace(const char* data, unsigned length); */
+
+  virtual void comment(const char* commentData, unsigned length);
+
+  virtual void startDocument(void);
+  virtual void endDocument(void);
+
+  virtual void startElement(const char* uri, const char* localName,
+                            const char* qName, const Attributes* atts);
+  virtual void endElement(const char* uri, const char* localName,
+                          const char* qName);
+
+  virtual void skippedEntity(const char* name);
+  virtual void processingInstruction(const char* target, const char* data);
+
+//   virtual void startPrefixMapping(const char* prefix, const char* uri);
+//   virtual void endPrefixMapping(const char* prefix);
+
+//   virtual void setDocumentLocator(Locator locator);
+};
+
+} // namespace XML
+} // namespace OpenFDM
+
+#endif


Property changes on: trunk/OpenFDM/src/OpenFDM/XML/ContentHandler.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/OpenFDM/src/OpenFDM/XML/EasyXMLReader.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/XML/EasyXMLReader.cpp	2006-01-22 15:17:59 UTC (rev 217)
+++ trunk/OpenFDM/src/OpenFDM/XML/EasyXMLReader.cpp	2006-01-22 18:49:31 UTC (rev 218)
@@ -0,0 +1,158 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2006 Mathias Froehlich 
+ *
+ */
+
+#include <simgear/xml/easyxml.hxx>
+#include "EasyXMLReader.h"
+
+namespace OpenFDM {
+namespace XML {
+
+class EasyXMLAttributes : public Attributes {
+public:
+  EasyXMLAttributes(const XMLAttributes* atts);
+  virtual int getIndex(const char* qName) const;
+  virtual int getLength(void) const;
+  virtual const char* getLocalName(int index) const;
+  virtual Type getType(int) const;
+  virtual Type getType(const char*) const;
+  virtual const char* getValue(int index) const;
+  virtual const char* getValue(const char* qName) const;
+private:
+  const XMLAttributes* mAtts;
+};
+
+EasyXMLAttributes::EasyXMLAttributes(const XMLAttributes* atts) : mAtts(atts)
+{
+}
+
+int
+EasyXMLAttributes::getIndex(const char* qName) const
+{
+  return mAtts->findAttribute(qName);
+}
+
+int
+EasyXMLAttributes::getLength(void) const
+{
+  return mAtts->size();
+}
+
+const char*
+EasyXMLAttributes::getLocalName(int index) const
+{
+  return mAtts->getName(index);
+}
+
+Type
+EasyXMLAttributes::getType(int) const
+{
+  return CDATA;
+}
+
+Type
+EasyXMLAttributes::getType(const char*) const
+{
+  return CDATA;
+}
+
+const char*
+EasyXMLAttributes::getValue(int index) const
+{
+  return mAtts->getValue(index);
+}
+
+const char*
+EasyXMLAttributes::getValue(const char* qName) const
+{
+  return mAtts->getValue(qName);
+}
+
+class EasyXMLVisitor : public XMLVisitor {
+public:
+  EasyXMLVisitor(SharedPtr<ContentHandler> contentHandler,
+                 SharedPtr<ErrorHandler> errorHandler) :
+    mContentHandler(contentHandler),
+    mErrorHandler(errorHandler)
+  {}
+  virtual ~EasyXMLVisitor(void) {}
+
+  virtual void startXML()
+  {
+    if (!mContentHandler)
+      return;
+    mContentHandler->startDocument();
+  }
+  virtual void endXML()
+  {
+    if (!mContentHandler)
+      return;
+    mContentHandler->endDocument();
+  }
+
+  virtual void startElement(const char *name, const XMLAttributes& atts)
+  {
+    if (!mContentHandler)
+      return;
+    EasyXMLAttributes eAtts(&atts);
+    mContentHandler->startElement("", name, name, &eAtts);
+  }
+  virtual void endElement(const char *name)
+  {
+    if (!mContentHandler)
+      return;
+    mContentHandler->endElement("", name, name);
+  }
+  virtual void data(const char *s, int length)
+  {
+    if (!mContentHandler)
+      return;
+    mContentHandler->characters(s, length);
+  }
+  virtual void pi(const char * target, const char * data)
+  {
+    if (!mContentHandler)
+      return;
+    mContentHandler->processingInstruction(target, data);
+  }
+  virtual void warning (const char * message, int line, int column)
+  {
+    if (!mErrorHandler)
+      return;
+    mErrorHandler->warning(message, line, column);
+  }
+
+private:
+  SharedPtr<ContentHandler> mContentHandler;
+  SharedPtr<ErrorHandler> mErrorHandler;
+};
+
+
+EasyXMLReader::EasyXMLReader(void)
+{
+}
+
+EasyXMLReader::~EasyXMLReader(void)
+{
+}
+
+void
+EasyXMLReader::parse(std::istream& stream)
+{
+  try {
+    const ErrorHandler* eh = mErrorHandler;
+    const ContentHandler* ch = mContentHandler;
+    EasyXMLVisitor easyXMLVisitor(const_cast<ContentHandler*>(ch),
+                                  const_cast<ErrorHandler*>(eh));
+    readXML(stream, easyXMLVisitor);
+  } catch (const sg_exception& e) {
+    if (mErrorHandler) {
+      std::string error = e.getOrigin() + ": " + e.getFormattedMessage();
+      const ErrorHandler* eh = mErrorHandler;
+      const_cast<ErrorHandler*>(eh)->error(error.c_str(), 0, 0);
+    }
+  }
+}
+
+} // namespace XML
+} // namespace OpenFDM


Property changes on: trunk/OpenFDM/src/OpenFDM/XML/EasyXMLReader.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/OpenFDM/src/OpenFDM/XML/EasyXMLReader.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/XML/EasyXMLReader.h	2006-01-22 15:17:59 UTC (rev 217)
+++ trunk/OpenFDM/src/OpenFDM/XML/EasyXMLReader.h	2006-01-22 18:49:31 UTC (rev 218)
@@ -0,0 +1,19 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2006 Mathias Froehlich 
+ *
+ */
+
+#include "XMLReader.h"
+
+namespace OpenFDM {
+namespace XML {
+
+class EasyXMLReader : public XMLReader {
+public:
+  EasyXMLReader(void);
+  virtual ~EasyXMLReader(void);
+  // returns bool instead of void to signal errors
+  virtual void parse(std::istream& stream);
+};
+
+} // namespace XML
+} // namespace OpenFDM


Property changes on: trunk/OpenFDM/src/OpenFDM/XML/EasyXMLReader.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/OpenFDM/src/OpenFDM/XML/ErrorHandler.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/XML/ErrorHandler.cpp	2006-01-22 15:17:59 UTC (rev 217)
+++ trunk/OpenFDM/src/OpenFDM/XML/ErrorHandler.cpp	2006-01-22 18:49:31 UTC (rev 218)
@@ -0,0 +1,30 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2006 Mathias Froehlich 
+ *
+ */
+
+#include "ErrorHandler.h"
+
+namespace OpenFDM {
+namespace XML {
+
+ErrorHandler::~ErrorHandler(void)
+{
+}
+
+void
+ErrorHandler::error(const char* msg, unsigned line, unsigned col)
+{
+}
+
+void
+ErrorHandler::fatalError(const char* msg, unsigned line, unsigned col)
+{
+}
+
+void
+ErrorHandler::warning(const char* msg, unsigned line, unsigned col)
+{
+}
+
+} // namespace XML
+} // namespace OpenFDM


Property changes on: trunk/OpenFDM/src/OpenFDM/XML/ErrorHandler.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/OpenFDM/src/OpenFDM/XML/ErrorHandler.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/XML/ErrorHandler.h	2006-01-22 15:17:59 UTC (rev 217)
+++ trunk/OpenFDM/src/OpenFDM/XML/ErrorHandler.h	2006-01-22 18:49:31 UTC (rev 218)
@@ -0,0 +1,24 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2006 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_XML_ErrorHandler_H
+#define OpenFDM_XML_ErrorHandler_H
+
+#include <OpenFDM/Referenced.h>
+
+namespace OpenFDM {
+namespace XML {
+
+class ErrorHandler : public Referenced {
+public:
+  virtual ~ErrorHandler(void);
+  virtual void error(const char* msg, unsigned line, unsigned col);
+  virtual void fatalError(const char* msg, unsigned line, unsigned col);
+  virtual void warning(const char* msg, unsigned line, unsigned col);
+};
+
+} // namespace XML
+} // namespace OpenFDM
+
+#endif


Property changes on: trunk/OpenFDM/src/OpenFDM/XML/ErrorHandler.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/OpenFDM/src/OpenFDM/XML/ExpatXMLReader.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/XML/ExpatXMLReader.cpp	2006-01-22 15:17:59 UTC (rev 217)
+++ trunk/OpenFDM/src/OpenFDM/XML/ExpatXMLReader.cpp	2006-01-22 18:49:31 UTC (rev 218)
@@ -0,0 +1,214 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2006 Mathias Froehlich 
+ *
+ */
+
+#include <iostream>
+#include <expat.h>
+#include "ExpatXMLReader.h"
+
+namespace OpenFDM {
+namespace XML {
+
+class ExpatXMLAttributes : public Attributes {
+public:
+  ExpatXMLAttributes(const char**atts);
+  virtual int getIndex(const char* qName) const;
+  virtual int getLength(void) const;
+  virtual const char* getLocalName(int index) const;
+  virtual Type getType(int) const;
+  virtual Type getType(const char*) const;
+  virtual const char* getValue(int index) const;
+  virtual const char* getValue(const char* qName) const;
+private:
+  unsigned mLength;
+  const char** mAtts;
+};
+
+ExpatXMLAttributes::ExpatXMLAttributes(const char ** atts) :
+  mLength(0), mAtts(atts)
+{
+  for (unsigned i = 0; mAtts[i] != 0; i += 2)
+    ++mLength;
+}
+
+int
+ExpatXMLAttributes::getIndex(const char* qName) const
+{
+  for (unsigned i = 0; mAtts[i] != 0; i += 2) {
+    if (strcmp(mAtts[i*2], qName) == 0)
+      return i;
+  }
+  return -1;
+}
+
+int
+ExpatXMLAttributes::getLength(void) const
+{
+  return mLength;
+}
+
+const char*
+ExpatXMLAttributes::getLocalName(int index) const
+{
+  return (index < mLength) ? mAtts[index*2] : 0;
+}
+
+Type
+ExpatXMLAttributes::getType(int) const
+{
+  return CDATA; /*FIXME*/
+}
+
+Type
+ExpatXMLAttributes::getType(const char*) const
+{
+  return CDATA; /*FIXME*/
+}
+
+const char*
+ExpatXMLAttributes::getValue(int index) const
+{
+  return (index < mLength) ? mAtts[index*2+1] : 0;
+}
+
+const char*
+ExpatXMLAttributes::getValue(const char* qName) const
+{
+  for (unsigned i = 0; mAtts[i] != 0; i += 2) {
+    if (strcmp(mAtts[i*2], qName) == 0)
+      return mAtts[i*2+1];
+  }
+  return 0;
+}
+
+static inline ContentHandler*
+userDataToContentHandler(void* userData)
+{
+  ExpatXMLReader* reader = static_cast<ExpatXMLReader*>(userData);
+  if (!reader)
+    return 0;
+  ContentHandler* contentHandler = reader->getContentHandler();
+  return contentHandler;
+}
+
+static void
+ExpatStartElement(void* userData, const char* name, const char** atts)
+{
+  ContentHandler* contentHandler = userDataToContentHandler(userData);
+  ExpatXMLAttributes eAtts(atts);
+  if (contentHandler)
+    contentHandler->startElement("", name, name, &eAtts);
+}
+
+static void
+ExpatEndElement(void* userData, const char* name)
+{
+  ContentHandler* contentHandler = userDataToContentHandler(userData);
+  if (contentHandler)
+    contentHandler->endElement("", name, name);
+}
+
+static void
+ExpatCharacterData(void* userData, const char* data, int length)
+{
+  ContentHandler* contentHandler = userDataToContentHandler(userData);
+  if (contentHandler)
+    contentHandler->characters(data, length);
+}
+
+static void
+ExpatComment(void* userData, const char* data)
+{
+  ContentHandler* contentHandler = userDataToContentHandler(userData);
+  if (contentHandler)
+    contentHandler->comment(data, strlen(data));
+}
+
+#ifdef HAVE_XML_SETSKIPPEDENTITYHANDLER
+static void
+ExpatSkippedEntity(void *userData, const char *entityName, int)
+{
+  ContentHandler* contentHandler = userDataToContentHandler(userData);
+  if (contentHandler)
+    contentHandler->skippedEntity(entityName);
+}
+#endif
+
+static void
+ExpatProcessingInstructions(void* userData, const char* target, const char* data)
+{
+  ContentHandler* contentHandler = userDataToContentHandler(userData);
+  if (contentHandler)
+    contentHandler->processingInstruction(target, data);
+}
+
+ExpatXMLReader::ExpatXMLReader(void)
+{
+}
+
+ExpatXMLReader::~ExpatXMLReader(void)
+{
+}
+
+void
+ExpatXMLReader::parse(std::istream& stream)
+{
+  XML_Parser parser = XML_ParserCreate(0);
+//   XML_Parser parser = XML_ParserCreateNS(0, ':');
+  XML_SetUserData(parser, this);
+  XML_SetElementHandler(parser, ExpatStartElement, ExpatEndElement);
+  XML_SetCharacterDataHandler(parser, ExpatCharacterData);
+  XML_SetProcessingInstructionHandler(parser, ExpatProcessingInstructions);
+  XML_SetCommentHandler(parser, ExpatComment);
+#ifdef HAVE_XML_SETSKIPPEDENTITYHANDLER
+  XML_SetSkippedEntityHandler(parser, ExpatSkippedEntity);
+#endif
+
+  if (mContentHandler)
+    mContentHandler->startDocument();
+
+  unsigned bufSize = 32*1024;
+  char* buf = new char[bufSize];
+  while (!stream.eof()) {
+    if (!stream.good()) {
+      if (mErrorHandler)
+        mErrorHandler->fatalError("ExpatXMLReader: "
+                                  "Can not read from input stream",
+                                  XML_GetCurrentLineNumber(parser),
+                                  XML_GetCurrentColumnNumber(parser));
+      XML_ParserFree(parser);
+      delete [] buf;
+      return;
+    }
+
+    stream.read(buf, bufSize);
+    if (!XML_Parse(parser, buf, stream.gcount(), false)) {
+      if (mErrorHandler)
+        mErrorHandler->fatalError("ExpatXMLReader: Error from Parser",
+                                  XML_GetCurrentLineNumber(parser),
+                                  XML_GetCurrentColumnNumber(parser));
+      XML_ParserFree(parser);
+      delete [] buf;
+      return;
+    }
+  }
+
+  if (!XML_Parse(parser, buf, 0, true)) {
+    if (mErrorHandler)
+      mErrorHandler->fatalError("ExpatXMLReader: Error from Parser",
+                                XML_GetCurrentLineNumber(parser),
+                                XML_GetCurrentColumnNumber(parser));
+    XML_ParserFree(parser);
+    delete [] buf;
+    return;
+  }
+
+  XML_ParserFree(parser);
+  delete [] buf;
+
+  if (mContentHandler)
+    mContentHandler->endDocument();
+}
+
+} // namespace XML
+} // namespace OpenFDM


Property changes on: trunk/OpenFDM/src/OpenFDM/XML/ExpatXMLReader.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/OpenFDM/src/OpenFDM/XML/ExpatXMLReader.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/XML/ExpatXMLReader.h	2006-01-22 15:17:59 UTC (rev 217)
+++ trunk/OpenFDM/src/OpenFDM/XML/ExpatXMLReader.h	2006-01-22 18:49:31 UTC (rev 218)
@@ -0,0 +1,19 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2006 Mathias Froehlich 
+ *
+ */
+
+#include "XMLReader.h"
+
+namespace OpenFDM {
+namespace XML {
+
+class ExpatXMLReader : public XMLReader {
+public:
+  ExpatXMLReader(void);
+  virtual ~ExpatXMLReader(void);
+  // returns bool instead of void to signal errors
+  virtual void parse(std::istream& stream);
+};
+
+} // namespace XML
+} // namespace OpenFDM


Property changes on: trunk/OpenFDM/src/OpenFDM/XML/ExpatXMLReader.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/OpenFDM/src/OpenFDM/XML/Makefile.am
===================================================================
--- trunk/OpenFDM/src/OpenFDM/XML/Makefile.am	2006-01-22 15:17:59 UTC (rev 217)
+++ trunk/OpenFDM/src/OpenFDM/XML/Makefile.am	2006-01-22 18:49:31 UTC (rev 218)
@@ -0,0 +1,47 @@
+INCLUDES = -I$(srcdir)/../..
+
+OpenFDMXMLincludedir = $(includedir)/OpenFDM/XML
+
+lib_LTLIBRARIES = libOpenFDMXML.la
+
+nobase_OpenFDMXMLinclude_HEADERS = \
+  Attributes.h \
+  ContentHandler.h \
+  ErrorHandler.h \
+  XMLReader.h
+
+libOpenFDMXML_la_SOURCES = \
+  Attributes.cpp \
+  ContentHandler.cpp \
+  ErrorHandler.cpp \
+  XMLReader.cpp
+
+if ENABLE_EXPAT
+
+lib_LTLIBRARIES += libOpenFDMexpatXML.la
+
+nobase_OpenFDMXMLinclude_HEADERS += ExpatXMLReader.h
+libOpenFDMexpatXML_la_SOURCES = ExpatXMLReader.cpp
+libOpenFDMexpatXML_la_LIBADD = -lexpat libOpenFDMXML.la
+
+endif
+
+if ENABLE_EASYXML
+
+lib_LTLIBRARIES += libOpenFDMeasyxmlXML.la
+
+nobase_OpenFDMXMLinclude_HEADERS += EasyXMLReader.h
+libOpenFDMeasyxmlXML_la_SOURCES = EasyXMLReader.cpp
+libOpenFDMeasyxmlXML_la_LIBADD = -lsgxml -lsgstructure libOpenFDMXML.la
+
+endif
+
+if ENABLE_LIBXML2
+
+lib_LTLIBRARIES += libOpenFDMlibxml2XML.la
+
+nobase_OpenFDMXMLinclude_HEADERS += Libxml2XMLReader.h
+libOpenFDMlibxml2XML_la_SOURCES = Libxml2XMLReader.cpp
+libOpenFDMlibxml2XML_la_LIBADD = -lxml2 libOpenFDMXML.la
+
+endif


Property changes on: trunk/OpenFDM/src/OpenFDM/XML/Makefile.am
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/OpenFDM/src/OpenFDM/XML/XMLReader.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/XML/XMLReader.cpp	2006-01-22 15:17:59 UTC (rev 217)
+++ trunk/OpenFDM/src/OpenFDM/XML/XMLReader.cpp	2006-01-22 18:49:31 UTC (rev 218)
@@ -0,0 +1,45 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2006 Mathias Froehlich 
+ *
+ */
+
+#include "XMLReader.h"
+
+namespace OpenFDM {
+namespace XML {
+
+Attributes::~Attributes(void)
+{
+}
+
+XMLReader::~XMLReader(void)
+{
+}
+
+ContentHandler*
+XMLReader::getContentHandler(void) const
+{
+  const ContentHandler* ch = mContentHandler;
+  return const_cast<ContentHandler*>(ch);
+}
+
+void
+XMLReader::setContentHandler(ContentHandler* contentHandler)
+{
+  mContentHandler = contentHandler;
+}
+
+ErrorHandler*
+XMLReader::getErrorHandler(void) const
+{
+  const ErrorHandler* eh = mErrorHandler;
+  return const_cast<ErrorHandler*>(eh);
+}
+
+void
+XMLReader::setErrorHandler(ErrorHandler* errorHandler)
+{
+  mErrorHandler = errorHandler;
+}
+
+} // namespace XML
+} // namespace OpenFDM


Property changes on: trunk/OpenFDM/src/OpenFDM/XML/XMLReader.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/OpenFDM/src/OpenFDM/XML/XMLReader.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/XML/XMLReader.h	2006-01-22 15:17:59 UTC (rev 217)
+++ trunk/OpenFDM/src/OpenFDM/XML/XMLReader.h	2006-01-22 18:49:31 UTC (rev 218)
@@ -0,0 +1,39 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2006 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_XML_XMLReader_H
+#define OpenFDM_XML_XMLReader_H
+
+#include <iosfwd>
+
+#include <OpenFDM/Referenced.h>
+#include <OpenFDM/SharedPtr.h>
+
+#include "Attributes.h"
+#include "ContentHandler.h"
+#include "ErrorHandler.h"
+
+namespace OpenFDM {
+namespace XML {
+
+class XMLReader : public Referenced {
+public:
+  virtual ~XMLReader(void);
+  virtual void parse(std::istream& stream) = 0;
+
+  ContentHandler* getContentHandler(void) const;
+  void setContentHandler(ContentHandler* contentHandler);
+
+  ErrorHandler* getErrorHandler(void) const;
+  void setErrorHandler(ErrorHandler* errorHandler);
+
+protected:
+  SharedPtr<ContentHandler> mContentHandler;
+  SharedPtr<ErrorHandler> mErrorHandler;
+};
+
+} // namespace XML
+} // namespace OpenFDM
+
+#endif


Property changes on: trunk/OpenFDM/src/OpenFDM/XML/XMLReader.h
___________________________________________________________________
Name: svn:eol-style
   + native

Deleted: trunk/OpenFDM/src/OpenFDM/config.h.in
===================================================================
--- trunk/OpenFDM/src/OpenFDM/config.h.in	2006-01-22 15:17:59 UTC (rev 217)
+++ trunk/OpenFDM/src/OpenFDM/config.h.in	2006-01-22 18:49:31 UTC (rev 218)
@@ -1,67 +0,0 @@
-/* src/OpenFDM/config.h.in.  Generated from configure.ac by autoheader.  */
-
-/* Define to 1 if you have the `backtrace' function. */
-#undef HAVE_BACKTRACE
-
-/* Define to 1 if you have the `backtrace_symbols' function. */
-#undef HAVE_BACKTRACE_SYMBOLS
-
-/* Define to 1 if you have the <cxxabi.h> header file. */
-#undef HAVE_CXXABI_H
-
-/* Define to 1 if you have the <dlfcn.h> header file. */
-#undef HAVE_DLFCN_H
-
-/* Define to 1 if you have the <execinfo.h> header file. */
-#undef HAVE_EXECINFO_H
-
-/* Define to 1 if you have the <inttypes.h> header file. */
-#undef HAVE_INTTYPES_H
-
-/* Define to 1 if you have the <memory.h> header file. */
-#undef HAVE_MEMORY_H
-
-/* Define to 1 if you have the <stdint.h> header file. */
-#undef HAVE_STDINT_H
-
-/* Define to 1 if you have the <stdlib.h> header file. */
-#undef HAVE_STDLIB_H
-
-/* Define to 1 if you have the <strings.h> header file. */
-#undef HAVE_STRINGS_H
-
-/* Define to 1 if you have the <string.h> header file. */
-#undef HAVE_STRING_H
-
-/* Define to 1 if you have the <sys/stat.h> header file. */
-#undef HAVE_SYS_STAT_H
-
-/* Define to 1 if you have the <sys/types.h> header file. */
-#undef HAVE_SYS_TYPES_H
-
-/* Define to 1 if you have the <unistd.h> header file. */
-#undef HAVE_UNISTD_H
-
-/* Name of package */
-#undef PACKAGE
-
-/* Define to the address where bug reports for this package should be sent. */
-#undef PACKAGE_BUGREPORT
-
-/* Define to the full name of this package. */
-#undef PACKAGE_NAME
-
-/* Define to the full name and version of this package. */
-#undef PACKAGE_STRING
-
-/* Define to the one symbol short name of this package. */
-#undef PACKAGE_TARNAME
-
-/* Define to the version of this package. */
-#undef PACKAGE_VERSION
-
-/* Define to 1 if you have the ANSI C header files. */
-#undef STDC_HEADERS
-
-/* Version number of package */
-#undef VERSION



From frohlich at berlios.de  Tue Jan 24 20:17:26 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Tue, 24 Jan 2006 20:17:26 +0100
Subject: [OpenFDM-svn] r219 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200601241917.k0OJHQGe030031@sheep.berlios.de>

Author: frohlich
Date: 2006-01-24 20:17:07 +0100 (Tue, 24 Jan 2006)
New Revision: 219

Modified:
   trunk/OpenFDM/src/OpenFDM/Quaternion.h
Log:
Fix quaternion to euler conversion error


Modified: trunk/OpenFDM/src/OpenFDM/Quaternion.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Quaternion.h	2006-01-22 18:49:31 UTC (rev 218)
+++ trunk/OpenFDM/src/OpenFDM/Quaternion.h	2006-01-24 19:17:07 UTC (rev 219)
@@ -112,13 +112,15 @@
     value_type sqrQ3 = q3*q3;
     value_type sqrQ4 = q4*q4;
 
-    value_type tmp = sqrQ1 - sqrQ2 - sqrQ3 + sqrQ4;
-    if (fabs(tmp) < Limits<value_type>::min())
-      angles(1) = pi05;
+    value_type den = sqrQ1 - sqrQ2 - sqrQ3 + sqrQ4;
+    value_type num = 2*(q3*q4 + q1*q2);
+    if (fabs(den) < Limits<value_type>::min() &&
+        fabs(num) < Limits<value_type>::min())
+      angles(1) = 0;
     else
-      angles(1) = atan2(2*(q3*q4 + q1*q2), tmp);
+      angles(1) = atan2(num, den);
     
-    tmp = 2*(q2*q4 - q1*q3);
+    value_type tmp = 2*(q2*q4 - q1*q3);
     if (tmp < -1.0)
       angles(2) = pi05;
     else if (1.0 < tmp)
@@ -126,11 +128,13 @@
     else
       angles(2) = -asin(tmp);
     
-    tmp = sqrQ1 + sqrQ2 - sqrQ3 - sqrQ4;
-    if (fabs(tmp) < Limits<value_type>::min())
-      angles(3) = pi05;
+    den = sqrQ1 + sqrQ2 - sqrQ3 - sqrQ4;
+    num = 2*(q2*q3 + q1*q4);
+    if (fabs(den) < Limits<value_type>::min() &&
+        fabs(num) < Limits<value_type>::min())
+      angles(3) = 0;
     else {
-      value_type psi = atan2(2*(q2*q3 + q1*q4), tmp);
+      value_type psi = atan2(num, den);
       if (psi < 0.0)
         psi += pi2;
       angles(3) = psi;



From frohlich at berlios.de  Fri Jan 27 21:03:11 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Fri, 27 Jan 2006 21:03:11 +0100
Subject: [OpenFDM-svn] r220 - in trunk/OpenFDM: . src/OpenFDM src/OpenFDM/XML
Message-ID: <200601272003.k0RK3BQH002436@sheep.berlios.de>

Author: frohlich
Date: 2006-01-27 21:02:44 +0100 (Fri, 27 Jan 2006)
New Revision: 220

Modified:
   trunk/OpenFDM/configure.ac
   trunk/OpenFDM/src/OpenFDM/Model.h
   trunk/OpenFDM/src/OpenFDM/ModelGroup.cpp
   trunk/OpenFDM/src/OpenFDM/ModelGroup.h
   trunk/OpenFDM/src/OpenFDM/OpenFDMConfig.h.in
   trunk/OpenFDM/src/OpenFDM/XML/ExpatXMLReader.cpp
   trunk/OpenFDM/src/OpenFDM/XML/XMLReader.cpp
Log:
Various small updates


Modified: trunk/OpenFDM/configure.ac
===================================================================
--- trunk/OpenFDM/configure.ac	2006-01-24 19:17:07 UTC (rev 219)
+++ trunk/OpenFDM/configure.ac	2006-01-27 20:02:44 UTC (rev 220)
@@ -53,21 +53,44 @@
 dnl Check for expat
 AC_CHECK_HEADERS([expat.h],
   [AC_CHECK_LIB([expat],[XML_ExpatVersion],
-     [openfdm_expat_enabled="1"])
+     [openfdm_expat_enabled="yes"])
   ])
-AC_CHECK_FUNC([XML_SetSkippedEntityHandler])
-AM_CONDITIONAL([ENABLE_EXPAT], [test "x$openfdm_expat_enabled" = "x1"])
-AC_SUBST(openfdm_expat_enabled)
+save_LIBS=$LIBS
+LIBS=-lexpat
+AC_CHECK_FUNC([XML_SetSkippedEntityHandler],
+              AC_DEFINE([HAVE_XML_SETSKIPPEDENTITYHANDLER], [1],
+                        [Define if expat provides XML_SetSkippedEntityHandler]))
+LIBS=$save_LIBS
+AM_CONDITIONAL([ENABLE_EXPAT], [test "x$openfdm_expat_enabled" = "xyes"])
+if test "x$openfdm_expat_enabled" = "xyes"
+then
+  OpenFDM_HAVE_EXPAT_XMLREADER=1
+else
+  OpenFDM_HAVE_EXPAT_XMLREADER=0
+fi
+AC_SUBST(OpenFDM_HAVE_EXPAT_XMLREADER)
 
 dnl Check for SimGear and easyxml
-AC_CHECK_HEADERS([simgear/xml/easyxml.hxx],[openfdm_easyxml_enabled="1"])
-AM_CONDITIONAL([ENABLE_EASYXML], [test "x$openfdm_easyxml_enabled" = "x1"])
-AC_SUBST(openfdm_easyxml_enabled)
+AC_CHECK_HEADERS([simgear/xml/easyxml.hxx],[openfdm_easyxml_enabled="yes"])
+AM_CONDITIONAL([ENABLE_EASYXML], [test "x$openfdm_easyxml_enabled" = "xyes"])
+if test "x$openfdm_easyxml_enabled" = "xyes"
+then
+  OpenFDM_HAVE_EASYXML_XMLREADER=1
+else
+  OpenFDM_HAVE_EASYXML_XMLREADER=0
+fi
+AC_SUBST(OpenFDM_HAVE_EASYXML_XMLREADER)
 
 dnl Check for libxml2 - this is the prefered one, since it does validation
 dnl not yet implemented
-AM_CONDITIONAL([ENABLE_LIBXML2], [test "x$openfdm_libxml2_enabled" = "x1"])
-AC_SUBST(openfdm_libxml2_enabled)
+AM_CONDITIONAL([ENABLE_LIBXML2], [test "x$openfdm_libxml2_enabled" = "xyes"])
+if test "x$openfdm_libxml2_enabled" = "xyes"
+then
+  OpenFDM_HAVE_LIBXML2_XMLREADER=1
+else
+  OpenFDM_HAVE_LIBXML2_XMLREADER=0
+fi
+AC_SUBST(OpenFDM_HAVE_LIBXML2_XMLREADER)
 
 dnl simple check for qt4
 AC_CHECK_HEADERS([Qt/QtGlobal],[openfdm_have_qt4="yes"])

Modified: trunk/OpenFDM/src/OpenFDM/Model.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Model.h	2006-01-24 19:17:07 UTC (rev 219)
+++ trunk/OpenFDM/src/OpenFDM/Model.h	2006-01-27 20:02:44 UTC (rev 220)
@@ -135,6 +135,9 @@
   Port* getOutputPort(const std::string& name);
   const std::string& getOutputPortName(unsigned i) const;
 
+  const Model* getParent(void) const { return mParentModel; }
+  Model* getParent(void) { return mParentModel; }
+
 protected:
   void setNumContinousStates(unsigned numContinousStates);
   void setNumDiscreteStates(unsigned numDiscreteStates);
@@ -186,8 +189,6 @@
 private:
   // Sets the parent model.
   // That is the one which is informed if the number of states changes.
-  const Model* getParent(void) const { return mParentModel; }
-  Model* getParent(void) { return mParentModel; }
   void setParent(Model* model);
   void adjustNumContinousStates(unsigned newCount, unsigned oldCount);
   void adjustNumDiscreteStates(unsigned newCount, unsigned oldCount);

Modified: trunk/OpenFDM/src/OpenFDM/ModelGroup.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/ModelGroup.cpp	2006-01-24 19:17:07 UTC (rev 219)
+++ trunk/OpenFDM/src/OpenFDM/ModelGroup.cpp	2006-01-27 20:02:44 UTC (rev 220)
@@ -93,6 +93,20 @@
 }
 
 unsigned
+ModelGroup::getModelIndex(const Model* model) const
+{
+  unsigned idx = 0u;
+  ModelList::const_iterator it = mModels.begin();
+  while (it != mModels.end()) {
+    if ((*it) == model)
+      return idx;
+    ++it;
+    ++idx;
+  }
+  return idx;
+}
+
+unsigned
 ModelGroup::addModel(Model* model)
 {
   // cannot add no model ...

Modified: trunk/OpenFDM/src/OpenFDM/ModelGroup.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/ModelGroup.h	2006-01-24 19:17:07 UTC (rev 219)
+++ trunk/OpenFDM/src/OpenFDM/ModelGroup.h	2006-01-27 20:02:44 UTC (rev 220)
@@ -45,6 +45,7 @@
   const Model* getModel(const std::string& name) const;
   Model* getModel(const std::string& name);
   unsigned getModelIndex(const std::string& name) const;
+  unsigned getModelIndex(const Model* model) const;
   unsigned addModel(Model* model);
   void removeModel(Model* model);
 

Modified: trunk/OpenFDM/src/OpenFDM/OpenFDMConfig.h.in
===================================================================
--- trunk/OpenFDM/src/OpenFDM/OpenFDMConfig.h.in	2006-01-24 19:17:07 UTC (rev 219)
+++ trunk/OpenFDM/src/OpenFDM/OpenFDMConfig.h.in	2006-01-27 20:02:44 UTC (rev 220)
@@ -18,16 +18,16 @@
 #ifdef OpenFDM_HAVE_EXPAT_XMLREADER
 #undef OpenFDM_HAVE_EXPAT_XMLREADER
 #endif
-#define OpenFDM_HAVE_EXPAT_XMLREADER @openfdm_expat_enabled@
+#define OpenFDM_HAVE_EXPAT_XMLREADER @OpenFDM_HAVE_EXPAT_XMLREADER@
 
 #ifdef OpenFDM_HAVE_EASYXML_XMLREADER
 #undef OpenFDM_HAVE_EASYXML_XMLREADER
 #endif
-#define OpenFDM_HAVE_EASYXML_XMLREADER @openfdm_easyxml_enabled@
+#define OpenFDM_HAVE_EASYXML_XMLREADER @OpenFDM_HAVE_EASYXML_XMLREADER@
 
 #ifdef OpenFDM_HAVE_LIBXML2_XMLREADER
 #undef OpenFDM_HAVE_LIBXML2_XMLREADER
 #endif
-#define OpenFDM_HAVE_LIBXML2_XMLREADER @openfdm_libxml2_enabled@
+#define OpenFDM_HAVE_LIBXML2_XMLREADER @OpenFDM_HAVE_LIBXML2_XMLREADER@
 
 #endif

Modified: trunk/OpenFDM/src/OpenFDM/XML/ExpatXMLReader.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/XML/ExpatXMLReader.cpp	2006-01-24 19:17:07 UTC (rev 219)
+++ trunk/OpenFDM/src/OpenFDM/XML/ExpatXMLReader.cpp	2006-01-27 20:02:44 UTC (rev 220)
@@ -5,6 +5,7 @@
 #include <iostream>
 #include <expat.h>
 #include "ExpatXMLReader.h"
+#include "config.h"
 
 namespace OpenFDM {
 namespace XML {

Modified: trunk/OpenFDM/src/OpenFDM/XML/XMLReader.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/XML/XMLReader.cpp	2006-01-24 19:17:07 UTC (rev 219)
+++ trunk/OpenFDM/src/OpenFDM/XML/XMLReader.cpp	2006-01-27 20:02:44 UTC (rev 220)
@@ -7,10 +7,6 @@
 namespace OpenFDM {
 namespace XML {
 
-Attributes::~Attributes(void)
-{
-}
-
 XMLReader::~XMLReader(void)
 {
 }



From frohlich at berlios.de  Sat Jan 28 08:06:47 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Sat, 28 Jan 2006 08:06:47 +0100
Subject: [OpenFDM-svn] r221 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200601280706.k0S76lYL015054@sheep.berlios.de>

Author: frohlich
Date: 2006-01-28 08:06:25 +0100 (Sat, 28 Jan 2006)
New Revision: 221

Modified:
   trunk/OpenFDM/src/OpenFDM/Object.h
   trunk/OpenFDM/src/OpenFDM/SharedPtr.h
Log:
Remove bogus constness for SharedPtr and WeakPtr


Modified: trunk/OpenFDM/src/OpenFDM/Object.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Object.h	2006-01-27 20:02:44 UTC (rev 220)
+++ trunk/OpenFDM/src/OpenFDM/Object.h	2006-01-28 07:06:25 UTC (rev 221)
@@ -133,19 +133,14 @@
   WeakPtr& operator=(const WeakPtr<U>& p)
   { assign(p._ptr); return *this; }
 
-  T* operator->(void)
+  T* operator->(void) const
   { return reinterpret_cast<T*>(_ptr); }
-  const T* operator->(void) const
-  { return reinterpret_cast<const T*>(_ptr); }
-  T& operator*(void)
+
+  T& operator*(void) const
   { return *reinterpret_cast<T*>(_ptr); }
-  const T& operator*(void) const
-  { return *reinterpret_cast<const T*>(_ptr); }
 
-  operator T*(void)
+  operator T*(void) const
   { return reinterpret_cast<T*>(_ptr); }
-  operator const T*(void) const
-  { return reinterpret_cast<const T*>(_ptr); }
 
 private:
   template<typename U>

Modified: trunk/OpenFDM/src/OpenFDM/SharedPtr.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/SharedPtr.h	2006-01-27 20:02:44 UTC (rev 220)
+++ trunk/OpenFDM/src/OpenFDM/SharedPtr.h	2006-01-28 07:06:25 UTC (rev 221)
@@ -45,19 +45,14 @@
   SharedPtr& operator=(const WeakPtr<U>& p)
   { assign(p._ptr); return *this; }
 
-  T* operator->(void)
+  T* operator->(void) const
   { return _ptr; }
-  const T* operator->(void) const
-  { return _ptr; }
-  T& operator*(void)
+
+  T& operator*(void) const
   { return *_ptr; }
-  const T& operator*(void) const
-  { return *_ptr; }
 
-  operator T*(void)
+  operator T*(void) const
   { return _ptr; }
-  operator const T*(void) const
-  { return _ptr; }
 
   bool isShared(void) const
   { return Referenced::shared(_ptr); }



From frohlich at berlios.de  Sat Jan 28 11:14:33 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Sat, 28 Jan 2006 11:14:33 +0100
Subject: [OpenFDM-svn] r222 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200601281014.k0SAEXgO020704@sheep.berlios.de>

Author: frohlich
Date: 2006-01-28 11:14:29 +0100 (Sat, 28 Jan 2006)
New Revision: 222

Modified:
   trunk/OpenFDM/src/OpenFDM/Object.cpp
   trunk/OpenFDM/src/OpenFDM/Object.h
   trunk/OpenFDM/src/OpenFDM/SharedPtr.h
Log:
Rework weak ptr's a bit. More to come ...


Modified: trunk/OpenFDM/src/OpenFDM/Object.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Object.cpp	2006-01-28 07:06:25 UTC (rev 221)
+++ trunk/OpenFDM/src/OpenFDM/Object.cpp	2006-01-28 10:14:29 UTC (rev 222)
@@ -8,18 +8,15 @@
 namespace OpenFDM {
 
 Object::Object(const std::string& name) :
-  mName(name)
+  mName(name),
+  mWeakDataPtr(new WeakData(this))
 {
   addStoredProperty("name", Property(this, &Object::getName, &Object::setName));
 }
 
 Object::~Object(void)
 {
-  std::list<Object**>::iterator it = _ptrList.begin();
-  while (it != _ptrList.end()) {
-    *(*it) = 0;
-    ++it;
-  }
+  mWeakDataPtr->object = 0;
 }
 
 const char*
@@ -102,22 +99,4 @@
   mProperties[name].setStoredProperty(true);
 }
 
-void
-Object::reg(Object** mp)
-{
-  _ptrList.push_back(mp);
-}
-
-void
-Object::dereg(Object** mp)
-{
-  std::list<Object**>::iterator it = _ptrList.begin();
-  while (it != _ptrList.end()) {
-    if ((*it) == mp)
-      it = _ptrList.erase(it);
-    else
-      ++it;
-  }
-}
-
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/Object.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Object.h	2006-01-28 07:06:25 UTC (rev 221)
+++ trunk/OpenFDM/src/OpenFDM/Object.h	2006-01-28 10:14:29 UTC (rev 222)
@@ -33,9 +33,7 @@
 
 
 /// The OpenFDM object base class.
-/// Every class 
-class Object :
-    public Referenced {
+class Object : public Referenced {
 public:
   Object(const std::string& name = std::string());
   virtual ~Object(void);
@@ -81,19 +79,27 @@
   Object(const Object&);
   const Object& operator=(const Object&);
 
-  /// Register and deregister a managed reference to this object.
-  void reg(Object** mp);
-  void dereg(Object** mp);
-
   /// The objects name
   std::string mName;
 
   /// The map of all properties of this object.
   PropertyMap mProperties;
 
+  /// Userdata ...
   SharedPtr<Object> mUserData;
 
-  mutable std::list<Object**> _ptrList;
+  /// Support for weak references, not increasing the reference count
+  /// that is done through that small helper class which holds an uncounted
+  /// reference which is zeroed out on destruction of the current object
+  struct WeakData : public Referenced {
+    WeakData(Object* o) : object(o) {}
+    Object* object;
+  private:
+    WeakData(void);
+    WeakData(const WeakData&);
+    WeakData& operator=(const WeakData&);
+  };
+  SharedPtr<WeakData> mWeakDataPtr;
 
   template<typename T>
   friend class SharedPtr;
@@ -105,57 +111,55 @@
 /// FIXME: remove the direct accessors, only copy to a SharedPtr
 /// where you can access then, may be similar to the std::tr2::weak_ptr::lock()
 /// function. That is to avoid deletion of a currently used object
-/// FIXME make const correct ...
 template<typename T>
 class WeakPtr {
 public:
-  WeakPtr(void) : _ptr(0)
+  WeakPtr(void)
   {}
-  WeakPtr(T* ptr) : _ptr(ptr)
-  { reg(); }
-  WeakPtr(const WeakPtr& p) : _ptr(p._ptr)
-  { reg(); }
+  WeakPtr(T* ptr)
+  { assign(ptr); }
+  WeakPtr(const WeakPtr& p) : mWeakDataPtr(p.mWeakDataPtr)
+  { }
   template<typename U>
-  WeakPtr(const SharedPtr<U>& p) : _ptr(p._ptr)
-  { reg(); }
+  WeakPtr(const SharedPtr<U>& p)
+  { assign(p.ptr()); }
   ~WeakPtr(void)
-  { dereg(); }
+  { }
   
   template<typename U>
   WeakPtr& operator=(const SharedPtr<U>& p)
-  { assign(p._ptr); return *this; }
+  { assign(p.ptr()); return *this; }
   template<typename U>
   WeakPtr& operator=(U* p)
   { assign(p); return *this; }
   WeakPtr& operator=(const WeakPtr& p)
-  { assign(p._ptr); return *this; }
-  template<typename U>
-  WeakPtr& operator=(const WeakPtr<U>& p)
-  { assign(p._ptr); return *this; }
+  { mWeakDataPtr = p.mWeakDataPtr; return *this; }
 
   T* operator->(void) const
-  { return reinterpret_cast<T*>(_ptr); }
+  { return ptr(); }
 
   T& operator*(void) const
-  { return *reinterpret_cast<T*>(_ptr); }
+  { return *ptr(); }
 
   operator T*(void) const
-  { return reinterpret_cast<T*>(_ptr); }
+  { return ptr(); }
 
 private:
-  template<typename U>
-  void assign(U* p)
-  { dereg(); _ptr = p; reg(); }
+  Object* objectPtr(void) const
+  { return mWeakDataPtr ? mWeakDataPtr->object : 0; }
+  T* ptr(void) const
+  { return reinterpret_cast<T*>(objectPtr()); }
+  void assign(T* p)
+  {
+    if (p)
+      mWeakDataPtr = p->mWeakDataPtr;
+    else
+      mWeakDataPtr = 0;
+  }
   
-  void reg(void)
-  { if (_ptr) _ptr->reg(&_ptr); }
+  // The indirect reference itself.
+  SharedPtr<Object::WeakData> mWeakDataPtr;
 
-  void dereg(void)
-  { if (_ptr) _ptr->dereg(&_ptr); }
-
-  // The reference itself.
-  Object* _ptr;
-
   template<typename U>
   friend class SharedPtr;
   template<typename U>

Modified: trunk/OpenFDM/src/OpenFDM/SharedPtr.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/SharedPtr.h	2006-01-28 07:06:25 UTC (rev 221)
+++ trunk/OpenFDM/src/OpenFDM/SharedPtr.h	2006-01-28 10:14:29 UTC (rev 222)
@@ -14,22 +14,21 @@
 template<typename T>
 class WeakPtr;
 
-/// FIXME make const correct ...
 template<typename T>
 class SharedPtr {
 public:
   SharedPtr(void) : _ptr(0)
   {}
   SharedPtr(T* ptr) : _ptr(ptr)
-  { get(_ptr); }
+  { Referenced::get(_ptr); }
   SharedPtr(const SharedPtr& p) : _ptr(p._ptr)
-  { get(_ptr); }
+  { Referenced::get(_ptr); }
   template<typename U>
   SharedPtr(const SharedPtr<U>& p) : _ptr(p._ptr)
-  { get(_ptr); }
+  { Referenced::get(_ptr); }
   template<typename U>
-  SharedPtr(const WeakPtr<U>& p) : _ptr(p._ptr)
-  { get(_ptr); }
+  SharedPtr(const WeakPtr<U>& p) : _ptr(p.ptr())
+  { Referenced::get(_ptr); }
   ~SharedPtr(void)
   { put(); }
   
@@ -43,7 +42,7 @@
   { assign(p); return *this; }
   template<typename U>
   SharedPtr& operator=(const WeakPtr<U>& p)
-  { assign(p._ptr); return *this; }
+  { assign(p.ptr()); return *this; }
 
   T* operator->(void) const
   { return _ptr; }
@@ -60,13 +59,12 @@
   { return Referenced::count(_ptr); }
 
 private:
-  template<typename U>
-  void assign(U* p)
-  { get(p); put(); _ptr = p; }
+  T* ptr(void) const
+  { return _ptr; }
 
-  template<typename U>
-  void get(const U* p) const
-  { Referenced::get(p); }
+  void assign(T* p)
+  { Referenced::get(p); put(); _ptr = p; }
+
   void put(void)
   { if (!Referenced::put(_ptr)) { delete _ptr; _ptr = 0; } }
   



From frohlich at berlios.de  Sat Jan 28 16:56:20 2006
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Sat, 28 Jan 2006 16:56:20 +0100
Subject: [OpenFDM-svn] r223 - in trunk/OpenFDM/src: OpenFDM builder
Message-ID: <200601281556.k0SFuKGE020251@sheep.berlios.de>

Author: frohlich
Date: 2006-01-28 16:56:04 +0100 (Sat, 28 Jan 2006)
New Revision: 223

Added:
   trunk/OpenFDM/src/builder/FrameItem.cpp
   trunk/OpenFDM/src/builder/FrameItem.h
   trunk/OpenFDM/src/builder/MainWindow.cpp
   trunk/OpenFDM/src/builder/MainWindow.h
   trunk/OpenFDM/src/builder/ModelItem.cpp
   trunk/OpenFDM/src/builder/ModelItem.h
Modified:
   trunk/OpenFDM/src/OpenFDM/Frame.cpp
   trunk/OpenFDM/src/OpenFDM/Frame.h
   trunk/OpenFDM/src/builder/Makefile.am
   trunk/OpenFDM/src/builder/main.cpp
Log:
Some experiments with qt/interview


Modified: trunk/OpenFDM/src/OpenFDM/Frame.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Frame.cpp	2006-01-28 10:14:29 UTC (rev 222)
+++ trunk/OpenFDM/src/OpenFDM/Frame.cpp	2006-01-28 15:56:04 UTC (rev 223)
@@ -149,6 +149,20 @@
   return mChildFrames[i];
 }
 
+unsigned
+Frame::getChildFrameIndex(const Frame* child) const
+{
+  if (!child)
+    return mChildFrames.size();
+
+  unsigned i = 0;
+  for (; i < mChildFrames.size(); ++i) {
+    if (mChildFrames[i] == child)
+      return i;
+  }
+  return i;
+}
+
 void
 Frame::reparentChildren(Frame* frame)
 {

Modified: trunk/OpenFDM/src/OpenFDM/Frame.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Frame.h	2006-01-28 10:14:29 UTC (rev 222)
+++ trunk/OpenFDM/src/OpenFDM/Frame.h	2006-01-28 15:56:04 UTC (rev 223)
@@ -108,6 +108,8 @@
   Frame* getChildFrame(unsigned i);
   /// Get the i-th child frame. Returns a 0 pointer if i is out of range.
   const Frame* getChildFrame(unsigned i) const;
+  /// Returns the child frame index of the given frame
+  unsigned getChildFrameIndex(const Frame* child) const;
   /// Returns the number of child frames
   unsigned getNumChildFrames(void) const
   { return mChildFrames.size(); }

Added: trunk/OpenFDM/src/builder/FrameItem.cpp
===================================================================
--- trunk/OpenFDM/src/builder/FrameItem.cpp	2006-01-28 10:14:29 UTC (rev 222)
+++ trunk/OpenFDM/src/builder/FrameItem.cpp	2006-01-28 15:56:04 UTC (rev 223)
@@ -0,0 +1,154 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2005-2006 Mathias Froehlich 
+ *
+ */
+
+#include <iostream>
+
+#include <OpenFDM/Frame.h>
+#include "FrameItem.h"
+
+using OpenFDM::Frame;
+
+static Frame* frameFrom(const QModelIndex& index)
+{
+  if (!index.isValid())
+    return 0;
+  return static_cast<Frame*>(index.internalPointer());
+}
+
+FrameItem::FrameItem(QObject* parent) :
+  QAbstractItemModel(parent)
+{
+}
+
+FrameItem::~FrameItem(void)
+{
+}
+
+QModelIndex
+FrameItem::index(int row, int column, const QModelIndex &parent) const
+{
+  if (!parent.isValid()) {
+    if (!mRootFrame)
+      return QModelIndex();
+    if (row != 0)
+      return QModelIndex();
+
+    return createIndex(row, 0, mRootFrame);
+  }
+
+  Frame* frame = frameFrom(parent);
+  if (!frame)
+    return QModelIndex();
+  if (frame->getNumChildFrames() <= row)
+    return QModelIndex();
+
+  Frame* childFrame = frame->getChildFrame(row);
+  if (!childFrame)
+    return QModelIndex();
+
+  return createIndex(row, 0, childFrame);
+}
+
+QModelIndex
+FrameItem::parent(const QModelIndex &child) const
+{
+  if (!child.isValid())
+    return QModelIndex();
+
+  Frame* frame = frameFrom(child);
+  if (!frame)
+    return QModelIndex();
+
+  Frame* parentFrame = frame->getParentFrame();
+  if (!parentFrame)
+    return QModelIndex();
+  if (parentFrame == mRootFrame)
+    return createIndex(0, 0, parentFrame);
+
+  Frame* parentFrame2 = parentFrame->getParentFrame();
+  if (!parentFrame2)
+    return QModelIndex();
+  unsigned row = parentFrame2->getChildFrameIndex(parentFrame);
+  if (row >= parentFrame2->getNumChildFrames())
+    return QModelIndex();
+
+  return createIndex(row, 0, parentFrame);
+}
+
+int
+FrameItem::rowCount(const QModelIndex &parent) const
+{
+  if (!parent.isValid()) {
+    if (!mRootFrame)
+      return 0;
+
+    return 1;
+  }
+
+  Frame* frame = frameFrom(parent);
+  if (!frame)
+    return 0;
+  return frame->getNumChildFrames();
+}
+
+int
+FrameItem::columnCount(const QModelIndex &parent) const
+{
+  return 2;
+}
+
+bool
+FrameItem::hasChildren(const QModelIndex &parent) const
+{
+  if (!parent.isValid())
+    return true;
+  Frame* frame = frameFrom(parent);
+  if (!frame)
+    return false;
+  return 0 < frame->getNumChildFrames();
+}
+
+QVariant
+FrameItem::data(const QModelIndex &index, int role) const
+{
+  if (!index.isValid())
+    return QVariant();
+
+  Frame* frame = frameFrom(index);
+  if (!frame)
+    return QVariant();
+  switch (role) {
+  case Qt::DisplayRole:
+    return QVariant(QString(frame->getName().c_str()));
+  case Qt::ToolTipRole:
+    return QVariant(QString(frame->getTypeName()));
+  default:
+    return QVariant();
+  }
+}
+
+QVariant
+FrameItem::headerData(int section, Qt::Orientation orientation, int role) const
+{
+  if (orientation != Qt::Horizontal || role != Qt::DisplayRole)
+    return QVariant();
+
+  switch (section) {
+  case 0:
+    return QString("Name");
+  case 1:
+    return QString("Properties");
+  default:
+    return QVariant();
+  }
+}
+
+Qt::ItemFlags
+FrameItem::flags(const QModelIndex &index) const
+{
+//   if (!index.isValid())
+//     return Qt::ItemIsEnabled;
+
+  return Qt::ItemIsEnabled | Qt::ItemIsSelectable;
+}


Property changes on: trunk/OpenFDM/src/builder/FrameItem.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/OpenFDM/src/builder/FrameItem.h
===================================================================
--- trunk/OpenFDM/src/builder/FrameItem.h	2006-01-28 10:14:29 UTC (rev 222)
+++ trunk/OpenFDM/src/builder/FrameItem.h	2006-01-28 15:56:04 UTC (rev 223)
@@ -0,0 +1,71 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2005-2006 Mathias Froehlich 
+ *
+ */
+
+#ifndef FrameItem_H
+#define FrameItem_H
+
+#include <Qt/QAbstractItemModel>
+
+#include <OpenFDM/System.h>
+
+class FrameItem : public QAbstractItemModel {
+public:
+  FrameItem(QObject* parent = 0);
+  virtual ~FrameItem(void);
+
+  virtual QModelIndex index(int row, int col, const QModelIndex &parent) const;
+  virtual QModelIndex parent(const QModelIndex &child) const;
+
+  virtual int rowCount(const QModelIndex &parent) const;
+  virtual int columnCount(const QModelIndex &parent) const;
+  virtual bool hasChildren(const QModelIndex &parent) const;
+
+  virtual QVariant data(const QModelIndex &index, int role) const;
+//virtual bool setData(const QModelIndex &index, const QVariant &value, int role);
+
+  virtual QVariant headerData(int section, Qt::Orientation orientation,
+                              int role) const;
+//virtual bool setHeaderData(int section, Qt::Orientation orientation, const QVariant &value,
+//                                int role);
+
+//     virtual QMap<int, QVariant> itemData(const QModelIndex &index) const;
+//     virtual bool setItemData(const QModelIndex &index, const QMap<int, QVariant> &roles);
+
+//     virtual QStringList mimeTypes() const;
+//     virtual QMimeData *mimeData(const QModelIndexList &indexes) const;
+//     virtual bool dropMimeData(const QMimeData *data, Qt::DropAction action,
+//                               int row, int col, const QModelIndex &parent);
+//     virtual Qt::DropActions supportedDropActions() const;
+
+//     virtual bool insertRows(int row, int count, const QModelIndex &parent);
+//     virtual bool insertColumns(int col, int count, const QModelIndex &parent);
+//     virtual bool removeRows(int row, int count, const QModelIndex &parent);
+//     virtual bool removeColumns(int col, int count, const QModelIndex &parent);
+
+//     inline bool insertRow(int row, const QModelIndex &parent);
+//     inline bool insertColumn(int col, const QModelIndex &parent);
+//     inline bool removeRow(int row, const QModelIndex &parent);
+//     inline bool removeColumn(int col, const QModelIndex &parent);
+
+//     virtual void fetchMore(const QModelIndex &parent);
+//     virtual bool canFetchMore(const QModelIndex &parent) const;
+  virtual Qt::ItemFlags flags(const QModelIndex &index) const;
+//     virtual void sort(int col, Qt::SortOrder order);
+//     virtual QModelIndex buddy(const QModelIndex &index) const;
+//     virtual QModelIndexList match(const QModelIndex &start, int role,
+//                                   const QVariant &value, int hits,
+//                                   Qt::MatchFlags flags) const;
+//     virtual QSize span(const QModelIndex &index) const;
+
+  /// set and get the system represented with that ItemModel
+  void setRootFrame(OpenFDM::Frame* frame)
+  { mRootFrame = frame; }
+  OpenFDM::Frame* getRootFrame(void) const
+  { return mRootFrame; }
+
+private:
+  OpenFDM::SharedPtr<OpenFDM::Frame> mRootFrame;
+};
+
+#endif


Property changes on: trunk/OpenFDM/src/builder/FrameItem.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/OpenFDM/src/builder/MainWindow.cpp
===================================================================
--- trunk/OpenFDM/src/builder/MainWindow.cpp	2006-01-28 10:14:29 UTC (rev 222)
+++ trunk/OpenFDM/src/builder/MainWindow.cpp	2006-01-28 15:56:04 UTC (rev 223)
@@ -0,0 +1,174 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2005-2006 Mathias Froehlich 
+ *
+ */
+
+#include <QtGui/QMainWindow>
+#include <QtGui/QMenu>
+#include <QtGui/QMenuBar>
+
+#include <osg/Node>
+#include <osg/Group>
+#include <osg/Geometry>
+#include <osg/Geode>
+#include <osg/StateSet>
+#include <osg/CullFace>
+#include <osg/Transform>
+#include <osg/Quat>
+#include <osg/PositionAttitudeTransform>
+#include <osgDB/Archive>
+#include <osgDB/ReadFile>
+
+#include <OpenFDM/ReaderWriter.h>
+#include <OpenFDM/XMLDumpModelVisitor.h>
+#include <JSBSim/LegacyJSBSimReader.h>
+
+using OpenFDM::ReaderWriter;
+using OpenFDM::LegacyJSBSimReader;
+
+#include <iostream>
+
+#include "Geometries.h"
+#include "QOsgWidget.h"
+
+#include "FrameItem.h"
+#include "ModelItem.h"
+#include "MainWindow.h"
+
+MainWindow::MainWindow(QWidget *parent, Qt::WFlags flags)
+  : QMainWindow(parent, flags)
+{
+  setObjectName("MainWindow");
+  setWindowTitle("OpenFDM Flightmodel Builder");
+  
+  // Make sure the actions are present
+  setupActions();
+  
+  setupToolBar();
+  setupMenuBar();
+  setupDockWindows();
+  
+  if (QGLFormat::hasOpenGL()) {
+    QOsgWidget *center = new QOsgWidget(this);
+    setCentralWidget(center);
+    
+    //       osgDB::ReaderWriter::Options* opts = new osgDB::ReaderWriter::Options;
+    //       opts->setObjectCacheHint(osgDB::ReaderWriter::Options::CACHE_ALL);
+    //       osgDB::Registry::instance()->setOptions(opts);
+    //       center->setScene(osgDB::readNodeFile("/home/frohlich/3D-Models/FA-18/Body/fa-18ab.ac"));
+    
+    center->setScene(OpenFDM::genCoordinateBullet());
+  }
+
+  
+  //     statusBar()->message(tr("Status Bar"));
+}
+
+MainWindow::~MainWindow(void)
+{
+}
+
+void
+MainWindow::setupToolBar()
+{
+//     toolbar = new ToolBar(this);
+//     toolbar->setAllowedAreas(Qt::ToolBarAreaTop | Qt::ToolBarAreaBottom);
+//     addToolBar(toolbar);
+}
+
+void
+MainWindow::setupMenuBar()
+{
+  QMenu *menu = menuBar()->addMenu(tr("&File"));
+  menu->addAction(mOpenAction);
+  menu->addAction(mSaveAsAction);
+  menu->addSeparator();
+  menu->addAction(mImportAction);
+  menu->addSeparator();
+  menu->addAction(mQuitAction);
+  
+  menu = menuBar()->addMenu(tr("&Tools"));
+  menu->addAction(mOpenModelBrowserAction);
+  menu->addAction(mOpenFrameBrowserAction);
+  menu->addAction(mOpen3DViewAction);
+  
+  menu = menuBar()->addMenu(tr("&Help"));
+  menu->addAction(mAboutAction);
+}
+
+void
+MainWindow::setupDockWindows()
+{
+  // Try to read JSBSim legacy files.
+  LegacyJSBSimReader reader;
+  
+  reader.addAircraftPath("/home/flightgear/sw/share/FlightGear/Aircraft/FA-18/");
+  reader.addEnginePath("/home/flightgear/sw/share/FlightGear/Aircraft/FA-18/Engines/");
+  
+  reader.loadAircraft("FA-18-cross.xml");
+  if (reader.getErrorState()) {
+    const ReaderWriter::StringList errors = reader.getErrors();
+    ReaderWriter::StringList::const_iterator it;
+    for (it = errors.begin(); it != errors.end(); ++it)
+      std::cerr << *it << std::endl;
+    return;
+  }
+  
+  // Ok, now the Vehicle here contains the imported data
+  // When the reflection stuff is ready, we can dump that data to a
+  // native format ...
+  reader.getVehicle()->getSystem()->init();
+  
+  ModelItem* model = new ModelItem;
+  model->setSystem(reader.getVehicle()->getSystem());
+
+  QDockWidget* dockWidget = new QDockWidget(this);
+  QTreeView* treeView = new QTreeView(dockWidget);
+  treeView->setModel(model);
+  dockWidget->setWidget(treeView);
+  addDockWidget(Qt::LeftDockWidgetArea, dockWidget);
+
+
+  FrameItem* frameModel = new FrameItem;
+  frameModel->setRootFrame(reader.getVehicle()->getSystem()->getEnvironment()->getRootFrame());
+
+  dockWidget = new QDockWidget(this);
+  treeView = new QTreeView(dockWidget);
+  treeView->setModel(frameModel);
+  dockWidget->setWidget(treeView);
+  addDockWidget(Qt::RightDockWidgetArea, dockWidget);
+}
+
+void
+MainWindow::setupActions(void)
+{
+  mOpenAction = new QAction(tr("&Open..."), this);
+  mOpenAction->setShortcut(tr("Ctrl+O"));
+  //     connect(mOpenAction, SIGNAL(triggered()), this, SLOT(open()));
+  
+  mSaveAsAction = new QAction(tr("&Save As..."), this);
+  mSaveAsAction->setShortcut(tr("Ctrl+S"));
+  //     connect(mSaveAsAction, SIGNAL(triggered()), this, SLOT(saveAs()));
+  
+  mImportAction = new QAction(tr("&Import..."), this);
+  mImportAction->setShortcut(tr("Ctrl+I"));
+  //     connect(mImportAction, SIGNAL(triggered()), this, SLOT(saveAs()));
+  
+  mQuitAction = new QAction(tr("&Quit"), this);
+  mQuitAction->setShortcut(tr("Ctrl+Q"));
+  connect(mQuitAction, SIGNAL(triggered()), this, SLOT(close()));
+  
+  mOpenModelBrowserAction = new QAction(tr("Open &Model Browser"), this);
+  mOpenModelBrowserAction->setShortcut(tr("Ctrl+M"));
+  //     connect(mOpenModelBrowserAction, SIGNAL(triggered()), this, SLOT(close()));
+  
+  mOpenFrameBrowserAction = new QAction(tr("Open &Frame Browser"), this);
+  mOpenFrameBrowserAction->setShortcut(tr("Ctrl+F"));
+  //     connect(mOpenFrameBrowserAction, SIGNAL(triggered()), this, SLOT(close()));
+  
+  mOpen3DViewAction = new QAction(tr("Open &3D View"), this);
+  mOpen3DViewAction->setShortcut(tr("Ctrl+3"));
+  //     connect(mOpen3DViewAction, SIGNAL(triggered()), this, SLOT(close()));
+  
+  mAboutAction = new QAction(tr("&About"), this);
+  connect(mAboutAction, SIGNAL(triggered()), this, SLOT(about()));
+}


Property changes on: trunk/OpenFDM/src/builder/MainWindow.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/OpenFDM/src/builder/MainWindow.h
===================================================================
--- trunk/OpenFDM/src/builder/MainWindow.h	2006-01-28 10:14:29 UTC (rev 222)
+++ trunk/OpenFDM/src/builder/MainWindow.h	2006-01-28 15:56:04 UTC (rev 223)
@@ -0,0 +1,36 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2005-2006 Mathias Froehlich 
+ *
+ */
+
+#ifndef MainWindow_H
+#define MainWindow_H
+
+#include <QtGui/QMainWindow>
+
+class MainWindow : public QMainWindow
+{
+//   Q_OBJECT
+public:
+  MainWindow(QWidget *parent = 0, Qt::WFlags flags = 0);
+  ~MainWindow(void);
+
+private:
+  void setupToolBar(void);
+  void setupMenuBar(void);
+  void setupDockWindows(void);
+  void setupActions(void);
+
+  // All the actions we can have in this application
+  QAction* mOpenAction;
+  QAction* mSaveAsAction;
+  QAction* mImportAction;
+  QAction* mQuitAction;
+
+  QAction* mOpenModelBrowserAction;
+  QAction* mOpenFrameBrowserAction;
+  QAction* mOpen3DViewAction;
+
+  QAction* mAboutAction;
+};
+
+#endif


Property changes on: trunk/OpenFDM/src/builder/MainWindow.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/OpenFDM/src/builder/Makefile.am
===================================================================
--- trunk/OpenFDM/src/builder/Makefile.am	2006-01-28 10:14:29 UTC (rev 222)
+++ trunk/OpenFDM/src/builder/Makefile.am	2006-01-28 15:56:04 UTC (rev 223)
@@ -16,12 +16,18 @@
 	main.cpp \
 	Configuration.h \
 	Configuration.cpp \
+	FrameItem.h \
+	FrameItem.cpp \
 	Geometries.h \
 	Geometries.cpp \
+	MainWindow.h \
+	MainWindow.cpp \
+	ModelItem.h \
+	ModelItem.cpp \
 	QOsgWidget.h \
 	QOsgWidget.cpp
 
-openfdm_LDADD = ../OpenFDM/libOpenFDM.la \
+openfdm_LDADD = ../JSBSim/libJSBReader.la ../OpenFDM/libOpenFDM.la \
                 -losgGA -losgUtil -losgDB -losg -lOpenThreads \
                 -lQtGui -lQtOpenGL -lQtCore \
                 -lGL -lGLU

Added: trunk/OpenFDM/src/builder/ModelItem.cpp
===================================================================
--- trunk/OpenFDM/src/builder/ModelItem.cpp	2006-01-28 10:14:29 UTC (rev 222)
+++ trunk/OpenFDM/src/builder/ModelItem.cpp	2006-01-28 15:56:04 UTC (rev 223)
@@ -0,0 +1,169 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2005-2006 Mathias Froehlich 
+ *
+ */
+
+#include <iostream>
+
+#include <OpenFDM/Model.h>
+#include <OpenFDM/ModelGroup.h>
+#include "ModelItem.h"
+
+using OpenFDM::Model;
+using OpenFDM::ModelGroup;
+
+static Model* modelFrom(const QModelIndex& index)
+{
+  if (!index.isValid())
+    return 0;
+  return static_cast<Model*>(index.internalPointer());
+}
+
+static ModelGroup* modelGroupFrom(const QModelIndex& index)
+{
+  if (!index.isValid())
+    return 0;
+  Model* model = static_cast<Model*>(index.internalPointer());
+  if (!model)
+    return 0;
+  return model->toModelGroup();
+}
+
+ModelItem::ModelItem(QObject* parent) :
+  QAbstractItemModel(parent)
+{
+}
+
+ModelItem::~ModelItem(void)
+{
+}
+
+QModelIndex
+ModelItem::index(int row, int column, const QModelIndex &parent) const
+{
+  if (!parent.isValid()) {
+    if (!mSystem)
+      return QModelIndex();
+    if (row != 0)
+      return QModelIndex();
+
+    return createIndex(row, 0, mSystem);
+  }
+
+  ModelGroup* modelGroup = modelGroupFrom(parent);
+  if (!modelGroup)
+    return QModelIndex();
+  if (modelGroup->getNumModels() <= row)
+    return QModelIndex();
+
+  Model* childModel = modelGroup->getModel(row);
+  if (!childModel)
+    return QModelIndex();
+
+  return createIndex(row, 0, childModel);
+}
+
+QModelIndex
+ModelItem::parent(const QModelIndex &child) const
+{
+  if (!child.isValid())
+    return QModelIndex();
+
+  Model* model = modelFrom(child);
+  if (!model)
+    return QModelIndex();
+
+  Model* parentModel = model->getParent();
+  if (!parentModel)
+    return QModelIndex();
+  if (parentModel == mSystem)
+    return createIndex(0, 0, parentModel);
+
+  Model* parentModel2 = parentModel->getParent();
+  if (!parentModel2)
+    return QModelIndex();
+  ModelGroup* parentModelGroup2 = parentModel2->toModelGroup();
+  if (!parentModelGroup2)
+    return QModelIndex();
+  unsigned row = parentModelGroup2->getModelIndex(parentModel);
+  if (row >= parentModelGroup2->getNumModels())
+    return QModelIndex();
+
+  return createIndex(row, 0, parentModel);
+}
+
+int
+ModelItem::rowCount(const QModelIndex &parent) const
+{
+  if (!parent.isValid()) {
+    if (!mSystem)
+      return 0;
+
+    return 1;
+  }
+
+  ModelGroup* modelGroup = modelGroupFrom(parent);
+  if (!modelGroup)
+    return 0;
+  return modelGroup->getNumModels();
+}
+
+int
+ModelItem::columnCount(const QModelIndex &parent) const
+{
+  return 2;
+}
+
+bool
+ModelItem::hasChildren(const QModelIndex &parent) const
+{
+  if (!parent.isValid())
+    return true;
+  ModelGroup* modelGroup = modelGroupFrom(parent);
+  if (!modelGroup)
+    return false;
+  return 0 < modelGroup->getNumModels();
+}
+
+QVariant
+ModelItem::data(const QModelIndex &index, int role) const
+{
+  if (!index.isValid())
+    return QVariant();
+
+  Model* model = modelFrom(index);
+  if (!model)
+    return QVariant();
+  switch (role) {
+  case Qt::DisplayRole:
+    return QVariant(QString(model->getName().c_str()));
+  case Qt::ToolTipRole:
+    return QVariant(QString(model->getTypeName()));
+  default:
+    return QVariant();
+  }
+}
+
+QVariant
+ModelItem::headerData(int section, Qt::Orientation orientation, int role) const
+{
+  if (orientation != Qt::Horizontal || role != Qt::DisplayRole)
+    return QVariant();
+
+  switch (section) {
+  case 0:
+    return QString("Name");
+  case 1:
+    return QString("Properties");
+  default:
+    return QVariant();
+  }
+}
+
+Qt::ItemFlags
+ModelItem::flags(const QModelIndex &index) const
+{
+//   if (!index.isValid())
+//     return Qt::ItemIsEnabled;
+
+  return Qt::ItemIsEnabled | Qt::ItemIsSelectable;
+}


Property changes on: trunk/OpenFDM/src/builder/ModelItem.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/OpenFDM/src/builder/ModelItem.h
===================================================================
--- trunk/OpenFDM/src/builder/ModelItem.h	2006-01-28 10:14:29 UTC (rev 222)
+++ trunk/OpenFDM/src/builder/ModelItem.h	2006-01-28 15:56:04 UTC (rev 223)
@@ -0,0 +1,71 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2005-2006 Mathias Froehlich 
+ *
+ */
+
+#ifndef ModelItem_H
+#define ModelItem_H
+
+#include <Qt/QAbstractItemModel>
+
+#include <OpenFDM/System.h>
+
+class ModelItem : public QAbstractItemModel {
+public:
+  ModelItem(QObject* parent = 0);
+  virtual ~ModelItem(void);
+
+  virtual QModelIndex index(int row, int col, const QModelIndex &parent) const;
+  virtual QModelIndex parent(const QModelIndex &child) const;
+
+  virtual int rowCount(const QModelIndex &parent) const;
+  virtual int columnCount(const QModelIndex &parent) const;
+  virtual bool hasChildren(const QModelIndex &parent) const;
+
+  virtual QVariant data(const QModelIndex &index, int role) const;
+//virtual bool setData(const QModelIndex &index, const QVariant &value, int role);
+
+  virtual QVariant headerData(int section, Qt::Orientation orientation,
+                              int role) const;
+//virtual bool setHeaderData(int section, Qt::Orientation orientation, const QVariant &value,
+//                                int role);
+
+//     virtual QMap<int, QVariant> itemData(const QModelIndex &index) const;
+//     virtual bool setItemData(const QModelIndex &index, const QMap<int, QVariant> &roles);
+
+//     virtual QStringList mimeTypes() const;
+//     virtual QMimeData *mimeData(const QModelIndexList &indexes) const;
+//     virtual bool dropMimeData(const QMimeData *data, Qt::DropAction action,
+//                               int row, int col, const QModelIndex &parent);
+//     virtual Qt::DropActions supportedDropActions() const;
+
+//     virtual bool insertRows(int row, int count, const QModelIndex &parent);
+//     virtual bool insertColumns(int col, int count, const QModelIndex &parent);
+//     virtual bool removeRows(int row, int count, const QModelIndex &parent);
+//     virtual bool removeColumns(int col, int count, const QModelIndex &parent);
+
+//     inline bool insertRow(int row, const QModelIndex &parent);
+//     inline bool insertColumn(int col, const QModelIndex &parent);
+//     inline bool removeRow(int row, const QModelIndex &parent);
+//     inline bool removeColumn(int col, const QModelIndex &parent);
+
+//     virtual void fetchMore(const QModelIndex &parent);
+//     virtual bool canFetchMore(const QModelIndex &parent) const;
+  virtual Qt::ItemFlags flags(const QModelIndex &index) const;
+//     virtual void sort(int col, Qt::SortOrder order);
+//     virtual QModelIndex buddy(const QModelIndex &index) const;
+//     virtual QModelIndexList match(const QModelIndex &start, int role,
+//                                   const QVariant &value, int hits,
+//                                   Qt::MatchFlags flags) const;
+//     virtual QSize span(const QModelIndex &index) const;
+
+  /// set and get the system represented with that ItemModel
+  void setSystem(OpenFDM::System* system)
+  { mSystem = system; }
+  OpenFDM::System* getSystem(void) const
+  { return mSystem; }
+
+private:
+  OpenFDM::SharedPtr<OpenFDM::System> mSystem;
+};
+
+#endif


Property changes on: trunk/OpenFDM/src/builder/ModelItem.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/OpenFDM/src/builder/main.cpp
===================================================================
--- trunk/OpenFDM/src/builder/main.cpp	2006-01-28 10:14:29 UTC (rev 222)
+++ trunk/OpenFDM/src/builder/main.cpp	2006-01-28 15:56:04 UTC (rev 223)
@@ -1,90 +1,12 @@
 #include <QtGui/QApplication>
-#include <QtGui/QMainWindow>
-#include <QtGui/QMenu>
-#include <QtGui/QMenuBar>
+#include "MainWindow.h"
 
-#include <osg/Node>
-#include <osg/Group>
-#include <osg/Geometry>
-#include <osg/Geode>
-#include <osg/StateSet>
-#include <osg/CullFace>
-#include <osg/Transform>
-#include <osg/Quat>
-#include <osg/PositionAttitudeTransform>
-#include <osgDB/Archive>
-#include <osgDB/ReadFile>
-
-#include <iostream>
-
-#include "Geometries.h"
-#include "QOsgWidget.h"
-
-class MainWindow : public QMainWindow
-{
-//   Q_OBJECT
-  
-  QMenu *dockWindowMenu;
-  
-public:
-  MainWindow(QWidget *parent = 0, Qt::WFlags flags = 0)
-    : QMainWindow(parent, flags)
-  {
-    setObjectName("MainWindow");
-    setWindowTitle("OpenFDM Flightmodel Builder");
-    
-//     setupToolBar();
-    setupMenuBar();
-//     setupDockWindows();
-
-    if (QGLFormat::hasOpenGL()) {
-      QOsgWidget *center = new QOsgWidget(this);
-      setCentralWidget(center);
-
-//       osgDB::ReaderWriter::Options* opts = new osgDB::ReaderWriter::Options;
-//       opts->setObjectCacheHint(osgDB::ReaderWriter::Options::CACHE_ALL);
-//       osgDB::Registry::instance()->setOptions(opts);
-//       center->setScene(osgDB::readNodeFile("/home/frohlich/3D-Models/FA-18/Body/fa-18ab.ac"));
-
-      center->setScene(OpenFDM::genCoordinateBullet());
-    }
-
-
-//     statusBar()->message(tr("Status Bar"));
-  }
-
-  
-public slots:
-  void actionTriggered(QAction *action)
-  {
-    qDebug("action '%s' triggered", action->text().toLocal8Bit().data());
-  }
-
-  
-private:
-//   void setupToolBar()
-//   {
-//     toolbar = new ToolBar(this);
-//     toolbar->setAllowedAreas(Qt::ToolBarAreaTop | Qt::ToolBarAreaBottom);
-//     addToolBar(toolbar);
-//   }
-
-  void setupMenuBar()
-  {
-    QMenu *menu = menuBar()->addMenu(tr("&File"));
-    menu->addAction(tr("&Quit"), this, SLOT(close()));
-    
-//     menuBar()->addMenu(toolbar->menu);
-//     dockWindowMenu = menuBar()->addMenu(tr("&Dock windows"));
-  }
-//   void setupDockWindows();
-};
-
 int main(int argc, char **argv)
 {
   QApplication app(argc, argv);
-  MainWindow mwd;
-  app.setActiveWindow(&mwd);
-  mwd.show();
+
+  MainWindow mainWindow;
+  app.setActiveWindow(&mainWindow);
+  mainWindow.show();
   return app.exec();
 }



