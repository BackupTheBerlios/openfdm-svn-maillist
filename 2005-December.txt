From frohlich at berlios.de  Sun Dec  4 20:07:49 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Sun, 4 Dec 2005 20:07:49 +0100
Subject: [OpenFDM-svn] r82 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200512041907.jB4J7nGk001304@sheep.berlios.de>

Author: frohlich
Date: 2005-12-04 20:07:21 +0100 (Sun, 04 Dec 2005)
New Revision: 82

Modified:
   trunk/OpenFDM/src/OpenFDM/Model.h
Log:
Sketch of a changed port api. Many if's and new's
are in the fast path now, making it dead slow ...


Modified: trunk/OpenFDM/src/OpenFDM/Model.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Model.h	2005-11-29 19:14:59 UTC (rev 81)
+++ trunk/OpenFDM/src/OpenFDM/Model.h	2005-12-04 19:07:21 UTC (rev 82)
@@ -24,7 +24,105 @@
 class Input;
 class Output;
 
-/// Class for an inout or output port of a Model.
+class RealPortInterface;
+class MatrixPortInterface;
+
+class PortInterface : public Referenced {
+public:
+  virtual ~PortInterface(void) {}
+  virtual RealPortInterface* toRealPortInterface(void) { return 0; }
+  virtual MatrixPortInterface* toMatrixPortInterface(void) { return 0; }
+
+  virtual bool isConnected(void) const = 0;
+  virtual void evaluate(void) = 0;
+};
+
+class RealPortInterface : public PortInterface {
+public:
+  RealPortInterface(unsigned m = 1, unsigned n = 1) : mValue(m, n) {}
+  virtual RealPortInterface* toRealPortInterface(void)
+  {
+    if (Size(1, 1) == size(mValue))
+      return this;
+    else
+      return 0;
+  }
+  // FIXME, should not be a virtual function
+  virtual real_type getRealValue(void)
+  { evaluate(); return mValue(1, 1); }
+protected:
+  Matrix mValue;
+};
+
+class MatrixPortInterface : public RealPortInterface {
+public:
+  virtual MatrixPortInterface* toMatrixPortInterface(void) { return this; }
+  // FIXME, should not be a virtual function
+  virtual const Matrix& getMatrixValue(void)
+  { evaluate(); return mValue; }
+};
+
+
+/// FIXME adapter to be somehow backwards compatible
+/// Should vanish
+class PropertyPortInterface : public MatrixPortInterface {
+public:
+  PropertyPortInterface(const Property& property) : mProperty(property)
+  { }
+  virtual void evaluate(void)
+  {
+    mValue = mProperty.getValue().toMatrix();
+  }
+  virtual bool isConnected(void) const
+  { return mProperty.isValid(); }
+private:
+  mutable Property mProperty;
+};
+
+class RealPortHandle {
+public:
+  RealPortHandle(RealPortInterface* realPortInterface) :
+    mRealPortInterface(realPortInterface)
+  { }
+  real_type getRealValue(void)
+  { return mRealPortInterface->getRealValue(); }
+  bool isConnected(void) const
+  { return mRealPortInterface && mRealPortInterface->isConnected(); }
+private:
+  shared_ptr<RealPortInterface> mRealPortInterface;
+};
+
+class MatrixPortHandle {
+public:
+  MatrixPortHandle(MatrixPortInterface* matrixPortInterface) :
+    mMatrixPortInterface(matrixPortInterface)
+  { }
+  const Matrix& getMatrixValue(void)
+  { return mMatrixPortInterface->getMatrixValue(); }
+  bool isConnected(void) const
+  { return mMatrixPortInterface && mMatrixPortInterface->isConnected(); }
+private:
+  shared_ptr<MatrixPortInterface> mMatrixPortInterface;
+};
+
+// should vanish, just an adaptor for smoother migration
+class RealPortExpression : public PropertyImpl<real_type> {
+public:
+  RealPortExpression(const RealPortHandle& rph) :
+    mRealPortHandle(rph)
+  { }
+  real_type getValue(void) const
+  { return mRealPortHandle.getRealValue(); }
+  void setValue(const real_type&)
+  {  }
+  bool isValid(void) const { return mRealPortHandle.isConnected(); }
+  const Object* getObject(void) const { return 0; }
+  Object* getObject(void) { return 0; }
+private:
+  mutable RealPortHandle mRealPortHandle;
+};
+
+/// Class for an input or output port of a Model.
 /// Ports can be connected together. This means in effect that the reader
 /// gains access to value at the source model.
 /// Additional information must be carried through that class.
@@ -43,22 +141,31 @@
   /// Just use the Properties for now. In this phase it might be a good idea.
   void setProperty(const Property& property)
   {
-    mProperty = property;
+    setPortInterface(new PropertyPortInterface(property));
+  }
+  void setPortInterface(PortInterface* portInterface)
+  {
+    mPortInterface = portInterface;
     std::vector<shared_ptr<Port> >::iterator it;
     for (it = mChainPorts.begin(); it != mChainPorts.end(); ++it) {
-      (*it)->setProperty(property);
+      (*it)->setPortInterface(mPortInterface);
     }
   }
+
   /// Just use the Properties for now. In this phase it might be a good idea.
-  const Property& getProperty(void) const
-  { return mProperty; }
-  Property& getProperty(void)
-  { return mProperty; }
+  Property getProperty(void) const
+  { return Property(new RealPortExpression(((Port*)(this))->toRealPortHandle())); }
 
+
   /// returns true if this port has a source port connected to it
   bool isConnected() const
-  { return mProperty.isValid(); }
+  { return mPortInterface->isConnected(); }
 
+  RealPortHandle toRealPortHandle(void)
+  { return RealPortHandle(mPortInterface->toRealPortInterface()); }
+  MatrixPortHandle toMatrixPortHandle(void)
+  { return MatrixPortHandle(mPortInterface->toMatrixPortInterface()); }
+
   /// Retrieve the value of this port
   /// Note that we don't need a setValue method since we attach a getter of a
   /// Model to a port.
@@ -66,8 +173,19 @@
   /// This might be the place where it is possible to implement
   /// TaskInfo dependent output ports ...
   /// Hmm, may be we should otoh 'dirty' some getters?
-  Variant getValue(void) const
-  { return mProperty.getValue(); }
+  /// Generic thing. Don't use if you don't have to
+  Variant getValue(void)
+  {
+    RealPortInterface* realPortInterface
+      = mPortInterface->toRealPortInterface();
+    if (realPortInterface)
+      return Variant(realPortInterface->getRealValue());
+    MatrixPortInterface* matrixPortInterface
+      = mPortInterface->toMatrixPortInterface();
+    if (matrixPortInterface)
+      return Variant(matrixPortInterface->getMatrixValue());
+    return Variant();
+  }
 
   /// Connect this port to the given source port
   void connect(Port* sourcePort)
@@ -124,7 +242,10 @@
   { disconnect(mSourcePort); }
 
 private:
-  mutable/*FIXME*/ Property mProperty;
+  /// For now the untyped input port
+  /// On Model::init() it is expected to be specialized
+  /// to a typed port handle
+  shared_ptr<PortInterface> mPortInterface;
   /// The list of readers for this port
   std::vector<shared_ptr<Port> > mChainPorts;
   /// The source of the current port connection



From frohlich at berlios.de  Sun Dec  4 20:17:29 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Sun, 4 Dec 2005 20:17:29 +0100
Subject: [OpenFDM-svn] r83 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200512041917.jB4JHTCT005660@sheep.berlios.de>

Author: frohlich
Date: 2005-12-04 20:17:24 +0100 (Sun, 04 Dec 2005)
New Revision: 83

Modified:
   trunk/OpenFDM/src/OpenFDM/Model.h
Log:
Use the new api even internally :)


Modified: trunk/OpenFDM/src/OpenFDM/Model.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Model.h	2005-12-04 19:07:21 UTC (rev 82)
+++ trunk/OpenFDM/src/OpenFDM/Model.h	2005-12-04 19:17:24 UTC (rev 83)
@@ -204,7 +204,7 @@
     }
 
     // If we have a source port, propagate its context.
-    setProperty(sourcePort->getProperty());
+    setPortInterface(sourcePort->mPortInterface);
     sourcePort->mChainPorts.push_back(this);
     mSourcePort = sourcePort;
   }
@@ -234,7 +234,7 @@
     mSourcePort = 0;
 
     // Invalidate all our listeners
-    setProperty(Property());
+    setPortInterface(0);
   }
 
   /// Just disconnect from whoever we are connected to



From frohlich at berlios.de  Wed Dec  7 21:41:16 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Wed, 7 Dec 2005 21:41:16 +0100
Subject: [OpenFDM-svn] r84 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200512072041.jB7KfGQc010546@sheep.berlios.de>

Author: frohlich
Date: 2005-12-07 21:40:50 +0100 (Wed, 07 Dec 2005)
New Revision: 84

Modified:
   trunk/OpenFDM/src/OpenFDM/Bias.cpp
   trunk/OpenFDM/src/OpenFDM/ConstSystem.cpp
   trunk/OpenFDM/src/OpenFDM/Contact.cpp
   trunk/OpenFDM/src/OpenFDM/DeadBand.cpp
   trunk/OpenFDM/src/OpenFDM/DeadBand.h
   trunk/OpenFDM/src/OpenFDM/DirectForce.cpp
   trunk/OpenFDM/src/OpenFDM/DiscBrake.cpp
   trunk/OpenFDM/src/OpenFDM/DiscreteIntegrator.cpp
   trunk/OpenFDM/src/OpenFDM/Gain.cpp
   trunk/OpenFDM/src/OpenFDM/Input.cpp
   trunk/OpenFDM/src/OpenFDM/Integrator.cpp
   trunk/OpenFDM/src/OpenFDM/LineActuator.cpp
   trunk/OpenFDM/src/OpenFDM/MaxModel.cpp
   trunk/OpenFDM/src/OpenFDM/MinModel.cpp
   trunk/OpenFDM/src/OpenFDM/Model.cpp
   trunk/OpenFDM/src/OpenFDM/Model.h
   trunk/OpenFDM/src/OpenFDM/ModelGroup.cpp
   trunk/OpenFDM/src/OpenFDM/ModelGroup.h
   trunk/OpenFDM/src/OpenFDM/PrismaticJoint.cpp
   trunk/OpenFDM/src/OpenFDM/PrismaticJoint.h
   trunk/OpenFDM/src/OpenFDM/Product.cpp
   trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp
   trunk/OpenFDM/src/OpenFDM/RevoluteJoint.h
   trunk/OpenFDM/src/OpenFDM/Saturation.cpp
   trunk/OpenFDM/src/OpenFDM/SimpleGear.cpp
   trunk/OpenFDM/src/OpenFDM/Summer.cpp
   trunk/OpenFDM/src/OpenFDM/Table.h
   trunk/OpenFDM/src/OpenFDM/TimeDerivative.cpp
   trunk/OpenFDM/src/OpenFDM/TransferFunction.cpp
Log:
More on transition to the new port interface


Modified: trunk/OpenFDM/src/OpenFDM/Bias.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Bias.cpp	2005-12-04 19:17:24 UTC (rev 83)
+++ trunk/OpenFDM/src/OpenFDM/Bias.cpp	2005-12-07 20:40:50 UTC (rev 84)
@@ -23,9 +23,9 @@
   setInputPortName(0, "input");
   
   setNumOutputPorts(1);
-  setOutputPort(0, "output", Property(this, &Bias::getOutput));
+  setOutputPort(0, "output", this, &Bias::getOutput);
+
   addProperty("output", Property(this, &Bias::getOutput));
-  
   addProperty("bias", Property(this, &Bias::getBias, &Bias::setBias));
 }
 
@@ -62,8 +62,9 @@
 Bias::output(const TaskInfo&)
 {
   OpenFDMAssert(getInputPort(0)->isConnected());
-  OpenFDMAssert(size(getInputPort(0)->getValue().toMatrix()) == size(mBias));
-  mOutput = mBias + getInputPort(0)->getValue().toMatrix();
+  MatrixPortHandle mh = getInputPort(0)->toMatrixPortHandle();
+  mOutput = mh.getMatrixValue();
+  mOutput += mBias;
 }
 
 const Matrix&

Modified: trunk/OpenFDM/src/OpenFDM/ConstSystem.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/ConstSystem.cpp	2005-12-04 19:17:24 UTC (rev 83)
+++ trunk/OpenFDM/src/OpenFDM/ConstSystem.cpp	2005-12-07 20:40:50 UTC (rev 84)
@@ -12,7 +12,7 @@
   addProperty("value", Property(this, &ConstSystem::getValue, &ConstSystem::setValue));
 
   setNumOutputPorts(1);
-  setOutputPort(0, "output", Property(this, &ConstSystem::getValue));
+  setOutputPort(0, "output", this, &ConstSystem::getValue);
 }
 
 ConstSystem::~ConstSystem(void)

Modified: trunk/OpenFDM/src/OpenFDM/Contact.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Contact.cpp	2005-12-04 19:17:24 UTC (rev 83)
+++ trunk/OpenFDM/src/OpenFDM/Contact.cpp	2005-12-07 20:40:50 UTC (rev 84)
@@ -43,8 +43,10 @@
     getGround(taskInfo.getTime());
 
     // FIXME
-    if (getInputPort("enabled")->isConnected())
-      mEnabled = 0.5 < getInputPort("enabled")->getValue().toReal();
+    if (getInputPort("enabled")->isConnected()) {
+      RealPortHandle rh = getInputPort("enabled")->toRealPortHandle();
+      mEnabled = 0.5 < rh.getRealValue();
+    }
   }
 }
 

Modified: trunk/OpenFDM/src/OpenFDM/DeadBand.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/DeadBand.cpp	2005-12-04 19:17:24 UTC (rev 83)
+++ trunk/OpenFDM/src/OpenFDM/DeadBand.cpp	2005-12-07 20:40:50 UTC (rev 84)
@@ -22,7 +22,7 @@
   setInputPortName(0, "input");
   
   setNumOutputPorts(1);
-  setOutputPort(0, "output", Property(this, &DeadBand::getOutput));
+  setOutputPort(0, "output", this, &DeadBand::getOutput);
   
   addProperty("width", Property(this, &DeadBand::getWidth, &DeadBand::setWidth));
 }
@@ -43,7 +43,8 @@
 {
   OpenFDMAssert(getInputPort(0)->isConnected());
   
-  mOutput = getInputPort(0)->getValue().toReal();
+  RealPortHandle rh = getInputPort(0)->toRealPortHandle();
+  mOutput = rh.getRealValue();
   if (mOutput < -mWidth)
     mOutput += mWidth;
   else if (mWidth < mOutput)
@@ -64,7 +65,7 @@
   mWidth = width;
 }
 
-real_type
+const real_type&
 DeadBand::getOutput(void) const
 {
   return mOutput;

Modified: trunk/OpenFDM/src/OpenFDM/DeadBand.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/DeadBand.h	2005-12-04 19:17:24 UTC (rev 83)
+++ trunk/OpenFDM/src/OpenFDM/DeadBand.h	2005-12-07 20:40:50 UTC (rev 84)
@@ -26,7 +26,7 @@
   const real_type& getWidth(void) const;
   void setWidth(const real_type& width);
 
-  real_type getOutput(void) const;
+  const real_type& getOutput(void) const;
 
 private:
   real_type mWidth;

Modified: trunk/OpenFDM/src/OpenFDM/DirectForce.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/DirectForce.cpp	2005-12-04 19:17:24 UTC (rev 83)
+++ trunk/OpenFDM/src/OpenFDM/DirectForce.cpp	2005-12-07 20:40:50 UTC (rev 84)
@@ -90,7 +90,8 @@
 void
 DirectForce::output(const TaskInfo&)
 {
-  mMagnitude = getInputPort(0)->getValue().toReal();
+  RealPortHandle rh = getInputPort(0)->toRealPortHandle();
+  mMagnitude = rh.getRealValue();
   mForce = mMagnitude*mDirection;
 }
 

Modified: trunk/OpenFDM/src/OpenFDM/DiscBrake.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/DiscBrake.cpp	2005-12-04 19:17:24 UTC (rev 83)
+++ trunk/OpenFDM/src/OpenFDM/DiscBrake.cpp	2005-12-07 20:40:50 UTC (rev 84)
@@ -23,7 +23,12 @@
 void
 DiscBrake::output(const TaskInfo& taskInfo)
 {
-  real_type brakeInput = getInputPort(0)->getValue().toReal();
+  Port* port = getInputPort(0);
+  real_type brakeInput = 0;
+  if (port->isConnected()) {
+    RealPortHandle rh = port->toRealPortHandle();
+    brakeInput = rh.getRealValue();
+  }
   setForce(getVel()*(-1e1 + brakeInput*mFrictionConstant));
 }
 

Modified: trunk/OpenFDM/src/OpenFDM/DiscreteIntegrator.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/DiscreteIntegrator.cpp	2005-12-04 19:17:24 UTC (rev 83)
+++ trunk/OpenFDM/src/OpenFDM/DiscreteIntegrator.cpp	2005-12-07 20:40:50 UTC (rev 84)
@@ -14,7 +14,7 @@
   setInputPortName(0, "derivatirve");
 
   setNumOutputPorts(1);
-  setOutputPort(0, "output", Property(this, &DiscreteIntegrator::getIntegralOutput));
+  setOutputPort(0, "output", this, &DiscreteIntegrator::getIntegralOutput);
 
   addProperty("initialValue", Property(this, &DiscreteIntegrator::getInitialValue, &DiscreteIntegrator::setInitialValue));
   addProperty("minSaturation", Property(this, &DiscreteIntegrator::getMinSaturation, &DiscreteIntegrator::setMinSaturation));
@@ -67,18 +67,15 @@
   // Just compute the integral.
   // FIXME: make sure this is the only dt ...
   real_type dt = (*taskInfo.getSampleTimeSet().begin()).getSampleTime();
-  Matrix input = getInputPort(0)->getValue().toMatrix();
-  OpenFDMAssert(size(input) == size(mIntegralState));
-  if (size(input) == size(mIntegralState))
-    mIntegralState += dt*input;
+  MatrixPortHandle mh = getInputPort(0)->toMatrixPortHandle();
+  if (size(mh.getMatrixValue()) == size(mIntegralState))
+    mIntegralState += dt*mh.getMatrixValue();
 
   // Hmm, should that be done on state setting too???
-  if (size(mMaxSaturation) == size(mInitialValue)) {
+  if (size(mMaxSaturation) == size(mInitialValue))
     mIntegralState = LinAlg::min(mIntegralState, mMaxSaturation);
-  }
-  if (size(mMinSaturation) == size(mInitialValue)) {
+  if (size(mMinSaturation) == size(mInitialValue))
     mIntegralState = LinAlg::max(mIntegralState, mMinSaturation);
-  }
 }
 
 void

Modified: trunk/OpenFDM/src/OpenFDM/Gain.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Gain.cpp	2005-12-04 19:17:24 UTC (rev 83)
+++ trunk/OpenFDM/src/OpenFDM/Gain.cpp	2005-12-07 20:40:50 UTC (rev 84)
@@ -23,7 +23,8 @@
   setInputPortName(0, "input");
   
   setNumOutputPorts(1);
-  setOutputPort(0, "output", Property(this, &Gain::getOutput));
+  setOutputPort(0, "output", this, &Gain::getOutput);
+
   addProperty("output", Property(this, &Gain::getOutput));
   
   addProperty("gain", Property(this, &Gain::getGain, &Gain::setGain));
@@ -47,7 +48,8 @@
 void Gain::output(const TaskInfo&)
 {
   OpenFDMAssert(getInputPort(0)->isConnected());
-  mOutput = getInputPort(0)->getValue().toMatrix();
+  MatrixPortHandle mh = getInputPort(0)->toMatrixPortHandle();
+  mOutput = mh.getMatrixValue();
   mOutput *= mGain;
 }
 

Modified: trunk/OpenFDM/src/OpenFDM/Input.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Input.cpp	2005-12-04 19:17:24 UTC (rev 83)
+++ trunk/OpenFDM/src/OpenFDM/Input.cpp	2005-12-07 20:40:50 UTC (rev 84)
@@ -11,7 +11,7 @@
   mInputGain(1)
 {
   setNumOutputPorts(1);
-  setOutputPort(0, "output", Property(this, &Input::getOutputValue));
+  setOutputPort(0, "output", this, &Input::getOutputValue);
 
   addProperty("inputValue",
               Property(this, &Input::getInputValue, &Input::setInputValue));
@@ -138,7 +138,8 @@
 void
 Output::output(const TaskInfo&)
 {
-  mValue = mOutputGain*getInputPort(0)->getValue().toReal();
+  RealPortHandle rh = getInputPort(0)->toRealPortHandle();
+  mValue = rh.getRealValue();
 }
 
 const real_type&

Modified: trunk/OpenFDM/src/OpenFDM/Integrator.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Integrator.cpp	2005-12-04 19:17:24 UTC (rev 83)
+++ trunk/OpenFDM/src/OpenFDM/Integrator.cpp	2005-12-07 20:40:50 UTC (rev 84)
@@ -82,7 +82,8 @@
   OpenFDMAssert(getInputPort(0)->isConnected());
 
   // Just compute the integral.
-  Matrix input = getInputPort(0)->getValue().toMatrix();
+  MatrixPortHandle mh = getInputPort(0)->toMatrixPortHandle();
+  const Matrix& input = mh.getMatrixValue();
   OpenFDMAssert(size(input) == size(mIntegralState));
 
   // FIXME reshape ...

Modified: trunk/OpenFDM/src/OpenFDM/LineActuator.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/LineActuator.cpp	2005-12-04 19:17:24 UTC (rev 83)
+++ trunk/OpenFDM/src/OpenFDM/LineActuator.cpp	2005-12-07 20:40:50 UTC (rev 84)
@@ -24,7 +24,8 @@
 void
 LineActuator::output(const TaskInfo& taskInfo)
 {
-  real_type posInput = getInputPort(0)->getValue().toReal();
+  RealPortHandle rh = getInputPort(0)->toRealPortHandle();
+  real_type posInput = rh.getRealValue();
   real_type displacement = getPosition() - posInput;
   setForce(mProportionalGain*displacement + getVel()*mDerivativeGain);
 }

Modified: trunk/OpenFDM/src/OpenFDM/MaxModel.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/MaxModel.cpp	2005-12-04 19:17:24 UTC (rev 83)
+++ trunk/OpenFDM/src/OpenFDM/MaxModel.cpp	2005-12-07 20:40:50 UTC (rev 84)
@@ -22,7 +22,8 @@
   setInputPortName(1, "Input 1");
   
   setNumOutputPorts(1);
-  setOutputPort(0, "output", Property(this, &MaxModel::getMax));
+  setOutputPort(0, "output", this, &MaxModel::getMax);
+
   addProperty("output", Property(this, &MaxModel::getMax));
 
   addProperty("numMaxInputs", Property(this, &MaxModel::getNumMaxInputs, &MaxModel::setNumMaxInputs));
@@ -54,9 +55,12 @@
 void
 MaxModel::output(const TaskInfo&)
 {
-  mMax = getInputPort(0)->getValue().toMatrix();
-  for (unsigned i = 1; i < getNumInputPorts(); ++i)
-    mMax = LinAlg::max(mMax, getInputPort(i)->getValue().toMatrix());
+  MatrixPortHandle mh = getInputPort(0)->toMatrixPortHandle();
+  mMax = mh.getMatrixValue();
+  for (unsigned i = 1; i < getNumInputPorts(); ++i) {
+    MatrixPortHandle mh = getInputPort(i)->toMatrixPortHandle();
+    mMax = LinAlg::max(mMax, mh.getMatrixValue());
+  }
 }
 
 const Matrix&

Modified: trunk/OpenFDM/src/OpenFDM/MinModel.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/MinModel.cpp	2005-12-04 19:17:24 UTC (rev 83)
+++ trunk/OpenFDM/src/OpenFDM/MinModel.cpp	2005-12-07 20:40:50 UTC (rev 84)
@@ -22,7 +22,8 @@
   setInputPortName(1, "Input 1");
   
   setNumOutputPorts(1);
-  setOutputPort(0, "output", Property(this, &MinModel::getMin));
+  setOutputPort(0, "output", this, &MinModel::getMin);
+
   addProperty("output", Property(this, &MinModel::getMin));
 
   addProperty("numMinInputs", Property(this, &MinModel::getNumMinInputs, &MinModel::setNumMinInputs));
@@ -54,9 +55,12 @@
 void
 MinModel::output(const TaskInfo&)
 {
-  mMin = getInputPort(0)->getValue().toMatrix();
-  for (unsigned i = 1; i < getNumInputPorts(); ++i)
-    mMin = LinAlg::min(mMin, getInputPort(i)->getValue().toMatrix());
+  MatrixPortHandle mh = getInputPort(0)->toMatrixPortHandle();
+  mMin = mh.getMatrixValue();
+  for (unsigned i = 1; i < getNumInputPorts(); ++i) {
+    MatrixPortHandle mh = getInputPort(i)->toMatrixPortHandle();
+    mMin = LinAlg::min(mMin, mh.getMatrixValue());
+  }
 }
 
 const Matrix&

Modified: trunk/OpenFDM/src/OpenFDM/Model.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Model.cpp	2005-12-04 19:17:24 UTC (rev 83)
+++ trunk/OpenFDM/src/OpenFDM/Model.cpp	2005-12-07 20:40:50 UTC (rev 84)
@@ -291,6 +291,17 @@
 }
 
 void
+Model::setOutputPort(unsigned i, const std::string& name,
+                     PortInterface* portInterface)
+{
+  OpenFDMAssert(i < mOutputPorts.size());
+  Port* port = new Port;
+  port->setPortInterface(portInterface);
+  port->setName(name);
+  mOutputPorts[i] = port;
+}
+
+void
 Model::setParent(ModelGroup* modelGroup)
 {
   if (mParentModel) {

Modified: trunk/OpenFDM/src/OpenFDM/Model.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Model.h	2005-12-04 19:17:24 UTC (rev 83)
+++ trunk/OpenFDM/src/OpenFDM/Model.h	2005-12-07 20:40:50 UTC (rev 84)
@@ -47,8 +47,8 @@
     else
       return 0;
   }
-  // FIXME, should not be a virtual function
-  virtual real_type getRealValue(void)
+  // FIXME, move evaluate into seperate method
+  real_type getRealValue(void)
   { evaluate(); return mValue(1, 1); }
 protected:
   Matrix mValue;
@@ -57,8 +57,8 @@
 class MatrixPortInterface : public RealPortInterface {
 public:
   virtual MatrixPortInterface* toMatrixPortInterface(void) { return this; }
-  // FIXME, should not be a virtual function
-  virtual const Matrix& getMatrixValue(void)
+  // FIXME, move evaluate into seperate method
+  const Matrix& getMatrixValue(void)
   { evaluate(); return mValue; }
 };
 
@@ -70,14 +70,43 @@
   PropertyPortInterface(const Property& property) : mProperty(property)
   { }
   virtual void evaluate(void)
-  {
-    mValue = mProperty.getValue().toMatrix();
-  }
+  { mValue = mProperty.getValue().toMatrix(); }
   virtual bool isConnected(void) const
   { return mProperty.isValid(); }
 private:
   mutable Property mProperty;
 };
+/// Just a getter used for now
+template<typename M>
+class RealGetterPortInterface : public MatrixPortInterface {
+public:
+  typedef const real_type& (M::*Getter) () const;
+  RealGetterPortInterface(M* sourceModel, Getter getter) :
+    mSourceModel(sourceModel), mGetter(getter)
+  { }
+  virtual void evaluate(void)
+  { mValue(1, 1) = (mSourceModel->*mGetter)(); }
+  virtual bool isConnected(void) const
+  { return mSourceModel && mGetter; }
+private:
+  managed_ptr<M> mSourceModel;
+  Getter mGetter;
+};
+template<typename M>
+class MatrixGetterPortInterface : public MatrixPortInterface {
+public:
+  typedef const Matrix& (M::*Getter) () const;
+  MatrixGetterPortInterface(M* sourceModel, Getter getter) :
+    mSourceModel(sourceModel), mGetter(getter)
+  { }
+  virtual void evaluate(void)
+  { mValue = (mSourceModel->*mGetter)(); }
+  virtual bool isConnected(void) const
+  { return mSourceModel && mGetter; }
+private:
+  managed_ptr<M> mSourceModel;
+  Getter mGetter;
+};
 
 class RealPortHandle {
 public:
@@ -159,8 +188,22 @@
 
   /// returns true if this port has a source port connected to it
   bool isConnected() const
-  { return mPortInterface->isConnected(); }
+  { return mPortInterface && mPortInterface->isConnected(); }
 
+  /// returns true if the source port sourcePort is the value source for the
+  /// current port
+  bool isConnectedTo(const Port* sourcePort) const
+  {
+    const Port* port = mSourcePort;
+    while (port) {
+      if (sourcePort == port)
+        return true;
+      port = port->mSourcePort;
+    }
+
+    return false;
+  }
+
   RealPortHandle toRealPortHandle(void)
   { return RealPortHandle(mPortInterface->toRealPortInterface()); }
   MatrixPortHandle toMatrixPortHandle(void)
@@ -176,14 +219,16 @@
   /// Generic thing. Don't use if you don't have to
   Variant getValue(void)
   {
-    RealPortInterface* realPortInterface
-      = mPortInterface->toRealPortInterface();
-    if (realPortInterface)
-      return Variant(realPortInterface->getRealValue());
-    MatrixPortInterface* matrixPortInterface
-      = mPortInterface->toMatrixPortInterface();
-    if (matrixPortInterface)
-      return Variant(matrixPortInterface->getMatrixValue());
+    if (mPortInterface) {
+      RealPortInterface* realPortInterface
+        = mPortInterface->toRealPortInterface();
+      if (realPortInterface)
+        return Variant(realPortInterface->getRealValue());
+      MatrixPortInterface* matrixPortInterface
+        = mPortInterface->toMatrixPortInterface();
+      if (matrixPortInterface)
+        return Variant(matrixPortInterface->getMatrixValue());
+    }
     return Variant();
   }
 
@@ -361,9 +406,21 @@
   void setNumOutputPorts(unsigned num);
 
   /// Sets the name of the i-th output property.
+  /// obsolete ...
   void setOutputPort(unsigned i, const std::string& name,
                      const Property& prop);
-
+  /// might be private ...
+  void setOutputPort(unsigned i, const std::string& name,
+                     PortInterface* portInterface);
+  /// the real used interface
+  template<typename M>
+  void setOutputPort(unsigned i, const std::string& name, M* model,
+                     const real_type& (M::*getter)(void) const)
+  { setOutputPort(i, name, new RealGetterPortInterface<M>(model, getter)); }
+  template<typename M>
+  void setOutputPort(unsigned i, const std::string& name, M* model,
+                     const Matrix& (M::*getter)(void) const)
+  { setOutputPort(i, name, new MatrixGetterPortInterface<M>(model, getter)); }
 private:
   // Sets the parent model.
   // That is the one which is informed if the number of states changes.

Modified: trunk/OpenFDM/src/OpenFDM/ModelGroup.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/ModelGroup.cpp	2005-12-04 19:17:24 UTC (rev 83)
+++ trunk/OpenFDM/src/OpenFDM/ModelGroup.cpp	2005-12-07 20:40:50 UTC (rev 84)
@@ -172,8 +172,11 @@
 {
   // Try to resolve direct feedthrough dependencies.
   // Bail out if not possible.
-  if (!sortModels())
+  if (!sortModels()) {
+    Log(Model, Error) << "Could not sort models of ModelGroup \"" << getName()
+                      << "\"!"<< endl;
     return false;
+  }
   // Just init all children.
   ModelList::iterator it;
   for (it = mModels.begin(); it != mModels.end(); ++it) {
@@ -304,7 +307,18 @@
   }
 }
 
+/// Returns true if the given Model is the source for the input port inputPort
 bool
+ModelGroup::dependsOn(Port* inputPort, Model* model)
+{
+  for (unsigned k = 0; k < model->getNumOutputPorts(); ++k) {
+    if (inputPort->isConnectedTo(model->getOutputPort(k)))
+      return true;
+  }
+  return false;
+}
+
+bool
 ModelGroup::appendDependecies(const Model* firstModel, Model* model, ModelList& newList)
 {
   // If the model in question does not have dependencies, stop.
@@ -314,18 +328,13 @@
   // Check, all inputs for dependencies.
   unsigned numInputs = model->getNumInputPorts();
   for (unsigned i = 0; i < numInputs; ++i) {
-    Property prop = model->getInputPort(i)->getProperty();
-    // might happen if some inputs are disabled
-    if (!prop.isValid())
-      continue;
+    // Determine the model which is the source for this port
+    Port* port = model->getInputPort(i);
 
-    // Get the dependent model.
-    Object* object = prop.getObject();
-
     // Check if it is still in the list to be scheduled.
     ModelList::iterator it = mModels.begin();
     while (it != mModels.end()) {
-      if (*it == object)
+      if (dependsOn(port, *it))
         break;
       ++it;
     }
@@ -353,6 +362,8 @@
     // push that one in question.
     newList.push_back(tmpModel);
   }
+
+  return true;
 }
 
 bool

Modified: trunk/OpenFDM/src/OpenFDM/ModelGroup.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/ModelGroup.h	2005-12-04 19:17:24 UTC (rev 83)
+++ trunk/OpenFDM/src/OpenFDM/ModelGroup.h	2005-12-07 20:40:50 UTC (rev 84)
@@ -56,7 +56,8 @@
 private:
   typedef std::vector<shared_ptr<Model> > ModelList;
 
-  /// Helper function to sort the models according their dependencies
+  /// Helper functions to sort the models according their dependencies
+  static bool dependsOn(Port* inputPort, Model* model);
   bool appendDependecies(const Model* firstModel, Model* model,
                          ModelList& newList);
   /// Sorts the models depending their dependencies

Modified: trunk/OpenFDM/src/OpenFDM/PrismaticJoint.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/PrismaticJoint.cpp	2005-12-04 19:17:24 UTC (rev 83)
+++ trunk/OpenFDM/src/OpenFDM/PrismaticJoint.cpp	2005-12-07 20:40:50 UTC (rev 84)
@@ -27,8 +27,8 @@
   mPosition = Vector3::zeros();
 
   setNumOutputPorts(2);
-  setOutputPort(0, "jointPos", Property(this, &PrismaticJoint::getJointPos));
-  setOutputPort(1, "jointVel", Property(this, &PrismaticJoint::getJointVel));
+  setOutputPort(0, "jointPos", this, &PrismaticJoint::getJointPos);
+  setOutputPort(1, "jointVel", this, &PrismaticJoint::getJointVel);
 }
 
 PrismaticJoint::~PrismaticJoint(void)

Modified: trunk/OpenFDM/src/OpenFDM/PrismaticJoint.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/PrismaticJoint.h	2005-12-04 19:17:24 UTC (rev 83)
+++ trunk/OpenFDM/src/OpenFDM/PrismaticJoint.h	2005-12-07 20:40:50 UTC (rev 84)
@@ -36,7 +36,7 @@
 
   /** Returns the joint position.
    */
-  real_type getJointPos(void) const
+  const real_type& getJointPos(void) const
   { return mJointPosition; }
 
   /** Sets the joint position.
@@ -45,7 +45,7 @@
 
   /** Returns the joint velocity.
    */
-  real_type getJointVel(void) const
+  const real_type& getJointVel(void) const
   { return mJointVelocity; }
 
   /** Sets the joint velocity.

Modified: trunk/OpenFDM/src/OpenFDM/Product.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Product.cpp	2005-12-04 19:17:24 UTC (rev 83)
+++ trunk/OpenFDM/src/OpenFDM/Product.cpp	2005-12-07 20:40:50 UTC (rev 84)
@@ -21,7 +21,8 @@
   setInputPortName(1, "*");
   
   setNumOutputPorts(1);
-  setOutputPort(0, "output", Property(this, &Product::getProduct));
+  setOutputPort(0, "output", this, &Product::getProduct);
+
   addProperty("output", Property(this, &Product::getProduct));
 
   addProperty("numFactors", Property(this, &Product::getNumFactors, &Product::setNumFactors));
@@ -45,7 +46,6 @@
     if (Size(1,1) != size(a))
       return false;
   }
-  mProduct.resize(1, 1);
   mProduct.resize(getInputPort(0)->getValue().toMatrix());
   return true;
 }
@@ -53,13 +53,14 @@
 void
 Product::output(const TaskInfo&)
 {
-  mProduct = getInputPort(0)->getValue().toMatrix();
+  MatrixPortHandle mh = getInputPort(0)->toMatrixPortHandle();
+  mProduct = mh.getMatrixValue();
   for (unsigned i = 1; i < getNumInputPorts(); ++i) {
-    Matrix a = getInputPort(i)->getValue().toMatrix();
+    RealPortHandle rh = getInputPort(i)->toRealPortHandle();
     if (getInputPortName(i) == "*")
-      mProduct(1,1) *= a(1,1);
+      mProduct *= rh.getRealValue();
     else
-      mProduct(1,1) /= a(1,1);
+      mProduct *= 1/rh.getRealValue();
   }
 }
 

Modified: trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp	2005-12-04 19:17:24 UTC (rev 83)
+++ trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp	2005-12-07 20:40:50 UTC (rev 84)
@@ -28,8 +28,8 @@
   mOrientation = Quaternion::unit();
 
   setNumOutputPorts(2);
-  setOutputPort(0, "jointPos", Property(this, &RevoluteJoint::getJointPos));
-  setOutputPort(1, "jointVel", Property(this, &RevoluteJoint::getJointVel));
+  setOutputPort(0, "jointPos", this, &RevoluteJoint::getJointPos);
+  setOutputPort(1, "jointVel", this, &RevoluteJoint::getJointVel);
 }
 
 RevoluteJoint::~RevoluteJoint(void)

Modified: trunk/OpenFDM/src/OpenFDM/RevoluteJoint.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RevoluteJoint.h	2005-12-04 19:17:24 UTC (rev 83)
+++ trunk/OpenFDM/src/OpenFDM/RevoluteJoint.h	2005-12-07 20:40:50 UTC (rev 84)
@@ -36,7 +36,7 @@
 
   /** Returns the joint position.
    */
-  real_type getJointPos(void) const
+  const real_type& getJointPos(void) const
   { return mJointPosition; }
 
   /** Sets the joint position.
@@ -45,7 +45,7 @@
 
   /** Returns the joint velocity.
    */
-  real_type getJointVel(void) const
+  const real_type& getJointVel(void) const
   { return mJointVelocity; }
 
   /** Sets the joint velocity.

Modified: trunk/OpenFDM/src/OpenFDM/Saturation.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Saturation.cpp	2005-12-04 19:17:24 UTC (rev 83)
+++ trunk/OpenFDM/src/OpenFDM/Saturation.cpp	2005-12-07 20:40:50 UTC (rev 84)
@@ -23,7 +23,8 @@
   setInputPortName(0, "input");
   
   setNumOutputPorts(1);
-  setOutputPort(0, "output", Property(this, &Saturation::getOutput));
+  setOutputPort(0, "output", this, &Saturation::getOutput);
+
   addProperty("output", Property(this, &Saturation::getOutput));
 
   addProperty("minSaturation", Property(this, &Saturation::getMinSaturation, &Saturation::setMinSaturation));
@@ -55,16 +56,12 @@
 Saturation::output(const TaskInfo&)
 {
   OpenFDMAssert(getInputPort(0)->isConnected());
-  
-  mOutput = getInputPort(0)->getValue().toMatrix();
-  unsigned r = rows(mOutput);
-  unsigned c = cols(mOutput);
-  if (0 < rows(mMaxSaturation) && 0 < cols(mMaxSaturation)) {
+  MatrixPortHandle mh = getInputPort(0)->toMatrixPortHandle();
+  mOutput = mh.getMatrixValue();
+  if (0 < rows(mMaxSaturation) && 0 < cols(mMaxSaturation))
     mOutput = LinAlg::min(mOutput, mMaxSaturation);
-  }
-  if (0 < rows(mMinSaturation) && 0 < cols(mMinSaturation)) {
+  if (0 < rows(mMinSaturation) && 0 < cols(mMinSaturation))
     mOutput = LinAlg::max(mOutput, mMinSaturation);
-  }
 }
 
 const Matrix&

Modified: trunk/OpenFDM/src/OpenFDM/SimpleGear.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/SimpleGear.cpp	2005-12-04 19:17:24 UTC (rev 83)
+++ trunk/OpenFDM/src/OpenFDM/SimpleGear.cpp	2005-12-07 20:40:50 UTC (rev 84)
@@ -59,10 +59,14 @@
 {
   if (nonZeroIntersection(taskInfo.getSampleTimeSet(),
                           SampleTime::PerTimestep)) {
-    if (getInputPort("brakeCommand")->isConnected())
-      mBrake = getInputPort("brakeCommand")->getValue().toReal();
-    if (getInputPort("steeringAngle")->isConnected())
-      mSteeringAngle = getInputPort("steeringAngle")->getValue().toReal();
+    if (getInputPort("brakeCommand")->isConnected()) {
+      RealPortHandle rh = getInputPort("brakeCommand")->toRealPortHandle();
+      mBrake = rh.getRealValue();
+    }
+    if (getInputPort("steeringAngle")->isConnected()) {
+      RealPortHandle rh = getInputPort("steeringAngle")->toRealPortHandle();
+      mSteeringAngle = rh.getRealValue();
+    }
   }
 
   Contact::output(taskInfo);

Modified: trunk/OpenFDM/src/OpenFDM/Summer.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Summer.cpp	2005-12-04 19:17:24 UTC (rev 83)
+++ trunk/OpenFDM/src/OpenFDM/Summer.cpp	2005-12-07 20:40:50 UTC (rev 84)
@@ -22,7 +22,8 @@
   setInputPortName(1, "+");
   
   setNumOutputPorts(1);
-  setOutputPort(0, "output", Property(this, &Summer::getSum));
+  setOutputPort(0, "output", this, &Summer::getSum);
+
   addProperty("output", Property(this, &Summer::getSum));
 
   addProperty("numSummands", Property(this, &Summer::getNumSummands, &Summer::setNumSummands));
@@ -56,11 +57,12 @@
 {
   mSum.clear();
   for (unsigned i = 0; i < getNumInputPorts(); ++i) {
-    Matrix a = getInputPort(i)->getValue().toMatrix();
+    /// FIXME could be preevaluated
+    MatrixPortHandle ph = getInputPort(i)->toMatrixPortHandle();
     if (getInputPortName(i) == "-")
-      mSum -= a;
+      mSum -= ph.getMatrixValue();
     else
-      mSum += a;
+      mSum += ph.getMatrixValue();
   }
 }
 

Modified: trunk/OpenFDM/src/OpenFDM/Table.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Table.h	2005-12-04 19:17:24 UTC (rev 83)
+++ trunk/OpenFDM/src/OpenFDM/Table.h	2005-12-07 20:40:50 UTC (rev 84)
@@ -288,8 +288,8 @@
   {
     OpenFDMAssert(getInputPort(0)->isConnected());
     TableData<1>::InterpVector interpVec;
-    real_type iv = getInputPort(0)->getValue().toReal();
-    interpVec(1) = mTableLookup.lookup(iv);
+    RealPortHandle rh = getInputPort(0)->toRealPortHandle();
+    interpVec(1) = mTableLookup.lookup(rh.getRealValue());
     mOutput = mTableData.interpolate(interpVec);
   }
 

Modified: trunk/OpenFDM/src/OpenFDM/TimeDerivative.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/TimeDerivative.cpp	2005-12-04 19:17:24 UTC (rev 83)
+++ trunk/OpenFDM/src/OpenFDM/TimeDerivative.cpp	2005-12-07 20:40:50 UTC (rev 84)
@@ -14,7 +14,8 @@
   setNumInputPorts(1);
 
   setNumOutputPorts(1);
-  setOutputPort(0, "output", Property(this, &TimeDerivative::getDerivativeOutput));
+  setOutputPort(0, "output", this, &TimeDerivative::getDerivativeOutput);
+
   addProperty("output", Property(this, &TimeDerivative::getDerivativeOutput));
 }
 
@@ -39,19 +40,18 @@
 TimeDerivative::output(const TaskInfo&)
 {
   OpenFDMAssert(getInputPort(0)->isConnected());
-
+  MatrixPortHandle mh = getInputPort(0)->toMatrixPortHandle();
   // If we are here at the first time, dt is set to zero.
   // So, computing a derivative is not possible in the first step.
   // Prepare zero output in this case.
   if (mDt != 0.0) {
-    Matrix input = getInputPort(0)->getValue().toMatrix();
-    OpenFDMAssert(size(input) == size(mPastInput));
-    if (size(input) == size(mPastInput)) {
-      mDerivativeOutput = input - mPastInput;
+    OpenFDMAssert(size(mh.getMatrixValue()) == size(mPastInput));
+    if (size(mh.getMatrixValue()) == size(mPastInput)) {
+      mDerivativeOutput = mh.getMatrixValue() - mPastInput;
       mDerivativeOutput *= 1/mDt;
     }
   } else {
-    mDerivativeOutput.resize(getInputPort(0)->getValue().toMatrix());
+    mDerivativeOutput.resize(mh.getMatrixValue());
     mDerivativeOutput.clear();
   }
 }
@@ -64,7 +64,8 @@
   // FIXME
   real_type dt = (*taskInfo.getSampleTimeSet().begin()).getSampleTime();
   // Updating is just storing required information for the next output step.
-  mPastInput = getInputPort(0)->getValue().toMatrix();
+  MatrixPortHandle mh = getInputPort(0)->toMatrixPortHandle();
+  mPastInput = mh.getMatrixValue();
   mDt = dt;
 }
 

Modified: trunk/OpenFDM/src/OpenFDM/TransferFunction.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/TransferFunction.cpp	2005-12-04 19:17:24 UTC (rev 83)
+++ trunk/OpenFDM/src/OpenFDM/TransferFunction.cpp	2005-12-07 20:40:50 UTC (rev 84)
@@ -128,7 +128,8 @@
 DiscreteTransferFunction::output(const TaskInfo&)
 {
   // Compute the output ...
-  real_type input = getInputPort(0)->getValue().toReal();
+  RealPortHandle rh = getInputPort(0)->toRealPortHandle();
+  real_type input = rh.getRealValue();
   mOutput = dot(mNumNorm, mState) + mD*input;
 }
 
@@ -141,7 +142,8 @@
   if (0 < rows(mState)) {
     // FIXME: use exponential integration scheme here ...
     // looks very benificial, since it is exact here!
-    real_type input = getInputPort(0)->getValue().toReal();
+    RealPortHandle rh = getInputPort(0)->toRealPortHandle();
+    real_type input = rh.getRealValue();
     if (mState.size() == 1) {
       /// On dimensional exponetial integrator ...
       real_type z = -dt*dot(mDenNorm, mState);



From frohlich at berlios.de  Wed Dec  7 21:57:41 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Wed, 7 Dec 2005 21:57:41 +0100
Subject: [OpenFDM-svn] r85 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200512072057.jB7Kvf9T012517@sheep.berlios.de>

Author: frohlich
Date: 2005-12-07 21:57:35 +0100 (Wed, 07 Dec 2005)
New Revision: 85

Modified:
   trunk/OpenFDM/src/OpenFDM/Frame.cpp
   trunk/OpenFDM/src/OpenFDM/Frame.h
   trunk/OpenFDM/src/OpenFDM/Model.cpp
   trunk/OpenFDM/src/OpenFDM/Model.h
   trunk/OpenFDM/src/OpenFDM/Object.cpp
   trunk/OpenFDM/src/OpenFDM/Object.h
Log:
Move name property into Object


Modified: trunk/OpenFDM/src/OpenFDM/Frame.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Frame.cpp	2005-12-07 20:40:50 UTC (rev 84)
+++ trunk/OpenFDM/src/OpenFDM/Frame.cpp	2005-12-07 20:57:35 UTC (rev 85)
@@ -15,7 +15,7 @@
 namespace OpenFDM {
 
 Frame::Frame(const std::string& name) :
-  mName(name),
+  Object(name),
   mDirtyPos(true),
   mDirtySpVel(true),
   mDirtySpAccel(true),
@@ -27,7 +27,6 @@
   setRelVel(Vector6::zeros());
   setRelAccel(Vector6::zeros());
 
-  addProperty("name", Property(this, &Frame::getName, &Frame::setName));
   addProperty("position", Property(this, &Frame::getPosition));
   addProperty("orienatation", Property(this, &Frame::getOrientation));
   addProperty("relVel", Property(this, &Frame::getRelVel));

Modified: trunk/OpenFDM/src/OpenFDM/Frame.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Frame.h	2005-12-07 20:40:50 UTC (rev 84)
+++ trunk/OpenFDM/src/OpenFDM/Frame.h	2005-12-07 20:57:35 UTC (rev 85)
@@ -65,13 +65,6 @@
   /// Cast to a const RigidBody Object if it is one.
   virtual const RigidBody* toRigidBody(void) const;
 
-  /// Set the name of the Frame FIXME: move into Object ...
-  void setName(const std::string& name)
-  { mName = name; }
-  /// The name of the Frame FIXME: move into Object ...
-  const std::string& getName(void) const
-  { return mName; }
-
   /// Return the parent frame.
   Frame* getParentFrame(void)
   { return mParentFrame; }
@@ -639,9 +632,6 @@
   managed_ptr<Frame> mParentFrame;
   // The list of child frames.
   ChildFrameList mChildFrames;
-
-  /// The frame's name. Might move into Object
-  std::string mName;
 };
 
 class FreeFrame

Modified: trunk/OpenFDM/src/OpenFDM/Model.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Model.cpp	2005-12-07 20:40:50 UTC (rev 84)
+++ trunk/OpenFDM/src/OpenFDM/Model.cpp	2005-12-07 20:57:35 UTC (rev 85)
@@ -13,13 +13,11 @@
 const SampleTime SampleTime::Continous(0);
 
 Model::Model(const std::string& name) :
+  Object(name),
   mNumContinousStates(0l),
   mNumDiscreteStates(0l),
-  mDirectFeedThrough(false),
-  mName(name)
+  mDirectFeedThrough(false)
 {
-  addProperty("name",
-              Property(this, &Model::getName, &Model::setName));
   addProperty("numContinousStates",
               Property(this, &Model::getNumContinousStates));
   addProperty("numDiscreteStates",

Modified: trunk/OpenFDM/src/OpenFDM/Model.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Model.h	2005-12-07 20:40:50 UTC (rev 84)
+++ trunk/OpenFDM/src/OpenFDM/Model.h	2005-12-07 20:57:35 UTC (rev 85)
@@ -355,12 +355,6 @@
   { return mSampleTimeSet; }
   
 
-  /// Returns the systems name.
-  const std::string& getName(void) const
-  { return mName; }
-  void setName(const std::string& name)
-  { mName = name; }
-
   /// Returns the number of input properties.
   unsigned getNumInputPorts(void) const
   { return mInputPorts.size(); }
@@ -430,7 +424,6 @@
   void adjustNumContinousStates(unsigned newCount, unsigned oldCount);
   void adjustNumDiscreteStates(unsigned newCount, unsigned oldCount);
 
-  std::string mName;
   managed_ptr<ModelGroup> mParentModel;
   unsigned mNumContinousStates;
   unsigned mNumDiscreteStates;

Modified: trunk/OpenFDM/src/OpenFDM/Object.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Object.cpp	2005-12-07 20:40:50 UTC (rev 84)
+++ trunk/OpenFDM/src/OpenFDM/Object.cpp	2005-12-07 20:57:35 UTC (rev 85)
@@ -7,8 +7,10 @@
 
 namespace OpenFDM {
 
-Object::Object(void)
+Object::Object(const std::string& name) :
+  mName(name)
 {
+  addProperty("name", Property(this, &Object::getName, &Object::setName));
 }
 
 Object::~Object(void)

Modified: trunk/OpenFDM/src/OpenFDM/Object.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Object.h	2005-12-07 20:40:50 UTC (rev 84)
+++ trunk/OpenFDM/src/OpenFDM/Object.h	2005-12-07 20:57:35 UTC (rev 85)
@@ -23,8 +23,14 @@
 class Object
   : public Referenced {
 public:
-  Object(void);
+  Object(const std::string& name = std::string());
 
+  /// Returns the systems name.
+  const std::string& getName(void) const
+  { return mName; }
+  void setName(const std::string& name)
+  { mName = name; }
+
   /// Return the typeinfo for that Object.
   virtual const TypeInfo* const getTypeInfo(void) const;
   
@@ -65,6 +71,9 @@
   void reg(Object** mp);
   void dereg(Object** mp);
 
+  /// The objects name
+  std::string mName;
+
   /// The map of all properties of this object.
   PropertyMap mProperties;
 



From frohlich at berlios.de  Wed Dec  7 22:58:34 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Wed, 7 Dec 2005 22:58:34 +0100
Subject: [OpenFDM-svn] r86 - trunk/OpenFDM/src/JSBSim
Message-ID: <200512072158.jB7LwYXx019083@sheep.berlios.de>

Author: frohlich
Date: 2005-12-07 22:58:31 +0100 (Wed, 07 Dec 2005)
New Revision: 86

Modified:
   trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
Log:
Fix wrong return value check.


Modified: trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
===================================================================
--- trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2005-12-07 20:57:35 UTC (rev 85)
+++ trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2005-12-07 21:58:31 UTC (rev 86)
@@ -506,7 +506,7 @@
 LegacyJSBSimReader::addFCSModel(Model* model)
 {
   // FIXME
-  while (!mVehicle->getModelGroup()->addModel(model)) {
+  while (mVehicle->getModelGroup()->addModel(model) == ~0u) {
     model->setName(model->getName() + "x");
   }
 }



From frohlich at berlios.de  Wed Dec  7 22:58:55 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Wed, 7 Dec 2005 22:58:55 +0100
Subject: [OpenFDM-svn] r87 - trunk/flightgear
Message-ID: <200512072158.jB7Lwtx5019139@sheep.berlios.de>

Author: frohlich
Date: 2005-12-07 22:58:52 +0100 (Wed, 07 Dec 2005)
New Revision: 87

Modified:
   trunk/flightgear/FGPropertyAdapter.h
Log:
Remove unused code


Modified: trunk/flightgear/FGPropertyAdapter.h
===================================================================
--- trunk/flightgear/FGPropertyAdapter.h	2005-12-07 21:58:31 UTC (rev 86)
+++ trunk/flightgear/FGPropertyAdapter.h	2005-12-07 21:58:52 UTC (rev 87)
@@ -132,75 +132,6 @@
   { return new FGIntegerPropertyAdapter(*this); }
 };
 
-class FGRealInputModel :
-    public Model {
-public:
-  FGRealInputModel(const std::string& name, SGPropertyNode* propertyNode) :
-    Model(name),
-    mPropertyNode(propertyNode)
-  {
-    setDirectFeedThrough(false);
-  
-    setNumOutputPorts(1);
-    setOutputPort(0, "value", Property(this, &FGRealInputModel::getValue));
-  }
-  virtual ~FGRealInputModel(void)
-  {
-  }
-
-  void setPropertyNode(SGPropertyNode* propertyNode)
-  { mPropertyNode = propertyNode; }
-  SGPropertyNode* getPropertyNode(void)
-  { return mPropertyNode.ptr(); }
-
-  real_type getValue(void) const
-  {
-    if (mPropertyNode.valid())
-      return mPropertyNode->getDoubleValue();
-    else
-      return 0;
-  }
-private:
-  SGPropertyNode_ptr mPropertyNode;
-};
-
-class FGRealOutputModel :
-    public Model {
-public:
-  FGRealOutputModel(const std::string& name, SGPropertyNode* propertyNode) :
-    Model(name),
-    mPropertyNode(propertyNode)
-  {
-    setDirectFeedThrough(false);
-  
-    setNumInputPorts(1);
-    setInputPortName(0, "input");
-  }
-  virtual ~FGRealOutputModel(void)
-  { }
-
-  void setPropertyNode(SGPropertyNode* propertyNode)
-  { mPropertyNode = propertyNode; }
-  SGPropertyNode* getPropertyNode(void)
-  { return mPropertyNode.ptr(); }
-
-  virtual bool init(void)
-  {
-    OpenFDMAssert(getInputPort(0)->isConnected());
-    return getInputPort(0)->isConnected();
-  }
-
-  virtual void output(void)
-  {
-    OpenFDMAssert(getInputPort(0)->isConnected());
-    if (mPropertyNode.valid())
-      mPropertyNode->setDoubleValue(getInputPort(0)->getValue().toReal());
-  }
-
-private:
-  SGPropertyNode_ptr mPropertyNode;
-};
-
 // This one is used to write changes to input properties into their input
 // models
 class InputChangeListener : public SGPropertyChangeListener {



From frohlich at berlios.de  Wed Dec  7 22:59:28 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Wed, 7 Dec 2005 22:59:28 +0100
Subject: [OpenFDM-svn] r88 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200512072159.jB7LxSTb019216@sheep.berlios.de>

Author: frohlich
Date: 2005-12-07 22:59:20 +0100 (Wed, 07 Dec 2005)
New Revision: 88

Modified:
   trunk/OpenFDM/src/OpenFDM/BinaryFunctionModel.cpp
   trunk/OpenFDM/src/OpenFDM/DirectForce.cpp
   trunk/OpenFDM/src/OpenFDM/Integrator.cpp
   trunk/OpenFDM/src/OpenFDM/Model.cpp
   trunk/OpenFDM/src/OpenFDM/Model.h
   trunk/OpenFDM/src/OpenFDM/Sensor.h
   trunk/OpenFDM/src/OpenFDM/Table.h
   trunk/OpenFDM/src/OpenFDM/TransferFunction.cpp
   trunk/OpenFDM/src/OpenFDM/UnaryFunctionModel.cpp
Log:
Remove now obsolete code


Modified: trunk/OpenFDM/src/OpenFDM/BinaryFunctionModel.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/BinaryFunctionModel.cpp	2005-12-07 21:58:52 UTC (rev 87)
+++ trunk/OpenFDM/src/OpenFDM/BinaryFunctionModel.cpp	2005-12-07 21:59:20 UTC (rev 88)
@@ -21,7 +21,7 @@
   setNumInputPorts(1);
   
   setNumOutputPorts(1);
-  setOutputPort(0, "output", Property(expression));
+  setOutputPort(0, "output", this, &BinaryFunctionModel::getFunctionValue);
 }
 
 BinaryFunctionModel::~BinaryFunctionModel(void)

Modified: trunk/OpenFDM/src/OpenFDM/DirectForce.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/DirectForce.cpp	2005-12-07 21:58:52 UTC (rev 87)
+++ trunk/OpenFDM/src/OpenFDM/DirectForce.cpp	2005-12-07 21:59:20 UTC (rev 88)
@@ -25,8 +25,8 @@
 
   setNumInputPorts(1);
   setInputPortName(0, "magnitude");
-  setNumOutputPorts(1);
-  setOutputPort(0, "force", Property(this, &DirectForce::getForce));
+//   setNumOutputPorts(1);
+//   setOutputPort(0, "force", this, &DirectForce::getForce);
 }
 
 DirectForce::~DirectForce(void)

Modified: trunk/OpenFDM/src/OpenFDM/Integrator.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Integrator.cpp	2005-12-07 21:58:52 UTC (rev 87)
+++ trunk/OpenFDM/src/OpenFDM/Integrator.cpp	2005-12-07 21:59:20 UTC (rev 88)
@@ -16,8 +16,7 @@
   setInputPortName(0, "derivatirve");
 
   setNumOutputPorts(1);
-  setOutputPort(0, "output",
-                Property(this, &Integrator::getIntegralOutput));
+  setOutputPort(0, "output", this, &Integrator::getIntegralOutput);
 
   addProperty("initialValue",
               Property(this, &Integrator::getInitialValue,

Modified: trunk/OpenFDM/src/OpenFDM/Model.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Model.cpp	2005-12-07 21:58:52 UTC (rev 87)
+++ trunk/OpenFDM/src/OpenFDM/Model.cpp	2005-12-07 21:59:20 UTC (rev 88)
@@ -158,34 +158,6 @@
   return mInputPorts[i]->getName();
 }
 
-bool
-Model::setInputPort(unsigned i, const Property& prop)
-{
-  if (mInputPorts.size() <= i) {
-    Log(Model, Error) << "Input port index " << i << "out of range in \""
-                      << getName() << "\"" << endl;
-    return false;
-  }
-
-  mInputPorts[i]->setProperty(prop);
-  return true;
-}
-
-bool
-Model::setInputPort(const std::string& name, const Property& prop)
-{
-  for (unsigned i = 0; i < mInputPorts.size(); ++i) {
-    if (mInputPorts[i]->getName() == name) {
-      setInputPort(i, prop);
-      return true;
-    }
-  }
-
-  Log(Model, Error) << "Input port name " << name << "not found in \""
-                    << getName() << "\"" << endl;
-  return false;
-}
-
 Port*
 Model::getInputPort(const std::string& name)
 {
@@ -279,16 +251,6 @@
 }
 
 void
-Model::setOutputPort(unsigned i, const std::string& name, const Property& prop)
-{
-  OpenFDMAssert(i < mOutputPorts.size());
-  Port* port = new Port;
-  port->setProperty(prop);
-  port->setName(name);
-  mOutputPorts[i] = port;
-}
-
-void
 Model::setOutputPort(unsigned i, const std::string& name,
                      PortInterface* portInterface)
 {

Modified: trunk/OpenFDM/src/OpenFDM/Model.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Model.h	2005-12-07 21:58:52 UTC (rev 87)
+++ trunk/OpenFDM/src/OpenFDM/Model.h	2005-12-07 21:59:20 UTC (rev 88)
@@ -363,11 +363,6 @@
   const std::string& getInputPortName(unsigned i) const;
 
   /// Sets the i-th input property.
-  bool setInputPort(unsigned i, const Property& prop);
-
-  /// Sets the input with the given name property.
-  bool setInputPort(const std::string& name, const Property& prop);
-
   Port* getInputPort(const std::string& name);
   Port* getInputPort(unsigned i)
   {
@@ -400,11 +395,7 @@
   void setNumOutputPorts(unsigned num);
 
   /// Sets the name of the i-th output property.
-  /// obsolete ...
   void setOutputPort(unsigned i, const std::string& name,
-                     const Property& prop);
-  /// might be private ...
-  void setOutputPort(unsigned i, const std::string& name,
                      PortInterface* portInterface);
   /// the real used interface
   template<typename M>

Modified: trunk/OpenFDM/src/OpenFDM/Sensor.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Sensor.h	2005-12-07 21:58:52 UTC (rev 87)
+++ trunk/OpenFDM/src/OpenFDM/Sensor.h	2005-12-07 21:59:20 UTC (rev 88)
@@ -24,7 +24,7 @@
   {
     mAccel.resize(6, 1);
     setNumOutputPorts(1);
-    setOutputPort(0, "nz", Property(this, &Sensor::getNZ));
+    setOutputPort(0, "nz", this, &Sensor::getNZ);
   }
   virtual ~Sensor(void)
   { }
@@ -45,17 +45,17 @@
       return;
     }
     mAccel = frame->getClassicAccel();
+    mNz = mAccel(6, 1)/9.81;
   }
 
-  real_type getNZ(void) const
-  {
-    return mAccel(6, 1)/9.81;
-  }
+  const real_type& getNZ(void) const
+  { return mNz; }
 
 private:
   OpenFDM_NodeImplementation(1);
 
   Matrix mAccel;
+  real_type mNz;
 };
 
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/Table.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Table.h	2005-12-07 21:58:52 UTC (rev 87)
+++ trunk/OpenFDM/src/OpenFDM/Table.h	2005-12-07 21:59:20 UTC (rev 88)
@@ -272,7 +272,8 @@
     setInputPortName(0, "input");
     
     setNumOutputPorts(1);
-    setOutputPort(0, "output", Property(this, &Table1D::getOutput));
+    setOutputPort(0, "output", this, &Table1D::getOutput);
+
     addProperty("output", Property(this, &Table1D::getOutput));
   }
   virtual ~Table1D(void) {}

Modified: trunk/OpenFDM/src/OpenFDM/TransferFunction.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/TransferFunction.cpp	2005-12-07 21:58:52 UTC (rev 87)
+++ trunk/OpenFDM/src/OpenFDM/TransferFunction.cpp	2005-12-07 21:59:20 UTC (rev 88)
@@ -24,7 +24,7 @@
 
   setNumInputPorts(1);
   setNumOutputPorts(1);
-  setOutputPort(0, "output", Property(this, &DiscreteTransferFunction::getOutput));
+  setOutputPort(0, "output", this, &DiscreteTransferFunction::getOutput);
 }
 
 DiscreteTransferFunction::~DiscreteTransferFunction(void)

Modified: trunk/OpenFDM/src/OpenFDM/UnaryFunctionModel.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/UnaryFunctionModel.cpp	2005-12-07 21:58:52 UTC (rev 87)
+++ trunk/OpenFDM/src/OpenFDM/UnaryFunctionModel.cpp	2005-12-07 21:59:20 UTC (rev 88)
@@ -21,7 +21,7 @@
   setNumInputPorts(1);
   
   setNumOutputPorts(1);
-  setOutputPort(0, "output", Property(expression));
+  setOutputPort(0, "output", this, &UnaryFunctionModel::getFunctionValue);
 }
 
 UnaryFunctionModel::~UnaryFunctionModel(void)



From frohlich at berlios.de  Thu Dec  8 08:14:47 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Thu, 8 Dec 2005 08:14:47 +0100
Subject: [OpenFDM-svn] r89 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200512080714.jB87Elaa028480@sheep.berlios.de>

Author: frohlich
Date: 2005-12-08 08:14:33 +0100 (Thu, 08 Dec 2005)
New Revision: 89

Modified:
   trunk/OpenFDM/src/OpenFDM/Model.h
Log:
Small improovements to the hot path for the current transitions phase to the new ports


Modified: trunk/OpenFDM/src/OpenFDM/Model.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Model.h	2005-12-07 21:59:20 UTC (rev 88)
+++ trunk/OpenFDM/src/OpenFDM/Model.h	2005-12-08 07:14:33 UTC (rev 89)
@@ -70,7 +70,16 @@
   PropertyPortInterface(const Property& property) : mProperty(property)
   { }
   virtual void evaluate(void)
-  { mValue = mProperty.getValue().toMatrix(); }
+  {
+    if (mProperty.isRealProperty()) {
+      RealProperty rp = mProperty.toRealProperty();
+      mValue.resize(1, 1);
+      mValue(1, 1) = rp.getValue();
+    } else if (mProperty.isMatrixProperty()) {
+      MatrixProperty mp = mProperty.toMatrixProperty();
+      mValue = mp.getValue();
+    }
+  }
   virtual bool isConnected(void) const
   { return mProperty.isValid(); }
 private:



From frohlich at berlios.de  Thu Dec  8 20:55:24 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Thu, 8 Dec 2005 20:55:24 +0100
Subject: [OpenFDM-svn] r90 - in trunk/OpenFDM/src: JSBSim OpenFDM
Message-ID: <200512081955.jB8JtOMd000080@sheep.berlios.de>

Author: frohlich
Date: 2005-12-08 20:55:06 +0100 (Thu, 08 Dec 2005)
New Revision: 90

Modified:
   trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
   trunk/OpenFDM/src/OpenFDM/Model.h
   trunk/OpenFDM/src/OpenFDM/UnaryFunctionModel.cpp
   trunk/OpenFDM/src/OpenFDM/UnaryFunctionModel.h
Log:
Convert UnaryFunctionModel


Modified: trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
===================================================================
--- trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2005-12-08 07:14:33 UTC (rev 89)
+++ trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2005-12-08 19:55:06 UTC (rev 90)
@@ -485,18 +485,18 @@
 Port*
 LegacyJSBSimReader::addInverterModel(const std::string& name, Port* in)
 {
-  Gain *gain = new Gain(name + " Inverter");
-  gain->getInputPort(0)->connect(in);
-  gain->setGain(-1);
-  addFCSModel(gain);
-  return gain->getOutputPort(0);
+  UnaryFunctionModel *unary
+    = new UnaryFunctionModel(name + " Inverter", UnaryFunctionModel::Minus);
+  unary->getInputPort(0)->connect(in);
+  addFCSModel(unary);
+  return unary->getOutputPort(0);
 }
 
 Port*
 LegacyJSBSimReader::addAbsModel(const std::string& name, Port* in)
 {
   UnaryFunctionModel *unary
-    = new UnaryFunctionModel(name + " Abs", new AbsExpressionImpl);
+    = new UnaryFunctionModel(name + " Abs", UnaryFunctionModel::Abs);
   unary->getInputPort(0)->connect(in);
   addFCSModel(unary);
   return unary->getOutputPort(0);
@@ -853,13 +853,15 @@
           addOutputModel(port, "Gear " + numStr + " Steering Output",
                          "/gear/gear[" + numStr + "]/steering-norm");
 
-          UnaryFunctionModel *unary
-            = new UnaryFunctionModel(name + " Degree Conversion",
-                                     new UnitToSiExpressionImpl(uDegree));
-          unary->getInputPort(0)->connect(gain->getOutputPort(0));
-          addFCSModel(unary);
 
-          sg->getInputPort("steeringAngle")->connect(unary->getOutputPort(0));
+          UnitConversionModel* unitConv
+            = new UnitConversionModel(name + " Degree Conversion",
+                                      UnitConversionModel::UnitToSi,
+                                      uDegree);
+          unitConv->getInputPort(0)->connect(gain->getOutputPort(0));
+          addFCSModel(unitConv);
+
+          sg->getInputPort("steeringAngle")->connect(unitConv->getOutputPort(0));
         }
         
         if (brake == "LEFT") {

Modified: trunk/OpenFDM/src/OpenFDM/Model.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Model.h	2005-12-08 07:14:33 UTC (rev 89)
+++ trunk/OpenFDM/src/OpenFDM/Model.h	2005-12-08 19:55:06 UTC (rev 90)
@@ -119,6 +119,8 @@
 
 class RealPortHandle {
 public:
+  RealPortHandle(void)
+  { }
   RealPortHandle(RealPortInterface* realPortInterface) :
     mRealPortInterface(realPortInterface)
   { }
@@ -132,6 +134,8 @@
 
 class MatrixPortHandle {
 public:
+  MatrixPortHandle(void)
+  { }
   MatrixPortHandle(MatrixPortInterface* matrixPortInterface) :
     mMatrixPortInterface(matrixPortInterface)
   { }

Modified: trunk/OpenFDM/src/OpenFDM/UnaryFunctionModel.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/UnaryFunctionModel.cpp	2005-12-08 07:14:33 UTC (rev 89)
+++ trunk/OpenFDM/src/OpenFDM/UnaryFunctionModel.cpp	2005-12-08 19:55:06 UTC (rev 90)
@@ -11,14 +11,126 @@
 
 namespace OpenFDM {
 
-UnaryFunctionModel::UnaryFunctionModel(const std::string& name,
-                                       UnaryExpressionImpl<real_type>* expression) :
+class UnaryFunctionModelImpl :
+    public Referenced {
+public:
+  void setRealPortHandle(const RealPortHandle& realPortHandle)
+  { mRealPortHandle = realPortHandle; }
+  virtual ~UnaryFunctionModelImpl(void) {}
+  virtual real_type getValue(void) = 0;
+protected:
+  RealPortHandle mRealPortHandle;
+};
+
+/// Implementations of various similar functions.
+class AbsUnaryFunctionModelImpl :
+    public UnaryFunctionModelImpl {
+private:
+  virtual real_type getValue(void)
+  { return fabs(mRealPortHandle.getRealValue()); }
+};
+
+class AcosUnaryFunctionModelImpl :
+    public UnaryFunctionModelImpl {
+private:
+  virtual real_type getValue(void)
+  { return acos(mRealPortHandle.getRealValue()); }
+};
+
+class AsinUnaryFunctionModelImpl :
+    public UnaryFunctionModelImpl {
+private:
+  virtual real_type getValue(void)
+  { return asin(mRealPortHandle.getRealValue()); }
+};
+
+class AtanUnaryFunctionModelImpl :
+    public UnaryFunctionModelImpl {
+private:
+  virtual real_type getValue(void)
+  { return atan(mRealPortHandle.getRealValue()); }
+};
+
+class CeilUnaryFunctionModelImpl :
+    public UnaryFunctionModelImpl {
+private:
+  virtual real_type getValue(void)
+  { return ceil(mRealPortHandle.getRealValue()); }
+};
+
+class CosUnaryFunctionModelImpl :
+    public UnaryFunctionModelImpl {
+private:
+  virtual real_type getValue(void)
+  { return cos(mRealPortHandle.getRealValue()); }
+};
+
+class ExpUnaryFunctionModelImpl :
+    public UnaryFunctionModelImpl {
+private:
+  virtual real_type getValue(void)
+  { return exp(mRealPortHandle.getRealValue()); }
+};
+
+class FloorUnaryFunctionModelImpl :
+    public UnaryFunctionModelImpl {
+private:
+  virtual real_type getValue(void)
+  { return floor(mRealPortHandle.getRealValue()); }
+};
+
+class LogUnaryFunctionModelImpl :
+    public UnaryFunctionModelImpl {
+private:
+  virtual real_type getValue(void)
+  { return log(mRealPortHandle.getRealValue()); }
+};
+
+class Log10UnaryFunctionModelImpl :
+    public UnaryFunctionModelImpl {
+private:
+  virtual real_type getValue(void)
+  { return log10(mRealPortHandle.getRealValue()); }
+};
+
+class MinusUnaryFunctionModelImpl :
+    public UnaryFunctionModelImpl {
+private:
+  virtual real_type getValue(void)
+  { return -mRealPortHandle.getRealValue(); }
+};
+
+class SqrUnaryFunctionModelImpl :
+    public UnaryFunctionModelImpl {
+private:
+  virtual real_type getValue(void)
+  { real_type v = mRealPortHandle.getRealValue(); return v*v; }
+};
+
+class SqrtUnaryFunctionModelImpl :
+    public UnaryFunctionModelImpl {
+private:
+  virtual real_type getValue(void)
+  { return sqrt(mRealPortHandle.getRealValue()); }
+};
+
+class TanUnaryFunctionModelImpl :
+    public UnaryFunctionModelImpl {
+private:
+  virtual real_type getValue(void)
+  { return tan(mRealPortHandle.getRealValue()); }
+};
+
+UnaryFunctionModel::UnaryFunctionModel(const std::string& name, Type type) :
   Model(name),
-  mUnaryExpression(expression)
+  mType(type)
 {
+  setType(type);
+
   setDirectFeedThrough(true);
 
   setNumInputPorts(1);
+  setInputPortName(0, "input");
   
   setNumOutputPorts(1);
   setOutputPort(0, "output", this, &UnaryFunctionModel::getFunctionValue);
@@ -31,17 +143,17 @@
 bool
 UnaryFunctionModel::init(void)
 {
-  OpenFDMAssert(mUnaryExpression);
-  mUnaryExpression->setInputProperty(getInputPort(0)->getProperty());
-  OpenFDMAssert(mUnaryExpression->isValid());
-  return mUnaryExpression->isValid();
+  OpenFDMAssert(mImpl);
+  OpenFDMAssert(getInputPort(0)->isConnected());
+  mImpl->setRealPortHandle(getInputPort(0)->toRealPortHandle());
+  return getInputPort(0)->isConnected();
 }
 
 void
 UnaryFunctionModel::output(const TaskInfo&)
 {
   // Evaluate the expression.
-  mFunctionValue = mUnaryExpression->getValue();
+  mFunctionValue = mImpl->getValue();
 }
 
 const real_type&
@@ -50,4 +162,127 @@
   return mFunctionValue;
 }
 
+void
+UnaryFunctionModel::setType(UnaryFunctionModel::Type type)
+{
+  switch (type) {
+  case Abs:
+    mImpl = new AbsUnaryFunctionModelImpl;
+    break;
+  case Acos:
+    mImpl = new AcosUnaryFunctionModelImpl;
+    break;
+  case Asin:
+    mImpl = new AsinUnaryFunctionModelImpl;
+    break;
+  case Atan:
+    mImpl = new AtanUnaryFunctionModelImpl;
+    break;
+  case Ceil:
+    mImpl = new CeilUnaryFunctionModelImpl;
+    break;
+  case Cos:
+    mImpl = new CosUnaryFunctionModelImpl;
+    break;
+  case Exp:
+    mImpl = new ExpUnaryFunctionModelImpl;
+    break;
+  case Floor:
+    mImpl = new FloorUnaryFunctionModelImpl;
+    break;
+  case Log:
+    mImpl = new LogUnaryFunctionModelImpl;
+    break;
+  case Log10:
+    mImpl = new Log10UnaryFunctionModelImpl;
+    break;
+  case Minus:
+    mImpl = new MinusUnaryFunctionModelImpl;
+    break;
+  case Sqr:
+    mImpl = new SqrUnaryFunctionModelImpl;
+    break;
+  case Sqrt:
+    mImpl = new SqrtUnaryFunctionModelImpl;
+    break;
+  case Tan:
+    mImpl = new TanUnaryFunctionModelImpl;
+    break;
+  default:
+    break;
+  }
+}
+
+UnaryFunctionModel::Type
+UnaryFunctionModel::getType(void) const
+{
+}
+
+
+
+UnitConversionModel::UnitConversionModel(const std::string& name,
+                                         Type type, Unit unit) :
+  Model(name),
+  mType(type),
+  mUnit(unit)
+{
+  setDirectFeedThrough(true);
+
+  setNumInputPorts(1);
+  setInputPortName(0, "input");
+  
+  setNumOutputPorts(1);
+  setOutputPort(0, "output", this, &UnitConversionModel::getFunctionValue);
+}
+
+UnitConversionModel::~UnitConversionModel(void)
+{
+}
+
+bool
+UnitConversionModel::init(void)
+{
+}
+
+void
+UnitConversionModel::output(const TaskInfo&)
+{
+  real_type value = getInputPort(0)->toRealPortHandle().getRealValue();
+  if (mType == UnitToSi) {
+    mValue = convertTo(mUnit, value);
+  } else {
+    mValue = convertFrom(mUnit, value);
+  }
+}
+
+const real_type&
+UnitConversionModel::getFunctionValue(void) const
+{
+  return mValue;
+}
+
+void
+UnitConversionModel::setType(UnitConversionModel::Type type)
+{
+  mType = type;
+}
+
+UnitConversionModel::Type
+UnitConversionModel::getType(void) const
+{
+  return mType;
+}
+
+void
+UnitConversionModel::setUnit(Unit unit)
+{
+  mUnit = unit;
+}
+
+Unit
+UnitConversionModel::getUnit(void) const
+{
+  return mUnit;
+}
+
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/UnaryFunctionModel.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/UnaryFunctionModel.h	2005-12-08 07:14:33 UTC (rev 89)
+++ trunk/OpenFDM/src/OpenFDM/UnaryFunctionModel.h	2005-12-08 19:55:06 UTC (rev 90)
@@ -15,12 +15,30 @@
 
 namespace OpenFDM {
 
+class UnaryFunctionModelImpl;
+
 /// Class representing a model with exactly one input.
 class UnaryFunctionModel :
     public Model {
 public:
-  UnaryFunctionModel(const std::string& name,
-                     UnaryExpressionImpl<real_type>* expression);
+  enum Type {
+    Abs,
+    Acos,
+    Asin,
+    Atan,
+    Ceil,
+    Cos,
+    Exp,
+    Floor,
+    Log,
+    Log10,
+    Minus,
+    Sqr,
+    Sqrt,
+    Tan
+  };
+
+  UnaryFunctionModel(const std::string& name, Type type);
   virtual ~UnaryFunctionModel(void);
 
   virtual bool init(void);
@@ -28,12 +46,43 @@
 
   const real_type& getFunctionValue(void) const;
 
+  void setType(Type type);
+  Type getType(void) const;
+
 private:
-  shared_ptr<UnaryExpressionImpl<real_type> > mUnaryExpression;
-
+  shared_ptr<UnaryFunctionModelImpl> mImpl;
+  Type mType;
   real_type mFunctionValue;
 };
 
+class UnitConversionModel :
+    public Model {
+public:
+  enum Type {
+    UnitToSi,
+    SiToUnit
+  };
+
+  UnitConversionModel(const std::string& name, Type type, Unit unit);
+  virtual ~UnitConversionModel(void);
+
+  virtual bool init(void);
+  virtual void output(const TaskInfo&);
+
+  const real_type& getFunctionValue(void) const;
+
+  void setType(Type type);
+  Type getType(void) const;
+
+  void setUnit(Unit unit);
+  Unit getUnit(void) const;
+
+private:
+  Type mType;
+  Unit mUnit;
+  real_type mValue;
+};
+
 } // namespace OpenFDM
 
 #endif



From frohlich at berlios.de  Fri Dec  9 07:35:52 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Fri, 9 Dec 2005 07:35:52 +0100
Subject: [OpenFDM-svn] r91 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200512090635.jB96ZqFF030573@sheep.berlios.de>

Author: frohlich
Date: 2005-12-09 07:35:20 +0100 (Fri, 09 Dec 2005)
New Revision: 91

Modified:
   trunk/OpenFDM/src/OpenFDM/BinaryFunctionModel.cpp
   trunk/OpenFDM/src/OpenFDM/BinaryFunctionModel.h
   trunk/OpenFDM/src/OpenFDM/Expression.h
   trunk/OpenFDM/src/OpenFDM/UnaryFunctionModel.cpp
   trunk/OpenFDM/src/OpenFDM/UnaryFunctionModel.h
Log:
Convert the binary function model, cleanups


Modified: trunk/OpenFDM/src/OpenFDM/BinaryFunctionModel.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/BinaryFunctionModel.cpp	2005-12-08 19:55:06 UTC (rev 90)
+++ trunk/OpenFDM/src/OpenFDM/BinaryFunctionModel.cpp	2005-12-09 06:35:20 UTC (rev 91)
@@ -5,20 +5,53 @@
 #include <string>
 
 #include "Types.h"
-#include "Matrix.h"
 #include "Property.h"
 #include "BinaryFunctionModel.h"
 
 namespace OpenFDM {
 
-BinaryFunctionModel::BinaryFunctionModel(const std::string& name,
-                                         BinaryExpressionImpl<real_type>* expression) :
-  Model(name),
-  mBinaryExpression(expression)
+class BinaryFunctionModelImpl :
+    public Referenced {
+public:
+  virtual ~BinaryFunctionModelImpl(void) {}
+  void setRealPortHandle(unsigned idx, const RealPortHandle& realPortHandle)
+  { mRealPortHandle[idx] = realPortHandle; }
+  virtual real_type getValue(void) = 0;
+protected:
+  RealPortHandle mRealPortHandle[2];
+};
+
+class Atan2BinaryFunctionModelImpl :
+    public BinaryFunctionModelImpl {
+private:
+  virtual real_type getValue(void)
+  { return atan2(mRealPortHandle[0].getRealValue(), mRealPortHandle[1].getRealValue()); }
+};
+
+class PowBinaryFunctionModelImpl :
+    public BinaryFunctionModelImpl {
+private:
+  virtual real_type getValue(void)
+  { return pow(mRealPortHandle[0].getRealValue(), mRealPortHandle[1].getRealValue()); }
+};
+
+class DivBinaryFunctionModelImpl :
+    public BinaryFunctionModelImpl {
+private:
+  virtual real_type getValue(void)
+  { return mRealPortHandle[0].getRealValue() / mRealPortHandle[1].getRealValue(); }
+};
+
+BinaryFunctionModel::BinaryFunctionModel(const std::string& name, Type type) :
+  Model(name)
 {
+  setType(type);
+
   setDirectFeedThrough(true);
 
-  setNumInputPorts(1);
+  setNumInputPorts(2);
+  setInputPortName(0, "input 0");
+  setInputPortName(1, "input 1");
   
   setNumOutputPorts(1);
   setOutputPort(0, "output", this, &BinaryFunctionModel::getFunctionValue);
@@ -31,18 +64,19 @@
 bool
 BinaryFunctionModel::init(void)
 {
-  OpenFDMAssert(mBinaryExpression);
-  mBinaryExpression->setInputProperty(0, getInputPort(0)->getProperty());
-  mBinaryExpression->setInputProperty(1, getInputPort(1)->getProperty());
-  OpenFDMAssert(mBinaryExpression->isValid());
-  return mBinaryExpression->isValid();
+  OpenFDMAssert(mImpl);
+  OpenFDMAssert(getInputPort(0)->isConnected());
+  OpenFDMAssert(getInputPort(1)->isConnected());
+  mImpl->setRealPortHandle(0, getInputPort(0)->toRealPortHandle());
+  mImpl->setRealPortHandle(1, getInputPort(1)->toRealPortHandle());
+  return getInputPort(0)->isConnected() && getInputPort(1)->isConnected();
 }
 
 void
 BinaryFunctionModel::output(const TaskInfo&)
 {
   // Evaluate the expression.
-  mFunctionValue = mBinaryExpression->getValue();
+  mFunctionValue = mImpl->getValue();
 }
 
 const real_type&
@@ -51,4 +85,29 @@
   return mFunctionValue;
 }
 
+void
+BinaryFunctionModel::setType(BinaryFunctionModel::Type type)
+{
+  mType = type;
+  switch (type) {
+  case Atan2:
+    mImpl = new Atan2BinaryFunctionModelImpl;
+    break;
+  case Pow:
+    mImpl = new PowBinaryFunctionModelImpl;
+    break;
+  case Div:
+    mImpl = new DivBinaryFunctionModelImpl;
+    break;
+  default:
+    break;
+  }
+}
+
+BinaryFunctionModel::Type
+BinaryFunctionModel::getType(void) const
+{
+  return mType;
+}
+
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/BinaryFunctionModel.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/BinaryFunctionModel.h	2005-12-08 19:55:06 UTC (rev 90)
+++ trunk/OpenFDM/src/OpenFDM/BinaryFunctionModel.h	2005-12-09 06:35:20 UTC (rev 91)
@@ -8,19 +8,24 @@
 #include <string>
 
 #include "Types.h"
-#include "Matrix.h"
 #include "Property.h"
-#include "Expression.h"
 #include "Model.h"
 
 namespace OpenFDM {
 
+class BinaryFunctionModelImpl;
+
 /// Class representing a model with exactly two inputs.
 class BinaryFunctionModel :
     public Model {
 public:
-  BinaryFunctionModel(const std::string& name,
-                      BinaryExpressionImpl<real_type>* expression);
+  enum Type {
+    Atan2,
+    Pow,
+    Div
+  };
+
+  BinaryFunctionModel(const std::string& name, Type type);
   virtual ~BinaryFunctionModel(void);
 
   virtual bool init(void);
@@ -28,9 +33,12 @@
 
   const real_type& getFunctionValue(void) const;
 
+  void setType(Type type);
+  Type getType(void) const;
+
 private:
-  shared_ptr<BinaryExpressionImpl<real_type> > mBinaryExpression;
-
+  shared_ptr<BinaryFunctionModelImpl> mImpl;
+  Type mType;
   real_type mFunctionValue;
 };
 

Modified: trunk/OpenFDM/src/OpenFDM/Expression.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Expression.h	2005-12-08 19:55:06 UTC (rev 90)
+++ trunk/OpenFDM/src/OpenFDM/Expression.h	2005-12-09 06:35:20 UTC (rev 91)
@@ -87,69 +87,6 @@
   { return fabs(mInput.getValue()); }
 };
 
-class AcosExpressionImpl :
-    public UnaryExpressionImpl<real_type> {
-private:
-  virtual real_type getValue(void) const
-  { return acos(mInput.getValue()); }
-};
-
-class AsinExpressionImpl :
-    public UnaryExpressionImpl<real_type> {
-private:
-  virtual real_type getValue(void) const
-  { return asin(mInput.getValue()); }
-};
-
-class AtanExpressionImpl :
-    public UnaryExpressionImpl<real_type> {
-private:
-  virtual real_type getValue(void) const
-  { return atan(mInput.getValue()); }
-};
-
-class CeilExpressionImpl :
-    public UnaryExpressionImpl<real_type> {
-private:
-  virtual real_type getValue(void) const
-  { return ceil(mInput.getValue()); }
-};
-
-class CosExpressionImpl :
-    public UnaryExpressionImpl<real_type> {
-private:
-  virtual real_type getValue(void) const
-  { return cos(mInput.getValue()); }
-};
-
-class ExpExpressionImpl :
-    public UnaryExpressionImpl<real_type> {
-private:
-  virtual real_type getValue(void) const
-  { return exp(mInput.getValue()); }
-};
-
-class FloorExpressionImpl :
-    public UnaryExpressionImpl<real_type> {
-private:
-  virtual real_type getValue(void) const
-  { return floor(mInput.getValue()); }
-};
-
-class LogExpressionImpl :
-    public UnaryExpressionImpl<real_type> {
-private:
-  virtual real_type getValue(void) const
-  { return log(mInput.getValue()); }
-};
-
-class Log10ExpressionImpl :
-    public UnaryExpressionImpl<real_type> {
-private:
-  virtual real_type getValue(void) const
-  { return log10(mInput.getValue()); }
-};
-
 class MinusExpressionImpl :
     public UnaryExpressionImpl<real_type> {
 private:
@@ -157,27 +94,6 @@
   { return -mInput.getValue(); }
 };
 
-class SqrExpressionImpl :
-    public UnaryExpressionImpl<real_type> {
-private:
-  virtual real_type getValue(void) const
-  { real_type v = mInput.getValue(); return v*v; }
-};
-
-class SqrtExpressionImpl :
-    public UnaryExpressionImpl<real_type> {
-private:
-  virtual real_type getValue(void) const
-  { return sqrt(mInput.getValue()); }
-};
-
-class TanExpressionImpl :
-    public UnaryExpressionImpl<real_type> {
-private:
-  virtual real_type getValue(void) const
-  { return tan(mInput.getValue()); }
-};
-
 class UnitToSiExpressionImpl :
     public UnaryExpressionImpl<real_type> {
 public:
@@ -199,76 +115,6 @@
 };
 
 template<typename T>
-class BinaryExpressionImpl :
-    public ExpressionPropertyImpl<T> {
-public:
-  BinaryExpressionImpl(void) {}
-  virtual ~BinaryExpressionImpl(void) {}
-
-  virtual bool isValid(void) const
-  { return mInput[0].isValid() && mInput[1].isValid(); }
-
-  void setInputProperty(unsigned idx, const Property& prop)
-  {
-    Property tmpHack(prop);
-    TypedProperty<T> tProp = tmpHack.toTypedProperty<T>();
-    if (tProp.isValid())
-      setInputProperty(idx, tProp);
-    else {
-      Property prop2(new RealCastExpressionPropertyImpl(tmpHack));
-      setInputProperty(idx, prop2.toTypedProperty<T>());
-    }
-  }
-  void setInputProperty(unsigned idx, const TypedProperty<T>& prop)
-  { mInput[idx%2] = prop; }
-
-protected:
-  mutable TypedProperty<T> mInput[2];
-};
-
-class Atan2ExpressionImpl :
-    public BinaryExpressionImpl<real_type> {
-private:
-  virtual real_type getValue(void) const
-  { return atan2(mInput[0].getValue(), mInput[1].getValue()); }
-};
-
-class PowExpressionImpl :
-    public BinaryExpressionImpl<real_type> {
-private:
-  virtual real_type getValue(void) const
-  { return pow(mInput[0].getValue(), mInput[1].getValue()); }
-};
-
-class AddExpressionImpl :
-    public BinaryExpressionImpl<real_type> {
-private:
-  virtual real_type getValue(void) const
-  { return mInput[0].getValue() + mInput[1].getValue(); }
-};
-
-class SubExpressionImpl :
-    public BinaryExpressionImpl<real_type> {
-private:
-  virtual real_type getValue(void) const
-  { return mInput[0].getValue() - mInput[1].getValue(); }
-};
-
-class MulExpressionImpl :
-    public BinaryExpressionImpl<real_type> {
-private:
-  virtual real_type getValue(void) const
-  { return mInput[0].getValue() * mInput[1].getValue(); }
-};
-
-class DivExpressionImpl :
-    public BinaryExpressionImpl<real_type> {
-private:
-  virtual real_type getValue(void) const
-  { return mInput[0].getValue() / mInput[1].getValue(); }
-};
-
-template<typename T>
 class MultiExpressionImpl :
     public ExpressionPropertyImpl<T> {
 public:
@@ -344,30 +190,6 @@
   }
 };
 
-class MinExpressionImpl :
-    public MultiExpressionImpl<real_type> {
-private:
-  virtual real_type getValue(void) const
-  {
-    real_type ret = Limits<real_type>::max();
-    for (unsigned i = 0; i < mInputs.size(); ++i)
-      ret = min(ret, mInputs[i].getValue());
-    return ret;
-  }
-};
-
-class MaxExpressionImpl :
-    public MultiExpressionImpl<real_type> {
-private:
-  virtual real_type getValue(void) const
-  {
-    real_type ret = -Limits<real_type>::max();
-    for (unsigned i = 0; i < mInputs.size(); ++i)
-      ret = max(ret, mInputs[i].getValue());
-    return ret;
-  }
-};
-
 template<unsigned numDims>
 class TableExpressionImpl :
     public ExpressionPropertyImpl<real_type> {

Modified: trunk/OpenFDM/src/OpenFDM/UnaryFunctionModel.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/UnaryFunctionModel.cpp	2005-12-08 19:55:06 UTC (rev 90)
+++ trunk/OpenFDM/src/OpenFDM/UnaryFunctionModel.cpp	2005-12-09 06:35:20 UTC (rev 91)
@@ -5,7 +5,6 @@
 #include <string>
 
 #include "Types.h"
-#include "Matrix.h"
 #include "Property.h"
 #include "UnaryFunctionModel.h"
 
@@ -14,9 +13,9 @@
 class UnaryFunctionModelImpl :
     public Referenced {
 public:
+  virtual ~UnaryFunctionModelImpl(void) {}
   void setRealPortHandle(const RealPortHandle& realPortHandle)
   { mRealPortHandle = realPortHandle; }
-  virtual ~UnaryFunctionModelImpl(void) {}
   virtual real_type getValue(void) = 0;
 protected:
   RealPortHandle mRealPortHandle;
@@ -165,6 +164,7 @@
 void
 UnaryFunctionModel::setType(UnaryFunctionModel::Type type)
 {
+  mType = type;
   switch (type) {
   case Abs:
     mImpl = new AbsUnaryFunctionModelImpl;
@@ -216,6 +216,7 @@
 UnaryFunctionModel::Type
 UnaryFunctionModel::getType(void) const
 {
+  return mType;
 }
 
 

Modified: trunk/OpenFDM/src/OpenFDM/UnaryFunctionModel.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/UnaryFunctionModel.h	2005-12-08 19:55:06 UTC (rev 90)
+++ trunk/OpenFDM/src/OpenFDM/UnaryFunctionModel.h	2005-12-09 06:35:20 UTC (rev 91)
@@ -8,9 +8,6 @@
 #include <string>
 
 #include "Types.h"
-#include "Matrix.h"
-#include "Property.h"
-#include "Expression.h"
 #include "Model.h"
 
 namespace OpenFDM {



From frohlich at berlios.de  Fri Dec  9 19:18:35 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Fri, 9 Dec 2005 19:18:35 +0100
Subject: [OpenFDM-svn] r92 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200512091818.jB9IIZCZ012266@sheep.berlios.de>

Author: frohlich
Date: 2005-12-09 19:18:31 +0100 (Fri, 09 Dec 2005)
New Revision: 92

Modified:
   trunk/OpenFDM/src/OpenFDM/Joint.h
Log:
Reduce the number of virtual calls a bit ...


Modified: trunk/OpenFDM/src/OpenFDM/Joint.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Joint.h	2005-12-09 06:35:20 UTC (rev 91)
+++ trunk/OpenFDM/src/OpenFDM/Joint.h	2005-12-09 18:18:31 UTC (rev 92)
@@ -35,63 +35,73 @@
 
   bool isArticulatedJoint(void) const
   {
-    if (!getParentFrame(0))
+    const Frame* parent0 = getParentFrame(0);
+    if (!parent0)
       return false;
-    if (!getParentFrame(1))
+    const Frame* parent1 = getParentFrame(1);
+    if (!parent1)
       return false;
-    if (getParentFrame(1)->isParentFrame(getParentFrame(0)))
+    if (parent1->isParentFrame(parent0))
       return true;
-    if (getParentFrame(0)->isParentFrame(getParentFrame(1)))
+    if (parent0->isParentFrame(parent1))
       return true;
     return false;
   }
 
   Frame* getInboardGroup(void)
   {
-    if (!getParentFrame(0))
+    Frame* parent0 = getParentFrame(0);
+    if (!parent0)
       return 0;
-    if (!getParentFrame(1))
+    Frame* parent1 = getParentFrame(1);
+    if (!parent1)
       return 0;
-    if (getParentFrame(1)->isParentFrame(getParentFrame(0)))
-      return getParentFrame(0);
-    if (getParentFrame(0)->isParentFrame(getParentFrame(1)))
-      return getParentFrame(1);
+    if (parent1->isParentFrame(parent0))
+      return parent0;
+    if (parent0->isParentFrame(parent1))
+      return parent1;
     return 0;
   }
   const Frame* getInboardGroup(void) const
   {
-    if (!getParentFrame(0))
+    const Frame* parent0 = getParentFrame(0);
+    if (!parent0)
       return 0;
-    if (!getParentFrame(1))
+    const Frame* parent1 = getParentFrame(1);
+    if (!parent1)
       return 0;
-    if (getParentFrame(1)->isParentFrame(getParentFrame(0)))
-      return getParentFrame(0);
-    if (getParentFrame(0)->isParentFrame(getParentFrame(1)))
-      return getParentFrame(1);
+    if (parent1->isParentFrame(parent0))
+      return parent0;
+    if (parent0->isParentFrame(parent1))
+      return parent1;
     return 0;
   }
   Frame* getOutboardGroup(void)
   {
-    if (!getParentFrame(0))
+    Frame* parent0 = getParentFrame(0);
+    if (!parent0)
       return 0;
-    if (!getParentFrame(1))
+    Frame* parent1 = getParentFrame(1);
+    if (!parent1)
       return 0;
-    if (getParentFrame(1)->isParentFrame(getParentFrame(0)))
-      return getParentFrame(1);
-    if (getParentFrame(0)->isParentFrame(getParentFrame(1)))
-      return getParentFrame(0);
+    if (parent1->isParentFrame(parent0))
+      return parent1;
+    if (parent0->isParentFrame(parent1))
+      return parent0;
     return 0;
   }
   const Frame* getOutboardGroup(void) const
   {
-    if (!getParentFrame(0))
+    const Frame* parent0 = getParentFrame(0);
+    if (!parent0)
       return 0;
-    if (!getParentFrame(1))
+    const Frame* parent1 = getParentFrame(1);
+    if (!parent1)
       return 0;
-    if (getParentFrame(1)->isParentFrame(getParentFrame(0)))
-      return getParentFrame(1);
-    if (getParentFrame(0)->isParentFrame(getParentFrame(1)))
-      return getParentFrame(0);
+    if (parent1->isParentFrame(parent0))
+      return parent1;
+    if (parent0->isParentFrame(parent1))
+      return parent0;
     return 0;
   }
 



From frohlich at berlios.de  Fri Dec  9 19:30:39 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Fri, 9 Dec 2005 19:30:39 +0100
Subject: [OpenFDM-svn] r93 - trunk/OpenFDM/src/JSBSim
Message-ID: <200512091830.jB9IUdkp016078@sheep.berlios.de>

Author: frohlich
Date: 2005-12-09 19:30:10 +0100 (Fri, 09 Dec 2005)
New Revision: 93

Added:
   trunk/OpenFDM/src/JSBSim/JSBSimFCSComponent.cpp
Log:
Add missing file


Added: trunk/OpenFDM/src/JSBSim/JSBSimFCSComponent.cpp
===================================================================
--- trunk/OpenFDM/src/JSBSim/JSBSimFCSComponent.cpp	2005-12-09 18:18:31 UTC (rev 92)
+++ trunk/OpenFDM/src/JSBSim/JSBSimFCSComponent.cpp	2005-12-09 18:30:10 UTC (rev 93)
@@ -0,0 +1,41 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
+ *
+ */
+
+#include <OpenFDM/ModelGroup.h>
+#include <OpenFDM/Gain.h>
+
+#include "JSBSimFCSComponent.h"
+
+namespace OpenFDM {
+
+JSBSimFCSComponent::JSBSimFCSComponent(const std::string& name, bool normOut)
+{
+  mModelGroup = new ModelGroup(name);
+
+  mModelGroup->setNumOutputPorts(1);
+  getOutputPort()->setName("Output");
+
+  if (normOut) {
+    mModelGroup->setNumOutputPorts(2);
+    getOutputNormPort()->setName("OutputNorm");
+  }
+}
+
+JSBSimFCSComponent::~JSBSimFCSComponent(void)
+{
+}
+
+Port*
+JSBSimFCSComponent::getOutputPort(void)
+{
+  return mModelGroup->getOutputPort(0);
+}
+
+Port*
+JSBSimFCSComponent::getOutputNormPort(void)
+{
+  return mModelGroup->getOutputPort(1);
+}
+
+} //namespace OpenFDM


Property changes on: trunk/OpenFDM/src/JSBSim/JSBSimFCSComponent.cpp
___________________________________________________________________
Name: svn:eol-style
   + native



From frohlich at berlios.de  Fri Dec  9 19:32:44 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Fri, 9 Dec 2005 19:32:44 +0100
Subject: [OpenFDM-svn] r94 - trunk/OpenFDM/src/JSBSim
Message-ID: <200512091832.jB9IWiYw016944@sheep.berlios.de>

Author: frohlich
Date: 2005-12-09 19:32:38 +0100 (Fri, 09 Dec 2005)
New Revision: 94

Added:
   trunk/OpenFDM/src/JSBSim/JSBSimFCSComponent.h
Log:
Add missing file


Added: trunk/OpenFDM/src/JSBSim/JSBSimFCSComponent.h
===================================================================
--- trunk/OpenFDM/src/JSBSim/JSBSimFCSComponent.h	2005-12-09 18:30:10 UTC (rev 93)
+++ trunk/OpenFDM/src/JSBSim/JSBSimFCSComponent.h	2005-12-09 18:32:38 UTC (rev 94)
@@ -0,0 +1,46 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_JSBSimFCSComponent_H
+#define OpenFDM_JSBSimFCSComponent_H
+
+#include <string>
+#include <OpenFDM/Referenced.h>
+#include <OpenFDM/RefPtr.h>
+
+namespace OpenFDM {
+
+class ModelGroup;
+class Gain;
+class Port;
+
+/// Just a small container mapping the JSBSim FCS component strangeness to
+/// the available OpenFDM discrete systems.
+/// As JSBSim usually munges several independent things into one thing,
+/// this is a ModelGroup for the first cut.
+class JSBSimFCSComponent :
+    public Referenced {
+public:
+  JSBSimFCSComponent(const std::string& name, bool normOut);
+  virtual ~JSBSimFCSComponent(void);
+
+//   /// Add an inverter into the input chanel numbered inNumber
+//   void invertInput(unsigned inNumber);
+//   /// Add an inverter into the output chanel
+//   void invertOutput(void);
+
+  /// Return /the/ output port (we have only one)
+  Port* getOutputPort(void);
+  /// Return /the/ normalized output port
+  Port* getOutputNormPort(void);
+
+  ModelGroup* getModelGroup(void)
+  { return mModelGroup; }
+private:
+  shared_ptr<ModelGroup> mModelGroup;
+};
+
+} //namespace OpenFDM
+
+#endif


Property changes on: trunk/OpenFDM/src/JSBSim/JSBSimFCSComponent.h
___________________________________________________________________
Name: svn:eol-style
   + native



From frohlich at berlios.de  Fri Dec  9 20:27:13 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Fri, 9 Dec 2005 20:27:13 +0100
Subject: [OpenFDM-svn] r95 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200512091927.jB9JRDgl012262@sheep.berlios.de>

Author: frohlich
Date: 2005-12-09 20:27:08 +0100 (Fri, 09 Dec 2005)
New Revision: 95

Modified:
   trunk/OpenFDM/src/OpenFDM/Table.h
Log:
Preliminary multimensional tables


Modified: trunk/OpenFDM/src/OpenFDM/Table.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Table.h	2005-12-09 18:32:38 UTC (rev 94)
+++ trunk/OpenFDM/src/OpenFDM/Table.h	2005-12-09 19:27:08 UTC (rev 95)
@@ -297,24 +297,15 @@
   const real_type& getOutput(void) const
   { return mOutput; }
 
-  void setTable(const TableData<1>& table)
-  { mTableData = table; }
   void setTableData(const TableData<1>& table)
   { mTableData = table; }
-
-  const TableData<1>& getTable(void) const 
-  { return mTableData; }
   const TableData<1>& getTableData(void) const 
   { return mTableData; }
-  TableData<1>& getTable(void)
-  { return mTableData; }
   TableData<1>& getTableData(void)
   { return mTableData; }
 
   void setTableLookup(const TableLookup& tl)
-  {
-    mTableLookup = tl;
-  }
+  { mTableLookup = tl; }
 
 private:
   real_type mOutput;
@@ -322,6 +313,121 @@
   TableLookup mTableLookup;
 };
 
+class Table2D : public Model {
+public:
+  Table2D(const std::string& name) :
+    Model(name)
+  {
+    setDirectFeedThrough(true);
+    
+    setNumInputPorts(2);
+    setInputPortName(0, "input 0");
+    setInputPortName(1, "input 1");
+    
+    setNumOutputPorts(1);
+    setOutputPort(0, "output", this, &Table2D::getOutput);
+
+    addProperty("output", Property(this, &Table2D::getOutput));
+  }
+  virtual ~Table2D(void) {}
+  
+  virtual bool init(void)
+  {
+    OpenFDMAssert(getInputPort(0)->isConnected());
+    OpenFDMAssert(getInputPort(1)->isConnected());
+    return getInputPort(0)->isConnected() && getInputPort(1)->isConnected();
+  }
+
+  virtual void output(const TaskInfo&)
+  {
+    OpenFDMAssert(getInputPort(0)->isConnected());
+    TableData<2>::InterpVector interpVec;
+    RealPortHandle rh = getInputPort(0)->toRealPortHandle();
+    interpVec(1) = mTableLookup[0].lookup(rh.getRealValue());
+    rh = getInputPort(1)->toRealPortHandle();
+    interpVec(2) = mTableLookup[1].lookup(rh.getRealValue());
+    mOutput = mTableData.interpolate(interpVec);
+  }
+
+  const real_type& getOutput(void) const
+  { return mOutput; }
+
+  void setTableData(const TableData<2>& table)
+  { mTableData = table; }
+  const TableData<2>& getTableData(void) const 
+  { return mTableData; }
+  TableData<2>& getTableData(void)
+  { return mTableData; }
+
+  void setTableLookup(unsigned idx, const TableLookup& tl)
+  { mTableLookup[idx] = tl; }
+
+private:
+  real_type mOutput;
+  TableData<2> mTableData;
+  TableLookup mTableLookup[2];
+};
+
+class Table3D : public Model {
+public:
+  Table3D(const std::string& name) :
+    Model(name)
+  {
+    setDirectFeedThrough(true);
+    
+    setNumInputPorts(3);
+    setInputPortName(0, "input 0");
+    setInputPortName(1, "input 1");
+    setInputPortName(2, "input 2");
+    
+    setNumOutputPorts(1);
+    setOutputPort(0, "output", this, &Table3D::getOutput);
+
+    addProperty("output", Property(this, &Table3D::getOutput));
+  }
+  virtual ~Table3D(void) {}
+  
+  virtual bool init(void)
+  {
+    OpenFDMAssert(getInputPort(0)->isConnected());
+    OpenFDMAssert(getInputPort(1)->isConnected());
+    OpenFDMAssert(getInputPort(3)->isConnected());
+    return getInputPort(0)->isConnected() && getInputPort(1)->isConnected()
+      && getInputPort(2)->isConnected();
+  }
+
+  virtual void output(const TaskInfo&)
+  {
+    OpenFDMAssert(getInputPort(0)->isConnected());
+    TableData<3>::InterpVector interpVec;
+    RealPortHandle rh = getInputPort(0)->toRealPortHandle();
+    interpVec(1) = mTableLookup[0].lookup(rh.getRealValue());
+    rh = getInputPort(1)->toRealPortHandle();
+    interpVec(2) = mTableLookup[1].lookup(rh.getRealValue());
+    rh = getInputPort(2)->toRealPortHandle();
+    interpVec(3) = mTableLookup[2].lookup(rh.getRealValue());
+    mOutput = mTableData.interpolate(interpVec);
+  }
+
+  const real_type& getOutput(void) const
+  { return mOutput; }
+
+  void setTableData(const TableData<3>& table)
+  { mTableData = table; }
+  const TableData<3>& getTableData(void) const 
+  { return mTableData; }
+  TableData<3>& getTableData(void)
+  { return mTableData; }
+
+  void setTableLookup(unsigned idx, const TableLookup& tl)
+  { mTableLookup[idx] = tl; }
+
+private:
+  real_type mOutput;
+  TableData<3> mTableData;
+  TableLookup mTableLookup[3];
+};
+
 } // namespace OpenFDM
 
 #endif



From frohlich at berlios.de  Sat Dec 10 18:47:21 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Sat, 10 Dec 2005 18:47:21 +0100
Subject: [OpenFDM-svn] r96 - in trunk/OpenFDM/src: JSBSim OpenFDM
Message-ID: <200512101747.jBAHlLPK027435@sheep.berlios.de>

Author: frohlich
Date: 2005-12-10 18:47:14 +0100 (Sat, 10 Dec 2005)
New Revision: 96

Modified:
   trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
   trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.h
   trunk/OpenFDM/src/OpenFDM/UnaryFunctionModel.cpp
Log:
More on ports instead of properties.


Modified: trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
===================================================================
--- trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2005-12-09 19:27:08 UTC (rev 95)
+++ trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2005-12-10 17:47:14 UTC (rev 96)
@@ -13,6 +13,7 @@
 
 #include <OpenFDM/AeroForce.h>
 #include <OpenFDM/Bias.h>
+#include <OpenFDM/ConstSystem.h>
 #include <OpenFDM/DeadBand.h>
 #include <OpenFDM/DiscreteIntegrator.h>
 #include <OpenFDM/Expression.h>
@@ -226,9 +227,8 @@
     // Ok, still not available, create a constant zero thing and bail out ...
     if (!port || !port->isConnected()) {
       std::cerr << "Creating expression \"" << propName << "\"" << std::endl;
-      port = new Port;
-      port->setProperty(Property(new ConstExpressionPropertyImpl<real_type>(0)));
-      return port;
+
+      return addConstModel(propName + " constant", 0);
     }
     
   } else {
@@ -502,6 +502,16 @@
   return unary->getOutputPort(0);
 }
 
+Port*
+LegacyJSBSimReader::addConstModel(const std::string& name, real_type value)
+{
+  Matrix m(1, 1);
+  m(1, 1) = 0;
+  ConstSystem* cModel = new ConstSystem(name, m);
+  addFCSModel(cModel);
+  return cModel->getOutputPort(0);
+}
+
 void
 LegacyJSBSimReader::addFCSModel(Model* model)
 {
@@ -608,8 +618,7 @@
     } else if (name == "AC_WINGINCIDENCE") {
       real_type value;
       datastr >> value;
-      Port* port = new Port;
-      port->setProperty(Property(new ConstExpressionPropertyImpl<real_type>(value)));
+      Port* port = addConstModel("metrics/iw-deg constant", value);
       registerJSBExpression("metrics/iw-deg", port);
     } else if (name == "AC_CHORD") {
       real_type value;
@@ -618,26 +627,22 @@
     } else if (name == "AC_HTAILAREA") {
       real_type value;
       datastr >> value;
-      Port* port = new Port;
-      port->setProperty(Property(new ConstExpressionPropertyImpl<real_type>(value)));
+      Port* port = addConstModel("metrics/Sh-sqft constant", value);
       registerJSBExpression("metrics/Sh-sqft", port);
     } else if (name == "AC_HTAILARM") {
       real_type value;
       datastr >> value;
-      Port* port = new Port;
-      port->setProperty(Property(new ConstExpressionPropertyImpl<real_type>(value)));
+      Port* port = addConstModel("metrics/lh-ft constant", value);
       registerJSBExpression("metrics/lh-ft", port);
     } else if (name == "AC_VTAILAREA") {
       real_type value;
       datastr >> value;
-      Port* port = new Port;
-      port->setProperty(Property(new ConstExpressionPropertyImpl<real_type>(value)));
+      Port* port = addConstModel("metrics/Sv-sqft constant", value);
       registerJSBExpression("metrics/Sv-sqft", port);
     } else if (name == "AC_VTAILARM") {
       real_type value;
       datastr >> value;
-      Port* port = new Port;
-      port->setProperty(Property(new ConstExpressionPropertyImpl<real_type>(value)));
+      Port* port = addConstModel("metrics/lv-ft constant", value);
       registerJSBExpression("metrics/lv-ft", port);
     } else if (name == "AC_IXX") {
       real_type value;
@@ -766,13 +771,15 @@
   wheel->addMultiBodyModel(wc);
   
   Port* port = wj->getOutputPort(0);
-  addOutputModel(port, "Wheel " + numStr + " Position",
+  std::string nameBase = "Wheel " + numStr + " Position";
+  addOutputModel(port, nameBase,
                  "gear/gear[" + numStr + "]/wheel-position-rad");
-  SiToUnitExpressionImpl* c = new SiToUnitExpressionImpl(uDegree);
-  c->setInputProperty(port->getProperty());
-  port = new Port;
-  port->setProperty(Property(c));
-  addOutputModel(port, "Wheel " + numStr + " Position Deg",
+  UnitConversionModel* unitModel
+    = new UnitConversionModel(nameBase + " converter",
+                              UnitConversionModel::SiToUnit, uDegree);
+  unitModel->getInputPort(0)->connect(port);
+  addFCSModel(unitModel);
+  addOutputModel(unitModel->getOutputPort(0), nameBase + " Deg",
                  "gear/gear[" + numStr + "]/wheel-position-deg");
 }
 
@@ -1020,13 +1027,15 @@
         
         // Prepare outputs
         port = sj->getOutputPort(0);
-        addOutputModel(port, "Steering " + numStr + " Position",
+        std::string nameBase = "Steering " + numStr + " Position";
+        addOutputModel(port, nameBase,
                        "/gear/gear[" + numStr + "]/steering-pos-rad");
-        SiToUnitExpressionImpl* c = new SiToUnitExpressionImpl(uDegree);
-        c->setInputProperty(port->getProperty());
-        port = new Port(); // FIXME add unit convert model
-        port->setProperty(Property(c));
-        addOutputModel(port, "Steering " + numStr + " Position Deg",
+        UnitConversionModel* unitModel
+          = new UnitConversionModel(nameBase + " converter",
+                                    UnitConversionModel::SiToUnit, uDegree);
+        unitModel->getInputPort(0)->connect(port);
+        addFCSModel(unitModel);
+        addOutputModel(unitModel->getOutputPort(0), nameBase + " Deg",
                        "/gear/gear[" + numStr + "]/steering-pos-deg");
       }
 

Modified: trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.h
===================================================================
--- trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.h	2005-12-09 19:27:08 UTC (rev 95)
+++ trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.h	2005-12-10 17:47:14 UTC (rev 96)
@@ -157,6 +157,7 @@
 
   Port* addInverterModel(const std::string& name, Port* in);
   Port* addAbsModel(const std::string& name, Port* in);
+  Port* addConstModel(const std::string& name, real_type value);
 
   void addFCSModel(Model* model);
   /// </FIXME> document and rethink

Modified: trunk/OpenFDM/src/OpenFDM/UnaryFunctionModel.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/UnaryFunctionModel.cpp	2005-12-09 19:27:08 UTC (rev 95)
+++ trunk/OpenFDM/src/OpenFDM/UnaryFunctionModel.cpp	2005-12-10 17:47:14 UTC (rev 96)
@@ -250,9 +250,9 @@
 {
   real_type value = getInputPort(0)->toRealPortHandle().getRealValue();
   if (mType == UnitToSi) {
+    mValue = convertFrom(mUnit, value);
+  } else {
     mValue = convertTo(mUnit, value);
-  } else {
-    mValue = convertFrom(mUnit, value);
   }
 }
 



From frohlich at berlios.de  Sat Dec 10 19:08:35 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Sat, 10 Dec 2005 19:08:35 +0100
Subject: [OpenFDM-svn] r97 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200512101808.jBAI8Zd3005101@sheep.berlios.de>

Author: frohlich
Date: 2005-12-10 19:08:24 +0100 (Sat, 10 Dec 2005)
New Revision: 97

Added:
   trunk/OpenFDM/src/OpenFDM/Port.cpp
   trunk/OpenFDM/src/OpenFDM/Port.h
Modified:
   trunk/OpenFDM/src/OpenFDM/Makefile.am
   trunk/OpenFDM/src/OpenFDM/Model.h
Log:
Move port stuff into its own file.


Modified: trunk/OpenFDM/src/OpenFDM/Makefile.am
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Makefile.am	2005-12-10 17:47:14 UTC (rev 96)
+++ trunk/OpenFDM/src/OpenFDM/Makefile.am	2005-12-10 18:08:24 UTC (rev 97)
@@ -90,6 +90,7 @@
   OpenFDMConfig.h \
   Plane.h \
   Planet.h \
+  Port.h \
   Property.h \
   Product.h \
   PrismaticJoint.h \
@@ -176,6 +177,7 @@
   Object.cpp \
   ODESolver.cpp \
   Planet.cpp \
+  Port.cpp \
   PrismaticJoint.cpp \
   Product.cpp \
   Property.cpp \

Modified: trunk/OpenFDM/src/OpenFDM/Model.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Model.h	2005-12-10 17:47:14 UTC (rev 96)
+++ trunk/OpenFDM/src/OpenFDM/Model.h	2005-12-10 18:08:24 UTC (rev 97)
@@ -17,6 +17,7 @@
 #include "Vector.h"
 #include "SampleTime.h"
 #include "TaskInfo.h"
+#include "Port.h"
 
 namespace OpenFDM {
 
@@ -24,294 +25,6 @@
 class Input;
 class Output;
 
-class RealPortInterface;
-class MatrixPortInterface;
-
-class PortInterface : public Referenced {
-public:
-  virtual ~PortInterface(void) {}
-  virtual RealPortInterface* toRealPortInterface(void) { return 0; }
-  virtual MatrixPortInterface* toMatrixPortInterface(void) { return 0; }
-
-  virtual bool isConnected(void) const = 0;
-  virtual void evaluate(void) = 0;
-};
-
-class RealPortInterface : public PortInterface {
-public:
-  RealPortInterface(unsigned m = 1, unsigned n = 1) : mValue(m, n) {}
-  virtual RealPortInterface* toRealPortInterface(void)
-  {
-    if (Size(1, 1) == size(mValue))
-      return this;
-    else
-      return 0;
-  }
-  // FIXME, move evaluate into seperate method
-  real_type getRealValue(void)
-  { evaluate(); return mValue(1, 1); }
-protected:
-  Matrix mValue;
-};
-
-class MatrixPortInterface : public RealPortInterface {
-public:
-  virtual MatrixPortInterface* toMatrixPortInterface(void) { return this; }
-  // FIXME, move evaluate into seperate method
-  const Matrix& getMatrixValue(void)
-  { evaluate(); return mValue; }
-};
-
-
-/// FIXME adapter to be somehow backwards compatible
-/// Should vanish
-class PropertyPortInterface : public MatrixPortInterface {
-public:
-  PropertyPortInterface(const Property& property) : mProperty(property)
-  { }
-  virtual void evaluate(void)
-  {
-    if (mProperty.isRealProperty()) {
-      RealProperty rp = mProperty.toRealProperty();
-      mValue.resize(1, 1);
-      mValue(1, 1) = rp.getValue();
-    } else if (mProperty.isMatrixProperty()) {
-      MatrixProperty mp = mProperty.toMatrixProperty();
-      mValue = mp.getValue();
-    }
-  }
-  virtual bool isConnected(void) const
-  { return mProperty.isValid(); }
-private:
-  mutable Property mProperty;
-};
-/// Just a getter used for now
-template<typename M>
-class RealGetterPortInterface : public MatrixPortInterface {
-public:
-  typedef const real_type& (M::*Getter) () const;
-  RealGetterPortInterface(M* sourceModel, Getter getter) :
-    mSourceModel(sourceModel), mGetter(getter)
-  { }
-  virtual void evaluate(void)
-  { mValue(1, 1) = (mSourceModel->*mGetter)(); }
-  virtual bool isConnected(void) const
-  { return mSourceModel && mGetter; }
-private:
-  managed_ptr<M> mSourceModel;
-  Getter mGetter;
-};
-template<typename M>
-class MatrixGetterPortInterface : public MatrixPortInterface {
-public:
-  typedef const Matrix& (M::*Getter) () const;
-  MatrixGetterPortInterface(M* sourceModel, Getter getter) :
-    mSourceModel(sourceModel), mGetter(getter)
-  { }
-  virtual void evaluate(void)
-  { mValue = (mSourceModel->*mGetter)(); }
-  virtual bool isConnected(void) const
-  { return mSourceModel && mGetter; }
-private:
-  managed_ptr<M> mSourceModel;
-  Getter mGetter;
-};
-
-class RealPortHandle {
-public:
-  RealPortHandle(void)
-  { }
-  RealPortHandle(RealPortInterface* realPortInterface) :
-    mRealPortInterface(realPortInterface)
-  { }
-  real_type getRealValue(void)
-  { return mRealPortInterface->getRealValue(); }
-  bool isConnected(void) const
-  { return mRealPortInterface && mRealPortInterface->isConnected(); }
-private:
-  shared_ptr<RealPortInterface> mRealPortInterface;
-};
-
-class MatrixPortHandle {
-public:
-  MatrixPortHandle(void)
-  { }
-  MatrixPortHandle(MatrixPortInterface* matrixPortInterface) :
-    mMatrixPortInterface(matrixPortInterface)
-  { }
-  const Matrix& getMatrixValue(void)
-  { return mMatrixPortInterface->getMatrixValue(); }
-  bool isConnected(void) const
-  { return mMatrixPortInterface && mMatrixPortInterface->isConnected(); }
-private:
-  shared_ptr<MatrixPortInterface> mMatrixPortInterface;
-};
-
-// should vanish, just an adaptor for smoother migration
-class RealPortExpression : public PropertyImpl<real_type> {
-public:
-  RealPortExpression(const RealPortHandle& rph) :
-    mRealPortHandle(rph)
-  { }
-  real_type getValue(void) const
-  { return mRealPortHandle.getRealValue(); }
-  void setValue(const real_type&)
-  {  }
-  bool isValid(void) const { return mRealPortHandle.isConnected(); }
-  const Object* getObject(void) const { return 0; }
-  Object* getObject(void) { return 0; }
-private:
-  mutable RealPortHandle mRealPortHandle;
-};
-
-/// Class for an input or output port of a Model.
-/// Ports can be connected together. This means in effect that the reader
-/// gains access to value at the source model.
-/// Additional information must be carried through that class.
-/// ...
-class Port :
-    public Object {
-public:
-  virtual ~Port(void) {}
-
-  /// Returns the systems name.
-  const std::string& getName(void) const
-  { return mName; }
-  void setName(const std::string& name)
-  { mName = name; }
-
-  /// Just use the Properties for now. In this phase it might be a good idea.
-  void setProperty(const Property& property)
-  {
-    setPortInterface(new PropertyPortInterface(property));
-  }
-  void setPortInterface(PortInterface* portInterface)
-  {
-    mPortInterface = portInterface;
-    std::vector<shared_ptr<Port> >::iterator it;
-    for (it = mChainPorts.begin(); it != mChainPorts.end(); ++it) {
-      (*it)->setPortInterface(mPortInterface);
-    }
-  }
-
-  /// Just use the Properties for now. In this phase it might be a good idea.
-  Property getProperty(void) const
-  { return Property(new RealPortExpression(((Port*)(this))->toRealPortHandle())); }
-
-
-  /// returns true if this port has a source port connected to it
-  bool isConnected() const
-  { return mPortInterface && mPortInterface->isConnected(); }
-
-  /// returns true if the source port sourcePort is the value source for the
-  /// current port
-  bool isConnectedTo(const Port* sourcePort) const
-  {
-    const Port* port = mSourcePort;
-    while (port) {
-      if (sourcePort == port)
-        return true;
-      port = port->mSourcePort;
-    }
-
-    return false;
-  }
-
-  RealPortHandle toRealPortHandle(void)
-  { return RealPortHandle(mPortInterface->toRealPortInterface()); }
-  MatrixPortHandle toMatrixPortHandle(void)
-  { return MatrixPortHandle(mPortInterface->toMatrixPortInterface()); }
-
-  /// Retrieve the value of this port
-  /// Note that we don't need a setValue method since we attach a getter of a
-  /// Model to a port.
-
-  /// This might be the place where it is possible to implement
-  /// TaskInfo dependent output ports ...
-  /// Hmm, may be we should otoh 'dirty' some getters?
-  /// Generic thing. Don't use if you don't have to
-  Variant getValue(void)
-  {
-    if (mPortInterface) {
-      RealPortInterface* realPortInterface
-        = mPortInterface->toRealPortInterface();
-      if (realPortInterface)
-        return Variant(realPortInterface->getRealValue());
-      MatrixPortInterface* matrixPortInterface
-        = mPortInterface->toMatrixPortInterface();
-      if (matrixPortInterface)
-        return Variant(matrixPortInterface->getMatrixValue());
-    }
-    return Variant();
-  }
-
-  /// Connect this port to the given source port
-  void connect(Port* sourcePort)
-  {
-    if (!sourcePort) {
-      Log(Model, Warning) << "Part argument to Port::connect is zero!"
-        "Ignoring!" << endl;
-      return;
-    }
-    // disconnect from other source if we are already connected
-    // FIXME: should this be explicit ??
-    if (mSourcePort) {
-      Log(Model, Warning) << "Connecting already connected port!"
-        "Disconnecting from old port now." << endl;
-      disconnect(mSourcePort);
-    }
-
-    // If we have a source port, propagate its context.
-    setPortInterface(sourcePort->mPortInterface);
-    sourcePort->mChainPorts.push_back(this);
-    mSourcePort = sourcePort;
-  }
-
-  /// Disconnect this port from the given source port
-  void disconnect(Port* sourcePort)
-  {
-    if (sourcePort != mSourcePort) {
-      Log(Model, Error) << "Try to disconnect from source port we are not "
-        "currently connected to!" << endl;
-      return;
-    }
-
-    if (!mSourcePort)
-      return;
-
-    // Remove ourselves from the consumer list of the sourcePort to
-    // disconnect us from
-    std::vector<shared_ptr<Port> >::iterator it, beginPort, endPort;
-    beginPort = sourcePort->mChainPorts.begin();
-    endPort = sourcePort->mChainPorts.end();
-    it = std::find(beginPort, endPort, this);
-    if (it != endPort)
-      sourcePort->mChainPorts.erase(it);
-
-    // Reset our source
-    mSourcePort = 0;
-
-    // Invalidate all our listeners
-    setPortInterface(0);
-  }
-
-  /// Just disconnect from whoever we are connected to
-  void disconnect(void)
-  { disconnect(mSourcePort); }
-
-private:
-  /// For now the untyped input port
-  /// On Model::init() it is expected to be specialized
-  /// to a typed port handle
-  shared_ptr<PortInterface> mPortInterface;
-  /// The list of readers for this port
-  std::vector<shared_ptr<Port> > mChainPorts;
-  /// The source of the current port connection
-  managed_ptr<Port> mSourcePort;
-  /// The current ports name FIXME does this belong here?
-  std::string mName;
-};
-
 class Model
   : public Object {
 public:

Added: trunk/OpenFDM/src/OpenFDM/Port.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Port.cpp	2005-12-10 17:47:14 UTC (rev 96)
+++ trunk/OpenFDM/src/OpenFDM/Port.cpp	2005-12-10 18:08:24 UTC (rev 97)
@@ -0,0 +1,118 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
+ *
+ */
+
+#include <string>
+#include <vector>
+#include <algorithm>
+
+#include "LogStream.h"
+#include "Object.h"
+#include "Property.h"
+#include "Variant.h"
+#include "Port.h"
+
+namespace OpenFDM {
+
+Port::~Port(void)
+{
+}
+
+void
+Port::setPortInterface(PortInterface* portInterface)
+{
+  mPortInterface = portInterface;
+  std::vector<shared_ptr<Port> >::iterator it;
+  for (it = mChainPorts.begin(); it != mChainPorts.end(); ++it) {
+    (*it)->setPortInterface(mPortInterface);
+  }
+}
+
+bool
+Port::isConnectedTo(const Port* sourcePort) const
+{
+  const Port* port = mSourcePort;
+  while (port) {
+    if (sourcePort == port)
+      return true;
+    port = port->mSourcePort;
+  }
+  
+  return false;
+}
+
+Variant
+Port::getValue(void)
+{
+  if (mPortInterface) {
+    RealPortInterface* realPortInterface
+      = mPortInterface->toRealPortInterface();
+    if (realPortInterface)
+      return Variant(realPortInterface->getRealValue());
+    MatrixPortInterface* matrixPortInterface
+      = mPortInterface->toMatrixPortInterface();
+    if (matrixPortInterface)
+      return Variant(matrixPortInterface->getMatrixValue());
+  }
+  return Variant();
+}
+
+void
+Port::connect(Port* sourcePort)
+{
+  if (!sourcePort) {
+    Log(Model, Warning) << "Part argument to Port::connect is zero!"
+      "Ignoring!" << endl;
+    return;
+  }
+  // disconnect from other source if we are already connected
+  // FIXME: should this be explicit ??
+  if (mSourcePort) {
+    Log(Model, Warning) << "Connecting already connected port!"
+      "Disconnecting from old port now." << endl;
+    disconnect(mSourcePort);
+  }
+  
+  // If we have a source port, propagate its context.
+  setPortInterface(sourcePort->mPortInterface);
+  sourcePort->mChainPorts.push_back(this);
+  mSourcePort = sourcePort;
+}
+
+/// Disconnect this port from the given source port
+void
+Port::disconnect(Port* sourcePort)
+{
+  if (sourcePort != mSourcePort) {
+    Log(Model, Error) << "Try to disconnect from source port we are not "
+      "currently connected to!" << endl;
+    return;
+  }
+  
+  if (!mSourcePort)
+    return;
+  
+  // Remove ourselves from the consumer list of the sourcePort to
+  // disconnect us from
+  std::vector<shared_ptr<Port> >::iterator it, beginPort, endPort;
+  beginPort = sourcePort->mChainPorts.begin();
+  endPort = sourcePort->mChainPorts.end();
+  it = std::find(beginPort, endPort, this);
+  if (it != endPort)
+    sourcePort->mChainPorts.erase(it);
+  
+  // Reset our source
+  mSourcePort = 0;
+  
+  // Invalidate all our listeners
+  setPortInterface(0);
+}
+
+/// Just disconnect from whoever we are connected to
+void
+Port::disconnect(void)
+{
+  disconnect(mSourcePort);
+}
+
+} // namespace OpenFDM


Property changes on: trunk/OpenFDM/src/OpenFDM/Port.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/OpenFDM/src/OpenFDM/Port.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Port.h	2005-12-10 17:47:14 UTC (rev 96)
+++ trunk/OpenFDM/src/OpenFDM/Port.h	2005-12-10 18:08:24 UTC (rev 97)
@@ -0,0 +1,224 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_Port_H
+#define OpenFDM_Port_H
+
+#include <string>
+#include <vector>
+#include <algorithm>
+
+#include "LogStream.h"
+#include "Object.h"
+#include "Property.h"
+#include "Variant.h"
+
+namespace OpenFDM {
+
+class RealPortInterface;
+class MatrixPortInterface;
+
+class PortInterface : public Referenced {
+public:
+  virtual ~PortInterface(void) {}
+  virtual RealPortInterface* toRealPortInterface(void) { return 0; }
+  virtual MatrixPortInterface* toMatrixPortInterface(void) { return 0; }
+
+  virtual bool isConnected(void) const = 0;
+  virtual void evaluate(void) = 0;
+};
+
+class RealPortInterface : public PortInterface {
+public:
+  RealPortInterface(unsigned m = 1, unsigned n = 1) : mValue(m, n) {}
+  virtual RealPortInterface* toRealPortInterface(void)
+  {
+    if (Size(1, 1) == size(mValue))
+      return this;
+    else
+      return 0;
+  }
+  // FIXME, move evaluate into seperate method
+  real_type getRealValue(void)
+  { evaluate(); return mValue(1, 1); }
+protected:
+  Matrix mValue;
+};
+
+class MatrixPortInterface : public RealPortInterface {
+public:
+  virtual MatrixPortInterface* toMatrixPortInterface(void) { return this; }
+  // FIXME, move evaluate into seperate method
+  const Matrix& getMatrixValue(void)
+  { evaluate(); return mValue; }
+};
+
+
+/// FIXME adapter to be somehow backwards compatible
+/// Should vanish
+class PropertyPortInterface : public MatrixPortInterface {
+public:
+  PropertyPortInterface(const Property& property) : mProperty(property)
+  { }
+  virtual void evaluate(void)
+  {
+    if (mProperty.isRealProperty()) {
+      RealProperty rp = mProperty.toRealProperty();
+      mValue.resize(1, 1);
+      mValue(1, 1) = rp.getValue();
+    } else if (mProperty.isMatrixProperty()) {
+      MatrixProperty mp = mProperty.toMatrixProperty();
+      mValue = mp.getValue();
+    }
+  }
+  virtual bool isConnected(void) const
+  { return mProperty.isValid(); }
+private:
+  mutable Property mProperty;
+};
+/// Just a getter used for now
+template<typename M>
+class RealGetterPortInterface : public MatrixPortInterface {
+public:
+  typedef const real_type& (M::*Getter) () const;
+  RealGetterPortInterface(M* sourceModel, Getter getter) :
+    mSourceModel(sourceModel), mGetter(getter)
+  { }
+  virtual void evaluate(void)
+  { mValue(1, 1) = (mSourceModel->*mGetter)(); }
+  virtual bool isConnected(void) const
+  { return mSourceModel && mGetter; }
+private:
+  managed_ptr<M> mSourceModel;
+  Getter mGetter;
+};
+template<typename M>
+class MatrixGetterPortInterface : public MatrixPortInterface {
+public:
+  typedef const Matrix& (M::*Getter) () const;
+  MatrixGetterPortInterface(M* sourceModel, Getter getter) :
+    mSourceModel(sourceModel), mGetter(getter)
+  { }
+  virtual void evaluate(void)
+  { mValue = (mSourceModel->*mGetter)(); }
+  virtual bool isConnected(void) const
+  { return mSourceModel && mGetter; }
+private:
+  managed_ptr<M> mSourceModel;
+  Getter mGetter;
+};
+
+class RealPortHandle {
+public:
+  RealPortHandle(void)
+  { }
+  RealPortHandle(RealPortInterface* realPortInterface) :
+    mRealPortInterface(realPortInterface)
+  { }
+  real_type getRealValue(void)
+  { return mRealPortInterface->getRealValue(); }
+  bool isConnected(void) const
+  { return mRealPortInterface && mRealPortInterface->isConnected(); }
+private:
+  shared_ptr<RealPortInterface> mRealPortInterface;
+};
+
+class MatrixPortHandle {
+public:
+  MatrixPortHandle(void)
+  { }
+  MatrixPortHandle(MatrixPortInterface* matrixPortInterface) :
+    mMatrixPortInterface(matrixPortInterface)
+  { }
+  const Matrix& getMatrixValue(void)
+  { return mMatrixPortInterface->getMatrixValue(); }
+  bool isConnected(void) const
+  { return mMatrixPortInterface && mMatrixPortInterface->isConnected(); }
+private:
+  shared_ptr<MatrixPortInterface> mMatrixPortInterface;
+};
+
+// should vanish, just an adaptor for smoother migration
+class RealPortExpression : public PropertyImpl<real_type> {
+public:
+  RealPortExpression(const RealPortHandle& rph) :
+    mRealPortHandle(rph)
+  { }
+  real_type getValue(void) const
+  { return mRealPortHandle.getRealValue(); }
+  void setValue(const real_type&)
+  {  }
+  bool isValid(void) const { return mRealPortHandle.isConnected(); }
+  const Object* getObject(void) const { return 0; }
+  Object* getObject(void) { return 0; }
+private:
+  mutable RealPortHandle mRealPortHandle;
+};
+
+/// Class for an input or output port of a Model.
+/// Ports can be connected together. This means in effect that the reader
+/// gains access to value at the source model.
+/// Additional information must be carried through that class.
+/// ...
+class Port :
+    public Object {
+public:
+  virtual ~Port(void);
+
+  /// Just use the Properties for now. In this phase it might be a good idea.
+  void setProperty(const Property& property)
+  { setPortInterface(new PropertyPortInterface(property)); }
+  void setPortInterface(PortInterface* portInterface);
+
+  /// Just use the Properties for now. In this phase it might be a good idea.
+  Property getProperty(void) const
+  { return Property(new RealPortExpression(((Port*)(this))->toRealPortHandle())); }
+
+
+  /// returns true if this port has a source port connected to it
+  bool isConnected() const
+  { return mPortInterface && mPortInterface->isConnected(); }
+
+  /// returns true if the source port sourcePort is the value source for the
+  /// current port
+  bool isConnectedTo(const Port* sourcePort) const;
+
+  RealPortHandle toRealPortHandle(void)
+  { return RealPortHandle(mPortInterface->toRealPortInterface()); }
+  MatrixPortHandle toMatrixPortHandle(void)
+  { return MatrixPortHandle(mPortInterface->toMatrixPortInterface()); }
+
+  /// Retrieve the value of this port
+  /// Note that we don't need a setValue method since we attach a getter of a
+  /// Model to a port.
+
+  /// This might be the place where it is possible to implement
+  /// TaskInfo dependent output ports ...
+  /// Hmm, may be we should otoh 'dirty' some getters?
+  /// Generic thing. Don't use if you don't have to
+  Variant getValue(void);
+
+  /// Connect this port to the given source port
+  void connect(Port* sourcePort);
+
+  /// Disconnect this port from the given source port
+  void disconnect(Port* sourcePort);
+
+  /// Just disconnect from whoever we are connected to
+  void disconnect(void);
+
+private:
+  /// For now the untyped input port
+  /// On Model::init() it is expected to be specialized
+  /// to a typed port handle
+  shared_ptr<PortInterface> mPortInterface;
+  /// The list of readers for this port
+  std::vector<shared_ptr<Port> > mChainPorts;
+  /// The source of the current port connection
+  managed_ptr<Port> mSourcePort;
+};
+
+} // namespace OpenFDM
+
+#endif


Property changes on: trunk/OpenFDM/src/OpenFDM/Port.h
___________________________________________________________________
Name: svn:eol-style
   + native



From frohlich at berlios.de  Thu Dec 15 08:18:19 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Thu, 15 Dec 2005 08:18:19 +0100
Subject: [OpenFDM-svn] r98 - in trunk/OpenFDM/src/OpenFDM: . LinAlg
Message-ID: <200512150718.jBF7IJdk032144@sheep.berlios.de>

Author: frohlich
Date: 2005-12-15 08:18:02 +0100 (Thu, 15 Dec 2005)
New Revision: 98

Modified:
   trunk/OpenFDM/src/OpenFDM/LinAlg/Algorithm.h
   trunk/OpenFDM/src/OpenFDM/System.cpp
Log:
Add very croase end check for screwed up integrations.


Modified: trunk/OpenFDM/src/OpenFDM/LinAlg/Algorithm.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/LinAlg/Algorithm.h	2005-12-10 18:08:24 UTC (rev 97)
+++ trunk/OpenFDM/src/OpenFDM/LinAlg/Algorithm.h	2005-12-15 07:18:02 UTC (rev 98)
@@ -447,6 +447,30 @@
   return equal(u, v, 8*eps);
 }
 
+/** inf check.
+
+    @param v vector.
+
+    Returns true if all entries are finite.
+*/
+template<typename Impl, size_type m>
+OpenFDM_FORCE_INLINE
+bool
+isFinite(const MatrixRValue<Impl,m,1>& v)
+{
+  typedef typename Impl::value_type value_type;
+  const Impl& vi = v.asImpl();
+
+  size_type rows = vi.rows();
+  for (size_type i = 1; i <= rows; ++i) {
+    value_type val = vi(i, 1);
+    if (!isfinite(val))
+      return false;
+  }
+
+  return true;
+}
+
 /** Cross product multiplication.
 
     @param u vector to multiply.

Modified: trunk/OpenFDM/src/OpenFDM/System.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/System.cpp	2005-12-10 18:08:24 UTC (rev 97)
+++ trunk/OpenFDM/src/OpenFDM/System.cpp	2005-12-15 07:18:02 UTC (rev 98)
@@ -202,21 +202,34 @@
       taskInfo.setTime(getTime());
       output(taskInfo);
 
-      Log(Schedule, Info) << "Integration: from time " << mTimestepper->getTime()
-                       << " up to time " << loopTEnd
-                       << " dt = " << loopTEnd - mTimestepper->getTime()
-                       << endl;
+      Log(Schedule, Info) << "Integration: from time "
+                          << mTimestepper->getTime()
+                          << " up to time " << loopTEnd
+                          << " dt = " << loopTEnd - mTimestepper->getTime()
+                          << endl;
+      // FIXME: check for errors
       mTimestepper->integrate(loopTEnd);
       mTime = mTimestepper->getTime();
+      Log(Schedule, Info) << "Integration: finished" << endl;
+      // Croase end check when it is too late, we might do stiffness
+      // detection at least within dopri in an other way ...
+      if (!isFinite(mTimestepper->getState())) {
+        Log(TimeStep, Warning) << "Found infinite values in continous state "
+          "vector. Consider using an other timestepping method or make your "
+          "model less stiff. Aborting!" << endl;
+        return false;
+      }
+
       // It set's the current state into the models and computes the
       // accelerations for the mechanical system
-      Log(Schedule, Info) << "Integration: finished" << endl;
       evalFunction(mTimestepper->getTime(), mTimestepper->getState(), state);
     }
 
     if (equal(mTime, tEnd, 10))
       mTime = tEnd;
   }
+
+  return true;
 }
 
 class TrimFunction



From frohlich at berlios.de  Fri Dec 16 21:19:44 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Fri, 16 Dec 2005 21:19:44 +0100
Subject: [OpenFDM-svn] r99 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200512162019.jBGKJipT031410@sheep.berlios.de>

Author: frohlich
Date: 2005-12-16 21:19:36 +0100 (Fri, 16 Dec 2005)
New Revision: 99

Added:
   trunk/OpenFDM/src/OpenFDM/ModelVisitor.h
Modified:
   trunk/OpenFDM/src/OpenFDM/Makefile.am
   trunk/OpenFDM/src/OpenFDM/Model.cpp
   trunk/OpenFDM/src/OpenFDM/Model.h
   trunk/OpenFDM/src/OpenFDM/ModelGroup.cpp
   trunk/OpenFDM/src/OpenFDM/ModelGroup.h
Log:
Hmm, introduce an other visitor.
Must rethink the multibody visitor/object model.


Modified: trunk/OpenFDM/src/OpenFDM/Makefile.am
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Makefile.am	2005-12-15 07:18:02 UTC (rev 98)
+++ trunk/OpenFDM/src/OpenFDM/Makefile.am	2005-12-16 20:19:36 UTC (rev 99)
@@ -83,6 +83,7 @@
   MinModel.h \
   Model.h \
   ModelGroup.h \
+  ModelVisitor.h \
   MultiBodyModel.h \
   Newton.h \
   Object.h \

Modified: trunk/OpenFDM/src/OpenFDM/Model.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Model.cpp	2005-12-15 07:18:02 UTC (rev 98)
+++ trunk/OpenFDM/src/OpenFDM/Model.cpp	2005-12-16 20:19:36 UTC (rev 99)
@@ -4,6 +4,7 @@
 
 #include "LogStream.h"
 #include "ModelGroup.h"
+#include "ModelVisitor.h"
 #include "Model.h"
 
 namespace OpenFDM {
@@ -30,6 +31,19 @@
 {
 }
 
+void
+Model::accept(ModelVisitor& visitor)
+{
+  visitor.apply(*this);
+}
+
+void
+Model::ascend(ModelVisitor& visitor)
+{
+  if (mParentModel)
+    mParentModel->accept(visitor);
+}
+
 const ModelGroup*
 Model::toModelGroup(void) const
 {

Modified: trunk/OpenFDM/src/OpenFDM/Model.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Model.h	2005-12-15 07:18:02 UTC (rev 98)
+++ trunk/OpenFDM/src/OpenFDM/Model.h	2005-12-16 20:19:36 UTC (rev 99)
@@ -25,12 +25,22 @@
 class Input;
 class Output;
 
+class ModelVisitor;
+
 class Model
   : public Object {
 public:
   Model(const std::string& name);
   virtual ~Model(void);
 
+  /// Double dispatch helper for the multibody system visitor
+  virtual void accept(ModelVisitor& visitor);
+  /// Double dispatch helper for the multibody system visitor
+//   virtual void accept(ConstModelVisitor& visitor) const;
+
+  /// Hmm ...
+  void ascend(ModelVisitor& visitor);
+
   virtual const ModelGroup* toModelGroup(void) const;
   virtual ModelGroup* toModelGroup(void);
 

Modified: trunk/OpenFDM/src/OpenFDM/ModelGroup.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/ModelGroup.cpp	2005-12-15 07:18:02 UTC (rev 98)
+++ trunk/OpenFDM/src/OpenFDM/ModelGroup.cpp	2005-12-16 20:19:36 UTC (rev 99)
@@ -7,6 +7,7 @@
 #include "Property.h"
 #include "Vector.h"
 #include "LogStream.h"
+#include "ModelVisitor.h"
 #include "ModelGroup.h"
 
 namespace OpenFDM {
@@ -26,6 +27,12 @@
   OpenFDMAssert(getNumContinousStates() == 0u);
 }
 
+void
+ModelGroup::accept(ModelVisitor& visitor)
+{
+  visitor.apply(*this);
+}
+
 const ModelGroup*
 ModelGroup::toModelGroup(void) const
 {

Modified: trunk/OpenFDM/src/OpenFDM/ModelGroup.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/ModelGroup.h	2005-12-15 07:18:02 UTC (rev 98)
+++ trunk/OpenFDM/src/OpenFDM/ModelGroup.h	2005-12-16 20:19:36 UTC (rev 99)
@@ -20,6 +20,18 @@
   ModelGroup(const std::string& name);
   virtual ~ModelGroup(void);
 
+  /// Double dispatch helper for the multibody system visitor
+  virtual void accept(ModelVisitor& visitor);
+  /// Double dispatch helper for the multibody system visitor
+//   virtual void accept(ConstModelVisitor& visitor) const;
+
+  void traverse(ModelVisitor& visitor)
+  {
+    for (ModelList::iterator it = mModels.begin(); it != mModels.end(); ++it)
+      (*it)->accept(visitor);
+  }
+
+
   virtual const ModelGroup* toModelGroup(void) const;
   virtual ModelGroup* toModelGroup(void);
 

Added: trunk/OpenFDM/src/OpenFDM/ModelVisitor.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/ModelVisitor.h	2005-12-15 07:18:02 UTC (rev 98)
+++ trunk/OpenFDM/src/OpenFDM/ModelVisitor.h	2005-12-16 20:19:36 UTC (rev 99)
@@ -0,0 +1,45 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_ModelVisitor_H
+#define OpenFDM_ModelVisitor_H
+
+#include "Model.h"
+#include "ModelGroup.h"
+// #include "MultiBodyModel.h"
+
+namespace OpenFDM {
+
+class ModelVisitor {
+public:
+  virtual ~ModelVisitor(void)
+  { }
+  virtual void apply(Model& model)
+  { }
+  virtual void apply(ModelGroup& modelGroup)
+  { apply((Model&)modelGroup); }
+//   virtual void apply(MultiBodyModel& multiBodyModel)
+//   { apply((Model&)multiBodyModel); }
+protected:
+  /// Call this in the apply(ModelGroup&) method if you want to
+  /// traverse downward
+  inline void traverse(ModelGroup& modelGroup)
+  { modelGroup.traverse(*this); }
+  /// Call this in the apply(MultiBodyModel&) method if you want to
+  /// traverse downward
+//   inline void traverse(MultiBodyModel& multiBodyModel)
+//   { multiBodyModel.traverse(*this); }
+  /// Call this in the apply(ModelGroup&) method if you want to
+  /// traverse upward
+  inline void ascend(Model& model)
+  { model.ascend(*this); }
+  /// Call this in the apply(MultiBodyModel&) method if you want to
+  /// traverse upward
+//   inline void ascend(MultiBodyModel& multiBodyModel)
+//   { multiBodyModel.ascend(*this); }
+};
+
+} // namespace OpenFDM
+
+#endif


Property changes on: trunk/OpenFDM/src/OpenFDM/ModelVisitor.h
___________________________________________________________________
Name: svn:eol-style
   + native



From frohlich at berlios.de  Sat Dec 17 09:48:42 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Sat, 17 Dec 2005 09:48:42 +0100
Subject: [OpenFDM-svn] r100 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200512170848.jBH8mg6G002150@sheep.berlios.de>

Author: frohlich
Date: 2005-12-17 09:48:20 +0100 (Sat, 17 Dec 2005)
New Revision: 100

Modified:
   trunk/OpenFDM/src/OpenFDM/Table.h
Log:
Make prelookup indices real_type.


Modified: trunk/OpenFDM/src/OpenFDM/Table.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Table.h	2005-12-16 20:19:36 UTC (rev 99)
+++ trunk/OpenFDM/src/OpenFDM/Table.h	2005-12-17 08:48:20 UTC (rev 100)
@@ -13,24 +13,10 @@
 
 namespace OpenFDM {
 
-struct InterploationData {
-  InterploationData(void) {}
-  InterploationData(unsigned index0, unsigned index1, real_type _theta)
-  {
-    weight[0] = 1 - _theta;
-    weight[1] = _theta;
-    index[0] = index0;
-    index[1] = index1;
-  }
-  real_type weight[2];
-  unsigned index[2];
-};
-
 class TableLookup {
   typedef std::map<real_type, unsigned> Table;
   typedef std::pair<real_type, unsigned> Pair;
-  
-  
+ 
 public:
   TableLookup(void)
   {}
@@ -129,12 +115,12 @@
     return true;
   }
 
-  InterploationData lookup(real_type input) const
+  real_type lookup(real_type input) const
   {
     // Empty table??
     // FIXME
     if (mTable.empty())
-      return InterploationData(1, 1, 0);
+      return 1;
 
     // Find the table bounds for the requested input.
     Table::const_iterator upBoundIt = mTable.upper_bound(input);
@@ -143,10 +129,10 @@
 
     Table::const_iterator beg = mTable.begin();
     if (upBoundIt == beg)
-      return InterploationData(1, 1, 0);
+      return 1;
     if (upBoundIt == mTable.end()) {
       unsigned last = mTable.rbegin()->second;
-      return InterploationData(last, last, 0);
+      return last;
     }
 
     // Just do linear interpolation.
@@ -154,10 +140,10 @@
     real_type upBound = upBoundIt->first;
     unsigned loIdx = loBoundIt->second;
     if (loBound == upBound)
-      return InterploationData(loIdx, loIdx, 0);
+      return loIdx;
     unsigned upIdx = upBoundIt->second;
     real_type theta = (input - loBound)/(upBound-loBound);
-    return InterploationData(loIdx, upIdx, theta);
+    return loIdx + theta;
   }
 
 private:
@@ -169,7 +155,7 @@
 public:
   typedef LinAlg::Vector<unsigned,numDims>  Index;
   typedef LinAlg::Vector<unsigned,numDims>  SizeVector;
-  typedef LinAlg::Vector<InterploationData,numDims> InterpVector;
+  typedef LinAlg::Vector<real_type,numDims> InterpVector;
 
   TableData(void) :
     mData(0)
@@ -244,17 +230,36 @@
     if (indexNum == 0)
       return at(curIndex);
 
-    real_type value = 0;
+    real_type ridx = interp(indexNum);
 
-    curIndex(indexNum) = interp(indexNum).index[0];
-    value += interp(indexNum).weight[0] *
-      interpolator(indexNum-1, curIndex, interp);
+    // Check for an out of range index
+    unsigned i0 = unsigned(floor(ridx));
+    if (i0 < 1) {
+      curIndex(indexNum) = 1;
+      return interpolator(indexNum-1, curIndex, interp);
+    }
 
-    curIndex(indexNum) = interp(indexNum).index[1];
-    value += interp(indexNum).weight[1] *
-      interpolator(indexNum-1, curIndex, interp);
+    // Check for an out of range index
+    unsigned sz = mSize(indexNum);
+    unsigned i1 = unsigned(ceil(ridx));
+    if (sz < i1) {
+      curIndex(indexNum) = sz;
+      return interpolator(indexNum-1, curIndex, interp);
+    } else if (i0 == i1) {
+      // Exactly hit an integer valued index
+      curIndex(indexNum) = i0;
+      return interpolator(indexNum-1, curIndex, interp);
+    } else {
+      // Need interpolation in this dimension
+      curIndex(indexNum) = i0;
+      real_type value;
+      value = (i1 - ridx) * interpolator(indexNum-1, curIndex, interp);
 
-    return value;
+      curIndex(indexNum) = i1;
+      value += (ridx - i0) * interpolator(indexNum-1, curIndex, interp);
+
+      return value;
+    }
   }
 
   real_type* mData;



From frohlich at berlios.de  Sat Dec 17 10:04:51 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Sat, 17 Dec 2005 10:04:51 +0100
Subject: [OpenFDM-svn] r101 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200512170904.jBH94pI0006792@sheep.berlios.de>

Author: frohlich
Date: 2005-12-17 10:04:30 +0100 (Sat, 17 Dec 2005)
New Revision: 101

Modified:
   trunk/OpenFDM/src/OpenFDM/Table.h
Log:
Make table lookup even more robust for out of bounds inputs


Modified: trunk/OpenFDM/src/OpenFDM/Table.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Table.h	2005-12-17 08:48:20 UTC (rev 100)
+++ trunk/OpenFDM/src/OpenFDM/Table.h	2005-12-17 09:04:30 UTC (rev 101)
@@ -233,33 +233,36 @@
     real_type ridx = interp(indexNum);
 
     // Check for an out of range index
-    unsigned i0 = unsigned(floor(ridx));
-    if (i0 < 1) {
+    // Note that this negated check also catches NaNs
+    if (!(1 <= ridx)) {
       curIndex(indexNum) = 1;
       return interpolator(indexNum-1, curIndex, interp);
     }
 
     // Check for an out of range index
     unsigned sz = mSize(indexNum);
-    unsigned i1 = unsigned(ceil(ridx));
-    if (sz < i1) {
+    if (sz < ridx) {
       curIndex(indexNum) = sz;
       return interpolator(indexNum-1, curIndex, interp);
-    } else if (i0 == i1) {
+    }
+
+    unsigned i0 = unsigned(floor(ridx));
+    unsigned i1 = unsigned(ceil(ridx));
+    if (i0 == i1) {
       // Exactly hit an integer valued index
       curIndex(indexNum) = i0;
       return interpolator(indexNum-1, curIndex, interp);
-    } else {
-      // Need interpolation in this dimension
-      curIndex(indexNum) = i0;
-      real_type value;
-      value = (i1 - ridx) * interpolator(indexNum-1, curIndex, interp);
+    }
 
-      curIndex(indexNum) = i1;
-      value += (ridx - i0) * interpolator(indexNum-1, curIndex, interp);
-
-      return value;
-    }
+    // Need interpolation in this dimension
+    curIndex(indexNum) = i0;
+    real_type value;
+    value = (i1 - ridx) * interpolator(indexNum-1, curIndex, interp);
+    
+    curIndex(indexNum) = i1;
+    value += (ridx - i0) * interpolator(indexNum-1, curIndex, interp);
+    
+    return value;
   }
 
   real_type* mData;



From frohlich at berlios.de  Sun Dec 18 21:24:21 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Sun, 18 Dec 2005 21:24:21 +0100
Subject: [OpenFDM-svn] r102 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200512182024.jBIKOLWT029832@sheep.berlios.de>

Author: frohlich
Date: 2005-12-18 21:24:18 +0100 (Sun, 18 Dec 2005)
New Revision: 102

Modified:
   trunk/OpenFDM/src/OpenFDM/Model.cpp
   trunk/OpenFDM/src/OpenFDM/Model.h
Log:
Make the parent of a Model a Model.


Modified: trunk/OpenFDM/src/OpenFDM/Model.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Model.cpp	2005-12-17 09:04:30 UTC (rev 101)
+++ trunk/OpenFDM/src/OpenFDM/Model.cpp	2005-12-18 20:24:18 UTC (rev 102)
@@ -3,7 +3,6 @@
  */
 
 #include "LogStream.h"
-#include "ModelGroup.h"
 #include "ModelVisitor.h"
 #include "Model.h"
 
@@ -37,13 +36,6 @@
   visitor.apply(*this);
 }
 
-void
-Model::ascend(ModelVisitor& visitor)
-{
-  if (mParentModel)
-    mParentModel->accept(visitor);
-}
-
 const ModelGroup*
 Model::toModelGroup(void) const
 {
@@ -276,13 +268,13 @@
 }
 
 void
-Model::setParent(ModelGroup* modelGroup)
+Model::setParent(Model* model)
 {
   if (mParentModel) {
     mParentModel->adjustNumDiscreteStates(0, getNumDiscreteStates());
     mParentModel->adjustNumContinousStates(0, getNumContinousStates());
   }
-  mParentModel = modelGroup;
+  mParentModel = model;
   if (mParentModel) {
     mParentModel->adjustNumDiscreteStates(getNumDiscreteStates(), 0);
     mParentModel->adjustNumContinousStates(getNumContinousStates(), 0);

Modified: trunk/OpenFDM/src/OpenFDM/Model.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Model.h	2005-12-17 09:04:30 UTC (rev 101)
+++ trunk/OpenFDM/src/OpenFDM/Model.h	2005-12-18 20:24:18 UTC (rev 102)
@@ -39,7 +39,8 @@
 //   virtual void accept(ConstModelVisitor& visitor) const;
 
   /// Hmm ...
-  void ascend(ModelVisitor& visitor);
+  void ascend(ModelVisitor& visitor)
+  { if (mParentModel) mParentModel->accept(visitor); }
 
   virtual const ModelGroup* toModelGroup(void) const;
   virtual ModelGroup* toModelGroup(void);
@@ -142,16 +143,17 @@
   void setOutputPort(unsigned i, const std::string& name, M* model,
                      const Matrix& (M::*getter)(void) const)
   { setOutputPort(i, name, new MatrixGetterPortInterface<M>(model, getter)); }
+
 private:
   // Sets the parent model.
   // That is the one which is informed if the number of states changes.
-  void setParent(ModelGroup* modelGroup);
-  const ModelGroup* getParent(void) const { return mParentModel; }
-  ModelGroup* getParent(void) { return mParentModel; }
+  const Model* getParent(void) const { return mParentModel; }
+  Model* getParent(void) { return mParentModel; }
+  void setParent(Model* model);
   void adjustNumContinousStates(unsigned newCount, unsigned oldCount);
   void adjustNumDiscreteStates(unsigned newCount, unsigned oldCount);
 
-  managed_ptr<ModelGroup> mParentModel;
+  managed_ptr<Model> mParentModel;
   unsigned mNumContinousStates;
   unsigned mNumDiscreteStates;
   bool mDirectFeedThrough;



From frohlich at berlios.de  Wed Dec 21 20:44:14 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Wed, 21 Dec 2005 20:44:14 +0100
Subject: [OpenFDM-svn] r103 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200512211944.jBLJiEAh002077@sheep.berlios.de>

Author: frohlich
Date: 2005-12-21 20:43:41 +0100 (Wed, 21 Dec 2005)
New Revision: 103

Modified:
   trunk/OpenFDM/src/OpenFDM/LogStream.h
Log:
Add new Log Category


Modified: trunk/OpenFDM/src/OpenFDM/LogStream.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/LogStream.h	2005-12-18 20:24:18 UTC (rev 102)
+++ trunk/OpenFDM/src/OpenFDM/LogStream.h	2005-12-21 19:43:41 UTC (rev 103)
@@ -13,26 +13,27 @@
 namespace Log {
 
 enum Category {
-  ArtBody = 1,
-  TimeStep = 1 << 2,
-  BoundCheck = 1 << 3,
-  Environment = 1 << 4,
-  Initialization = 1 << 5,
-  NewtonMethod = 1 << 6,
-  Misc = 1 << 7,
-  Model = 1 << 8,
-  Schedule = 1 << 9,
-  Assert = ~0
+  ArtBody          = 1,
+  MultiBody        = ArtBody << 1,
+  TimeStep         = MultiBody << 1,
+  BoundCheck       = TimeStep << 1,
+  Environment      = BoundCheck << 1,
+  Initialization   = Environment << 1,
+  NewtonMethod     = Initialization << 1,
+  Misc             = NewtonMethod << 1,
+  Model            = Misc << 1,
+  Schedule         = Model << 1,
+  Assert           = ~0
 };
 
 enum Priority {
-  Error = 0,
-  Warning = 1,
-  Info = 2,
-  Debug = 3,
-  Debug1 = 4,
-  Debug2 = 5,
-  Debug3 = 6
+  Error            = 0,
+  Warning          = Error + 1,
+  Info             = Warning + 1,
+  Debug            = Info + 1,
+  Debug1           = Debug + 1,
+  Debug2           = Debug1 + 1,
+  Debug3           = Debug2 + 1
 };
 
 template<Category category, Priority priority>



From frohlich at berlios.de  Fri Dec 23 08:14:43 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Fri, 23 Dec 2005 08:14:43 +0100
Subject: [OpenFDM-svn] r104 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200512230714.jBN7EhKr013013@sheep.berlios.de>

Author: frohlich
Date: 2005-12-23 08:14:30 +0100 (Fri, 23 Dec 2005)
New Revision: 104

Modified:
   trunk/OpenFDM/src/OpenFDM/Object.h
Log:
Add hint for further improovements.


Modified: trunk/OpenFDM/src/OpenFDM/Object.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Object.h	2005-12-21 19:43:41 UTC (rev 103)
+++ trunk/OpenFDM/src/OpenFDM/Object.h	2005-12-23 07:14:30 UTC (rev 104)
@@ -87,6 +87,10 @@
   friend class managed_ptr;
 };
 
+
+/// FIXME: remove the direct accessors, only copy to a shared_ptr
+/// Where you can access then, may be similar to the std::tr2::weak_ptr::lock()
+/// function. That is to avoid deletioin of a currently used object
 template<typename T>
 class managed_ptr {
 public:



From frohlich at berlios.de  Fri Dec 23 08:15:43 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Fri, 23 Dec 2005 08:15:43 +0100
Subject: [OpenFDM-svn] r105 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200512230715.jBN7Fh9I013373@sheep.berlios.de>

Author: frohlich
Date: 2005-12-23 08:15:37 +0100 (Fri, 23 Dec 2005)
New Revision: 105

Modified:
   trunk/OpenFDM/src/OpenFDM/Force.h
Log:
Remive unused and incomplete method.


Modified: trunk/OpenFDM/src/OpenFDM/Force.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Force.h	2005-12-23 07:14:30 UTC (rev 104)
+++ trunk/OpenFDM/src/OpenFDM/Force.h	2005-12-23 07:15:37 UTC (rev 105)
@@ -27,16 +27,6 @@
   virtual Force* toForce(void);
   virtual const Force* toForce(void) const;
 
-  void applyForce(RigidBody& body) const
-  {
-    // What about that??
-    if (&body == getParentFrame(0)) {
-    } else if (&body == getParentFrame(1)) {
-    } else {
-      // error
-    }
-  }
-
   /**
    */
   virtual const Vector6& getForce(Frame *parent) const = 0;



From frohlich at berlios.de  Fri Dec 23 09:25:33 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Fri, 23 Dec 2005 09:25:33 +0100
Subject: [OpenFDM-svn] r106 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200512230825.jBN8PX01014780@sheep.berlios.de>

Author: frohlich
Date: 2005-12-23 09:25:22 +0100 (Fri, 23 Dec 2005)
New Revision: 106

Modified:
   trunk/OpenFDM/src/OpenFDM/Object.h
   trunk/OpenFDM/src/OpenFDM/RefPtr.h
Log:
More hints


Modified: trunk/OpenFDM/src/OpenFDM/Object.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Object.h	2005-12-23 07:15:37 UTC (rev 105)
+++ trunk/OpenFDM/src/OpenFDM/Object.h	2005-12-23 08:25:22 UTC (rev 106)
@@ -91,6 +91,8 @@
 /// FIXME: remove the direct accessors, only copy to a shared_ptr
 /// Where you can access then, may be similar to the std::tr2::weak_ptr::lock()
 /// function. That is to avoid deletioin of a currently used object
+// FIXME: rename to WeakPtr in the spirit of OpenFDM's naming and not to
+// collide with std::tr2's shared_ptr ...
 template<typename T>
 class managed_ptr {
 public:

Modified: trunk/OpenFDM/src/OpenFDM/RefPtr.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RefPtr.h	2005-12-23 07:15:37 UTC (rev 105)
+++ trunk/OpenFDM/src/OpenFDM/RefPtr.h	2005-12-23 08:25:22 UTC (rev 106)
@@ -14,6 +14,8 @@
 template<typename T>
 class managed_ptr;
 
+// FIXME: rename to SharedPtr in the spirit of OpenFDM's naming and not to
+// collide with std::tr2's shared_ptr ...
 template<typename T>
 class shared_ptr {
 public:



From frohlich at berlios.de  Fri Dec 23 09:34:28 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Fri, 23 Dec 2005 09:34:28 +0100
Subject: [OpenFDM-svn] r107 - in trunk/OpenFDM/src: JSBSim OpenFDM
Message-ID: <200512230834.jBN8YSsG020156@sheep.berlios.de>

Author: frohlich
Date: 2005-12-23 09:34:14 +0100 (Fri, 23 Dec 2005)
New Revision: 107

Added:
   trunk/OpenFDM/src/OpenFDM/SharedPtr.h
Removed:
   trunk/OpenFDM/src/OpenFDM/RefPtr.h
Modified:
   trunk/OpenFDM/src/JSBSim/JSBSimFCSComponent.h
   trunk/OpenFDM/src/OpenFDM/CowPtr.h
   trunk/OpenFDM/src/OpenFDM/Makefile.am
   trunk/OpenFDM/src/OpenFDM/Variant.h
Log:
Rename RefPtr.h to SharedPtr.h


Modified: trunk/OpenFDM/src/JSBSim/JSBSimFCSComponent.h
===================================================================
--- trunk/OpenFDM/src/JSBSim/JSBSimFCSComponent.h	2005-12-23 08:25:22 UTC (rev 106)
+++ trunk/OpenFDM/src/JSBSim/JSBSimFCSComponent.h	2005-12-23 08:34:14 UTC (rev 107)
@@ -7,7 +7,7 @@
 
 #include <string>
 #include <OpenFDM/Referenced.h>
-#include <OpenFDM/RefPtr.h>
+#include <OpenFDM/SharedPtr.h>
 
 namespace OpenFDM {
 

Modified: trunk/OpenFDM/src/OpenFDM/CowPtr.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/CowPtr.h	2005-12-23 08:25:22 UTC (rev 106)
+++ trunk/OpenFDM/src/OpenFDM/CowPtr.h	2005-12-23 08:34:14 UTC (rev 107)
@@ -7,7 +7,7 @@
 
 #include "Assert.h"
 #include "Referenced.h"
-#include "RefPtr.h"
+#include "SharedPtr.h"
 
 namespace OpenFDM {
 

Modified: trunk/OpenFDM/src/OpenFDM/Makefile.am
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Makefile.am	2005-12-23 08:25:22 UTC (rev 106)
+++ trunk/OpenFDM/src/OpenFDM/Makefile.am	2005-12-23 08:34:14 UTC (rev 107)
@@ -98,7 +98,6 @@
   Quaternion.h \
   ReaderWriter.h \
   Referenced.h \
-  RefPtr.h \
   RevoluteActuator.h \
   RevoluteJoint.h \
   RigidBody.h \
@@ -106,6 +105,7 @@
   RootFrame.h \
   SampleTime.h \
   Saturation.h \
+  SharedPtr.h \
   Sensor.h \
   SimpleContact.h \
   SimpleGear.h \

Deleted: trunk/OpenFDM/src/OpenFDM/RefPtr.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RefPtr.h	2005-12-23 08:25:22 UTC (rev 106)
+++ trunk/OpenFDM/src/OpenFDM/RefPtr.h	2005-12-23 08:34:14 UTC (rev 107)
@@ -1,90 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
- *
- */
-
-#ifndef OpenFDM_RefPtr_H
-#define OpenFDM_RefPtr_H
-
-#include "Referenced.h"
-
-namespace OpenFDM {
-
-template<typename T>
-class shared_ptr;
-template<typename T>
-class managed_ptr;
-
-// FIXME: rename to SharedPtr in the spirit of OpenFDM's naming and not to
-// collide with std::tr2's shared_ptr ...
-template<typename T>
-class shared_ptr {
-public:
-  shared_ptr(void) : _ptr(0)
-  {}
-  shared_ptr(T* ptr) : _ptr(ptr)
-  { get(_ptr); }
-  shared_ptr(const shared_ptr& p) : _ptr(p._ptr)
-  { get(_ptr); }
-  template<typename U>
-  shared_ptr(const shared_ptr<U>& p) : _ptr(p._ptr)
-  { get(_ptr); }
-  template<typename U>
-  shared_ptr(const managed_ptr<U>& p) : _ptr(p._ptr)
-  { get(_ptr); }
-  ~shared_ptr(void)
-  { put(); }
-  
-  shared_ptr& operator=(const shared_ptr& p)
-  { assign(p._ptr); return *this; }
-  template<typename U>
-  shared_ptr& operator=(const shared_ptr<U>& p)
-  { assign(p._ptr); return *this; }
-  template<typename U>
-  shared_ptr& operator=(U* p)
-  { assign(p); return *this; }
-  template<typename U>
-  shared_ptr& operator=(const managed_ptr<U>& p)
-  { assign(p._ptr); return *this; }
-
-  T* operator->(void)
-  { return _ptr; }
-  const T* operator->(void) const
-  { return _ptr; }
-  T& operator*(void)
-  { return *_ptr; }
-  const T& operator*(void) const
-  { return *_ptr; }
-
-  operator T*(void)
-  { return _ptr; }
-  operator const T*(void) const
-  { return _ptr; }
-
-  bool isShared(void) const
-  { return Referenced::shared(_ptr); }
-  unsigned getNumRefs(void) const
-  { return Referenced::count(_ptr); }
-
-private:
-  template<typename U>
-  void assign(U* p)
-  { get(p); put(); _ptr = p; }
-
-  template<typename U>
-  void get(const U* p) const
-  { Referenced::get(p); }
-  void put(void)
-  { if (!Referenced::put(_ptr)) { delete _ptr; _ptr = 0; } }
-  
-  // The reference itself.
-  T* _ptr;
-
-  template<typename U>
-  friend class shared_ptr;
-  template<typename U>
-  friend class managed_ptr;
-};
-
-} // namespace OpenFDM
-
-#endif

Copied: trunk/OpenFDM/src/OpenFDM/SharedPtr.h (from rev 106, trunk/OpenFDM/src/OpenFDM/RefPtr.h)
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RefPtr.h	2005-12-23 08:25:22 UTC (rev 106)
+++ trunk/OpenFDM/src/OpenFDM/SharedPtr.h	2005-12-23 08:34:14 UTC (rev 107)
@@ -0,0 +1,90 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_SharedPtr_H
+#define OpenFDM_SharedPtr_H
+
+#include "Referenced.h"
+
+namespace OpenFDM {
+
+template<typename T>
+class shared_ptr;
+template<typename T>
+class managed_ptr;
+
+// FIXME: rename to SharedPtr in the spirit of OpenFDM's naming and not to
+// collide with std::tr2's shared_ptr ...
+template<typename T>
+class shared_ptr {
+public:
+  shared_ptr(void) : _ptr(0)
+  {}
+  shared_ptr(T* ptr) : _ptr(ptr)
+  { get(_ptr); }
+  shared_ptr(const shared_ptr& p) : _ptr(p._ptr)
+  { get(_ptr); }
+  template<typename U>
+  shared_ptr(const shared_ptr<U>& p) : _ptr(p._ptr)
+  { get(_ptr); }
+  template<typename U>
+  shared_ptr(const managed_ptr<U>& p) : _ptr(p._ptr)
+  { get(_ptr); }
+  ~shared_ptr(void)
+  { put(); }
+  
+  shared_ptr& operator=(const shared_ptr& p)
+  { assign(p._ptr); return *this; }
+  template<typename U>
+  shared_ptr& operator=(const shared_ptr<U>& p)
+  { assign(p._ptr); return *this; }
+  template<typename U>
+  shared_ptr& operator=(U* p)
+  { assign(p); return *this; }
+  template<typename U>
+  shared_ptr& operator=(const managed_ptr<U>& p)
+  { assign(p._ptr); return *this; }
+
+  T* operator->(void)
+  { return _ptr; }
+  const T* operator->(void) const
+  { return _ptr; }
+  T& operator*(void)
+  { return *_ptr; }
+  const T& operator*(void) const
+  { return *_ptr; }
+
+  operator T*(void)
+  { return _ptr; }
+  operator const T*(void) const
+  { return _ptr; }
+
+  bool isShared(void) const
+  { return Referenced::shared(_ptr); }
+  unsigned getNumRefs(void) const
+  { return Referenced::count(_ptr); }
+
+private:
+  template<typename U>
+  void assign(U* p)
+  { get(p); put(); _ptr = p; }
+
+  template<typename U>
+  void get(const U* p) const
+  { Referenced::get(p); }
+  void put(void)
+  { if (!Referenced::put(_ptr)) { delete _ptr; _ptr = 0; } }
+  
+  // The reference itself.
+  T* _ptr;
+
+  template<typename U>
+  friend class shared_ptr;
+  template<typename U>
+  friend class managed_ptr;
+};
+
+} // namespace OpenFDM
+
+#endif

Modified: trunk/OpenFDM/src/OpenFDM/Variant.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Variant.h	2005-12-23 08:25:22 UTC (rev 106)
+++ trunk/OpenFDM/src/OpenFDM/Variant.h	2005-12-23 08:34:14 UTC (rev 107)
@@ -9,7 +9,7 @@
 
 #include "Types.h"
 #include "Referenced.h"
-#include "RefPtr.h"
+#include "SharedPtr.h"
 #include "Matrix.h"
 
 namespace OpenFDM {



From frohlich at berlios.de  Fri Dec 23 09:48:43 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Fri, 23 Dec 2005 09:48:43 +0100
Subject: [OpenFDM-svn] r108 - in trunk/OpenFDM/src: JSBSim OpenFDM OpenFDM/XML builder
Message-ID: <200512230848.jBN8mh2N024295@sheep.berlios.de>

Author: frohlich
Date: 2005-12-23 09:47:44 +0100 (Fri, 23 Dec 2005)
New Revision: 108

Modified:
   trunk/OpenFDM/src/JSBSim/JSBSimAerosurfaceScale.h
   trunk/OpenFDM/src/JSBSim/JSBSimFCSComponent.h
   trunk/OpenFDM/src/JSBSim/JSBSimKinemat.h
   trunk/OpenFDM/src/JSBSim/JSBSimScheduledGain.h
   trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
   trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.h
   trunk/OpenFDM/src/OpenFDM/AeroForce.h
   trunk/OpenFDM/src/OpenFDM/BinaryFunctionModel.h
   trunk/OpenFDM/src/OpenFDM/Contact.h
   trunk/OpenFDM/src/OpenFDM/CowPtr.h
   trunk/OpenFDM/src/OpenFDM/Environment.h
   trunk/OpenFDM/src/OpenFDM/EnvironmentObject.h
   trunk/OpenFDM/src/OpenFDM/Frame.h
   trunk/OpenFDM/src/OpenFDM/FreeJoint.h
   trunk/OpenFDM/src/OpenFDM/Model.cpp
   trunk/OpenFDM/src/OpenFDM/Model.h
   trunk/OpenFDM/src/OpenFDM/ModelGroup.cpp
   trunk/OpenFDM/src/OpenFDM/ModelGroup.h
   trunk/OpenFDM/src/OpenFDM/MultiBodyModel.h
   trunk/OpenFDM/src/OpenFDM/ODESolver.h
   trunk/OpenFDM/src/OpenFDM/Object.h
   trunk/OpenFDM/src/OpenFDM/Port.cpp
   trunk/OpenFDM/src/OpenFDM/Port.h
   trunk/OpenFDM/src/OpenFDM/PrismaticJoint.h
   trunk/OpenFDM/src/OpenFDM/Property.h
   trunk/OpenFDM/src/OpenFDM/ReaderWriter.h
   trunk/OpenFDM/src/OpenFDM/RevoluteJoint.h
   trunk/OpenFDM/src/OpenFDM/RootFrame.h
   trunk/OpenFDM/src/OpenFDM/SharedPtr.h
   trunk/OpenFDM/src/OpenFDM/System.h
   trunk/OpenFDM/src/OpenFDM/UnaryFunctionModel.h
   trunk/OpenFDM/src/OpenFDM/Variant.h
   trunk/OpenFDM/src/OpenFDM/Vehicle.h
   trunk/OpenFDM/src/OpenFDM/WheelContact.h
   trunk/OpenFDM/src/OpenFDM/XML/XMLReader.h
   trunk/OpenFDM/src/OpenFDM/main.cpp
   trunk/OpenFDM/src/builder/Configuration.cpp
   trunk/OpenFDM/src/builder/Configuration.h
Log:
Rename shared_ptr->SharedPtr and managed_ptr->WeakPtr


Modified: trunk/OpenFDM/src/JSBSim/JSBSimAerosurfaceScale.h
===================================================================
--- trunk/OpenFDM/src/JSBSim/JSBSimAerosurfaceScale.h	2005-12-23 08:34:14 UTC (rev 107)
+++ trunk/OpenFDM/src/JSBSim/JSBSimAerosurfaceScale.h	2005-12-23 08:47:44 UTC (rev 108)
@@ -23,7 +23,7 @@
   void setMaxValue(real_type maxValue);
 
 private:
-  shared_ptr<Table1D> mTable;
+  SharedPtr<Table1D> mTable;
 };
 
 } //namespace OpenFDM

Modified: trunk/OpenFDM/src/JSBSim/JSBSimFCSComponent.h
===================================================================
--- trunk/OpenFDM/src/JSBSim/JSBSimFCSComponent.h	2005-12-23 08:34:14 UTC (rev 107)
+++ trunk/OpenFDM/src/JSBSim/JSBSimFCSComponent.h	2005-12-23 08:47:44 UTC (rev 108)
@@ -38,7 +38,7 @@
   ModelGroup* getModelGroup(void)
   { return mModelGroup; }
 private:
-  shared_ptr<ModelGroup> mModelGroup;
+  SharedPtr<ModelGroup> mModelGroup;
 };
 
 } //namespace OpenFDM

Modified: trunk/OpenFDM/src/JSBSim/JSBSimKinemat.h
===================================================================
--- trunk/OpenFDM/src/JSBSim/JSBSimKinemat.h	2005-12-23 08:34:14 UTC (rev 107)
+++ trunk/OpenFDM/src/JSBSim/JSBSimKinemat.h	2005-12-23 08:47:44 UTC (rev 108)
@@ -24,10 +24,10 @@
 
 private:
   bool mNoScale;
-  shared_ptr<Gain> mInputGain;
-  shared_ptr<Saturation> mInputSaturation;
-  shared_ptr<Saturation> mKinematRateLimit;
-  shared_ptr<Gain> mOutputNormGain;
+  SharedPtr<Gain> mInputGain;
+  SharedPtr<Saturation> mInputSaturation;
+  SharedPtr<Saturation> mKinematRateLimit;
+  SharedPtr<Gain> mOutputNormGain;
 };
 
 } //namespace OpenFDM

Modified: trunk/OpenFDM/src/JSBSim/JSBSimScheduledGain.h
===================================================================
--- trunk/OpenFDM/src/JSBSim/JSBSimScheduledGain.h	2005-12-23 08:34:14 UTC (rev 107)
+++ trunk/OpenFDM/src/JSBSim/JSBSimScheduledGain.h	2005-12-23 08:47:44 UTC (rev 108)
@@ -25,7 +25,7 @@
   void setTableData(const TableData<1>& tableData, const TableLookup& lookup);
 
 private:
-  shared_ptr<Table1D> mTable;
+  SharedPtr<Table1D> mTable;
 };
 
 } //namespace OpenFDM

Modified: trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
===================================================================
--- trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2005-12-23 08:34:14 UTC (rev 107)
+++ trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2005-12-23 08:47:44 UTC (rev 108)
@@ -1112,9 +1112,9 @@
   // value. This one is stored here.
   mPrevousFCSOutput = 0;
   
-  std::list<shared_ptr<const XMLElement> > comps
+  std::list<SharedPtr<const XMLElement> > comps
     = fcsElem->getElements("COMPONENT");
-  std::list<shared_ptr<const XMLElement> >::const_iterator it;
+  std::list<SharedPtr<const XMLElement> >::const_iterator it;
   for (it = comps.begin(); it != comps.end(); ++it) {
     if (!convertFCSComponent((*it)->getAttribute("TYPE"),
                              (*it)->getAttribute("NAME"),
@@ -1137,18 +1137,18 @@
   std::stringstream datastr(data);
 
   // The model we put into the fcs group in the end ...
-  shared_ptr<Model> model;
-  shared_ptr<DeadBand> deadband;
-  shared_ptr<Summer> summer;
-  shared_ptr<Gain> gain;
-  shared_ptr<DiscreteTransferFunction> discreteTransfFunc;
-  shared_ptr<JSBSimAerosurfaceScale> asScale;
-  shared_ptr<JSBSimKinemat> kinemat;
-  shared_ptr<JSBSimScheduledGain> sGain;
+  SharedPtr<Model> model;
+  SharedPtr<DeadBand> deadband;
+  SharedPtr<Summer> summer;
+  SharedPtr<Gain> gain;
+  SharedPtr<DiscreteTransferFunction> discreteTransfFunc;
+  SharedPtr<JSBSimAerosurfaceScale> asScale;
+  SharedPtr<JSBSimKinemat> kinemat;
+  SharedPtr<JSBSimScheduledGain> sGain;
 
   // The final output property.
-  shared_ptr<Port> out;
-  shared_ptr<Port> normOut;
+  SharedPtr<Port> out;
+  SharedPtr<Port> normOut;
 
   // JSBSim FCS output values contain some implicit rules.
   // From the component name a default output property is formed.
@@ -1275,12 +1275,12 @@
 
   // The output expression from the prevous FCS block.
   // This is the default input value for this FCS block.
-  std::list<shared_ptr<Port> > inputs;
+  std::list<SharedPtr<Port> > inputs;
 
   // Collect any expressions for the output chain here.
-  shared_ptr<Saturation> saturation;
-  shared_ptr<Bias> outbias;
-  shared_ptr<Gain> outgain;
+  SharedPtr<Saturation> saturation;
+  SharedPtr<Bias> outbias;
+  SharedPtr<Gain> outgain;
   bool outInvert = false;
 
   for (;;) {
@@ -1604,7 +1604,7 @@
     inputs.push_back(mPrevousFCSOutput);
 
   unsigned idx = 0;
-  for (std::list<shared_ptr<Port> >::iterator it = inputs.begin();
+  for (std::list<SharedPtr<Port> >::iterator it = inputs.begin();
        it != inputs.end(); ++it) {
     // FIXME!!!!!!
     if (summer && summer->getNumInputPorts() <= idx)
@@ -1679,8 +1679,8 @@
   unsigned engineNumber = 0;
   unsigned tankNumber = 0;
 
-  std::list<shared_ptr<XMLElement> > elems = pElem->getElements();
-  std::list<shared_ptr<XMLElement> >::const_iterator it;
+  std::list<SharedPtr<XMLElement> > elems = pElem->getElements();
+  std::list<SharedPtr<XMLElement> >::const_iterator it;
   for (it = elems.begin(); it != elems.end(); ++it) {
     if ((*it)->getName() == "AC_ENGINE") {
 //       std::string engineFile = mEnginePath+(*it)->getAttribute("FILE")+".xml";
@@ -1859,26 +1859,26 @@
 bool
 LegacyJSBSimReader::convertAerodynamics(const XMLElement* aerodynamics)
 {
-  std::list<shared_ptr<XMLElement> > elems = aerodynamics->getElements();
-  std::list<shared_ptr<XMLElement> >::const_iterator it;
+  std::list<SharedPtr<XMLElement> > elems = aerodynamics->getElements();
+  std::list<SharedPtr<XMLElement> >::const_iterator it;
   for (it = elems.begin(); it != elems.end(); ++it) {
     std::string axisname = (*it)->getAttribute("NAME");
 
-    shared_ptr<UnitToSiExpressionImpl> toNewton
+    SharedPtr<UnitToSiExpressionImpl> toNewton
       = new UnitToSiExpressionImpl(uPoundForce);
-    shared_ptr<UnitToSiExpressionImpl> toNewtonMeter
+    SharedPtr<UnitToSiExpressionImpl> toNewtonMeter
       = new UnitToSiExpressionImpl(uPoundForceFt);
-    shared_ptr<SumExpressionImpl> sum = new SumExpressionImpl;
+    SharedPtr<SumExpressionImpl> sum = new SumExpressionImpl;
     toNewtonMeter->setInputProperty(TypedProperty<real_type>(sum));
     toNewton->setInputProperty(TypedProperty<real_type>(sum));
     if (axisname == "LIFT") {
-      shared_ptr<MinusExpressionImpl> minus = new MinusExpressionImpl;
+      SharedPtr<MinusExpressionImpl> minus = new MinusExpressionImpl;
       minus->setInputProperty(TypedProperty<real_type>(toNewton));
       mAeroForce->addStabilityAxisSummand(AeroForce::LiftAxis,
                                           TypedProperty<real_type>(minus));
     }
     else if (axisname == "DRAG") {
-      shared_ptr<MinusExpressionImpl> minus = new MinusExpressionImpl;
+      SharedPtr<MinusExpressionImpl> minus = new MinusExpressionImpl;
       minus->setInputProperty(TypedProperty<real_type>(toNewton));
       mAeroForce->addStabilityAxisSummand(AeroForce::DragAxis,
                                           TypedProperty<real_type>(minus));
@@ -1912,14 +1912,14 @@
                                         SumExpressionImpl* sum,
                                         ProductExpressionImpl* prod)
 {
-  std::list<shared_ptr<XMLElement> > elems = aeroSummands->getElements();
-  std::list<shared_ptr<XMLElement> >::const_iterator it;
+  std::list<SharedPtr<XMLElement> > elems = aeroSummands->getElements();
+  std::list<SharedPtr<XMLElement> >::const_iterator it;
   for (it = elems.begin(); it != elems.end(); ++it) {
     if ((*it)->getName() == "GROUP") {
      
-      shared_ptr<ProductExpressionImpl> newProd = new ProductExpressionImpl;
+      SharedPtr<ProductExpressionImpl> newProd = new ProductExpressionImpl;
       sum->addInputProperty(TypedProperty<real_type>(newProd));
-      shared_ptr<SumExpressionImpl> newSum = new SumExpressionImpl;
+      SharedPtr<SumExpressionImpl> newSum = new SumExpressionImpl;
       newProd->addInputProperty(TypedProperty<real_type>(newSum));
 
       if (!convertAEROSummands(*it, newSum, newProd))

Modified: trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.h
===================================================================
--- trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.h	2005-12-23 08:34:14 UTC (rev 107)
+++ trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.h	2005-12-23 08:47:44 UTC (rev 108)
@@ -30,7 +30,7 @@
 // 
 /// FIXME!!!!!!!!
 class PropertyMap
-  : public std::map<std::string,shared_ptr<Port> > {
+  : public std::map<std::string,SharedPtr<Port> > {
 public:
   static std::string simplyfy(std::string path)
   {
@@ -43,61 +43,61 @@
 
   mapped_type&
   operator[](const key_type& key)
-  { return std::map<std::string,shared_ptr<Port> >::operator[](simplyfy(key)); }
+  { return std::map<std::string,SharedPtr<Port> >::operator[](simplyfy(key)); }
 
   size_type
   erase(const key_type& key)
-  { return std::map<std::string,shared_ptr<Port> >::erase(simplyfy(key)); }
+  { return std::map<std::string,SharedPtr<Port> >::erase(simplyfy(key)); }
 
   iterator
   find(const key_type& key)
-  { return std::map<std::string,shared_ptr<Port> >::find(simplyfy(key)); }
+  { return std::map<std::string,SharedPtr<Port> >::find(simplyfy(key)); }
 
   const_iterator
   find(const key_type& key) const
-  { return std::map<std::string,shared_ptr<Port> >::find(simplyfy(key)); }
+  { return std::map<std::string,SharedPtr<Port> >::find(simplyfy(key)); }
 
   size_type
   count(const key_type& key) const
-  { return std::map<std::string,shared_ptr<Port> >::count(simplyfy(key)); }
+  { return std::map<std::string,SharedPtr<Port> >::count(simplyfy(key)); }
 
   iterator
   lower_bound(const key_type& key)
-  { return std::map<std::string,shared_ptr<Port> >::lower_bound(simplyfy(key)); }
+  { return std::map<std::string,SharedPtr<Port> >::lower_bound(simplyfy(key)); }
 
   const_iterator
   lower_bound(const key_type& key) const
-  { return std::map<std::string,shared_ptr<Port> >::lower_bound(simplyfy(key)); }
+  { return std::map<std::string,SharedPtr<Port> >::lower_bound(simplyfy(key)); }
 
   iterator
   upper_bound(const key_type& key)
-  { return std::map<std::string,shared_ptr<Port> >::upper_bound(simplyfy(key)); }
+  { return std::map<std::string,SharedPtr<Port> >::upper_bound(simplyfy(key)); }
 
   const_iterator
   upper_bound(const key_type& key) const
-  { return std::map<std::string,shared_ptr<Port> >::upper_bound(simplyfy(key)); }
+  { return std::map<std::string,SharedPtr<Port> >::upper_bound(simplyfy(key)); }
 
   std::pair<iterator,iterator>
   equal_range(const key_type& key)
-  { return std::map<std::string,shared_ptr<Port> >::equal_range(simplyfy(key)); }
+  { return std::map<std::string,SharedPtr<Port> >::equal_range(simplyfy(key)); }
 
   std::pair<const_iterator,const_iterator>
   equal_range(const key_type& key) const
-  { return std::map<std::string,shared_ptr<Port> >::equal_range(simplyfy(key)); }
+  { return std::map<std::string,SharedPtr<Port> >::equal_range(simplyfy(key)); }
 
 
   std::pair<iterator,bool>
   insert(const value_type& val)
   {
     value_type sval(simplyfy(val.first), val.second);
-    return std::map<std::string,shared_ptr<Port> >::insert(sval);
+    return std::map<std::string,SharedPtr<Port> >::insert(sval);
   }
 
   iterator
   insert(iterator position, const value_type& val)
   {
     value_type sval(simplyfy(val.first), val.second);
-    return std::map<std::string,shared_ptr<Port> >::insert(position, sval);
+    return std::map<std::string,SharedPtr<Port> >::insert(position, sval);
   }
 };
 
@@ -216,9 +216,9 @@
     Vector3 cgoff = v - mBodyReference;
     return convertFrom(uInch, Vector3(-cgoff(1), cgoff(2), -cgoff(3)));
   }
-  shared_ptr<Port> mPrevousFCSOutput;
+  SharedPtr<Port> mPrevousFCSOutput;
   PropertyMap mExpressionTable;
-  shared_ptr<AeroForce> mAeroForce;
+  SharedPtr<AeroForce> mAeroForce;
   Vector3 mBodyReference;
 };
 

Modified: trunk/OpenFDM/src/OpenFDM/AeroForce.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/AeroForce.h	2005-12-23 08:34:14 UTC (rev 107)
+++ trunk/OpenFDM/src/OpenFDM/AeroForce.h	2005-12-23 08:47:44 UTC (rev 108)
@@ -125,15 +125,15 @@
   void computeSLAtmosphere(void) const;
   void computeCalEquAirspeed(void) const;
 
-  shared_ptr<SumExpressionImpl> mStabilityAxisSummers[6];
-  shared_ptr<SumExpressionImpl> mBodyAxisSummers[6];
+  SharedPtr<SumExpressionImpl> mStabilityAxisSummers[6];
+  SharedPtr<SumExpressionImpl> mBodyAxisSummers[6];
 
   const Atmosphere* getAtmosphere(void) const
   { return mEnvironment->getAtmosphere(); }
   const Planet* getPlanet(void) const
   { return mEnvironment->getPlanet(); }
 
-  shared_ptr<Environment> mEnvironment;
+  SharedPtr<Environment> mEnvironment;
 
   Vector3 mPosition;
   Rotation mOrientation;

Modified: trunk/OpenFDM/src/OpenFDM/BinaryFunctionModel.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/BinaryFunctionModel.h	2005-12-23 08:34:14 UTC (rev 107)
+++ trunk/OpenFDM/src/OpenFDM/BinaryFunctionModel.h	2005-12-23 08:47:44 UTC (rev 108)
@@ -37,7 +37,7 @@
   Type getType(void) const;
 
 private:
-  shared_ptr<BinaryFunctionModelImpl> mImpl;
+  SharedPtr<BinaryFunctionModelImpl> mImpl;
   Type mType;
   real_type mFunctionValue;
 };

Modified: trunk/OpenFDM/src/OpenFDM/Contact.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Contact.h	2005-12-23 08:34:14 UTC (rev 107)
+++ trunk/OpenFDM/src/OpenFDM/Contact.h	2005-12-23 08:47:44 UTC (rev 108)
@@ -45,7 +45,7 @@
 
   bool mEnabled;
   GroundValues mGroundVal;
-  shared_ptr<Environment> mEnvironment;
+  SharedPtr<Environment> mEnvironment;
 };
 
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/CowPtr.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/CowPtr.h	2005-12-23 08:34:14 UTC (rev 107)
+++ trunk/OpenFDM/src/OpenFDM/CowPtr.h	2005-12-23 08:47:44 UTC (rev 108)
@@ -36,7 +36,7 @@
   { return mPtr; }
 
 private:
-  shared_ptr<T> mPtr;
+  SharedPtr<T> mPtr;
 };
 
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/Environment.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Environment.h	2005-12-23 08:34:14 UTC (rev 107)
+++ trunk/OpenFDM/src/OpenFDM/Environment.h	2005-12-23 08:47:44 UTC (rev 108)
@@ -82,12 +82,12 @@
   void attachEnvironmentObject(EnvironmentObject* environmentObject);
   void detachEnvironmentObject(EnvironmentObject* environmentObject);
 
-  shared_ptr<Atmosphere> mAtmosphere;
-  shared_ptr<Gravity> mGravity;
-  shared_ptr<Ground> mGround;
-  shared_ptr<Planet> mPlanet;
-  shared_ptr<Turbulence> mTurbulence;
-  shared_ptr<Wind> mWind;
+  SharedPtr<Atmosphere> mAtmosphere;
+  SharedPtr<Gravity> mGravity;
+  SharedPtr<Ground> mGround;
+  SharedPtr<Planet> mPlanet;
+  SharedPtr<Turbulence> mTurbulence;
+  SharedPtr<Wind> mWind;
 };
 
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/EnvironmentObject.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/EnvironmentObject.h	2005-12-23 08:34:14 UTC (rev 107)
+++ trunk/OpenFDM/src/OpenFDM/EnvironmentObject.h	2005-12-23 08:47:44 UTC (rev 108)
@@ -25,7 +25,7 @@
 private:
   void attachToEnvironment(Environment* environment);
 
-  managed_ptr<Environment> mEnvironment;
+  WeakPtr<Environment> mEnvironment;
 
   friend class Environment;
 };

Modified: trunk/OpenFDM/src/OpenFDM/Frame.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Frame.h	2005-12-23 08:34:14 UTC (rev 107)
+++ trunk/OpenFDM/src/OpenFDM/Frame.h	2005-12-23 08:47:44 UTC (rev 108)
@@ -46,7 +46,7 @@
   typedef const void* frameid_type;
 
   /// Container for the child frames.
-  typedef std::vector<shared_ptr<Frame> > ChildFrameList;
+  typedef std::vector<SharedPtr<Frame> > ChildFrameList;
 
   Frame(const std::string& name);
   virtual ~Frame(void);
@@ -98,7 +98,7 @@
 
 
   /////////////////////////////////////////
-  typedef std::vector<shared_ptr<MultiBodyModel> > abchild_list;
+  typedef std::vector<SharedPtr<MultiBodyModel> > abchild_list;
   typedef abchild_list::iterator           abchild_iterator;
   typedef abchild_list::const_iterator     const_abchild_iterator;
   abchild_list _children;
@@ -629,7 +629,7 @@
 
   // The parent frame.
   // FIXME: May be we should store a list of all parents ???
-  managed_ptr<Frame> mParentFrame;
+  WeakPtr<Frame> mParentFrame;
   // The list of child frames.
   ChildFrameList mChildFrames;
 };

Modified: trunk/OpenFDM/src/OpenFDM/FreeJoint.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/FreeJoint.h	2005-12-23 08:34:14 UTC (rev 107)
+++ trunk/OpenFDM/src/OpenFDM/FreeJoint.h	2005-12-23 08:47:44 UTC (rev 108)
@@ -93,7 +93,7 @@
 
   /** Reference to the vehicles environment.
    */
-  shared_ptr<Environment> mEnvironment;
+  SharedPtr<Environment> mEnvironment;
 };
 
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/Model.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Model.cpp	2005-12-23 08:34:14 UTC (rev 107)
+++ trunk/OpenFDM/src/OpenFDM/Model.cpp	2005-12-23 08:47:44 UTC (rev 108)
@@ -168,7 +168,7 @@
 Model::getInputPort(const std::string& name)
 {
   // Check if this one exists and return its value.
-  std::vector<shared_ptr<Port> >::iterator it = mInputPorts.begin();
+  std::vector<SharedPtr<Port> >::iterator it = mInputPorts.begin();
   while (it != mInputPorts.end()) {
     if ((*it)->getName() == name)
       return *it;
@@ -193,7 +193,7 @@
 Model::getOutputPort(const std::string& name)
 {
   // Check if this one exists and return its value.
-  std::vector<shared_ptr<Port> >::iterator it = mOutputPorts.begin();
+  std::vector<SharedPtr<Port> >::iterator it = mOutputPorts.begin();
   while (it != mOutputPorts.end()) {
     if ((*it)->getName() == name)
       return *it;
@@ -220,7 +220,7 @@
   if (!getDirectFeedThrough())
     return false;
   // Check if the given model is the source of any input property.
-  std::vector<shared_ptr<Port> >::const_iterator it = mInputPorts.begin();
+  std::vector<SharedPtr<Port> >::const_iterator it = mInputPorts.begin();
   while (it != mInputPorts.end()) {
     if (model == (*it)->getProperty().getObject())
       return true;

Modified: trunk/OpenFDM/src/OpenFDM/Model.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Model.h	2005-12-23 08:34:14 UTC (rev 107)
+++ trunk/OpenFDM/src/OpenFDM/Model.h	2005-12-23 08:47:44 UTC (rev 108)
@@ -153,13 +153,13 @@
   void adjustNumContinousStates(unsigned newCount, unsigned oldCount);
   void adjustNumDiscreteStates(unsigned newCount, unsigned oldCount);
 
-  managed_ptr<Model> mParentModel;
+  WeakPtr<Model> mParentModel;
   unsigned mNumContinousStates;
   unsigned mNumDiscreteStates;
   bool mDirectFeedThrough;
   SampleTimeSet mSampleTimeSet;
-  std::vector<shared_ptr<Port> > mInputPorts;
-  std::vector<shared_ptr<Port> > mOutputPorts;
+  std::vector<SharedPtr<Port> > mInputPorts;
+  std::vector<SharedPtr<Port> > mOutputPorts;
 
   // FIXME
   friend class ModelGroup;

Modified: trunk/OpenFDM/src/OpenFDM/ModelGroup.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/ModelGroup.cpp	2005-12-23 08:34:14 UTC (rev 107)
+++ trunk/OpenFDM/src/OpenFDM/ModelGroup.cpp	2005-12-23 08:47:44 UTC (rev 108)
@@ -358,7 +358,7 @@
 
     // We need to store that one here since the iterator possibly invalidates
     // during the next append dependency call
-    shared_ptr<Model> tmpModel = *it;
+    SharedPtr<Model> tmpModel = *it;
     mModels.erase(it);
 
     // Now recurse into that model.

Modified: trunk/OpenFDM/src/OpenFDM/ModelGroup.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/ModelGroup.h	2005-12-23 08:34:14 UTC (rev 107)
+++ trunk/OpenFDM/src/OpenFDM/ModelGroup.h	2005-12-23 08:47:44 UTC (rev 108)
@@ -66,7 +66,7 @@
   using Model::setNumOutputPorts;
 
 private:
-  typedef std::vector<shared_ptr<Model> > ModelList;
+  typedef std::vector<SharedPtr<Model> > ModelList;
 
   /// Helper functions to sort the models according their dependencies
   static bool dependsOn(Port* inputPort, Model* model);

Modified: trunk/OpenFDM/src/OpenFDM/MultiBodyModel.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/MultiBodyModel.h	2005-12-23 08:34:14 UTC (rev 107)
+++ trunk/OpenFDM/src/OpenFDM/MultiBodyModel.h	2005-12-23 08:47:44 UTC (rev 108)
@@ -92,7 +92,7 @@
   private:
     // The parent node.
     // FIXME: May be we should store a list of all parents ???
-    managed_ptr<Frame> _parent[numParents];
+    WeakPtr<Frame> _parent[numParents];
   };
 
 #define OpenFDM_NodeImplementation(nParents)            \

Modified: trunk/OpenFDM/src/OpenFDM/ODESolver.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/ODESolver.h	2005-12-23 08:34:14 UTC (rev 107)
+++ trunk/OpenFDM/src/OpenFDM/ODESolver.h	2005-12-23 08:47:44 UTC (rev 108)
@@ -65,8 +65,8 @@
   real_type mTime;
   Vector mState;
 
-  /// managed_ptr ???
-  managed_ptr<Model> mModel;
+  /// WeakPtr ???
+  WeakPtr<Model> mModel;
 
   Stats mStats;
 };

Modified: trunk/OpenFDM/src/OpenFDM/Object.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Object.h	2005-12-23 08:34:14 UTC (rev 107)
+++ trunk/OpenFDM/src/OpenFDM/Object.h	2005-12-23 08:47:44 UTC (rev 108)
@@ -14,9 +14,9 @@
 namespace OpenFDM {
 
 template<typename T>
-class shared_ptr;
+class SharedPtr;
 template<typename T>
-class managed_ptr;
+class WeakPtr;
 
 class TypeInfo;
 
@@ -77,47 +77,46 @@
   /// The map of all properties of this object.
   PropertyMap mProperties;
 
-  shared_ptr<Object> mUserData;
+  SharedPtr<Object> mUserData;
 
   mutable std::list<Object**> _ptrList;
 
   template<typename T>
-  friend class shared_ptr;
+  friend class SharedPtr;
   template<typename T>
-  friend class managed_ptr;
+  friend class WeakPtr;
 };
 
 
-/// FIXME: remove the direct accessors, only copy to a shared_ptr
-/// Where you can access then, may be similar to the std::tr2::weak_ptr::lock()
-/// function. That is to avoid deletioin of a currently used object
-// FIXME: rename to WeakPtr in the spirit of OpenFDM's naming and not to
-// collide with std::tr2's shared_ptr ...
+/// FIXME: remove the direct accessors, only copy to a SharedPtr
+/// where you can access then, may be similar to the std::tr2::weak_ptr::lock()
+/// function. That is to avoid deletion of a currently used object
+/// FIXME make const correct ...
 template<typename T>
-class managed_ptr {
+class WeakPtr {
 public:
-  managed_ptr(void) : _ptr(0)
+  WeakPtr(void) : _ptr(0)
   {}
-  managed_ptr(T* ptr) : _ptr(ptr)
+  WeakPtr(T* ptr) : _ptr(ptr)
   { reg(); }
-  managed_ptr(const managed_ptr& p) : _ptr(p._ptr)
+  WeakPtr(const WeakPtr& p) : _ptr(p._ptr)
   { reg(); }
   template<typename U>
-  managed_ptr(const shared_ptr<U>& p) : _ptr(p._ptr)
+  WeakPtr(const SharedPtr<U>& p) : _ptr(p._ptr)
   { reg(); }
-  ~managed_ptr(void)
+  ~WeakPtr(void)
   { dereg(); }
   
   template<typename U>
-  managed_ptr& operator=(const shared_ptr<U>& p)
+  WeakPtr& operator=(const SharedPtr<U>& p)
   { assign(p._ptr); return *this; }
   template<typename U>
-  managed_ptr& operator=(U* p)
+  WeakPtr& operator=(U* p)
   { assign(p); return *this; }
-  managed_ptr& operator=(const managed_ptr& p)
+  WeakPtr& operator=(const WeakPtr& p)
   { assign(p._ptr); return *this; }
   template<typename U>
-  managed_ptr& operator=(const managed_ptr<U>& p)
+  WeakPtr& operator=(const WeakPtr<U>& p)
   { assign(p._ptr); return *this; }
 
   T* operator->(void)
@@ -149,9 +148,9 @@
   Object* _ptr;
 
   template<typename U>
-  friend class shared_ptr;
+  friend class SharedPtr;
   template<typename U>
-  friend class managed_ptr;
+  friend class WeakPtr;
 };
 
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/Port.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Port.cpp	2005-12-23 08:34:14 UTC (rev 107)
+++ trunk/OpenFDM/src/OpenFDM/Port.cpp	2005-12-23 08:47:44 UTC (rev 108)
@@ -22,7 +22,7 @@
 Port::setPortInterface(PortInterface* portInterface)
 {
   mPortInterface = portInterface;
-  std::vector<shared_ptr<Port> >::iterator it;
+  std::vector<SharedPtr<Port> >::iterator it;
   for (it = mChainPorts.begin(); it != mChainPorts.end(); ++it) {
     (*it)->setPortInterface(mPortInterface);
   }
@@ -94,7 +94,7 @@
   
   // Remove ourselves from the consumer list of the sourcePort to
   // disconnect us from
-  std::vector<shared_ptr<Port> >::iterator it, beginPort, endPort;
+  std::vector<SharedPtr<Port> >::iterator it, beginPort, endPort;
   beginPort = sourcePort->mChainPorts.begin();
   endPort = sourcePort->mChainPorts.end();
   it = std::find(beginPort, endPort, this);

Modified: trunk/OpenFDM/src/OpenFDM/Port.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Port.h	2005-12-23 08:34:14 UTC (rev 107)
+++ trunk/OpenFDM/src/OpenFDM/Port.h	2005-12-23 08:47:44 UTC (rev 108)
@@ -90,7 +90,7 @@
   virtual bool isConnected(void) const
   { return mSourceModel && mGetter; }
 private:
-  managed_ptr<M> mSourceModel;
+  WeakPtr<M> mSourceModel;
   Getter mGetter;
 };
 template<typename M>
@@ -105,7 +105,7 @@
   virtual bool isConnected(void) const
   { return mSourceModel && mGetter; }
 private:
-  managed_ptr<M> mSourceModel;
+  WeakPtr<M> mSourceModel;
   Getter mGetter;
 };
 
@@ -121,7 +121,7 @@
   bool isConnected(void) const
   { return mRealPortInterface && mRealPortInterface->isConnected(); }
 private:
-  shared_ptr<RealPortInterface> mRealPortInterface;
+  SharedPtr<RealPortInterface> mRealPortInterface;
 };
 
 class MatrixPortHandle {
@@ -136,7 +136,7 @@
   bool isConnected(void) const
   { return mMatrixPortInterface && mMatrixPortInterface->isConnected(); }
 private:
-  shared_ptr<MatrixPortInterface> mMatrixPortInterface;
+  SharedPtr<MatrixPortInterface> mMatrixPortInterface;
 };
 
 // should vanish, just an adaptor for smoother migration
@@ -212,11 +212,11 @@
   /// For now the untyped input port
   /// On Model::init() it is expected to be specialized
   /// to a typed port handle
-  shared_ptr<PortInterface> mPortInterface;
+  SharedPtr<PortInterface> mPortInterface;
   /// The list of readers for this port
-  std::vector<shared_ptr<Port> > mChainPorts;
+  std::vector<SharedPtr<Port> > mChainPorts;
   /// The source of the current port connection
-  managed_ptr<Port> mSourcePort;
+  WeakPtr<Port> mSourcePort;
 };
 
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/PrismaticJoint.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/PrismaticJoint.h	2005-12-23 08:34:14 UTC (rev 107)
+++ trunk/OpenFDM/src/OpenFDM/PrismaticJoint.h	2005-12-23 08:47:44 UTC (rev 108)
@@ -116,7 +116,7 @@
 
   /** The direct joint interaction force
    */
-  shared_ptr<LineForce> mLineForce;
+  SharedPtr<LineForce> mLineForce;
 };
 
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/Property.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Property.h	2005-12-23 08:34:14 UTC (rev 107)
+++ trunk/OpenFDM/src/OpenFDM/Property.h	2005-12-23 08:47:44 UTC (rev 108)
@@ -170,7 +170,7 @@
   virtual Object* getObject(void) { return mObject; }
 
 private:
-  managed_ptr<O> mObject;
+  WeakPtr<O> mObject;
   GetMethod mGetMethod;
   GetRefMethod mGetRefMethod;
   SetMethod mSetMethod;
@@ -230,7 +230,7 @@
   }
 
 private:
-  shared_ptr<implementation_t> mPropertyImpl;
+  SharedPtr<implementation_t> mPropertyImpl;
 };
 
 typedef TypedProperty<int> IntegerProperty;
@@ -355,7 +355,7 @@
   }
 
 private:
-  shared_ptr<UntypedPropertyImpl> mPropertyImpl;
+  SharedPtr<UntypedPropertyImpl> mPropertyImpl;
 };
 
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/ReaderWriter.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/ReaderWriter.h	2005-12-23 08:34:14 UTC (rev 107)
+++ trunk/OpenFDM/src/OpenFDM/ReaderWriter.h	2005-12-23 08:47:44 UTC (rev 108)
@@ -65,7 +65,7 @@
 
   /** The Vehicle handle.
    */
-  shared_ptr<Vehicle> mVehicle;
+  SharedPtr<Vehicle> mVehicle;
 
 private:
   /** A list of errors during import.

Modified: trunk/OpenFDM/src/OpenFDM/RevoluteJoint.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RevoluteJoint.h	2005-12-23 08:34:14 UTC (rev 107)
+++ trunk/OpenFDM/src/OpenFDM/RevoluteJoint.h	2005-12-23 08:47:44 UTC (rev 108)
@@ -123,7 +123,7 @@
 
   /** The direct joint interaction force
    */
-  shared_ptr<LineForce> mLineForce;
+  SharedPtr<LineForce> mLineForce;
 };
 
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/RootFrame.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RootFrame.h	2005-12-23 08:34:14 UTC (rev 107)
+++ trunk/OpenFDM/src/OpenFDM/RootFrame.h	2005-12-23 08:47:44 UTC (rev 108)
@@ -46,7 +46,7 @@
   virtual void output(const TaskInfo& taskInfo);
   virtual void update(const TaskInfo& taskInfo);
 private:
-  shared_ptr<RootFrame> mRootFrame;
+  SharedPtr<RootFrame> mRootFrame;
 };
 
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/SharedPtr.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/SharedPtr.h	2005-12-23 08:34:14 UTC (rev 107)
+++ trunk/OpenFDM/src/OpenFDM/SharedPtr.h	2005-12-23 08:47:44 UTC (rev 108)
@@ -10,40 +10,39 @@
 namespace OpenFDM {
 
 template<typename T>
-class shared_ptr;
+class SharedPtr;
 template<typename T>
-class managed_ptr;
+class WeakPtr;
 
-// FIXME: rename to SharedPtr in the spirit of OpenFDM's naming and not to
-// collide with std::tr2's shared_ptr ...
+/// FIXME make const correct ...
 template<typename T>
-class shared_ptr {
+class SharedPtr {
 public:
-  shared_ptr(void) : _ptr(0)
+  SharedPtr(void) : _ptr(0)
   {}
-  shared_ptr(T* ptr) : _ptr(ptr)
+  SharedPtr(T* ptr) : _ptr(ptr)
   { get(_ptr); }
-  shared_ptr(const shared_ptr& p) : _ptr(p._ptr)
+  SharedPtr(const SharedPtr& p) : _ptr(p._ptr)
   { get(_ptr); }
   template<typename U>
-  shared_ptr(const shared_ptr<U>& p) : _ptr(p._ptr)
+  SharedPtr(const SharedPtr<U>& p) : _ptr(p._ptr)
   { get(_ptr); }
   template<typename U>
-  shared_ptr(const managed_ptr<U>& p) : _ptr(p._ptr)
+  SharedPtr(const WeakPtr<U>& p) : _ptr(p._ptr)
   { get(_ptr); }
-  ~shared_ptr(void)
+  ~SharedPtr(void)
   { put(); }
   
-  shared_ptr& operator=(const shared_ptr& p)
+  SharedPtr& operator=(const SharedPtr& p)
   { assign(p._ptr); return *this; }
   template<typename U>
-  shared_ptr& operator=(const shared_ptr<U>& p)
+  SharedPtr& operator=(const SharedPtr<U>& p)
   { assign(p._ptr); return *this; }
   template<typename U>
-  shared_ptr& operator=(U* p)
+  SharedPtr& operator=(U* p)
   { assign(p); return *this; }
   template<typename U>
-  shared_ptr& operator=(const managed_ptr<U>& p)
+  SharedPtr& operator=(const WeakPtr<U>& p)
   { assign(p._ptr); return *this; }
 
   T* operator->(void)
@@ -80,9 +79,9 @@
   T* _ptr;
 
   template<typename U>
-  friend class shared_ptr;
+  friend class SharedPtr;
   template<typename U>
-  friend class managed_ptr;
+  friend class WeakPtr;
 };
 
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/System.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/System.h	2005-12-23 08:34:14 UTC (rev 107)
+++ trunk/OpenFDM/src/OpenFDM/System.h	2005-12-23 08:47:44 UTC (rev 108)
@@ -52,7 +52,7 @@
 private:
   /// The timestepper used to get time discrete approximate solutions to the
   /// continous system
-  shared_ptr<ODESolver> mTimestepper;
+  SharedPtr<ODESolver> mTimestepper;
 
   /// Hmm, need to think about this...
   typedef std::vector<TaskInfo> TaskList;

Modified: trunk/OpenFDM/src/OpenFDM/UnaryFunctionModel.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/UnaryFunctionModel.h	2005-12-23 08:34:14 UTC (rev 107)
+++ trunk/OpenFDM/src/OpenFDM/UnaryFunctionModel.h	2005-12-23 08:47:44 UTC (rev 108)
@@ -47,7 +47,7 @@
   Type getType(void) const;
 
 private:
-  shared_ptr<UnaryFunctionModelImpl> mImpl;
+  SharedPtr<UnaryFunctionModelImpl> mImpl;
   Type mType;
   real_type mFunctionValue;
 };

Modified: trunk/OpenFDM/src/OpenFDM/Variant.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Variant.h	2005-12-23 08:34:14 UTC (rev 107)
+++ trunk/OpenFDM/src/OpenFDM/Variant.h	2005-12-23 08:47:44 UTC (rev 108)
@@ -131,7 +131,7 @@
     { return this; }
   };
   
-  shared_ptr<VariantData> mData;
+  SharedPtr<VariantData> mData;
 };
 
 inline Variant&

Modified: trunk/OpenFDM/src/OpenFDM/Vehicle.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Vehicle.h	2005-12-23 08:34:14 UTC (rev 107)
+++ trunk/OpenFDM/src/OpenFDM/Vehicle.h	2005-12-23 08:47:44 UTC (rev 108)
@@ -139,21 +139,21 @@
 
 private:
   // Environment ...
-  shared_ptr<Environment> mEnvironment;
+  SharedPtr<Environment> mEnvironment;
 
-  shared_ptr<RigidBody> mTopBody;
-  shared_ptr<FreeJoint> mFreeJoint;
-  shared_ptr<RootFrame> mRootFrame;
-  shared_ptr<MultiBodySystem> mMultiBodySystem;
+  SharedPtr<RigidBody> mTopBody;
+  SharedPtr<FreeJoint> mFreeJoint;
+  SharedPtr<RootFrame> mRootFrame;
+  SharedPtr<MultiBodySystem> mMultiBodySystem;
 
-  shared_ptr<ModelGroup> mModelGroup;
+  SharedPtr<ModelGroup> mModelGroup;
 
-  shared_ptr<System> mSystem;
+  SharedPtr<System> mSystem;
 
-  std::map<std::string, shared_ptr<Frame> > mFrameIdMap;
-  std::map<std::string, shared_ptr<Joint> > mJointIdMap;
-  std::map<std::string, shared_ptr<RigidBody> > mRigidBodyIdMap;
-  std::map<std::string, shared_ptr<Force> > mForceIdMap;
+  std::map<std::string, SharedPtr<Frame> > mFrameIdMap;
+  std::map<std::string, SharedPtr<Joint> > mJointIdMap;
+  std::map<std::string, SharedPtr<RigidBody> > mRigidBodyIdMap;
+  std::map<std::string, SharedPtr<Force> > mForceIdMap;
 
   // FIXME make a attach blub at id ...
   friend class JSBReader;

Modified: trunk/OpenFDM/src/OpenFDM/WheelContact.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/WheelContact.h	2005-12-23 08:34:14 UTC (rev 107)
+++ trunk/OpenFDM/src/OpenFDM/WheelContact.h	2005-12-23 08:47:44 UTC (rev 108)
@@ -57,7 +57,7 @@
   void getGround(real_type t);
 
   GroundValues mGroundVal;
-  shared_ptr<Environment> mEnvironment;
+  SharedPtr<Environment> mEnvironment;
 
   real_type mWheelRadius;
   real_type mSpringConstant;

Modified: trunk/OpenFDM/src/OpenFDM/XML/XMLReader.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/XML/XMLReader.h	2005-12-23 08:34:14 UTC (rev 107)
+++ trunk/OpenFDM/src/OpenFDM/XML/XMLReader.h	2005-12-23 08:47:44 UTC (rev 108)
@@ -22,8 +22,8 @@
 class XMLElement
   : public Object {
 public:
-  typedef shared_ptr<XMLElement> pointer;
-  typedef shared_ptr<const XMLElement> const_pointer;
+  typedef SharedPtr<XMLElement> pointer;
+  typedef SharedPtr<const XMLElement> const_pointer;
 
   XMLElement(const std::string& name);
   virtual ~XMLElement(void);
@@ -66,15 +66,15 @@
 class XMLDocument
   : public Object {
 public:
-  typedef shared_ptr<XMLDocument> pointer;
-  typedef shared_ptr<const XMLDocument> const_pointer;
+  typedef SharedPtr<XMLDocument> pointer;
+  typedef SharedPtr<const XMLDocument> const_pointer;
 
   XMLElement* getElement(void);
   const XMLElement* getElement(void) const;
   void setElement(XMLElement* top);
 
 private:
-  shared_ptr<XMLElement> mTop;
+  SharedPtr<XMLElement> mTop;
 
   friend class XMLDomParser;
 };
@@ -97,7 +97,7 @@
   const std::string& getErrorMessage(void) const;
 
 private:
-  shared_ptr<XMLDocument> mDoc;
+  SharedPtr<XMLDocument> mDoc;
   std::stack<XMLElement::pointer> mElementStack;
 
   std::string mErrorMessage;

Modified: trunk/OpenFDM/src/OpenFDM/main.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/main.cpp	2005-12-23 08:34:14 UTC (rev 107)
+++ trunk/OpenFDM/src/OpenFDM/main.cpp	2005-12-23 08:47:44 UTC (rev 108)
@@ -305,7 +305,7 @@
       return error("Error loading Models: Empty name!");
 
     std::string type = modelElement->getAttribute("type");
-    shared_ptr<Model> model;
+    SharedPtr<Model> model;
     if (type == "Bias") {
       model = new Bias(name);
     } else if (type == "Const") {
@@ -598,7 +598,7 @@
   
   OpenFDMReader reader;
   reader.loadVehicle(argv[1]);
-  shared_ptr<Vehicle> vehicle = reader.getVehicle();
+  SharedPtr<Vehicle> vehicle = reader.getVehicle();
 
   if (reader.getErrorState()) {
     std::cerr << "Could not read vehicle:" << std::endl;
@@ -638,7 +638,7 @@
   }
 
 #else
-  shared_ptr<Vehicle> vehicle = new Vehicle();
+  SharedPtr<Vehicle> vehicle = new Vehicle();
 
   Geodetic geod;
   geod.longitude = -81.636*deg2rad;

Modified: trunk/OpenFDM/src/builder/Configuration.cpp
===================================================================
--- trunk/OpenFDM/src/builder/Configuration.cpp	2005-12-23 08:34:14 UTC (rev 107)
+++ trunk/OpenFDM/src/builder/Configuration.cpp	2005-12-23 08:47:44 UTC (rev 108)
@@ -6,7 +6,7 @@
 
 namespace OpenFDM {
 
-// shared_ptr<Configuration> Configuration::mConfiguration;
+// SharedPtr<Configuration> Configuration::mConfiguration;
 Configuration* Configuration::mConfiguration = 0;
 
 Configuration::Configuration(void)

Modified: trunk/OpenFDM/src/builder/Configuration.h
===================================================================
--- trunk/OpenFDM/src/builder/Configuration.h	2005-12-23 08:34:14 UTC (rev 107)
+++ trunk/OpenFDM/src/builder/Configuration.h	2005-12-23 08:47:44 UTC (rev 108)
@@ -30,7 +30,7 @@
   Configuration& operator= (const Configuration&);
 
   // The only single instance.
-//   static shared_ptr<Configuration> mConfiguration;
+//   static SharedPtr<Configuration> mConfiguration;
   static Configuration* mConfiguration;
 };
 



From frohlich at berlios.de  Fri Dec 23 09:53:46 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Fri, 23 Dec 2005 09:53:46 +0100
Subject: [OpenFDM-svn] r109 - trunk/flightgear
Message-ID: <200512230853.jBN8rkNL026867@sheep.berlios.de>

Author: frohlich
Date: 2005-12-23 09:53:18 +0100 (Fri, 23 Dec 2005)
New Revision: 109

Modified:
   trunk/flightgear/FGOpenFDM.cpp
   trunk/flightgear/FGPropertyAdapter.h
Log:
Reflect past changes


Modified: trunk/flightgear/FGOpenFDM.cpp
===================================================================
--- trunk/flightgear/FGOpenFDM.cpp	2005-12-23 08:47:44 UTC (rev 108)
+++ trunk/flightgear/FGOpenFDM.cpp	2005-12-23 08:53:18 UTC (rev 109)
@@ -213,8 +213,8 @@
 // Our local storage covers the pointer to our vehicle.
 // A list of the property to expression adaptors.
 struct FGOpenFDMData {
-  OpenFDM::shared_ptr<OpenFDM::Vehicle> vehicle;
-  OpenFDM::shared_ptr<OpenFDM::FGGround> ground;
+  OpenFDM::SharedPtr<OpenFDM::Vehicle> vehicle;
+  OpenFDM::SharedPtr<OpenFDM::FGGround> ground;
 };
 
 FGOpenFDM::FGOpenFDM(SGPropertyNode* fdmRootNode) :

Modified: trunk/flightgear/FGPropertyAdapter.h
===================================================================
--- trunk/flightgear/FGPropertyAdapter.h	2005-12-23 08:47:44 UTC (rev 108)
+++ trunk/flightgear/FGPropertyAdapter.h	2005-12-23 08:53:18 UTC (rev 109)
@@ -40,7 +40,7 @@
 
 private:
   std::string mPropertyName;
-  managed_ptr<Object> mObject;
+  WeakPtr<Object> mObject;
 };
 
 
@@ -151,9 +151,9 @@
   }
 private:
   // Holds the input model where it should write the value
-  // Note that this shal not be a shared_ptr, since we get a recursive
+  // Note that this shal not be a SharedPtr, since we get a recursive
   // ref count loop in that case.
-  managed_ptr<Input> mInputModel;
+  WeakPtr<Input> mInputModel;
 };
 
 // That class just takes care that the listeners to a specific Input are



From frohlich at berlios.de  Fri Dec 23 10:53:37 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Fri, 23 Dec 2005 10:53:37 +0100
Subject: [OpenFDM-svn] r110 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200512230953.jBN9rbds006258@sheep.berlios.de>

Author: frohlich
Date: 2005-12-23 10:53:31 +0100 (Fri, 23 Dec 2005)
New Revision: 110

Modified:
   trunk/OpenFDM/src/OpenFDM/Force.h
Log:
Remove unused and incomplete class


Modified: trunk/OpenFDM/src/OpenFDM/Force.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Force.h	2005-12-23 08:53:18 UTC (rev 109)
+++ trunk/OpenFDM/src/OpenFDM/Force.h	2005-12-23 09:53:31 UTC (rev 110)
@@ -35,68 +35,6 @@
   virtual void computeForce(void) = 0;
 };
 
-class InternalForce
-  : public Force {
-public:
-  OpenFDM_NodeImplementation(2);
-
-  InternalForce(const std::string& name)
-    : Force(name)
-  {}
-  virtual ~InternalForce(void) {}
-
-  virtual const Vector6& getForce(Frame *parent) const
-  {
-    OpenFDMAssert(parent == getParentFrame(0) || parent == getParentFrame(1));
-    if (getParentFrame(0) == parent)
-      return mForce[0];
-    else
-      return mForce[1];
-  }
-
-protected:
-  /**
-   */
- 
-  Vector6 parentXTransform(unsigned fromParent, unsigned toParent,
-                           const Vector6& force)
-  {
-    Frame* parentFrames[2] = { getParentFrame(fromParent), getParentFrame(toParent) };
-    if (!(parentFrames[0] && parentFrames[1]))
-      return Vector6();
-
-    // FIXME don't go over the world's center ...
-    Vector6 refForce = forceFrom(parentFrames[0]->getRefPosition(),
-                                 parentFrames[0]->getRefOrientation(), force);
-
-    return forceTo(parentFrames[1]->getRefPosition(),
-                   parentFrames[1]->getRefOrientation(), refForce);
-  }
-
-  /** Sets the force contribution of this force element.
-   * Sets the force contribution of this current force element to
-   * the parent rigid body with the index parent to force.
-   * The force applied to the other rigid body is transformed accordingly.
-   */
-  void applyForce(unsigned parent, const Vector6& force)
-  {
-    OpenFDMAssert(parent < 2);
-    if (2 <= parent)
-      return;
-
-    if (parent == 0) {
-      mForce[0] = force;
-      mForce[1] = parentXTransform(0, 1, force);
-    } else {
-      mForce[0] = parentXTransform(1, 0, force);
-      mForce[1] = force;
-    }
-  }
-
-private:
-  Vector6 mForce[2];
-};
-
 class ExternalForce
   : public Force {
   OpenFDM_NodeImplementation(1);



From frohlich at berlios.de  Fri Dec 23 14:39:09 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Fri, 23 Dec 2005 14:39:09 +0100
Subject: [OpenFDM-svn] r111 - in trunk/OpenFDM/src: JSBSim OpenFDM
Message-ID: <200512231339.jBNDd972016328@sheep.berlios.de>

Author: frohlich
Date: 2005-12-23 14:38:44 +0100 (Fri, 23 Dec 2005)
New Revision: 111

Modified:
   trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
   trunk/OpenFDM/src/OpenFDM/ConstVisitor.h
   trunk/OpenFDM/src/OpenFDM/Force.cpp
   trunk/OpenFDM/src/OpenFDM/Force.h
   trunk/OpenFDM/src/OpenFDM/Frame.h
   trunk/OpenFDM/src/OpenFDM/ModelVisitor.h
   trunk/OpenFDM/src/OpenFDM/RigidBody.cpp
   trunk/OpenFDM/src/OpenFDM/RigidBody.h
   trunk/OpenFDM/src/OpenFDM/RootFrame.cpp
   trunk/OpenFDM/src/OpenFDM/Visitor.h
Log:
Switch forces to make use of the Interact class


Modified: trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
===================================================================
--- trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2005-12-23 09:53:31 UTC (rev 110)
+++ trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2005-12-23 13:38:44 UTC (rev 111)
@@ -90,7 +90,7 @@
   // Allocate a new vehicle
   mVehicle = new Vehicle;
   mAeroForce = new AeroForce(mVehicle->getEnvironment(), "Aerodynamic force");
-  mVehicle->getTopBody()->addMultiBodyModel(mAeroForce);
+  mVehicle->getTopBody()->addInteract2(mAeroForce);
   // Default discrete stepsize of JSBSim
   mVehicle->getModelGroup()->addSampleTime(SampleTime(1.0/120));
 
@@ -768,7 +768,7 @@
   wc->setSpringConstant(convertFrom(uPoundForcePFt, tireSpring));
   wc->setSpringDamping(convertFrom(uPoundForcePFt, tireDamp));
   wc->setFrictionCoeficient(0.9);
-  wheel->addMultiBodyModel(wc);
+  wheel->addInteract2(wc);
   
   Port* port = wj->getOutputPort(0);
   std::string nameBase = "Wheel " + numStr + " Position";
@@ -821,7 +821,7 @@
         sc->setSpringDamping(convertFrom(uPoundForcePFt, d));
         sc->setFrictionCoeficient(0.1*fs);
         
-        mVehicle->getTopBody()->addMultiBodyModel(sc);
+        mVehicle->getTopBody()->addInteract2(sc);
 
       } else {
         // For jsbsim use simple gears
@@ -879,7 +879,7 @@
           sg->getInputPort("brakeCommand")->connect(port);
         }
         
-        mVehicle->getTopBody()->addMultiBodyModel(sg);
+        mVehicle->getTopBody()->addInteract2(sg);
       }
       
     } else if (uctype == "AC_LAUNCHBAR") {
@@ -1097,7 +1097,7 @@
       sc->setSpringDamping(convertFrom(uPoundForcePFt, d));
       sc->setFrictionCoeficient(fs);
 
-      mVehicle->getTopBody()->addMultiBodyModel(sc);
+      mVehicle->getTopBody()->addInteract2(sc);
     }
   }
 
@@ -1851,7 +1851,7 @@
   std::string throttlename = "fcs/throttle-cmd-norm[" + number + "]";
   engineForce->getInputPort(0)->connect(lookupJSBExpression(throttlename));
 
-  mVehicle->getTopBody()->addMultiBodyModel(engineForce);
+  mVehicle->getTopBody()->addInteract2(engineForce);
 
   return true;
 }

Modified: trunk/OpenFDM/src/OpenFDM/ConstVisitor.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/ConstVisitor.h	2005-12-23 09:53:31 UTC (rev 110)
+++ trunk/OpenFDM/src/OpenFDM/ConstVisitor.h	2005-12-23 13:38:44 UTC (rev 111)
@@ -14,6 +14,7 @@
 class Mass;
 class Force;
 class Joint;
+class Interact;
 
 class ConstVisitor {
 public:
@@ -27,10 +28,12 @@
   { traverse(abNode); }
   virtual void apply(const Mass& mass)
   { apply((const MultiBodyModel&)mass); }
-  virtual void apply(const Force& force)
-  { apply((const MultiBodyModel&)force); }
+//   virtual void apply(const Force& force)
+//   { apply((const MultiBodyModel&)force); }
   virtual void apply(const Joint& joint)
   { apply((const MultiBodyModel&)joint); }
+  virtual void apply(const Interact& interact)
+  { }
   inline void traverse(const Frame& frame)
   { frame.traverse(*this); }
   inline void traverse(const MultiBodyModel& multiBodyModel)

Modified: trunk/OpenFDM/src/OpenFDM/Force.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Force.cpp	2005-12-23 09:53:31 UTC (rev 110)
+++ trunk/OpenFDM/src/OpenFDM/Force.cpp	2005-12-23 13:38:44 UTC (rev 111)
@@ -6,8 +6,8 @@
 
 namespace OpenFDM {
 
-Force::Force(const std::string& name)
-  : MultiBodyModel(name)
+Force::Force(const std::string& name, unsigned numParents) :
+  Interact(name, numParents)
 {
 }
 
@@ -15,28 +15,4 @@
 {
 }
 
-void
-Force::accept(Visitor& visitor)
-{
-  visitor.apply(*this);
-}
-
-void
-Force::accept(ConstVisitor& visitor) const
-{
-  visitor.apply(*this);
-}
-
-Force*
-Force::toForce(void)
-{
-  return this;
-}
-
-const Force*
-Force::toForce(void) const
-{
-  return this;
-}
-
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/Force.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Force.h	2005-12-23 09:53:31 UTC (rev 110)
+++ trunk/OpenFDM/src/OpenFDM/Force.h	2005-12-23 13:38:44 UTC (rev 111)
@@ -15,41 +15,32 @@
 
 namespace OpenFDM {
 
-class Force
-  : public MultiBodyModel {
+class Force :
+    public Interact {
 public:
-  Force(const std::string& name);
+  Force(const std::string& name, unsigned numParents);
   virtual ~Force(void);
 
-  virtual void accept(Visitor& visitor);
-  virtual void accept(ConstVisitor& visitor) const;
-
-  virtual Force* toForce(void);
-  virtual const Force* toForce(void) const;
-
-  /**
-   */
-  virtual const Vector6& getForce(Frame *parent) const = 0;
-
-  // Needs to call applyForce once ...
-  virtual void computeForce(void) = 0;
 };
 
 class ExternalForce
   : public Force {
-  OpenFDM_NodeImplementation(1);
 public:
   ExternalForce(const std::string& name)
-    : Force(name)
+    : Force(name, 1), mForce(0, 0, 0, 0, 0, 0)
   {}
   virtual ~ExternalForce(void) {}
 
-  virtual const Vector6& getForce(Frame *parent) const
+  // Needs to call applyForce once ...
+  virtual void interactWith(RigidBody* rigidBody)
   {
-    OpenFDMAssert(parent == getParentFrame(0));
-    return mForce;
+    computeForce();
+    rigidBody->contributeForce(-mForce);
   }
 
+  /// FIXME here for compatibility
+  virtual void computeForce(void) = 0;
+
 protected:
   /** Sets the force contribution of this force element.
    * Sets the force contribution of this current force element to

Modified: trunk/OpenFDM/src/OpenFDM/Frame.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Frame.h	2005-12-23 09:53:31 UTC (rev 110)
+++ trunk/OpenFDM/src/OpenFDM/Frame.h	2005-12-23 13:38:44 UTC (rev 111)
@@ -23,6 +23,7 @@
 namespace OpenFDM {
 
 class RigidBody;
+class Interact;
 
 /** 
 The \ref Frame class is the basic tool to model a tree of moving and
@@ -38,6 +39,8 @@
 parent frame.
 */
 
+/// FIXME: RelAccel->VelDot ...
+
 class Frame :
     public Object {
 public:
@@ -157,6 +160,9 @@
   unsigned getNumMultiBodyModels(void) const
   { return _children.size(); }
 
+  virtual bool addInteract2(Interact* child, unsigned parentNum = 0)
+  { return false; }
+
   //////////////////
 
 
@@ -667,6 +673,148 @@
   { Frame::setRefOrientation(o); }
 };
 
+class PrismaticJointFrame :
+    public Frame {
+public:
+  PrismaticJointFrame(const std::string& name) :
+    Frame(name) { /*FIXME zero out members ...*/ }
+  virtual ~PrismaticJointFrame(void) {}
+
+  /// Gets the joint axis where this joint is allowed to rotate around.
+  const Vector3& getJointAxis(void) const
+  { return mJointAxis; }
+
+  /// Sets the joint axis where this joint is allowed to rotate around.
+  void setJointAxis(const Vector3& axis)
+  {
+    mJointAxis = axis;
+    setPosition(mZeroPos + mJointPos*mJointAxis);
+    setLinearRelVel(mJointVel*mJointAxis);
+    setLinearRelAccel(mJointVelDot*mJointAxis);
+  }
+
+  /// Returns the joint position.
+  const real_type& getJointPos(void) const
+  { return mJointPos; }
+
+  /// Sets the joint position.
+  void setJointPos(real_type pos)
+  { mJointPos = pos; setPosition(mZeroPos + mJointPos*mJointAxis); }
+
+  /// Returns the joint velocity.
+  const real_type& getJointVel(void) const
+  { return mJointVel; }
+
+  /// Sets the joint velocity.
+  void setJointVel(real_type vel)
+  { mJointVel = vel; setLinearRelVel(mJointVel*mJointAxis); }
+
+  /// Returns the derivative of the relative velocity
+  const real_type& getJointVelDot(void) const
+  { return mJointVelDot; }
+
+  /// Returns the derivative of the relative velocity
+  void setJointVelDot(real_type velDot)
+  { mJointVelDot = velDot; setLinearRelAccel(mJointVelDot*mJointAxis); }
+
+  /// Sets the zero position of the joint.
+  void setZeroPos(const Vector3& zeroPos)
+  { mZeroPos = zeroPos; setPosition(mZeroPos + mJointPos*mJointAxis); }
+  const Vector3& getZeroPos(void) const
+  { return mZeroPos; }
+
+  /// FIXME Hdot
+
+private:
+  /// The zero position with respect to the parent frame.
+  Vector3 mZeroPos;
+  /// The joint rotation axis.
+  Vector3 mJointAxis;
+
+  /// The relative joint translation along the joint axis
+  real_type mJointPos;
+
+  /// The realtive linear velocity along the joint axis
+  real_type mJointVel;
+
+  /// The realtive linear velocity derivative along the joint axis
+  real_type mJointVelDot;
+};
+
+class RevoluteJointFrame :
+    public Frame {
+public:
+  RevoluteJointFrame(const std::string& name) :
+    Frame(name) { /*FIXME zero out members ...*/ }
+  virtual ~RevoluteJointFrame(void) {}
+
+  /// Gets the joint axis where this joint is allowed to rotate around.
+  const Vector3& getJointAxis(void) const
+  { return mJointAxis; }
+
+  /// Sets the joint axis where this joint is allowed to rotate around.
+  void setJointAxis(const Vector3& axis)
+  {
+    mJointAxis = axis;
+    setOrientation(mZeroOrient*Quaternion::fromAngleAxis(mJointPos, mJointAxis));
+    setAngularRelVel(mJointVel*mJointAxis);
+    setAngularRelAccel(mJointVelDot*mJointAxis);
+  }
+
+  /// Returns the joint position.
+  const real_type& getJointPos(void) const
+  { return mJointPos; }
+
+  /// Sets the joint position.
+  void setJointPos(real_type pos)
+  {
+    mJointPos = pos;
+    setOrientation(mZeroOrient*Quaternion::fromAngleAxis(mJointPos, mJointAxis));
+  }
+
+  /// Returns the joint velocity.
+  const real_type& getJointVel(void) const
+  { return mJointVel; }
+
+  /// Sets the joint velocity.
+  void setJointVel(real_type vel)
+  { mJointVel = vel; setAngularRelVel(mJointVel*mJointAxis); }
+
+  /// Returns the derivative of the relative velocity
+  const real_type& getJointVelDot(void) const
+  { return mJointVelDot; }
+
+  /// Returns the derivative of the relative velocity
+  void setJointVelDot(real_type velDot)
+  { mJointVelDot = velDot; setAngularRelAccel(mJointVelDot*mJointAxis); }
+
+  /// Sets the zero position of the joint.
+  void setZeroOrient(const Quaternion& zeroOrient)
+  {
+    mZeroOrient = zeroOrient;
+    setOrientation(mZeroOrient*Quaternion::fromAngleAxis(mJointPos, mJointAxis));
+  }
+  const Quaternion& getZeroOrient(void) const
+  { return mZeroOrient; }
+
+  /// FIXME Hdot
+
+private:
+  /// The zero orientation with respect to the parent frame.
+  Quaternion mZeroOrient;
+  /// The joint rotation axis.
+  Vector3 mJointAxis;
+
+  /// The relative joint rotation with respect to the zero orientation.
+  real_type mJointPos;
+
+  /// The rotational velocity with respect to the rotation axis.
+  real_type mJointVel;
+
+  /// The rotational velocity derivative with respect to the rotation axis.
+  real_type mJointVelDot;
+};
+
 } // namespace OpenFDM
 
 #endif

Modified: trunk/OpenFDM/src/OpenFDM/ModelVisitor.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/ModelVisitor.h	2005-12-23 09:53:31 UTC (rev 110)
+++ trunk/OpenFDM/src/OpenFDM/ModelVisitor.h	2005-12-23 13:38:44 UTC (rev 111)
@@ -7,7 +7,7 @@
 
 #include "Model.h"
 #include "ModelGroup.h"
-// #include "MultiBodyModel.h"
+#include "RigidBody.h"
 
 namespace OpenFDM {
 
@@ -19,25 +19,17 @@
   { }
   virtual void apply(ModelGroup& modelGroup)
   { apply((Model&)modelGroup); }
-//   virtual void apply(MultiBodyModel& multiBodyModel)
-//   { apply((Model&)multiBodyModel); }
+  virtual void apply(Interact& interact)
+  { apply((Model&)interact); }
 protected:
   /// Call this in the apply(ModelGroup&) method if you want to
   /// traverse downward
   inline void traverse(ModelGroup& modelGroup)
   { modelGroup.traverse(*this); }
-  /// Call this in the apply(MultiBodyModel&) method if you want to
-  /// traverse downward
-//   inline void traverse(MultiBodyModel& multiBodyModel)
-//   { multiBodyModel.traverse(*this); }
   /// Call this in the apply(ModelGroup&) method if you want to
   /// traverse upward
   inline void ascend(Model& model)
   { model.ascend(*this); }
-  /// Call this in the apply(MultiBodyModel&) method if you want to
-  /// traverse upward
-//   inline void ascend(MultiBodyModel& multiBodyModel)
-//   { multiBodyModel.ascend(*this); }
 };
 
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/RigidBody.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RigidBody.cpp	2005-12-23 09:53:31 UTC (rev 110)
+++ trunk/OpenFDM/src/OpenFDM/RigidBody.cpp	2005-12-23 13:38:44 UTC (rev 111)
@@ -51,6 +51,31 @@
 }
 
 void
+RigidBody::traverse(Visitor& visitor)
+{
+  InteractList::iterator it;
+  for (it = mInteracts.begin(); it != mInteracts.end(); ++it)
+    (*it)->accept(visitor);
+//     MassList::iterator it;
+//     for (it = mMasses.begin(); it != mMasses.end(); ++it)
+//       (*it)->accept(visitor);
+  
+  Frame::traverse(visitor);
+}
+
+void
+RigidBody::traverse(ConstVisitor& visitor) const
+{
+  InteractList::const_iterator it;
+  for (it = mInteracts.begin(); it != mInteracts.end(); ++it)
+    (*it)->accept(visitor);
+//     MassList::const_iterator it;
+//     for (it = mMasses.begin(); it != mMasses.end(); ++it)
+//       (*it)->accept(visitor);
+  Frame::traverse(visitor);
+}
+
+void
 RigidBody::computeArtValues(void)
 {
   Log(ArtBody, Debug) << "Entry of computeArtValues of \"" << getName()
@@ -79,18 +104,18 @@
                       cross(iv.getAngular(), Jiv.getLinear()));
 
   // Collect all forces acting directly on that body.
-  n = getNumMultiBodyModels();
-  for (unsigned i = 0; i < n; ++i) {
-    Force* child = getMultiBodyModel(i)->toForce();
-    if (child) {
-      Log(ArtBody, Debug) << "Adding local force \"" << child->getName()
-                          << "\" to body \"" << getName() << "\"" << endl;
+//   n = getNumMultiBodyModels();
+//   for (unsigned i = 0; i < n; ++i) {
+//     Force* child = getMultiBodyModel(i)->toForce();
+//     if (child) {
+//       Log(ArtBody, Debug) << "Adding local force \"" << child->getName()
+//                           << "\" to body \"" << getName() << "\"" << endl;
      
-      // FIXME: why is this - sign ???
-      // Ok, because of the minus in MobileRoot ...
-      mArtForce -= child->getForce(this);
-    }
-  }
+//       // FIXME: why is this - sign ???
+//       // Ok, because of the minus in MobileRoot ...
+//       mArtForce -= child->getForce(this);
+//     }
+//   }
 
   // Now collect all articulated forces and all articulated inertias.
   for (unsigned i = 0; i < n; ++i) {
@@ -107,6 +132,11 @@
         ;
     }
   }
+
+  // Collect all articulated forces and inertias
+  InteractList::iterator it;
+  for (it = mInteracts.begin(); it != mInteracts.end(); ++it)
+    (*it)->interactWith(this);
   
   Log(ArtBody, Debug3) << "On exit of computeArtValues of \"" << getName()
                        << "\" Force is:\n" << trans(mArtForce)
@@ -136,4 +166,42 @@
                        << "\"" << endl;
 }
 
+void
+RigidBody::addInteract(Interact* interact)
+{
+  mInteracts.push_back(interact);
+}
+
+bool
+RigidBody::removeInteract(Interact* interact)
+{
+  InteractList::iterator it;
+  for (it = mInteracts.begin(); it != mInteracts.end(); ++it) {
+    if ((*it) == interact) {
+      mInteracts.erase(it);
+      return true;
+    }
+  }
+  return false;
+}
+
+bool
+RigidBody::addInteract2(Interact* child, unsigned parentNum)
+{
+  child->attachTo(this);
+}
+
+/// FIXME does not belong here
+void
+Interact::accept(Visitor& visitor)
+{
+  visitor.apply(*this);
+}
+
+void
+Interact::accept(ConstVisitor& visitor) const
+{
+  visitor.apply(*this);
+}
+
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/RigidBody.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RigidBody.h	2005-12-23 09:53:31 UTC (rev 110)
+++ trunk/OpenFDM/src/OpenFDM/RigidBody.h	2005-12-23 13:38:44 UTC (rev 111)
@@ -19,6 +19,8 @@
 
 namespace OpenFDM {
 
+class Interact;
+
 // Rename to Body???
 class RigidBody :
     public Frame {
@@ -39,7 +41,10 @@
 
   virtual void accept(Visitor& visitor);
   virtual void accept(ConstVisitor& visitor) const;
+  virtual void traverse(Visitor& visitor);
+  virtual void traverse(ConstVisitor& visitor) const;
 
+
 // protected:
   /** Compute articulated values outboard including this body.
       That function is part of the articulated body algorithm.
@@ -87,7 +92,21 @@
   void contributeInertia(const SpatialInertia& inertia)
   { mArtInertia += inertia; }
 
+
+  /** Introduce an interface routine
+   */
+  Frame* getFrame(void)
+  { return this; }
+  const Frame* getFrame(void) const
+  { return this; }
+
+  /// FIXME remove
+  virtual bool addInteract2(Interact* child, unsigned parentNum = 0);
+
 private:
+  void addInteract(Interact* interact);
+  bool removeInteract(Interact* interact);
+
   /** Outboard articulated inertia.
    */
   SpatialInertia mArtInertia;
@@ -95,8 +114,111 @@
   /** Outboard articulated force.
    */
   Vector6 mArtForce;
+
+  /// Frame attached to this rigid body
+//   SharedPtr<Frame> mFrame;
+
+  typedef std::vector<SharedPtr<Interact> > InteractList;
+  InteractList mInteracts;
+
+  /// FIXME: is interact too???
+  typedef std::vector<SharedPtr<Mass> > MassList;
+  MassList mMasses;
+
+  friend class Interact;
 };
 
+class Interact :
+    public Model {
+public:
+  Interact(const std::string& name, unsigned numParents) :
+    Model(name), mParents(numParents) { }
+  virtual ~Interact(void) { }
+
+
+  /// Double dispatch helper for the multibody system visitor
+  virtual void accept(Visitor& visitor);
+  /// Double dispatch helper for the multibody system visitor
+  virtual void traverse(Visitor& visitor)
+  { }
+  /// Double dispatch helper for the multibody system visitor
+  virtual void accept(ConstVisitor& visitor) const;
+  /// Double dispatch helper for the multibody system visitor
+  virtual void traverse(ConstVisitor& visitor) const
+  { }
+
+
+  bool attachTo(RigidBody* rigidBody)
+  {
+    if (!rigidBody) {
+      Log(MultiBody,Error) << "Got 0 RigidBody pointer to attach to." << endl;
+      return false;
+    }
+    ParentList::iterator it;
+    for (it = mParents.begin(); it != mParents.end(); ++it) {
+      if (!(*it)) {
+        (*it) = rigidBody;
+        (*it)->addInteract(this);
+        return true;
+      }
+    }
+
+    Log(MultiBody,Error) << "Cannot attach Interact \"" << getName()
+                         << "\" to RigidBody \"" << rigidBody->getName()
+                         << "\": Already attached to 2 Rigid bodies."
+                         << endl;
+    return false;
+  }
+  bool detachFrom(RigidBody* rigidBody)
+  {
+    if (!rigidBody) {
+      Log(MultiBody,Error) << "Got 0 RigidBody pointer to attach to." << endl;
+      return false;
+    }
+    ParentList::iterator it;
+    for (it = mParents.begin(); it != mParents.end(); ++it) {
+      if ((*it) == rigidBody) {
+        (*it)->removeInteract(this);
+        (*it) = 0;
+        return true;
+      }
+    }
+
+    Log(MultiBody,Error) << "Cannot detatach Interact \"" << getName()
+                         << "\" from RigidBody \"" << rigidBody->getName()
+                         << "\": Interact is not attached to that RigidBody."
+                         << endl;
+    return false;
+  }
+
+  virtual void interactWith(RigidBody* rigidBody) = 0;
+
+  /// FIXME remove
+  const Frame* getParentFrame(unsigned id = 0) const
+  {
+    OpenFDMAssert(id < mParents.size() && mParents[id]);
+    return mParents[id]->getFrame();
+  }
+  /// FIXME remove
+  Frame* getParentFrame(unsigned id = 0)
+  {
+    OpenFDMAssert(id < mParents.size() && mParents[id]);
+    return mParents[id]->getFrame();
+  }
+
+private:
+  typedef std::vector<WeakPtr<RigidBody> > ParentList;
+  ParentList mParents;
+};
+
+class Joint2 :
+    public Interact {
+public:
+  Joint2(const std::string& name) : Interact(name, 2) { }
+  virtual ~Joint2(void) { }
+
+};
+
 } // namespace OpenFDM
 
 #endif

Modified: trunk/OpenFDM/src/OpenFDM/RootFrame.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RootFrame.cpp	2005-12-23 09:53:31 UTC (rev 110)
+++ trunk/OpenFDM/src/OpenFDM/RootFrame.cpp	2005-12-23 13:38:44 UTC (rev 111)
@@ -17,15 +17,6 @@
 
 namespace OpenFDM {
 
-class ForceComputationVisitor
-  : public Visitor {
-public:
-  virtual void apply(Force& force)
-  {
-    force.computeForce();
-  }
-};
-
 class ForwardDynamicsVisitor
   : public Visitor {
 public:
@@ -62,6 +53,12 @@
     abNode.setState(mState, mOffset);
     mOffset += abNode.getNumContinousStates();
   }
+  virtual void apply(Interact& abNode)
+  {
+    OpenFDMAssert(mOffset + abNode.getNumContinousStates() <= mState.size());
+    abNode.setState(mState, mOffset);
+    mOffset += abNode.getNumContinousStates();
+  }
 private:
   Vector mState;
   unsigned mOffset;
@@ -80,6 +77,12 @@
     abNode.getState(mState, mOffset);
     mOffset += abNode.getNumContinousStates();
   }
+  virtual void apply(const Interact& abNode)
+  {
+    OpenFDMAssert(mOffset + abNode.getNumContinousStates() <= mState.size());
+    abNode.getState(mState, mOffset);
+    mOffset += abNode.getNumContinousStates();
+  }
   const Vector& getState(void) const
   { return mState; }
 private:
@@ -99,6 +102,12 @@
     abNode.getStateDeriv(mStateDeriv, mOffset);
     mOffset += abNode.getNumContinousStates();
   }
+  virtual void apply(Interact& abNode)
+  {
+    OpenFDMAssert(mOffset + abNode.getNumContinousStates() <= mStateDeriv.size());
+    abNode.getStateDeriv(mStateDeriv, mOffset);
+    mOffset += abNode.getNumContinousStates();
+  }
   const Vector& getStateDeriv(void) const
   { return mStateDeriv; }
 private:
@@ -115,6 +124,10 @@
   {
     abNode.output(mTaskInfo);
   }
+  virtual void apply(Interact& abNode)
+  {
+    abNode.output(mTaskInfo);
+  }
 private:
   const TaskInfo& mTaskInfo;
 };
@@ -128,6 +141,10 @@
   {
     abNode.update(mTaskInfo);
   }
+  virtual void apply(Interact& abNode)
+  {
+    abNode.update(mTaskInfo);
+  }
 private:
   const TaskInfo& mTaskInfo;
 };
@@ -142,6 +159,10 @@
   {
     mOffset += abNode.getNumContinousStates();
   }
+  virtual void apply(const Interact& abNode)
+  {
+    mOffset += abNode.getNumContinousStates();
+  }
   unsigned getStateCount(void) const
   { return mOffset; }
 private:
@@ -178,8 +199,7 @@
   setState(state, 0);
 
   // Compute the external and interaction forces.
-  ForceComputationVisitor forceVisitor;
-  mRootFrame->accept(forceVisitor);
+  // FIXME:Output->continous states ...
 
   // Compute forward dynamics, that is the articulated forces and inertia.
   ForwardDynamicsVisitor fwdVisitor;
@@ -220,8 +240,7 @@
 MultiBodySystem::getStateDeriv(Vector& stateDeriv, unsigned offset)
 {
   // Compute the external and interaction forces.
-  ForceComputationVisitor forceVisitor;
-  mRootFrame->accept(forceVisitor);
+  // FIXME:Output->continous states ...
 
   // Compute forward dynamics, that is the articulated forces and inertia.
   ForwardDynamicsVisitor fwdVisitor;

Modified: trunk/OpenFDM/src/OpenFDM/Visitor.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Visitor.h	2005-12-23 09:53:31 UTC (rev 110)
+++ trunk/OpenFDM/src/OpenFDM/Visitor.h	2005-12-23 13:38:44 UTC (rev 111)
@@ -14,6 +14,7 @@
 class Force;
 class Joint;
 class MultiBodyModel;
+class Interact;
 
 class Visitor {
 public:
@@ -27,10 +28,12 @@
   { traverse(abNode); }
   virtual void apply(Mass& mass)
   { apply((MultiBodyModel&)mass); }
-  virtual void apply(Force& force)
-  { apply((MultiBodyModel&)force); }
+//   virtual void apply(Force& force)
+//   { apply((MultiBodyModel&)force); }
   virtual void apply(Joint& joint)
   { apply((MultiBodyModel&)joint); }
+  virtual void apply(Interact& interact)
+  { }
   inline void traverse(Frame& frame)
   { frame.traverse(*this); }
   inline void traverse(MultiBodyModel& multiBodyModel)



From frohlich at berlios.de  Fri Dec 23 16:36:33 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Fri, 23 Dec 2005 16:36:33 +0100
Subject: [OpenFDM-svn] r112 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200512231536.jBNFaX8R018110@sheep.berlios.de>

Author: frohlich
Date: 2005-12-23 16:36:24 +0100 (Fri, 23 Dec 2005)
New Revision: 112

Added:
   trunk/OpenFDM/src/OpenFDM/MultiBodySystem.cpp
   trunk/OpenFDM/src/OpenFDM/MultiBodySystem.h
Modified:
   trunk/OpenFDM/src/OpenFDM/Makefile.am
   trunk/OpenFDM/src/OpenFDM/ModelVisitor.h
   trunk/OpenFDM/src/OpenFDM/RootFrame.cpp
   trunk/OpenFDM/src/OpenFDM/RootFrame.h
   trunk/OpenFDM/src/OpenFDM/Vehicle.h
Log:
Split MultiBodySystem out of RootFrame.


Modified: trunk/OpenFDM/src/OpenFDM/Makefile.am
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Makefile.am	2005-12-23 13:38:44 UTC (rev 111)
+++ trunk/OpenFDM/src/OpenFDM/Makefile.am	2005-12-23 15:36:24 UTC (rev 112)
@@ -85,6 +85,7 @@
   ModelGroup.h \
   ModelVisitor.h \
   MultiBodyModel.h \
+  MultiBodySystem.h \
   Newton.h \
   Object.h \
   ODESolver.h \
@@ -174,6 +175,7 @@
   Model.cpp \
   ModelGroup.cpp \
   MultiBodyModel.cpp \
+  MultiBodySystem.cpp \
   Newton.cpp \
   Object.cpp \
   ODESolver.cpp \

Modified: trunk/OpenFDM/src/OpenFDM/ModelVisitor.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/ModelVisitor.h	2005-12-23 13:38:44 UTC (rev 111)
+++ trunk/OpenFDM/src/OpenFDM/ModelVisitor.h	2005-12-23 15:36:24 UTC (rev 112)
@@ -8,6 +8,7 @@
 #include "Model.h"
 #include "ModelGroup.h"
 #include "RigidBody.h"
+#include "MultiBodySystem.h"
 
 namespace OpenFDM {
 
@@ -21,6 +22,8 @@
   { apply((Model&)modelGroup); }
   virtual void apply(Interact& interact)
   { apply((Model&)interact); }
+  virtual void apply(MultiBodySystem& multiBodySystem)
+  { apply((Model&)multiBodySystem); }
 protected:
   /// Call this in the apply(ModelGroup&) method if you want to
   /// traverse downward

Added: trunk/OpenFDM/src/OpenFDM/MultiBodySystem.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/MultiBodySystem.cpp	2005-12-23 13:38:44 UTC (rev 111)
+++ trunk/OpenFDM/src/OpenFDM/MultiBodySystem.cpp	2005-12-23 15:36:24 UTC (rev 112)
@@ -0,0 +1,280 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
+ *
+ */
+
+#include "Assert.h"
+#include "Object.h"
+#include "Vector.h"
+#include "Matrix.h"
+#include "Quaternion.h"
+#include "Inertia.h"
+#include "Frame.h"
+#include "RigidBody.h"
+#include "Visitor.h"
+#include "ModelVisitor.h"
+#include "Mass.h"
+#include "Force.h"
+#include "MultiBodySystem.h"
+
+namespace OpenFDM {
+
+class ForwardDynamicsVisitor
+  : public Visitor {
+public:
+  virtual void apply(RigidBody& body)
+  {
+    // Note the order. First compute the articulated values on each child.
+    traverse(body);
+    // Past that, do it on this current rigid body.
+    body.computeArtValues();
+  }
+};
+
+class AccelerationPropagationVisitor
+  : public Visitor {
+public:
+  virtual void apply(RigidBody& body)
+  {
+    body.computeAccel();
+    // Note the order. First compute the acceleration and than traverse
+    // to the children.
+    traverse(body);
+  }
+};
+
+class SetStateVisitor
+  : public Visitor {
+public:
+  SetStateVisitor(const Vector& state)
+    : mState(state), mOffset(0u)
+  { }
+  virtual void apply(MultiBodyModel& abNode)
+  {
+    OpenFDMAssert(mOffset + abNode.getNumContinousStates() <= mState.size());
+    abNode.setState(mState, mOffset);
+    mOffset += abNode.getNumContinousStates();
+  }
+  virtual void apply(Interact& abNode)
+  {
+    OpenFDMAssert(mOffset + abNode.getNumContinousStates() <= mState.size());
+    abNode.setState(mState, mOffset);
+    mOffset += abNode.getNumContinousStates();
+  }
+private:
+  Vector mState;
+  unsigned mOffset;
+  real_type mTime;
+};
+
+class GetStateVisitor
+  : public ConstVisitor {
+public:
+  GetStateVisitor(unsigned size)
+    : mState(size), mOffset(0u)
+  { }
+  virtual void apply(const MultiBodyModel& abNode)
+  {
+    OpenFDMAssert(mOffset + abNode.getNumContinousStates() <= mState.size());
+    abNode.getState(mState, mOffset);
+    mOffset += abNode.getNumContinousStates();
+  }
+  virtual void apply(const Interact& abNode)
+  {
+    OpenFDMAssert(mOffset + abNode.getNumContinousStates() <= mState.size());
+    abNode.getState(mState, mOffset);
+    mOffset += abNode.getNumContinousStates();
+  }
+  const Vector& getState(void) const
+  { return mState; }
+private:
+  Vector mState;
+  unsigned mOffset;
+};
+
+class GetStateDerivVisitor
+  : public Visitor {
+public:
+  GetStateDerivVisitor(unsigned size)
+    : mStateDeriv(size), mOffset(0u)
+  { }
+  virtual void apply(MultiBodyModel& abNode)
+  {
+    OpenFDMAssert(mOffset + abNode.getNumContinousStates() <= mStateDeriv.size());
+    abNode.getStateDeriv(mStateDeriv, mOffset);
+    mOffset += abNode.getNumContinousStates();
+  }
+  virtual void apply(Interact& abNode)
+  {
+    OpenFDMAssert(mOffset + abNode.getNumContinousStates() <= mStateDeriv.size());
+    abNode.getStateDeriv(mStateDeriv, mOffset);
+    mOffset += abNode.getNumContinousStates();
+  }
+  const Vector& getStateDeriv(void) const
+  { return mStateDeriv; }
+private:
+  Vector mStateDeriv;
+  unsigned mOffset;
+};
+
+class OutputVisitor
+  : public Visitor {
+public:
+  OutputVisitor(const TaskInfo& taskInfo) : mTaskInfo(taskInfo)
+  { }
+  virtual void apply(MultiBodyModel& abNode)
+  {
+    abNode.output(mTaskInfo);
+  }
+  virtual void apply(Interact& abNode)
+  {
+    abNode.output(mTaskInfo);
+  }
+private:
+  const TaskInfo& mTaskInfo;
+};
+
+class UpdateVisitor
+  : public Visitor {
+public:
+  UpdateVisitor(const TaskInfo& taskInfo) : mTaskInfo(taskInfo)
+  { }
+  virtual void apply(MultiBodyModel& abNode)
+  {
+    abNode.update(mTaskInfo);
+  }
+  virtual void apply(Interact& abNode)
+  {
+    abNode.update(mTaskInfo);
+  }
+private:
+  const TaskInfo& mTaskInfo;
+};
+
+class StateCountVisitor
+  : public ConstVisitor {
+public:
+  StateCountVisitor(void)
+    : mOffset(0u)
+  { }
+  virtual void apply(const MultiBodyModel& abNode)
+  {
+    mOffset += abNode.getNumContinousStates();
+  }
+  virtual void apply(const Interact& abNode)
+  {
+    mOffset += abNode.getNumContinousStates();
+  }
+  unsigned getStateCount(void) const
+  { return mOffset; }
+private:
+  unsigned mOffset;
+};
+
+MultiBodySystem::MultiBodySystem(RootFrame* rootFrame) :
+  Model("multibodymodel"),
+  mRootFrame(rootFrame)
+{
+  // FIXME
+  addSampleTime(SampleTime::PerTimestep);
+  addSampleTime(SampleTime::Continous);
+}
+
+MultiBodySystem::~MultiBodySystem(void)
+{
+}
+
+void
+MultiBodySystem::accept(ModelVisitor& visitor)
+{
+  visitor.apply(*this);
+}
+
+void
+MultiBodySystem::setEvalState(const Vector& state)
+{
+  // First we need to inject the current state into the tree of parts.
+  setState(state, 0);
+
+  // Compute the external and interaction forces.
+  // FIXME:Output->continous states ...
+
+  // Compute forward dynamics, that is the articulated forces and inertia.
+  ForwardDynamicsVisitor fwdVisitor;
+  mRootFrame->accept(fwdVisitor);
+
+  // Then compute the articulated inertias and forces.
+  AccelerationPropagationVisitor apVisitor;
+  mRootFrame->accept(apVisitor);
+}
+
+void
+MultiBodySystem::computeStateDeriv(real_type t, const Vector& state, Vector& deriv)
+{
+  setEvalState(state);
+
+  // And finally extract the derivative vector from the tree.
+  GetStateDerivVisitor gsdv(getNumContinousStates());
+  mRootFrame->accept(gsdv);
+  deriv = gsdv.getStateDeriv();
+}
+
+void
+MultiBodySystem::setState(const Vector& state, unsigned offset)
+{
+  SetStateVisitor ssv(state(Range(offset+1, offset+getNumContinousStates())));
+  mRootFrame->accept(ssv);
+}
+
+void
+MultiBodySystem::getState(Vector& state, unsigned offset) const
+{
+  GetStateVisitor gsv(getNumContinousStates());
+  mRootFrame->accept(gsv);
+  state(Range(offset+1, offset+getNumContinousStates())) = gsv.getState();
+}
+
+void
+MultiBodySystem::getStateDeriv(Vector& stateDeriv, unsigned offset)
+{
+  // Compute the external and interaction forces.
+  // FIXME:Output->continous states ...
+
+  // Compute forward dynamics, that is the articulated forces and inertia.
+  ForwardDynamicsVisitor fwdVisitor;
+  mRootFrame->accept(fwdVisitor);
+
+  // Then compute the articulated inertias and forces.
+  AccelerationPropagationVisitor apVisitor;
+  mRootFrame->accept(apVisitor);
+
+  // And finally extract the derivative vector from the tree.
+  GetStateDerivVisitor gsdv(getNumContinousStates());
+  mRootFrame->accept(gsdv);
+  stateDeriv(Range(offset+1, offset+getNumContinousStates()))
+    = gsdv.getStateDeriv();
+}
+
+bool
+MultiBodySystem::init(void)
+{
+  StateCountVisitor gsc;
+  mRootFrame->accept(gsc);
+  setNumContinousStates(gsc.getStateCount());
+  return true;
+}
+
+void
+MultiBodySystem::output(const TaskInfo& taskInfo)
+{
+  OutputVisitor ov(taskInfo);
+  mRootFrame->accept(ov);
+}
+
+void
+MultiBodySystem::update(const TaskInfo& taskInfo)
+{
+  UpdateVisitor uv(taskInfo);
+  mRootFrame->accept(uv);
+}
+
+} // namespace OpenFDM


Property changes on: trunk/OpenFDM/src/OpenFDM/MultiBodySystem.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/OpenFDM/src/OpenFDM/MultiBodySystem.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/MultiBodySystem.h	2005-12-23 13:38:44 UTC (rev 111)
+++ trunk/OpenFDM/src/OpenFDM/MultiBodySystem.h	2005-12-23 15:36:24 UTC (rev 112)
@@ -0,0 +1,55 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_MultiBodySystem_H
+#define OpenFDM_MultiBodySystem_H
+
+#include "Assert.h"
+#include "Object.h"
+#include "Vector.h"
+#include "Matrix.h"
+#include "Quaternion.h"
+#include "Inertia.h"
+#include "Frame.h"
+#include "RigidBody.h"
+#include "Joint.h"
+#include "RootFrame.h"
+
+namespace OpenFDM {
+
+class MultiBodySystem :
+    public Model {
+public:
+  MultiBodySystem(RootFrame* rootFrame);
+  virtual ~MultiBodySystem(void);
+
+  /// Double dispatch helper for the multibody system visitor
+  virtual void accept(ModelVisitor& visitor);
+  /// Double dispatch helper for the multibody system visitor
+//   virtual void accept(ConstModelVisitor& visitor) const;
+
+  /** Sets the state of this multibody system from the state vector state.
+   */
+  void setEvalState(const Vector& state);
+  /** Sets the state of this multibody system from the state vector state
+      and returns the time derivative in deriv.
+   */
+  void computeStateDeriv(real_type t, const Vector& state, Vector& deriv);
+  
+  virtual void setState(const Vector& state, unsigned offset);
+  virtual void getState(Vector& state, unsigned offset) const;
+  virtual void getStateDeriv(Vector& stateDeriv, unsigned offset);
+
+  virtual bool init(void);
+  virtual void output(const TaskInfo& taskInfo);
+  virtual void update(const TaskInfo& taskInfo);
+private:
+  /// At the moment each MultiBodySystem has its own root frame,
+  /// In the future just store the root joint and reference a common root frame
+  SharedPtr<RootFrame> mRootFrame;
+};
+
+} // namespace OpenFDM
+
+#endif


Property changes on: trunk/OpenFDM/src/OpenFDM/MultiBodySystem.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/OpenFDM/src/OpenFDM/RootFrame.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RootFrame.cpp	2005-12-23 13:38:44 UTC (rev 111)
+++ trunk/OpenFDM/src/OpenFDM/RootFrame.cpp	2005-12-23 15:36:24 UTC (rev 112)
@@ -2,173 +2,11 @@
  *
  */
 
-#include "Assert.h"
-#include "Object.h"
-#include "Vector.h"
-#include "Matrix.h"
-#include "Quaternion.h"
-#include "Inertia.h"
 #include "Frame.h"
-#include "RigidBody.h"
-#include "Visitor.h"
 #include "RootFrame.h"
-#include "Mass.h"
-#include "Force.h"
 
 namespace OpenFDM {
 
-class ForwardDynamicsVisitor
-  : public Visitor {
-public:
-  virtual void apply(RigidBody& body)
-  {
-    // Note the order. First compute the articulated values on each child.
-    traverse(body);
-    // Past that, do it on this current rigid body.
-    body.computeArtValues();
-  }
-};
-
-class AccelerationPropagationVisitor
-  : public Visitor {
-public:
-  virtual void apply(RigidBody& body)
-  {
-    body.computeAccel();
-    // Note the order. First compute the acceleration and than traverse
-    // to the children.
-    traverse(body);
-  }
-};
-
-class SetStateVisitor
-  : public Visitor {
-public:
-  SetStateVisitor(const Vector& state)
-    : mState(state), mOffset(0u)
-  { }
-  virtual void apply(MultiBodyModel& abNode)
-  {
-    OpenFDMAssert(mOffset + abNode.getNumContinousStates() <= mState.size());
-    abNode.setState(mState, mOffset);
-    mOffset += abNode.getNumContinousStates();
-  }
-  virtual void apply(Interact& abNode)
-  {
-    OpenFDMAssert(mOffset + abNode.getNumContinousStates() <= mState.size());
-    abNode.setState(mState, mOffset);
-    mOffset += abNode.getNumContinousStates();
-  }
-private:
-  Vector mState;
-  unsigned mOffset;
-  real_type mTime;
-};
-
-class GetStateVisitor
-  : public ConstVisitor {
-public:
-  GetStateVisitor(unsigned size)
-    : mState(size), mOffset(0u)
-  { }
-  virtual void apply(const MultiBodyModel& abNode)
-  {
-    OpenFDMAssert(mOffset + abNode.getNumContinousStates() <= mState.size());
-    abNode.getState(mState, mOffset);
-    mOffset += abNode.getNumContinousStates();
-  }
-  virtual void apply(const Interact& abNode)
-  {
-    OpenFDMAssert(mOffset + abNode.getNumContinousStates() <= mState.size());
-    abNode.getState(mState, mOffset);
-    mOffset += abNode.getNumContinousStates();
-  }
-  const Vector& getState(void) const
-  { return mState; }
-private:
-  Vector mState;
-  unsigned mOffset;
-};
-
-class GetStateDerivVisitor
-  : public Visitor {
-public:
-  GetStateDerivVisitor(unsigned size)
-    : mStateDeriv(size), mOffset(0u)
-  { }
-  virtual void apply(MultiBodyModel& abNode)
-  {
-    OpenFDMAssert(mOffset + abNode.getNumContinousStates() <= mStateDeriv.size());
-    abNode.getStateDeriv(mStateDeriv, mOffset);
-    mOffset += abNode.getNumContinousStates();
-  }
-  virtual void apply(Interact& abNode)
-  {
-    OpenFDMAssert(mOffset + abNode.getNumContinousStates() <= mStateDeriv.size());
-    abNode.getStateDeriv(mStateDeriv, mOffset);
-    mOffset += abNode.getNumContinousStates();
-  }
-  const Vector& getStateDeriv(void) const
-  { return mStateDeriv; }
-private:
-  Vector mStateDeriv;
-  unsigned mOffset;
-};
-
-class OutputVisitor
-  : public Visitor {
-public:
-  OutputVisitor(const TaskInfo& taskInfo) : mTaskInfo(taskInfo)
-  { }
-  virtual void apply(MultiBodyModel& abNode)
-  {
-    abNode.output(mTaskInfo);
-  }
-  virtual void apply(Interact& abNode)
-  {
-    abNode.output(mTaskInfo);
-  }
-private:
-  const TaskInfo& mTaskInfo;
-};
-
-class UpdateVisitor
-  : public Visitor {
-public:
-  UpdateVisitor(const TaskInfo& taskInfo) : mTaskInfo(taskInfo)
-  { }
-  virtual void apply(MultiBodyModel& abNode)
-  {
-    abNode.update(mTaskInfo);
-  }
-  virtual void apply(Interact& abNode)
-  {
-    abNode.update(mTaskInfo);
-  }
-private:
-  const TaskInfo& mTaskInfo;
-};
-
-class StateCountVisitor
-  : public ConstVisitor {
-public:
-  StateCountVisitor(void)
-    : mOffset(0u)
-  { }
-  virtual void apply(const MultiBodyModel& abNode)
-  {
-    mOffset += abNode.getNumContinousStates();
-  }
-  virtual void apply(const Interact& abNode)
-  {
-    mOffset += abNode.getNumContinousStates();
-  }
-  unsigned getStateCount(void) const
-  { return mOffset; }
-private:
-  unsigned mOffset;
-};
-
 RootFrame::RootFrame(const std::string& name)
   : FreeFrame(name)
 {
@@ -178,106 +16,4 @@
 {
 }
 
-
-MultiBodySystem::MultiBodySystem(RootFrame* rootFrame) :
-  Model("multibodymodel"),
-  mRootFrame(rootFrame)
-{
-  // FIXME
-  addSampleTime(SampleTime::PerTimestep);
-  addSampleTime(SampleTime::Continous);
-}
-
-MultiBodySystem::~MultiBodySystem(void)
-{
-}
-
-void
-MultiBodySystem::setEvalState(const Vector& state)
-{
-  // First we need to inject the current state into the tree of parts.
-  setState(state, 0);
-
-  // Compute the external and interaction forces.
-  // FIXME:Output->continous states ...
-
-  // Compute forward dynamics, that is the articulated forces and inertia.
-  ForwardDynamicsVisitor fwdVisitor;
-  mRootFrame->accept(fwdVisitor);
-
-  // Then compute the articulated inertias and forces.
-  AccelerationPropagationVisitor apVisitor;
-  mRootFrame->accept(apVisitor);
-}
-
-void
-MultiBodySystem::computeStateDeriv(real_type t, const Vector& state, Vector& deriv)
-{
-  setEvalState(state);
-
-  // And finally extract the derivative vector from the tree.
-  GetStateDerivVisitor gsdv(getNumContinousStates());
-  mRootFrame->accept(gsdv);
-  deriv = gsdv.getStateDeriv();
-}
-
-void
-MultiBodySystem::setState(const Vector& state, unsigned offset)
-{
-  SetStateVisitor ssv(state(Range(offset+1, offset+getNumContinousStates())));
-  mRootFrame->accept(ssv);
-}
-
-void
-MultiBodySystem::getState(Vector& state, unsigned offset) const
-{
-  GetStateVisitor gsv(getNumContinousStates());
-  mRootFrame->accept(gsv);
-  state(Range(offset+1, offset+getNumContinousStates())) = gsv.getState();
-}
-
-void
-MultiBodySystem::getStateDeriv(Vector& stateDeriv, unsigned offset)
-{
-  // Compute the external and interaction forces.
-  // FIXME:Output->continous states ...
-
-  // Compute forward dynamics, that is the articulated forces and inertia.
-  ForwardDynamicsVisitor fwdVisitor;
-  mRootFrame->accept(fwdVisitor);
-
-  // Then compute the articulated inertias and forces.
-  AccelerationPropagationVisitor apVisitor;
-  mRootFrame->accept(apVisitor);
-
-  // And finally extract the derivative vector from the tree.
-  GetStateDerivVisitor gsdv(getNumContinousStates());
-  mRootFrame->accept(gsdv);
-  stateDeriv(Range(offset+1, offset+getNumContinousStates()))
-    = gsdv.getStateDeriv();
-}
-
-bool
-MultiBodySystem::init(void)
-{
-  StateCountVisitor gsc;
-  mRootFrame->accept(gsc);
-  setNumContinousStates(gsc.getStateCount());
-  return true;
-}
-
-void
-MultiBodySystem::output(const TaskInfo& taskInfo)
-{
-  OutputVisitor ov(taskInfo);
-  mRootFrame->accept(ov);
-}
-
-void
-MultiBodySystem::update(const TaskInfo& taskInfo)
-{
-  UpdateVisitor uv(taskInfo);
-  mRootFrame->accept(uv);
-}
-
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/RootFrame.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RootFrame.h	2005-12-23 13:38:44 UTC (rev 111)
+++ trunk/OpenFDM/src/OpenFDM/RootFrame.h	2005-12-23 15:36:24 UTC (rev 112)
@@ -24,31 +24,6 @@
   virtual ~RootFrame(void);
 };
 
-class MultiBodySystem :
-    public Model {
-public:
-  MultiBodySystem(RootFrame* rootFrame);
-  virtual ~MultiBodySystem(void);
-
-  /** Sets the state of this multibody system from the state vector state.
-   */
-  void setEvalState(const Vector& state);
-  /** Sets the state of this multibody system from the state vector state
-      and returns the time derivative in deriv.
-   */
-  void computeStateDeriv(real_type t, const Vector& state, Vector& deriv);
-  
-  virtual void setState(const Vector& state, unsigned offset);
-  virtual void getState(Vector& state, unsigned offset) const;
-  virtual void getStateDeriv(Vector& stateDeriv, unsigned offset);
-
-  virtual bool init(void);
-  virtual void output(const TaskInfo& taskInfo);
-  virtual void update(const TaskInfo& taskInfo);
-private:
-  SharedPtr<RootFrame> mRootFrame;
-};
-
 } // namespace OpenFDM
 
 #endif

Modified: trunk/OpenFDM/src/OpenFDM/Vehicle.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Vehicle.h	2005-12-23 13:38:44 UTC (rev 111)
+++ trunk/OpenFDM/src/OpenFDM/Vehicle.h	2005-12-23 15:36:24 UTC (rev 112)
@@ -13,6 +13,7 @@
 #include "Frame.h"
 #include "FreeJoint.h"
 #include "RootFrame.h"
+#include "MultiBodySystem.h"
 #include "Planet.h"
 #include "ODESolver.h"
 #include "Environment.h"



From frohlich at berlios.de  Fri Dec 23 17:30:18 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Fri, 23 Dec 2005 17:30:18 +0100
Subject: [OpenFDM-svn] r113 - in trunk/OpenFDM/src: JSBSim OpenFDM
Message-ID: <200512231630.jBNGUIjP023680@sheep.berlios.de>

Author: frohlich
Date: 2005-12-23 17:30:12 +0100 (Fri, 23 Dec 2005)
New Revision: 113

Modified:
   trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
   trunk/OpenFDM/src/OpenFDM/MultiBodySystem.cpp
   trunk/OpenFDM/src/OpenFDM/MultiBodySystem.h
   trunk/OpenFDM/src/OpenFDM/Vehicle.cpp
   trunk/OpenFDM/src/OpenFDM/Vehicle.h
   trunk/OpenFDM/src/OpenFDM/main.cpp
Log:
The MultiBodySystem has a list of RigidBody objects.


Modified: trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
===================================================================
--- trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2005-12-23 15:36:24 UTC (rev 112)
+++ trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2005-12-23 16:30:12 UTC (rev 113)
@@ -740,6 +740,7 @@
   InertiaMatrix wheelInertia(10, 0, 0, 100, 0, 10);
   wheel->addMultiBodyModel(new Mass(SpatialInertia(wheelInertia, 50)));
   parent->addChildFrame(wheel);
+  mVehicle->getMultiBodySystem()->addRigidBody(wheel);
   
   RevoluteJoint* wj = new RevoluteJoint(name + " Wheel Joint");
   parent->addMultiBodyModel(wj, 0);
@@ -926,6 +927,7 @@
 
       // This is the movable part of the strut, doing the compression
       RigidBody* arm = new RigidBody(name + " Arm");
+      mVehicle->getMultiBodySystem()->addRigidBody(arm);
       mVehicle->getTopBody()->addChildFrame(arm);
       arm->addMultiBodyModel(new Mass(inertiaFrom(Vector3(-1, 0, 0), SpatialInertia(200))));
 
@@ -1000,6 +1002,7 @@
       if (steer == "STEERABLE") {
         // A new part modelling the steering
         RigidBody* steer = new RigidBody(name + " Steer");
+        mVehicle->getMultiBodySystem()->addRigidBody(steer);
         strutParent->addChildFrame(steer);
 
         // connect that via a revolute joint to the toplevel body.
@@ -1042,6 +1045,7 @@
 
       // Now the compressible part of the strut
       RigidBody* arm = new RigidBody(name + " Strut");
+      mVehicle->getMultiBodySystem()->addRigidBody(arm);
       strutParent->addChildFrame(arm);
       arm->addMultiBodyModel(new Mass(inertiaFrom(Vector3(0, 0, 1), SpatialInertia(200))));
 

Modified: trunk/OpenFDM/src/OpenFDM/MultiBodySystem.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/MultiBodySystem.cpp	2005-12-23 15:36:24 UTC (rev 112)
+++ trunk/OpenFDM/src/OpenFDM/MultiBodySystem.cpp	2005-12-23 16:30:12 UTC (rev 113)
@@ -277,4 +277,10 @@
   mRootFrame->accept(uv);
 }
 
+void
+MultiBodySystem::addRigidBody(RigidBody* rigidBody)
+{
+  mRigidBodies.push_back(rigidBody);
+}
+
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/MultiBodySystem.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/MultiBodySystem.h	2005-12-23 15:36:24 UTC (rev 112)
+++ trunk/OpenFDM/src/OpenFDM/MultiBodySystem.h	2005-12-23 16:30:12 UTC (rev 113)
@@ -44,10 +44,17 @@
   virtual bool init(void);
   virtual void output(const TaskInfo& taskInfo);
   virtual void update(const TaskInfo& taskInfo);
+
+  /// Add a RigidBody to that MultiBodySystem FIXME missing other api functions
+  void addRigidBody(RigidBody* rigidBody);
 private:
   /// At the moment each MultiBodySystem has its own root frame,
   /// In the future just store the root joint and reference a common root frame
   SharedPtr<RootFrame> mRootFrame;
+
+  /// A list of RigidBody objects in this MultiBodySystem
+  typedef std::vector<SharedPtr<RigidBody> > BodyList;
+  BodyList mRigidBodies;
 };
 
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/Vehicle.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Vehicle.cpp	2005-12-23 15:36:24 UTC (rev 112)
+++ trunk/OpenFDM/src/OpenFDM/Vehicle.cpp	2005-12-23 16:30:12 UTC (rev 113)
@@ -46,6 +46,7 @@
   mModelGroup = new ModelGroup("Flight Control System");
 
   mMultiBodySystem = new MultiBodySystem(mRootFrame);
+  mMultiBodySystem->addRigidBody(mTopBody);
 
 //   mSystem->setTimestepper(new ExplicitAdams);
   mSystem->setTimestepper(new DoPri5);

Modified: trunk/OpenFDM/src/OpenFDM/Vehicle.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Vehicle.h	2005-12-23 15:36:24 UTC (rev 112)
+++ trunk/OpenFDM/src/OpenFDM/Vehicle.h	2005-12-23 16:30:12 UTC (rev 113)
@@ -121,22 +121,8 @@
   System* getSystem(void)
   { return mSystem; }
 
-  void addRigidBody(RigidBody* rigidBody)
-  { mRigidBodyIdMap[rigidBody->getName()] = rigidBody; }
-  RigidBody* getRigidBody(const std::string& id)
-  {
-    if (0 < mRigidBodyIdMap.count(id))
-      return mRigidBodyIdMap[id];
-    return 0;
-  }
-  void addJoint(Joint* joint)
-  { mJointIdMap[joint->getName()] = joint; }
-  Joint* getJoint(const std::string& id)
-  {
-    if (0 < mJointIdMap.count(id))
-      return mJointIdMap[id];
-    return 0;
-  }
+  MultiBodySystem* getMultiBodySystem(void)
+  { return mMultiBodySystem; }
 
 private:
   // Environment ...
@@ -150,14 +136,6 @@
   SharedPtr<ModelGroup> mModelGroup;
 
   SharedPtr<System> mSystem;
-
-  std::map<std::string, SharedPtr<Frame> > mFrameIdMap;
-  std::map<std::string, SharedPtr<Joint> > mJointIdMap;
-  std::map<std::string, SharedPtr<RigidBody> > mRigidBodyIdMap;
-  std::map<std::string, SharedPtr<Force> > mForceIdMap;
-
-  // FIXME make a attach blub at id ...
-  friend class JSBReader;
 };
 
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/main.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/main.cpp	2005-12-23 15:36:24 UTC (rev 112)
+++ trunk/OpenFDM/src/OpenFDM/main.cpp	2005-12-23 16:30:12 UTC (rev 113)
@@ -409,11 +409,11 @@
       RigidBody* rigidBody = new RigidBody();
       rigidBody->setName((*it)->getAttribute("Name"));
       
-      if (mVehicle->getRigidBody((*it)->getAttribute("Name")))
-        return error(std::string("Error loading RigidBodies: Duplicate Rigid Body Name \"")
-                     + (*it)->getAttribute("Name") + "\" !");
+//       if (mVehicle->getRigidBody((*it)->getAttribute("Name")))
+//         return error(std::string("Error loading RigidBodies: Duplicate Rigid Body Name \"")
+//                      + (*it)->getAttribute("Name") + "\" !");
       
-      mVehicle->addRigidBody(rigidBody);
+//       mVehicle->addRigidBody(rigidBody);
       ++it;
     }
     return true;
@@ -438,10 +438,10 @@
                      + (*it)->getAttribute("Type") + "\" !");
       
       
-      if (mVehicle->getJoint((*it)->getAttribute("Name")))
-        return error(std::string("Error loading Vehicle: Duplicate Name \"")
-                     + (*it)->getAttribute("Name") + "\" !");
-      mVehicle->addJoint(joint);
+//       if (mVehicle->getJoint((*it)->getAttribute("Name")))
+//         return error(std::string("Error loading Vehicle: Duplicate Name \"")
+//                      + (*it)->getAttribute("Name") + "\" !");
+//       mVehicle->addJoint(joint);
       
       
       // Connect the joints to the rigid bodies.
@@ -452,13 +452,13 @@
       std::list<XMLElement::const_pointer>::iterator mit = mounts.begin();
       for (unsigned idx = 0; mit != mounts.end(); ++idx, ++mit) {
         std::string mountAttrName = (*mit)->getAttribute("Name");
-        RigidBody* body = mVehicle->getRigidBody(mountAttrName);
-        if (!body)
-          return error(std::string("Error loading Vehicle:") +
-                       " Can not find RigidBody \"" + mountAttrName +
-                       "\" for Mount of Joint \"" + joint->getName() + "\"!");
+//         RigidBody* body = mVehicle->getRigidBody(mountAttrName);
+//         if (!body)
+//           return error(std::string("Error loading Vehicle:") +
+//                        " Can not find RigidBody \"" + mountAttrName +
+//                        "\" for Mount of Joint \"" + joint->getName() + "\"!");
        
-        joint->setParentFrame(body, idx);
+//         joint->setParentFrame(body, idx);
         
         // Read the orientation. No orientation element means unit orientation.
         // Multiple orientations is an error.



From frohlich at berlios.de  Fri Dec 23 18:48:48 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Fri, 23 Dec 2005 18:48:48 +0100
Subject: [OpenFDM-svn] r114 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200512231748.jBNHmm4R012937@sheep.berlios.de>

Author: frohlich
Date: 2005-12-23 18:48:36 +0100 (Fri, 23 Dec 2005)
New Revision: 114

Added:
   trunk/OpenFDM/src/OpenFDM/Interact.cpp
   trunk/OpenFDM/src/OpenFDM/Interact.h
Modified:
   trunk/OpenFDM/src/OpenFDM/Force.h
   trunk/OpenFDM/src/OpenFDM/Joint.h
   trunk/OpenFDM/src/OpenFDM/Makefile.am
   trunk/OpenFDM/src/OpenFDM/MultiBodyModel.cpp
   trunk/OpenFDM/src/OpenFDM/MultiBodyModel.h
   trunk/OpenFDM/src/OpenFDM/RigidBody.cpp
   trunk/OpenFDM/src/OpenFDM/RigidBody.h
Log:
Move Interact into its own file.


Modified: trunk/OpenFDM/src/OpenFDM/Force.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Force.h	2005-12-23 16:30:12 UTC (rev 113)
+++ trunk/OpenFDM/src/OpenFDM/Force.h	2005-12-23 17:48:36 UTC (rev 114)
@@ -10,6 +10,7 @@
 #include "Vector.h"
 #include "Frame.h"
 #include "RigidBody.h"
+#include "Interact.h"
 #include "Visitor.h"
 #include "ConstVisitor.h"
 

Added: trunk/OpenFDM/src/OpenFDM/Interact.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Interact.cpp	2005-12-23 16:30:12 UTC (rev 113)
+++ trunk/OpenFDM/src/OpenFDM/Interact.cpp	2005-12-23 17:48:36 UTC (rev 114)
@@ -0,0 +1,101 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
+ *
+ */
+
+#include <iosfwd>
+#include <list>
+#include <string>
+
+#include "Assert.h"
+#include "Object.h"
+#include "Vector.h"
+#include "Matrix.h"
+#include "Quaternion.h"
+#include "Inertia.h"
+#include "Frame.h"
+#include "RigidBody.h"
+#include "Visitor.h"
+#include "ConstVisitor.h"
+#include "Interact.h"
+
+namespace OpenFDM {
+
+Interact::Interact(const std::string& name, unsigned numParents) :
+  Model(name),
+  mParents(numParents)
+{
+}
+
+Interact::~Interact(void)
+{
+}
+
+void
+Interact::accept(Visitor& visitor)
+{
+  visitor.apply(*this);
+}
+
+void
+Interact::traverse(Visitor& visitor)
+{
+}
+
+void
+Interact::accept(ConstVisitor& visitor) const
+{
+  visitor.apply(*this);
+}
+
+void
+Interact::traverse(ConstVisitor& visitor) const
+{
+}
+
+bool
+Interact::attachTo(RigidBody* rigidBody)
+{
+  if (!rigidBody) {
+    Log(MultiBody,Error) << "Got 0 RigidBody pointer to attach to." << endl;
+    return false;
+  }
+  ParentList::iterator it;
+  for (it = mParents.begin(); it != mParents.end(); ++it) {
+    if (!(*it)) {
+      (*it) = rigidBody;
+      (*it)->addInteract(this);
+      return true;
+    }
+  }
+  
+  Log(MultiBody,Error) << "Cannot attach Interact \"" << getName()
+                       << "\" to RigidBody \"" << rigidBody->getName()
+                       << "\": Already attached to 2 Rigid bodies."
+                       << endl;
+  return false;
+}
+
+bool
+Interact::detachFrom(RigidBody* rigidBody)
+{
+  if (!rigidBody) {
+    Log(MultiBody,Error) << "Got 0 RigidBody pointer to attach to." << endl;
+    return false;
+  }
+  ParentList::iterator it;
+  for (it = mParents.begin(); it != mParents.end(); ++it) {
+    if ((*it) == rigidBody) {
+      (*it)->removeInteract(this);
+      (*it) = 0;
+      return true;
+    }
+  }
+  
+  Log(MultiBody,Error) << "Cannot detatach Interact \"" << getName()
+                       << "\" from RigidBody \"" << rigidBody->getName()
+                       << "\": Interact is not attached to that RigidBody."
+                       << endl;
+  return false;
+}
+
+} // namespace OpenFDM


Property changes on: trunk/OpenFDM/src/OpenFDM/Interact.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/OpenFDM/src/OpenFDM/Interact.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Interact.h	2005-12-23 16:30:12 UTC (rev 113)
+++ trunk/OpenFDM/src/OpenFDM/Interact.h	2005-12-23 17:48:36 UTC (rev 114)
@@ -0,0 +1,65 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_Interact_H
+#define OpenFDM_Interact_H
+
+#include <iosfwd>
+#include <list>
+#include <string>
+
+#include "Assert.h"
+#include "Object.h"
+#include "Vector.h"
+#include "Matrix.h"
+#include "Quaternion.h"
+#include "Inertia.h"
+#include "Frame.h"
+#include "RigidBody.h"
+
+namespace OpenFDM {
+
+class Interact :
+    public Model {
+public:
+  Interact(const std::string& name, unsigned numParents);
+  virtual ~Interact(void);
+
+
+  /// Double dispatch helper for the multibody system visitor
+  virtual void accept(Visitor& visitor);
+  /// Double dispatch helper for the multibody system visitor
+  virtual void traverse(Visitor& visitor);
+  /// Double dispatch helper for the multibody system visitor
+  virtual void accept(ConstVisitor& visitor) const;
+  /// Double dispatch helper for the multibody system visitor
+  virtual void traverse(ConstVisitor& visitor) const;
+
+
+  bool attachTo(RigidBody* rigidBody);
+  bool detachFrom(RigidBody* rigidBody);
+
+  virtual void interactWith(RigidBody* rigidBody) = 0;
+
+  /// FIXME remove
+  const Frame* getParentFrame(unsigned id = 0) const
+  {
+    OpenFDMAssert(id < mParents.size() && mParents[id]);
+    return mParents[id]->getFrame();
+  }
+  /// FIXME remove
+  Frame* getParentFrame(unsigned id = 0)
+  {
+    OpenFDMAssert(id < mParents.size() && mParents[id]);
+    return mParents[id]->getFrame();
+  }
+
+private:
+  typedef std::vector<WeakPtr<RigidBody> > ParentList;
+  ParentList mParents;
+};
+
+} // namespace OpenFDM
+
+#endif


Property changes on: trunk/OpenFDM/src/OpenFDM/Interact.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/OpenFDM/src/OpenFDM/Joint.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Joint.h	2005-12-23 16:30:12 UTC (rev 113)
+++ trunk/OpenFDM/src/OpenFDM/Joint.h	2005-12-23 17:48:36 UTC (rev 114)
@@ -13,6 +13,7 @@
 #include "Matrix.h"
 #include "Quaternion.h"
 #include "Inertia.h"
+#include "Interact.h"
 #include "Visitor.h"
 #include "ConstVisitor.h"
 #include "Frame.h"
@@ -20,6 +21,14 @@
 
 namespace OpenFDM {
 
+class Joint2 :
+    public Interact {
+public:
+  Joint2(const std::string& name) : Interact(name, 2) { }
+  virtual ~Joint2(void) { }
+
+};
+
 class Joint
   : public MultiBodyModel {
   OpenFDM_NodeImplementation(2);

Modified: trunk/OpenFDM/src/OpenFDM/Makefile.am
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Makefile.am	2005-12-23 16:30:12 UTC (rev 113)
+++ trunk/OpenFDM/src/OpenFDM/Makefile.am	2005-12-23 17:48:36 UTC (rev 114)
@@ -58,6 +58,7 @@
   Ground.h \
   Input.h \
   Integrator.h \
+  Interact.h \
   ImplicitEuler.h \
   Inertia.h \
   Joint.h \
@@ -163,6 +164,7 @@
   Ground.cpp \
   Input.cpp \
   Integrator.cpp \
+  Interact.cpp \
   ImplicitEuler.cpp \
   LineActuator.cpp \
   LinearSpring.cpp \

Modified: trunk/OpenFDM/src/OpenFDM/MultiBodyModel.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/MultiBodyModel.cpp	2005-12-23 16:30:12 UTC (rev 113)
+++ trunk/OpenFDM/src/OpenFDM/MultiBodyModel.cpp	2005-12-23 17:48:36 UTC (rev 114)
@@ -52,18 +52,6 @@
   return 0;
 }
 
-Force*
-MultiBodyModel::toForce(void)
-{
-  return 0;
-}
-
-const Force*
-MultiBodyModel::toForce(void) const
-{
-  return 0;
-}
-
 Joint*
 MultiBodyModel::toJoint(void)
 {

Modified: trunk/OpenFDM/src/OpenFDM/MultiBodyModel.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/MultiBodyModel.h	2005-12-23 16:30:12 UTC (rev 113)
+++ trunk/OpenFDM/src/OpenFDM/MultiBodyModel.h	2005-12-23 17:48:36 UTC (rev 114)
@@ -13,8 +13,6 @@
 
 class Frame;
 class Mass;
-// class Interact;
-class Force;
 class Joint;
 class Visitor;
 class ConstVisitor;
@@ -34,13 +32,6 @@
   virtual Mass* toMass(void);
   virtual const Mass* toMass(void) const;
 
-  /// FIXME, hmm ...
-//   virtual Interact* toInteract(void) { return 0; }
-//   virtual const Interact* toInteract(void) const { return 0; }
-
-  virtual Force* toForce(void);
-  virtual const Force* toForce(void) const;
-
   virtual Joint* toJoint(void);
   virtual const Joint* toJoint(void) const;
 

Modified: trunk/OpenFDM/src/OpenFDM/RigidBody.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RigidBody.cpp	2005-12-23 16:30:12 UTC (rev 113)
+++ trunk/OpenFDM/src/OpenFDM/RigidBody.cpp	2005-12-23 17:48:36 UTC (rev 114)
@@ -103,20 +103,6 @@
                       cross(iv.getLinear(), Jiv.getLinear()),
                       cross(iv.getAngular(), Jiv.getLinear()));
 
-  // Collect all forces acting directly on that body.
-//   n = getNumMultiBodyModels();
-//   for (unsigned i = 0; i < n; ++i) {
-//     Force* child = getMultiBodyModel(i)->toForce();
-//     if (child) {
-//       Log(ArtBody, Debug) << "Adding local force \"" << child->getName()
-//                           << "\" to body \"" << getName() << "\"" << endl;
-     
-//       // FIXME: why is this - sign ???
-//       // Ok, because of the minus in MobileRoot ...
-//       mArtForce -= child->getForce(this);
-//     }
-//   }
-
   // Now collect all articulated forces and all articulated inertias.
   for (unsigned i = 0; i < n; ++i) {
     Joint* joint = getMultiBodyModel(i)->toJoint();
@@ -191,17 +177,4 @@
   child->attachTo(this);
 }
 
-/// FIXME does not belong here
-void
-Interact::accept(Visitor& visitor)
-{
-  visitor.apply(*this);
-}
-
-void
-Interact::accept(ConstVisitor& visitor) const
-{
-  visitor.apply(*this);
-}
-
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/RigidBody.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RigidBody.h	2005-12-23 16:30:12 UTC (rev 113)
+++ trunk/OpenFDM/src/OpenFDM/RigidBody.h	2005-12-23 17:48:36 UTC (rev 114)
@@ -122,103 +122,12 @@
   InteractList mInteracts;
 
   /// FIXME: is interact too???
-  typedef std::vector<SharedPtr<Mass> > MassList;
-  MassList mMasses;
+//   typedef std::vector<SharedPtr<Mass> > MassList;
+//   MassList mMasses;
 
   friend class Interact;
 };
 
-class Interact :
-    public Model {
-public:
-  Interact(const std::string& name, unsigned numParents) :
-    Model(name), mParents(numParents) { }
-  virtual ~Interact(void) { }
-
-
-  /// Double dispatch helper for the multibody system visitor
-  virtual void accept(Visitor& visitor);
-  /// Double dispatch helper for the multibody system visitor
-  virtual void traverse(Visitor& visitor)
-  { }
-  /// Double dispatch helper for the multibody system visitor
-  virtual void accept(ConstVisitor& visitor) const;
-  /// Double dispatch helper for the multibody system visitor
-  virtual void traverse(ConstVisitor& visitor) const
-  { }
-
-
-  bool attachTo(RigidBody* rigidBody)
-  {
-    if (!rigidBody) {
-      Log(MultiBody,Error) << "Got 0 RigidBody pointer to attach to." << endl;
-      return false;
-    }
-    ParentList::iterator it;
-    for (it = mParents.begin(); it != mParents.end(); ++it) {
-      if (!(*it)) {
-        (*it) = rigidBody;
-        (*it)->addInteract(this);
-        return true;
-      }
-    }
-
-    Log(MultiBody,Error) << "Cannot attach Interact \"" << getName()
-                         << "\" to RigidBody \"" << rigidBody->getName()
-                         << "\": Already attached to 2 Rigid bodies."
-                         << endl;
-    return false;
-  }
-  bool detachFrom(RigidBody* rigidBody)
-  {
-    if (!rigidBody) {
-      Log(MultiBody,Error) << "Got 0 RigidBody pointer to attach to." << endl;
-      return false;
-    }
-    ParentList::iterator it;
-    for (it = mParents.begin(); it != mParents.end(); ++it) {
-      if ((*it) == rigidBody) {
-        (*it)->removeInteract(this);
-        (*it) = 0;
-        return true;
-      }
-    }
-
-    Log(MultiBody,Error) << "Cannot detatach Interact \"" << getName()
-                         << "\" from RigidBody \"" << rigidBody->getName()
-                         << "\": Interact is not attached to that RigidBody."
-                         << endl;
-    return false;
-  }
-
-  virtual void interactWith(RigidBody* rigidBody) = 0;
-
-  /// FIXME remove
-  const Frame* getParentFrame(unsigned id = 0) const
-  {
-    OpenFDMAssert(id < mParents.size() && mParents[id]);
-    return mParents[id]->getFrame();
-  }
-  /// FIXME remove
-  Frame* getParentFrame(unsigned id = 0)
-  {
-    OpenFDMAssert(id < mParents.size() && mParents[id]);
-    return mParents[id]->getFrame();
-  }
-
-private:
-  typedef std::vector<WeakPtr<RigidBody> > ParentList;
-  ParentList mParents;
-};
-
-class Joint2 :
-    public Interact {
-public:
-  Joint2(const std::string& name) : Interact(name, 2) { }
-  virtual ~Joint2(void) { }
-
-};
-
 } // namespace OpenFDM
 
 #endif



From frohlich at berlios.de  Fri Dec 23 19:48:11 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Fri, 23 Dec 2005 19:48:11 +0100
Subject: [OpenFDM-svn] r115 - in trunk/OpenFDM/src: JSBSim OpenFDM
Message-ID: <200512231848.jBNImBBt010053@sheep.berlios.de>

Author: frohlich
Date: 2005-12-23 19:48:01 +0100 (Fri, 23 Dec 2005)
New Revision: 115

Modified:
   trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
   trunk/OpenFDM/src/OpenFDM/Interact.h
   trunk/OpenFDM/src/OpenFDM/Mass.cpp
   trunk/OpenFDM/src/OpenFDM/Mass.h
   trunk/OpenFDM/src/OpenFDM/MultiBodyModel.cpp
   trunk/OpenFDM/src/OpenFDM/MultiBodyModel.h
   trunk/OpenFDM/src/OpenFDM/RigidBody.cpp
   trunk/OpenFDM/src/OpenFDM/RigidBody.h
Log:
Make Mass an Interact


Modified: trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
===================================================================
--- trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2005-12-23 17:48:36 UTC (rev 114)
+++ trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2005-12-23 18:48:01 UTC (rev 115)
@@ -707,7 +707,7 @@
     spi += inertiaFrom(structToBody(it->first), inertia);
     ++it;
   }
-  mVehicle->getTopBody()->addMultiBodyModel(new Mass(spi));
+  mVehicle->getTopBody()->addInteract2(new Mass(spi));
 
   // Attach the eye point.
   FreeFrame* epFrame = new FreeFrame("Eyepoint Frame");
@@ -738,7 +738,7 @@
 {
   RigidBody* wheel = new RigidBody(name + " Wheel");
   InertiaMatrix wheelInertia(10, 0, 0, 100, 0, 10);
-  wheel->addMultiBodyModel(new Mass(SpatialInertia(wheelInertia, 50)));
+  wheel->addInteract2(new Mass(SpatialInertia(wheelInertia, 50)));
   parent->addChildFrame(wheel);
   mVehicle->getMultiBodySystem()->addRigidBody(wheel);
   
@@ -929,7 +929,7 @@
       RigidBody* arm = new RigidBody(name + " Arm");
       mVehicle->getMultiBodySystem()->addRigidBody(arm);
       mVehicle->getTopBody()->addChildFrame(arm);
-      arm->addMultiBodyModel(new Mass(inertiaFrom(Vector3(-1, 0, 0), SpatialInertia(200))));
+      arm->addInteract2(new Mass(inertiaFrom(Vector3(-1, 0, 0), SpatialInertia(200))));
 
       // Connect that with a revolute joint to the main body
       RevoluteJoint* rj = new RevoluteJoint(name + " Arm Joint");
@@ -1047,7 +1047,7 @@
       RigidBody* arm = new RigidBody(name + " Strut");
       mVehicle->getMultiBodySystem()->addRigidBody(arm);
       strutParent->addChildFrame(arm);
-      arm->addMultiBodyModel(new Mass(inertiaFrom(Vector3(0, 0, 1), SpatialInertia(200))));
+      arm->addInteract2(new Mass(inertiaFrom(Vector3(0, 0, 1), SpatialInertia(200))));
 
       // This time it is a prismatic joint
       PrismaticJoint* pj = new PrismaticJoint(name + " Compress Joint");

Modified: trunk/OpenFDM/src/OpenFDM/Interact.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Interact.h	2005-12-23 17:48:36 UTC (rev 114)
+++ trunk/OpenFDM/src/OpenFDM/Interact.h	2005-12-23 18:48:01 UTC (rev 115)
@@ -26,7 +26,6 @@
   Interact(const std::string& name, unsigned numParents);
   virtual ~Interact(void);
 
-
   /// Double dispatch helper for the multibody system visitor
   virtual void accept(Visitor& visitor);
   /// Double dispatch helper for the multibody system visitor
@@ -37,6 +36,8 @@
   virtual void traverse(ConstVisitor& visitor) const;
 
 
+
+
   bool attachTo(RigidBody* rigidBody);
   bool detachFrom(RigidBody* rigidBody);
 

Modified: trunk/OpenFDM/src/OpenFDM/Mass.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Mass.cpp	2005-12-23 17:48:36 UTC (rev 114)
+++ trunk/OpenFDM/src/OpenFDM/Mass.cpp	2005-12-23 18:48:01 UTC (rev 115)
@@ -2,15 +2,13 @@
  *
  */
 
-#include "Frame.h"
 #include "Mass.h"
-#include "Visitor.h"
-#include "ConstVisitor.h"
 
 namespace OpenFDM {
 
-Mass::Mass(const SpatialInertia& inertia, const std::string& name)
-  : MultiBodyModel(name), _inertia(inertia)
+Mass::Mass(const SpatialInertia& inertia, const std::string& name) :
+  Interact(name, 1),
+  mInertia(inertia)
 {
 }
 
@@ -19,51 +17,27 @@
 }
 
 void
-Mass::accept(Visitor& visitor)
+Mass::interactWith(RigidBody* rigidBody)
 {
-  visitor.apply(*this);
+  rigidBody->contributeLocalInertia(mInertia);
 }
 
 void
-Mass::accept(ConstVisitor& visitor) const
-{
-  visitor.apply(*this);
-}
-
-Mass*
-Mass::toMass(void)
-{
-  return this;
-}
-
-const Mass*
-Mass::toMass(void) const
-{
-  return this;
-}
-
-void
 Mass::setInertia(real_type mass)
 {
-  _inertia = SpatialInertia(mass);
+  mInertia = SpatialInertia(mass);
 }
 
 void
 Mass::setInertia(real_type mass, const InertiaMatrix& inertia)
 {
-  _inertia = SpatialInertia(inertia, mass);
+  mInertia = SpatialInertia(inertia, mass);
 }
 
 void
 Mass::setInertia(const SpatialInertia& I)
 {
-  _inertia = I;
+  mInertia = I;
 }
 
-void
-Mass::contributeInertia(SpatialInertia& I) const
-{
-  I += _inertia;
-}
-
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/Mass.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Mass.h	2005-12-23 17:48:36 UTC (rev 114)
+++ trunk/OpenFDM/src/OpenFDM/Mass.h	2005-12-23 18:48:01 UTC (rev 115)
@@ -5,31 +5,22 @@
 #ifndef OpenFDM_Mass_H
 #define OpenFDM_Mass_H
 
-#include "Assert.h"
-#include "MultiBodyModel.h"
+#include "Interact.h"
 #include "Inertia.h"
 
 namespace OpenFDM {
 
-class Visitor;
-class ConstVisitor;
-
-class Mass
-  : public MultiBodyModel {
-  OpenFDM_NodeImplementation(1);
+class Mass :
+    public Interact {
 public:
   Mass(const SpatialInertia& inertia = SpatialInertia(0),
        const std::string& name = std::string());
   virtual ~Mass(void);
 
-  virtual void accept(Visitor& visitor);
-  virtual void accept(ConstVisitor& visitor) const;
+  virtual void interactWith(RigidBody* rigidBody);
 
-  virtual Mass* toMass(void);
-  virtual const Mass* toMass(void) const;
-
   const SpatialInertia& getInertia(void) const
-  { return _inertia; }
+  { return mInertia; }
 
   /** Set the local spatial inertia.
       @param mass mass in kg.
@@ -55,11 +46,8 @@
    */
   void setInertia(const SpatialInertia& I);
 
-  // More efficient getter. ??
-  void contributeInertia(SpatialInertia& I) const;
-
 private:
-  SpatialInertia _inertia;
+  SpatialInertia mInertia;
 };
 
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/MultiBodyModel.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/MultiBodyModel.cpp	2005-12-23 17:48:36 UTC (rev 114)
+++ trunk/OpenFDM/src/OpenFDM/MultiBodyModel.cpp	2005-12-23 18:48:01 UTC (rev 115)
@@ -40,18 +40,6 @@
 {
 }
 
-Mass*
-MultiBodyModel::toMass(void)
-{
-  return 0;
-}
-
-const Mass*
-MultiBodyModel::toMass(void) const
-{
-  return 0;
-}
-
 Joint*
 MultiBodyModel::toJoint(void)
 {

Modified: trunk/OpenFDM/src/OpenFDM/MultiBodyModel.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/MultiBodyModel.h	2005-12-23 17:48:36 UTC (rev 114)
+++ trunk/OpenFDM/src/OpenFDM/MultiBodyModel.h	2005-12-23 18:48:01 UTC (rev 115)
@@ -12,7 +12,6 @@
 namespace OpenFDM {
 
 class Frame;
-class Mass;
 class Joint;
 class Visitor;
 class ConstVisitor;
@@ -29,9 +28,6 @@
   virtual void accept(ConstVisitor& visitor) const;
   virtual void traverse(ConstVisitor& visitor) const;
 
-  virtual Mass* toMass(void);
-  virtual const Mass* toMass(void) const;
-
   virtual Joint* toJoint(void);
   virtual const Joint* toJoint(void) const;
 

Modified: trunk/OpenFDM/src/OpenFDM/RigidBody.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RigidBody.cpp	2005-12-23 17:48:36 UTC (rev 114)
+++ trunk/OpenFDM/src/OpenFDM/RigidBody.cpp	2005-12-23 18:48:01 UTC (rev 115)
@@ -56,10 +56,6 @@
   InteractList::iterator it;
   for (it = mInteracts.begin(); it != mInteracts.end(); ++it)
     (*it)->accept(visitor);
-//     MassList::iterator it;
-//     for (it = mMasses.begin(); it != mMasses.end(); ++it)
-//       (*it)->accept(visitor);
-  
   Frame::traverse(visitor);
 }
 
@@ -69,9 +65,6 @@
   InteractList::const_iterator it;
   for (it = mInteracts.begin(); it != mInteracts.end(); ++it)
     (*it)->accept(visitor);
-//     MassList::const_iterator it;
-//     for (it = mMasses.begin(); it != mMasses.end(); ++it)
-//       (*it)->accept(visitor);
   Frame::traverse(visitor);
 }
 
@@ -83,28 +76,11 @@
 
   // At first this is the inertia matrix of the current body.
   mArtInertia = SpatialInertia::zeros();
+  mArtForce = Vector6::zeros();
 
+  // Now collect all articulated forces and all articulated inertias.
   unsigned n = getNumMultiBodyModels();
   for (unsigned i = 0; i < n; ++i) {
-    Mass* child = getMultiBodyModel(i)->toMass();
-    if (child) {
-      Log(ArtBody, Debug) << "Adding local mass \"" << child->getName()
-                          << "\" to body \"" << getName() << "\"" << endl;
-      mArtInertia += child->getInertia();
-    }
-  }
-  
-
-  // 
-  Vector6 iv = getSpVel();
-  Vector6 Jiv = mArtInertia*iv;
-  Log(ArtBody, Debug3) << "Spatial velocity is " << trans(iv) << endl;
-  mArtForce = Vector6(cross(iv.getAngular(), Jiv.getAngular()) +
-                      cross(iv.getLinear(), Jiv.getLinear()),
-                      cross(iv.getAngular(), Jiv.getLinear()));
-
-  // Now collect all articulated forces and all articulated inertias.
-  for (unsigned i = 0; i < n; ++i) {
     Joint* joint = getMultiBodyModel(i)->toJoint();
     if (joint) {
       Log(ArtBody, Debug) << "Processing joint \"" << joint->getName()

Modified: trunk/OpenFDM/src/OpenFDM/RigidBody.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RigidBody.h	2005-12-23 17:48:36 UTC (rev 114)
+++ trunk/OpenFDM/src/OpenFDM/RigidBody.h	2005-12-23 18:48:01 UTC (rev 115)
@@ -82,16 +82,24 @@
   Vector6 getPAlpha(void) const
   { return mArtForce + mArtInertia*getHdot(); }
 
-  /**
-   */
+  /// Contribute articulated force
   void contributeForce(const Vector6& force)
   { mArtForce += force; }
 
-  /**
-   */
+  /// Contribute articulated inertia
   void contributeInertia(const SpatialInertia& inertia)
   { mArtInertia += inertia; }
 
+  /// Contribute the articulated inertia and force of a local Mass object
+  void contributeLocalInertia(const SpatialInertia& inertia)
+  {
+    Vector6 iv = getFrame()->getSpVel();
+    Vector6 Jiv = inertia*iv;
+    mArtForce += Vector6(cross(iv.getAngular(), Jiv.getAngular()) +
+                         cross(iv.getLinear(), Jiv.getLinear()),
+                         cross(iv.getAngular(), Jiv.getLinear()));
+    mArtInertia += inertia;
+  }
 
   /** Introduce an interface routine
    */
@@ -107,14 +115,15 @@
   void addInteract(Interact* interact);
   bool removeInteract(Interact* interact);
 
-  /** Outboard articulated inertia.
-   */
+  /// Outboard articulated inertia
   SpatialInertia mArtInertia;
 
-  /** Outboard articulated force.
-   */
+  /// Outboard articulated force
   Vector6 mArtForce;
 
+  /// Local inertia, needs to be set up at each cycle!?
+//   SpatialInertia mLocalInertia;
+
   /// Frame attached to this rigid body
 //   SharedPtr<Frame> mFrame;
 



From frohlich at berlios.de  Fri Dec 23 20:59:12 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Fri, 23 Dec 2005 20:59:12 +0100
Subject: [OpenFDM-svn] r116 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200512231959.jBNJxC3E006685@sheep.berlios.de>

Author: frohlich
Date: 2005-12-23 20:59:05 +0100 (Fri, 23 Dec 2005)
New Revision: 116

Modified:
   trunk/OpenFDM/src/OpenFDM/ConstVisitor.h
   trunk/OpenFDM/src/OpenFDM/Interact.cpp
   trunk/OpenFDM/src/OpenFDM/Interact.h
   trunk/OpenFDM/src/OpenFDM/Model.h
   trunk/OpenFDM/src/OpenFDM/ModelVisitor.h
   trunk/OpenFDM/src/OpenFDM/MultiBodySystem.cpp
   trunk/OpenFDM/src/OpenFDM/MultiBodySystem.h
   trunk/OpenFDM/src/OpenFDM/Visitor.h
Log:
Store a list of Interacts in a MultiBodySystem


Modified: trunk/OpenFDM/src/OpenFDM/ConstVisitor.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/ConstVisitor.h	2005-12-23 18:48:01 UTC (rev 115)
+++ trunk/OpenFDM/src/OpenFDM/ConstVisitor.h	2005-12-23 19:59:05 UTC (rev 116)
@@ -11,7 +11,6 @@
 
 class Frame;
 class RigidBody;
-class Mass;
 class Force;
 class Joint;
 class Interact;
@@ -26,10 +25,6 @@
   { apply((const Frame&)body); }
   virtual void apply(const MultiBodyModel& abNode)
   { traverse(abNode); }
-  virtual void apply(const Mass& mass)
-  { apply((const MultiBodyModel&)mass); }
-//   virtual void apply(const Force& force)
-//   { apply((const MultiBodyModel&)force); }
   virtual void apply(const Joint& joint)
   { apply((const MultiBodyModel&)joint); }
   virtual void apply(const Interact& interact)

Modified: trunk/OpenFDM/src/OpenFDM/Interact.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Interact.cpp	2005-12-23 18:48:01 UTC (rev 115)
+++ trunk/OpenFDM/src/OpenFDM/Interact.cpp	2005-12-23 19:59:05 UTC (rev 116)
@@ -14,6 +14,7 @@
 #include "Inertia.h"
 #include "Frame.h"
 #include "RigidBody.h"
+#include "ModelVisitor.h"
 #include "Visitor.h"
 #include "ConstVisitor.h"
 #include "Interact.h"
@@ -52,6 +53,12 @@
 {
 }
 
+void
+Interact::accept(ModelVisitor& visitor)
+{
+  visitor.apply(*this);
+}
+
 bool
 Interact::attachTo(RigidBody* rigidBody)
 {

Modified: trunk/OpenFDM/src/OpenFDM/Interact.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Interact.h	2005-12-23 18:48:01 UTC (rev 115)
+++ trunk/OpenFDM/src/OpenFDM/Interact.h	2005-12-23 19:59:05 UTC (rev 116)
@@ -36,8 +36,13 @@
   virtual void traverse(ConstVisitor& visitor) const;
 
 
+  /// Double dispatch helper for the multibody system visitor
+  virtual void accept(ModelVisitor& visitor);
+  /// Double dispatch helper for the multibody system visitor
+//   virtual void accept(ConstModelVisitor& visitor) const;
 
 
+
   bool attachTo(RigidBody* rigidBody);
   bool detachFrom(RigidBody* rigidBody);
 

Modified: trunk/OpenFDM/src/OpenFDM/Model.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Model.h	2005-12-23 18:48:01 UTC (rev 115)
+++ trunk/OpenFDM/src/OpenFDM/Model.h	2005-12-23 19:59:05 UTC (rev 116)
@@ -22,6 +22,7 @@
 namespace OpenFDM {
 
 class ModelGroup;
+class MultiBodySystem;
 class Input;
 class Output;
 
@@ -163,6 +164,7 @@
 
   // FIXME
   friend class ModelGroup;
+  friend class MultiBodySystem;
 };
 
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/ModelVisitor.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/ModelVisitor.h	2005-12-23 18:48:01 UTC (rev 115)
+++ trunk/OpenFDM/src/OpenFDM/ModelVisitor.h	2005-12-23 19:59:05 UTC (rev 116)
@@ -29,6 +29,10 @@
   /// traverse downward
   inline void traverse(ModelGroup& modelGroup)
   { modelGroup.traverse(*this); }
+  /// Call this in the apply(MultiBodyModel&) method if you want to
+  /// traverse downward
+  inline void traverse(MultiBodySystem& multiBodySystem)
+  { multiBodySystem.traverse(*this); }
   /// Call this in the apply(ModelGroup&) method if you want to
   /// traverse upward
   inline void ascend(Model& model)

Modified: trunk/OpenFDM/src/OpenFDM/MultiBodySystem.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/MultiBodySystem.cpp	2005-12-23 18:48:01 UTC (rev 115)
+++ trunk/OpenFDM/src/OpenFDM/MultiBodySystem.cpp	2005-12-23 19:59:05 UTC (rev 116)
@@ -280,7 +280,56 @@
 void
 MultiBodySystem::addRigidBody(RigidBody* rigidBody)
 {
+  if (!rigidBody)
+    return;
+  RigidBodyList::iterator it = mRigidBodies.begin();
+  while (it != mRigidBodies.end()) {
+    if ((*it) == rigidBody)
+      return;
+    ++it;
+  }
   mRigidBodies.push_back(rigidBody);
 }
 
+void
+MultiBodySystem::removeRigidBody(RigidBody* rigidBody)
+{
+  RigidBodyList::iterator it = mRigidBodies.begin();
+  while (it != mRigidBodies.end()) {
+    if ((*it) == rigidBody)
+      it = mRigidBodies.erase(it);
+    else
+      ++it;
+  }
+}
+
+void
+MultiBodySystem::addInteract(Interact* interact)
+{
+  if (!interact)
+    return;
+  /// Already in the list, might be already attached to an other rigid body
+  if (this == interact->getParent())
+    return;
+  mInteracts.push_back(interact);
+  interact->setParent(this);
+}
+
+void
+MultiBodySystem::removeInteract(Interact* interact)
+{
+  if (!interact)
+    return;
+  if (this != interact->getParent())
+    return;
+  interact->setParent(0);
+  InteractList::iterator it = mInteracts.begin();
+  while (it != mInteracts.end()) {
+    if ((*it) == interact)
+      it = mInteracts.erase(it);
+    else
+      ++it;
+  }
+}
+
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/MultiBodySystem.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/MultiBodySystem.h	2005-12-23 18:48:01 UTC (rev 115)
+++ trunk/OpenFDM/src/OpenFDM/MultiBodySystem.h	2005-12-23 19:59:05 UTC (rev 116)
@@ -29,6 +29,15 @@
   /// Double dispatch helper for the multibody system visitor
 //   virtual void accept(ConstModelVisitor& visitor) const;
 
+  void traverse(ModelVisitor& visitor)
+  {
+    InteractList::iterator it = mInteracts.begin();
+    while (it != mInteracts.end()) {
+      (*it)->accept(visitor);
+      ++it;
+    }
+  }
+
   /** Sets the state of this multibody system from the state vector state.
    */
   void setEvalState(const Vector& state);
@@ -45,16 +54,25 @@
   virtual void output(const TaskInfo& taskInfo);
   virtual void update(const TaskInfo& taskInfo);
 
-  /// Add a RigidBody to that MultiBodySystem FIXME missing other api functions
+  /// Add a RigidBody to that MultiBodySystem
   void addRigidBody(RigidBody* rigidBody);
+  void removeRigidBody(RigidBody* rigidBody);
+
+  /// Add an Interact to that MultiBodySystem
+  void addInteract(Interact* interact);
+  void removeInteract(Interact* interact);
 private:
   /// At the moment each MultiBodySystem has its own root frame,
   /// In the future just store the root joint and reference a common root frame
   SharedPtr<RootFrame> mRootFrame;
 
   /// A list of RigidBody objects in this MultiBodySystem
-  typedef std::vector<SharedPtr<RigidBody> > BodyList;
-  BodyList mRigidBodies;
+  typedef std::vector<SharedPtr<RigidBody> > RigidBodyList;
+  RigidBodyList mRigidBodies;
+
+  /// A list of Interact objects in this MultiBodySystem
+  typedef std::vector<SharedPtr<Interact> > InteractList;
+  InteractList mInteracts;
 };
 
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/Visitor.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Visitor.h	2005-12-23 18:48:01 UTC (rev 115)
+++ trunk/OpenFDM/src/OpenFDM/Visitor.h	2005-12-23 19:59:05 UTC (rev 116)
@@ -10,8 +10,6 @@
 namespace OpenFDM {
 
 class RigidBody;
-class Mass;
-class Force;
 class Joint;
 class MultiBodyModel;
 class Interact;
@@ -26,10 +24,6 @@
   { apply((Frame&)body); }
   virtual void apply(MultiBodyModel& abNode)
   { traverse(abNode); }
-  virtual void apply(Mass& mass)
-  { apply((MultiBodyModel&)mass); }
-//   virtual void apply(Force& force)
-//   { apply((MultiBodyModel&)force); }
   virtual void apply(Joint& joint)
   { apply((MultiBodyModel&)joint); }
   virtual void apply(Interact& interact)



From frohlich at berlios.de  Sun Dec 25 19:22:22 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Sun, 25 Dec 2005 19:22:22 +0100
Subject: [OpenFDM-svn] r117 - in trunk/OpenFDM/src: JSBSim OpenFDM
Message-ID: <200512251822.jBPIMMku008225@sheep.berlios.de>

Author: frohlich
Date: 2005-12-25 19:22:08 +0100 (Sun, 25 Dec 2005)
New Revision: 117

Modified:
   trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
   trunk/OpenFDM/src/OpenFDM/AeroForce.cpp
   trunk/OpenFDM/src/OpenFDM/AeroForce.h
   trunk/OpenFDM/src/OpenFDM/FreeJoint.h
   trunk/OpenFDM/src/OpenFDM/Interact.cpp
   trunk/OpenFDM/src/OpenFDM/Interact.h
   trunk/OpenFDM/src/OpenFDM/Joint.h
   trunk/OpenFDM/src/OpenFDM/ModelVisitor.h
   trunk/OpenFDM/src/OpenFDM/MultiBodySystem.cpp
   trunk/OpenFDM/src/OpenFDM/MultiBodySystem.h
   trunk/OpenFDM/src/OpenFDM/RigidBody.cpp
   trunk/OpenFDM/src/OpenFDM/RigidBody.h
   trunk/OpenFDM/src/OpenFDM/Sensor.h
   trunk/OpenFDM/src/OpenFDM/System.cpp
   trunk/OpenFDM/src/OpenFDM/Vehicle.cpp
Log:
Make Joints Interacts


Modified: trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
===================================================================
--- trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2005-12-23 19:59:05 UTC (rev 116)
+++ trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2005-12-25 18:22:08 UTC (rev 117)
@@ -718,7 +718,7 @@
   accelSensor->addSampleTime(SampleTime(1.0/120));
   Port* port = accelSensor->getOutputPort("nz");
   registerJSBExpression("accelerations/n-pilot-z-norm", port);
-//   epFrame->addMultiBodyModel(accelSensor);
+//   epFrame->addInteract2(accelSensor);
   mVehicle->getTopBody()->addMultiBodyModel(accelSensor);
   mVehicle->getTopBody()->addChildFrame(epFrame);
   addOutputModel(port, "Normalized load value", "/accelerations/nlf");
@@ -743,8 +743,8 @@
   mVehicle->getMultiBodySystem()->addRigidBody(wheel);
   
   RevoluteJoint* wj = new RevoluteJoint(name + " Wheel Joint");
-  parent->addMultiBodyModel(wj, 0);
-  wheel->addMultiBodyModel(wj, 1);
+  parent->addInteract2(wj, 0);
+  wheel->addInteract2(wj, 1);
   wj->setJointAxis(Vector3(0, 1, 0));
   wj->setPosition(pos);
   wj->setOrientation(Quaternion::unit());
@@ -933,8 +933,8 @@
 
       // Connect that with a revolute joint to the main body
       RevoluteJoint* rj = new RevoluteJoint(name + " Arm Joint");
-      mVehicle->getTopBody()->addMultiBodyModel(rj, 0);
-      arm->addMultiBodyModel(rj, 1);
+      mVehicle->getTopBody()->addInteract2(rj, 0);
+      arm->addInteract2(rj, 1);
       rj->setJointAxis(Vector3(0, 1, 0));
       rj->setJointPos(0);
       rj->setJointVel(0);
@@ -1009,8 +1009,8 @@
         // Note the 0.05m below, most steering wheels have some kind of
         // castering auto line up behavour. That is doe with this 0.05m.
         RevoluteJoint* sj = new RevoluteJoint(name + " Steer Joint");
-        strutParent->addMultiBodyModel(sj, 0);
-        steer->addMultiBodyModel(sj, 1);
+        strutParent->addInteract2(sj, 0);
+        steer->addInteract2(sj, 1);
         sj->setJointAxis(Vector3(0, 0, 1));
         sj->setJointPos(0);
         sj->setJointVel(0);
@@ -1051,8 +1051,8 @@
 
       // This time it is a prismatic joint
       PrismaticJoint* pj = new PrismaticJoint(name + " Compress Joint");
-      strutParent->addMultiBodyModel(pj, 0);
-      arm->addMultiBodyModel(pj, 1);
+      strutParent->addInteract2(pj, 0);
+      arm->addInteract2(pj, 1);
       pj->setJointAxis(Vector3(0, 0, -1));
       if (strutParent == mVehicle->getTopBody())
         pj->setPosition(structToBody(compressJointPos));

Modified: trunk/OpenFDM/src/OpenFDM/AeroForce.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/AeroForce.cpp	2005-12-23 19:59:05 UTC (rev 116)
+++ trunk/OpenFDM/src/OpenFDM/AeroForce.cpp	2005-12-25 18:22:08 UTC (rev 117)
@@ -31,23 +31,7 @@
   mWingArea = 0.0;
   mCoord = 0.0;
 
-  mDirtyRefPosition = true;
-  mDirtyUnitDown = false;
-  mDirtyLocalGroundPlane = true;
-  mDirtyAtmosphere = true;
-  mDirtyAltitude = true;
-  mDirtyAboveGroundLevel = true;
-  mDirtySLAtmosphere = true;
-  mDirtyAirSpeed = true;
-  mDirtyMach = true;
-  mDirtyTrueSpeed = true;
-  mDirtyCalibratedAirSpeed = true;
-  mDirtyEquivalentAirSpeed = true;
-  mDirtyDynamicPressure = true;
-  mDirtyAlpha = true;
-  mDirtyAlphaDot = true;
-  mDirtyBeta = true;
-  mDirtyBetaDot = true;
+  dirtyAll();
 
   addProperty("position",
               Property(this, &AeroForce::getPosition, &AeroForce::setPosition));
@@ -127,6 +111,7 @@
     real_type t = taskInfo.getTime();
     mGroundVal = mEnvironment->getGround()->getGroundPlane(t, getRefPosition());
   }
+  dirtyAll();
 }
 
 void
@@ -572,29 +557,6 @@
 }
 
 void
-AeroForce::setState(const Vector& state, unsigned offset)
-{
-  // Dirty everything.
-  mDirtyRefPosition = true;
-  mDirtyUnitDown = true;
-  mDirtyLocalGroundPlane = true;
-  mDirtyAtmosphere = true;
-  mDirtyAltitude = true;
-  mDirtyAboveGroundLevel = true;
-  mDirtySLAtmosphere = true;
-  mDirtyAirSpeed = true;
-  mDirtyMach = true;
-  mDirtyTrueSpeed = true;
-  mDirtyCalibratedAirSpeed = true;
-  mDirtyEquivalentAirSpeed = true;
-  mDirtyDynamicPressure = true;
-  mDirtyAlpha = true;
-  mDirtyAlphaDot = true;
-  mDirtyBeta = true;
-  mDirtyBetaDot = true;
-}
-
-void
 AeroForce::computeForce(void)
 {
   // FIXME: they can be computed cheaper ...
@@ -624,6 +586,29 @@
 }
 
 void
+AeroForce::dirtyAll(void)
+{
+  // Dirty everything.
+  mDirtyRefPosition = true;
+  mDirtyUnitDown = true;
+  mDirtyLocalGroundPlane = true;
+  mDirtyAtmosphere = true;
+  mDirtyAltitude = true;
+  mDirtyAboveGroundLevel = true;
+  mDirtySLAtmosphere = true;
+  mDirtyAirSpeed = true;
+  mDirtyMach = true;
+  mDirtyTrueSpeed = true;
+  mDirtyCalibratedAirSpeed = true;
+  mDirtyEquivalentAirSpeed = true;
+  mDirtyDynamicPressure = true;
+  mDirtyAlpha = true;
+  mDirtyAlphaDot = true;
+  mDirtyBeta = true;
+  mDirtyBetaDot = true;
+}
+
+void
 AeroForce::computeAtmosphere(void) const
 {
   if (mDirtyAtmosphere) {

Modified: trunk/OpenFDM/src/OpenFDM/AeroForce.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/AeroForce.h	2005-12-23 19:59:05 UTC (rev 116)
+++ trunk/OpenFDM/src/OpenFDM/AeroForce.h	2005-12-25 18:22:08 UTC (rev 117)
@@ -114,13 +114,11 @@
     mBodyAxisSummers[axis-1]->addInputProperty(prop);
   }
 
-  virtual void
-  setState(const Vector& state, unsigned offset);
-
   // The interface to the mechanical system.
   virtual void computeForce(void);
 
 private:
+  void dirtyAll(void);
   void computeAtmosphere(void) const;
   void computeSLAtmosphere(void) const;
   void computeCalEquAirspeed(void) const;

Modified: trunk/OpenFDM/src/OpenFDM/FreeJoint.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/FreeJoint.h	2005-12-23 19:59:05 UTC (rev 116)
+++ trunk/OpenFDM/src/OpenFDM/FreeJoint.h	2005-12-25 18:22:08 UTC (rev 117)
@@ -24,6 +24,18 @@
   FreeJoint(Environment* env, const std::string& name = std::string());
   virtual ~FreeJoint(void);
 
+  /// HACK
+  virtual bool isArticulatedJoint(void) const
+  { return true; }
+  virtual Frame* getInboardGroup(void)
+  { return 0; }
+  virtual const Frame* getInboardGroup(void) const
+  { return 0; }
+  virtual Frame* getOutboardGroup(void)
+  { return getParentFrame(0); }
+  virtual const Frame* getOutboardGroup(void) const
+  { return getParentFrame(0); }
+
   /** Set the relative velocity.
    */
   void setRelVel(const Vector6& vel)

Modified: trunk/OpenFDM/src/OpenFDM/Interact.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Interact.cpp	2005-12-23 19:59:05 UTC (rev 116)
+++ trunk/OpenFDM/src/OpenFDM/Interact.cpp	2005-12-25 18:22:08 UTC (rev 117)
@@ -68,7 +68,7 @@
   }
   ParentList::iterator it;
   for (it = mParents.begin(); it != mParents.end(); ++it) {
-    if (!(*it)) {
+    if ((*it) == 0) {
       (*it) = rigidBody;
       (*it)->addInteract(this);
       return true;

Modified: trunk/OpenFDM/src/OpenFDM/Interact.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Interact.h	2005-12-23 19:59:05 UTC (rev 116)
+++ trunk/OpenFDM/src/OpenFDM/Interact.h	2005-12-25 18:22:08 UTC (rev 117)
@@ -48,6 +48,9 @@
 
   virtual void interactWith(RigidBody* rigidBody) = 0;
 
+  /// FIXME: hmm
+  virtual bool updateAccels() { return true; }
+
   /// FIXME remove
   const Frame* getParentFrame(unsigned id = 0) const
   {

Modified: trunk/OpenFDM/src/OpenFDM/Joint.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Joint.h	2005-12-23 19:59:05 UTC (rev 116)
+++ trunk/OpenFDM/src/OpenFDM/Joint.h	2005-12-25 18:22:08 UTC (rev 117)
@@ -7,7 +7,6 @@
 
 #include "Assert.h"
 #include "Object.h"
-#include "MultiBodyModel.h"
 #include "Frame.h"
 #include "Vector.h"
 #include "Matrix.h"
@@ -21,20 +20,11 @@
 
 namespace OpenFDM {
 
-class Joint2 :
-    public Interact {
-public:
-  Joint2(const std::string& name) : Interact(name, 2) { }
-  virtual ~Joint2(void) { }
-
-};
-
 class Joint
-  : public MultiBodyModel {
-  OpenFDM_NodeImplementation(2);
+  : public Interact {
 public:
   Joint(const std::string& name)
-    : MultiBodyModel(name)
+    : Interact(name, 2)
   {}
 
   virtual void accept(Visitor& visitor)
@@ -42,7 +32,7 @@
   virtual void accept(ConstVisitor& visitor) const
   { visitor.apply(*this); }
 
-  bool isArticulatedJoint(void) const
+  virtual bool isArticulatedJoint(void) const
   {
     const Frame* parent0 = getParentFrame(0);
     if (!parent0)
@@ -57,7 +47,7 @@
     return false;
   }
 
-  Frame* getInboardGroup(void)
+  virtual Frame* getInboardGroup(void)
   {
     Frame* parent0 = getParentFrame(0);
     if (!parent0)
@@ -71,7 +61,7 @@
       return parent1;
     return 0;
   }
-  const Frame* getInboardGroup(void) const
+  virtual const Frame* getInboardGroup(void) const
   {
     const Frame* parent0 = getParentFrame(0);
     if (!parent0)
@@ -85,7 +75,7 @@
       return parent1;
     return 0;
   }
-  Frame* getOutboardGroup(void)
+  virtual Frame* getOutboardGroup(void)
   {
     Frame* parent0 = getParentFrame(0);
     if (!parent0)
@@ -99,7 +89,7 @@
       return parent0;
     return 0;
   }
-  const Frame* getOutboardGroup(void) const
+  virtual const Frame* getOutboardGroup(void) const
   {
     const Frame* parent0 = getParentFrame(0);
     if (!parent0)
@@ -114,12 +104,22 @@
     return 0;
   }
 
-  // Cast functions.
-  virtual Joint* toJoint(void)
-  { return this; }
-  virtual const Joint* toJoint(void) const
-  { return this; }
+  virtual void interactWith(RigidBody* rigidBody)
+  {
+    // HMmMm
+    if (!isArticulatedJoint())
+      return;
 
+    if (rigidBody->getFrame() != getInboardGroup())
+      return;
+
+    SpatialInertia artI = SpatialInertia::zeros();
+    Vector6 artF = Vector6::zeros();
+    contributeArticulation(artI, artF);
+    rigidBody->contributeForce(artF);
+    rigidBody->contributeInertia(artI);
+  }
+
   bool contributeArticulation(SpatialInertia& artI, Vector6& artF)
   {
     RigidBody* outboardBody = getOutboardGroup()->toRigidBody();

Modified: trunk/OpenFDM/src/OpenFDM/ModelVisitor.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/ModelVisitor.h	2005-12-23 19:59:05 UTC (rev 116)
+++ trunk/OpenFDM/src/OpenFDM/ModelVisitor.h	2005-12-25 18:22:08 UTC (rev 117)
@@ -20,16 +20,16 @@
   { }
   virtual void apply(ModelGroup& modelGroup)
   { apply((Model&)modelGroup); }
+  virtual void apply(MultiBodySystem& multiBodySystem)
+  { apply((ModelGroup&)multiBodySystem); }
   virtual void apply(Interact& interact)
   { apply((Model&)interact); }
-  virtual void apply(MultiBodySystem& multiBodySystem)
-  { apply((Model&)multiBodySystem); }
 protected:
   /// Call this in the apply(ModelGroup&) method if you want to
   /// traverse downward
   inline void traverse(ModelGroup& modelGroup)
   { modelGroup.traverse(*this); }
-  /// Call this in the apply(MultiBodyModel&) method if you want to
+  /// Call this in the apply(MultiBodySystem&) method if you want to
   /// traverse downward
   inline void traverse(MultiBodySystem& multiBodySystem)
   { multiBodySystem.traverse(*this); }

Modified: trunk/OpenFDM/src/OpenFDM/MultiBodySystem.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/MultiBodySystem.cpp	2005-12-23 19:59:05 UTC (rev 116)
+++ trunk/OpenFDM/src/OpenFDM/MultiBodySystem.cpp	2005-12-25 18:22:08 UTC (rev 117)
@@ -42,136 +42,8 @@
   }
 };
 
-class SetStateVisitor
-  : public Visitor {
-public:
-  SetStateVisitor(const Vector& state)
-    : mState(state), mOffset(0u)
-  { }
-  virtual void apply(MultiBodyModel& abNode)
-  {
-    OpenFDMAssert(mOffset + abNode.getNumContinousStates() <= mState.size());
-    abNode.setState(mState, mOffset);
-    mOffset += abNode.getNumContinousStates();
-  }
-  virtual void apply(Interact& abNode)
-  {
-    OpenFDMAssert(mOffset + abNode.getNumContinousStates() <= mState.size());
-    abNode.setState(mState, mOffset);
-    mOffset += abNode.getNumContinousStates();
-  }
-private:
-  Vector mState;
-  unsigned mOffset;
-  real_type mTime;
-};
-
-class GetStateVisitor
-  : public ConstVisitor {
-public:
-  GetStateVisitor(unsigned size)
-    : mState(size), mOffset(0u)
-  { }
-  virtual void apply(const MultiBodyModel& abNode)
-  {
-    OpenFDMAssert(mOffset + abNode.getNumContinousStates() <= mState.size());
-    abNode.getState(mState, mOffset);
-    mOffset += abNode.getNumContinousStates();
-  }
-  virtual void apply(const Interact& abNode)
-  {
-    OpenFDMAssert(mOffset + abNode.getNumContinousStates() <= mState.size());
-    abNode.getState(mState, mOffset);
-    mOffset += abNode.getNumContinousStates();
-  }
-  const Vector& getState(void) const
-  { return mState; }
-private:
-  Vector mState;
-  unsigned mOffset;
-};
-
-class GetStateDerivVisitor
-  : public Visitor {
-public:
-  GetStateDerivVisitor(unsigned size)
-    : mStateDeriv(size), mOffset(0u)
-  { }
-  virtual void apply(MultiBodyModel& abNode)
-  {
-    OpenFDMAssert(mOffset + abNode.getNumContinousStates() <= mStateDeriv.size());
-    abNode.getStateDeriv(mStateDeriv, mOffset);
-    mOffset += abNode.getNumContinousStates();
-  }
-  virtual void apply(Interact& abNode)
-  {
-    OpenFDMAssert(mOffset + abNode.getNumContinousStates() <= mStateDeriv.size());
-    abNode.getStateDeriv(mStateDeriv, mOffset);
-    mOffset += abNode.getNumContinousStates();
-  }
-  const Vector& getStateDeriv(void) const
-  { return mStateDeriv; }
-private:
-  Vector mStateDeriv;
-  unsigned mOffset;
-};
-
-class OutputVisitor
-  : public Visitor {
-public:
-  OutputVisitor(const TaskInfo& taskInfo) : mTaskInfo(taskInfo)
-  { }
-  virtual void apply(MultiBodyModel& abNode)
-  {
-    abNode.output(mTaskInfo);
-  }
-  virtual void apply(Interact& abNode)
-  {
-    abNode.output(mTaskInfo);
-  }
-private:
-  const TaskInfo& mTaskInfo;
-};
-
-class UpdateVisitor
-  : public Visitor {
-public:
-  UpdateVisitor(const TaskInfo& taskInfo) : mTaskInfo(taskInfo)
-  { }
-  virtual void apply(MultiBodyModel& abNode)
-  {
-    abNode.update(mTaskInfo);
-  }
-  virtual void apply(Interact& abNode)
-  {
-    abNode.update(mTaskInfo);
-  }
-private:
-  const TaskInfo& mTaskInfo;
-};
-
-class StateCountVisitor
-  : public ConstVisitor {
-public:
-  StateCountVisitor(void)
-    : mOffset(0u)
-  { }
-  virtual void apply(const MultiBodyModel& abNode)
-  {
-    mOffset += abNode.getNumContinousStates();
-  }
-  virtual void apply(const Interact& abNode)
-  {
-    mOffset += abNode.getNumContinousStates();
-  }
-  unsigned getStateCount(void) const
-  { return mOffset; }
-private:
-  unsigned mOffset;
-};
-
 MultiBodySystem::MultiBodySystem(RootFrame* rootFrame) :
-  Model("multibodymodel"),
+  ModelGroup("multibodymodel"),
   mRootFrame(rootFrame)
 {
   // FIXME
@@ -189,56 +61,35 @@
   visitor.apply(*this);
 }
 
-void
-MultiBodySystem::setEvalState(const Vector& state)
-{
-  // First we need to inject the current state into the tree of parts.
-  setState(state, 0);
+// bool
+// MultiBodySystem::init(void)
+// {
+//   StateCountVisitor gsc;
+//   mRootFrame->accept(gsc);
+//   setNumContinousStates(gsc.getStateCount());
+//   return ModelGroup::init();
+// }
 
-  // Compute the external and interaction forces.
-  // FIXME:Output->continous states ...
+class OutputVisitor
+  : public Visitor {
+public:
+  OutputVisitor(const TaskInfo& taskInfo) : mTaskInfo(taskInfo)
+  { }
+  virtual void apply(MultiBodyModel& abNode)
+  {
+    abNode.output(mTaskInfo);
+  }
+  virtual void apply(Interact& abNode)
+  { }
+private:
+  const TaskInfo& mTaskInfo;
+};
 
-  // Compute forward dynamics, that is the articulated forces and inertia.
-  ForwardDynamicsVisitor fwdVisitor;
-  mRootFrame->accept(fwdVisitor);
-
-  // Then compute the articulated inertias and forces.
-  AccelerationPropagationVisitor apVisitor;
-  mRootFrame->accept(apVisitor);
-}
-
 void
-MultiBodySystem::computeStateDeriv(real_type t, const Vector& state, Vector& deriv)
+MultiBodySystem::output(const TaskInfo& taskInfo)
 {
-  setEvalState(state);
+  ModelGroup::output(taskInfo);
 
-  // And finally extract the derivative vector from the tree.
-  GetStateDerivVisitor gsdv(getNumContinousStates());
-  mRootFrame->accept(gsdv);
-  deriv = gsdv.getStateDeriv();
-}
-
-void
-MultiBodySystem::setState(const Vector& state, unsigned offset)
-{
-  SetStateVisitor ssv(state(Range(offset+1, offset+getNumContinousStates())));
-  mRootFrame->accept(ssv);
-}
-
-void
-MultiBodySystem::getState(Vector& state, unsigned offset) const
-{
-  GetStateVisitor gsv(getNumContinousStates());
-  mRootFrame->accept(gsv);
-  state(Range(offset+1, offset+getNumContinousStates())) = gsv.getState();
-}
-
-void
-MultiBodySystem::getStateDeriv(Vector& stateDeriv, unsigned offset)
-{
-  // Compute the external and interaction forces.
-  // FIXME:Output->continous states ...
-
   // Compute forward dynamics, that is the articulated forces and inertia.
   ForwardDynamicsVisitor fwdVisitor;
   mRootFrame->accept(fwdVisitor);
@@ -247,37 +98,12 @@
   AccelerationPropagationVisitor apVisitor;
   mRootFrame->accept(apVisitor);
 
-  // And finally extract the derivative vector from the tree.
-  GetStateDerivVisitor gsdv(getNumContinousStates());
-  mRootFrame->accept(gsdv);
-  stateDeriv(Range(offset+1, offset+getNumContinousStates()))
-    = gsdv.getStateDeriv();
-}
-
-bool
-MultiBodySystem::init(void)
-{
-  StateCountVisitor gsc;
-  mRootFrame->accept(gsc);
-  setNumContinousStates(gsc.getStateCount());
-  return true;
-}
-
-void
-MultiBodySystem::output(const TaskInfo& taskInfo)
-{
+  // At the moment only that acceleration sensor ...
   OutputVisitor ov(taskInfo);
   mRootFrame->accept(ov);
 }
 
 void
-MultiBodySystem::update(const TaskInfo& taskInfo)
-{
-  UpdateVisitor uv(taskInfo);
-  mRootFrame->accept(uv);
-}
-
-void
 MultiBodySystem::addRigidBody(RigidBody* rigidBody)
 {
   if (!rigidBody)
@@ -289,6 +115,7 @@
     ++it;
   }
   mRigidBodies.push_back(rigidBody);
+  rigidBody->setParentMultiBodySystem(this);
 }
 
 void
@@ -296,8 +123,10 @@
 {
   RigidBodyList::iterator it = mRigidBodies.begin();
   while (it != mRigidBodies.end()) {
-    if ((*it) == rigidBody)
+    if ((*it) == rigidBody) {
       it = mRigidBodies.erase(it);
+      rigidBody->setParentMultiBodySystem(0);
+    }
     else
       ++it;
   }
@@ -311,8 +140,7 @@
   /// Already in the list, might be already attached to an other rigid body
   if (this == interact->getParent())
     return;
-  mInteracts.push_back(interact);
-  interact->setParent(this);
+  addModel(interact);
 }
 
 void
@@ -322,14 +150,7 @@
     return;
   if (this != interact->getParent())
     return;
-  interact->setParent(0);
-  InteractList::iterator it = mInteracts.begin();
-  while (it != mInteracts.end()) {
-    if ((*it) == interact)
-      it = mInteracts.erase(it);
-    else
-      ++it;
-  }
+  removeModel(interact);
 }
 
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/MultiBodySystem.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/MultiBodySystem.h	2005-12-23 19:59:05 UTC (rev 116)
+++ trunk/OpenFDM/src/OpenFDM/MultiBodySystem.h	2005-12-25 18:22:08 UTC (rev 117)
@@ -15,11 +15,12 @@
 #include "RigidBody.h"
 #include "Joint.h"
 #include "RootFrame.h"
+#include "ModelGroup.h"
 
 namespace OpenFDM {
 
 class MultiBodySystem :
-    public Model {
+    public ModelGroup {
 public:
   MultiBodySystem(RootFrame* rootFrame);
   virtual ~MultiBodySystem(void);
@@ -29,30 +30,8 @@
   /// Double dispatch helper for the multibody system visitor
 //   virtual void accept(ConstModelVisitor& visitor) const;
 
-  void traverse(ModelVisitor& visitor)
-  {
-    InteractList::iterator it = mInteracts.begin();
-    while (it != mInteracts.end()) {
-      (*it)->accept(visitor);
-      ++it;
-    }
-  }
-
-  /** Sets the state of this multibody system from the state vector state.
-   */
-  void setEvalState(const Vector& state);
-  /** Sets the state of this multibody system from the state vector state
-      and returns the time derivative in deriv.
-   */
-  void computeStateDeriv(real_type t, const Vector& state, Vector& deriv);
-  
-  virtual void setState(const Vector& state, unsigned offset);
-  virtual void getState(Vector& state, unsigned offset) const;
-  virtual void getStateDeriv(Vector& stateDeriv, unsigned offset);
-
-  virtual bool init(void);
+//   virtual bool init(void);
   virtual void output(const TaskInfo& taskInfo);
-  virtual void update(const TaskInfo& taskInfo);
 
   /// Add a RigidBody to that MultiBodySystem
   void addRigidBody(RigidBody* rigidBody);
@@ -69,10 +48,6 @@
   /// A list of RigidBody objects in this MultiBodySystem
   typedef std::vector<SharedPtr<RigidBody> > RigidBodyList;
   RigidBodyList mRigidBodies;
-
-  /// A list of Interact objects in this MultiBodySystem
-  typedef std::vector<SharedPtr<Interact> > InteractList;
-  InteractList mInteracts;
 };
 
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/RigidBody.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RigidBody.cpp	2005-12-23 19:59:05 UTC (rev 116)
+++ trunk/OpenFDM/src/OpenFDM/RigidBody.cpp	2005-12-25 18:22:08 UTC (rev 117)
@@ -14,6 +14,7 @@
 #include "Force.h"
 #include "Mass.h"
 #include "Joint.h"
+#include "MultiBodySystem.h"
 
 namespace OpenFDM {
 
@@ -78,23 +79,6 @@
   mArtInertia = SpatialInertia::zeros();
   mArtForce = Vector6::zeros();
 
-  // Now collect all articulated forces and all articulated inertias.
-  unsigned n = getNumMultiBodyModels();
-  for (unsigned i = 0; i < n; ++i) {
-    Joint* joint = getMultiBodyModel(i)->toJoint();
-    if (joint) {
-      Log(ArtBody, Debug) << "Processing joint \"" << joint->getName()
-                          << "\" to body \"" << getName() << "\"" << endl;
-      // Check if this is an articulated joint and if we are the parent.
-      // BTW: here the recursion happens ...
-      if (joint->isArticulatedJoint() && this == joint->getInboardGroup())
-        joint->contributeArticulation(mArtInertia, mArtForce);
-      else
-        // Return some contraint force for now...
-        ;
-    }
-  }
-
   // Collect all articulated forces and inertias
   InteractList::iterator it;
   for (it = mInteracts.begin(); it != mInteracts.end(); ++it)
@@ -111,27 +95,41 @@
   Log(ArtBody, Debug) << "Entry of computeAccel of \"" << getName()
                       << "\"" << endl;
 
-  unsigned n = getNumMultiBodyModels();
-  for (unsigned i = 0; i < n; ++i) {
-    Joint* joint = getMultiBodyModel(i)->toJoint();
-    if (joint) {
-      Log(ArtBody, Debug) << "Processing joint \"" << joint->getName()
-                          << "\" to body \"" << getName()
-                          << "\" for acceleration update" << endl;
-      // Check if this is an articulated joint and if we are the parent.
-      if (joint->isArticulatedJoint() && this == joint->getOutboardGroup())
-        joint->updateAccels();
-    }
-  }
-  
+  // Update all accelerations, Hmm, is a bit too croase that way ...
+  InteractList::iterator it;
+  for (it = mInteracts.begin(); it != mInteracts.end(); ++it)
+    (*it)->updateAccels();
+
   Log(ArtBody, Debug3) << "On exit of computeAccel of \"" << getName()
                        << "\"" << endl;
 }
 
 void
+RigidBody::setParentMultiBodySystem(MultiBodySystem* multiBodySystem)
+{
+  /// FIXME: rethink that ...
+  mParentMultiBodySystem = multiBodySystem;
+  if (!multiBodySystem)
+    return;
+  InteractList::iterator it;
+  for (it = mInteracts.begin(); it != mInteracts.end(); ++it) {
+    multiBodySystem->addInteract(*it);
+  }
+}
+
+MultiBodySystem*
+RigidBody::getParentMultiBodySystem(void)
+{
+  return mParentMultiBodySystem;
+}
+
+void
 RigidBody::addInteract(Interact* interact)
 {
   mInteracts.push_back(interact);
+  if (!mParentMultiBodySystem)
+    return;
+  mParentMultiBodySystem->addInteract(interact);
 }
 
 bool

Modified: trunk/OpenFDM/src/OpenFDM/RigidBody.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RigidBody.h	2005-12-23 19:59:05 UTC (rev 116)
+++ trunk/OpenFDM/src/OpenFDM/RigidBody.h	2005-12-25 18:22:08 UTC (rev 117)
@@ -20,6 +20,7 @@
 namespace OpenFDM {
 
 class Interact;
+class MultiBodySystem;
 
 // Rename to Body???
 class RigidBody :
@@ -111,6 +112,9 @@
   /// FIXME remove
   virtual bool addInteract2(Interact* child, unsigned parentNum = 0);
 
+  void setParentMultiBodySystem(MultiBodySystem* multiBodySystem);
+  MultiBodySystem* getParentMultiBodySystem(void);
+
 private:
   void addInteract(Interact* interact);
   bool removeInteract(Interact* interact);
@@ -134,6 +138,8 @@
 //   typedef std::vector<SharedPtr<Mass> > MassList;
 //   MassList mMasses;
 
+  WeakPtr<MultiBodySystem> mParentMultiBodySystem;
+
   friend class Interact;
 };
 

Modified: trunk/OpenFDM/src/OpenFDM/Sensor.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Sensor.h	2005-12-23 19:59:05 UTC (rev 116)
+++ trunk/OpenFDM/src/OpenFDM/Sensor.h	2005-12-25 18:22:08 UTC (rev 117)
@@ -30,9 +30,9 @@
   { }
 
   virtual void accept(Visitor& visitor)
-  {  visitor.apply(*this); }
+  { visitor.apply(*this); }
   virtual void accept(ConstVisitor& visitor) const
-  {  visitor.apply(*this); }
+  { visitor.apply(*this); }
 
   void output(const TaskInfo& taskInfo)
   {

Modified: trunk/OpenFDM/src/OpenFDM/System.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/System.cpp	2005-12-23 19:59:05 UTC (rev 116)
+++ trunk/OpenFDM/src/OpenFDM/System.cpp	2005-12-25 18:22:08 UTC (rev 117)
@@ -13,6 +13,8 @@
 #include "Newton.h"
 #include "System.h"
 
+#include "ModelVisitor.h"
+
 namespace OpenFDM {
 
 System::System(const std::string& name) :
@@ -68,8 +70,8 @@
   // Now that we know the basic sample time, build the job schedules
   Log(Schedule, Info) << "Basic time is: " << gcd << endl;
   if (100*gcd < minSampleTime)
-    Log(Schedule, Warning) << "Basic sample time is less than 100 times smaller "
-      "than the smalles submodels sample time" << endl;
+    Log(Schedule, Warning) << "Basic sample time is less than 100 times "
+      "smaller than the smallest submodels sample time" << endl;
 
   // We do not have any discrete sample time, just do continous scheduling
   if (gcd <= 0)
@@ -131,6 +133,37 @@
   return true;
 }
 
+class StateGetModelVisitor : public ModelVisitor {
+public:
+  StateGetModelVisitor(unsigned nStates) : mState(nStates), mOffset(0u)
+  {}
+  virtual void apply(Model& model)
+  {
+    OpenFDMAssert(mOffset + model.getNumContinousStates() <= mState.size());
+    model.getState(mState, mOffset);
+    mOffset += model.getNumContinousStates();
+  }
+
+  virtual void apply(ModelGroup& modelGroup)
+  {
+    traverse(modelGroup);
+  }
+  virtual void apply(Interact& interact)
+  {
+//     traverse(interact);
+  }
+  virtual void apply(MultiBodySystem& multiBodySystem)
+  {
+    traverse(multiBodySystem);
+  }
+
+  const Vector& getState(void) const
+  { return mState; }
+private:
+  Vector mState;
+  unsigned mOffset;
+};
+
 bool
 System::simulate(real_type tEnd)
 {

Modified: trunk/OpenFDM/src/OpenFDM/Vehicle.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Vehicle.cpp	2005-12-23 19:59:05 UTC (rev 116)
+++ trunk/OpenFDM/src/OpenFDM/Vehicle.cpp	2005-12-25 18:22:08 UTC (rev 117)
@@ -37,9 +37,9 @@
   mTopBody = new RigidBody("Topmost rigid body");
   mRootFrame->addChildFrame(mTopBody);
 
-  mFreeJoint = new FreeJoint(mEnvironment, "Mobile vehicle base (free joint)");
-  mRootFrame->addMultiBodyModel(mFreeJoint, 1);
-  mTopBody->addMultiBodyModel(mFreeJoint);
+  mFreeJoint = new FreeJoint(mEnvironment, "Mobile vehicle base");
+  mRootFrame->addInteract2(mFreeJoint, 1);
+  mTopBody->addInteract2(mFreeJoint);
 
   mSystem = new System("Top Vehicle System");
 



From frohlich at berlios.de  Sun Dec 25 20:46:24 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Sun, 25 Dec 2005 20:46:24 +0100
Subject: [OpenFDM-svn] r118 - in trunk/OpenFDM/src: JSBSim OpenFDM
Message-ID: <200512251946.jBPJkOuQ013272@sheep.berlios.de>

Author: frohlich
Date: 2005-12-25 20:46:11 +0100 (Sun, 25 Dec 2005)
New Revision: 118

Removed:
   trunk/OpenFDM/src/OpenFDM/MultiBodyModel.cpp
   trunk/OpenFDM/src/OpenFDM/MultiBodyModel.h
Modified:
   trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
   trunk/OpenFDM/src/OpenFDM/ConstVisitor.h
   trunk/OpenFDM/src/OpenFDM/Force.h
   trunk/OpenFDM/src/OpenFDM/Frame.cpp
   trunk/OpenFDM/src/OpenFDM/Frame.h
   trunk/OpenFDM/src/OpenFDM/Interact.cpp
   trunk/OpenFDM/src/OpenFDM/Interact.h
   trunk/OpenFDM/src/OpenFDM/Joint.h
   trunk/OpenFDM/src/OpenFDM/Makefile.am
   trunk/OpenFDM/src/OpenFDM/Model.cpp
   trunk/OpenFDM/src/OpenFDM/Model.h
   trunk/OpenFDM/src/OpenFDM/ModelGroup.h
   trunk/OpenFDM/src/OpenFDM/MultiBodySystem.cpp
   trunk/OpenFDM/src/OpenFDM/RigidBody.cpp
   trunk/OpenFDM/src/OpenFDM/RigidBody.h
   trunk/OpenFDM/src/OpenFDM/Sensor.h
   trunk/OpenFDM/src/OpenFDM/Visitor.h
   trunk/OpenFDM/src/OpenFDM/main.cpp
Log:
Make the acceleration sensor an interact for now.
Remove the MultiBodyModel class.


Modified: trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
===================================================================
--- trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2005-12-25 18:22:08 UTC (rev 117)
+++ trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2005-12-25 19:46:11 UTC (rev 118)
@@ -719,7 +719,7 @@
   Port* port = accelSensor->getOutputPort("nz");
   registerJSBExpression("accelerations/n-pilot-z-norm", port);
 //   epFrame->addInteract2(accelSensor);
-  mVehicle->getTopBody()->addMultiBodyModel(accelSensor);
+  mVehicle->getTopBody()->addInteract2(accelSensor);
   mVehicle->getTopBody()->addChildFrame(epFrame);
   addOutputModel(port, "Normalized load value", "/accelerations/nlf");
 

Modified: trunk/OpenFDM/src/OpenFDM/ConstVisitor.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/ConstVisitor.h	2005-12-25 18:22:08 UTC (rev 117)
+++ trunk/OpenFDM/src/OpenFDM/ConstVisitor.h	2005-12-25 19:46:11 UTC (rev 118)
@@ -9,11 +9,7 @@
 
 namespace OpenFDM {
 
-class Frame;
 class RigidBody;
-class Force;
-class Joint;
-class Interact;
 
 class ConstVisitor {
 public:
@@ -21,18 +17,10 @@
   {}
   virtual void apply(const Frame& frame)
   { traverse(frame); }
-  virtual void apply(const RigidBody& body)
-  { apply((const Frame&)body); }
-  virtual void apply(const MultiBodyModel& abNode)
-  { traverse(abNode); }
-  virtual void apply(const Joint& joint)
-  { apply((const MultiBodyModel&)joint); }
-  virtual void apply(const Interact& interact)
-  { }
+  virtual void apply(const RigidBody& rigidBody)
+  { apply((const Frame&)rigidBody); }
   inline void traverse(const Frame& frame)
   { frame.traverse(*this); }
-  inline void traverse(const MultiBodyModel& multiBodyModel)
-  { multiBodyModel.traverse(*this); }
 };
 
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/Force.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Force.h	2005-12-25 18:22:08 UTC (rev 117)
+++ trunk/OpenFDM/src/OpenFDM/Force.h	2005-12-25 19:46:11 UTC (rev 118)
@@ -11,8 +11,6 @@
 #include "Frame.h"
 #include "RigidBody.h"
 #include "Interact.h"
-#include "Visitor.h"
-#include "ConstVisitor.h"
 
 namespace OpenFDM {
 

Modified: trunk/OpenFDM/src/OpenFDM/Frame.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Frame.cpp	2005-12-25 18:22:08 UTC (rev 117)
+++ trunk/OpenFDM/src/OpenFDM/Frame.cpp	2005-12-25 19:46:11 UTC (rev 118)
@@ -52,22 +52,10 @@
 void
 Frame::traverse(Visitor& visitor)
 {
-  {
-    ChildFrameList::iterator it = mChildFrames.begin();
-    ChildFrameList::iterator iEnd = mChildFrames.end();
-    while (it != iEnd) {
-      (*it)->accept(visitor);
-      ++it;
-    }
-  }
-  abchild_iterator it = _children.begin();
-  abchild_iterator iEnd = _children.end();
+  ChildFrameList::iterator it = mChildFrames.begin();
+  ChildFrameList::iterator iEnd = mChildFrames.end();
   while (it != iEnd) {
-    // Make sure the nodes with two parents are only traversed once.
-    MultiBodyModel* child = (*it);
-    if (child->getParentFrame(0) == this)
-      child->accept(visitor);
-    
+    (*it)->accept(visitor);
     ++it;
   }
 }
@@ -81,22 +69,10 @@
 void
 Frame::traverse(ConstVisitor& visitor) const
 {
-  {
-    ChildFrameList::const_iterator it = mChildFrames.begin();
-    ChildFrameList::const_iterator iEnd = mChildFrames.end();
-    while (it != iEnd) {
-      (*it)->accept(visitor);
-      ++it;
-    }
-  }
-  const_abchild_iterator it = _children.begin();
-  const_abchild_iterator iEnd = _children.end();
+  ChildFrameList::const_iterator it = mChildFrames.begin();
+  ChildFrameList::const_iterator iEnd = mChildFrames.end();
   while (it != iEnd) {
-    // Make sure the nodes with two parents are only traversed once.
-    const MultiBodyModel* child = (*it);
-    if (child->getParentFrame(0) == this)
-      child->accept(visitor);
-    
+    (*it)->accept(visitor);
     ++it;
   }
 }

Modified: trunk/OpenFDM/src/OpenFDM/Frame.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Frame.h	2005-12-25 18:22:08 UTC (rev 117)
+++ trunk/OpenFDM/src/OpenFDM/Frame.h	2005-12-25 19:46:11 UTC (rev 118)
@@ -18,13 +18,15 @@
 #include "Quaternion.h"
 #include "Rotation.h"
 #include "Inertia.h"
-#include "MultiBodyModel.h"
 
 namespace OpenFDM {
 
 class RigidBody;
 class Interact;
 
+class Visitor;
+class ConstVisitor;
+
 /** 
 The \ref Frame class is the basic tool to model a tree of moving and
 accelerating coordinate frames.
@@ -98,68 +100,9 @@
 
 
 
+  //////////////////
 
-
-  /////////////////////////////////////////
-  typedef std::vector<SharedPtr<MultiBodyModel> > abchild_list;
-  typedef abchild_list::iterator           abchild_iterator;
-  typedef abchild_list::const_iterator     const_abchild_iterator;
-  abchild_list _children;
-
-  bool addMultiBodyModel(MultiBodyModel* child, unsigned parentNum = 0)
-  {
-    if (!child)
-      return false;
-    if (findMultiBodyModelIndex(child) < _children.size())
-      return false;
-    
-    bool couldSetParent = child->setParentFrame(this, parentNum);
-    if (couldSetParent)
-      _children.push_back(child);
-    return couldSetParent;
-  }
-  bool removeMultiBodyModel(const MultiBodyModel* child)
-  { return removeMultiBodyModel(findMultiBodyModelIndex(child)); }
-private:
-  bool removeMultiBodyModel(unsigned i)
-  {
-    if (_children.size() <= i)
-      return false;
-
-    abchild_iterator it = _children.begin() + i;
-    MultiBodyModel* child = *it;
-    bool couldRemoveParent = child->removeParentFrame(this);
-    if (couldRemoveParent)
-      _children.erase(it);
-    return couldRemoveParent;
-  }
-public:
-  unsigned findMultiBodyModelIndex(const MultiBodyModel* child) const
-  {
-    unsigned i;
-    for (i = 0; i < _children.size(); ++i) {
-      if (_children[i] == child)
-        return i;
-    }
-    return i;
-  }
-
-  MultiBodyModel* getMultiBodyModel(unsigned i)
-  {
-    if (_children.size() <= i)
-      return 0;
-    return _children[i];
-  }
-  const MultiBodyModel* getMultiBodyModel(unsigned i) const
-  {
-    if (_children.size() <= i)
-      return 0;
-    return _children[i];
-  }
-
-  unsigned getNumMultiBodyModels(void) const
-  { return _children.size(); }
-
+  /// FIXME should vanish
   virtual bool addInteract2(Interact* child, unsigned parentNum = 0)
   { return false; }
 

Modified: trunk/OpenFDM/src/OpenFDM/Interact.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Interact.cpp	2005-12-25 18:22:08 UTC (rev 117)
+++ trunk/OpenFDM/src/OpenFDM/Interact.cpp	2005-12-25 19:46:11 UTC (rev 118)
@@ -12,11 +12,8 @@
 #include "Matrix.h"
 #include "Quaternion.h"
 #include "Inertia.h"
-#include "Frame.h"
 #include "RigidBody.h"
 #include "ModelVisitor.h"
-#include "Visitor.h"
-#include "ConstVisitor.h"
 #include "Interact.h"
 
 namespace OpenFDM {
@@ -32,28 +29,6 @@
 }
 
 void
-Interact::accept(Visitor& visitor)
-{
-  visitor.apply(*this);
-}
-
-void
-Interact::traverse(Visitor& visitor)
-{
-}
-
-void
-Interact::accept(ConstVisitor& visitor) const
-{
-  visitor.apply(*this);
-}
-
-void
-Interact::traverse(ConstVisitor& visitor) const
-{
-}
-
-void
 Interact::accept(ModelVisitor& visitor)
 {
   visitor.apply(*this);

Modified: trunk/OpenFDM/src/OpenFDM/Interact.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Interact.h	2005-12-25 18:22:08 UTC (rev 117)
+++ trunk/OpenFDM/src/OpenFDM/Interact.h	2005-12-25 19:46:11 UTC (rev 118)
@@ -17,6 +17,7 @@
 #include "Inertia.h"
 #include "Frame.h"
 #include "RigidBody.h"
+#include "Model.h"
 
 namespace OpenFDM {
 
@@ -27,22 +28,10 @@
   virtual ~Interact(void);
 
   /// Double dispatch helper for the multibody system visitor
-  virtual void accept(Visitor& visitor);
-  /// Double dispatch helper for the multibody system visitor
-  virtual void traverse(Visitor& visitor);
-  /// Double dispatch helper for the multibody system visitor
-  virtual void accept(ConstVisitor& visitor) const;
-  /// Double dispatch helper for the multibody system visitor
-  virtual void traverse(ConstVisitor& visitor) const;
-
-
-  /// Double dispatch helper for the multibody system visitor
   virtual void accept(ModelVisitor& visitor);
   /// Double dispatch helper for the multibody system visitor
 //   virtual void accept(ConstModelVisitor& visitor) const;
 
-
-
   bool attachTo(RigidBody* rigidBody);
   bool detachFrom(RigidBody* rigidBody);
 

Modified: trunk/OpenFDM/src/OpenFDM/Joint.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Joint.h	2005-12-25 18:22:08 UTC (rev 117)
+++ trunk/OpenFDM/src/OpenFDM/Joint.h	2005-12-25 19:46:11 UTC (rev 118)
@@ -13,8 +13,6 @@
 #include "Quaternion.h"
 #include "Inertia.h"
 #include "Interact.h"
-#include "Visitor.h"
-#include "ConstVisitor.h"
 #include "Frame.h"
 #include "LogStream.h"
 
@@ -27,11 +25,6 @@
     : Interact(name, 2)
   {}
 
-  virtual void accept(Visitor& visitor)
-  { visitor.apply(*this); }
-  virtual void accept(ConstVisitor& visitor) const
-  { visitor.apply(*this); }
-
   virtual bool isArticulatedJoint(void) const
   {
     const Frame* parent0 = getParentFrame(0);

Modified: trunk/OpenFDM/src/OpenFDM/Makefile.am
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Makefile.am	2005-12-25 18:22:08 UTC (rev 117)
+++ trunk/OpenFDM/src/OpenFDM/Makefile.am	2005-12-25 19:46:11 UTC (rev 118)
@@ -85,7 +85,6 @@
   Model.h \
   ModelGroup.h \
   ModelVisitor.h \
-  MultiBodyModel.h \
   MultiBodySystem.h \
   Newton.h \
   Object.h \
@@ -176,7 +175,6 @@
   MinModel.cpp \
   Model.cpp \
   ModelGroup.cpp \
-  MultiBodyModel.cpp \
   MultiBodySystem.cpp \
   Newton.cpp \
   Object.cpp \

Modified: trunk/OpenFDM/src/OpenFDM/Model.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Model.cpp	2005-12-25 18:22:08 UTC (rev 117)
+++ trunk/OpenFDM/src/OpenFDM/Model.cpp	2005-12-25 19:46:11 UTC (rev 118)
@@ -16,7 +16,8 @@
   Object(name),
   mNumContinousStates(0l),
   mNumDiscreteStates(0l),
-  mDirectFeedThrough(false)
+  mDirectFeedThrough(false),
+  mMultiBodyAcceleration(false)
 {
   addProperty("numContinousStates",
               Property(this, &Model::getNumContinousStates));

Modified: trunk/OpenFDM/src/OpenFDM/Model.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Model.h	2005-12-25 18:22:08 UTC (rev 117)
+++ trunk/OpenFDM/src/OpenFDM/Model.h	2005-12-25 19:46:11 UTC (rev 118)
@@ -85,6 +85,9 @@
   bool getDirectFeedThrough(void) const
   { return mDirectFeedThrough; }
 
+  bool getMultiBodyAcceleration(void) const
+  { return mMultiBodyAcceleration; }
+
   bool addSampleTime(const SampleTime& sampleTime)
   { return mSampleTimeSet.addSampleTime(sampleTime); }
   bool removeSampleTime(const SampleTime& sampleTime)
@@ -122,6 +125,8 @@
   void setNumDiscreteStates(unsigned numDiscreteStates);
   void setDirectFeedThrough(bool directFeedThrough)
   { mDirectFeedThrough = directFeedThrough; }
+  void setMultiBodyAcceleration(bool multiBodyAcceleration)
+  { mMultiBodyAcceleration = multiBodyAcceleration; }
 
   /// Sets the number of input properties.
   void setNumInputPorts(unsigned num);
@@ -158,6 +163,9 @@
   unsigned mNumContinousStates;
   unsigned mNumDiscreteStates;
   bool mDirectFeedThrough;
+  // FIXME, at the moment used to state that this model must be scheduled
+  // past all joint interacts
+  bool mMultiBodyAcceleration;
   SampleTimeSet mSampleTimeSet;
   std::vector<SharedPtr<Port> > mInputPorts;
   std::vector<SharedPtr<Port> > mOutputPorts;

Modified: trunk/OpenFDM/src/OpenFDM/ModelGroup.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/ModelGroup.h	2005-12-25 18:22:08 UTC (rev 117)
+++ trunk/OpenFDM/src/OpenFDM/ModelGroup.h	2005-12-25 19:46:11 UTC (rev 118)
@@ -65,7 +65,8 @@
   using Model::setNumInputPorts;
   using Model::setNumOutputPorts;
 
-private:
+protected: // FIXME
+// private:
   typedef std::vector<SharedPtr<Model> > ModelList;
 
   /// Helper functions to sort the models according their dependencies

Deleted: trunk/OpenFDM/src/OpenFDM/MultiBodyModel.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/MultiBodyModel.cpp	2005-12-25 18:22:08 UTC (rev 117)
+++ trunk/OpenFDM/src/OpenFDM/MultiBodyModel.cpp	2005-12-25 19:46:11 UTC (rev 118)
@@ -1,55 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
- *
- */
-
-#include "Model.h"
-#include "MultiBodyModel.h"
-#include "Visitor.h"
-#include "ConstVisitor.h"
-
-namespace OpenFDM {
-
-MultiBodyModel::MultiBodyModel(const std::string& name) :
-  Model(name)
-{
-}
-
-MultiBodyModel::~MultiBodyModel(void)
-{
-}
-
-void
-MultiBodyModel::accept(Visitor& visitor)
-{
-  visitor.apply(*this);
-}
-
-void
-MultiBodyModel::traverse(Visitor& visitor)
-{
-}
-
-void
-MultiBodyModel::accept(ConstVisitor& visitor) const
-{
-  visitor.apply(*this);
-}
-
-void
-MultiBodyModel::traverse(ConstVisitor& visitor) const
-{
-}
-
-Joint*
-MultiBodyModel::toJoint(void)
-{
-  return 0;
-}
-
-const Joint*
-MultiBodyModel::toJoint(void) const
-{
-  return 0;
-}
-
-} // namespace OpenFDM

Deleted: trunk/OpenFDM/src/OpenFDM/MultiBodyModel.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/MultiBodyModel.h	2005-12-25 18:22:08 UTC (rev 117)
+++ trunk/OpenFDM/src/OpenFDM/MultiBodyModel.h	2005-12-25 19:46:11 UTC (rev 118)
@@ -1,104 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
- *
- */
-
-#ifndef OpenFDM_MultiBodyModel_H
-#define OpenFDM_MultiBodyModel_H
-
-#include "Object.h"
-#include "Model.h"
-#include "Vector.h"
-
-namespace OpenFDM {
-
-class Frame;
-class Joint;
-class Visitor;
-class ConstVisitor;
-
-// Should read StateNode or something like that.
-class MultiBodyModel :
-    public Model {
-public:
-  MultiBodyModel(const std::string& name);
-  virtual ~MultiBodyModel(void);
-
-  virtual void accept(Visitor& visitor);
-  virtual void traverse(Visitor& visitor);
-  virtual void accept(ConstVisitor& visitor) const;
-  virtual void traverse(ConstVisitor& visitor) const;
-
-  virtual Joint* toJoint(void);
-  virtual const Joint* toJoint(void) const;
-
-  // Set the parent node.
-  virtual bool setParentFrame(Frame* parent, unsigned idx) = 0;
-  virtual bool removeParentFrame(Frame* parent) = 0;
-  // Return the parent node.
-  virtual Frame* getParentFrame(unsigned idx) = 0;
-  virtual const Frame* getParentFrame(unsigned idx) const = 0;
-  virtual bool isParentFrame(const Frame* group) const = 0;
-
-protected:
-
-  template<unsigned numParents>
-  class NodeImplementation {
-  public:
-    bool setParentFrame(Frame* parent, unsigned idx)
-    {
-      if (numParents <= idx)
-        return false;
-      _parent[idx] = parent;
-      return true;
-    }
-    bool removeParentFrame(Frame* parent)
-    {
-      unsigned idx;
-      for (idx = 0; idx < numParents; ++idx) {
-        if (parent == _parent[idx]) {
-          _parent[idx] = 0;
-          return true;
-        }
-      }
-      return false;
-    }
-    // Return the parent node.
-    Frame* getParentFrame(unsigned idx)
-    { if (numParents <= idx) return 0; return _parent[idx]; }
-    const Frame* getParentFrame(unsigned idx) const
-    { if (numParents <= idx) return 0; return _parent[idx]; }
-    bool isParentFrame(const Frame* group) const
-    {
-      for (unsigned idx = 0; idx < numParents; ++idx) {
-        if (group == _parent[idx])
-          return true;
-      }
-      return false;
-    }
-    
-  private:
-    // The parent node.
-    // FIXME: May be we should store a list of all parents ???
-    WeakPtr<Frame> _parent[numParents];
-  };
-
-#define OpenFDM_NodeImplementation(nParents)            \
-public:                                                 \
-  virtual bool setParentFrame(Frame* parent, unsigned idx)   \
-  { return mNodeImpl.setParentFrame(parent, idx); }          \
-  virtual bool removeParentFrame(Frame* parent)              \
-  { return mNodeImpl.removeParentFrame(parent); }            \
-  virtual Frame* getParentFrame(unsigned idx)                \
-  { return mNodeImpl.getParentFrame(idx); }                  \
-  virtual const Frame* getParentFrame(unsigned idx) const    \
-  { return mNodeImpl.getParentFrame(idx); }                   \
-  virtual bool isParentFrame(const Frame* group) const       \
-  { return mNodeImpl.isParentFrame(group); }                 \
-private:                                                \
-  NodeImplementation<nParents> mNodeImpl
-
-};
-
-} // namespace OpenFDM
-
-#endif

Modified: trunk/OpenFDM/src/OpenFDM/MultiBodySystem.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/MultiBodySystem.cpp	2005-12-25 18:22:08 UTC (rev 117)
+++ trunk/OpenFDM/src/OpenFDM/MultiBodySystem.cpp	2005-12-25 19:46:11 UTC (rev 118)
@@ -70,25 +70,15 @@
 //   return ModelGroup::init();
 // }
 
-class OutputVisitor
-  : public Visitor {
-public:
-  OutputVisitor(const TaskInfo& taskInfo) : mTaskInfo(taskInfo)
-  { }
-  virtual void apply(MultiBodyModel& abNode)
-  {
-    abNode.output(mTaskInfo);
-  }
-  virtual void apply(Interact& abNode)
-  { }
-private:
-  const TaskInfo& mTaskInfo;
-};
-
 void
 MultiBodySystem::output(const TaskInfo& taskInfo)
 {
-  ModelGroup::output(taskInfo);
+  // Hmm, just works now ... FIXME
+  ModelList::iterator it;
+  for (it = mModels.begin(); it != mModels.end(); ++it) {
+    if (!(*it)->getMultiBodyAcceleration())
+      (*it)->output(taskInfo);
+  }
 
   // Compute forward dynamics, that is the articulated forces and inertia.
   ForwardDynamicsVisitor fwdVisitor;
@@ -98,9 +88,11 @@
   AccelerationPropagationVisitor apVisitor;
   mRootFrame->accept(apVisitor);
 
-  // At the moment only that acceleration sensor ...
-  OutputVisitor ov(taskInfo);
-  mRootFrame->accept(ov);
+  // Hmm, just works now ... FIXME
+  for (it = mModels.begin(); it != mModels.end(); ++it) {
+    if ((*it)->getMultiBodyAcceleration())
+      (*it)->output(taskInfo);
+  }
 }
 
 void

Modified: trunk/OpenFDM/src/OpenFDM/RigidBody.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RigidBody.cpp	2005-12-25 18:22:08 UTC (rev 117)
+++ trunk/OpenFDM/src/OpenFDM/RigidBody.cpp	2005-12-25 19:46:11 UTC (rev 118)
@@ -10,11 +10,13 @@
 #include "Quaternion.h"
 #include "Inertia.h"
 #include "Frame.h"
-#include "RigidBody.h"
 #include "Force.h"
 #include "Mass.h"
 #include "Joint.h"
 #include "MultiBodySystem.h"
+#include "Visitor.h"
+#include "ConstVisitor.h"
+#include "RigidBody.h"
 
 namespace OpenFDM {
 
@@ -52,24 +54,6 @@
 }
 
 void
-RigidBody::traverse(Visitor& visitor)
-{
-  InteractList::iterator it;
-  for (it = mInteracts.begin(); it != mInteracts.end(); ++it)
-    (*it)->accept(visitor);
-  Frame::traverse(visitor);
-}
-
-void
-RigidBody::traverse(ConstVisitor& visitor) const
-{
-  InteractList::const_iterator it;
-  for (it = mInteracts.begin(); it != mInteracts.end(); ++it)
-    (*it)->accept(visitor);
-  Frame::traverse(visitor);
-}
-
-void
 RigidBody::computeArtValues(void)
 {
   Log(ArtBody, Debug) << "Entry of computeArtValues of \"" << getName()

Modified: trunk/OpenFDM/src/OpenFDM/RigidBody.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RigidBody.h	2005-12-25 18:22:08 UTC (rev 117)
+++ trunk/OpenFDM/src/OpenFDM/RigidBody.h	2005-12-25 19:46:11 UTC (rev 118)
@@ -42,8 +42,6 @@
 
   virtual void accept(Visitor& visitor);
   virtual void accept(ConstVisitor& visitor) const;
-  virtual void traverse(Visitor& visitor);
-  virtual void traverse(ConstVisitor& visitor) const;
 
 
 // protected:

Modified: trunk/OpenFDM/src/OpenFDM/Sensor.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Sensor.h	2005-12-25 18:22:08 UTC (rev 117)
+++ trunk/OpenFDM/src/OpenFDM/Sensor.h	2005-12-25 19:46:11 UTC (rev 118)
@@ -10,30 +10,24 @@
 #include "Vector.h"
 #include "Frame.h"
 #include "RigidBody.h"
-#include "Visitor.h"
-#include "ConstVisitor.h"
-#include "MultiBodyModel.h"
+#include "Interact.h"
 
 namespace OpenFDM {
 
 class Sensor
-  : public MultiBodyModel {
+  : public Interact {
 public:
   Sensor(const std::string& name) :
-    MultiBodyModel(name)
+    Interact(name, 1)
   {
     mAccel.resize(6, 1);
     setNumOutputPorts(1);
+    setMultiBodyAcceleration(true);
     setOutputPort(0, "nz", this, &Sensor::getNZ);
   }
   virtual ~Sensor(void)
   { }
 
-  virtual void accept(Visitor& visitor)
-  { visitor.apply(*this); }
-  virtual void accept(ConstVisitor& visitor) const
-  { visitor.apply(*this); }
-
   void output(const TaskInfo& taskInfo)
   {
     if (!nonZeroIntersection(taskInfo.getSampleTimeSet(), getSampleTimeSet()))
@@ -51,9 +45,10 @@
   const real_type& getNZ(void) const
   { return mNz; }
 
-private:
-  OpenFDM_NodeImplementation(1);
+  virtual void interactWith(RigidBody*)
+  {}
 
+private:
   Matrix mAccel;
   real_type mNz;
 };

Modified: trunk/OpenFDM/src/OpenFDM/Visitor.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Visitor.h	2005-12-25 18:22:08 UTC (rev 117)
+++ trunk/OpenFDM/src/OpenFDM/Visitor.h	2005-12-25 19:46:11 UTC (rev 118)
@@ -10,9 +10,6 @@
 namespace OpenFDM {
 
 class RigidBody;
-class Joint;
-class MultiBodyModel;
-class Interact;
 
 class Visitor {
 public:
@@ -20,18 +17,10 @@
   {}
   virtual void apply(Frame& frame)
   { traverse(frame); }
-  virtual void apply(RigidBody& body)
-  { apply((Frame&)body); }
-  virtual void apply(MultiBodyModel& abNode)
-  { traverse(abNode); }
-  virtual void apply(Joint& joint)
-  { apply((MultiBodyModel&)joint); }
-  virtual void apply(Interact& interact)
-  { }
+  virtual void apply(RigidBody& rigidBody)
+  { apply((Frame&)rigidBody); }
   inline void traverse(Frame& frame)
   { frame.traverse(*this); }
-  inline void traverse(MultiBodyModel& multiBodyModel)
-  { multiBodyModel.traverse(*this); }
 };
 
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/main.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/main.cpp	2005-12-25 18:22:08 UTC (rev 117)
+++ trunk/OpenFDM/src/OpenFDM/main.cpp	2005-12-25 19:46:11 UTC (rev 118)
@@ -40,6 +40,8 @@
 #include <OpenFDM/LogStream.h>
 #include <OpenFDM/Variant.h>
 #include <OpenFDM/Property.h>
+#include <OpenFDM/Visitor.h>
+#include <OpenFDM/ConstVisitor.h>
 
 // Model includes
 #include <OpenFDM/Model.h>
@@ -557,14 +559,6 @@
 public:
   StatePrintVisitor(void) : _indent(3) {}
   virtual ~StatePrintVisitor(void) {}
-  virtual void apply(const MultiBodyModel& node)
-  {
-    Vector v(node.getNumContinousStates());
-    node.getState(v, 0);
-    std::cout << std::setw(_indent) << ""
-              << "\"" << node.getName() << "\", "
-              << trans(v) << endl;
-  }
   virtual void apply(const Frame& group)
   {
     std::cout << std::setw(_indent) << ""



From frohlich at berlios.de  Sun Dec 25 20:46:52 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Sun, 25 Dec 2005 20:46:52 +0100
Subject: [OpenFDM-svn] r119 - trunk/flightgear
Message-ID: <200512251946.jBPJkqD2013291@sheep.berlios.de>

Author: frohlich
Date: 2005-12-25 20:46:50 +0100 (Sun, 25 Dec 2005)
New Revision: 119

Modified:
   trunk/flightgear/FGOpenFDM.cpp
Log:
Remove now obsolete visitor.


Modified: trunk/flightgear/FGOpenFDM.cpp
===================================================================
--- trunk/flightgear/FGOpenFDM.cpp	2005-12-25 19:46:11 UTC (rev 118)
+++ trunk/flightgear/FGOpenFDM.cpp	2005-12-25 19:46:50 UTC (rev 119)
@@ -153,60 +153,12 @@
   SGPropertyNode_ptr mPropertyNode;
 };
 
-
-class StatePrintVisitor
-  : public ConstVisitor {
-public:
-  StatePrintVisitor(void) : _indent(3) {}
-  virtual ~StatePrintVisitor(void) {}
-  virtual void apply(const MultiBodyModel& node)
-  {
-//     if (node.getName() != "Aerodynamic force")
-//       return;
-//     const AeroForce* aeroForce = (const AeroForce*)&node;
-//     std::cout << "Alpha " << convertTo(uDegree, aeroForce->getAlpha())
-//               << ", Beta " << convertTo(uDegree, aeroForce->getBeta())
-// //               << ", Mach " << aeroForce->getMachNumber()
-//               << ", speed " << trans(aeroForce->getAirSpeed())
-//               << std::endl;
-
-    Vector v(node.getNumContinousStates());
-    node.getState(v, 0);
-    std::cout << std::setw(_indent) << ""
-              << "\"" << node.getName() << "\", "
-              << trans(v) << endl;
-  }
-  virtual void apply(const Frame& group)
-  {
-    std::cout << std::setw(_indent) << ""
-              << "Traversing \""
-              << group.getName() << "\" ("
-              << trans(group.getRelVel().getLinear())
-//               << ", "
-//               << trans(group.getSpVel().getLinear())
-//               << ", "
-//               << trans(group.getRelAccel().getLinear())
-//               << ", "
-//               << trans(group.getSpAccel().getLinear())
-              << "), "
-              << endl;
-    _indent += 3;
-    traverse(group);
-    _indent -= 3;
-  }
-private:
-  unsigned _indent;
-};
-
 void printVehicle(Vehicle* vehicle)
 {
   cout << "T = " << vehicle->getTime()
        << ", Pos: " << vehicle->getGeodPosition()
 //        << ", Or: " << vehicle->getGeodOrientation()
        << endl;
-
-  StatePrintVisitor spv;
-  vehicle->getTopBody()->getParentFrame()->accept(spv);
 }
 
 



From frohlich at berlios.de  Mon Dec 26 09:08:44 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Mon, 26 Dec 2005 09:08:44 +0100
Subject: [OpenFDM-svn] r120 - in trunk/OpenFDM/src: JSBSim OpenFDM
Message-ID: <200512260808.jBQ88iwo028943@sheep.berlios.de>

Author: frohlich
Date: 2005-12-26 09:08:34 +0100 (Mon, 26 Dec 2005)
New Revision: 120

Modified:
   trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
   trunk/OpenFDM/src/OpenFDM/Frame.cpp
   trunk/OpenFDM/src/OpenFDM/Frame.h
   trunk/OpenFDM/src/OpenFDM/FreeJoint.cpp
   trunk/OpenFDM/src/OpenFDM/FreeJoint.h
   trunk/OpenFDM/src/OpenFDM/Interact.h
   trunk/OpenFDM/src/OpenFDM/Joint.h
   trunk/OpenFDM/src/OpenFDM/MultiBodySystem.cpp
   trunk/OpenFDM/src/OpenFDM/MultiBodySystem.h
   trunk/OpenFDM/src/OpenFDM/PrismaticJoint.cpp
   trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp
   trunk/OpenFDM/src/OpenFDM/RigidBody.cpp
   trunk/OpenFDM/src/OpenFDM/RigidBody.h
   trunk/OpenFDM/src/OpenFDM/Vehicle.cpp
   trunk/OpenFDM/src/OpenFDM/Vehicle.h
Log:
No longer derive RigidBody from Frame


Modified: trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
===================================================================
--- trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2005-12-25 19:46:50 UTC (rev 119)
+++ trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2005-12-26 08:08:34 UTC (rev 120)
@@ -720,7 +720,7 @@
   registerJSBExpression("accelerations/n-pilot-z-norm", port);
 //   epFrame->addInteract2(accelSensor);
   mVehicle->getTopBody()->addInteract2(accelSensor);
-  mVehicle->getTopBody()->addChildFrame(epFrame);
+  mVehicle->getTopBody()->getFrame()->addChildFrame(epFrame);
   addOutputModel(port, "Normalized load value", "/accelerations/nlf");
 
   // Set the position of the aerodynamic force frame.
@@ -739,7 +739,7 @@
   RigidBody* wheel = new RigidBody(name + " Wheel");
   InertiaMatrix wheelInertia(10, 0, 0, 100, 0, 10);
   wheel->addInteract2(new Mass(SpatialInertia(wheelInertia, 50)));
-  parent->addChildFrame(wheel);
+  parent->getFrame()->addChildFrame(wheel->getFrame());
   mVehicle->getMultiBodySystem()->addRigidBody(wheel);
   
   RevoluteJoint* wj = new RevoluteJoint(name + " Wheel Joint");
@@ -928,7 +928,7 @@
       // This is the movable part of the strut, doing the compression
       RigidBody* arm = new RigidBody(name + " Arm");
       mVehicle->getMultiBodySystem()->addRigidBody(arm);
-      mVehicle->getTopBody()->addChildFrame(arm);
+      mVehicle->getTopBody()->getFrame()->addChildFrame(arm->getFrame());
       arm->addInteract2(new Mass(inertiaFrom(Vector3(-1, 0, 0), SpatialInertia(200))));
 
       // Connect that with a revolute joint to the main body
@@ -1003,7 +1003,7 @@
         // A new part modelling the steering
         RigidBody* steer = new RigidBody(name + " Steer");
         mVehicle->getMultiBodySystem()->addRigidBody(steer);
-        strutParent->addChildFrame(steer);
+        strutParent->getFrame()->addChildFrame(steer->getFrame());
 
         // connect that via a revolute joint to the toplevel body.
         // Note the 0.05m below, most steering wheels have some kind of
@@ -1046,7 +1046,7 @@
       // Now the compressible part of the strut
       RigidBody* arm = new RigidBody(name + " Strut");
       mVehicle->getMultiBodySystem()->addRigidBody(arm);
-      strutParent->addChildFrame(arm);
+      strutParent->getFrame()->addChildFrame(arm->getFrame());
       arm->addInteract2(new Mass(inertiaFrom(Vector3(0, 0, 1), SpatialInertia(200))));
 
       // This time it is a prismatic joint

Modified: trunk/OpenFDM/src/OpenFDM/Frame.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Frame.cpp	2005-12-25 19:46:50 UTC (rev 119)
+++ trunk/OpenFDM/src/OpenFDM/Frame.cpp	2005-12-26 08:08:34 UTC (rev 120)
@@ -77,18 +77,6 @@
   }
 }
 
-RigidBody*
-Frame::toRigidBody(void)
-{
-  return 0;
-}
-
-const RigidBody*
-Frame::toRigidBody(void) const
-{
-  return 0;
-}
-
 bool
 Frame::addChildFrame(Frame* child)
 {

Modified: trunk/OpenFDM/src/OpenFDM/Frame.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Frame.h	2005-12-25 19:46:50 UTC (rev 119)
+++ trunk/OpenFDM/src/OpenFDM/Frame.h	2005-12-26 08:08:34 UTC (rev 120)
@@ -22,6 +22,7 @@
 namespace OpenFDM {
 
 class RigidBody;
+class Joint;
 class Interact;
 
 class Visitor;
@@ -65,11 +66,6 @@
   /// Double dispatch helper for the multibody system visitor
   virtual void traverse(ConstVisitor& visitor) const;
 
-  /// Cast to a RigidBody Object if it is one.
-  virtual RigidBody* toRigidBody(void);
-  /// Cast to a const RigidBody Object if it is one.
-  virtual const RigidBody* toRigidBody(void) const;
-
   /// Return the parent frame.
   Frame* getParentFrame(void)
   { return mParentFrame; }
@@ -496,6 +492,7 @@
   { mDisableSpAccel = true; }
   void enableAccel(void)
   { mDisableSpAccel = false; }
+  friend class Joint; /// FIXME
 
   void computePositionDep(void) const;
   void computeVelocityDep(void) const;

Modified: trunk/OpenFDM/src/OpenFDM/FreeJoint.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/FreeJoint.cpp	2005-12-25 19:46:50 UTC (rev 119)
+++ trunk/OpenFDM/src/OpenFDM/FreeJoint.cpp	2005-12-26 08:08:34 UTC (rev 120)
@@ -39,27 +39,29 @@
 FreeJoint::computeRelAccel(const SpatialInertia& artI,
                            const Vector6& artF)
 {
-  RigidBody* topBody = getOutboardGroup()->toRigidBody();
+  RigidBody* topBody = getOutboardBody();
   if (!topBody)
     return Vector6::zeros();
 
+  FreeFrame* frame = topBody->getFreeFrame();
+
   Log(ArtBody, Debug) << "FreeJoint::computeRelAccel():\n" << artI << endl;
 
   // Assumption: body is small compared to the distance to the planets
   // center of mass. That means gravity could be considered equal for the whole
   // vehicle.
   // See Featherstone, Orin: Equations and Algorithms
-  Vector3 ga = mEnvironment->getGravity()->gravityAccel(topBody->getRefPosition());
-  Vector6 grav = Vector6(Vector3::zeros(), topBody->rotFromRef(ga));
+  Vector3 ga = mEnvironment->getGravity()->gravityAccel(frame->getRefPosition());
+  Vector6 grav = Vector6(Vector3::zeros(), frame->rotFromRef(ga));
 
   Log(ArtBody, Debug) << "grav = " << trans(grav) << endl;
   Log(ArtBody, Debug) << "solve = " << trans(solve(artI, artF)) << endl;
-  Log(ArtBody, Debug) << "parent spatial accel = " << trans(topBody->getParentSpAccel()) << endl;
+  Log(ArtBody, Debug) << "parent spatial accel = " << trans(frame->getParentSpAccel()) << endl;
   Log(ArtBody, Debug) << "Hdot = " << trans(getHdot()) << endl;
   
 
   Vector6 accel = grav - solve(artI, artF)
-    - topBody->getParentSpAccel() - getHdot();
+    - frame->getParentSpAccel() - getHdot();
   return accel;
 }
 
@@ -76,21 +78,22 @@
 void
 FreeJoint::getState(Vector& state, unsigned offset) const
 {
-  const RigidBody* topBody = getOutboardGroup()->toRigidBody();
+  const RigidBody* topBody = getParentRigidBody(0);
   if (!topBody)
     return;
-  Quaternion q = topBody->getOrientation();
+  const Frame* frame = topBody->getFrame();
+  Quaternion q = frame->getOrientation();
   state(offset+1) = q(1);
   state(offset+2) = q(2);
   state(offset+3) = q(3);
   state(offset+4) = q(4);
   
-  Vector3 p = topBody->getPosition();
+  Vector3 p = frame->getPosition();
   state(offset+5) = p(1);
   state(offset+6) = p(2);
   state(offset+7) = p(3);
   
-  Vector6 v = topBody->getRelVel();
+  Vector6 v = frame->getRelVel();
   state(offset+8) = v(1);
   state(offset+9) = v(2);
   state(offset+10) = v(3);
@@ -102,12 +105,13 @@
 void
 FreeJoint::getStateDeriv(Vector& state, unsigned offset)
 {
-  RigidBody* topBody = getOutboardGroup()->toRigidBody();
+  RigidBody* topBody = getOutboardBody();
   if (!topBody)
     return;
-  Quaternion q = topBody->getOrientation();
-  Vector3 angVel = topBody->getRelVel().getAngular();
-  Vector3 vel = topBody->rotToParent(topBody->getRelVel().getLinear());
+  FreeFrame* frame = topBody->getFreeFrame();
+  Quaternion q = frame->getOrientation();
+  Vector3 angVel = frame->getRelVel().getAngular();
+  Vector3 vel = frame->rotToParent(frame->getRelVel().getLinear());
 
   // Compute the derivative term originating from the angular velocity.
   // Correction term to keep the quaternion normalized.
@@ -123,7 +127,7 @@
   state(offset+6) = vel(2);
   state(offset+7) = vel(3);
   
-  Vector6 accel = topBody->getRelAccel();
+  Vector6 accel = frame->getRelAccel();
   state(offset+8)  = accel(1);
   state(offset+9)  = accel(2);
   state(offset+10) = accel(3);

Modified: trunk/OpenFDM/src/OpenFDM/FreeJoint.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/FreeJoint.h	2005-12-25 19:46:50 UTC (rev 119)
+++ trunk/OpenFDM/src/OpenFDM/FreeJoint.h	2005-12-26 08:08:34 UTC (rev 120)
@@ -35,6 +35,8 @@
   { return getParentFrame(0); }
   virtual const Frame* getOutboardGroup(void) const
   { return getParentFrame(0); }
+  virtual RigidBody* getOutboardBody(void)
+  { return getParentRigidBody(0); }
 
   /** Set the relative velocity.
    */
@@ -44,7 +46,7 @@
    */
   void setLinearRelVel(const Vector3& vel)
   {
-    RigidBody* topBody = getOutboardGroup()->toRigidBody();
+    FreeFrame* topBody = getOutboardBody()->getFreeFrame();
     if (!topBody)
       return;
     topBody->setLinearRelVel(vel);
@@ -53,7 +55,7 @@
    */
   void setAngularRelVel(const Vector3& vel)
   {
-    RigidBody* topBody = getOutboardGroup()->toRigidBody();
+    FreeFrame* topBody = getOutboardBody()->getFreeFrame();
     if (!topBody)
       return;
     topBody->setAngularRelVel(vel);
@@ -63,7 +65,7 @@
    */
   void setRefPosition(const Vector3& p)
   {
-    RigidBody* topBody = getOutboardGroup()->toRigidBody();
+    FreeFrame* topBody = getOutboardBody()->getFreeFrame();
     if (!topBody)
       return;
     topBody->setRefPosition(p);
@@ -72,7 +74,7 @@
    */
   void setRefOrientation(const Quaternion& o)
   {
-    RigidBody* topBody = getOutboardGroup()->toRigidBody();
+    FreeFrame* topBody = getOutboardBody()->getFreeFrame();
     if (!topBody)
       return;
     topBody->setRefOrientation(o);

Modified: trunk/OpenFDM/src/OpenFDM/Interact.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Interact.h	2005-12-25 19:46:50 UTC (rev 119)
+++ trunk/OpenFDM/src/OpenFDM/Interact.h	2005-12-26 08:08:34 UTC (rev 120)
@@ -35,10 +35,23 @@
   bool attachTo(RigidBody* rigidBody);
   bool detachFrom(RigidBody* rigidBody);
 
+  const RigidBody* getParentRigidBody(unsigned id = 0) const
+  {
+    OpenFDMAssert(id < mParents.size());
+    return mParents[id];
+  }
+  RigidBody* getParentRigidBody(unsigned id = 0)
+  {
+    OpenFDMAssert(id < mParents.size());
+    return mParents[id];
+  }
+
   virtual void interactWith(RigidBody* rigidBody) = 0;
 
+
+
   /// FIXME: hmm
-  virtual bool updateAccels() { return true; }
+  virtual bool updateAccels(RigidBody*) { return true; }
 
   /// FIXME remove
   const Frame* getParentFrame(unsigned id = 0) const

Modified: trunk/OpenFDM/src/OpenFDM/Joint.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Joint.h	2005-12-25 19:46:50 UTC (rev 119)
+++ trunk/OpenFDM/src/OpenFDM/Joint.h	2005-12-26 08:08:34 UTC (rev 120)
@@ -96,6 +96,20 @@
       return parent0;
     return 0;
   }
+  virtual RigidBody* getOutboardBody(void)
+  {
+    Frame* parent0 = getParentFrame(0);
+    if (!parent0)
+      return 0;
+    Frame* parent1 = getParentFrame(1);
+    if (!parent1)
+      return 0;
+    if (parent1->isParentFrame(parent0))
+      return getParentRigidBody(1);
+    if (parent0->isParentFrame(parent1))
+      return getParentRigidBody(0);
+    return 0;
+  }
 
   virtual void interactWith(RigidBody* rigidBody)
   {
@@ -106,6 +120,7 @@
     if (rigidBody->getFrame() != getInboardGroup())
       return;
 
+    getOutboardBody()->computeArtValues();
     SpatialInertia artI = SpatialInertia::zeros();
     Vector6 artF = Vector6::zeros();
     contributeArticulation(artI, artF);
@@ -115,7 +130,8 @@
 
   bool contributeArticulation(SpatialInertia& artI, Vector6& artF)
   {
-    RigidBody* outboardBody = getOutboardGroup()->toRigidBody();
+    Frame* frame = getOutboardGroup();
+    RigidBody* outboardBody = getOutboardBody();
     if (!outboardBody)
       return false;
 
@@ -141,8 +157,8 @@
                          << "\nInertia\n" << I << endl;
 
     // Contribute the transformed values to the parent.
-    artI += outboardBody->inertiaToParent(I);
-    artF += outboardBody->forceToParent(F);
+    artI += frame->inertiaToParent(I);
+    artF += frame->forceToParent(F);
 
     return true;
   }
@@ -156,23 +172,26 @@
   // FIXME: just for compatibility
   Vector6 getHdot()
   {
-    RigidBody* outboardBody = getOutboardGroup()->toRigidBody();
-    if (!outboardBody)
-      return Vector6::zeros();
-    return outboardBody->getHdot();
+    Frame* frame = getOutboardGroup();
+    return frame->getHdot();
   }
 
   //???
-  bool updateAccels(void)
+  bool updateAccels(RigidBody* rigidBody)
   {
-    RigidBody* outboardBody = getOutboardGroup()->toRigidBody();
+    RigidBody* outboardBody = getOutboardBody();
     if (!outboardBody)
       return false;
 
+    if (outboardBody == rigidBody)
+      return false;
+
     // Set the local acceleration
     setOutboardRelAccel(computeRelAccel(outboardBody->getArtInertia(),
                                         outboardBody->getArtForce()));
     
+    outboardBody->computeAccel();
+
     return true;
   }
 
@@ -184,51 +203,56 @@
   void setOutboardState(const Vector3& pos, const Quaternion& orient,
                         const Vector6& vel)
   {
-    RigidBody* outboardBody = getOutboardGroup()->toRigidBody();
-    if (!outboardBody)
+    Frame* frame0 = getOutboardGroup();
+    FreeFrame* frame = dynamic_cast<FreeFrame*>(frame0);
+    if (!frame)
       return;
 
-    outboardBody->disableAccel();
-    outboardBody->setPosition(pos);
-    outboardBody->setOrientation(orient);
-    outboardBody->setRelVel(vel);
+    frame->disableAccel();
+    frame->setPosition(pos);
+    frame->setOrientation(orient);
+    frame->setRelVel(vel);
   }
 
   void setOutboardPosition(const Vector3& pos)
   {
-    RigidBody* outboardBody = getOutboardGroup()->toRigidBody();
-    if (!outboardBody)
+    Frame* frame0 = getOutboardGroup();
+    FreeFrame* frame = dynamic_cast<FreeFrame*>(frame0);
+    if (!frame)
       return;
 
-    outboardBody->disableAccel();
-    outboardBody->setPosition(pos);
+    frame->disableAccel();
+    frame->setPosition(pos);
   }
   void setOutboardOrientation(const Quaternion& orient)
   {
-    RigidBody* outboardBody = getOutboardGroup()->toRigidBody();
-    if (!outboardBody)
+    Frame* frame0 = getOutboardGroup();
+    FreeFrame* frame = dynamic_cast<FreeFrame*>(frame0);
+    if (!frame)
       return;
 
-    outboardBody->disableAccel();
-    outboardBody->setOrientation(orient);
+    frame->disableAccel();
+    frame->setOrientation(orient);
   }
   void setOutboardRelVel(const Vector6& vel)
   {
-    RigidBody* outboardBody = getOutboardGroup()->toRigidBody();
-    if (!outboardBody)
+    Frame* frame0 = getOutboardGroup();
+    FreeFrame* frame = dynamic_cast<FreeFrame*>(frame0);
+    if (!frame)
       return;
 
-    outboardBody->disableAccel();
-    outboardBody->setRelVel(vel);
+    frame->disableAccel();
+    frame->setRelVel(vel);
   }
   void setOutboardRelAccel(const Vector6& accel)
   {
-    RigidBody* outboardBody = getOutboardGroup()->toRigidBody();
-    if (!outboardBody)
+    Frame* frame0 = getOutboardGroup();
+    FreeFrame* frame = dynamic_cast<FreeFrame*>(frame0);
+    if (!frame)
       return;
 
-    outboardBody->enableAccel();
-    outboardBody->setRelAccel(accel);
+    frame->enableAccel();
+    frame->setRelAccel(accel);
   }
 };
 

Modified: trunk/OpenFDM/src/OpenFDM/MultiBodySystem.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/MultiBodySystem.cpp	2005-12-25 19:46:50 UTC (rev 119)
+++ trunk/OpenFDM/src/OpenFDM/MultiBodySystem.cpp	2005-12-26 08:08:34 UTC (rev 120)
@@ -18,30 +18,6 @@
 
 namespace OpenFDM {
 
-class ForwardDynamicsVisitor
-  : public Visitor {
-public:
-  virtual void apply(RigidBody& body)
-  {
-    // Note the order. First compute the articulated values on each child.
-    traverse(body);
-    // Past that, do it on this current rigid body.
-    body.computeArtValues();
-  }
-};
-
-class AccelerationPropagationVisitor
-  : public Visitor {
-public:
-  virtual void apply(RigidBody& body)
-  {
-    body.computeAccel();
-    // Note the order. First compute the acceleration and than traverse
-    // to the children.
-    traverse(body);
-  }
-};
-
 MultiBodySystem::MultiBodySystem(RootFrame* rootFrame) :
   ModelGroup("multibodymodel"),
   mRootFrame(rootFrame)
@@ -81,12 +57,9 @@
   }
 
   // Compute forward dynamics, that is the articulated forces and inertia.
-  ForwardDynamicsVisitor fwdVisitor;
-  mRootFrame->accept(fwdVisitor);
-
+  mFreeJoint->getOutboardBody()->computeArtValues();
   // Then compute the articulated inertias and forces.
-  AccelerationPropagationVisitor apVisitor;
-  mRootFrame->accept(apVisitor);
+  mFreeJoint->updateAccels(0);
 
   // Hmm, just works now ... FIXME
   for (it = mModels.begin(); it != mModels.end(); ++it) {
@@ -132,6 +105,10 @@
   /// Already in the list, might be already attached to an other rigid body
   if (this == interact->getParent())
     return;
+  // FIXME incorporate that somehow into the depencencies ...
+  if (dynamic_cast<FreeJoint*>(interact)) {
+    mFreeJoint = dynamic_cast<FreeJoint*>(interact);
+  }
   addModel(interact);
 }
 

Modified: trunk/OpenFDM/src/OpenFDM/MultiBodySystem.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/MultiBodySystem.h	2005-12-25 19:46:50 UTC (rev 119)
+++ trunk/OpenFDM/src/OpenFDM/MultiBodySystem.h	2005-12-26 08:08:34 UTC (rev 120)
@@ -14,6 +14,7 @@
 #include "Frame.h"
 #include "RigidBody.h"
 #include "Joint.h"
+#include "FreeJoint.h"
 #include "RootFrame.h"
 #include "ModelGroup.h"
 
@@ -43,8 +44,12 @@
 private:
   /// At the moment each MultiBodySystem has its own root frame,
   /// In the future just store the root joint and reference a common root frame
+  /// move that to environment
   SharedPtr<RootFrame> mRootFrame;
 
+  /// That is the root for now ...
+  SharedPtr<FreeJoint> mFreeJoint;
+
   /// A list of RigidBody objects in this MultiBodySystem
   typedef std::vector<SharedPtr<RigidBody> > RigidBodyList;
   RigidBodyList mRigidBodies;

Modified: trunk/OpenFDM/src/OpenFDM/PrismaticJoint.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/PrismaticJoint.cpp	2005-12-25 19:46:50 UTC (rev 119)
+++ trunk/OpenFDM/src/OpenFDM/PrismaticJoint.cpp	2005-12-26 08:08:34 UTC (rev 120)
@@ -79,7 +79,7 @@
 {
   // That projects away tha components where the degrees of freedom
   // of the joint are.
-  RigidBody* out = getOutboardGroup()->toRigidBody();
+  RigidBody* out = getOutboardBody();
   real_type tau = getJointForce();
   return JointT<1>::jointArticulation(artI, artF, out->getPAlpha(),
                                       tau*getJointAxis(),
@@ -90,8 +90,8 @@
 PrismaticJoint::computeRelAccel(const SpatialInertia&,
                                 const Vector6&)
 {
-  RigidBody* out = getOutboardGroup()->toRigidBody();
-  Vector6 parentAccel = out->getParentSpAccel();
+  RigidBody* out = getOutboardBody();
+  Vector6 parentAccel = out->getFrame()->getParentSpAccel();
 
   SpatialInertia artI = out->getArtInertia();
   Vector6 pAlpha = out->getPAlpha();

Modified: trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp	2005-12-25 19:46:50 UTC (rev 119)
+++ trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp	2005-12-26 08:08:34 UTC (rev 120)
@@ -84,7 +84,7 @@
 {
   // That projects away tha components where the degrees of freedom
   // of the joint are.
-  RigidBody* out = getOutboardGroup()->toRigidBody();
+  RigidBody* out = getOutboardBody();
   real_type tau = getJointForce();
   return JointT<1>::jointArticulation(artI, artF, out->getPAlpha(),
                                       tau*getJointAxis(),
@@ -95,8 +95,8 @@
 RevoluteJoint::computeRelAccel(const SpatialInertia&,
                                const Vector6&)
 {
-  RigidBody* out = getOutboardGroup()->toRigidBody();
-  Vector6 parentAccel = out->getParentSpAccel();
+  RigidBody* out = getOutboardBody();
+  Vector6 parentAccel = out->getFrame()->getParentSpAccel();
 
   SpatialInertia artI = out->getArtInertia();
   Vector6 pAlpha = out->getPAlpha();

Modified: trunk/OpenFDM/src/OpenFDM/RigidBody.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RigidBody.cpp	2005-12-25 19:46:50 UTC (rev 119)
+++ trunk/OpenFDM/src/OpenFDM/RigidBody.cpp	2005-12-26 08:08:34 UTC (rev 120)
@@ -21,7 +21,8 @@
 namespace OpenFDM {
 
 RigidBody::RigidBody(const std::string& name) :
-  Frame(name)
+  Object(name),
+  mFrame(new FreeFrame(name))
 {
 }
 
@@ -29,18 +30,6 @@
 {
 }
 
-RigidBody*
-RigidBody::toRigidBody(void)
-{
-  return this;
-}
-
-const RigidBody*
-RigidBody::toRigidBody(void) const
-{
-  return this;
-}
-
 void
 RigidBody::accept(Visitor& visitor)
 {
@@ -81,8 +70,9 @@
 
   // Update all accelerations, Hmm, is a bit too croase that way ...
   InteractList::iterator it;
-  for (it = mInteracts.begin(); it != mInteracts.end(); ++it)
-    (*it)->updateAccels();
+  for (it = mInteracts.begin(); it != mInteracts.end(); ++it) {
+    (*it)->updateAccels(this);
+  }
 
   Log(ArtBody, Debug3) << "On exit of computeAccel of \"" << getName()
                        << "\"" << endl;

Modified: trunk/OpenFDM/src/OpenFDM/RigidBody.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RigidBody.h	2005-12-25 19:46:50 UTC (rev 119)
+++ trunk/OpenFDM/src/OpenFDM/RigidBody.h	2005-12-26 08:08:34 UTC (rev 120)
@@ -24,7 +24,7 @@
 
 // Rename to Body???
 class RigidBody :
-    public Frame {
+    public Object {
 public:
   // HMM ... FIXME
   friend class Joint;
@@ -37,9 +37,6 @@
    */
   virtual ~RigidBody(void);
 
-  virtual RigidBody* toRigidBody(void);
-  virtual const RigidBody* toRigidBody(void) const;
-
   virtual void accept(Visitor& visitor);
   virtual void accept(ConstVisitor& visitor) const;
 
@@ -79,7 +76,7 @@
   /** HMM
    */
   Vector6 getPAlpha(void) const
-  { return mArtForce + mArtInertia*getHdot(); }
+  { return mArtForce + mArtInertia*getFrame()->getHdot(); }
 
   /// Contribute articulated force
   void contributeForce(const Vector6& force)
@@ -103,9 +100,13 @@
   /** Introduce an interface routine
    */
   Frame* getFrame(void)
-  { return this; }
+  { return mFrame; }
   const Frame* getFrame(void) const
-  { return this; }
+  { return mFrame; }
+  FreeFrame* getFreeFrame(void)
+  { return mFrame; }
+  const FreeFrame* getFreeFrame(void) const
+  { return mFrame; }
 
   /// FIXME remove
   virtual bool addInteract2(Interact* child, unsigned parentNum = 0);
@@ -128,6 +129,7 @@
 
   /// Frame attached to this rigid body
 //   SharedPtr<Frame> mFrame;
+  SharedPtr<FreeFrame> mFrame;
 
   typedef std::vector<SharedPtr<Interact> > InteractList;
   InteractList mInteracts;

Modified: trunk/OpenFDM/src/OpenFDM/Vehicle.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Vehicle.cpp	2005-12-25 19:46:50 UTC (rev 119)
+++ trunk/OpenFDM/src/OpenFDM/Vehicle.cpp	2005-12-26 08:08:34 UTC (rev 120)
@@ -35,7 +35,7 @@
   mRootFrame->setAngularRelVel(earthRotation);
 
   mTopBody = new RigidBody("Topmost rigid body");
-  mRootFrame->addChildFrame(mTopBody);
+  mRootFrame->addChildFrame(mTopBody->getFrame());
 
   mFreeJoint = new FreeJoint(mEnvironment, "Mobile vehicle base");
   mRootFrame->addInteract2(mFreeJoint, 1);
@@ -114,7 +114,7 @@
 Vector3
 Vehicle::getCartPosition(void) const
 {
-  return mTopBody->getRefPosition();/*FIXME*/
+  return mTopBody->getFrame()->getRefPosition();/*FIXME*/
 }
 
 void
@@ -150,7 +150,7 @@
 Quaternion
 Vehicle::getCartOrientation(void) const
 {
-  return mTopBody->getRefOrientation();/*FIXME*/
+  return mTopBody->getFrame()->getRefOrientation();/*FIXME*/
 }
 
 void

Modified: trunk/OpenFDM/src/OpenFDM/Vehicle.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Vehicle.h	2005-12-25 19:46:50 UTC (rev 119)
+++ trunk/OpenFDM/src/OpenFDM/Vehicle.h	2005-12-26 08:08:34 UTC (rev 120)
@@ -103,7 +103,7 @@
 
   // FIXME
   Vector6 getVelocity(void) const
-  { return mTopBody->getRelVel(); }
+  { return mTopBody->getFrame()->getRelVel(); }
   real_type getRadius(void) const
   { return 15; }
   real_type getTime(void) const



From frohlich at berlios.de  Mon Dec 26 09:09:45 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Mon, 26 Dec 2005 09:09:45 +0100
Subject: [OpenFDM-svn] r121 - trunk/flightgear
Message-ID: <200512260809.jBQ89j9o029001@sheep.berlios.de>

Author: frohlich
Date: 2005-12-26 09:09:41 +0100 (Mon, 26 Dec 2005)
New Revision: 121

Modified:
   trunk/flightgear/FGOpenFDM.cpp
Log:
Reflect past core changes


Modified: trunk/flightgear/FGOpenFDM.cpp
===================================================================
--- trunk/flightgear/FGOpenFDM.cpp	2005-12-26 08:08:34 UTC (rev 120)
+++ trunk/flightgear/FGOpenFDM.cpp	2005-12-26 08:09:41 UTC (rev 121)
@@ -343,7 +343,7 @@
   _set_Climb_Rate(-localVel(3));
 
   const RigidBody* topBody = vehicle->getTopBody();
-  Vector3 bodyAccel = convertTo(uFeetPSec2, topBody->getClassicAccel().getLinear());
+  Vector3 bodyAccel = convertTo(uFeetPSec2, topBody->getFrame()->getClassicAccel().getLinear());
   _set_Accels_Body(bodyAccel(1), bodyAccel(2), bodyAccel(3));
   _set_Accels_Pilot_Body(bodyAccel(1), bodyAccel(2), bodyAccel(3));
   _set_Accels_CG_Body(bodyAccel(1), bodyAccel(2), bodyAccel(3));
@@ -357,7 +357,7 @@
   _set_Nlf(-nAccel(3));
 
   
-  Vector3 angVel = topBody->getRelVel().getAngular();
+  Vector3 angVel = topBody->getFrame()->getRelVel().getAngular();
   _set_Omega_Body(angVel(1), angVel(2), angVel(3));
 //   _set_Euler_Rates(roll, pitch, hdg);
 



From frohlich at berlios.de  Mon Dec 26 11:18:35 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Mon, 26 Dec 2005 11:18:35 +0100
Subject: [OpenFDM-svn] r122 - in trunk/OpenFDM/src: JSBSim OpenFDM
Message-ID: <200512261018.jBQAIZNQ004556@sheep.berlios.de>

Author: frohlich
Date: 2005-12-26 11:18:30 +0100 (Mon, 26 Dec 2005)
New Revision: 122

Modified:
   trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
   trunk/OpenFDM/src/OpenFDM/Frame.h
   trunk/OpenFDM/src/OpenFDM/Interact.cpp
   trunk/OpenFDM/src/OpenFDM/Interact.h
   trunk/OpenFDM/src/OpenFDM/RigidBody.cpp
   trunk/OpenFDM/src/OpenFDM/RigidBody.h
   trunk/OpenFDM/src/OpenFDM/Vehicle.cpp
Log:
Remove some FIXME's


Modified: trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
===================================================================
--- trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2005-12-26 08:09:41 UTC (rev 121)
+++ trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2005-12-26 10:18:30 UTC (rev 122)
@@ -90,7 +90,7 @@
   // Allocate a new vehicle
   mVehicle = new Vehicle;
   mAeroForce = new AeroForce(mVehicle->getEnvironment(), "Aerodynamic force");
-  mVehicle->getTopBody()->addInteract2(mAeroForce);
+  mVehicle->getTopBody()->addInteract(mAeroForce);
   // Default discrete stepsize of JSBSim
   mVehicle->getModelGroup()->addSampleTime(SampleTime(1.0/120));
 
@@ -707,7 +707,7 @@
     spi += inertiaFrom(structToBody(it->first), inertia);
     ++it;
   }
-  mVehicle->getTopBody()->addInteract2(new Mass(spi));
+  mVehicle->getTopBody()->addInteract(new Mass(spi));
 
   // Attach the eye point.
   FreeFrame* epFrame = new FreeFrame("Eyepoint Frame");
@@ -718,8 +718,8 @@
   accelSensor->addSampleTime(SampleTime(1.0/120));
   Port* port = accelSensor->getOutputPort("nz");
   registerJSBExpression("accelerations/n-pilot-z-norm", port);
-//   epFrame->addInteract2(accelSensor);
-  mVehicle->getTopBody()->addInteract2(accelSensor);
+//   epFrame->addInteract(accelSensor);
+  mVehicle->getTopBody()->addInteract(accelSensor);
   mVehicle->getTopBody()->getFrame()->addChildFrame(epFrame);
   addOutputModel(port, "Normalized load value", "/accelerations/nlf");
 
@@ -738,13 +738,13 @@
 {
   RigidBody* wheel = new RigidBody(name + " Wheel");
   InertiaMatrix wheelInertia(10, 0, 0, 100, 0, 10);
-  wheel->addInteract2(new Mass(SpatialInertia(wheelInertia, 50)));
+  wheel->addInteract(new Mass(SpatialInertia(wheelInertia, 50)));
   parent->getFrame()->addChildFrame(wheel->getFrame());
   mVehicle->getMultiBodySystem()->addRigidBody(wheel);
   
   RevoluteJoint* wj = new RevoluteJoint(name + " Wheel Joint");
-  parent->addInteract2(wj, 0);
-  wheel->addInteract2(wj, 1);
+  parent->addInteract(wj);
+  wheel->addInteract(wj);
   wj->setJointAxis(Vector3(0, 1, 0));
   wj->setPosition(pos);
   wj->setOrientation(Quaternion::unit());
@@ -769,7 +769,7 @@
   wc->setSpringConstant(convertFrom(uPoundForcePFt, tireSpring));
   wc->setSpringDamping(convertFrom(uPoundForcePFt, tireDamp));
   wc->setFrictionCoeficient(0.9);
-  wheel->addInteract2(wc);
+  wheel->addInteract(wc);
   
   Port* port = wj->getOutputPort(0);
   std::string nameBase = "Wheel " + numStr + " Position";
@@ -822,7 +822,7 @@
         sc->setSpringDamping(convertFrom(uPoundForcePFt, d));
         sc->setFrictionCoeficient(0.1*fs);
         
-        mVehicle->getTopBody()->addInteract2(sc);
+        mVehicle->getTopBody()->addInteract(sc);
 
       } else {
         // For jsbsim use simple gears
@@ -880,7 +880,7 @@
           sg->getInputPort("brakeCommand")->connect(port);
         }
         
-        mVehicle->getTopBody()->addInteract2(sg);
+        mVehicle->getTopBody()->addInteract(sg);
       }
       
     } else if (uctype == "AC_LAUNCHBAR") {
@@ -929,12 +929,12 @@
       RigidBody* arm = new RigidBody(name + " Arm");
       mVehicle->getMultiBodySystem()->addRigidBody(arm);
       mVehicle->getTopBody()->getFrame()->addChildFrame(arm->getFrame());
-      arm->addInteract2(new Mass(inertiaFrom(Vector3(-1, 0, 0), SpatialInertia(200))));
+      arm->addInteract(new Mass(inertiaFrom(Vector3(-1, 0, 0), SpatialInertia(200))));
 
       // Connect that with a revolute joint to the main body
       RevoluteJoint* rj = new RevoluteJoint(name + " Arm Joint");
-      mVehicle->getTopBody()->addInteract2(rj, 0);
-      arm->addInteract2(rj, 1);
+      mVehicle->getTopBody()->addInteract(rj);
+      arm->addInteract(rj);
       rj->setJointAxis(Vector3(0, 1, 0));
       rj->setJointPos(0);
       rj->setJointVel(0);
@@ -1009,8 +1009,8 @@
         // Note the 0.05m below, most steering wheels have some kind of
         // castering auto line up behavour. That is doe with this 0.05m.
         RevoluteJoint* sj = new RevoluteJoint(name + " Steer Joint");
-        strutParent->addInteract2(sj, 0);
-        steer->addInteract2(sj, 1);
+        strutParent->addInteract(sj);
+        steer->addInteract(sj);
         sj->setJointAxis(Vector3(0, 0, 1));
         sj->setJointPos(0);
         sj->setJointVel(0);
@@ -1047,12 +1047,12 @@
       RigidBody* arm = new RigidBody(name + " Strut");
       mVehicle->getMultiBodySystem()->addRigidBody(arm);
       strutParent->getFrame()->addChildFrame(arm->getFrame());
-      arm->addInteract2(new Mass(inertiaFrom(Vector3(0, 0, 1), SpatialInertia(200))));
+      arm->addInteract(new Mass(inertiaFrom(Vector3(0, 0, 1), SpatialInertia(200))));
 
       // This time it is a prismatic joint
       PrismaticJoint* pj = new PrismaticJoint(name + " Compress Joint");
-      strutParent->addInteract2(pj, 0);
-      arm->addInteract2(pj, 1);
+      strutParent->addInteract(pj);
+      arm->addInteract(pj);
       pj->setJointAxis(Vector3(0, 0, -1));
       if (strutParent == mVehicle->getTopBody())
         pj->setPosition(structToBody(compressJointPos));
@@ -1101,7 +1101,7 @@
       sc->setSpringDamping(convertFrom(uPoundForcePFt, d));
       sc->setFrictionCoeficient(fs);
 
-      mVehicle->getTopBody()->addInteract2(sc);
+      mVehicle->getTopBody()->addInteract(sc);
     }
   }
 
@@ -1855,7 +1855,7 @@
   std::string throttlename = "fcs/throttle-cmd-norm[" + number + "]";
   engineForce->getInputPort(0)->connect(lookupJSBExpression(throttlename));
 
-  mVehicle->getTopBody()->addInteract2(engineForce);
+  mVehicle->getTopBody()->addInteract(engineForce);
 
   return true;
 }

Modified: trunk/OpenFDM/src/OpenFDM/Frame.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Frame.h	2005-12-26 08:09:41 UTC (rev 121)
+++ trunk/OpenFDM/src/OpenFDM/Frame.h	2005-12-26 10:18:30 UTC (rev 122)
@@ -94,17 +94,6 @@
   { return mChildFrames.size(); }
 
 
-
-
-  //////////////////
-
-  /// FIXME should vanish
-  virtual bool addInteract2(Interact* child, unsigned parentNum = 0)
-  { return false; }
-
-  //////////////////
-
-
   // Return the current frames frame id.
   frameid_type getFrameId(void) const
   { return this; }

Modified: trunk/OpenFDM/src/OpenFDM/Interact.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Interact.cpp	2005-12-26 08:09:41 UTC (rev 121)
+++ trunk/OpenFDM/src/OpenFDM/Interact.cpp	2005-12-26 10:18:30 UTC (rev 122)
@@ -45,7 +45,6 @@
   for (it = mParents.begin(); it != mParents.end(); ++it) {
     if ((*it) == 0) {
       (*it) = rigidBody;
-      (*it)->addInteract(this);
       return true;
     }
   }
@@ -67,7 +66,6 @@
   ParentList::iterator it;
   for (it = mParents.begin(); it != mParents.end(); ++it) {
     if ((*it) == rigidBody) {
-      (*it)->removeInteract(this);
       (*it) = 0;
       return true;
     }

Modified: trunk/OpenFDM/src/OpenFDM/Interact.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Interact.h	2005-12-26 08:09:41 UTC (rev 121)
+++ trunk/OpenFDM/src/OpenFDM/Interact.h	2005-12-26 10:18:30 UTC (rev 122)
@@ -32,9 +32,14 @@
   /// Double dispatch helper for the multibody system visitor
 //   virtual void accept(ConstModelVisitor& visitor) const;
 
+private:
   bool attachTo(RigidBody* rigidBody);
   bool detachFrom(RigidBody* rigidBody);
 
+  friend class RigidBody;
+
+public:
+
   const RigidBody* getParentRigidBody(unsigned id = 0) const
   {
     OpenFDMAssert(id < mParents.size());

Modified: trunk/OpenFDM/src/OpenFDM/RigidBody.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RigidBody.cpp	2005-12-26 08:09:41 UTC (rev 121)
+++ trunk/OpenFDM/src/OpenFDM/RigidBody.cpp	2005-12-26 10:18:30 UTC (rev 122)
@@ -97,13 +97,16 @@
   return mParentMultiBodySystem;
 }
 
-void
+bool
 RigidBody::addInteract(Interact* interact)
 {
   mInteracts.push_back(interact);
+  if (!interact->attachTo(this))
+    return false;
   if (!mParentMultiBodySystem)
-    return;
+    return true;
   mParentMultiBodySystem->addInteract(interact);
+  return true;
 }
 
 bool
@@ -119,10 +122,4 @@
   return false;
 }
 
-bool
-RigidBody::addInteract2(Interact* child, unsigned parentNum)
-{
-  child->attachTo(this);
-}
-
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/RigidBody.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RigidBody.h	2005-12-26 08:09:41 UTC (rev 121)
+++ trunk/OpenFDM/src/OpenFDM/RigidBody.h	2005-12-26 10:18:30 UTC (rev 122)
@@ -108,16 +108,13 @@
   const FreeFrame* getFreeFrame(void) const
   { return mFrame; }
 
-  /// FIXME remove
-  virtual bool addInteract2(Interact* child, unsigned parentNum = 0);
-
   void setParentMultiBodySystem(MultiBodySystem* multiBodySystem);
   MultiBodySystem* getParentMultiBodySystem(void);
 
-private:
-  void addInteract(Interact* interact);
+  bool addInteract(Interact* interact);
   bool removeInteract(Interact* interact);
 
+private:
   /// Outboard articulated inertia
   SpatialInertia mArtInertia;
 

Modified: trunk/OpenFDM/src/OpenFDM/Vehicle.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Vehicle.cpp	2005-12-26 08:09:41 UTC (rev 121)
+++ trunk/OpenFDM/src/OpenFDM/Vehicle.cpp	2005-12-26 10:18:30 UTC (rev 122)
@@ -38,8 +38,8 @@
   mRootFrame->addChildFrame(mTopBody->getFrame());
 
   mFreeJoint = new FreeJoint(mEnvironment, "Mobile vehicle base");
-  mRootFrame->addInteract2(mFreeJoint, 1);
-  mTopBody->addInteract2(mFreeJoint);
+//   mRootFrame->addInteract(mFreeJoint);
+  mTopBody->addInteract(mFreeJoint);
 
   mSystem = new System("Top Vehicle System");
 



From frohlich at berlios.de  Mon Dec 26 14:05:57 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Mon, 26 Dec 2005 14:05:57 +0100
Subject: [OpenFDM-svn] r123 - in trunk/OpenFDM/src: JSBSim OpenFDM
Message-ID: <200512261305.jBQD5vng004071@sheep.berlios.de>

Author: frohlich
Date: 2005-12-26 14:05:30 +0100 (Mon, 26 Dec 2005)
New Revision: 123

Modified:
   trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
   trunk/OpenFDM/src/OpenFDM/AeroForce.cpp
   trunk/OpenFDM/src/OpenFDM/AeroForce.h
   trunk/OpenFDM/src/OpenFDM/Contact.cpp
   trunk/OpenFDM/src/OpenFDM/Contact.h
   trunk/OpenFDM/src/OpenFDM/Environment.cpp
   trunk/OpenFDM/src/OpenFDM/Environment.h
   trunk/OpenFDM/src/OpenFDM/Frame.cpp
   trunk/OpenFDM/src/OpenFDM/Frame.h
   trunk/OpenFDM/src/OpenFDM/FreeJoint.cpp
   trunk/OpenFDM/src/OpenFDM/FreeJoint.h
   trunk/OpenFDM/src/OpenFDM/Joint.h
   trunk/OpenFDM/src/OpenFDM/Model.cpp
   trunk/OpenFDM/src/OpenFDM/Model.h
   trunk/OpenFDM/src/OpenFDM/SimpleContact.cpp
   trunk/OpenFDM/src/OpenFDM/SimpleContact.h
   trunk/OpenFDM/src/OpenFDM/SimpleGear.cpp
   trunk/OpenFDM/src/OpenFDM/SimpleGear.h
   trunk/OpenFDM/src/OpenFDM/System.cpp
   trunk/OpenFDM/src/OpenFDM/System.h
   trunk/OpenFDM/src/OpenFDM/Vehicle.cpp
   trunk/OpenFDM/src/OpenFDM/Vehicle.h
   trunk/OpenFDM/src/OpenFDM/WheelContact.cpp
   trunk/OpenFDM/src/OpenFDM/WheelContact.h
Log:
Put the root frame into Environment, Make the
Environment class accessible through the models.
Make use of that.


Modified: trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
===================================================================
--- trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2005-12-26 10:18:30 UTC (rev 122)
+++ trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2005-12-26 13:05:30 UTC (rev 123)
@@ -89,7 +89,7 @@
   mExpressionTable.clear();
   // Allocate a new vehicle
   mVehicle = new Vehicle;
-  mAeroForce = new AeroForce(mVehicle->getEnvironment(), "Aerodynamic force");
+  mAeroForce = new AeroForce("Aerodynamic force");
   mVehicle->getTopBody()->addInteract(mAeroForce);
   // Default discrete stepsize of JSBSim
   mVehicle->getModelGroup()->addSampleTime(SampleTime(1.0/120));
@@ -763,8 +763,7 @@
   }
   wj->setLineForce(brakeF);
   
-  WheelContact* wc = new WheelContact(name + " Wheel Contact",
-                                      mVehicle->getEnvironment());
+  WheelContact* wc = new WheelContact(name + " Wheel Contact");
   wc->setWheelRadius(0.5*wheelDiam);
   wc->setSpringConstant(convertFrom(uPoundForcePFt, tireSpring));
   wc->setSpringDamping(convertFrom(uPoundForcePFt, tireDamp));
@@ -810,8 +809,7 @@
       if (type == "CASTERING") {
         // Modelling castering gars as simple contacs without a special
         // direction
-        SimpleContact* sc = new SimpleContact(name,
-                                              mVehicle->getEnvironment());
+        SimpleContact* sc = new SimpleContact(name);
         sc->setPosition(structToBody(Vector3(x, y, z)));
 
         sc->setSpringConstant(convertFrom(uPoundForcePFt, k));
@@ -826,7 +824,7 @@
 
       } else {
         // For jsbsim use simple gears
-        SimpleGear* sg = new SimpleGear(name, mVehicle->getEnvironment());
+        SimpleGear* sg = new SimpleGear(name);
         sg->setPosition(structToBody(Vector3(x, y, z)));
         
         sg->setSpringConstant(convertFrom(uPoundForcePFt, k));
@@ -1090,7 +1088,7 @@
               >> type >> brake >> sa >> retract;
 
       // Very simple contact force. Penalty method.
-      SimpleContact* sc = new SimpleContact(name, mVehicle->getEnvironment());
+      SimpleContact* sc = new SimpleContact(name);
       sc->setPosition(structToBody(Vector3(x, y, z)));
 
       sc->setSpringConstant(convertFrom(uPoundForcePFt, k));

Modified: trunk/OpenFDM/src/OpenFDM/AeroForce.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/AeroForce.cpp	2005-12-26 10:18:30 UTC (rev 122)
+++ trunk/OpenFDM/src/OpenFDM/AeroForce.cpp	2005-12-26 13:05:30 UTC (rev 123)
@@ -13,11 +13,9 @@
 
 namespace OpenFDM {
 
-AeroForce::AeroForce(Environment* env, const std::string& name)
+AeroForce::AeroForce(const std::string& name)
   : ExternalForce(name)
 {
-  mEnvironment = env;
-
   // Initialize all the expression nodes we will need.
   for (unsigned i = 0; i < 6; ++i) {
     mStabilityAxisSummers[i] = new SumExpressionImpl;
@@ -101,6 +99,15 @@
 {
 }
 
+bool
+AeroForce::init(void)
+{
+  mEnvironment = getEnvironment();
+  if (!mEnvironment)
+    return false;
+  return ExternalForce::init();
+}
+
 void
 AeroForce::output(const TaskInfo& taskInfo)
 {
@@ -198,6 +205,10 @@
     const Frame* frame = getParentFrame(0);
     OpenFDMAssert(frame);
     if (frame) {
+      // FIXME temporary workaround
+      if (!mEnvironment) {
+        const_cast<AeroForce*>(this)->mEnvironment = getEnvironment();
+      }
       // Get the position in the earth centered coordinate frame.
       Vector3 pos = frame->posToRef(getPosition());
       Vector3 windVel = mEnvironment->getWind()->getWindVel(pos);
@@ -426,6 +437,10 @@
 AeroForce::getAltitude(void) const
 {
   if (mDirtyAltitude) {
+    // FIXME temporary workaround
+    if (!mEnvironment) {
+      const_cast<AeroForce*>(this)->mEnvironment = getEnvironment();
+    }
     // Get the altitude for the atmosphere.
     Geodetic geod = mEnvironment->getPlanet()->toGeod(getRefPosition());
 

Modified: trunk/OpenFDM/src/OpenFDM/AeroForce.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/AeroForce.h	2005-12-26 10:18:30 UTC (rev 122)
+++ trunk/OpenFDM/src/OpenFDM/AeroForce.h	2005-12-26 13:05:30 UTC (rev 123)
@@ -30,9 +30,10 @@
     SideAxis = 5,
     LiftAxis = 6
   };
-  AeroForce(Environment* env, const std::string&);
+  AeroForce(const std::string&);
   virtual ~AeroForce(void);
 
+  virtual bool init(void);
   virtual void output(const TaskInfo&);
 
   void setPosition(const Vector3& p);

Modified: trunk/OpenFDM/src/OpenFDM/Contact.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Contact.cpp	2005-12-26 10:18:30 UTC (rev 122)
+++ trunk/OpenFDM/src/OpenFDM/Contact.cpp	2005-12-26 13:05:30 UTC (rev 123)
@@ -13,11 +13,10 @@
 
 namespace OpenFDM {
 
-Contact::Contact(const std::string& name, Environment* env)
+Contact::Contact(const std::string& name)
   : ExternalForce(name)
 {
   mEnabled = true;
-  mEnvironment = env;
   setPosition(Vector3::zeros());
 
   unsigned inputPortBase = getNumInputPorts();
@@ -33,6 +32,15 @@
 {
 }
 
+bool
+Contact::init(void)
+{
+  mEnvironment = getEnvironment();
+  if (!mEnvironment)
+    return false;
+  return ExternalForce::init();
+}
+
 void
 Contact::output(const TaskInfo& taskInfo)
 {
@@ -124,6 +132,11 @@
   if (!frame)
     return;
 
+  // FIXME
+  if (!mEnvironment) {
+    mEnvironment = getEnvironment();
+  }
+
   // Get the position of the contact in the reference system.
   Vector3 pos = frame->posToRef(getPosition());
   // Query for the ground parameters at this point.

Modified: trunk/OpenFDM/src/OpenFDM/Contact.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Contact.h	2005-12-26 10:18:30 UTC (rev 122)
+++ trunk/OpenFDM/src/OpenFDM/Contact.h	2005-12-26 13:05:30 UTC (rev 123)
@@ -18,9 +18,10 @@
 class Contact
   : public ExternalForce {
 public:
-  Contact(const std::string& name, Environment* env);
+  Contact(const std::string& name);
   virtual ~Contact(void);
 
+  virtual bool init(void);
   virtual void output(const TaskInfo&);
 
   Vector3 mPosition;

Modified: trunk/OpenFDM/src/OpenFDM/Environment.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Environment.cpp	2005-12-26 10:18:30 UTC (rev 122)
+++ trunk/OpenFDM/src/OpenFDM/Environment.cpp	2005-12-26 13:05:30 UTC (rev 123)
@@ -12,6 +12,7 @@
 #include "Turbulence.h"
 #include "Wind.h"
 #include "Environment.h"
+#include "RootFrame.h"
 
 namespace OpenFDM {
 
@@ -22,6 +23,10 @@
   setGround(new DefaultGround);
   setPlanet(new DefaultPlanet);
   setWind(new Wind);
+  RootFrame* rootFrame = new RootFrame("Planet centered frame");
+  Vector3 earthRotation(0.0, 0.0, pi2/(60*60*24));
+  rootFrame->setAngularRelVel(earthRotation);
+  setRootFrame(rootFrame);
 }
 
 Environment::~Environment(void)
@@ -77,6 +82,13 @@
 }
 
 void
+Environment::setRootFrame(RootFrame* rootFrame)
+{
+  rootFrame->reparentChildren(mRootFrame);
+  mRootFrame = rootFrame;
+}
+
+void
 Environment::attachEnvironmentObject(EnvironmentObject* environmentObject)
 {
   if (!environmentObject)

Modified: trunk/OpenFDM/src/OpenFDM/Environment.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Environment.h	2005-12-26 10:18:30 UTC (rev 122)
+++ trunk/OpenFDM/src/OpenFDM/Environment.h	2005-12-26 13:05:30 UTC (rev 123)
@@ -15,6 +15,7 @@
 class Planet;
 class Turbulence;
 class Wind;
+class RootFrame;
 
 class EnvironmentObject;
 
@@ -78,6 +79,15 @@
   const Wind* getWind(void) const
   { return mWind; }
 
+  /// Set RootFrame
+  void setRootFrame(RootFrame* rootFrame);
+
+  /// Get RootFrame
+  const RootFrame* getRootFrame(void) const
+  { return mRootFrame; }
+  RootFrame* getRootFrame(void)
+  { return mRootFrame; }
+
 private:
   void attachEnvironmentObject(EnvironmentObject* environmentObject);
   void detachEnvironmentObject(EnvironmentObject* environmentObject);
@@ -88,6 +98,7 @@
   SharedPtr<Planet> mPlanet;
   SharedPtr<Turbulence> mTurbulence;
   SharedPtr<Wind> mWind;
+  SharedPtr<RootFrame> mRootFrame;
 };
 
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/Frame.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Frame.cpp	2005-12-26 10:18:30 UTC (rev 122)
+++ trunk/OpenFDM/src/OpenFDM/Frame.cpp	2005-12-26 13:05:30 UTC (rev 123)
@@ -127,6 +127,19 @@
 }
 
 void
+Frame::reparentChildren(Frame* frame)
+{
+  if (!frame)
+    return;
+  ChildFrameList::iterator it = frame->mChildFrames.begin();
+  while (it != frame->mChildFrames.end()) {
+    (*it)->setParentFrame(0);
+    addChildFrame(*it);
+    it = frame->mChildFrames.erase(it);
+  }
+}
+
+void
 Frame::computePositionDep(void) const
 {
   if (hasParent()) {

Modified: trunk/OpenFDM/src/OpenFDM/Frame.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Frame.h	2005-12-26 10:18:30 UTC (rev 122)
+++ trunk/OpenFDM/src/OpenFDM/Frame.h	2005-12-26 13:05:30 UTC (rev 123)
@@ -93,6 +93,8 @@
   unsigned getNumChildFrames(void) const
   { return mChildFrames.size(); }
 
+  /// Take over all children from the given frame to this frame
+  void reparentChildren(Frame* frame);
 
   // Return the current frames frame id.
   frameid_type getFrameId(void) const

Modified: trunk/OpenFDM/src/OpenFDM/FreeJoint.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/FreeJoint.cpp	2005-12-26 10:18:30 UTC (rev 122)
+++ trunk/OpenFDM/src/OpenFDM/FreeJoint.cpp	2005-12-26 13:05:30 UTC (rev 123)
@@ -12,15 +12,15 @@
 #include "Gravity.h"
 #include "Frame.h"
 #include "RigidBody.h"
+#include "RootFrame.h"
 #include "FreeJoint.h"
 
 namespace OpenFDM {
 
-FreeJoint::FreeJoint(Environment* env,const std::string& name)
+FreeJoint::FreeJoint(const std::string& name)
   : Joint(name)
 {
   setNumContinousStates(13);
-  mEnvironment = env;
   addSampleTime(SampleTime::Continous);
 }
 
@@ -29,6 +29,31 @@
 }
 
 bool
+FreeJoint::init(void)
+{
+  Environment* environment = getEnvironment();
+  if (!environment) {
+    Log(Model,Error) << "Can not get environment pointer! Most propably the"
+      " Model is not put together correctly!" << endl;
+    return false;
+  }
+  mGravity = environment->getGravity();
+  if (!mGravity) {
+    Log(Model,Error) << "Can not get gravity model!" << endl;
+    return false;
+  }
+  Frame* rootFrame = environment->getRootFrame();
+  if (!rootFrame) {
+    Log(Model,Error) << "Can not get rootFrame model!" << endl;
+    return false;
+  }
+  Frame* outboardFrame = getOutboardBody()->getFrame();
+  rootFrame->addChildFrame(outboardFrame);
+
+  return Joint::init();
+}
+
+bool
 FreeJoint::jointArticulation(SpatialInertia& artI, Vector6& artF)
 {
   artI = SpatialInertia::zeros();
@@ -51,7 +76,7 @@
   // center of mass. That means gravity could be considered equal for the whole
   // vehicle.
   // See Featherstone, Orin: Equations and Algorithms
-  Vector3 ga = mEnvironment->getGravity()->gravityAccel(frame->getRefPosition());
+  Vector3 ga = mGravity->gravityAccel(frame->getRefPosition());
   Vector6 grav = Vector6(Vector3::zeros(), frame->rotFromRef(ga));
 
   Log(ArtBody, Debug) << "grav = " << trans(grav) << endl;

Modified: trunk/OpenFDM/src/OpenFDM/FreeJoint.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/FreeJoint.h	2005-12-26 10:18:30 UTC (rev 122)
+++ trunk/OpenFDM/src/OpenFDM/FreeJoint.h	2005-12-26 13:05:30 UTC (rev 123)
@@ -21,9 +21,11 @@
 class FreeJoint
   : public Joint {
 public:
-  FreeJoint(Environment* env, const std::string& name = std::string());
+  FreeJoint(const std::string& name = std::string());
   virtual ~FreeJoint(void);
 
+  virtual bool init(void);
+
   /// HACK
   virtual bool isArticulatedJoint(void) const
   { return true; }
@@ -107,7 +109,7 @@
 
   /** Reference to the vehicles environment.
    */
-  SharedPtr<Environment> mEnvironment;
+  SharedPtr<const Gravity> mGravity;
 };
 
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/Joint.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Joint.h	2005-12-26 10:18:30 UTC (rev 122)
+++ trunk/OpenFDM/src/OpenFDM/Joint.h	2005-12-26 13:05:30 UTC (rev 123)
@@ -25,6 +25,10 @@
     : Interact(name, 2)
   {}
 
+  /// FIXME: joint's should be lockable, which means trylock == true and
+  /// velocity small enough - keep position ...
+
+
   virtual bool isArticulatedJoint(void) const
   {
     const Frame* parent0 = getParentFrame(0);

Modified: trunk/OpenFDM/src/OpenFDM/Model.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Model.cpp	2005-12-26 10:18:30 UTC (rev 122)
+++ trunk/OpenFDM/src/OpenFDM/Model.cpp	2005-12-26 13:05:30 UTC (rev 123)
@@ -268,6 +268,14 @@
   mOutputPorts[i] = port;
 }
 
+Environment*
+Model::getEnvironment(void) const
+{
+  if (mParentModel)
+    return mParentModel->getEnvironment();
+  return 0;
+}
+
 void
 Model::setParent(Model* model)
 {

Modified: trunk/OpenFDM/src/OpenFDM/Model.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Model.h	2005-12-26 10:18:30 UTC (rev 122)
+++ trunk/OpenFDM/src/OpenFDM/Model.h	2005-12-26 13:05:30 UTC (rev 123)
@@ -23,6 +23,8 @@
 
 class ModelGroup;
 class MultiBodySystem;
+class Environment;
+
 class Input;
 class Output;
 
@@ -150,6 +152,8 @@
                      const Matrix& (M::*getter)(void) const)
   { setOutputPort(i, name, new MatrixGetterPortInterface<M>(model, getter)); }
 
+  virtual Environment* getEnvironment(void) const;
+
 private:
   // Sets the parent model.
   // That is the one which is informed if the number of states changes.

Modified: trunk/OpenFDM/src/OpenFDM/SimpleContact.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/SimpleContact.cpp	2005-12-26 10:18:30 UTC (rev 122)
+++ trunk/OpenFDM/src/OpenFDM/SimpleContact.cpp	2005-12-26 13:05:30 UTC (rev 123)
@@ -12,8 +12,8 @@
 
 namespace OpenFDM {
 
-SimpleContact::SimpleContact(const std::string& name, Environment* env)
-  : Contact(name, env)
+SimpleContact::SimpleContact(const std::string& name)
+  : Contact(name)
 {
   mSpringConst = 0;
   mSpringDamp = 0;

Modified: trunk/OpenFDM/src/OpenFDM/SimpleContact.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/SimpleContact.h	2005-12-26 10:18:30 UTC (rev 122)
+++ trunk/OpenFDM/src/OpenFDM/SimpleContact.h	2005-12-26 13:05:30 UTC (rev 123)
@@ -17,7 +17,7 @@
 class SimpleContact
   : public Contact {
 public:
-  SimpleContact(const std::string& name, Environment* env);
+  SimpleContact(const std::string& name);
   virtual ~SimpleContact(void);
 
   real_type getSpringConstant(void) const

Modified: trunk/OpenFDM/src/OpenFDM/SimpleGear.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/SimpleGear.cpp	2005-12-26 10:18:30 UTC (rev 122)
+++ trunk/OpenFDM/src/OpenFDM/SimpleGear.cpp	2005-12-26 13:05:30 UTC (rev 123)
@@ -14,8 +14,8 @@
 
 namespace OpenFDM {
 
-SimpleGear::SimpleGear(const std::string& name, Environment* env)
-  : Contact(name, env)
+SimpleGear::SimpleGear(const std::string& name)
+  : Contact(name)
 {
   mSteeringAngle = 0;
   mBrake = 0;

Modified: trunk/OpenFDM/src/OpenFDM/SimpleGear.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/SimpleGear.h	2005-12-26 10:18:30 UTC (rev 122)
+++ trunk/OpenFDM/src/OpenFDM/SimpleGear.h	2005-12-26 13:05:30 UTC (rev 123)
@@ -18,7 +18,7 @@
 class SimpleGear
   : public Contact {
 public:
-  SimpleGear(const std::string& name, Environment* env);
+  SimpleGear(const std::string& name);
   virtual ~SimpleGear(void);
 
 //   virtual bool init(void);

Modified: trunk/OpenFDM/src/OpenFDM/System.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/System.cpp	2005-12-26 10:18:30 UTC (rev 122)
+++ trunk/OpenFDM/src/OpenFDM/System.cpp	2005-12-26 13:05:30 UTC (rev 123)
@@ -22,6 +22,7 @@
   mTime(0)
 {
   setTimestepper(new ExplicitEuler);
+  mEnvironment = new Environment;
 }
 
 System::~System(void)
@@ -343,4 +344,11 @@
   }
 }
 
+Environment*
+System::getEnvironment(void) const
+{
+  /// Hmmm, FIXME
+  return const_cast<Environment*>((const Environment*)mEnvironment);
+}
+
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/System.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/System.h	2005-12-26 10:18:30 UTC (rev 122)
+++ trunk/OpenFDM/src/OpenFDM/System.h	2005-12-26 13:05:30 UTC (rev 123)
@@ -49,6 +49,8 @@
   /// Return a reference to the timestepping algorithm
   ODESolver* getTimestepper(void) { return mTimestepper; }
 
+  virtual Environment* getEnvironment(void) const;
+
 private:
   /// The timestepper used to get time discrete approximate solutions to the
   /// continous system
@@ -60,6 +62,8 @@
   unsigned mCurrentTaskNum;
   real_type mCurrentSliceTime;
 
+  SharedPtr<Environment> mEnvironment;
+
   /// The actual simulation time for the system
   real_type mTime;
 };

Modified: trunk/OpenFDM/src/OpenFDM/Vehicle.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Vehicle.cpp	2005-12-26 10:18:30 UTC (rev 122)
+++ trunk/OpenFDM/src/OpenFDM/Vehicle.cpp	2005-12-26 13:05:30 UTC (rev 123)
@@ -26,9 +26,6 @@
 
 Vehicle::Vehicle(void)
 {
-  // The environment models and callbacks of this vehicle.
-  mEnvironment = new Environment;
-
   // The Planet centered frame is used by the others!
   mRootFrame = new RootFrame("Planet centered frame");
   Vector3 earthRotation(0.0, 0.0, pi2/(60*60*24));
@@ -37,8 +34,7 @@
   mTopBody = new RigidBody("Topmost rigid body");
   mRootFrame->addChildFrame(mTopBody->getFrame());
 
-  mFreeJoint = new FreeJoint(mEnvironment, "Mobile vehicle base");
-//   mRootFrame->addInteract(mFreeJoint);
+  mFreeJoint = new FreeJoint("Mobile vehicle base");
   mTopBody->addInteract(mFreeJoint);
 
   mSystem = new System("Top Vehicle System");
@@ -90,25 +86,25 @@
 void
 Vehicle::setPlanet(Planet* p)
 {
-  mEnvironment->setPlanet(p);
+  mSystem->getEnvironment()->setPlanet(p);
 }
 
 void
 Vehicle::setGround(Ground* p)
 {
-  mEnvironment->setGround(p);
+  mSystem->getEnvironment()->setGround(p);
 }
 
 void
 Vehicle::setAtmosphere(Atmosphere* p)
 {
-  mEnvironment->setAtmosphere(p);
+  mSystem->getEnvironment()->setAtmosphere(p);
 }
 
 void
 Vehicle::setWind(Wind* w)
 {
-  mEnvironment->setWind(w);
+  mSystem->getEnvironment()->setWind(w);
 }
 
 Vector3

Modified: trunk/OpenFDM/src/OpenFDM/Vehicle.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Vehicle.h	2005-12-26 10:18:30 UTC (rev 122)
+++ trunk/OpenFDM/src/OpenFDM/Vehicle.h	2005-12-26 13:05:30 UTC (rev 123)
@@ -45,7 +45,7 @@
   /** Get planet callback.
    */
   const Planet* getPlanet(void) const
-  { return mEnvironment->getPlanet(); }
+  { return mSystem->getEnvironment()->getPlanet(); }
 
   /** Set ground callback.
    */
@@ -54,7 +54,7 @@
   /** Get ground callback.
    */
   const Ground* getGround(void) const
-  { return mEnvironment->getGround(); }
+  { return mSystem->getEnvironment()->getGround(); }
 
   /** Set atmosphere callback.
    */
@@ -64,7 +64,7 @@
       FIXME ?? only callback??
    */
   const Atmosphere* getAtmosphere(void) const
-  { return mEnvironment->getAtmosphere(); }
+  { return mSystem->getEnvironment()->getAtmosphere(); }
 
   /** Set wind callback.
    */
@@ -73,7 +73,7 @@
   /** Get wind callback.
    */
   const Wind* getWind(void) const
-  { return mEnvironment->getWind(); }
+  { return mSystem->getEnvironment()->getWind(); }
 
   /** Get the vehicle base node.
    */
@@ -113,8 +113,6 @@
   { return mTopBody; }
   RigidBody* getTopBody(void)
   { return mTopBody; }
-  Environment* getEnvironment(void)
-  { return mEnvironment; }
 
   const System* getSystem(void) const
   { return mSystem; }
@@ -125,9 +123,6 @@
   { return mMultiBodySystem; }
 
 private:
-  // Environment ...
-  SharedPtr<Environment> mEnvironment;
-
   SharedPtr<RigidBody> mTopBody;
   SharedPtr<FreeJoint> mFreeJoint;
   SharedPtr<RootFrame> mRootFrame;

Modified: trunk/OpenFDM/src/OpenFDM/WheelContact.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/WheelContact.cpp	2005-12-26 10:18:30 UTC (rev 122)
+++ trunk/OpenFDM/src/OpenFDM/WheelContact.cpp	2005-12-26 13:05:30 UTC (rev 123)
@@ -13,7 +13,7 @@
 
 namespace OpenFDM {
 
-WheelContact::WheelContact(const std::string& name, Environment* env)
+WheelContact::WheelContact(const std::string& name)
   : ExternalForce(name)
 {
   mWheelRadius = 0.3;
@@ -21,8 +21,6 @@
   mSpringDamping = 0;
   mFrictionCoeficient = 0.8;
 
-  mEnvironment = env;
-
   // FIXME??
   addSampleTime(SampleTime::PerTimestep);
   addSampleTime(SampleTime::Continous);
@@ -32,6 +30,15 @@
 {
 }
 
+bool
+WheelContact::init(void)
+{
+  mEnvironment = getEnvironment();
+  if (!mEnvironment)
+    return false;
+  return ExternalForce::init();
+}
+
 void
 WheelContact::output(const TaskInfo& taskInfo)
 {
@@ -166,6 +173,11 @@
   if (!frame)
     return;
 
+  // FIXME
+  if (!mEnvironment) {
+    mEnvironment = getEnvironment();
+  }
+
   // Get the position of the contact in the reference system.
   Vector3 pos = frame->posToRef(Vector3::zeros());
   // Query for the ground parameters at this point.

Modified: trunk/OpenFDM/src/OpenFDM/WheelContact.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/WheelContact.h	2005-12-26 10:18:30 UTC (rev 122)
+++ trunk/OpenFDM/src/OpenFDM/WheelContact.h	2005-12-26 13:05:30 UTC (rev 123)
@@ -18,9 +18,10 @@
 class WheelContact
   : public ExternalForce {
 public:
-  WheelContact(const std::string& name, Environment* env);
+  WheelContact(const std::string& name);
   virtual ~WheelContact(void);
 
+  virtual bool init(void);
   virtual void output(const TaskInfo&);
 
   virtual void computeForce(void);



From frohlich at berlios.de  Mon Dec 26 14:43:21 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Mon, 26 Dec 2005 14:43:21 +0100
Subject: [OpenFDM-svn] r124 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200512261343.jBQDhLLq009737@sheep.berlios.de>

Author: frohlich
Date: 2005-12-26 14:43:09 +0100 (Mon, 26 Dec 2005)
New Revision: 124

Modified:
   trunk/OpenFDM/src/OpenFDM/FreeJoint.h
Log:
Remove obsolete decl.


Modified: trunk/OpenFDM/src/OpenFDM/FreeJoint.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/FreeJoint.h	2005-12-26 13:05:30 UTC (rev 123)
+++ trunk/OpenFDM/src/OpenFDM/FreeJoint.h	2005-12-26 13:43:09 UTC (rev 124)
@@ -82,11 +82,6 @@
     topBody->setRefOrientation(o);
   }
 
-  /** Sets the state of this multibody system from the state vector state
-      and returns the time derivative in deriv.
-   */
-  void computeStateDeriv(real_type t, const Vector& state, Vector& deriv);
-
 private:
   /** Plugin function for the articulated body algorithm.
    */



From frohlich at berlios.de  Mon Dec 26 20:11:02 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Mon, 26 Dec 2005 20:11:02 +0100
Subject: [OpenFDM-svn] r125 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200512261911.jBQJB2F3000793@sheep.berlios.de>

Author: frohlich
Date: 2005-12-26 20:09:51 +0100 (Mon, 26 Dec 2005)
New Revision: 125

Modified:
   trunk/OpenFDM/src/OpenFDM/FreeJoint.cpp
   trunk/OpenFDM/src/OpenFDM/FreeJoint.h
   trunk/OpenFDM/src/OpenFDM/Interact.cpp
   trunk/OpenFDM/src/OpenFDM/Interact.h
   trunk/OpenFDM/src/OpenFDM/Joint.h
   trunk/OpenFDM/src/OpenFDM/MultiBodySystem.cpp
   trunk/OpenFDM/src/OpenFDM/MultiBodySystem.h
   trunk/OpenFDM/src/OpenFDM/RigidBody.cpp
   trunk/OpenFDM/src/OpenFDM/RigidBody.h
   trunk/OpenFDM/src/OpenFDM/Vehicle.cpp
   trunk/OpenFDM/src/OpenFDM/Vehicle.h
   trunk/OpenFDM/src/OpenFDM/main.cpp
Log:
Some further cleanup


Modified: trunk/OpenFDM/src/OpenFDM/FreeJoint.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/FreeJoint.cpp	2005-12-26 13:43:09 UTC (rev 124)
+++ trunk/OpenFDM/src/OpenFDM/FreeJoint.cpp	2005-12-26 19:09:51 UTC (rev 125)
@@ -18,7 +18,8 @@
 namespace OpenFDM {
 
 FreeJoint::FreeJoint(const std::string& name)
-  : Joint(name)
+  : Joint(name),
+    mFrame(new FreeFrame(name))
 {
   setNumContinousStates(13);
   addSampleTime(SampleTime::Continous);
@@ -47,12 +48,39 @@
     Log(Model,Error) << "Can not get rootFrame model!" << endl;
     return false;
   }
-  Frame* outboardFrame = getOutboardBody()->getFrame();
-  rootFrame->addChildFrame(outboardFrame);
+  recheckTopology();
 
   return Joint::init();
 }
 
+void
+FreeJoint::recheckTopology(void)
+{
+  // Hmm, works for the first cut, but rethink what happens with strange
+  // attach reattach sequences ...
+  RigidBody* rigidBody = getParentRigidBody(0);
+  if (!rigidBody)
+    return;
+  // check if already done
+  if (mFrame != rigidBody->getFrame())
+    rigidBody->setFrame(mFrame);
+
+  // Check if we are attached to some rigid body ...
+  rigidBody = getParentRigidBody(1);
+  if (rigidBody) {
+    Frame* frame = rigidBody->getFrame();
+    if (!frame->isParentFrame(mFrame))
+      frame->addChildFrame(mFrame);
+  } else {
+    Environment* environment = getEnvironment();
+    if (environment) {
+      Frame* rootFrame = environment->getRootFrame();
+      if (rootFrame)
+        rootFrame->addChildFrame(mFrame);
+    }
+  }
+}
+
 bool
 FreeJoint::jointArticulation(SpatialInertia& artI, Vector6& artF)
 {
@@ -64,29 +92,26 @@
 FreeJoint::computeRelAccel(const SpatialInertia& artI,
                            const Vector6& artF)
 {
-  RigidBody* topBody = getOutboardBody();
-  if (!topBody)
-    return Vector6::zeros();
+  RigidBody* topBody = getParentRigidBody(0);
+  OpenFDMAssert(topBody);
 
-  FreeFrame* frame = topBody->getFreeFrame();
-
   Log(ArtBody, Debug) << "FreeJoint::computeRelAccel():\n" << artI << endl;
 
   // Assumption: body is small compared to the distance to the planets
   // center of mass. That means gravity could be considered equal for the whole
   // vehicle.
   // See Featherstone, Orin: Equations and Algorithms
-  Vector3 ga = mGravity->gravityAccel(frame->getRefPosition());
-  Vector6 grav = Vector6(Vector3::zeros(), frame->rotFromRef(ga));
+  Vector3 ga = mGravity->gravityAccel(mFrame->getRefPosition());
+  Vector6 grav = Vector6(Vector3::zeros(), mFrame->rotFromRef(ga));
 
   Log(ArtBody, Debug) << "grav = " << trans(grav) << endl;
   Log(ArtBody, Debug) << "solve = " << trans(solve(artI, artF)) << endl;
-  Log(ArtBody, Debug) << "parent spatial accel = " << trans(frame->getParentSpAccel()) << endl;
+  Log(ArtBody, Debug) << "parent spatial accel = " << trans(mFrame->getParentSpAccel()) << endl;
   Log(ArtBody, Debug) << "Hdot = " << trans(getHdot()) << endl;
   
 
   Vector6 accel = grav - solve(artI, artF)
-    - frame->getParentSpAccel() - getHdot();
+    - mFrame->getParentSpAccel() - getHdot();
   return accel;
 }
 
@@ -103,22 +128,18 @@
 void
 FreeJoint::getState(Vector& state, unsigned offset) const
 {
-  const RigidBody* topBody = getParentRigidBody(0);
-  if (!topBody)
-    return;
-  const Frame* frame = topBody->getFrame();
-  Quaternion q = frame->getOrientation();
+  Quaternion q = mFrame->getOrientation();
   state(offset+1) = q(1);
   state(offset+2) = q(2);
   state(offset+3) = q(3);
   state(offset+4) = q(4);
   
-  Vector3 p = frame->getPosition();
+  Vector3 p = mFrame->getPosition();
   state(offset+5) = p(1);
   state(offset+6) = p(2);
   state(offset+7) = p(3);
   
-  Vector6 v = frame->getRelVel();
+  Vector6 v = mFrame->getRelVel();
   state(offset+8) = v(1);
   state(offset+9) = v(2);
   state(offset+10) = v(3);
@@ -130,13 +151,9 @@
 void
 FreeJoint::getStateDeriv(Vector& state, unsigned offset)
 {
-  RigidBody* topBody = getOutboardBody();
-  if (!topBody)
-    return;
-  FreeFrame* frame = topBody->getFreeFrame();
-  Quaternion q = frame->getOrientation();
-  Vector3 angVel = frame->getRelVel().getAngular();
-  Vector3 vel = frame->rotToParent(frame->getRelVel().getLinear());
+  Quaternion q = mFrame->getOrientation();
+  Vector3 angVel = mFrame->getRelVel().getAngular();
+  Vector3 vel = mFrame->rotToParent(mFrame->getRelVel().getLinear());
 
   // Compute the derivative term originating from the angular velocity.
   // Correction term to keep the quaternion normalized.
@@ -152,7 +169,7 @@
   state(offset+6) = vel(2);
   state(offset+7) = vel(3);
   
-  Vector6 accel = frame->getRelAccel();
+  Vector6 accel = mFrame->getRelAccel();
   state(offset+8)  = accel(1);
   state(offset+9)  = accel(2);
   state(offset+10) = accel(3);

Modified: trunk/OpenFDM/src/OpenFDM/FreeJoint.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/FreeJoint.h	2005-12-26 13:43:09 UTC (rev 124)
+++ trunk/OpenFDM/src/OpenFDM/FreeJoint.h	2005-12-26 19:09:51 UTC (rev 125)
@@ -21,11 +21,29 @@
 class FreeJoint
   : public Joint {
 public:
-  FreeJoint(const std::string& name = std::string());
+  FreeJoint(const std::string& name);
   virtual ~FreeJoint(void);
 
   virtual bool init(void);
 
+  const Vector3& getInitialPosition(void) const
+  { return mInitialPosition; }
+  void setInitialPosition(const Vector3& pos)
+  { mInitialPosition = pos; }
+
+  const Quaternion& getInitialOrientation(void) const
+  { return mInitialOrientation; }
+  void setInitialOrientation(const Quaternion& orientation)
+  { mInitialOrientation = orientation; }
+
+  const Vector6& getInitialVel(void) const
+  { return mInitialVel; }
+  void setInitialVel(const Vector6& vel)
+  { mInitialVel = vel; }
+
+  virtual void recheckTopology(void);
+
+
   /// HACK
   virtual bool isArticulatedJoint(void) const
   { return true; }
@@ -39,47 +57,37 @@
   { return getParentFrame(0); }
   virtual RigidBody* getOutboardBody(void)
   { return getParentRigidBody(0); }
+  virtual RigidBody* getInboardBody(void)
+  { return 0; }
 
   /** Set the relative velocity.
    */
   void setRelVel(const Vector6& vel)
-  { Joint::setOutboardRelVel(vel); }
+  { mFrame->setRelVel(vel); }
   /** Set the relative velocity.
    */
   void setLinearRelVel(const Vector3& vel)
   {
-    FreeFrame* topBody = getOutboardBody()->getFreeFrame();
-    if (!topBody)
-      return;
-    topBody->setLinearRelVel(vel);
+    mFrame->setLinearRelVel(vel);
   }
   /** Set the relative velocity.
    */
   void setAngularRelVel(const Vector3& vel)
   {
-    FreeFrame* topBody = getOutboardBody()->getFreeFrame();
-    if (!topBody)
-      return;
-    topBody->setAngularRelVel(vel);
+    mFrame->setAngularRelVel(vel);
   }
 
   /** Set the reference position.
    */
   void setRefPosition(const Vector3& p)
   {
-    FreeFrame* topBody = getOutboardBody()->getFreeFrame();
-    if (!topBody)
-      return;
-    topBody->setRefPosition(p);
+    mFrame->setRefPosition(p);
   }
   /** Set the reference orientation.
    */
   void setRefOrientation(const Quaternion& o)
   {
-    FreeFrame* topBody = getOutboardBody()->getFreeFrame();
-    if (!topBody)
-      return;
-    topBody->setRefOrientation(o);
+    mFrame->setRefOrientation(o);
   }
 
 private:
@@ -102,9 +110,17 @@
    */
   virtual void getStateDeriv(Vector& state, unsigned offset);
 
-  /** Reference to the vehicles environment.
-   */
+  /// The initial states which are used for the first guess
+  Vector3 mInitialPosition;
+  Quaternion mInitialOrientation;
+  Vector6 mInitialVel;
+
+  /// The commonly used gravity model from the environment class
+  /// It is initialized at the init() call
   SharedPtr<const Gravity> mGravity;
+
+  /// The frame of the mobile root
+  SharedPtr<FreeFrame> mFrame;
 };
 
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/Interact.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Interact.cpp	2005-12-26 13:43:09 UTC (rev 124)
+++ trunk/OpenFDM/src/OpenFDM/Interact.cpp	2005-12-26 19:09:51 UTC (rev 125)
@@ -45,6 +45,7 @@
   for (it = mParents.begin(); it != mParents.end(); ++it) {
     if ((*it) == 0) {
       (*it) = rigidBody;
+      recheckTopology();
       return true;
     }
   }
@@ -67,6 +68,7 @@
   for (it = mParents.begin(); it != mParents.end(); ++it) {
     if ((*it) == rigidBody) {
       (*it) = 0;
+      recheckTopology();
       return true;
     }
   }

Modified: trunk/OpenFDM/src/OpenFDM/Interact.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Interact.h	2005-12-26 13:43:09 UTC (rev 124)
+++ trunk/OpenFDM/src/OpenFDM/Interact.h	2005-12-26 19:09:51 UTC (rev 125)
@@ -36,6 +36,10 @@
   bool attachTo(RigidBody* rigidBody);
   bool detachFrom(RigidBody* rigidBody);
 
+  /// Called whenever the local topology chages, use to manage frames with this
+  /// interact
+  virtual void recheckTopology(void) {}
+
   friend class RigidBody;
 
 public:
@@ -50,7 +54,15 @@
     OpenFDMAssert(id < mParents.size());
     return mParents[id];
   }
+  void swapParents(void)
+  {
+    OpenFDMAssert(2 == mParents.size());
+    WeakPtr<RigidBody> rigidBody = mParents[0];
+    mParents[0] = mParents[1];
+    mParents[1] = rigidBody;
+  }
 
+
   virtual void interactWith(RigidBody* rigidBody) = 0;
 
 

Modified: trunk/OpenFDM/src/OpenFDM/Joint.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Joint.h	2005-12-26 13:43:09 UTC (rev 124)
+++ trunk/OpenFDM/src/OpenFDM/Joint.h	2005-12-26 19:09:51 UTC (rev 125)
@@ -114,6 +114,20 @@
       return getParentRigidBody(0);
     return 0;
   }
+  virtual RigidBody* getInboardBody(void)
+  {
+    const Frame* parent0 = getParentFrame(0);
+    if (!parent0)
+      return 0;
+    const Frame* parent1 = getParentFrame(1);
+    if (!parent1)
+      return 0;
+    if (parent1->isParentFrame(parent0))
+      return getParentRigidBody(0);
+    if (parent0->isParentFrame(parent1))
+      return getParentRigidBody(1);
+    return 0;
+  }
 
   virtual void interactWith(RigidBody* rigidBody)
   {
@@ -121,7 +135,7 @@
     if (!isArticulatedJoint())
       return;
 
-    if (rigidBody->getFrame() != getInboardGroup())
+    if (rigidBody != getInboardBody())
       return;
 
     getOutboardBody()->computeArtValues();
@@ -134,11 +148,12 @@
 
   bool contributeArticulation(SpatialInertia& artI, Vector6& artF)
   {
-    Frame* frame = getOutboardGroup();
     RigidBody* outboardBody = getOutboardBody();
     if (!outboardBody)
       return false;
 
+    Frame* frame = outboardBody->getFrame();
+
     Log(ArtBody, Debug) << "Contributing articulation from \""
                         << outboardBody->getName() << "\" through joint \""
                         << getName() << "\"" << endl;

Modified: trunk/OpenFDM/src/OpenFDM/MultiBodySystem.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/MultiBodySystem.cpp	2005-12-26 13:43:09 UTC (rev 124)
+++ trunk/OpenFDM/src/OpenFDM/MultiBodySystem.cpp	2005-12-26 19:09:51 UTC (rev 125)
@@ -18,9 +18,8 @@
 
 namespace OpenFDM {
 
-MultiBodySystem::MultiBodySystem(RootFrame* rootFrame) :
-  ModelGroup("multibodymodel"),
-  mRootFrame(rootFrame)
+MultiBodySystem::MultiBodySystem(const std::string& name) :
+  ModelGroup(name)
 {
   // FIXME
   addSampleTime(SampleTime::PerTimestep);

Modified: trunk/OpenFDM/src/OpenFDM/MultiBodySystem.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/MultiBodySystem.h	2005-12-26 13:43:09 UTC (rev 124)
+++ trunk/OpenFDM/src/OpenFDM/MultiBodySystem.h	2005-12-26 19:09:51 UTC (rev 125)
@@ -23,7 +23,7 @@
 class MultiBodySystem :
     public ModelGroup {
 public:
-  MultiBodySystem(RootFrame* rootFrame);
+  MultiBodySystem(const std::string& name);
   virtual ~MultiBodySystem(void);
 
   /// Double dispatch helper for the multibody system visitor
@@ -42,11 +42,6 @@
   void addInteract(Interact* interact);
   void removeInteract(Interact* interact);
 private:
-  /// At the moment each MultiBodySystem has its own root frame,
-  /// In the future just store the root joint and reference a common root frame
-  /// move that to environment
-  SharedPtr<RootFrame> mRootFrame;
-
   /// That is the root for now ...
   SharedPtr<FreeJoint> mFreeJoint;
 

Modified: trunk/OpenFDM/src/OpenFDM/RigidBody.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RigidBody.cpp	2005-12-26 13:43:09 UTC (rev 124)
+++ trunk/OpenFDM/src/OpenFDM/RigidBody.cpp	2005-12-26 19:09:51 UTC (rev 125)
@@ -14,8 +14,6 @@
 #include "Mass.h"
 #include "Joint.h"
 #include "MultiBodySystem.h"
-#include "Visitor.h"
-#include "ConstVisitor.h"
 #include "RigidBody.h"
 
 namespace OpenFDM {
@@ -31,18 +29,6 @@
 }
 
 void
-RigidBody::accept(Visitor& visitor)
-{
-  visitor.apply(*this);
-}
-
-void
-RigidBody::accept(ConstVisitor& visitor) const
-{
-  visitor.apply(*this);
-}
-
-void
 RigidBody::computeArtValues(void)
 {
   Log(ArtBody, Debug) << "Entry of computeArtValues of \"" << getName()
@@ -116,6 +102,8 @@
   for (it = mInteracts.begin(); it != mInteracts.end(); ++it) {
     if ((*it) == interact) {
       mInteracts.erase(it);
+      if (!interact->detachFrom(this))
+        return false;
       return true;
     }
   }

Modified: trunk/OpenFDM/src/OpenFDM/RigidBody.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RigidBody.h	2005-12-26 13:43:09 UTC (rev 124)
+++ trunk/OpenFDM/src/OpenFDM/RigidBody.h	2005-12-26 19:09:51 UTC (rev 125)
@@ -32,15 +32,12 @@
 
   /** Constructor.
    */
-  RigidBody(const std::string& name = std::string());
+  RigidBody(const std::string& name);
   /** Destructor.
    */
   virtual ~RigidBody(void);
 
-  virtual void accept(Visitor& visitor);
-  virtual void accept(ConstVisitor& visitor) const;
 
-
 // protected:
   /** Compute articulated values outboard including this body.
       That function is part of the articulated body algorithm.
@@ -99,14 +96,16 @@
 
   /** Introduce an interface routine
    */
+  void setFrame(Frame* frame)
+  {
+    // take over all children
+    frame->reparentChildren(mFrame);
+    mFrame = frame;
+  }
   Frame* getFrame(void)
   { return mFrame; }
   const Frame* getFrame(void) const
   { return mFrame; }
-  FreeFrame* getFreeFrame(void)
-  { return mFrame; }
-  const FreeFrame* getFreeFrame(void) const
-  { return mFrame; }
 
   void setParentMultiBodySystem(MultiBodySystem* multiBodySystem);
   MultiBodySystem* getParentMultiBodySystem(void);
@@ -125,8 +124,7 @@
 //   SpatialInertia mLocalInertia;
 
   /// Frame attached to this rigid body
-//   SharedPtr<Frame> mFrame;
-  SharedPtr<FreeFrame> mFrame;
+  SharedPtr<Frame> mFrame;
 
   typedef std::vector<SharedPtr<Interact> > InteractList;
   InteractList mInteracts;

Modified: trunk/OpenFDM/src/OpenFDM/Vehicle.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Vehicle.cpp	2005-12-26 13:43:09 UTC (rev 124)
+++ trunk/OpenFDM/src/OpenFDM/Vehicle.cpp	2005-12-26 19:09:51 UTC (rev 125)
@@ -9,7 +9,6 @@
 #include "Force.h"
 #include "RigidBody.h"
 #include "FreeJoint.h"
-#include "RootFrame.h"
 #include "Planet.h"
 #include "Wind.h"
 #include "ExplicitEuler.h"
@@ -26,13 +25,7 @@
 
 Vehicle::Vehicle(void)
 {
-  // The Planet centered frame is used by the others!
-  mRootFrame = new RootFrame("Planet centered frame");
-  Vector3 earthRotation(0.0, 0.0, pi2/(60*60*24));
-  mRootFrame->setAngularRelVel(earthRotation);
-
   mTopBody = new RigidBody("Topmost rigid body");
-  mRootFrame->addChildFrame(mTopBody->getFrame());
 
   mFreeJoint = new FreeJoint("Mobile vehicle base");
   mTopBody->addInteract(mFreeJoint);
@@ -41,7 +34,7 @@
 
   mModelGroup = new ModelGroup("Flight Control System");
 
-  mMultiBodySystem = new MultiBodySystem(mRootFrame);
+  mMultiBodySystem = new MultiBodySystem("Multi Body System");
   mMultiBodySystem->addRigidBody(mTopBody);
 
 //   mSystem->setTimestepper(new ExplicitAdams);

Modified: trunk/OpenFDM/src/OpenFDM/Vehicle.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Vehicle.h	2005-12-26 13:43:09 UTC (rev 124)
+++ trunk/OpenFDM/src/OpenFDM/Vehicle.h	2005-12-26 19:09:51 UTC (rev 125)
@@ -125,7 +125,6 @@
 private:
   SharedPtr<RigidBody> mTopBody;
   SharedPtr<FreeJoint> mFreeJoint;
-  SharedPtr<RootFrame> mRootFrame;
   SharedPtr<MultiBodySystem> mMultiBodySystem;
 
   SharedPtr<ModelGroup> mModelGroup;

Modified: trunk/OpenFDM/src/OpenFDM/main.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/main.cpp	2005-12-26 13:43:09 UTC (rev 124)
+++ trunk/OpenFDM/src/OpenFDM/main.cpp	2005-12-26 19:09:51 UTC (rev 125)
@@ -408,7 +408,7 @@
 
     std::list<XMLElement::const_pointer>::iterator it = rigidBodies.begin();
     while (it != rigidBodies.end()) {
-      RigidBody* rigidBody = new RigidBody();
+      RigidBody* rigidBody = new RigidBody("rigid body");
       rigidBody->setName((*it)->getAttribute("Name"));
       
 //       if (mVehicle->getRigidBody((*it)->getAttribute("Name")))
@@ -554,25 +554,6 @@
   
 } // namespace OpenFDM
 
-class StatePrintVisitor
-  : public ConstVisitor {
-public:
-  StatePrintVisitor(void) : _indent(3) {}
-  virtual ~StatePrintVisitor(void) {}
-  virtual void apply(const Frame& group)
-  {
-    std::cout << std::setw(_indent) << ""
-              << "Traversing \""
-              << group.getName() << "\", "
-              << endl;
-    _indent += 3;
-    traverse(group);
-    _indent -= 3;
-  }
-private:
-  unsigned _indent;
-};
-
 void printVehicle(Vehicle* vehicle)
 {
   cout << "T = " << vehicle->getTime()
@@ -580,8 +561,6 @@
 //        << ", Or: " << vehicle->getGeodOrientation()
        << endl;
 
-  StatePrintVisitor spv;
-  vehicle->getTopBody()->accept(spv);
 }
 
 int main(int argc, char *argv[])



From frohlich at berlios.de  Tue Dec 27 09:25:27 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Tue, 27 Dec 2005 09:25:27 +0100
Subject: [OpenFDM-svn] r126 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200512270825.jBR8PR8s006840@sheep.berlios.de>

Author: frohlich
Date: 2005-12-27 09:25:14 +0100 (Tue, 27 Dec 2005)
New Revision: 126

Removed:
   trunk/OpenFDM/src/OpenFDM/RevoluteActuator.cpp
   trunk/OpenFDM/src/OpenFDM/RevoluteActuator.h
Modified:
   trunk/OpenFDM/src/OpenFDM/Frame.cpp
   trunk/OpenFDM/src/OpenFDM/FreeJoint.cpp
   trunk/OpenFDM/src/OpenFDM/FreeJoint.h
   trunk/OpenFDM/src/OpenFDM/Interact.cpp
   trunk/OpenFDM/src/OpenFDM/Interact.h
   trunk/OpenFDM/src/OpenFDM/Joint.h
   trunk/OpenFDM/src/OpenFDM/LogStream.h
   trunk/OpenFDM/src/OpenFDM/Makefile.am
   trunk/OpenFDM/src/OpenFDM/Mass.cpp
   trunk/OpenFDM/src/OpenFDM/Mass.h
   trunk/OpenFDM/src/OpenFDM/MultiBodySystem.cpp
   trunk/OpenFDM/src/OpenFDM/MultiBodySystem.h
   trunk/OpenFDM/src/OpenFDM/PrismaticJoint.cpp
   trunk/OpenFDM/src/OpenFDM/PrismaticJoint.h
   trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp
   trunk/OpenFDM/src/OpenFDM/RevoluteJoint.h
   trunk/OpenFDM/src/OpenFDM/RigidBody.cpp
   trunk/OpenFDM/src/OpenFDM/RigidBody.h
   trunk/OpenFDM/src/OpenFDM/Vehicle.cpp
   trunk/OpenFDM/src/OpenFDM/main.cpp
Log:
Further cleanup, simple frame hierarchy building hints


Modified: trunk/OpenFDM/src/OpenFDM/Frame.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Frame.cpp	2005-12-26 19:09:51 UTC (rev 125)
+++ trunk/OpenFDM/src/OpenFDM/Frame.cpp	2005-12-27 08:25:14 UTC (rev 126)
@@ -3,6 +3,7 @@
  */
 
 #include "Assert.h"
+#include "LogStream.h"
 #include "Object.h"
 #include "Vector.h"
 #include "Matrix.h"
@@ -80,16 +81,18 @@
 bool
 Frame::addChildFrame(Frame* child)
 {
-  if (!child)
+  if (!child) {
+    Log(Frame,Warning) << "Trying to attach zero pointer child Frame to "
+                       << "Frame \"" << getName() << "\"!" << endl;
     return false;
-  // check if it is already there. Emit an error in this caes.
-  ChildFrameList::iterator it = mChildFrames.begin();
-  ChildFrameList::iterator iEnd = mChildFrames.end();
-  while (it != iEnd) {
-    if ((*it) == child)
-      return false;
-    ++it;
   }
+  if (child->getParentFrame()) {
+    Log(Frame,Error) << "Can not attach Frame \"" << child->getName()
+                     << "\" to Frame \"" << getName() << "\": "
+                     << " is already child of \""
+                     << child->getParentFrame()->getName() << endl;
+    return false;
+  }
   
   child->setParentFrame(this);
   mChildFrames.push_back(child);
@@ -107,6 +110,7 @@
     }
     ++it;
   }
+
   return false;
 }
 
@@ -126,17 +130,34 @@
   return mChildFrames[i];
 }
 
+// class PrintVisitor : public ConstVisitor {
+// public:
+//   virtual void apply(const Frame& frame)
+//   {
+//     Log(Model,Error) << frame.getName() << endl;
+//     traverse(frame);
+//   }
+// };
+
 void
 Frame::reparentChildren(Frame* frame)
 {
   if (!frame)
     return;
+
+//   PrintVisitor pv;
+//   frame->accept(pv);
+
   ChildFrameList::iterator it = frame->mChildFrames.begin();
   while (it != frame->mChildFrames.end()) {
-    (*it)->setParentFrame(0);
-    addChildFrame(*it);
+    Log(Model,Error) << "Moving Frame " << (*it)->getName() << " from "
+                     << frame->getName() << " to " << getName() << endl;
+    (*it)->setParentFrame(this);
+    mChildFrames.push_back(*it);
     it = frame->mChildFrames.erase(it);
   }
+
+//   frame->accept(pv);
 }
 
 void

Modified: trunk/OpenFDM/src/OpenFDM/FreeJoint.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/FreeJoint.cpp	2005-12-26 19:09:51 UTC (rev 125)
+++ trunk/OpenFDM/src/OpenFDM/FreeJoint.cpp	2005-12-27 08:25:14 UTC (rev 126)
@@ -58,7 +58,7 @@
 {
   // Hmm, works for the first cut, but rethink what happens with strange
   // attach reattach sequences ...
-  RigidBody* rigidBody = getParentRigidBody(0);
+  RigidBody* rigidBody = getOutboardBody();
   if (!rigidBody)
     return;
   // check if already done
@@ -66,10 +66,10 @@
     rigidBody->setFrame(mFrame);
 
   // Check if we are attached to some rigid body ...
-  rigidBody = getParentRigidBody(1);
+  rigidBody = getInboardBody();
   if (rigidBody) {
     Frame* frame = rigidBody->getFrame();
-    if (!frame->isParentFrame(mFrame))
+    if (frame && !frame->isParentFrame(mFrame))
       frame->addChildFrame(mFrame);
   } else {
     Environment* environment = getEnvironment();
@@ -107,21 +107,21 @@
   Log(ArtBody, Debug) << "grav = " << trans(grav) << endl;
   Log(ArtBody, Debug) << "solve = " << trans(solve(artI, artF)) << endl;
   Log(ArtBody, Debug) << "parent spatial accel = " << trans(mFrame->getParentSpAccel()) << endl;
-  Log(ArtBody, Debug) << "Hdot = " << trans(getHdot()) << endl;
+  Log(ArtBody, Debug) << "Hdot = " << trans(mFrame->getHdot()) << endl;
   
 
   Vector6 accel = grav - solve(artI, artF)
-    - mFrame->getParentSpAccel() - getHdot();
+    - mFrame->getParentSpAccel() - mFrame->getHdot();
   return accel;
 }
 
 void
 FreeJoint::setState(const Vector& state, unsigned offset)
 {
-  setOutboardOrientation(Vector4(state(offset+1), state(offset+2),
-                         state(offset+3), state(offset+4)));
-  setOutboardPosition(Vector3(state(offset+5), state(offset+6), state(offset+7)));
-  setOutboardRelVel(Vector6(state(offset+8), state(offset+9), state(offset+10),
+  mFrame->setOrientation(Vector4(state(offset+1), state(offset+2),
+                                 state(offset+3), state(offset+4)));
+  mFrame->setPosition(Vector3(state(offset+5), state(offset+6), state(offset+7)));
+  mFrame->setRelVel(Vector6(state(offset+8), state(offset+9), state(offset+10),
                             state(offset+11), state(offset+12), state(offset+13)));
 }
 

Modified: trunk/OpenFDM/src/OpenFDM/FreeJoint.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/FreeJoint.h	2005-12-26 19:09:51 UTC (rev 125)
+++ trunk/OpenFDM/src/OpenFDM/FreeJoint.h	2005-12-27 08:25:14 UTC (rev 126)
@@ -26,69 +26,24 @@
 
   virtual bool init(void);
 
-  const Vector3& getInitialPosition(void) const
-  { return mInitialPosition; }
-  void setInitialPosition(const Vector3& pos)
-  { mInitialPosition = pos; }
-
-  const Quaternion& getInitialOrientation(void) const
-  { return mInitialOrientation; }
-  void setInitialOrientation(const Quaternion& orientation)
-  { mInitialOrientation = orientation; }
-
-  const Vector6& getInitialVel(void) const
-  { return mInitialVel; }
-  void setInitialVel(const Vector6& vel)
-  { mInitialVel = vel; }
-
   virtual void recheckTopology(void);
 
-
-  /// HACK
-  virtual bool isArticulatedJoint(void) const
-  { return true; }
-  virtual Frame* getInboardGroup(void)
-  { return 0; }
-  virtual const Frame* getInboardGroup(void) const
-  { return 0; }
-  virtual Frame* getOutboardGroup(void)
-  { return getParentFrame(0); }
-  virtual const Frame* getOutboardGroup(void) const
-  { return getParentFrame(0); }
-  virtual RigidBody* getOutboardBody(void)
-  { return getParentRigidBody(0); }
-  virtual RigidBody* getInboardBody(void)
-  { return 0; }
-
-  /** Set the relative velocity.
-   */
+  /// Set the relative velocity.
   void setRelVel(const Vector6& vel)
   { mFrame->setRelVel(vel); }
-  /** Set the relative velocity.
-   */
+  /// Set the relative velocity.
   void setLinearRelVel(const Vector3& vel)
-  {
-    mFrame->setLinearRelVel(vel);
-  }
-  /** Set the relative velocity.
-   */
+  { mFrame->setLinearRelVel(vel); }
+  /// Set the relative velocity.
   void setAngularRelVel(const Vector3& vel)
-  {
-    mFrame->setAngularRelVel(vel);
-  }
+  { mFrame->setAngularRelVel(vel); }
 
-  /** Set the reference position.
-   */
+  /// Set the reference position.
   void setRefPosition(const Vector3& p)
-  {
-    mFrame->setRefPosition(p);
-  }
-  /** Set the reference orientation.
-   */
+  { mFrame->setRefPosition(p); }
+  /// Set the reference orientation.
   void setRefOrientation(const Quaternion& o)
-  {
-    mFrame->setRefOrientation(o);
-  }
+  { mFrame->setRefOrientation(o); }
 
 private:
   /** Plugin function for the articulated body algorithm.
@@ -110,11 +65,6 @@
    */
   virtual void getStateDeriv(Vector& state, unsigned offset);
 
-  /// The initial states which are used for the first guess
-  Vector3 mInitialPosition;
-  Quaternion mInitialOrientation;
-  Vector6 mInitialVel;
-
   /// The commonly used gravity model from the environment class
   /// It is initialized at the init() call
   SharedPtr<const Gravity> mGravity;

Modified: trunk/OpenFDM/src/OpenFDM/Interact.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Interact.cpp	2005-12-26 19:09:51 UTC (rev 125)
+++ trunk/OpenFDM/src/OpenFDM/Interact.cpp	2005-12-27 08:25:14 UTC (rev 126)
@@ -35,7 +35,7 @@
 }
 
 bool
-Interact::attachTo(RigidBody* rigidBody)
+Interact::attachTo(RigidBody* rigidBody, bool upstream)
 {
   if (!rigidBody) {
     Log(MultiBody,Error) << "Got 0 RigidBody pointer to attach to." << endl;
@@ -45,6 +45,8 @@
   for (it = mParents.begin(); it != mParents.end(); ++it) {
     if ((*it) == 0) {
       (*it) = rigidBody;
+      if (upstream && it != mParents.begin())
+        swapParents();
       recheckTopology();
       return true;
     }

Modified: trunk/OpenFDM/src/OpenFDM/Interact.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Interact.h	2005-12-26 19:09:51 UTC (rev 125)
+++ trunk/OpenFDM/src/OpenFDM/Interact.h	2005-12-27 08:25:14 UTC (rev 126)
@@ -32,8 +32,13 @@
   /// Double dispatch helper for the multibody system visitor
 //   virtual void accept(ConstModelVisitor& visitor) const;
 
+  /// This is the primary gate function which handles interaction
+  virtual void interactWith(RigidBody* rigidBody) = 0;
+
+
+
 private:
-  bool attachTo(RigidBody* rigidBody);
+  bool attachTo(RigidBody* rigidBody, bool upstream);
   bool detachFrom(RigidBody* rigidBody);
 
   /// Called whenever the local topology chages, use to manage frames with this
@@ -57,16 +62,12 @@
   void swapParents(void)
   {
     OpenFDMAssert(2 == mParents.size());
-    WeakPtr<RigidBody> rigidBody = mParents[0];
+    RigidBody* rigidBody = mParents[0];
     mParents[0] = mParents[1];
     mParents[1] = rigidBody;
   }
 
 
-  virtual void interactWith(RigidBody* rigidBody) = 0;
-
-
-
   /// FIXME: hmm
   virtual bool updateAccels(RigidBody*) { return true; }
 

Modified: trunk/OpenFDM/src/OpenFDM/Joint.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Joint.h	2005-12-26 19:09:51 UTC (rev 125)
+++ trunk/OpenFDM/src/OpenFDM/Joint.h	2005-12-27 08:25:14 UTC (rev 126)
@@ -28,113 +28,14 @@
   /// FIXME: joint's should be lockable, which means trylock == true and
   /// velocity small enough - keep position ...
 
+  RigidBody* getOutboardBody(void)
+  { return getParentRigidBody(0); }
+  RigidBody* getInboardBody(void)
+  { return getParentRigidBody(1); }
 
-  virtual bool isArticulatedJoint(void) const
-  {
-    const Frame* parent0 = getParentFrame(0);
-    if (!parent0)
-      return false;
-    const Frame* parent1 = getParentFrame(1);
-    if (!parent1)
-      return false;
-    if (parent1->isParentFrame(parent0))
-      return true;
-    if (parent0->isParentFrame(parent1))
-      return true;
-    return false;
-  }
-
-  virtual Frame* getInboardGroup(void)
-  {
-    Frame* parent0 = getParentFrame(0);
-    if (!parent0)
-      return 0;
-    Frame* parent1 = getParentFrame(1);
-    if (!parent1)
-      return 0;
-    if (parent1->isParentFrame(parent0))
-      return parent0;
-    if (parent0->isParentFrame(parent1))
-      return parent1;
-    return 0;
-  }
-  virtual const Frame* getInboardGroup(void) const
-  {
-    const Frame* parent0 = getParentFrame(0);
-    if (!parent0)
-      return 0;
-    const Frame* parent1 = getParentFrame(1);
-    if (!parent1)
-      return 0;
-    if (parent1->isParentFrame(parent0))
-      return parent0;
-    if (parent0->isParentFrame(parent1))
-      return parent1;
-    return 0;
-  }
-  virtual Frame* getOutboardGroup(void)
-  {
-    Frame* parent0 = getParentFrame(0);
-    if (!parent0)
-      return 0;
-    Frame* parent1 = getParentFrame(1);
-    if (!parent1)
-      return 0;
-    if (parent1->isParentFrame(parent0))
-      return parent1;
-    if (parent0->isParentFrame(parent1))
-      return parent0;
-    return 0;
-  }
-  virtual const Frame* getOutboardGroup(void) const
-  {
-    const Frame* parent0 = getParentFrame(0);
-    if (!parent0)
-      return 0;
-    const Frame* parent1 = getParentFrame(1);
-    if (!parent1)
-      return 0;
-    if (parent1->isParentFrame(parent0))
-      return parent1;
-    if (parent0->isParentFrame(parent1))
-      return parent0;
-    return 0;
-  }
-  virtual RigidBody* getOutboardBody(void)
-  {
-    Frame* parent0 = getParentFrame(0);
-    if (!parent0)
-      return 0;
-    Frame* parent1 = getParentFrame(1);
-    if (!parent1)
-      return 0;
-    if (parent1->isParentFrame(parent0))
-      return getParentRigidBody(1);
-    if (parent0->isParentFrame(parent1))
-      return getParentRigidBody(0);
-    return 0;
-  }
-  virtual RigidBody* getInboardBody(void)
-  {
-    const Frame* parent0 = getParentFrame(0);
-    if (!parent0)
-      return 0;
-    const Frame* parent1 = getParentFrame(1);
-    if (!parent1)
-      return 0;
-    if (parent1->isParentFrame(parent0))
-      return getParentRigidBody(0);
-    if (parent0->isParentFrame(parent1))
-      return getParentRigidBody(1);
-    return 0;
-  }
-
   virtual void interactWith(RigidBody* rigidBody)
   {
     // HMmMm
-    if (!isArticulatedJoint())
-      return;
-
     if (rigidBody != getInboardBody())
       return;
 
@@ -188,13 +89,6 @@
   virtual Vector6 computeRelAccel(const SpatialInertia& artI,
                                   const Vector6& artF) = 0;
 
-  // FIXME: just for compatibility
-  Vector6 getHdot()
-  {
-    Frame* frame = getOutboardGroup();
-    return frame->getHdot();
-  }
-
   //???
   bool updateAccels(RigidBody* rigidBody)
   {
@@ -206,73 +100,23 @@
       return false;
 
     // Set the local acceleration
-    setOutboardRelAccel(computeRelAccel(outboardBody->getArtInertia(),
-                                        outboardBody->getArtForce()));
+    Vector6 accel = computeRelAccel(outboardBody->getArtInertia(),
+                                    outboardBody->getArtForce());
     
-    outboardBody->computeAccel();
-
-    return true;
-  }
-
-
-  Quaternion mOrientation[2];
-  Vector3 mPosition[2];
-
-protected:
-  void setOutboardState(const Vector3& pos, const Quaternion& orient,
-                        const Vector6& vel)
-  {
-    Frame* frame0 = getOutboardGroup();
+    Frame* frame0 = outboardBody->getFrame();
+    if (!frame0)
+      return false;
     FreeFrame* frame = dynamic_cast<FreeFrame*>(frame0);
     if (!frame)
-      return;
+      return false;
 
-    frame->disableAccel();
-    frame->setPosition(pos);
-    frame->setOrientation(orient);
-    frame->setRelVel(vel);
-  }
+    frame->enableAccel();
+    frame->setRelAccel(accel);
 
-  void setOutboardPosition(const Vector3& pos)
-  {
-    Frame* frame0 = getOutboardGroup();
-    FreeFrame* frame = dynamic_cast<FreeFrame*>(frame0);
-    if (!frame)
-      return;
+    outboardBody->computeAccel();
 
-    frame->disableAccel();
-    frame->setPosition(pos);
+    return true;
   }
-  void setOutboardOrientation(const Quaternion& orient)
-  {
-    Frame* frame0 = getOutboardGroup();
-    FreeFrame* frame = dynamic_cast<FreeFrame*>(frame0);
-    if (!frame)
-      return;
-
-    frame->disableAccel();
-    frame->setOrientation(orient);
-  }
-  void setOutboardRelVel(const Vector6& vel)
-  {
-    Frame* frame0 = getOutboardGroup();
-    FreeFrame* frame = dynamic_cast<FreeFrame*>(frame0);
-    if (!frame)
-      return;
-
-    frame->disableAccel();
-    frame->setRelVel(vel);
-  }
-  void setOutboardRelAccel(const Vector6& accel)
-  {
-    Frame* frame0 = getOutboardGroup();
-    FreeFrame* frame = dynamic_cast<FreeFrame*>(frame0);
-    if (!frame)
-      return;
-
-    frame->enableAccel();
-    frame->setRelAccel(accel);
-  }
 };
 
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/LogStream.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/LogStream.h	2005-12-26 19:09:51 UTC (rev 125)
+++ trunk/OpenFDM/src/OpenFDM/LogStream.h	2005-12-27 08:25:14 UTC (rev 126)
@@ -18,7 +18,8 @@
   TimeStep         = MultiBody << 1,
   BoundCheck       = TimeStep << 1,
   Environment      = BoundCheck << 1,
-  Initialization   = Environment << 1,
+  Frame            = Environment << 1,
+  Initialization   = Frame << 1,
   NewtonMethod     = Initialization << 1,
   Misc             = NewtonMethod << 1,
   Model            = Misc << 1,

Modified: trunk/OpenFDM/src/OpenFDM/Makefile.am
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Makefile.am	2005-12-26 19:09:51 UTC (rev 125)
+++ trunk/OpenFDM/src/OpenFDM/Makefile.am	2005-12-27 08:25:14 UTC (rev 126)
@@ -99,7 +99,6 @@
   Quaternion.h \
   ReaderWriter.h \
   Referenced.h \
-  RevoluteActuator.h \
   RevoluteJoint.h \
   RigidBody.h \
   Rotation.h \
@@ -185,7 +184,6 @@
   Product.cpp \
   Property.cpp \
   ReaderWriter.cpp \
-  RevoluteActuator.cpp \
   RevoluteJoint.cpp \
   RigidBody.cpp \
   RootFrame.cpp \

Modified: trunk/OpenFDM/src/OpenFDM/Mass.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Mass.cpp	2005-12-26 19:09:51 UTC (rev 125)
+++ trunk/OpenFDM/src/OpenFDM/Mass.cpp	2005-12-27 08:25:14 UTC (rev 126)
@@ -6,7 +6,7 @@
 
 namespace OpenFDM {
 
-Mass::Mass(const SpatialInertia& inertia, const std::string& name) :
+Mass::Mass(const std::string& name, const SpatialInertia& inertia) :
   Interact(name, 1),
   mInertia(inertia)
 {

Modified: trunk/OpenFDM/src/OpenFDM/Mass.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Mass.h	2005-12-26 19:09:51 UTC (rev 125)
+++ trunk/OpenFDM/src/OpenFDM/Mass.h	2005-12-27 08:25:14 UTC (rev 126)
@@ -13,8 +13,8 @@
 class Mass :
     public Interact {
 public:
-  Mass(const SpatialInertia& inertia = SpatialInertia(0),
-       const std::string& name = std::string());
+  Mass(const std::string& name,
+       const SpatialInertia& inertia = SpatialInertia(0));
   virtual ~Mass(void);
 
   virtual void interactWith(RigidBody* rigidBody);

Modified: trunk/OpenFDM/src/OpenFDM/MultiBodySystem.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/MultiBodySystem.cpp	2005-12-26 19:09:51 UTC (rev 125)
+++ trunk/OpenFDM/src/OpenFDM/MultiBodySystem.cpp	2005-12-27 08:25:14 UTC (rev 126)
@@ -10,7 +10,7 @@
 #include "Inertia.h"
 #include "Frame.h"
 #include "RigidBody.h"
-#include "Visitor.h"
+#include "ConstVisitor.h"
 #include "ModelVisitor.h"
 #include "Mass.h"
 #include "Force.h"
@@ -36,14 +36,11 @@
   visitor.apply(*this);
 }
 
-// bool
-// MultiBodySystem::init(void)
-// {
-//   StateCountVisitor gsc;
-//   mRootFrame->accept(gsc);
-//   setNumContinousStates(gsc.getStateCount());
-//   return ModelGroup::init();
-// }
+bool
+MultiBodySystem::init(void)
+{
+  return ModelGroup::init();
+}
 
 void
 MultiBodySystem::output(const TaskInfo& taskInfo)

Modified: trunk/OpenFDM/src/OpenFDM/MultiBodySystem.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/MultiBodySystem.h	2005-12-26 19:09:51 UTC (rev 125)
+++ trunk/OpenFDM/src/OpenFDM/MultiBodySystem.h	2005-12-27 08:25:14 UTC (rev 126)
@@ -31,7 +31,7 @@
   /// Double dispatch helper for the multibody system visitor
 //   virtual void accept(ConstModelVisitor& visitor) const;
 
-//   virtual bool init(void);
+  virtual bool init(void);
   virtual void output(const TaskInfo& taskInfo);
 
   /// Add a RigidBody to that MultiBodySystem

Modified: trunk/OpenFDM/src/OpenFDM/PrismaticJoint.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/PrismaticJoint.cpp	2005-12-26 19:09:51 UTC (rev 125)
+++ trunk/OpenFDM/src/OpenFDM/PrismaticJoint.cpp	2005-12-27 08:25:14 UTC (rev 126)
@@ -26,6 +26,8 @@
   mJointAxis = Vector3::unit(1);
   mPosition = Vector3::zeros();
 
+  mFrame = new FreeFrame(name);
+
   setNumOutputPorts(2);
   setOutputPort(0, "jointPos", this, &PrismaticJoint::getJointPos);
   setOutputPort(1, "jointVel", this, &PrismaticJoint::getJointVel);
@@ -51,27 +53,27 @@
 PrismaticJoint::setJointPos(real_type pos)
 {
   mJointPosition = pos;
-  setOutboardPosition(mPosition + mJointPosition*mJointAxis);
+  mFrame->setPosition(mPosition + mJointPosition*mJointAxis);
 }
 
 void
 PrismaticJoint::setJointVel(real_type vel)
 {
   mJointVelocity = vel;
-  setOutboardRelVel(mJointVelocity*getJointAxis());
+  mFrame->setRelVel(mJointVelocity*getJointAxis());
 }
 
 void
 PrismaticJoint::setOrientation(const Quaternion& orientation)
 {
-  setOutboardPosition(mPosition + mJointPosition*mJointAxis);
+  mFrame->setPosition(mPosition + mJointPosition*mJointAxis);
 }
 
 void
 PrismaticJoint::setPosition(const Vector3& position)
 {
   mPosition = position;
-  setOutboardPosition(mPosition + mJointPosition*mJointAxis);
+  mFrame->setPosition(mPosition + mJointPosition*mJointAxis);
 }
 
 bool
@@ -90,9 +92,9 @@
 PrismaticJoint::computeRelAccel(const SpatialInertia&,
                                 const Vector6&)
 {
+  Vector6 parentAccel = mFrame->getParentSpAccel();
+
   RigidBody* out = getOutboardBody();
-  Vector6 parentAccel = out->getFrame()->getParentSpAccel();
-
   SpatialInertia artI = out->getArtInertia();
   Vector6 pAlpha = out->getPAlpha();
 

Modified: trunk/OpenFDM/src/OpenFDM/PrismaticJoint.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/PrismaticJoint.h	2005-12-26 19:09:51 UTC (rev 125)
+++ trunk/OpenFDM/src/OpenFDM/PrismaticJoint.h	2005-12-27 08:25:14 UTC (rev 126)
@@ -22,9 +22,32 @@
 class PrismaticJoint
   : public Joint, public JointT<1> {
 public:
-  PrismaticJoint(const std::string& name = std::string());
+  PrismaticJoint(const std::string& name);
   virtual ~PrismaticJoint(void);
 
+  virtual bool init(void)
+  { recheckTopology(); return Joint::init(); }
+
+  virtual void recheckTopology(void)
+  {
+    if (!getOutboardBody() || !getInboardBody())
+      return;
+
+    // check for the inboard frame
+    Frame* inFrame = getInboardBody()->getFrame();
+    if (!inFrame)
+      return;
+
+    Frame* outFrame = getOutboardBody()->getFrame();
+    if (!outFrame) {
+      getOutboardBody()->setFrame(mFrame);
+    }
+    outFrame = getOutboardBody()->getFrame();
+    if (!outFrame->isParentFrame(inFrame)) {
+      inFrame->addChildFrame(mFrame);
+    }
+  }
+
   /** Gets the joint axis where this joint is allowed to rotate around.
    */
   Vector6 getJointAxis(void) const
@@ -117,6 +140,9 @@
   /** The direct joint interaction force
    */
   SharedPtr<LineForce> mLineForce;
+
+  /// The frame of the mobile root
+  SharedPtr<FreeFrame> mFrame;
 };
 
 } // namespace OpenFDM

Deleted: trunk/OpenFDM/src/OpenFDM/RevoluteActuator.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RevoluteActuator.cpp	2005-12-26 19:09:51 UTC (rev 125)
+++ trunk/OpenFDM/src/OpenFDM/RevoluteActuator.cpp	2005-12-27 08:25:14 UTC (rev 126)
@@ -1,133 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
- *
- */
-
-#include "Assert.h"
-#include "LogStream.h"
-#include "Object.h"
-#include "Limits.h"
-#include "Vector.h"
-#include "Matrix.h"
-#include "Quaternion.h"
-#include "Inertia.h"
-#include "Frame.h"
-#include "RigidBody.h"
-#include "RevoluteActuator.h"
-
-namespace OpenFDM {
-
-RevoluteActuator::RevoluteActuator(const std::string& name)
-  : Joint(name)
-{
-}
-
-RevoluteActuator::~RevoluteActuator(void)
-{
-}
-
-void
-RevoluteActuator::setJointAxis(const Vector3& axis)
-{
-  real_type nrm = norm(axis);
-  if (nrm < Limits<real_type>::min()) {
-    Log(Initialization, Error) << "JointAxis is zero ..." << endl;
-    return;
-  }
-
-  mJointAxis = (1/nrm)*axis;
-}
-
-void
-RevoluteActuator::setJointPos(real_type pos)
-{
-  mJointPos = pos;
-  Quaternion q = mOrientation;
-  q *= Quaternion::fromAngleAxis(mJointPos, mJointAxis);
-  setOutboardOrientation(q);
-}
-
-void
-RevoluteActuator::setJointVel(real_type vel)
-{
-  mJointVel = vel;
-  setOutboardRelVel(mJointVel*getJointAxis());
-}
-
-void
-RevoluteActuator::setPosition(const Vector3& position)
-{
-  setOutboardPosition(position);
-}
-
-void
-RevoluteActuator::setOrientation(const Quaternion& orientation)
-{
-  mOrientation = orientation;
-  Quaternion q = orientation;
-  q *= Quaternion::fromAngleAxis(mJointPos, mJointAxis);
-  setOutboardOrientation(q);
-}
-
-// bool
-// RevoluteJoint::jointArticulation(SpatialInertia& artI, Vector6& artF)
-// {
-// }
-
-Vector6
-RevoluteActuator::computeRelAccel(void)
-{
-  return mJointAccel*getJointAxis();
-}
-
-void
-RevoluteActuator::output(const TaskInfo&)
-{
-  /*FIXME*/
-}
-
-void
-RevoluteActuator::update(const TaskInfo& taskInfo)
-{
-  Log(ArtBody, Debug) << __PRETTY_FUNCTION__ << " " << getName() << endl;
-
-  // FIXME
-  real_type h = (*taskInfo.getSampleTimeSet().begin()).getSampleTime();
-
-  if (mLocked) {
-    mJointVel = 0;
-    mJointAccel = 0;
-    setJointPos(mJointPos);
-    setJointVel(mJointVel);
-    return;
-  }
-
-  real_type Pp = 1;
-  real_type Pv = 1;
-
-  if (mCtrlMode == PositionControl) {
-    real_type posErr = mJointPos - mDesiredPos;
-    mDesiredVel = Pp*posErr;
-    mDesiredVel = max(mDesiredVel, mMinVel);
-    mDesiredVel = min(mDesiredVel, mMaxVel);
-
-    Log(ArtBody, Debug) << " posErr = " << posErr << endl;
-  }
-  real_type velErr = mJointVel - mDesiredVel;
-  mJointAccel = Pv*velErr;
-  mJointAccel = max(mJointAccel, mMinAccel);
-  mJointAccel = min(mJointAccel, mMaxAccel);
-
-  Log(ArtBody, Debug) << " velErr = " << velErr << endl;
-
-  // Integrate
-  mJointPos += h*mJointVel;
-  mJointVel += h*mJointAccel;
-
-  setJointPos(mJointPos);
-  setJointVel(mJointVel);
-
-  Log(ArtBody, Debug) << " vel = " << mJointVel << " accel = " << mJointAccel
-                      << endl;
-}
-
-} // namespace OpenFDM

Deleted: trunk/OpenFDM/src/OpenFDM/RevoluteActuator.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RevoluteActuator.h	2005-12-26 19:09:51 UTC (rev 125)
+++ trunk/OpenFDM/src/OpenFDM/RevoluteActuator.h	2005-12-27 08:25:14 UTC (rev 126)
@@ -1,148 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
- *
- */
-
-#ifndef OpenFDM_RevoluteActuator_H
-#define OpenFDM_RevoluteActuator_H
-
-#include "Assert.h"
-#include "Object.h"
-#include "Vector.h"
-#include "Matrix.h"
-#include "Quaternion.h"
-#include "Inertia.h"
-#include "Frame.h"
-#include "RigidBody.h"
-#include "Joint.h"
-
-namespace OpenFDM {
-
-class RevoluteActuator
-  : public Joint {
-public:
-  enum ControlMode {
-    PositionControl,
-    VelocityControl
-  };
-
-  RevoluteActuator(const std::string& name = std::string());
-  virtual ~RevoluteActuator(void);
-
-  /** Gets the joint axis where this joint is allowed to rotate around.
-   */
-  Vector6 getJointAxis(void) const
-  { return Vector6(mJointAxis, Vector3::zeros()); }
-
-  /** Sets the joint axis where this joint is allowed to rotate around.
-   */
-  void setJointAxis(const Vector3& axis);
-
-  /** Returns the joint position.
-   */
-  real_type getJointPos(void) const
-  { return mJointPos; }
-
-  /** Sets the joint position.
-   */
-  void setJointPos(real_type pos);
-
-  /** Returns the joint velocity.
-   */
-  real_type getJointVel(void) const
-  { return mJointVel; }
-
-  /** Sets the joint velocity.
-   */
-  void setJointVel(real_type vel);
-
-  void setMaxVel(real_type vel)
-  { mMaxVel = vel; }
-  real_type getMinVel(void) const
-  { return mMinVel; }
-  void setMinVel(real_type vel)
-  { mMinVel = vel; }
-  real_type getMaxVel(void) const
-  { return mMaxVel; }
-
-  void setDesiredVel(real_type vel)
-  { mDesiredVel = vel; }
-  real_type getDesiredVel(void) const
-  { return mDesiredVel; }
-
-  void setDesiredPos(real_type pos)
-  { mDesiredPos = pos; }
-  real_type getDesiredPos(void) const
-  { return mDesiredPos; }
-
-  void setControlMode(ControlMode mode)
-  { mCtrlMode = mode; }
-  ControlMode getControlMode(void) const
-  { return mCtrlMode; }
-
-  void unlock(void)
-  { mLocked = false; }
-  void lock(void)
-  { mLocked = true; }
-  void setLocked(bool locked)
-  { mLocked = locked; }
-  bool getLocked(void) const
-  { return mLocked; }
-
-  /** Set the position of the joint.
-   */
-  void setPosition(const Vector3& position);
-
-  /** Sets the zero orientation of the joint.
-   */
-  void setOrientation(const Quaternion& orientation);
-
-private:
-  /** Computes the inboard articulated inertia and force for
-      this articulated body. It is part of the articulated body algorithm.
-   */
-//   virtual bool jointArticulation(SpatialInertia& artI, Vector6& artF);
-
-  /** Computes the relative acceleration of this body with respect to its
-      parent. It is part of the articulated body algorithm.
-   */
-  virtual Vector6 computeRelAccel(void);
-
-  virtual void output(const TaskInfo&);
-  virtual void update(const TaskInfo& taskInfo);
-
-  /** The joint rotation axis.
-   */
-  Vector3 mJointAxis;
-
-  /** The relative joint rotation with respect to the zero orientation.
-   */
-  real_type mJointPos;
-
-  /** The rotational velocity with respect to the rotation axis.
-   */
-  real_type mJointVel;
-
-  real_type mMaxVel;
-  real_type mMinVel;
-  real_type mMaxAccel;
-  real_type mMinAccel;
-
-  real_type mDesiredVel;
-  real_type mDesiredPos;
-
-  /** The rotational velocity with respect to the rotation axis.
-   */
-  real_type mJointAccel;
-
-  /** The zero orientation with respect to the parent frame.
-   */
-  Quaternion mOrientation;
-
-  ControlMode mCtrlMode;
-
-  bool mLocked;
-};
-
-} // namespace OpenFDM
-
-#endif

Modified: trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp	2005-12-26 19:09:51 UTC (rev 125)
+++ trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp	2005-12-27 08:25:14 UTC (rev 126)
@@ -27,6 +27,8 @@
   mJointAxis = Vector3::unit(1);
   mOrientation = Quaternion::unit();
 
+  mFrame = new FreeFrame(name);
+
   setNumOutputPorts(2);
   setOutputPort(0, "jointPos", this, &RevoluteJoint::getJointPos);
   setOutputPort(1, "jointVel", this, &RevoluteJoint::getJointVel);
@@ -54,20 +56,20 @@
   mJointPosition = pos;
   Quaternion q = mOrientation;
   q *= Quaternion::fromAngleAxis(mJointPosition, mJointAxis);
-  setOutboardOrientation(q);
+  mFrame->setOrientation(q);
 }
 
 void
 RevoluteJoint::setJointVel(real_type vel)
 {
   mJointVelocity = vel;
-  setOutboardRelVel(mJointVelocity*getJointAxis());
+  mFrame->setRelVel(mJointVelocity*getJointAxis());
 }
 
 void
 RevoluteJoint::setPosition(const Vector3& position)
 {
-  setOutboardPosition(position);
+  mFrame->setPosition(position);
 }
 
 void
@@ -76,7 +78,7 @@
   mOrientation = orientation;
   Quaternion q = orientation;
   q *= Quaternion::fromAngleAxis(mJointPosition, mJointAxis);
-  setOutboardOrientation(q);
+  mFrame->setOrientation(q);
 }
 
 bool
@@ -95,9 +97,9 @@
 RevoluteJoint::computeRelAccel(const SpatialInertia&,
                                const Vector6&)
 {
+  Vector6 parentAccel = mFrame->getParentSpAccel();
+
   RigidBody* out = getOutboardBody();
-  Vector6 parentAccel = out->getFrame()->getParentSpAccel();
-
   SpatialInertia artI = out->getArtInertia();
   Vector6 pAlpha = out->getPAlpha();
 

Modified: trunk/OpenFDM/src/OpenFDM/RevoluteJoint.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RevoluteJoint.h	2005-12-26 19:09:51 UTC (rev 125)
+++ trunk/OpenFDM/src/OpenFDM/RevoluteJoint.h	2005-12-27 08:25:14 UTC (rev 126)
@@ -22,9 +22,32 @@
 class RevoluteJoint
   : public Joint, public JointT<1> {
 public:
-  RevoluteJoint(const std::string& name = std::string(), bool trackPosition = true);
+  RevoluteJoint(const std::string& name, bool trackPosition = true);
   virtual ~RevoluteJoint(void);
 
+  virtual bool init(void)
+  { recheckTopology(); return Joint::init(); }
+
+  virtual void recheckTopology(void)
+  {
+    if (!getOutboardBody() || !getInboardBody())
+      return;
+
+    // check for the inboard frame
+    Frame* inFrame = getInboardBody()->getFrame();
+    if (!inFrame)
+      return;
+
+    Frame* outFrame = getOutboardBody()->getFrame();
+    if (!outFrame) {
+      getOutboardBody()->setFrame(mFrame);
+    }
+    outFrame = getOutboardBody()->getFrame();
+    if (!outFrame->isParentFrame(inFrame)) {
+      inFrame->addChildFrame(mFrame);
+    }
+  }
+
   /** Gets the joint axis where this joint is allowed to rotate around.
    */
   Vector6 getJointAxis(void) const
@@ -124,6 +147,9 @@
   /** The direct joint interaction force
    */
   SharedPtr<LineForce> mLineForce;
+
+  /// The frame of the mobile root
+  SharedPtr<FreeFrame> mFrame;
 };
 
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/RigidBody.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RigidBody.cpp	2005-12-26 19:09:51 UTC (rev 125)
+++ trunk/OpenFDM/src/OpenFDM/RigidBody.cpp	2005-12-27 08:25:14 UTC (rev 126)
@@ -19,8 +19,7 @@
 namespace OpenFDM {
 
 RigidBody::RigidBody(const std::string& name) :
-  Object(name),
-  mFrame(new FreeFrame(name))
+  Object(name)
 {
 }
 
@@ -75,6 +74,8 @@
   for (it = mInteracts.begin(); it != mInteracts.end(); ++it) {
     multiBodySystem->addInteract(*it);
   }
+  if (mInboardJoint)
+    multiBodySystem->addInteract(mInboardJoint);
 }
 
 MultiBodySystem*
@@ -84,10 +85,22 @@
 }
 
 bool
+RigidBody::setInboardJoint(Joint* joint)
+{
+  mInboardJoint = joint;
+  if (!joint->attachTo(this, true))
+    return false;
+  if (!mParentMultiBodySystem)
+    return true;
+  mParentMultiBodySystem->addInteract(joint);
+  return true;
+}
+
+bool
 RigidBody::addInteract(Interact* interact)
 {
   mInteracts.push_back(interact);
-  if (!interact->attachTo(this))
+  if (!interact->attachTo(this, false))
     return false;
   if (!mParentMultiBodySystem)
     return true;

Modified: trunk/OpenFDM/src/OpenFDM/RigidBody.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RigidBody.h	2005-12-26 19:09:51 UTC (rev 125)
+++ trunk/OpenFDM/src/OpenFDM/RigidBody.h	2005-12-27 08:25:14 UTC (rev 126)
@@ -26,15 +26,9 @@
 class RigidBody :
     public Object {
 public:
-  // HMM ... FIXME
-  friend class Joint;
-  friend class FreeJoint;
-
-  /** Constructor.
-   */
+  /// Constructor
   RigidBody(const std::string& name);
-  /** Destructor.
-   */
+  /// Destructor
   virtual ~RigidBody(void);
 
 
@@ -94,8 +88,7 @@
     mArtInertia += inertia;
   }
 
-  /** Introduce an interface routine
-   */
+  /// Introduce an interface routine
   void setFrame(Frame* frame)
   {
     // take over all children
@@ -110,6 +103,7 @@
   void setParentMultiBodySystem(MultiBodySystem* multiBodySystem);
   MultiBodySystem* getParentMultiBodySystem(void);
 
+  bool setInboardJoint(Joint* joint);
   bool addInteract(Interact* interact);
   bool removeInteract(Interact* interact);
 
@@ -120,21 +114,20 @@
   /// Outboard articulated force
   Vector6 mArtForce;
 
-  /// Local inertia, needs to be set up at each cycle!?
-//   SpatialInertia mLocalInertia;
-
   /// Frame attached to this rigid body
   SharedPtr<Frame> mFrame;
 
+  /// One of our interacts is special ...
+  /// FIXME Make that dynamic later, for now we need to know the tree root at
+  /// MultiBodySystem build time
+  SharedPtr<Joint> mInboardJoint;
+  /// All Interacts attached to this RigidBody
   typedef std::vector<SharedPtr<Interact> > InteractList;
   InteractList mInteracts;
 
-  /// FIXME: is interact too???
-//   typedef std::vector<SharedPtr<Mass> > MassList;
-//   MassList mMasses;
-
   WeakPtr<MultiBodySystem> mParentMultiBodySystem;
 
+  // HMM ... FIXME
   friend class Interact;
 };
 

Modified: trunk/OpenFDM/src/OpenFDM/Vehicle.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Vehicle.cpp	2005-12-26 19:09:51 UTC (rev 125)
+++ trunk/OpenFDM/src/OpenFDM/Vehicle.cpp	2005-12-27 08:25:14 UTC (rev 126)
@@ -28,7 +28,7 @@
   mTopBody = new RigidBody("Topmost rigid body");
 
   mFreeJoint = new FreeJoint("Mobile vehicle base");
-  mTopBody->addInteract(mFreeJoint);
+  mTopBody->setInboardJoint(mFreeJoint);
 
   mSystem = new System("Top Vehicle System");
 

Modified: trunk/OpenFDM/src/OpenFDM/main.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/main.cpp	2005-12-26 19:09:51 UTC (rev 125)
+++ trunk/OpenFDM/src/OpenFDM/main.cpp	2005-12-27 08:25:14 UTC (rev 126)
@@ -626,12 +626,12 @@
   vehicle->getFreeJoint()->setRelVel(Vector6::zeros());
   Vector3 vel(convertFrom(uFeetPSecond, 23900.0), 0, 0);
   vehicle->getFreeJoint()->setLinearRelVel(vel);
-  vehicle->getTopBody()->addMultiBodyModel(new Mass(SpatialInertia(InertiaMatrix(100,0,0,100,0,100), 100), "Mass"));
+  vehicle->getTopBody()->addMultiBodyModel(new Mass("Testmass", SpatialInertia(InertiaMatrix(100,0,0,100,0,100), 100), "Mass"));
 
 
   RigidBody* body = new RigidBody;
   body->setName("Body am revolute Joint");
-  body->addMultiBodyModel(new Mass(SpatialInertia(InertiaMatrix(1,0,0,1,0,1), 1), "Mass"));
+  body->addMultiBodyModel(new Mass("Testmass", SpatialInertia(InertiaMatrix(1,0,0,1,0,1), 1), "Mass"));
   vehicle->getTopBody()->addChildFrame(body);
   PrismaticJoint* joint = new PrismaticJoint("Prismatic Joint 1");
   // FIXME, seem to have a poblem with the 2*pi periodicity,
@@ -644,7 +644,7 @@
 
   RigidBody* body2 = new RigidBody;
   body2->setName("Body2 am prismatic Joint");
-  body2->addMultiBodyModel(new Mass(SpatialInertia(InertiaMatrix(1,0,0,1,0,1), 1), "Mass"));
+  body2->addMultiBodyModel(new Mass("Testmass", SpatialInertia(InertiaMatrix(1,0,0,1,0,1), 1), "Mass"));
   body->addChildFrame(body2);
 //   PrismaticJoint* joint2 = new PrismaticJoint("Prismatic Joint 1");
   RevoluteJoint* joint2 = new RevoluteJoint("Revolute Joint 2");



From frohlich at berlios.de  Tue Dec 27 11:55:59 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Tue, 27 Dec 2005 11:55:59 +0100
Subject: [OpenFDM-svn] r127 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200512271055.jBRAtxTE020071@sheep.berlios.de>

Author: frohlich
Date: 2005-12-27 11:55:54 +0100 (Tue, 27 Dec 2005)
New Revision: 127

Modified:
   trunk/OpenFDM/src/OpenFDM/Frame.cpp
   trunk/OpenFDM/src/OpenFDM/Frame.h
   trunk/OpenFDM/src/OpenFDM/FreeJoint.cpp
   trunk/OpenFDM/src/OpenFDM/Joint.h
   trunk/OpenFDM/src/OpenFDM/PrismaticJoint.cpp
   trunk/OpenFDM/src/OpenFDM/PrismaticJoint.h
   trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp
   trunk/OpenFDM/src/OpenFDM/RevoluteJoint.h
Log:
Make the two joints use special frames


Modified: trunk/OpenFDM/src/OpenFDM/Frame.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Frame.cpp	2005-12-27 08:25:14 UTC (rev 126)
+++ trunk/OpenFDM/src/OpenFDM/Frame.cpp	2005-12-27 10:55:54 UTC (rev 127)
@@ -251,6 +251,13 @@
   }
 }
 
+void
+Frame::setParentFrame(Frame* parent)
+{
+  mParentFrame = parent;
+  setPosDirty();
+}
+
 SpatialInertia
 Frame::inertiaToParent(const SpatialInertia& I) const
 {

Modified: trunk/OpenFDM/src/OpenFDM/Frame.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Frame.h	2005-12-27 08:25:14 UTC (rev 126)
+++ trunk/OpenFDM/src/OpenFDM/Frame.h	2005-12-27 10:55:54 UTC (rev 127)
@@ -527,8 +527,7 @@
 
 private:
   /// Set the parent frame to the given one.
-  void setParentFrame(Frame* parent)
-  { mParentFrame = parent; }
+  void setParentFrame(Frame* parent);
 
   // The offset of this frames origin wrt the parent frame measured in
   // the parent frames coordinates.
@@ -608,7 +607,14 @@
     public Frame {
 public:
   PrismaticJointFrame(const std::string& name) :
-    Frame(name) { /*FIXME zero out members ...*/ }
+    Frame(name)
+  {
+    mZeroPos = Vector3::zeros();
+    mJointAxis = Vector3::unit(1);
+    mJointPos = 0;
+    mJointVel = 0;
+    mJointVelDot = 0;
+  }
   virtual ~PrismaticJointFrame(void) {}
 
   /// Gets the joint axis where this joint is allowed to rotate around.
@@ -649,13 +655,14 @@
   { mJointVelDot = velDot; setLinearRelAccel(mJointVelDot*mJointAxis); }
 
   /// Sets the zero position of the joint.
-  void setZeroPos(const Vector3& zeroPos)
+  void setZeroPosition(const Vector3& zeroPos)
   { mZeroPos = zeroPos; setPosition(mZeroPos + mJointPos*mJointAxis); }
-  const Vector3& getZeroPos(void) const
+  const Vector3& getZeroPosition(void) const
   { return mZeroPos; }
 
+  using Frame::setOrientation;
   /// FIXME Hdot
-
+  
 private:
   /// The zero position with respect to the parent frame.
   Vector3 mZeroPos;
@@ -676,7 +683,14 @@
     public Frame {
 public:
   RevoluteJointFrame(const std::string& name) :
-    Frame(name) { /*FIXME zero out members ...*/ }
+    Frame(name)
+  {
+    mZeroOrient = Quaternion::unit();
+    mJointAxis = Vector3::unit(1);
+    mJointPos = 0;
+    mJointVel = 0;
+    mJointVelDot = 0;
+  }
   virtual ~RevoluteJointFrame(void) {}
 
   /// Gets the joint axis where this joint is allowed to rotate around.
@@ -719,15 +733,17 @@
   void setJointVelDot(real_type velDot)
   { mJointVelDot = velDot; setAngularRelAccel(mJointVelDot*mJointAxis); }
 
-  /// Sets the zero position of the joint.
-  void setZeroOrient(const Quaternion& zeroOrient)
+  /// Sets the zero orientation of the joint.
+  void setZeroOrientation(const Quaternion& zeroOrient)
   {
     mZeroOrient = zeroOrient;
-    setOrientation(mZeroOrient*Quaternion::fromAngleAxis(mJointPos, mJointAxis));
+    setOrientation(zeroOrient*Quaternion::fromAngleAxis(mJointPos, mJointAxis));
   }
-  const Quaternion& getZeroOrient(void) const
+  const Quaternion& getZeroOrientation(void) const
   { return mZeroOrient; }
 
+  using Frame::setPosition;
+
   /// FIXME Hdot
 
 private:

Modified: trunk/OpenFDM/src/OpenFDM/FreeJoint.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/FreeJoint.cpp	2005-12-27 08:25:14 UTC (rev 126)
+++ trunk/OpenFDM/src/OpenFDM/FreeJoint.cpp	2005-12-27 10:55:54 UTC (rev 127)
@@ -104,12 +104,12 @@
   Vector3 ga = mGravity->gravityAccel(mFrame->getRefPosition());
   Vector6 grav = Vector6(Vector3::zeros(), mFrame->rotFromRef(ga));
 
-  Log(ArtBody, Debug) << "grav = " << trans(grav) << endl;
-  Log(ArtBody, Debug) << "solve = " << trans(solve(artI, artF)) << endl;
-  Log(ArtBody, Debug) << "parent spatial accel = " << trans(mFrame->getParentSpAccel()) << endl;
-  Log(ArtBody, Debug) << "Hdot = " << trans(mFrame->getHdot()) << endl;
+  Log(ArtBody, Debug) << "grav = " << trans(grav) << endl
+                      << "solve = " << trans(solve(artI, artF)) << endl
+                      << "parent spatial accel = "
+                      << trans(mFrame->getParentSpAccel()) << endl
+                      << "Hdot = " << trans(mFrame->getHdot()) << endl;
   
-
   Vector6 accel = grav - solve(artI, artF)
     - mFrame->getParentSpAccel() - mFrame->getHdot();
   return accel;

Modified: trunk/OpenFDM/src/OpenFDM/Joint.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Joint.h	2005-12-27 08:25:14 UTC (rev 126)
+++ trunk/OpenFDM/src/OpenFDM/Joint.h	2005-12-27 10:55:54 UTC (rev 127)
@@ -106,13 +106,11 @@
     Frame* frame0 = outboardBody->getFrame();
     if (!frame0)
       return false;
+    frame0->enableAccel();
     FreeFrame* frame = dynamic_cast<FreeFrame*>(frame0);
-    if (!frame)
-      return false;
+    if (frame)
+      frame->setRelAccel(accel);
 
-    frame->enableAccel();
-    frame->setRelAccel(accel);
-
     outboardBody->computeAccel();
 
     return true;

Modified: trunk/OpenFDM/src/OpenFDM/PrismaticJoint.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/PrismaticJoint.cpp	2005-12-27 08:25:14 UTC (rev 126)
+++ trunk/OpenFDM/src/OpenFDM/PrismaticJoint.cpp	2005-12-27 10:55:54 UTC (rev 127)
@@ -20,13 +20,8 @@
   : Joint(name)
 {
   setNumContinousStates(2);
-  mJointPosition = 0;
-  mJointVelocity = 0;
-  mJointAcceleration = 0;
-  mJointAxis = Vector3::unit(1);
-  mPosition = Vector3::zeros();
 
-  mFrame = new FreeFrame(name);
+  mPrismaticJointFrame = new PrismaticJointFrame(name);
 
   setNumOutputPorts(2);
   setOutputPort(0, "jointPos", this, &PrismaticJoint::getJointPos);
@@ -46,34 +41,31 @@
     return;
   }
 
-  mJointAxis = (1/nrm)*axis;
+  mPrismaticJointFrame->setJointAxis((1/nrm)*axis);
 }
 
 void
 PrismaticJoint::setJointPos(real_type pos)
 {
-  mJointPosition = pos;
-  mFrame->setPosition(mPosition + mJointPosition*mJointAxis);
+  mPrismaticJointFrame->setJointPos(pos);
 }
 
 void
 PrismaticJoint::setJointVel(real_type vel)
 {
-  mJointVelocity = vel;
-  mFrame->setRelVel(mJointVelocity*getJointAxis());
+  mPrismaticJointFrame->setJointVel(vel);
 }
 
 void
 PrismaticJoint::setOrientation(const Quaternion& orientation)
 {
-  mFrame->setPosition(mPosition + mJointPosition*mJointAxis);
+  mPrismaticJointFrame->setOrientation(orientation);
 }
 
 void
 PrismaticJoint::setPosition(const Vector3& position)
 {
-  mPosition = position;
-  mFrame->setPosition(mPosition + mJointPosition*mJointAxis);
+  mPrismaticJointFrame->setZeroPosition(position);
 }
 
 bool
@@ -92,7 +84,7 @@
 PrismaticJoint::computeRelAccel(const SpatialInertia&,
                                 const Vector6&)
 {
-  Vector6 parentAccel = mFrame->getParentSpAccel();
+  Vector6 parentAccel = mPrismaticJointFrame->getParentSpAccel();
 
   RigidBody* out = getOutboardBody();
   SpatialInertia artI = out->getArtInertia();
@@ -100,7 +92,7 @@
 
   JointT<1>::VectorN acc;
   JointT<1>::computeRelAccel(artI, parentAccel, pAlpha, getJointAxis(), acc);
-  mJointAcceleration = acc(1);
+  mPrismaticJointFrame->setJointVelDot(acc(1));
   Log(ArtBody, Debug) << "Relative acceleration for Joint \""
                       << getName() << "\" is " << trans(acc) << endl;
   return getJointAxis()*acc;
@@ -109,22 +101,22 @@
 void
 PrismaticJoint::setState(const Vector& state, unsigned offset)
 {
-  setJointPos(state(offset+1));
-  setJointVel(state(offset+2));
+  mPrismaticJointFrame->setJointPos(state(offset+1));
+  mPrismaticJointFrame->setJointVel(state(offset+2));
 }
 
 void
 PrismaticJoint::getState(Vector& state, unsigned offset) const
 {
-  state(offset+1) = mJointPosition;
-  state(offset+2) = mJointVelocity;
+  state(offset+1) = mPrismaticJointFrame->getJointPos();
+  state(offset+2) = mPrismaticJointFrame->getJointVel();
 }
 
 void
 PrismaticJoint::getStateDeriv(Vector& state, unsigned offset)
 {
-  state(offset+1) = mJointVelocity;
-  state(offset+2) = mJointAcceleration;
+  state(offset+1) = mPrismaticJointFrame->getJointVel();
+  state(offset+2) = mPrismaticJointFrame->getJointVelDot();
 }
 
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/PrismaticJoint.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/PrismaticJoint.h	2005-12-27 08:25:14 UTC (rev 126)
+++ trunk/OpenFDM/src/OpenFDM/PrismaticJoint.h	2005-12-27 10:55:54 UTC (rev 127)
@@ -40,18 +40,18 @@
 
     Frame* outFrame = getOutboardBody()->getFrame();
     if (!outFrame) {
-      getOutboardBody()->setFrame(mFrame);
+      getOutboardBody()->setFrame(mPrismaticJointFrame);
     }
     outFrame = getOutboardBody()->getFrame();
     if (!outFrame->isParentFrame(inFrame)) {
-      inFrame->addChildFrame(mFrame);
+      inFrame->addChildFrame(mPrismaticJointFrame);
     }
   }
 
   /** Gets the joint axis where this joint is allowed to rotate around.
    */
   Vector6 getJointAxis(void) const
-  { return Vector6(Vector3::zeros(), mJointAxis); }
+  { return Vector6(Vector3::zeros(), mPrismaticJointFrame->getJointAxis()); }
 
   /** Sets the joint axis where this joint is allowed to rotate around.
    */
@@ -60,7 +60,7 @@
   /** Returns the joint position.
    */
   const real_type& getJointPos(void) const
-  { return mJointPosition; }
+  { return mPrismaticJointFrame->getJointPos(); }
 
   /** Sets the joint position.
    */
@@ -69,7 +69,7 @@
   /** Returns the joint velocity.
    */
   const real_type& getJointVel(void) const
-  { return mJointVelocity; }
+  { return mPrismaticJointFrame->getJointVel(); }
 
   /** Sets the joint velocity.
    */
@@ -95,7 +95,7 @@
     if (!mLineForce)
       return 0;
     
-    mLineForce->computeForce(mJointPosition, mJointVelocity);
+    mLineForce->computeForce(getJointPos(), getJointVel());
     return mLineForce->getForce();
   }
 
@@ -117,32 +117,12 @@
   virtual void getState(Vector& state, unsigned offset) const;
   virtual void getStateDeriv(Vector& state, unsigned offset);
 
-  /** The joint rotation axis.
-   */
-  Vector3 mJointAxis;
-
-  /** The relative joint rotation with respect to the zero orientation.
-   */
-  real_type mJointPosition;
-
-  /** The rotational velocity with respect to the rotation axis.
-   */
-  real_type mJointVelocity;
-
-  /** The rotational velocity with respect to the rotation axis.
-   */
-  real_type mJointAcceleration;
-
-  /** The zero orientation with respect to the parent frame.
-   */
-  Vector3 mPosition;
-
   /** The direct joint interaction force
    */
   SharedPtr<LineForce> mLineForce;
 
   /// The frame of the mobile root
-  SharedPtr<FreeFrame> mFrame;
+  SharedPtr<PrismaticJointFrame> mPrismaticJointFrame;
 };
 
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp	2005-12-27 08:25:14 UTC (rev 126)
+++ trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp	2005-12-27 10:55:54 UTC (rev 127)
@@ -16,18 +16,12 @@
 
 namespace OpenFDM {
 
-RevoluteJoint::RevoluteJoint(const std::string& name, bool trackPosition)
-  : Joint(name)
+RevoluteJoint::RevoluteJoint(const std::string& name) :
+  Joint(name)
 {
-  setNumContinousStates(trackPosition ? 2 : 1);
-  mTrackPosition = trackPosition;
-  mJointPosition = 0;
-  mJointVelocity = 0;
-  mJointAcceleration = 0;
-  mJointAxis = Vector3::unit(1);
-  mOrientation = Quaternion::unit();
+  setNumContinousStates(2);
 
-  mFrame = new FreeFrame(name);
+  mRevoluteJointFrame = new RevoluteJointFrame(name);
 
   setNumOutputPorts(2);
   setOutputPort(0, "jointPos", this, &RevoluteJoint::getJointPos);
@@ -46,39 +40,31 @@
     Log(Initialization, Error) << "JointAxis is zero ..." << endl;
     return;
   }
-
-  mJointAxis = (1/nrm)*axis;
+  mRevoluteJointFrame->setJointAxis((1/nrm)*axis);
 }
 
 void
 RevoluteJoint::setJointPos(real_type pos)
 {
-  mJointPosition = pos;
-  Quaternion q = mOrientation;
-  q *= Quaternion::fromAngleAxis(mJointPosition, mJointAxis);
-  mFrame->setOrientation(q);
+  mRevoluteJointFrame->setJointPos(pos);
 }
 
 void
 RevoluteJoint::setJointVel(real_type vel)
 {
-  mJointVelocity = vel;
-  mFrame->setRelVel(mJointVelocity*getJointAxis());
+  mRevoluteJointFrame->setJointVel(vel);
 }
 
 void
 RevoluteJoint::setPosition(const Vector3& position)
 {
-  mFrame->setPosition(position);
+  mRevoluteJointFrame->setPosition(position);
 }
 
 void
 RevoluteJoint::setOrientation(const Quaternion& orientation)
 {
-  mOrientation = orientation;
-  Quaternion q = orientation;
-  q *= Quaternion::fromAngleAxis(mJointPosition, mJointAxis);
-  mFrame->setOrientation(q);
+  mRevoluteJointFrame->setZeroOrientation(orientation);
 }
 
 bool
@@ -97,7 +83,7 @@
 RevoluteJoint::computeRelAccel(const SpatialInertia&,
                                const Vector6&)
 {
-  Vector6 parentAccel = mFrame->getParentSpAccel();
+  Vector6 parentAccel = mRevoluteJointFrame->getParentSpAccel();
 
   RigidBody* out = getOutboardBody();
   SpatialInertia artI = out->getArtInertia();
@@ -105,7 +91,8 @@
 
   JointT<1>::VectorN acc;
   JointT<1>::computeRelAccel(artI, parentAccel, pAlpha, getJointAxis(), acc);
-  mJointAcceleration = acc(1);
+  mRevoluteJointFrame->setJointVelDot(acc(1));
+  
   Log(ArtBody, Debug) << "Relative acceleration for Joint \""
                       << getName() << "\" is " << trans(acc) << endl;
   return getJointAxis()*acc;
@@ -114,34 +101,22 @@
 void
 RevoluteJoint::setState(const Vector& state, unsigned offset)
 {
-  if (mTrackPosition) {
-    setJointPos(state(offset+1));
-    setJointVel(state(offset+2));
-  } else {
-    setJointVel(state(offset+1));
-  }
+  mRevoluteJointFrame->setJointPos(state(offset+1));
+  mRevoluteJointFrame->setJointVel(state(offset+2));
 }
 
 void
 RevoluteJoint::getState(Vector& state, unsigned offset) const
 {
-  if (mTrackPosition) {
-    state(offset+1) = mJointPosition;
-    state(offset+2) = mJointVelocity;
-  } else {
-    state(offset+1) = mJointVelocity;
-  }
+  state(offset+1) = mRevoluteJointFrame->getJointPos();
+  state(offset+2) = mRevoluteJointFrame->getJointVel();
 }
 
 void
 RevoluteJoint::getStateDeriv(Vector& state, unsigned offset)
 {
-  if (mTrackPosition) {
-    state(offset+1) = mJointVelocity;
-    state(offset+2) = mJointAcceleration;
-  } else {
-    state(offset+1) = mJointAcceleration;
-  }
+  state(offset+1) = mRevoluteJointFrame->getJointVel();
+  state(offset+2) = mRevoluteJointFrame->getJointVelDot();
 }
 
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/RevoluteJoint.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RevoluteJoint.h	2005-12-27 08:25:14 UTC (rev 126)
+++ trunk/OpenFDM/src/OpenFDM/RevoluteJoint.h	2005-12-27 10:55:54 UTC (rev 127)
@@ -22,7 +22,7 @@
 class RevoluteJoint
   : public Joint, public JointT<1> {
 public:
-  RevoluteJoint(const std::string& name, bool trackPosition = true);
+  RevoluteJoint(const std::string& name);
   virtual ~RevoluteJoint(void);
 
   virtual bool init(void)
@@ -40,18 +40,18 @@
 
     Frame* outFrame = getOutboardBody()->getFrame();
     if (!outFrame) {
-      getOutboardBody()->setFrame(mFrame);
+      getOutboardBody()->setFrame(mRevoluteJointFrame);
     }
     outFrame = getOutboardBody()->getFrame();
     if (!outFrame->isParentFrame(inFrame)) {
-      inFrame->addChildFrame(mFrame);
+      inFrame->addChildFrame(mRevoluteJointFrame);
     }
   }
 
   /** Gets the joint axis where this joint is allowed to rotate around.
    */
   Vector6 getJointAxis(void) const
-  { return Vector6(mJointAxis, Vector3::zeros()); }
+  { return Vector6(mRevoluteJointFrame->getJointAxis(), Vector3::zeros()); }
 
   /** Sets the joint axis where this joint is allowed to rotate around.
    */
@@ -60,7 +60,7 @@
   /** Returns the joint position.
    */
   const real_type& getJointPos(void) const
-  { return mJointPosition; }
+  { return mRevoluteJointFrame->getJointPos(); }
 
   /** Sets the joint position.
    */
@@ -69,7 +69,7 @@
   /** Returns the joint velocity.
    */
   const real_type& getJointVel(void) const
-  { return mJointVelocity; }
+  { return mRevoluteJointFrame->getJointVel(); }
 
   /** Sets the joint velocity.
    */
@@ -95,7 +95,7 @@
     if (!mLineForce)
       return 0;
     
-    mLineForce->computeForce(mJointPosition, mJointVelocity);
+    mLineForce->computeForce(getJointPos(), getJointVel());
     return mLineForce->getForce();
   }
 
@@ -117,39 +117,12 @@
   virtual void getState(Vector& state, unsigned offset) const;
   virtual void getStateDeriv(Vector& state, unsigned offset);
 
-  /** The joint rotation axis.
-   */
-  Vector3 mJointAxis;
-
-  /** The relative joint rotation with respect to the zero orientation.
-   */
-  real_type mJointPosition;
-
-  /** The rotational velocity with respect to the rotation axis.
-   */
-  real_type mJointVelocity;
-
-  /** The rotational velocity with respect to the rotation axis.
-   */
-  real_type mJointAcceleration;
-
-  /** The zero orientation with respect to the parent frame.
-   */
-  Quaternion mOrientation;
-
-  /** Signals if we should track the joint position in the ordinary
-      differential equation part of the multibody system.
-      This is useful for wheel models where the position of the wheel is
-      only used for animations and thus could be postprocessed.
-   */
-  bool mTrackPosition;
-
   /** The direct joint interaction force
    */
   SharedPtr<LineForce> mLineForce;
 
   /// The frame of the mobile root
-  SharedPtr<FreeFrame> mFrame;
+  SharedPtr<RevoluteJointFrame> mRevoluteJointFrame;
 };
 
 } // namespace OpenFDM



From frohlich at berlios.de  Tue Dec 27 13:31:26 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Tue, 27 Dec 2005 13:31:26 +0100
Subject: [OpenFDM-svn] r128 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200512271231.jBRCVQol028728@sheep.berlios.de>

Author: frohlich
Date: 2005-12-27 13:31:05 +0100 (Tue, 27 Dec 2005)
New Revision: 128

Added:
   trunk/OpenFDM/src/OpenFDM/CartesianJointFrame.h
   trunk/OpenFDM/src/OpenFDM/PrismaticJointFrame.h
   trunk/OpenFDM/src/OpenFDM/RevoluteJointFrame.h
Removed:
   trunk/OpenFDM/src/OpenFDM/JointT.h
Modified:
   trunk/OpenFDM/src/OpenFDM/Frame.h
   trunk/OpenFDM/src/OpenFDM/Joint.h
   trunk/OpenFDM/src/OpenFDM/Makefile.am
   trunk/OpenFDM/src/OpenFDM/PrismaticJoint.cpp
   trunk/OpenFDM/src/OpenFDM/PrismaticJoint.h
   trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp
   trunk/OpenFDM/src/OpenFDM/RevoluteJoint.h
   trunk/OpenFDM/src/OpenFDM/RigidBody.cpp
Log:
Slowly moving to the desired structure ...


Added: trunk/OpenFDM/src/OpenFDM/CartesianJointFrame.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/CartesianJointFrame.h	2005-12-27 10:55:54 UTC (rev 127)
+++ trunk/OpenFDM/src/OpenFDM/CartesianJointFrame.h	2005-12-27 12:31:05 UTC (rev 128)
@@ -0,0 +1,83 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_CartesianJointFrame_H
+#define OpenFDM_CartesianJointFrame_H
+
+#include "Assert.h"
+#include "Vector.h"
+#include "Matrix.h"
+#include "Inertia.h"
+#include "Frame.h"
+
+namespace OpenFDM {
+
+template<unsigned n>
+class CartesianJointFrame :
+  public Frame {
+public:
+  CartesianJointFrame(const std::string& name) :
+    Frame(name)
+  { }
+  virtual ~CartesianJointFrame(void)
+  { }
+
+
+// protected:
+  typedef LinAlg::Vector<real_type,n> VectorN;
+  typedef LinAlg::Matrix<real_type,6,n> Matrix6N;
+  typedef LinAlg::Matrix<real_type,n,n> MatrixNN;
+  typedef LinAlg::MatrixFactors<real_type,n,n,LinAlg::LUTag> MatrixFactorsNN;
+
+  bool jointArticulation(SpatialInertia& artI,
+                         Vector6& artF,
+                         const SpatialInertia& outI,
+                         const Vector6& pAlpha,
+                         const Vector6& jointForce,
+                         const Matrix6N& jointAxis)
+  {
+    Log(ArtBody, Debug1) << artI << endl;
+
+    mOutboardInertia = outI;
+
+    mJointForce = jointForce;
+
+    Matrix6N Ih = outI*jointAxis;
+    hIh = trans(jointAxis)*Ih;
+
+    if (hIh.singular())
+      return false;
+
+    artF = pAlpha;
+    
+    Vector6 mForcePAlpha = pAlpha - jointForce;
+
+    artF -= Ih*hIh.solve(trans(jointAxis)*mForcePAlpha);
+    artI = outI;
+    artI -= SpatialInertia(Ih*hIh.solve(trans(Ih)));
+
+    return true;
+  }
+  
+  void computeRelAccel(const Vector6& pAlpha,
+                       const Matrix6N& jointAxis,
+                       VectorN& jointAccel) const
+  {
+    if (hIh.singular()) {
+      jointAccel.clear();
+    } else {
+      Vector6 tmp = mJointForce - mOutboardInertia*getParentSpAccel() - pAlpha;
+      jointAccel = hIh.solve(trans(jointAxis)*tmp);
+    }
+  }
+
+private:
+  SpatialInertia mOutboardInertia;
+  Vector6 mJointForce;
+  MatrixFactorsNN hIh;
+};
+
+} // namespace OpenFDM
+
+#endif


Property changes on: trunk/OpenFDM/src/OpenFDM/CartesianJointFrame.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/OpenFDM/src/OpenFDM/Frame.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Frame.h	2005-12-27 10:55:54 UTC (rev 127)
+++ trunk/OpenFDM/src/OpenFDM/Frame.h	2005-12-27 12:31:05 UTC (rev 128)
@@ -603,165 +603,6 @@
   { Frame::setRefOrientation(o); }
 };
 
-class PrismaticJointFrame :
-    public Frame {
-public:
-  PrismaticJointFrame(const std::string& name) :
-    Frame(name)
-  {
-    mZeroPos = Vector3::zeros();
-    mJointAxis = Vector3::unit(1);
-    mJointPos = 0;
-    mJointVel = 0;
-    mJointVelDot = 0;
-  }
-  virtual ~PrismaticJointFrame(void) {}
-
-  /// Gets the joint axis where this joint is allowed to rotate around.
-  const Vector3& getJointAxis(void) const
-  { return mJointAxis; }
-
-  /// Sets the joint axis where this joint is allowed to rotate around.
-  void setJointAxis(const Vector3& axis)
-  {
-    mJointAxis = axis;
-    setPosition(mZeroPos + mJointPos*mJointAxis);
-    setLinearRelVel(mJointVel*mJointAxis);
-    setLinearRelAccel(mJointVelDot*mJointAxis);
-  }
-
-  /// Returns the joint position.
-  const real_type& getJointPos(void) const
-  { return mJointPos; }
-
-  /// Sets the joint position.
-  void setJointPos(real_type pos)
-  { mJointPos = pos; setPosition(mZeroPos + mJointPos*mJointAxis); }
-
-  /// Returns the joint velocity.
-  const real_type& getJointVel(void) const
-  { return mJointVel; }
-
-  /// Sets the joint velocity.
-  void setJointVel(real_type vel)
-  { mJointVel = vel; setLinearRelVel(mJointVel*mJointAxis); }
-
-  /// Returns the derivative of the relative velocity
-  const real_type& getJointVelDot(void) const
-  { return mJointVelDot; }
-
-  /// Returns the derivative of the relative velocity
-  void setJointVelDot(real_type velDot)
-  { mJointVelDot = velDot; setLinearRelAccel(mJointVelDot*mJointAxis); }
-
-  /// Sets the zero position of the joint.
-  void setZeroPosition(const Vector3& zeroPos)
-  { mZeroPos = zeroPos; setPosition(mZeroPos + mJointPos*mJointAxis); }
-  const Vector3& getZeroPosition(void) const
-  { return mZeroPos; }
-
-  using Frame::setOrientation;
-  /// FIXME Hdot
-  
-private:
-  /// The zero position with respect to the parent frame.
-  Vector3 mZeroPos;
-  /// The joint rotation axis.
-  Vector3 mJointAxis;
-
-  /// The relative joint translation along the joint axis
-  real_type mJointPos;
-
-  /// The realtive linear velocity along the joint axis
-  real_type mJointVel;
-
-  /// The realtive linear velocity derivative along the joint axis
-  real_type mJointVelDot;
-};
-
-class RevoluteJointFrame :
-    public Frame {
-public:
-  RevoluteJointFrame(const std::string& name) :
-    Frame(name)
-  {
-    mZeroOrient = Quaternion::unit();
-    mJointAxis = Vector3::unit(1);
-    mJointPos = 0;
-    mJointVel = 0;
-    mJointVelDot = 0;
-  }
-  virtual ~RevoluteJointFrame(void) {}
-
-  /// Gets the joint axis where this joint is allowed to rotate around.
-  const Vector3& getJointAxis(void) const
-  { return mJointAxis; }
-
-  /// Sets the joint axis where this joint is allowed to rotate around.
-  void setJointAxis(const Vector3& axis)
-  {
-    mJointAxis = axis;
-    setOrientation(mZeroOrient*Quaternion::fromAngleAxis(mJointPos, mJointAxis));
-    setAngularRelVel(mJointVel*mJointAxis);
-    setAngularRelAccel(mJointVelDot*mJointAxis);
-  }
-
-  /// Returns the joint position.
-  const real_type& getJointPos(void) const
-  { return mJointPos; }
-
-  /// Sets the joint position.
-  void setJointPos(real_type pos)
-  {
-    mJointPos = pos;
-    setOrientation(mZeroOrient*Quaternion::fromAngleAxis(mJointPos, mJointAxis));
-  }
-
-  /// Returns the joint velocity.
-  const real_type& getJointVel(void) const
-  { return mJointVel; }
-
-  /// Sets the joint velocity.
-  void setJointVel(real_type vel)
-  { mJointVel = vel; setAngularRelVel(mJointVel*mJointAxis); }
-
-  /// Returns the derivative of the relative velocity
-  const real_type& getJointVelDot(void) const
-  { return mJointVelDot; }
-
-  /// Returns the derivative of the relative velocity
-  void setJointVelDot(real_type velDot)
-  { mJointVelDot = velDot; setAngularRelAccel(mJointVelDot*mJointAxis); }
-
-  /// Sets the zero orientation of the joint.
-  void setZeroOrientation(const Quaternion& zeroOrient)
-  {
-    mZeroOrient = zeroOrient;
-    setOrientation(zeroOrient*Quaternion::fromAngleAxis(mJointPos, mJointAxis));
-  }
-  const Quaternion& getZeroOrientation(void) const
-  { return mZeroOrient; }
-
-  using Frame::setPosition;
-
-  /// FIXME Hdot
-
-private:
-  /// The zero orientation with respect to the parent frame.
-  Quaternion mZeroOrient;
-  /// The joint rotation axis.
-  Vector3 mJointAxis;
-
-  /// The relative joint rotation with respect to the zero orientation.
-  real_type mJointPos;
-
-  /// The rotational velocity with respect to the rotation axis.
-  real_type mJointVel;
-
-  /// The rotational velocity derivative with respect to the rotation axis.
-  real_type mJointVelDot;
-};
-
 } // namespace OpenFDM
 
 #endif

Modified: trunk/OpenFDM/src/OpenFDM/Joint.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Joint.h	2005-12-27 10:55:54 UTC (rev 127)
+++ trunk/OpenFDM/src/OpenFDM/Joint.h	2005-12-27 12:31:05 UTC (rev 128)
@@ -39,50 +39,36 @@
     if (rigidBody != getInboardBody())
       return;
 
-    getOutboardBody()->computeArtValues();
-    SpatialInertia artI = SpatialInertia::zeros();
-    Vector6 artF = Vector6::zeros();
-    contributeArticulation(artI, artF);
-    rigidBody->contributeForce(artF);
-    rigidBody->contributeInertia(artI);
-  }
-
-  bool contributeArticulation(SpatialInertia& artI, Vector6& artF)
-  {
     RigidBody* outboardBody = getOutboardBody();
     if (!outboardBody)
-      return false;
+      return;
 
-    Frame* frame = outboardBody->getFrame();
-
+    outboardBody->computeArtValues();
     Log(ArtBody, Debug) << "Contributing articulation from \""
                         << outboardBody->getName() << "\" through joint \""
                         << getName() << "\"" << endl;
 
     // We need the articulated inertia and force from the outboard body.
-    SpatialInertia I = outboardBody->getArtInertia();
-    Vector6 F = outboardBody->getArtForce();
+    SpatialInertia I;
+    Vector6 F;
 
-    Log(ArtBody, Debug3) << "Outboard Articulated values: Force:\n"
-                         << trans(F) << "\nInertia\n" << I << endl;
-
     // Apply the joint degrees of freedom to that.
     // If there was an error, (something was singular ???)
     // just ignore that part. FIXME, ist this ok????
     if (!jointArticulation(I, F))
-      return false;
+      return;
 
     Log(ArtBody, Debug3) << "Outboard Articulated values past joint "
                          << "projection: Force:\n" << trans(F)
                          << "\nInertia\n" << I << endl;
 
     // Contribute the transformed values to the parent.
-    artI += frame->inertiaToParent(I);
-    artF += frame->forceToParent(F);
-
-    return true;
+    Frame* frame = outboardBody->getFrame();
+    rigidBody->contributeInertia(frame->inertiaToParent(I));
+    rigidBody->contributeForce(frame->forceToParent(F));
   }
 
+
   // Joint slot ...
   // FIXME: pure virtual
   virtual bool jointArticulation(SpatialInertia& artI, Vector6& artF) = 0;

Deleted: trunk/OpenFDM/src/OpenFDM/JointT.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/JointT.h	2005-12-27 10:55:54 UTC (rev 127)
+++ trunk/OpenFDM/src/OpenFDM/JointT.h	2005-12-27 12:31:05 UTC (rev 128)
@@ -1,84 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
- *
- */
-
-#ifndef OpenFDM_JointT_H
-#define OpenFDM_JointT_H
-
-#include "Assert.h"
-#include "Vector.h"
-#include "Matrix.h"
-#include "Inertia.h"
-
-namespace OpenFDM {
-
-template<unsigned n>
-class JointT {
-  // FIXME: move that as template member into RigidBody ...
-  // or something like that ...
-protected:
-  typedef LinAlg::Vector<real_type,n> VectorN;
-  typedef LinAlg::Matrix<real_type,6,n> Matrix6N;
-  typedef LinAlg::Matrix<real_type,n,n> MatrixNN;
-  typedef LinAlg::MatrixFactors<real_type,n,n,LinAlg::LUTag> MatrixFactorsNN;
-
-  bool jointArticulation(SpatialInertia& artI,
-                         Vector6& artF,
-                         const Vector6& pAlpha,
-                         const Vector6& jointForce,
-                         const Matrix6N& jointAxis)
-  {
-    Log(ArtBody, Debug1) << artI << endl;
-
-    mJointForce = jointForce;
-
-    Matrix6N Ih = artI*jointAxis;
-    hIh = trans(jointAxis)*Ih;
-
-    if (hIh.singular())
-      return false;
-
-    artF = pAlpha;
-    
-    Vector6 mForcePAlpha = pAlpha - jointForce;
-
-    Log(ArtBody, Debug1) << trans(jointAxis)*Ih
-                         << endl
-                         << trans(jointForce)
-                         << endl
-                         << trans(pAlpha)
-                         << endl
-                         << trans(Ih*hIh.solve(trans(jointAxis)*mForcePAlpha))
-                         << endl
-                         << SpatialInertia(Ih*hIh.solve(trans(Ih)))
-                         << endl;
-
-
-    artF -= Ih*hIh.solve(trans(jointAxis)*mForcePAlpha);
-    artI -= SpatialInertia(Ih*hIh.solve(trans(Ih)));
-
-    return true;
-  }
-  
-  void computeRelAccel(const SpatialInertia& outBoardArtInertia,
-                       const Vector6& parentSpAccel,
-                       const Vector6& pAlpha,
-                       const Matrix6N& jointAxis,
-                       VectorN& jointAccel) const
-  {
-    if (hIh.singular()) {
-      jointAccel.clear();
-    } else {
-      Vector6 tmp = mJointForce - outBoardArtInertia*parentSpAccel - pAlpha;
-      jointAccel = hIh.solve(trans(jointAxis)*tmp);
-    }
-  }
-
-private:
-  Vector6 mJointForce;
-  MatrixFactorsNN hIh;
-};
-
-} // namespace OpenFDM
-
-#endif

Modified: trunk/OpenFDM/src/OpenFDM/Makefile.am
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Makefile.am	2005-12-27 10:55:54 UTC (rev 127)
+++ trunk/OpenFDM/src/OpenFDM/Makefile.am	2005-12-27 12:31:05 UTC (rev 128)
@@ -31,6 +31,7 @@
   AtmosphereSTD1976.h \
   Bias.h \
   BinaryFunctionModel.h \
+  CartesianJointFrame.h \
   Contact.h \
   ConstantForce.h \
   ConstSystem.h \
@@ -62,7 +63,6 @@
   ImplicitEuler.h \
   Inertia.h \
   Joint.h \
-  JointT.h \
   Limits.h \
   LinAlg/Algorithm.h \
   LinAlg/Array.h \
@@ -96,10 +96,12 @@
   Property.h \
   Product.h \
   PrismaticJoint.h \
+  PrismaticJointFrame.h \
   Quaternion.h \
   ReaderWriter.h \
   Referenced.h \
   RevoluteJoint.h \
+  RevoluteJointFrame.h \
   RigidBody.h \
   Rotation.h \
   RootFrame.h \

Modified: trunk/OpenFDM/src/OpenFDM/PrismaticJoint.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/PrismaticJoint.cpp	2005-12-27 10:55:54 UTC (rev 127)
+++ trunk/OpenFDM/src/OpenFDM/PrismaticJoint.cpp	2005-12-27 12:31:05 UTC (rev 128)
@@ -75,23 +75,22 @@
   // of the joint are.
   RigidBody* out = getOutboardBody();
   real_type tau = getJointForce();
-  return JointT<1>::jointArticulation(artI, artF, out->getPAlpha(),
-                                      tau*getJointAxis(),
-                                      getJointAxis());
+  return mPrismaticJointFrame->jointArticulation(artI, artF,
+                                                 out->getArtInertia(),
+                                                 out->getPAlpha(),
+                                                 tau*getJointAxis(),
+                                                 getJointAxis());
 }
 
 Vector6
 PrismaticJoint::computeRelAccel(const SpatialInertia&,
                                 const Vector6&)
 {
-  Vector6 parentAccel = mPrismaticJointFrame->getParentSpAccel();
-
   RigidBody* out = getOutboardBody();
-  SpatialInertia artI = out->getArtInertia();
   Vector6 pAlpha = out->getPAlpha();
 
-  JointT<1>::VectorN acc;
-  JointT<1>::computeRelAccel(artI, parentAccel, pAlpha, getJointAxis(), acc);
+  CartesianJointFrame<1>::VectorN acc;
+  mPrismaticJointFrame->computeRelAccel(pAlpha, getJointAxis(), acc);
   mPrismaticJointFrame->setJointVelDot(acc(1));
   Log(ArtBody, Debug) << "Relative acceleration for Joint \""
                       << getName() << "\" is " << trans(acc) << endl;

Modified: trunk/OpenFDM/src/OpenFDM/PrismaticJoint.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/PrismaticJoint.h	2005-12-27 10:55:54 UTC (rev 127)
+++ trunk/OpenFDM/src/OpenFDM/PrismaticJoint.h	2005-12-27 12:31:05 UTC (rev 128)
@@ -13,14 +13,14 @@
 #include "Inertia.h"
 #include "Frame.h"
 #include "RigidBody.h"
-#include "JointT.h"
 #include "Joint.h"
 #include "LineForce.h"
+#include "PrismaticJointFrame.h"
 
 namespace OpenFDM {
 
 class PrismaticJoint
-  : public Joint, public JointT<1> {
+  : public Joint {
 public:
   PrismaticJoint(const std::string& name);
   virtual ~PrismaticJoint(void);

Added: trunk/OpenFDM/src/OpenFDM/PrismaticJointFrame.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/PrismaticJointFrame.h	2005-12-27 10:55:54 UTC (rev 127)
+++ trunk/OpenFDM/src/OpenFDM/PrismaticJointFrame.h	2005-12-27 12:31:05 UTC (rev 128)
@@ -0,0 +1,99 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_PrismaticJointFrame_H
+#define OpenFDM_PrismaticJointFrame_H
+
+#include "Assert.h"
+#include "Object.h"
+#include "Vector.h"
+#include "Matrix.h"
+#include "Quaternion.h"
+#include "Inertia.h"
+#include "Frame.h"
+#include "RigidBody.h"
+#include "Joint.h"
+#include "LineForce.h"
+#include "CartesianJointFrame.h"
+
+namespace OpenFDM {
+
+class PrismaticJointFrame :
+    public CartesianJointFrame<1> {
+public:
+  PrismaticJointFrame(const std::string& name) :
+    CartesianJointFrame<1>(name),
+    mZeroPos(Vector3::zeros()),
+    mJointAxis(Vector3::unit(1)),
+    mJointPos(0),
+    mJointVel(0),
+    mJointVelDot(0)
+  { }
+  virtual ~PrismaticJointFrame(void) {}
+
+  /// Gets the joint axis where this joint is allowed to rotate around.
+  const Vector3& getJointAxis(void) const
+  { return mJointAxis; }
+
+  /// Sets the joint axis where this joint is allowed to rotate around.
+  void setJointAxis(const Vector3& axis)
+  {
+    mJointAxis = axis;
+    setPosition(mZeroPos + mJointPos*mJointAxis);
+    setLinearRelVel(mJointVel*mJointAxis);
+    setLinearRelAccel(mJointVelDot*mJointAxis);
+  }
+
+  /// Returns the joint position.
+  const real_type& getJointPos(void) const
+  { return mJointPos; }
+
+  /// Sets the joint position.
+  void setJointPos(real_type pos)
+  { mJointPos = pos; setPosition(mZeroPos + mJointPos*mJointAxis); }
+
+  /// Returns the joint velocity.
+  const real_type& getJointVel(void) const
+  { return mJointVel; }
+
+  /// Sets the joint velocity.
+  void setJointVel(real_type vel)
+  { mJointVel = vel; setLinearRelVel(mJointVel*mJointAxis); }
+
+  /// Returns the derivative of the relative velocity
+  const real_type& getJointVelDot(void) const
+  { return mJointVelDot; }
+
+  /// Returns the derivative of the relative velocity
+  void setJointVelDot(real_type velDot)
+  { mJointVelDot = velDot; setLinearRelAccel(mJointVelDot*mJointAxis); }
+
+  /// Sets the zero position of the joint.
+  void setZeroPosition(const Vector3& zeroPos)
+  { mZeroPos = zeroPos; setPosition(mZeroPos + mJointPos*mJointAxis); }
+  const Vector3& getZeroPosition(void) const
+  { return mZeroPos; }
+
+  using Frame::setOrientation;
+  /// FIXME Hdot
+  
+private:
+  /// The zero position with respect to the parent frame.
+  Vector3 mZeroPos;
+  /// The joint rotation axis.
+  Vector3 mJointAxis;
+
+  /// The relative joint translation along the joint axis
+  real_type mJointPos;
+
+  /// The realtive linear velocity along the joint axis
+  real_type mJointVel;
+
+  /// The realtive linear velocity derivative along the joint axis
+  real_type mJointVelDot;
+};
+
+} // namespace OpenFDM
+
+#endif


Property changes on: trunk/OpenFDM/src/OpenFDM/PrismaticJointFrame.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp	2005-12-27 10:55:54 UTC (rev 127)
+++ trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp	2005-12-27 12:31:05 UTC (rev 128)
@@ -74,23 +74,22 @@
   // of the joint are.
   RigidBody* out = getOutboardBody();
   real_type tau = getJointForce();
-  return JointT<1>::jointArticulation(artI, artF, out->getPAlpha(),
-                                      tau*getJointAxis(),
-                                      getJointAxis());
+  return mRevoluteJointFrame->jointArticulation(artI, artF,
+                                                out->getArtInertia(),
+                                                out->getPAlpha(),
+                                                tau*getJointAxis(),
+                                                getJointAxis());
 }
 
 Vector6
 RevoluteJoint::computeRelAccel(const SpatialInertia&,
                                const Vector6&)
 {
-  Vector6 parentAccel = mRevoluteJointFrame->getParentSpAccel();
-
   RigidBody* out = getOutboardBody();
-  SpatialInertia artI = out->getArtInertia();
   Vector6 pAlpha = out->getPAlpha();
 
-  JointT<1>::VectorN acc;
-  JointT<1>::computeRelAccel(artI, parentAccel, pAlpha, getJointAxis(), acc);
+  CartesianJointFrame<1>::VectorN acc;
+  mRevoluteJointFrame->computeRelAccel(pAlpha, getJointAxis(), acc);
   mRevoluteJointFrame->setJointVelDot(acc(1));
   
   Log(ArtBody, Debug) << "Relative acceleration for Joint \""

Modified: trunk/OpenFDM/src/OpenFDM/RevoluteJoint.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RevoluteJoint.h	2005-12-27 10:55:54 UTC (rev 127)
+++ trunk/OpenFDM/src/OpenFDM/RevoluteJoint.h	2005-12-27 12:31:05 UTC (rev 128)
@@ -14,13 +14,13 @@
 #include "Frame.h"
 #include "RigidBody.h"
 #include "Joint.h"
-#include "JointT.h"
 #include "LineForce.h"
+#include "RevoluteJointFrame.h"
 
 namespace OpenFDM {
 
-class RevoluteJoint
-  : public Joint, public JointT<1> {
+class RevoluteJoint :
+    public Joint {
 public:
   RevoluteJoint(const std::string& name);
   virtual ~RevoluteJoint(void);

Added: trunk/OpenFDM/src/OpenFDM/RevoluteJointFrame.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RevoluteJointFrame.h	2005-12-27 10:55:54 UTC (rev 127)
+++ trunk/OpenFDM/src/OpenFDM/RevoluteJointFrame.h	2005-12-27 12:31:05 UTC (rev 128)
@@ -0,0 +1,106 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_RevoluteJointFrame_H
+#define OpenFDM_RevoluteJointFrame_H
+
+#include "Assert.h"
+#include "Object.h"
+#include "Vector.h"
+#include "Matrix.h"
+#include "Quaternion.h"
+#include "Inertia.h"
+#include "Frame.h"
+#include "RigidBody.h"
+#include "Joint.h"
+#include "LineForce.h"
+#include "CartesianJointFrame.h"
+
+namespace OpenFDM {
+
+class RevoluteJointFrame :
+    public CartesianJointFrame<1> {
+public:
+  RevoluteJointFrame(const std::string& name) :
+    CartesianJointFrame<1>(name),
+    mZeroOrient(Quaternion::unit()),
+    mJointAxis(Vector3::unit(1)),
+    mJointPos(0),
+    mJointVel(0),
+    mJointVelDot(0)
+  { }
+  virtual ~RevoluteJointFrame(void) {}
+
+  /// Gets the joint axis where this joint is allowed to rotate around.
+  const Vector3& getJointAxis(void) const
+  { return mJointAxis; }
+
+  /// Sets the joint axis where this joint is allowed to rotate around.
+  void setJointAxis(const Vector3& axis)
+  {
+    mJointAxis = axis;
+    setOrientation(mZeroOrient*Quaternion::fromAngleAxis(mJointPos, mJointAxis));
+    setAngularRelVel(mJointVel*mJointAxis);
+    setAngularRelAccel(mJointVelDot*mJointAxis);
+  }
+
+  /// Returns the joint position.
+  const real_type& getJointPos(void) const
+  { return mJointPos; }
+
+  /// Sets the joint position.
+  void setJointPos(real_type pos)
+  {
+    mJointPos = pos;
+    setOrientation(mZeroOrient*Quaternion::fromAngleAxis(mJointPos, mJointAxis));
+  }
+
+  /// Returns the joint velocity.
+  const real_type& getJointVel(void) const
+  { return mJointVel; }
+
+  /// Sets the joint velocity.
+  void setJointVel(real_type vel)
+  { mJointVel = vel; setAngularRelVel(mJointVel*mJointAxis); }
+
+  /// Returns the derivative of the relative velocity
+  const real_type& getJointVelDot(void) const
+  { return mJointVelDot; }
+
+  /// Returns the derivative of the relative velocity
+  void setJointVelDot(real_type velDot)
+  { mJointVelDot = velDot; setAngularRelAccel(mJointVelDot*mJointAxis); }
+
+  /// Sets the zero orientation of the joint.
+  void setZeroOrientation(const Quaternion& zeroOrient)
+  {
+    mZeroOrient = zeroOrient;
+    setOrientation(zeroOrient*Quaternion::fromAngleAxis(mJointPos, mJointAxis));
+  }
+  const Quaternion& getZeroOrientation(void) const
+  { return mZeroOrient; }
+
+  using Frame::setPosition;
+
+  /// FIXME Hdot
+
+private:
+  /// The zero orientation with respect to the parent frame.
+  Quaternion mZeroOrient;
+  /// The joint rotation axis.
+  Vector3 mJointAxis;
+
+  /// The relative joint rotation with respect to the zero orientation.
+  real_type mJointPos;
+
+  /// The rotational velocity with respect to the rotation axis.
+  real_type mJointVel;
+
+  /// The rotational velocity derivative with respect to the rotation axis.
+  real_type mJointVelDot;
+};
+
+} // namespace OpenFDM
+
+#endif


Property changes on: trunk/OpenFDM/src/OpenFDM/RevoluteJointFrame.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/OpenFDM/src/OpenFDM/RigidBody.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RigidBody.cpp	2005-12-27 10:55:54 UTC (rev 127)
+++ trunk/OpenFDM/src/OpenFDM/RigidBody.cpp	2005-12-27 12:31:05 UTC (rev 128)
@@ -34,8 +34,8 @@
                       << "\"" << endl;
 
   // At first this is the inertia matrix of the current body.
-  mArtInertia = SpatialInertia::zeros();
-  mArtForce = Vector6::zeros();
+  mArtInertia.clear();
+  mArtForce.clear();
 
   // Collect all articulated forces and inertias
   InteractList::iterator it;



From frohlich at berlios.de  Tue Dec 27 13:52:22 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Tue, 27 Dec 2005 13:52:22 +0100
Subject: [OpenFDM-svn] r129 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200512271252.jBRCqMOH003659@sheep.berlios.de>

Author: frohlich
Date: 2005-12-27 13:52:16 +0100 (Tue, 27 Dec 2005)
New Revision: 129

Modified:
   trunk/OpenFDM/src/OpenFDM/CartesianJointFrame.h
   trunk/OpenFDM/src/OpenFDM/Joint.h
   trunk/OpenFDM/src/OpenFDM/PrismaticJoint.cpp
   trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp
   trunk/OpenFDM/src/OpenFDM/RigidBody.h
Log:
Move getPAlpha out of RigidBody


Modified: trunk/OpenFDM/src/OpenFDM/CartesianJointFrame.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/CartesianJointFrame.h	2005-12-27 12:31:05 UTC (rev 128)
+++ trunk/OpenFDM/src/OpenFDM/CartesianJointFrame.h	2005-12-27 12:52:16 UTC (rev 129)
@@ -32,15 +32,21 @@
 
   bool jointArticulation(SpatialInertia& artI,
                          Vector6& artF,
+                         const Vector6& outF,
                          const SpatialInertia& outI,
-                         const Vector6& pAlpha,
                          const Vector6& jointForce,
                          const Matrix6N& jointAxis)
   {
     Log(ArtBody, Debug1) << artI << endl;
 
     mOutboardInertia = outI;
+    mOutboardForce = outF;
 
+
+    Vector6 pAlpha = outF + mOutboardInertia*getHdot();
+
+
+
     mJointForce = jointForce;
 
     Matrix6N Ih = outI*jointAxis;
@@ -60,13 +66,13 @@
     return true;
   }
   
-  void computeRelAccel(const Vector6& pAlpha,
-                       const Matrix6N& jointAxis,
+  void computeRelAccel(const Matrix6N& jointAxis,
                        VectorN& jointAccel) const
   {
     if (hIh.singular()) {
       jointAccel.clear();
     } else {
+      Vector6 pAlpha = mOutboardForce + mOutboardInertia*getHdot();
       Vector6 tmp = mJointForce - mOutboardInertia*getParentSpAccel() - pAlpha;
       jointAccel = hIh.solve(trans(jointAxis)*tmp);
     }
@@ -74,6 +80,7 @@
 
 private:
   SpatialInertia mOutboardInertia;
+  Vector6 mOutboardForce;
   Vector6 mJointForce;
   MatrixFactorsNN hIh;
 };

Modified: trunk/OpenFDM/src/OpenFDM/Joint.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Joint.h	2005-12-27 12:31:05 UTC (rev 128)
+++ trunk/OpenFDM/src/OpenFDM/Joint.h	2005-12-27 12:52:16 UTC (rev 129)
@@ -68,7 +68,6 @@
     rigidBody->contributeForce(frame->forceToParent(F));
   }
 
-
   // Joint slot ...
   // FIXME: pure virtual
   virtual bool jointArticulation(SpatialInertia& artI, Vector6& artF) = 0;

Modified: trunk/OpenFDM/src/OpenFDM/PrismaticJoint.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/PrismaticJoint.cpp	2005-12-27 12:31:05 UTC (rev 128)
+++ trunk/OpenFDM/src/OpenFDM/PrismaticJoint.cpp	2005-12-27 12:52:16 UTC (rev 129)
@@ -75,9 +75,10 @@
   // of the joint are.
   RigidBody* out = getOutboardBody();
   real_type tau = getJointForce();
+
   return mPrismaticJointFrame->jointArticulation(artI, artF,
+                                                 out->getArtForce(),
                                                  out->getArtInertia(),
-                                                 out->getPAlpha(),
                                                  tau*getJointAxis(),
                                                  getJointAxis());
 }
@@ -86,11 +87,8 @@
 PrismaticJoint::computeRelAccel(const SpatialInertia&,
                                 const Vector6&)
 {
-  RigidBody* out = getOutboardBody();
-  Vector6 pAlpha = out->getPAlpha();
-
   CartesianJointFrame<1>::VectorN acc;
-  mPrismaticJointFrame->computeRelAccel(pAlpha, getJointAxis(), acc);
+  mPrismaticJointFrame->computeRelAccel(getJointAxis(), acc);
   mPrismaticJointFrame->setJointVelDot(acc(1));
   Log(ArtBody, Debug) << "Relative acceleration for Joint \""
                       << getName() << "\" is " << trans(acc) << endl;

Modified: trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp	2005-12-27 12:31:05 UTC (rev 128)
+++ trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp	2005-12-27 12:52:16 UTC (rev 129)
@@ -75,8 +75,8 @@
   RigidBody* out = getOutboardBody();
   real_type tau = getJointForce();
   return mRevoluteJointFrame->jointArticulation(artI, artF,
+                                                out->getArtForce(),
                                                 out->getArtInertia(),
-                                                out->getPAlpha(),
                                                 tau*getJointAxis(),
                                                 getJointAxis());
 }
@@ -85,11 +85,8 @@
 RevoluteJoint::computeRelAccel(const SpatialInertia&,
                                const Vector6&)
 {
-  RigidBody* out = getOutboardBody();
-  Vector6 pAlpha = out->getPAlpha();
-
   CartesianJointFrame<1>::VectorN acc;
-  mRevoluteJointFrame->computeRelAccel(pAlpha, getJointAxis(), acc);
+  mRevoluteJointFrame->computeRelAccel(getJointAxis(), acc);
   mRevoluteJointFrame->setJointVelDot(acc(1));
   
   Log(ArtBody, Debug) << "Relative acceleration for Joint \""

Modified: trunk/OpenFDM/src/OpenFDM/RigidBody.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RigidBody.h	2005-12-27 12:31:05 UTC (rev 128)
+++ trunk/OpenFDM/src/OpenFDM/RigidBody.h	2005-12-27 12:52:16 UTC (rev 129)
@@ -5,15 +5,11 @@
 #ifndef OpenFDM_RigidBody_H
 #define OpenFDM_RigidBody_H
 
-#include <iosfwd>
-#include <list>
 #include <string>
+#include <vector>
 
-#include "Assert.h"
 #include "Object.h"
 #include "Vector.h"
-#include "Matrix.h"
-#include "Quaternion.h"
 #include "Inertia.h"
 #include "Frame.h"
 
@@ -64,11 +60,6 @@
   const Vector6& getArtForce(void) const
   { return mArtForce; }
 
-  /** HMM
-   */
-  Vector6 getPAlpha(void) const
-  { return mArtForce + mArtInertia*getFrame()->getHdot(); }
-
   /// Contribute articulated force
   void contributeForce(const Vector6& force)
   { mArtForce += force; }



From frohlich at berlios.de  Tue Dec 27 15:56:09 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Tue, 27 Dec 2005 15:56:09 +0100
Subject: [OpenFDM-svn] r130 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200512271456.jBREu9Km003893@sheep.berlios.de>

Author: frohlich
Date: 2005-12-27 15:56:05 +0100 (Tue, 27 Dec 2005)
New Revision: 130

Modified:
   trunk/OpenFDM/src/OpenFDM/CartesianJointFrame.h
   trunk/OpenFDM/src/OpenFDM/PrismaticJoint.cpp
   trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp
Log:
Make joint internal forces use the dimension of the joint


Modified: trunk/OpenFDM/src/OpenFDM/CartesianJointFrame.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/CartesianJointFrame.h	2005-12-27 12:52:16 UTC (rev 129)
+++ trunk/OpenFDM/src/OpenFDM/CartesianJointFrame.h	2005-12-27 14:56:05 UTC (rev 130)
@@ -34,7 +34,7 @@
                          Vector6& artF,
                          const Vector6& outF,
                          const SpatialInertia& outI,
-                         const Vector6& jointForce,
+                         const VectorN& jointForce,
                          const Matrix6N& jointAxis)
   {
     Log(ArtBody, Debug1) << artI << endl;
@@ -57,9 +57,7 @@
 
     artF = pAlpha;
     
-    Vector6 mForcePAlpha = pAlpha - jointForce;
-
-    artF -= Ih*hIh.solve(trans(jointAxis)*mForcePAlpha);
+    artF -= Ih*hIh.solve(trans(jointAxis)*pAlpha - jointForce);
     artI = outI;
     artI -= SpatialInertia(Ih*hIh.solve(trans(Ih)));
 
@@ -73,15 +71,15 @@
       jointAccel.clear();
     } else {
       Vector6 pAlpha = mOutboardForce + mOutboardInertia*getHdot();
-      Vector6 tmp = mJointForce - mOutboardInertia*getParentSpAccel() - pAlpha;
-      jointAccel = hIh.solve(trans(jointAxis)*tmp);
+      Vector6 tmp = - mOutboardInertia*getParentSpAccel() - pAlpha;
+      jointAccel = hIh.solve(trans(jointAxis)*tmp + mJointForce);
     }
   }
 
 private:
   SpatialInertia mOutboardInertia;
   Vector6 mOutboardForce;
-  Vector6 mJointForce;
+  VectorN mJointForce;
   MatrixFactorsNN hIh;
 };
 

Modified: trunk/OpenFDM/src/OpenFDM/PrismaticJoint.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/PrismaticJoint.cpp	2005-12-27 12:52:16 UTC (rev 129)
+++ trunk/OpenFDM/src/OpenFDM/PrismaticJoint.cpp	2005-12-27 14:56:05 UTC (rev 130)
@@ -74,12 +74,12 @@
   // That projects away tha components where the degrees of freedom
   // of the joint are.
   RigidBody* out = getOutboardBody();
-  real_type tau = getJointForce();
-
+  LinAlg::Vector<real_type,1> tau;
+  tau(1) = getJointForce();
   return mPrismaticJointFrame->jointArticulation(artI, artF,
                                                  out->getArtForce(),
                                                  out->getArtInertia(),
-                                                 tau*getJointAxis(),
+                                                 tau,
                                                  getJointAxis());
 }
 

Modified: trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp	2005-12-27 12:52:16 UTC (rev 129)
+++ trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp	2005-12-27 14:56:05 UTC (rev 130)
@@ -73,11 +73,12 @@
   // That projects away tha components where the degrees of freedom
   // of the joint are.
   RigidBody* out = getOutboardBody();
-  real_type tau = getJointForce();
+  LinAlg::Vector<real_type,1> tau;
+  tau(1) = getJointForce();
   return mRevoluteJointFrame->jointArticulation(artI, artF,
                                                 out->getArtForce(),
                                                 out->getArtInertia(),
-                                                tau*getJointAxis(),
+                                                tau,
                                                 getJointAxis());
 }
 



From frohlich at berlios.de  Tue Dec 27 16:29:34 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Tue, 27 Dec 2005 16:29:34 +0100
Subject: [OpenFDM-svn] r131 - in trunk/OpenFDM/src: JSBSim OpenFDM
Message-ID: <200512271529.jBRFTYux006993@sheep.berlios.de>

Author: frohlich
Date: 2005-12-27 16:29:26 +0100 (Tue, 27 Dec 2005)
New Revision: 131

Modified:
   trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
   trunk/OpenFDM/src/OpenFDM/CartesianJointFrame.h
   trunk/OpenFDM/src/OpenFDM/Frame.cpp
   trunk/OpenFDM/src/OpenFDM/Frame.h
   trunk/OpenFDM/src/OpenFDM/FreeJoint.cpp
   trunk/OpenFDM/src/OpenFDM/FreeJoint.h
   trunk/OpenFDM/src/OpenFDM/Joint.h
   trunk/OpenFDM/src/OpenFDM/PrismaticJoint.cpp
   trunk/OpenFDM/src/OpenFDM/PrismaticJoint.h
   trunk/OpenFDM/src/OpenFDM/PrismaticJointFrame.h
   trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp
   trunk/OpenFDM/src/OpenFDM/RevoluteJoint.h
   trunk/OpenFDM/src/OpenFDM/RevoluteJointFrame.h
Log:
Rename RelAccel to RelVelDot


Modified: trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
===================================================================
--- trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2005-12-27 14:56:05 UTC (rev 130)
+++ trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2005-12-27 15:29:26 UTC (rev 131)
@@ -707,13 +707,13 @@
     spi += inertiaFrom(structToBody(it->first), inertia);
     ++it;
   }
-  mVehicle->getTopBody()->addInteract(new Mass(spi));
+  mVehicle->getTopBody()->addInteract(new Mass("Emptyweight Mass", spi));
 
   // Attach the eye point.
   FreeFrame* epFrame = new FreeFrame("Eyepoint Frame");
   epFrame->setPosition(structToBody(ep));
   epFrame->setRelVel(Vector6::zeros());
-  epFrame->setRelAccel(Vector6::zeros());
+  epFrame->setRelVelDot(Vector6::zeros());
   Sensor* accelSensor = new Sensor("Acceleration Sensor");
   accelSensor->addSampleTime(SampleTime(1.0/120));
   Port* port = accelSensor->getOutputPort("nz");
@@ -738,13 +738,12 @@
 {
   RigidBody* wheel = new RigidBody(name + " Wheel");
   InertiaMatrix wheelInertia(10, 0, 0, 100, 0, 10);
-  wheel->addInteract(new Mass(SpatialInertia(wheelInertia, 50)));
-  parent->getFrame()->addChildFrame(wheel->getFrame());
+  wheel->addInteract(new Mass("Wheel Inertia", SpatialInertia(wheelInertia, 50)));
   mVehicle->getMultiBodySystem()->addRigidBody(wheel);
   
   RevoluteJoint* wj = new RevoluteJoint(name + " Wheel Joint");
   parent->addInteract(wj);
-  wheel->addInteract(wj);
+  wheel->setInboardJoint(wj);
   wj->setJointAxis(Vector3(0, 1, 0));
   wj->setPosition(pos);
   wj->setOrientation(Quaternion::unit());
@@ -926,13 +925,12 @@
       // This is the movable part of the strut, doing the compression
       RigidBody* arm = new RigidBody(name + " Arm");
       mVehicle->getMultiBodySystem()->addRigidBody(arm);
-      mVehicle->getTopBody()->getFrame()->addChildFrame(arm->getFrame());
-      arm->addInteract(new Mass(inertiaFrom(Vector3(-1, 0, 0), SpatialInertia(200))));
+      arm->addInteract(new Mass("Strut Mass", inertiaFrom(Vector3(-1, 0, 0), SpatialInertia(200))));
 
       // Connect that with a revolute joint to the main body
       RevoluteJoint* rj = new RevoluteJoint(name + " Arm Joint");
       mVehicle->getTopBody()->addInteract(rj);
-      arm->addInteract(rj);
+      arm->setInboardJoint(rj);
       rj->setJointAxis(Vector3(0, 1, 0));
       rj->setJointPos(0);
       rj->setJointVel(0);
@@ -1001,14 +999,13 @@
         // A new part modelling the steering
         RigidBody* steer = new RigidBody(name + " Steer");
         mVehicle->getMultiBodySystem()->addRigidBody(steer);
-        strutParent->getFrame()->addChildFrame(steer->getFrame());
 
         // connect that via a revolute joint to the toplevel body.
         // Note the 0.05m below, most steering wheels have some kind of
         // castering auto line up behavour. That is doe with this 0.05m.
         RevoluteJoint* sj = new RevoluteJoint(name + " Steer Joint");
         strutParent->addInteract(sj);
-        steer->addInteract(sj);
+        steer->setInboardJoint(sj);
         sj->setJointAxis(Vector3(0, 0, 1));
         sj->setJointPos(0);
         sj->setJointVel(0);
@@ -1044,13 +1041,12 @@
       // Now the compressible part of the strut
       RigidBody* arm = new RigidBody(name + " Strut");
       mVehicle->getMultiBodySystem()->addRigidBody(arm);
-      strutParent->getFrame()->addChildFrame(arm->getFrame());
-      arm->addInteract(new Mass(inertiaFrom(Vector3(0, 0, 1), SpatialInertia(200))));
+      arm->addInteract(new Mass("Strut Mass", inertiaFrom(Vector3(0, 0, 1), SpatialInertia(200))));
 
       // This time it is a prismatic joint
       PrismaticJoint* pj = new PrismaticJoint(name + " Compress Joint");
       strutParent->addInteract(pj);
-      arm->addInteract(pj);
+      arm->setInboardJoint(pj);
       pj->setJointAxis(Vector3(0, 0, -1));
       if (strutParent == mVehicle->getTopBody())
         pj->setPosition(structToBody(compressJointPos));

Modified: trunk/OpenFDM/src/OpenFDM/CartesianJointFrame.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/CartesianJointFrame.h	2005-12-27 14:56:05 UTC (rev 130)
+++ trunk/OpenFDM/src/OpenFDM/CartesianJointFrame.h	2005-12-27 15:29:26 UTC (rev 131)
@@ -64,8 +64,8 @@
     return true;
   }
   
-  void computeRelAccel(const Matrix6N& jointAxis,
-                       VectorN& jointAccel) const
+  void computeRelVelDot(const Matrix6N& jointAxis,
+                        VectorN& jointAccel) const
   {
     if (hIh.singular()) {
       jointAccel.clear();

Modified: trunk/OpenFDM/src/OpenFDM/Frame.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Frame.cpp	2005-12-27 14:56:05 UTC (rev 130)
+++ trunk/OpenFDM/src/OpenFDM/Frame.cpp	2005-12-27 15:29:26 UTC (rev 131)
@@ -26,14 +26,14 @@
   setPosition(Vector3::zeros());
   setOrientation(Quaternion::unit());
   setRelVel(Vector6::zeros());
-  setRelAccel(Vector6::zeros());
+  setRelVelDot(Vector6::zeros());
 
   addProperty("position", Property(this, &Frame::getPosition));
   addProperty("orienatation", Property(this, &Frame::getOrientation));
   addProperty("relVel", Property(this, &Frame::getRelVel));
   addProperty("spVel", Property(this, &Frame::getSpVel));
   addProperty("refVel", Property(this, &Frame::getRefVel));
-  addProperty("relAccel", Property(this, &Frame::getRelAccel));
+  addProperty("relVelDot", Property(this, &Frame::getRelVelDot));
   addProperty("spAccel", Property(this, &Frame::getSpAccel));
   addProperty("classicAccel", Property(this, &Frame::getClassicAccel));
   addProperty("refPosition", Property(this, &Frame::getRefPosition));

Modified: trunk/OpenFDM/src/OpenFDM/Frame.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Frame.h	2005-12-27 14:56:05 UTC (rev 130)
+++ trunk/OpenFDM/src/OpenFDM/Frame.h	2005-12-27 15:29:26 UTC (rev 131)
@@ -42,8 +42,6 @@
 parent frame.
 */
 
-/// FIXME: RelAccel->VelDot ...
-
 class Frame :
     public Object {
 public:
@@ -155,8 +153,8 @@
               to the parent frame. The velocity is in the current frames
               coordinates.
    */
-  const Vector6& getRelAccel(void) const 
-  { return mRelAccel; }
+  const Vector6& getRelVelDot(void) const 
+  { return mRelVelDot; }
 
 
   /** Linear velocity with respect to parent.
@@ -204,15 +202,15 @@
       @return The linear acceleration of this frame with respect to the parent
       frame.
    */
-  Vector3 getLinearRelAccel(void) const
-  { return getRelAccel().getLinear(); }
+  Vector3 getLinearRelVelDot(void) const
+  { return getRelVelDot().getLinear(); }
 
   /** Angular acceleration with respect to parent.
       @return The angular acceleration of this frame with respect to the parent
       frame.
    */
-  Vector3 getAngularRelAccel(void) const
-  { return getRelAccel().getAngular(); }
+  Vector3 getAngularRelVelDot(void) const
+  { return getRelVelDot().getAngular(); }
 
   /** Spatial acceleration of the parent frame.
       @return The spatial acceleration of the parent frame with respect to an
@@ -238,7 +236,7 @@
   Vector6 getSpAccel(void) const
   {
     OpenFDMAssert(!mDisableSpAccel);
-    return getRelAccel() + getParentSpAccel() + getHdot();
+    return getRelVelDot() + getParentSpAccel() + getHdot();
   }
 
   /** Classical acceleration of the current frame.
@@ -250,7 +248,7 @@
   {
     OpenFDMAssert(!mDisableSpAccel);
     Vector6 iv = getSpVel();
-    return getRelAccel() + getParentSpAccel() + getHdot()
+    return getRelVelDot() + getParentSpAccel() + getHdot()
       + Vector6(Vector3::zeros(), cross(iv.getAngular(), iv.getLinear()));
   }
 
@@ -472,12 +470,12 @@
   { setVelDirty(); mRelVel.setLinear(v); }
   void setAngularRelVel(const Vector3& rotVel)
   { setVelDirty(); mRelVel.setAngular(rotVel); }
-  void setRelAccel(const Vector6& accel)
-  { setAccelDirty(); mRelAccel = accel; }
-  void setLinearRelAccel(const Vector3& accel)
-  { setAccelDirty(); mRelAccel.setLinear(accel); }
-  void setAngularRelAccel(const Vector3& accel)
-  { setAccelDirty(); mRelAccel.setAngular(accel); }
+  void setRelVelDot(const Vector6& accel)
+  { setAccelDirty(); mRelVelDot = accel; }
+  void setLinearRelVelDot(const Vector3& accel)
+  { setAccelDirty(); mRelVelDot.setLinear(accel); }
+  void setAngularRelVelDot(const Vector3& accel)
+  { setAccelDirty(); mRelVelDot.setAngular(accel); }
 
   void disableAccel(void)
   { mDisableSpAccel = true; }
@@ -542,7 +540,7 @@
 
   // The spatial acceleration of this frame wrt the parent frame.
   // True? more the relative acceleration ...
-  Vector6 mRelAccel;
+  Vector6 mRelVelDot;
 
   mutable Vector6 mParentSpVel;
   mutable Vector6 mParentSpAccel;
@@ -590,12 +588,12 @@
   { Frame::setLinearRelVel(vel); }
   void setAngularRelVel(const Vector3& vel)
   { Frame::setAngularRelVel(vel); }
-  void setRelAccel(const Vector6& accel)
-  { Frame::setRelAccel(accel); }
-  void setLinearRelAccel(const Vector3& accel)
-  { Frame::setLinearRelAccel(accel); }
-  void setAngularRelAccel(const Vector3& accel)
-  { Frame::setAngularRelAccel(accel); }
+  void setRelVelDot(const Vector6& accel)
+  { Frame::setRelVelDot(accel); }
+  void setLinearRelVelDot(const Vector3& accel)
+  { Frame::setLinearRelVelDot(accel); }
+  void setAngularRelVelDot(const Vector3& accel)
+  { Frame::setAngularRelVelDot(accel); }
 
   void setRefPosition(const Vector3& p)
   { Frame::setRefPosition(p); }

Modified: trunk/OpenFDM/src/OpenFDM/FreeJoint.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/FreeJoint.cpp	2005-12-27 14:56:05 UTC (rev 130)
+++ trunk/OpenFDM/src/OpenFDM/FreeJoint.cpp	2005-12-27 15:29:26 UTC (rev 131)
@@ -89,13 +89,13 @@
 }
 
 Vector6
-FreeJoint::computeRelAccel(const SpatialInertia& artI,
-                           const Vector6& artF)
+FreeJoint::computeRelVelDot(const SpatialInertia& artI,
+                            const Vector6& artF)
 {
   RigidBody* topBody = getParentRigidBody(0);
   OpenFDMAssert(topBody);
 
-  Log(ArtBody, Debug) << "FreeJoint::computeRelAccel():\n" << artI << endl;
+  Log(ArtBody, Debug) << "FreeJoint::computeRelVelDot():\n" << artI << endl;
 
   // Assumption: body is small compared to the distance to the planets
   // center of mass. That means gravity could be considered equal for the whole
@@ -169,7 +169,7 @@
   state(offset+6) = vel(2);
   state(offset+7) = vel(3);
   
-  Vector6 accel = mFrame->getRelAccel();
+  Vector6 accel = mFrame->getRelVelDot();
   state(offset+8)  = accel(1);
   state(offset+9)  = accel(2);
   state(offset+10) = accel(3);

Modified: trunk/OpenFDM/src/OpenFDM/FreeJoint.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/FreeJoint.h	2005-12-27 14:56:05 UTC (rev 130)
+++ trunk/OpenFDM/src/OpenFDM/FreeJoint.h	2005-12-27 15:29:26 UTC (rev 131)
@@ -51,8 +51,8 @@
   virtual bool jointArticulation(SpatialInertia& artI, Vector6& artF);
   /** Plugin function for the articulated body algorithm.
    */
-  virtual Vector6 computeRelAccel(const SpatialInertia& artI,
-                                  const Vector6& artF);
+  virtual Vector6 computeRelVelDot(const SpatialInertia& artI,
+                                   const Vector6& artF);
 
 
   /** Plugin function for the state propagation.

Modified: trunk/OpenFDM/src/OpenFDM/Joint.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Joint.h	2005-12-27 14:56:05 UTC (rev 130)
+++ trunk/OpenFDM/src/OpenFDM/Joint.h	2005-12-27 15:29:26 UTC (rev 131)
@@ -71,8 +71,8 @@
   // Joint slot ...
   // FIXME: pure virtual
   virtual bool jointArticulation(SpatialInertia& artI, Vector6& artF) = 0;
-  virtual Vector6 computeRelAccel(const SpatialInertia& artI,
-                                  const Vector6& artF) = 0;
+  virtual Vector6 computeRelVelDot(const SpatialInertia& artI,
+                                   const Vector6& artF) = 0;
 
   //???
   bool updateAccels(RigidBody* rigidBody)
@@ -85,8 +85,8 @@
       return false;
 
     // Set the local acceleration
-    Vector6 accel = computeRelAccel(outboardBody->getArtInertia(),
-                                    outboardBody->getArtForce());
+    Vector6 accel = computeRelVelDot(outboardBody->getArtInertia(),
+                                     outboardBody->getArtForce());
     
     Frame* frame0 = outboardBody->getFrame();
     if (!frame0)
@@ -94,7 +94,7 @@
     frame0->enableAccel();
     FreeFrame* frame = dynamic_cast<FreeFrame*>(frame0);
     if (frame)
-      frame->setRelAccel(accel);
+      frame->setRelVelDot(accel);
 
     outboardBody->computeAccel();
 

Modified: trunk/OpenFDM/src/OpenFDM/PrismaticJoint.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/PrismaticJoint.cpp	2005-12-27 14:56:05 UTC (rev 130)
+++ trunk/OpenFDM/src/OpenFDM/PrismaticJoint.cpp	2005-12-27 15:29:26 UTC (rev 131)
@@ -84,11 +84,11 @@
 }
 
 Vector6
-PrismaticJoint::computeRelAccel(const SpatialInertia&,
-                                const Vector6&)
+PrismaticJoint::computeRelVelDot(const SpatialInertia&,
+                                 const Vector6&)
 {
   CartesianJointFrame<1>::VectorN acc;
-  mPrismaticJointFrame->computeRelAccel(getJointAxis(), acc);
+  mPrismaticJointFrame->computeRelVelDot(getJointAxis(), acc);
   mPrismaticJointFrame->setJointVelDot(acc(1));
   Log(ArtBody, Debug) << "Relative acceleration for Joint \""
                       << getName() << "\" is " << trans(acc) << endl;

Modified: trunk/OpenFDM/src/OpenFDM/PrismaticJoint.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/PrismaticJoint.h	2005-12-27 14:56:05 UTC (rev 130)
+++ trunk/OpenFDM/src/OpenFDM/PrismaticJoint.h	2005-12-27 15:29:26 UTC (rev 131)
@@ -108,8 +108,8 @@
   /** Computes the relative acceleration of this body with respect to its
       parent. It is part of the articulated body algorithm.
    */
-  virtual Vector6 computeRelAccel(const SpatialInertia& artI,
-                                  const Vector6& artF);
+  virtual Vector6 computeRelVelDot(const SpatialInertia& artI,
+                                   const Vector6& artF);
 
   /** Methods for the OpenFDM::Part.
    */

Modified: trunk/OpenFDM/src/OpenFDM/PrismaticJointFrame.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/PrismaticJointFrame.h	2005-12-27 14:56:05 UTC (rev 130)
+++ trunk/OpenFDM/src/OpenFDM/PrismaticJointFrame.h	2005-12-27 15:29:26 UTC (rev 131)
@@ -42,7 +42,7 @@
     mJointAxis = axis;
     setPosition(mZeroPos + mJointPos*mJointAxis);
     setLinearRelVel(mJointVel*mJointAxis);
-    setLinearRelAccel(mJointVelDot*mJointAxis);
+    setLinearRelVelDot(mJointVelDot*mJointAxis);
   }
 
   /// Returns the joint position.
@@ -67,7 +67,7 @@
 
   /// Returns the derivative of the relative velocity
   void setJointVelDot(real_type velDot)
-  { mJointVelDot = velDot; setLinearRelAccel(mJointVelDot*mJointAxis); }
+  { mJointVelDot = velDot; setLinearRelVelDot(mJointVelDot*mJointAxis); }
 
   /// Sets the zero position of the joint.
   void setZeroPosition(const Vector3& zeroPos)

Modified: trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp	2005-12-27 14:56:05 UTC (rev 130)
+++ trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp	2005-12-27 15:29:26 UTC (rev 131)
@@ -83,11 +83,11 @@
 }
 
 Vector6
-RevoluteJoint::computeRelAccel(const SpatialInertia&,
-                               const Vector6&)
+RevoluteJoint::computeRelVelDot(const SpatialInertia&,
+                                const Vector6&)
 {
   CartesianJointFrame<1>::VectorN acc;
-  mRevoluteJointFrame->computeRelAccel(getJointAxis(), acc);
+  mRevoluteJointFrame->computeRelVelDot(getJointAxis(), acc);
   mRevoluteJointFrame->setJointVelDot(acc(1));
   
   Log(ArtBody, Debug) << "Relative acceleration for Joint \""

Modified: trunk/OpenFDM/src/OpenFDM/RevoluteJoint.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RevoluteJoint.h	2005-12-27 14:56:05 UTC (rev 130)
+++ trunk/OpenFDM/src/OpenFDM/RevoluteJoint.h	2005-12-27 15:29:26 UTC (rev 131)
@@ -108,8 +108,8 @@
   /** Computes the relative acceleration of this body with respect to its
       parent. It is part of the articulated body algorithm.
    */
-  virtual Vector6 computeRelAccel(const SpatialInertia& artI,
-                                  const Vector6& artF);
+  virtual Vector6 computeRelVelDot(const SpatialInertia& artI,
+                                   const Vector6& artF);
 
   /** Methods for the OpenFDM::Part.
    */

Modified: trunk/OpenFDM/src/OpenFDM/RevoluteJointFrame.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RevoluteJointFrame.h	2005-12-27 14:56:05 UTC (rev 130)
+++ trunk/OpenFDM/src/OpenFDM/RevoluteJointFrame.h	2005-12-27 15:29:26 UTC (rev 131)
@@ -42,7 +42,7 @@
     mJointAxis = axis;
     setOrientation(mZeroOrient*Quaternion::fromAngleAxis(mJointPos, mJointAxis));
     setAngularRelVel(mJointVel*mJointAxis);
-    setAngularRelAccel(mJointVelDot*mJointAxis);
+    setAngularRelVelDot(mJointVelDot*mJointAxis);
   }
 
   /// Returns the joint position.
@@ -70,7 +70,7 @@
 
   /// Returns the derivative of the relative velocity
   void setJointVelDot(real_type velDot)
-  { mJointVelDot = velDot; setAngularRelAccel(mJointVelDot*mJointAxis); }
+  { mJointVelDot = velDot; setAngularRelVelDot(mJointVelDot*mJointAxis); }
 
   /// Sets the zero orientation of the joint.
   void setZeroOrientation(const Quaternion& zeroOrient)



From frohlich at berlios.de  Tue Dec 27 21:17:14 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Tue, 27 Dec 2005 21:17:14 +0100
Subject: [OpenFDM-svn] r132 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200512272017.jBRKHENi005256@sheep.berlios.de>

Author: frohlich
Date: 2005-12-27 21:17:05 +0100 (Tue, 27 Dec 2005)
New Revision: 132

Added:
   trunk/OpenFDM/src/OpenFDM/Joint.cpp
Modified:
   trunk/OpenFDM/src/OpenFDM/CartesianJointFrame.h
   trunk/OpenFDM/src/OpenFDM/FreeJoint.cpp
   trunk/OpenFDM/src/OpenFDM/FreeJoint.h
   trunk/OpenFDM/src/OpenFDM/Joint.h
   trunk/OpenFDM/src/OpenFDM/Makefile.am
   trunk/OpenFDM/src/OpenFDM/MultiBodySystem.cpp
   trunk/OpenFDM/src/OpenFDM/PrismaticJoint.cpp
   trunk/OpenFDM/src/OpenFDM/PrismaticJoint.h
   trunk/OpenFDM/src/OpenFDM/PrismaticJointFrame.h
   trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp
   trunk/OpenFDM/src/OpenFDM/RevoluteJoint.h
   trunk/OpenFDM/src/OpenFDM/RevoluteJointFrame.h
Log:
More prearations for moving acceleration computation into the Frame's


Modified: trunk/OpenFDM/src/OpenFDM/CartesianJointFrame.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/CartesianJointFrame.h	2005-12-27 15:29:26 UTC (rev 131)
+++ trunk/OpenFDM/src/OpenFDM/CartesianJointFrame.h	2005-12-27 20:17:05 UTC (rev 132)
@@ -17,25 +17,30 @@
 class CartesianJointFrame :
   public Frame {
 public:
+  typedef LinAlg::Vector<real_type,n> VectorN;
+  typedef LinAlg::Matrix<real_type,6,n> Matrix6N;
+  typedef LinAlg::Matrix<real_type,n,n> MatrixNN;
+  typedef LinAlg::MatrixFactors<real_type,n,n,LinAlg::LUTag> MatrixFactorsNN;
+
   CartesianJointFrame(const std::string& name) :
     Frame(name)
   { }
   virtual ~CartesianJointFrame(void)
   { }
 
+protected:
+  const Matrix6N& getJointMatrix(void) const
+  { return mJointMatrix; }
 
-// protected:
-  typedef LinAlg::Vector<real_type,n> VectorN;
-  typedef LinAlg::Matrix<real_type,6,n> Matrix6N;
-  typedef LinAlg::Matrix<real_type,n,n> MatrixNN;
-  typedef LinAlg::MatrixFactors<real_type,n,n,LinAlg::LUTag> MatrixFactorsNN;
+  void setJointMatrix(const Matrix6N& jointAxis)
+  { mJointMatrix = jointAxis; }
 
+public: /// FIXME
   bool jointArticulation(SpatialInertia& artI,
                          Vector6& artF,
                          const Vector6& outF,
                          const SpatialInertia& outI,
-                         const VectorN& jointForce,
-                         const Matrix6N& jointAxis)
+                         const VectorN& jointForce)
   {
     Log(ArtBody, Debug1) << artI << endl;
 
@@ -43,42 +48,42 @@
     mOutboardForce = outF;
 
 
-    Vector6 pAlpha = outF + mOutboardInertia*getHdot();
+    mPAlpha = outF + mOutboardInertia*getHdot();
 
 
 
     mJointForce = jointForce;
 
-    Matrix6N Ih = outI*jointAxis;
-    hIh = trans(jointAxis)*Ih;
+    Matrix6N Ih = outI*mJointMatrix;
+    hIh = trans(mJointMatrix)*Ih;
 
     if (hIh.singular())
       return false;
 
-    artF = pAlpha;
+    artF = mPAlpha;
     
-    artF -= Ih*hIh.solve(trans(jointAxis)*pAlpha - jointForce);
+    artF -= Ih*hIh.solve(trans(mJointMatrix)*mPAlpha - jointForce);
     artI = outI;
     artI -= SpatialInertia(Ih*hIh.solve(trans(Ih)));
 
     return true;
   }
   
-  void computeRelVelDot(const Matrix6N& jointAxis,
-                        VectorN& jointAccel) const
+  void computeRelVelDot(VectorN& jointAccel) const
   {
     if (hIh.singular()) {
       jointAccel.clear();
     } else {
-      Vector6 pAlpha = mOutboardForce + mOutboardInertia*getHdot();
-      Vector6 tmp = - mOutboardInertia*getParentSpAccel() - pAlpha;
-      jointAccel = hIh.solve(trans(jointAxis)*tmp + mJointForce);
+      Vector6 tmp = mOutboardInertia*getParentSpAccel() + mPAlpha;
+      jointAccel = hIh.solve(mJointForce - trans(mJointMatrix)*tmp);
     }
   }
 
 private:
   SpatialInertia mOutboardInertia;
   Vector6 mOutboardForce;
+  Vector6 mPAlpha;
+  Matrix6N mJointMatrix;
   VectorN mJointForce;
   MatrixFactorsNN hIh;
 };

Modified: trunk/OpenFDM/src/OpenFDM/FreeJoint.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/FreeJoint.cpp	2005-12-27 15:29:26 UTC (rev 131)
+++ trunk/OpenFDM/src/OpenFDM/FreeJoint.cpp	2005-12-27 20:17:05 UTC (rev 132)
@@ -82,21 +82,15 @@
 }
 
 bool
-FreeJoint::jointArticulation(SpatialInertia& artI, Vector6& artF)
+FreeJoint::jointArticulation(SpatialInertia& artI, Vector6& artF,
+                             const SpatialInertia& outI,
+                             const Vector6& outF)
 {
-  artI = SpatialInertia::zeros();
-  artF = Vector6::zeros();
-}
+  artI.clear();
+  artF.clear();
 
-Vector6
-FreeJoint::computeRelVelDot(const SpatialInertia& artI,
-                            const Vector6& artF)
-{
-  RigidBody* topBody = getParentRigidBody(0);
-  OpenFDMAssert(topBody);
+  Log(ArtBody, Debug) << "FreeJoint::computeRelVelDot():\n" << outI << endl;
 
-  Log(ArtBody, Debug) << "FreeJoint::computeRelVelDot():\n" << artI << endl;
-
   // Assumption: body is small compared to the distance to the planets
   // center of mass. That means gravity could be considered equal for the whole
   // vehicle.
@@ -105,17 +99,25 @@
   Vector6 grav = Vector6(Vector3::zeros(), mFrame->rotFromRef(ga));
 
   Log(ArtBody, Debug) << "grav = " << trans(grav) << endl
-                      << "solve = " << trans(solve(artI, artF)) << endl
+                      << "solve = " << trans(solve(outI, outF)) << endl
                       << "parent spatial accel = "
                       << trans(mFrame->getParentSpAccel()) << endl
                       << "Hdot = " << trans(mFrame->getHdot()) << endl;
   
-  Vector6 accel = grav - solve(artI, artF)
+  Vector6 accel = grav - solve(outI, outF)
     - mFrame->getParentSpAccel() - mFrame->getHdot();
-  return accel;
+  
+  mFrame->setRelVelDot(accel);
+
+  return true;
 }
 
 void
+FreeJoint::computeRelVelDot()
+{
+}
+
+void
 FreeJoint::setState(const Vector& state, unsigned offset)
 {
   mFrame->setOrientation(Vector4(state(offset+1), state(offset+2),

Modified: trunk/OpenFDM/src/OpenFDM/FreeJoint.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/FreeJoint.h	2005-12-27 15:29:26 UTC (rev 131)
+++ trunk/OpenFDM/src/OpenFDM/FreeJoint.h	2005-12-27 20:17:05 UTC (rev 132)
@@ -48,11 +48,12 @@
 private:
   /** Plugin function for the articulated body algorithm.
    */
-  virtual bool jointArticulation(SpatialInertia& artI, Vector6& artF);
+  virtual bool jointArticulation(SpatialInertia& artI, Vector6& artF,
+                                 const SpatialInertia& outI,
+                                 const Vector6& outF);
   /** Plugin function for the articulated body algorithm.
    */
-  virtual Vector6 computeRelVelDot(const SpatialInertia& artI,
-                                   const Vector6& artF);
+  virtual void computeRelVelDot();
 
 
   /** Plugin function for the state propagation.

Added: trunk/OpenFDM/src/OpenFDM/Joint.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Joint.cpp	2005-12-27 15:29:26 UTC (rev 131)
+++ trunk/OpenFDM/src/OpenFDM/Joint.cpp	2005-12-27 20:17:05 UTC (rev 132)
@@ -0,0 +1,28 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
+ *
+ */
+
+#include "Assert.h"
+#include "Object.h"
+#include "Frame.h"
+#include "Vector.h"
+#include "Matrix.h"
+#include "Quaternion.h"
+#include "Inertia.h"
+#include "Interact.h"
+#include "Frame.h"
+#include "LogStream.h"
+#include "Joint.h"
+
+namespace OpenFDM {
+
+Joint::Joint(const std::string& name)
+  : Interact(name, 2)
+{
+}
+
+Joint::~Joint(void)
+{
+}
+
+} // namespace OpenFDM


Property changes on: trunk/OpenFDM/src/OpenFDM/Joint.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/OpenFDM/src/OpenFDM/Joint.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Joint.h	2005-12-27 15:29:26 UTC (rev 131)
+++ trunk/OpenFDM/src/OpenFDM/Joint.h	2005-12-27 20:17:05 UTC (rev 132)
@@ -21,9 +21,8 @@
 class Joint
   : public Interact {
 public:
-  Joint(const std::string& name)
-    : Interact(name, 2)
-  {}
+  Joint(const std::string& name);
+  virtual ~Joint(void);
 
   /// FIXME: joint's should be lockable, which means trylock == true and
   /// velocity small enough - keep position ...
@@ -55,7 +54,8 @@
     // Apply the joint degrees of freedom to that.
     // If there was an error, (something was singular ???)
     // just ignore that part. FIXME, ist this ok????
-    if (!jointArticulation(I, F))
+    if (!jointArticulation(I, F, outboardBody->getArtInertia(),
+                           outboardBody->getArtForce()))
       return;
 
     Log(ArtBody, Debug3) << "Outboard Articulated values past joint "
@@ -63,6 +63,8 @@
                          << "\nInertia\n" << I << endl;
 
     // Contribute the transformed values to the parent.
+    if (!rigidBody)
+      return;
     Frame* frame = outboardBody->getFrame();
     rigidBody->contributeInertia(frame->inertiaToParent(I));
     rigidBody->contributeForce(frame->forceToParent(F));
@@ -70,9 +72,10 @@
 
   // Joint slot ...
   // FIXME: pure virtual
-  virtual bool jointArticulation(SpatialInertia& artI, Vector6& artF) = 0;
-  virtual Vector6 computeRelVelDot(const SpatialInertia& artI,
-                                   const Vector6& artF) = 0;
+  virtual bool jointArticulation(SpatialInertia& artI, Vector6& artF,
+                                 const SpatialInertia& outI,
+                                 const Vector6& outF) = 0;
+  virtual void computeRelVelDot() = 0;
 
   //???
   bool updateAccels(RigidBody* rigidBody)
@@ -85,16 +88,12 @@
       return false;
 
     // Set the local acceleration
-    Vector6 accel = computeRelVelDot(outboardBody->getArtInertia(),
-                                     outboardBody->getArtForce());
+    computeRelVelDot();
     
     Frame* frame0 = outboardBody->getFrame();
     if (!frame0)
       return false;
     frame0->enableAccel();
-    FreeFrame* frame = dynamic_cast<FreeFrame*>(frame0);
-    if (frame)
-      frame->setRelVelDot(accel);
 
     outboardBody->computeAccel();
 

Modified: trunk/OpenFDM/src/OpenFDM/Makefile.am
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Makefile.am	2005-12-27 15:29:26 UTC (rev 131)
+++ trunk/OpenFDM/src/OpenFDM/Makefile.am	2005-12-27 20:17:05 UTC (rev 132)
@@ -166,6 +166,7 @@
   Integrator.cpp \
   Interact.cpp \
   ImplicitEuler.cpp \
+  Joint.cpp \
   LineActuator.cpp \
   LinearSpring.cpp \
   LineForce.cpp \

Modified: trunk/OpenFDM/src/OpenFDM/MultiBodySystem.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/MultiBodySystem.cpp	2005-12-27 15:29:26 UTC (rev 131)
+++ trunk/OpenFDM/src/OpenFDM/MultiBodySystem.cpp	2005-12-27 20:17:05 UTC (rev 132)
@@ -53,9 +53,9 @@
   }
 
   // Compute forward dynamics, that is the articulated forces and inertia.
-  mFreeJoint->getOutboardBody()->computeArtValues();
+  mFreeJoint->interactWith(mFreeJoint->getInboardBody());
   // Then compute the articulated inertias and forces.
-  mFreeJoint->updateAccels(0);
+  mFreeJoint->updateAccels(mFreeJoint->getInboardBody());
 
   // Hmm, just works now ... FIXME
   for (it = mModels.begin(); it != mModels.end(); ++it) {

Modified: trunk/OpenFDM/src/OpenFDM/PrismaticJoint.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/PrismaticJoint.cpp	2005-12-27 15:29:26 UTC (rev 131)
+++ trunk/OpenFDM/src/OpenFDM/PrismaticJoint.cpp	2005-12-27 20:17:05 UTC (rev 132)
@@ -69,30 +69,25 @@
 }
 
 bool
-PrismaticJoint::jointArticulation(SpatialInertia& artI, Vector6& artF)
+PrismaticJoint::jointArticulation(SpatialInertia& artI, Vector6& artF,
+                                 const SpatialInertia& outI,
+                                 const Vector6& outF)
 {
   // That projects away tha components where the degrees of freedom
   // of the joint are.
-  RigidBody* out = getOutboardBody();
-  LinAlg::Vector<real_type,1> tau;
+  CartesianJointFrame<1>::VectorN tau;
   tau(1) = getJointForce();
-  return mPrismaticJointFrame->jointArticulation(artI, artF,
-                                                 out->getArtForce(),
-                                                 out->getArtInertia(),
-                                                 tau,
-                                                 getJointAxis());
+  return mPrismaticJointFrame->jointArticulation(artI, artF, outF, outI, tau);
 }
 
-Vector6
-PrismaticJoint::computeRelVelDot(const SpatialInertia&,
-                                 const Vector6&)
+void
+PrismaticJoint::computeRelVelDot()
 {
   CartesianJointFrame<1>::VectorN acc;
-  mPrismaticJointFrame->computeRelVelDot(getJointAxis(), acc);
+  mPrismaticJointFrame->computeRelVelDot(acc);
   mPrismaticJointFrame->setJointVelDot(acc(1));
   Log(ArtBody, Debug) << "Relative acceleration for Joint \""
                       << getName() << "\" is " << trans(acc) << endl;
-  return getJointAxis()*acc;
 }
 
 void

Modified: trunk/OpenFDM/src/OpenFDM/PrismaticJoint.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/PrismaticJoint.h	2005-12-27 15:29:26 UTC (rev 131)
+++ trunk/OpenFDM/src/OpenFDM/PrismaticJoint.h	2005-12-27 20:17:05 UTC (rev 132)
@@ -48,11 +48,6 @@
     }
   }
 
-  /** Gets the joint axis where this joint is allowed to rotate around.
-   */
-  Vector6 getJointAxis(void) const
-  { return Vector6(Vector3::zeros(), mPrismaticJointFrame->getJointAxis()); }
-
   /** Sets the joint axis where this joint is allowed to rotate around.
    */
   void setJointAxis(const Vector3& axis);
@@ -103,13 +98,14 @@
   /** Computes the inboard articulated inertia and force for
       this articulated body. It is part of the articulated body algorithm.
    */
-  virtual bool jointArticulation(SpatialInertia& artI, Vector6& artF);
+  virtual bool jointArticulation(SpatialInertia& artI, Vector6& artF,
+                                 const SpatialInertia& outI,
+                                 const Vector6& outF);
 
   /** Computes the relative acceleration of this body with respect to its
       parent. It is part of the articulated body algorithm.
    */
-  virtual Vector6 computeRelVelDot(const SpatialInertia& artI,
-                                   const Vector6& artF);
+  virtual void computeRelVelDot();
 
   /** Methods for the OpenFDM::Part.
    */

Modified: trunk/OpenFDM/src/OpenFDM/PrismaticJointFrame.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/PrismaticJointFrame.h	2005-12-27 15:29:26 UTC (rev 131)
+++ trunk/OpenFDM/src/OpenFDM/PrismaticJointFrame.h	2005-12-27 20:17:05 UTC (rev 132)
@@ -43,6 +43,7 @@
     setPosition(mZeroPos + mJointPos*mJointAxis);
     setLinearRelVel(mJointVel*mJointAxis);
     setLinearRelVelDot(mJointVelDot*mJointAxis);
+    setJointMatrix(Vector6(Vector3::zeros(), axis));
   }
 
   /// Returns the joint position.

Modified: trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp	2005-12-27 15:29:26 UTC (rev 131)
+++ trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp	2005-12-27 20:17:05 UTC (rev 132)
@@ -68,31 +68,24 @@
 }
 
 bool
-RevoluteJoint::jointArticulation(SpatialInertia& artI, Vector6& artF)
+RevoluteJoint::jointArticulation(SpatialInertia& artI, Vector6& artF,
+                                 const SpatialInertia& outI,
+                                 const Vector6& outF)
 {
-  // That projects away tha components where the degrees of freedom
-  // of the joint are.
-  RigidBody* out = getOutboardBody();
-  LinAlg::Vector<real_type,1> tau;
+  CartesianJointFrame<1>::VectorN tau;
   tau(1) = getJointForce();
-  return mRevoluteJointFrame->jointArticulation(artI, artF,
-                                                out->getArtForce(),
-                                                out->getArtInertia(),
-                                                tau,
-                                                getJointAxis());
+  return mRevoluteJointFrame->jointArticulation(artI, artF, outF, outI, tau);
 }
 
-Vector6
-RevoluteJoint::computeRelVelDot(const SpatialInertia&,
-                                const Vector6&)
+void
+RevoluteJoint::computeRelVelDot()
 {
   CartesianJointFrame<1>::VectorN acc;
-  mRevoluteJointFrame->computeRelVelDot(getJointAxis(), acc);
+  mRevoluteJointFrame->computeRelVelDot(acc);
   mRevoluteJointFrame->setJointVelDot(acc(1));
   
   Log(ArtBody, Debug) << "Relative acceleration for Joint \""
                       << getName() << "\" is " << trans(acc) << endl;
-  return getJointAxis()*acc;
 }
 
 void

Modified: trunk/OpenFDM/src/OpenFDM/RevoluteJoint.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RevoluteJoint.h	2005-12-27 15:29:26 UTC (rev 131)
+++ trunk/OpenFDM/src/OpenFDM/RevoluteJoint.h	2005-12-27 20:17:05 UTC (rev 132)
@@ -48,11 +48,6 @@
     }
   }
 
-  /** Gets the joint axis where this joint is allowed to rotate around.
-   */
-  Vector6 getJointAxis(void) const
-  { return Vector6(mRevoluteJointFrame->getJointAxis(), Vector3::zeros()); }
-
   /** Sets the joint axis where this joint is allowed to rotate around.
    */
   void setJointAxis(const Vector3& axis);
@@ -103,13 +98,14 @@
   /** Computes the inboard articulated inertia and force for
       this articulated body. It is part of the articulated body algorithm.
    */
-  virtual bool jointArticulation(SpatialInertia& artI, Vector6& artF);
+  virtual bool jointArticulation(SpatialInertia& artI, Vector6& artF,
+                                 const SpatialInertia& outI,
+                                 const Vector6& outF);
 
   /** Computes the relative acceleration of this body with respect to its
       parent. It is part of the articulated body algorithm.
    */
-  virtual Vector6 computeRelVelDot(const SpatialInertia& artI,
-                                   const Vector6& artF);
+  virtual void computeRelVelDot();
 
   /** Methods for the OpenFDM::Part.
    */

Modified: trunk/OpenFDM/src/OpenFDM/RevoluteJointFrame.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RevoluteJointFrame.h	2005-12-27 15:29:26 UTC (rev 131)
+++ trunk/OpenFDM/src/OpenFDM/RevoluteJointFrame.h	2005-12-27 20:17:05 UTC (rev 132)
@@ -43,6 +43,8 @@
     setOrientation(mZeroOrient*Quaternion::fromAngleAxis(mJointPos, mJointAxis));
     setAngularRelVel(mJointVel*mJointAxis);
     setAngularRelVelDot(mJointVelDot*mJointAxis);
+
+    setJointMatrix(Vector6(axis, Vector3::zeros()));
   }
 
   /// Returns the joint position.



From frohlich at berlios.de  Wed Dec 28 10:41:16 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Wed, 28 Dec 2005 10:41:16 +0100
Subject: [OpenFDM-svn] r133 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200512280941.jBS9fG6c007286@sheep.berlios.de>

Author: frohlich
Date: 2005-12-28 10:41:07 +0100 (Wed, 28 Dec 2005)
New Revision: 133

Modified:
   trunk/OpenFDM/src/OpenFDM/CartesianJointFrame.h
   trunk/OpenFDM/src/OpenFDM/Frame.cpp
   trunk/OpenFDM/src/OpenFDM/Frame.h
   trunk/OpenFDM/src/OpenFDM/FreeJoint.cpp
   trunk/OpenFDM/src/OpenFDM/FreeJoint.h
   trunk/OpenFDM/src/OpenFDM/Joint.h
   trunk/OpenFDM/src/OpenFDM/PrismaticJoint.cpp
   trunk/OpenFDM/src/OpenFDM/PrismaticJoint.h
   trunk/OpenFDM/src/OpenFDM/PrismaticJointFrame.h
   trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp
   trunk/OpenFDM/src/OpenFDM/RevoluteJoint.h
   trunk/OpenFDM/src/OpenFDM/RevoluteJointFrame.h
   trunk/OpenFDM/src/OpenFDM/RigidBody.cpp
   trunk/OpenFDM/src/OpenFDM/RigidBody.h
Log:
Move joint acceleration computation logic into the joint frames


Modified: trunk/OpenFDM/src/OpenFDM/CartesianJointFrame.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/CartesianJointFrame.h	2005-12-27 20:17:05 UTC (rev 132)
+++ trunk/OpenFDM/src/OpenFDM/CartesianJointFrame.h	2005-12-28 09:41:07 UTC (rev 133)
@@ -23,69 +23,142 @@
   typedef LinAlg::MatrixFactors<real_type,n,n,LinAlg::LUTag> MatrixFactorsNN;
 
   CartesianJointFrame(const std::string& name) :
-    Frame(name)
+    Frame(name),
+//     mJointMatrix(Matrix6N::zeros()), /// ??? ... see LinAlg checkout ...
+    mOutboardInertia(SpatialInertia::zeros()),
+    mOutboardForce(Vector6::zeros()),
+    mPAlpha(Vector6::zeros()),
+    mJointForce(VectorN::zeros()),
+    mArticulationDirty(true),
+    mJointVelDotDirty(true),
+    mSpVelDotDirty(true),
+    mJointVelDot(VectorN::zeros()),
+    mRelVelDot(Vector6::zeros())
   { }
   virtual ~CartesianJointFrame(void)
   { }
 
-protected:
-  const Matrix6N& getJointMatrix(void) const
-  { return mJointMatrix; }
+  /// The interface routine for the Frame,
+  /// returns the relative velocity derivative of this frame
+  virtual const Vector6& getRelVelDot(void) const
+  {
+    if (mSpVelDotDirty) {
+      mRelVelDot = mJointMatrix*getJointVelDot();
+      mSpVelDotDirty = false;
+      // Note that we do not need to mark the accelerations dirty since
+      // we can only get here if something else the accelerations will depend
+      // on anyway is set dirty before
+      // setAccelDirty();
+    }
+    return mRelVelDot;
+  }
 
-  void setJointMatrix(const Matrix6N& jointAxis)
-  { mJointMatrix = jointAxis; }
+  /// Returns the derivative of the joint velocity
+  const VectorN& getJointVelDot() const
+  {
+    OpenFDMAssert(!mArticulationDirty);
+    if (mJointVelDotDirty) {
+      if (hIh.singular()) {
+        Log(ArtBody,Error) << "Detected singular mass matrix for "
+                           << "CartesianJointFrame \"" << getName()
+                           << "\": Fix your model!" << endl;
+        mJointVelDot.clear();
+      } else {
+        Vector6 tmp = mOutboardInertia*getParentSpAccel() + mPAlpha;
+        mJointVelDot = hIh.solve(mJointForce - trans(mJointMatrix)*tmp);
+      }
+      mJointVelDotDirty = false;
+    }
+    return mJointVelDot;
+  }
 
-public: /// FIXME
-  bool jointArticulation(SpatialInertia& artI,
-                         Vector6& artF,
-                         const Vector6& outF,
-                         const SpatialInertia& outI,
+  /// Compute the articulated force and inertia past inboard to that joint
+  bool jointArticulation(SpatialInertia& artI, Vector6& artF,
+                         const Vector6& outF, const SpatialInertia& outI,
                          const VectorN& jointForce)
   {
-    Log(ArtBody, Debug1) << artI << endl;
-
+    // Store the outboard values since we will need them later in velocity
+    // derivative computations
     mOutboardInertia = outI;
     mOutboardForce = outF;
-
-
-    mPAlpha = outF + mOutboardInertia*getHdot();
-
-
-
     mJointForce = jointForce;
+    // Make sure we have the correct internal state
+    mJointVelDotDirty = true;
+    mArticulationDirty = false;
 
+    // Compute the projection to the joint coodinate space
     Matrix6N Ih = outI*mJointMatrix;
     hIh = trans(mJointMatrix)*Ih;
 
-    if (hIh.singular())
+    mPAlpha = mOutboardForce + mOutboardInertia*getHdot();
+    artF = mPAlpha;
+    artI = outI;
+
+    if (hIh.singular()) {
+      Log(ArtBody,Error) << "Detected singular mass matrix for "
+                         << "CartesianJointFrame \"" << getName()
+                         << "\": Fix your model!" << endl;
       return false;
-
-    artF = mPAlpha;
+    }
     
+    // Project away the directions handled with this current joint
     artF -= Ih*hIh.solve(trans(mJointMatrix)*mPAlpha - jointForce);
-    artI = outI;
     artI -= SpatialInertia(Ih*hIh.solve(trans(Ih)));
 
     return true;
   }
-  
-  void computeRelVelDot(VectorN& jointAccel) const
+
+protected:
+  const Matrix6N& getJointMatrix(void) const
+  { return mJointMatrix; }
+
+  void setJointMatrix(const Matrix6N& jointAxis)
+  { mJointMatrix = jointAxis; setDirty(); }
+
+  void setPosition(const Vector3& pos)
+  { Frame::setPosition(pos); setDirty(); }
+  void setOrientation(const Quaternion& orientation)
+  { Frame::setOrientation(orientation); setDirty(); }
+  void setRelVel(const Vector6& vel)
+  { Frame::setRelVel(vel); setDirty(); }
+  void setLinearRelVel(const Vector3& vel)
+  { Frame::setLinearRelVel(vel); setDirty(); }
+  void setAngularRelVel(const Vector3& vel)
+  { Frame::setAngularRelVel(vel); setDirty(); }
+  void setDirty(void) const
   {
-    if (hIh.singular()) {
-      jointAccel.clear();
-    } else {
-      Vector6 tmp = mOutboardInertia*getParentSpAccel() + mPAlpha;
-      jointAccel = hIh.solve(mJointForce - trans(mJointMatrix)*tmp);
-    }
+    mArticulationDirty = true;
+    mJointVelDotDirty = true;
+    mSpVelDotDirty = true;
+    setAccelDirty();
   }
 
 private:
+  /// The cartesian joint map matrix, that is for the simple one dimensional
+  /// case just a spatial vector.
+  Matrix6N mJointMatrix;
+
+  /// The articulated intertia of the outboard frame, 
   SpatialInertia mOutboardInertia;
+  /// The articulated force of the outboard frame, 
   Vector6 mOutboardForce;
+  /// The joint internal force in joint generalized coordinates
+  VectorN mJointForce;
+  /// Some intermediate value we will need later
   Vector6 mPAlpha;
-  Matrix6N mJointMatrix;
-  VectorN mJointForce;
+  /// The decomposition of the inertia matrix projected to joint coordinates
   MatrixFactorsNN hIh;
+  /// This is true if the state has changed but the articulated intertia and
+  /// forces are not yet updated
+  mutable bool mArticulationDirty : 1;
+  /// This is true if the joint velocity derivatives are not yet computed
+  mutable bool mJointVelDotDirty : 1;
+  /// This is true if the spatial velocity derivative is not yet computed
+  mutable bool mSpVelDotDirty : 1;
+  /// The derivative of the joint velocity
+  mutable VectorN mJointVelDot;
+  /// The derivative of the frame velocity
+  mutable Vector6 mRelVelDot;
 };
 
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/Frame.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Frame.cpp	2005-12-27 20:17:05 UTC (rev 132)
+++ trunk/OpenFDM/src/OpenFDM/Frame.cpp	2005-12-28 09:41:07 UTC (rev 133)
@@ -20,13 +20,11 @@
   mDirtyPos(true),
   mDirtySpVel(true),
   mDirtySpAccel(true),
-  mDisableSpAccel(false),
   mReferenceFrameId(0)
 {
   setPosition(Vector3::zeros());
   setOrientation(Quaternion::unit());
   setRelVel(Vector6::zeros());
-  setRelVelDot(Vector6::zeros());
 
   addProperty("position", Property(this, &Frame::getPosition));
   addProperty("orienatation", Property(this, &Frame::getOrientation));
@@ -237,14 +235,14 @@
 }
 
 void
-Frame::setAccelDirtyUnconditional(void)
+Frame::setAccelDirtyUnconditional(void) const
 {
   // Mark ourself dirty.
   mDirtySpAccel = true;
   
   // Mark all child dirty.
-  ChildFrameList::iterator it = mChildFrames.begin();
-  ChildFrameList::iterator iEnd = mChildFrames.end();
+  ChildFrameList::const_iterator it = mChildFrames.begin();
+  ChildFrameList::const_iterator iEnd = mChildFrames.end();
   while (it != iEnd) {
     (*it)->setAccelDirty();
     ++it;
@@ -276,4 +274,6 @@
   }
 }
 
+const Vector6 Frame::mZeroVector = Vector6::zeros();
+
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/Frame.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Frame.h	2005-12-27 20:17:05 UTC (rev 132)
+++ trunk/OpenFDM/src/OpenFDM/Frame.h	2005-12-28 09:41:07 UTC (rev 133)
@@ -71,6 +71,8 @@
   const Frame* getParentFrame(void) const
   { return mParentFrame; }
   /// Return true if the given frame is the parent frame.
+  /// FIXME: it will read more intuitive if it is called
+  /// this->isParentFrameOf(that)
   bool isParentFrame(const Frame* frame) const
   { return frame == mParentFrame; }
   /// True if the current frame has a parent frame.
@@ -153,8 +155,8 @@
               to the parent frame. The velocity is in the current frames
               coordinates.
    */
-  const Vector6& getRelVelDot(void) const 
-  { return mRelVelDot; }
+  virtual const Vector6& getRelVelDot(void) const 
+  { return mZeroVector; }
 
 
   /** Linear velocity with respect to parent.
@@ -234,10 +236,7 @@
       of the moving and accelerating body (@see getClassicAccel).
    */
   Vector6 getSpAccel(void) const
-  {
-    OpenFDMAssert(!mDisableSpAccel);
-    return getRelVelDot() + getParentSpAccel() + getHdot();
-  }
+  { return getRelVelDot() + getParentSpAccel() + getHdot(); }
 
   /** Classical acceleration of the current frame.
       @return The sensed acceleration of the current frame with respect to an
@@ -246,7 +245,6 @@
    */
   Vector6 getClassicAccel(void) const
   {
-    OpenFDMAssert(!mDisableSpAccel);
     Vector6 iv = getSpVel();
     return getRelVelDot() + getParentSpAccel() + getHdot()
       + Vector6(Vector3::zeros(), cross(iv.getAngular(), iv.getLinear()));
@@ -470,19 +468,7 @@
   { setVelDirty(); mRelVel.setLinear(v); }
   void setAngularRelVel(const Vector3& rotVel)
   { setVelDirty(); mRelVel.setAngular(rotVel); }
-  void setRelVelDot(const Vector6& accel)
-  { setAccelDirty(); mRelVelDot = accel; }
-  void setLinearRelVelDot(const Vector3& accel)
-  { setAccelDirty(); mRelVelDot.setLinear(accel); }
-  void setAngularRelVelDot(const Vector3& accel)
-  { setAccelDirty(); mRelVelDot.setAngular(accel); }
 
-  void disableAccel(void)
-  { mDisableSpAccel = true; }
-  void enableAccel(void)
-  { mDisableSpAccel = false; }
-  friend class Joint; /// FIXME
-
   void computePositionDep(void) const;
   void computeVelocityDep(void) const;
   void computeAccelerationDep(void) const;
@@ -508,7 +494,7 @@
     // only really call a function if real work needs to be done.
     setVelDirtyUnconditional();
   }
-  void setAccelDirty(void)
+  void setAccelDirty(void) const
   {
     // Don't bother iterating over all children if we are already dirty.
     if (mDirtySpAccel == true)
@@ -521,7 +507,7 @@
 private:
   void setPosDirtyUnconditional(void);
   void setVelDirtyUnconditional(void);
-  void setAccelDirtyUnconditional(void);
+  void setAccelDirtyUnconditional(void) const;
 
 private:
   /// Set the parent frame to the given one.
@@ -538,10 +524,6 @@
   // True? more the relative velocity ...
   Vector6 mRelVel;
 
-  // The spatial acceleration of this frame wrt the parent frame.
-  // True? more the relative acceleration ...
-  Vector6 mRelVelDot;
-
   mutable Vector6 mParentSpVel;
   mutable Vector6 mParentSpAccel;
 
@@ -559,13 +541,15 @@
   mutable bool mDirtyPos:1;
   mutable bool mDirtySpVel:1;
   mutable bool mDirtySpAccel:1;
-  mutable bool mDisableSpAccel:1;
 
   // The parent frame.
   // FIXME: May be we should store a list of all parents ???
   WeakPtr<Frame> mParentFrame;
   // The list of child frames.
   ChildFrameList mChildFrames;
+
+  /// Used to return a zero acceleration, might move to the LinAlg namespace
+  static const Vector6 mZeroVector;
 };
 
 class FreeFrame
@@ -573,7 +557,9 @@
 public:
   FreeFrame(const std::string& name = std::string())
     : Frame(name)
-  {}
+  {
+    setRelVelDot(Vector6::zeros());
+  }
   virtual ~FreeFrame(void)
   {}
 
@@ -588,17 +574,25 @@
   { Frame::setLinearRelVel(vel); }
   void setAngularRelVel(const Vector3& vel)
   { Frame::setAngularRelVel(vel); }
+
+  virtual const Vector6& getRelVelDot(void) const 
+  { return mRelVelDot; }
   void setRelVelDot(const Vector6& accel)
-  { Frame::setRelVelDot(accel); }
-  void setLinearRelVelDot(const Vector3& accel)
-  { Frame::setLinearRelVelDot(accel); }
-  void setAngularRelVelDot(const Vector3& accel)
-  { Frame::setAngularRelVelDot(accel); }
+  { setAccelDirty(); mRelVelDot = accel; }
+//   void setLinearRelVelDot(const Vector3& accel)
+//   { setAccelDirty(); mRelVelDot.setLinear(accel); }
+//   void setAngularRelVelDot(const Vector3& accel)
+//   { setAccelDirty(); mRelVelDot.setAngular(accel); }
 
   void setRefPosition(const Vector3& p)
   { Frame::setRefPosition(p); }
   void setRefOrientation(const Quaternion& o)
   { Frame::setRefOrientation(o); }
+
+private:
+  // The spatial acceleration of this frame wrt the parent frame.
+  // True? more the relative acceleration ...
+  Vector6 mRelVelDot;
 };
 
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/FreeJoint.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/FreeJoint.cpp	2005-12-27 20:17:05 UTC (rev 132)
+++ trunk/OpenFDM/src/OpenFDM/FreeJoint.cpp	2005-12-28 09:41:07 UTC (rev 133)
@@ -81,7 +81,7 @@
   }
 }
 
-bool
+void
 FreeJoint::jointArticulation(SpatialInertia& artI, Vector6& artF,
                              const SpatialInertia& outI,
                              const Vector6& outF)
@@ -108,16 +108,9 @@
     - mFrame->getParentSpAccel() - mFrame->getHdot();
   
   mFrame->setRelVelDot(accel);
-
-  return true;
 }
 
 void
-FreeJoint::computeRelVelDot()
-{
-}
-
-void
 FreeJoint::setState(const Vector& state, unsigned offset)
 {
   mFrame->setOrientation(Vector4(state(offset+1), state(offset+2),

Modified: trunk/OpenFDM/src/OpenFDM/FreeJoint.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/FreeJoint.h	2005-12-27 20:17:05 UTC (rev 132)
+++ trunk/OpenFDM/src/OpenFDM/FreeJoint.h	2005-12-28 09:41:07 UTC (rev 133)
@@ -48,12 +48,9 @@
 private:
   /** Plugin function for the articulated body algorithm.
    */
-  virtual bool jointArticulation(SpatialInertia& artI, Vector6& artF,
+  virtual void jointArticulation(SpatialInertia& artI, Vector6& artF,
                                  const SpatialInertia& outI,
                                  const Vector6& outF);
-  /** Plugin function for the articulated body algorithm.
-   */
-  virtual void computeRelVelDot();
 
 
   /** Plugin function for the state propagation.

Modified: trunk/OpenFDM/src/OpenFDM/Joint.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Joint.h	2005-12-27 20:17:05 UTC (rev 132)
+++ trunk/OpenFDM/src/OpenFDM/Joint.h	2005-12-28 09:41:07 UTC (rev 133)
@@ -54,9 +54,8 @@
     // Apply the joint degrees of freedom to that.
     // If there was an error, (something was singular ???)
     // just ignore that part. FIXME, ist this ok????
-    if (!jointArticulation(I, F, outboardBody->getArtInertia(),
-                           outboardBody->getArtForce()))
-      return;
+    jointArticulation(I, F, outboardBody->getArtInertia(),
+                      outboardBody->getArtForce());
 
     Log(ArtBody, Debug3) << "Outboard Articulated values past joint "
                          << "projection: Force:\n" << trans(F)
@@ -71,34 +70,10 @@
   }
 
   // Joint slot ...
-  // FIXME: pure virtual
-  virtual bool jointArticulation(SpatialInertia& artI, Vector6& artF,
+  virtual void jointArticulation(SpatialInertia& artI, Vector6& artF,
                                  const SpatialInertia& outI,
                                  const Vector6& outF) = 0;
-  virtual void computeRelVelDot() = 0;
 
-  //???
-  bool updateAccels(RigidBody* rigidBody)
-  {
-    RigidBody* outboardBody = getOutboardBody();
-    if (!outboardBody)
-      return false;
-
-    if (outboardBody == rigidBody)
-      return false;
-
-    // Set the local acceleration
-    computeRelVelDot();
-    
-    Frame* frame0 = outboardBody->getFrame();
-    if (!frame0)
-      return false;
-    frame0->enableAccel();
-
-    outboardBody->computeAccel();
-
-    return true;
-  }
 };
 
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/PrismaticJoint.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/PrismaticJoint.cpp	2005-12-27 20:17:05 UTC (rev 132)
+++ trunk/OpenFDM/src/OpenFDM/PrismaticJoint.cpp	2005-12-28 09:41:07 UTC (rev 133)
@@ -12,6 +12,7 @@
 #include "Inertia.h"
 #include "Frame.h"
 #include "RigidBody.h"
+#include "PrismaticJointFrame.h"
 #include "PrismaticJoint.h"
 
 namespace OpenFDM {
@@ -33,6 +34,27 @@
 }
 
 void
+PrismaticJoint::recheckTopology(void)
+{
+  if (!getOutboardBody() || !getInboardBody())
+    return;
+  
+  // check for the inboard frame
+  Frame* inFrame = getInboardBody()->getFrame();
+  if (!inFrame)
+    return;
+  
+  Frame* outFrame = getOutboardBody()->getFrame();
+  if (!outFrame) {
+    getOutboardBody()->setFrame(mPrismaticJointFrame);
+  }
+  outFrame = getOutboardBody()->getFrame();
+  if (!outFrame->isParentFrame(inFrame)) {
+    inFrame->addChildFrame(mPrismaticJointFrame);
+  }
+}
+
+void
 PrismaticJoint::setJointAxis(const Vector3& axis)
 {
   real_type nrm = norm(axis);
@@ -44,6 +66,12 @@
   mPrismaticJointFrame->setJointAxis((1/nrm)*axis);
 }
 
+const real_type&
+PrismaticJoint::getJointPos(void) const
+{
+  return mPrismaticJointFrame->getJointPos();
+}
+
 void
 PrismaticJoint::setJointPos(real_type pos)
 {
@@ -56,6 +84,12 @@
   mPrismaticJointFrame->setJointVel(vel);
 }
 
+const real_type&
+PrismaticJoint::getJointVel(void) const
+{
+  return mPrismaticJointFrame->getJointVel();
+}
+
 void
 PrismaticJoint::setOrientation(const Quaternion& orientation)
 {
@@ -68,7 +102,7 @@
   mPrismaticJointFrame->setZeroPosition(position);
 }
 
-bool
+void
 PrismaticJoint::jointArticulation(SpatialInertia& artI, Vector6& artF,
                                  const SpatialInertia& outI,
                                  const Vector6& outF)
@@ -77,20 +111,10 @@
   // of the joint are.
   CartesianJointFrame<1>::VectorN tau;
   tau(1) = getJointForce();
-  return mPrismaticJointFrame->jointArticulation(artI, artF, outF, outI, tau);
+  mPrismaticJointFrame->jointArticulation(artI, artF, outF, outI, tau);
 }
 
 void
-PrismaticJoint::computeRelVelDot()
-{
-  CartesianJointFrame<1>::VectorN acc;
-  mPrismaticJointFrame->computeRelVelDot(acc);
-  mPrismaticJointFrame->setJointVelDot(acc(1));
-  Log(ArtBody, Debug) << "Relative acceleration for Joint \""
-                      << getName() << "\" is " << trans(acc) << endl;
-}
-
-void
 PrismaticJoint::setState(const Vector& state, unsigned offset)
 {
   mPrismaticJointFrame->setJointPos(state(offset+1));
@@ -108,7 +132,7 @@
 PrismaticJoint::getStateDeriv(Vector& state, unsigned offset)
 {
   state(offset+1) = mPrismaticJointFrame->getJointVel();
-  state(offset+2) = mPrismaticJointFrame->getJointVelDot();
+  state(offset+2) = mPrismaticJointFrame->getJointVelDot()(1);
 }
 
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/PrismaticJoint.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/PrismaticJoint.h	2005-12-27 20:17:05 UTC (rev 132)
+++ trunk/OpenFDM/src/OpenFDM/PrismaticJoint.h	2005-12-28 09:41:07 UTC (rev 133)
@@ -15,10 +15,11 @@
 #include "RigidBody.h"
 #include "Joint.h"
 #include "LineForce.h"
-#include "PrismaticJointFrame.h"
 
 namespace OpenFDM {
 
+class PrismaticJointFrame;
+
 class PrismaticJoint
   : public Joint {
 public:
@@ -28,34 +29,15 @@
   virtual bool init(void)
   { recheckTopology(); return Joint::init(); }
 
-  virtual void recheckTopology(void)
-  {
-    if (!getOutboardBody() || !getInboardBody())
-      return;
+  virtual void recheckTopology(void);
 
-    // check for the inboard frame
-    Frame* inFrame = getInboardBody()->getFrame();
-    if (!inFrame)
-      return;
-
-    Frame* outFrame = getOutboardBody()->getFrame();
-    if (!outFrame) {
-      getOutboardBody()->setFrame(mPrismaticJointFrame);
-    }
-    outFrame = getOutboardBody()->getFrame();
-    if (!outFrame->isParentFrame(inFrame)) {
-      inFrame->addChildFrame(mPrismaticJointFrame);
-    }
-  }
-
   /** Sets the joint axis where this joint is allowed to rotate around.
    */
   void setJointAxis(const Vector3& axis);
 
   /** Returns the joint position.
    */
-  const real_type& getJointPos(void) const
-  { return mPrismaticJointFrame->getJointPos(); }
+  const real_type& getJointPos(void) const;
 
   /** Sets the joint position.
    */
@@ -63,8 +45,7 @@
 
   /** Returns the joint velocity.
    */
-  const real_type& getJointVel(void) const
-  { return mPrismaticJointFrame->getJointVel(); }
+  const real_type& getJointVel(void) const;
 
   /** Sets the joint velocity.
    */
@@ -98,15 +79,10 @@
   /** Computes the inboard articulated inertia and force for
       this articulated body. It is part of the articulated body algorithm.
    */
-  virtual bool jointArticulation(SpatialInertia& artI, Vector6& artF,
+  virtual void jointArticulation(SpatialInertia& artI, Vector6& artF,
                                  const SpatialInertia& outI,
                                  const Vector6& outF);
 
-  /** Computes the relative acceleration of this body with respect to its
-      parent. It is part of the articulated body algorithm.
-   */
-  virtual void computeRelVelDot();
-
   /** Methods for the OpenFDM::Part.
    */
   virtual void setState(const Vector& state, unsigned offset);

Modified: trunk/OpenFDM/src/OpenFDM/PrismaticJointFrame.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/PrismaticJointFrame.h	2005-12-27 20:17:05 UTC (rev 132)
+++ trunk/OpenFDM/src/OpenFDM/PrismaticJointFrame.h	2005-12-28 09:41:07 UTC (rev 133)
@@ -27,8 +27,7 @@
     mZeroPos(Vector3::zeros()),
     mJointAxis(Vector3::unit(1)),
     mJointPos(0),
-    mJointVel(0),
-    mJointVelDot(0)
+    mJointVel(0)
   { }
   virtual ~PrismaticJointFrame(void) {}
 
@@ -42,7 +41,6 @@
     mJointAxis = axis;
     setPosition(mZeroPos + mJointPos*mJointAxis);
     setLinearRelVel(mJointVel*mJointAxis);
-    setLinearRelVelDot(mJointVelDot*mJointAxis);
     setJointMatrix(Vector6(Vector3::zeros(), axis));
   }
 
@@ -60,28 +58,20 @@
 
   /// Sets the joint velocity.
   void setJointVel(real_type vel)
-  { mJointVel = vel; setLinearRelVel(mJointVel*mJointAxis); }
+  { setLinearRelVel(mJointVel*mJointAxis); mJointVel = vel; }
 
-  /// Returns the derivative of the relative velocity
-  const real_type& getJointVelDot(void) const
-  { return mJointVelDot; }
-
-  /// Returns the derivative of the relative velocity
-  void setJointVelDot(real_type velDot)
-  { mJointVelDot = velDot; setLinearRelVelDot(mJointVelDot*mJointAxis); }
-
   /// Sets the zero position of the joint.
   void setZeroPosition(const Vector3& zeroPos)
-  { mZeroPos = zeroPos; setPosition(mZeroPos + mJointPos*mJointAxis); }
+  { setPosition(mZeroPos + mJointPos*mJointAxis); mZeroPos = zeroPos; }
   const Vector3& getZeroPosition(void) const
   { return mZeroPos; }
 
-  using Frame::setOrientation;
-  /// FIXME Hdot
+  using CartesianJointFrame<1>::setOrientation;
   
 private:
   /// The zero position with respect to the parent frame.
   Vector3 mZeroPos;
+
   /// The joint rotation axis.
   Vector3 mJointAxis;
 
@@ -90,9 +80,6 @@
 
   /// The realtive linear velocity along the joint axis
   real_type mJointVel;
-
-  /// The realtive linear velocity derivative along the joint axis
-  real_type mJointVelDot;
 };
 
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp	2005-12-27 20:17:05 UTC (rev 132)
+++ trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp	2005-12-28 09:41:07 UTC (rev 133)
@@ -12,6 +12,7 @@
 #include "Inertia.h"
 #include "Frame.h"
 #include "RigidBody.h"
+#include "RevoluteJointFrame.h"
 #include "RevoluteJoint.h"
 
 namespace OpenFDM {
@@ -33,6 +34,27 @@
 }
 
 void
+RevoluteJoint::recheckTopology(void)
+{
+  if (!getOutboardBody() || !getInboardBody())
+    return;
+  
+  // check for the inboard frame
+  Frame* inFrame = getInboardBody()->getFrame();
+  if (!inFrame)
+    return;
+  
+  Frame* outFrame = getOutboardBody()->getFrame();
+  if (!outFrame) {
+    getOutboardBody()->setFrame(mRevoluteJointFrame);
+  }
+  outFrame = getOutboardBody()->getFrame();
+  if (!outFrame->isParentFrame(inFrame)) {
+    inFrame->addChildFrame(mRevoluteJointFrame);
+  }
+}
+
+void
 RevoluteJoint::setJointAxis(const Vector3& axis)
 {
   real_type nrm = norm(axis);
@@ -43,12 +65,24 @@
   mRevoluteJointFrame->setJointAxis((1/nrm)*axis);
 }
 
+const real_type&
+RevoluteJoint::getJointPos(void) const
+{
+  return mRevoluteJointFrame->getJointPos();
+}
+
 void
 RevoluteJoint::setJointPos(real_type pos)
 {
   mRevoluteJointFrame->setJointPos(pos);
 }
 
+const real_type&
+RevoluteJoint::getJointVel(void) const
+{
+  return mRevoluteJointFrame->getJointVel();
+}
+
 void
 RevoluteJoint::setJointVel(real_type vel)
 {
@@ -67,28 +101,17 @@
   mRevoluteJointFrame->setZeroOrientation(orientation);
 }
 
-bool
+void
 RevoluteJoint::jointArticulation(SpatialInertia& artI, Vector6& artF,
                                  const SpatialInertia& outI,
                                  const Vector6& outF)
 {
   CartesianJointFrame<1>::VectorN tau;
   tau(1) = getJointForce();
-  return mRevoluteJointFrame->jointArticulation(artI, artF, outF, outI, tau);
+  mRevoluteJointFrame->jointArticulation(artI, artF, outF, outI, tau);
 }
 
 void
-RevoluteJoint::computeRelVelDot()
-{
-  CartesianJointFrame<1>::VectorN acc;
-  mRevoluteJointFrame->computeRelVelDot(acc);
-  mRevoluteJointFrame->setJointVelDot(acc(1));
-  
-  Log(ArtBody, Debug) << "Relative acceleration for Joint \""
-                      << getName() << "\" is " << trans(acc) << endl;
-}
-
-void
 RevoluteJoint::setState(const Vector& state, unsigned offset)
 {
   mRevoluteJointFrame->setJointPos(state(offset+1));
@@ -106,7 +129,7 @@
 RevoluteJoint::getStateDeriv(Vector& state, unsigned offset)
 {
   state(offset+1) = mRevoluteJointFrame->getJointVel();
-  state(offset+2) = mRevoluteJointFrame->getJointVelDot();
+  state(offset+2) = mRevoluteJointFrame->getJointVelDot()(1);
 }
 
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/RevoluteJoint.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RevoluteJoint.h	2005-12-27 20:17:05 UTC (rev 132)
+++ trunk/OpenFDM/src/OpenFDM/RevoluteJoint.h	2005-12-28 09:41:07 UTC (rev 133)
@@ -15,10 +15,11 @@
 #include "RigidBody.h"
 #include "Joint.h"
 #include "LineForce.h"
-#include "RevoluteJointFrame.h"
 
 namespace OpenFDM {
 
+class RevoluteJointFrame;
+
 class RevoluteJoint :
     public Joint {
 public:
@@ -28,34 +29,15 @@
   virtual bool init(void)
   { recheckTopology(); return Joint::init(); }
 
-  virtual void recheckTopology(void)
-  {
-    if (!getOutboardBody() || !getInboardBody())
-      return;
+  virtual void recheckTopology(void);
 
-    // check for the inboard frame
-    Frame* inFrame = getInboardBody()->getFrame();
-    if (!inFrame)
-      return;
-
-    Frame* outFrame = getOutboardBody()->getFrame();
-    if (!outFrame) {
-      getOutboardBody()->setFrame(mRevoluteJointFrame);
-    }
-    outFrame = getOutboardBody()->getFrame();
-    if (!outFrame->isParentFrame(inFrame)) {
-      inFrame->addChildFrame(mRevoluteJointFrame);
-    }
-  }
-
   /** Sets the joint axis where this joint is allowed to rotate around.
    */
   void setJointAxis(const Vector3& axis);
 
   /** Returns the joint position.
    */
-  const real_type& getJointPos(void) const
-  { return mRevoluteJointFrame->getJointPos(); }
+  const real_type& getJointPos(void) const;
 
   /** Sets the joint position.
    */
@@ -63,8 +45,7 @@
 
   /** Returns the joint velocity.
    */
-  const real_type& getJointVel(void) const
-  { return mRevoluteJointFrame->getJointVel(); }
+  const real_type& getJointVel(void) const;
 
   /** Sets the joint velocity.
    */
@@ -98,15 +79,10 @@
   /** Computes the inboard articulated inertia and force for
       this articulated body. It is part of the articulated body algorithm.
    */
-  virtual bool jointArticulation(SpatialInertia& artI, Vector6& artF,
+  virtual void jointArticulation(SpatialInertia& artI, Vector6& artF,
                                  const SpatialInertia& outI,
                                  const Vector6& outF);
 
-  /** Computes the relative acceleration of this body with respect to its
-      parent. It is part of the articulated body algorithm.
-   */
-  virtual void computeRelVelDot();
-
   /** Methods for the OpenFDM::Part.
    */
   virtual void setState(const Vector& state, unsigned offset);

Modified: trunk/OpenFDM/src/OpenFDM/RevoluteJointFrame.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RevoluteJointFrame.h	2005-12-27 20:17:05 UTC (rev 132)
+++ trunk/OpenFDM/src/OpenFDM/RevoluteJointFrame.h	2005-12-28 09:41:07 UTC (rev 133)
@@ -27,8 +27,7 @@
     mZeroOrient(Quaternion::unit()),
     mJointAxis(Vector3::unit(1)),
     mJointPos(0),
-    mJointVel(0),
-    mJointVelDot(0)
+    mJointVel(0)
   { }
   virtual ~RevoluteJointFrame(void) {}
 
@@ -42,7 +41,6 @@
     mJointAxis = axis;
     setOrientation(mZeroOrient*Quaternion::fromAngleAxis(mJointPos, mJointAxis));
     setAngularRelVel(mJointVel*mJointAxis);
-    setAngularRelVelDot(mJointVelDot*mJointAxis);
 
     setJointMatrix(Vector6(axis, Vector3::zeros()));
   }
@@ -64,32 +62,23 @@
 
   /// Sets the joint velocity.
   void setJointVel(real_type vel)
-  { mJointVel = vel; setAngularRelVel(mJointVel*mJointAxis); }
+  { setAngularRelVel(mJointVel*mJointAxis); mJointVel = vel; }
 
-  /// Returns the derivative of the relative velocity
-  const real_type& getJointVelDot(void) const
-  { return mJointVelDot; }
-
-  /// Returns the derivative of the relative velocity
-  void setJointVelDot(real_type velDot)
-  { mJointVelDot = velDot; setAngularRelVelDot(mJointVelDot*mJointAxis); }
-
   /// Sets the zero orientation of the joint.
   void setZeroOrientation(const Quaternion& zeroOrient)
   {
-    mZeroOrient = zeroOrient;
     setOrientation(zeroOrient*Quaternion::fromAngleAxis(mJointPos, mJointAxis));
+    mZeroOrient = zeroOrient;
   }
   const Quaternion& getZeroOrientation(void) const
   { return mZeroOrient; }
 
-  using Frame::setPosition;
+  using CartesianJointFrame<1>::setPosition;
 
-  /// FIXME Hdot
-
 private:
   /// The zero orientation with respect to the parent frame.
   Quaternion mZeroOrient;
+
   /// The joint rotation axis.
   Vector3 mJointAxis;
 
@@ -98,9 +87,6 @@
 
   /// The rotational velocity with respect to the rotation axis.
   real_type mJointVel;
-
-  /// The rotational velocity derivative with respect to the rotation axis.
-  real_type mJointVelDot;
 };
 
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/RigidBody.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RigidBody.cpp	2005-12-27 20:17:05 UTC (rev 132)
+++ trunk/OpenFDM/src/OpenFDM/RigidBody.cpp	2005-12-28 09:41:07 UTC (rev 133)
@@ -48,22 +48,6 @@
 }
 
 void
-RigidBody::computeAccel(void)
-{
-  Log(ArtBody, Debug) << "Entry of computeAccel of \"" << getName()
-                      << "\"" << endl;
-
-  // Update all accelerations, Hmm, is a bit too croase that way ...
-  InteractList::iterator it;
-  for (it = mInteracts.begin(); it != mInteracts.end(); ++it) {
-    (*it)->updateAccels(this);
-  }
-
-  Log(ArtBody, Debug3) << "On exit of computeAccel of \"" << getName()
-                       << "\"" << endl;
-}
-
-void
 RigidBody::setParentMultiBodySystem(MultiBodySystem* multiBodySystem)
 {
   /// FIXME: rethink that ...

Modified: trunk/OpenFDM/src/OpenFDM/RigidBody.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RigidBody.h	2005-12-27 20:17:05 UTC (rev 132)
+++ trunk/OpenFDM/src/OpenFDM/RigidBody.h	2005-12-28 09:41:07 UTC (rev 133)
@@ -42,8 +42,6 @@
    */
   void computeArtValues(void);
 
-  void computeAccel(void);
-
   /** Get the outboard articulated inertia.
       Returns a reference to the outboard articulated inertia.
       The returned inertia matrix is computed prevously by a call to



From frohlich at berlios.de  Wed Dec 28 11:28:48 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Wed, 28 Dec 2005 11:28:48 +0100
Subject: [OpenFDM-svn] r134 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200512281028.jBSASmDM011550@sheep.berlios.de>

Author: frohlich
Date: 2005-12-28 11:28:44 +0100 (Wed, 28 Dec 2005)
New Revision: 134

Modified:
   trunk/OpenFDM/src/OpenFDM/Force.h
   trunk/OpenFDM/src/OpenFDM/Interact.h
   trunk/OpenFDM/src/OpenFDM/MultiBodySystem.cpp
   trunk/OpenFDM/src/OpenFDM/Sensor.h
Log:
Little cleanup, move some workarounds one class higher ...


Modified: trunk/OpenFDM/src/OpenFDM/Force.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Force.h	2005-12-28 09:41:07 UTC (rev 133)
+++ trunk/OpenFDM/src/OpenFDM/Force.h	2005-12-28 10:28:44 UTC (rev 134)
@@ -50,6 +50,19 @@
     mForce = force;
   }
 
+  /// FIXME remove
+  const Frame* getParentFrame(unsigned id = 0) const
+  {
+    OpenFDMAssert(id < mParents.size() && mParents[id]);
+    return getParentRigidBody(id)->getFrame();
+  }
+  /// FIXME remove
+  Frame* getParentFrame(unsigned id = 0)
+  {
+    OpenFDMAssert(id < mParents.size() && mParents[id]);
+    return getParentRigidBody(id)->getFrame();
+  }
+
 private:
   Vector6 mForce;
 };

Modified: trunk/OpenFDM/src/OpenFDM/Interact.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Interact.h	2005-12-28 09:41:07 UTC (rev 133)
+++ trunk/OpenFDM/src/OpenFDM/Interact.h	2005-12-28 10:28:44 UTC (rev 134)
@@ -35,8 +35,17 @@
   /// This is the primary gate function which handles interaction
   virtual void interactWith(RigidBody* rigidBody) = 0;
 
+  const RigidBody* getParentRigidBody(unsigned id = 0) const
+  {
+    OpenFDMAssert(id < mParents.size());
+    return mParents[id];
+  }
+  RigidBody* getParentRigidBody(unsigned id = 0)
+  {
+    OpenFDMAssert(id < mParents.size());
+    return mParents[id];
+  }
 
-
 private:
   bool attachTo(RigidBody* rigidBody, bool upstream);
   bool detachFrom(RigidBody* rigidBody);
@@ -47,18 +56,6 @@
 
   friend class RigidBody;
 
-public:
-
-  const RigidBody* getParentRigidBody(unsigned id = 0) const
-  {
-    OpenFDMAssert(id < mParents.size());
-    return mParents[id];
-  }
-  RigidBody* getParentRigidBody(unsigned id = 0)
-  {
-    OpenFDMAssert(id < mParents.size());
-    return mParents[id];
-  }
   void swapParents(void)
   {
     OpenFDMAssert(2 == mParents.size());
@@ -67,23 +64,6 @@
     mParents[1] = rigidBody;
   }
 
-
-  /// FIXME: hmm
-  virtual bool updateAccels(RigidBody*) { return true; }
-
-  /// FIXME remove
-  const Frame* getParentFrame(unsigned id = 0) const
-  {
-    OpenFDMAssert(id < mParents.size() && mParents[id]);
-    return mParents[id]->getFrame();
-  }
-  /// FIXME remove
-  Frame* getParentFrame(unsigned id = 0)
-  {
-    OpenFDMAssert(id < mParents.size() && mParents[id]);
-    return mParents[id]->getFrame();
-  }
-
 private:
   typedef std::vector<WeakPtr<RigidBody> > ParentList;
   ParentList mParents;

Modified: trunk/OpenFDM/src/OpenFDM/MultiBodySystem.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/MultiBodySystem.cpp	2005-12-28 09:41:07 UTC (rev 133)
+++ trunk/OpenFDM/src/OpenFDM/MultiBodySystem.cpp	2005-12-28 10:28:44 UTC (rev 134)
@@ -54,8 +54,6 @@
 
   // Compute forward dynamics, that is the articulated forces and inertia.
   mFreeJoint->interactWith(mFreeJoint->getInboardBody());
-  // Then compute the articulated inertias and forces.
-  mFreeJoint->updateAccels(mFreeJoint->getInboardBody());
 
   // Hmm, just works now ... FIXME
   for (it = mModels.begin(); it != mModels.end(); ++it) {

Modified: trunk/OpenFDM/src/OpenFDM/Sensor.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Sensor.h	2005-12-28 09:41:07 UTC (rev 133)
+++ trunk/OpenFDM/src/OpenFDM/Sensor.h	2005-12-28 10:28:44 UTC (rev 134)
@@ -33,7 +33,12 @@
     if (!nonZeroIntersection(taskInfo.getSampleTimeSet(), getSampleTimeSet()))
         return;
 
-    Frame* frame = getParentFrame(0);
+    RigidBody* rigidBody = getParentRigidBody(0);
+    if (!rigidBody) {
+      mAccel = Vector6::zeros();
+      return;
+    }
+    Frame* frame = rigidBody->getFrame();
     if (!frame) {
       mAccel = Vector6::zeros();
       return;



From frohlich at berlios.de  Wed Dec 28 11:50:28 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Wed, 28 Dec 2005 11:50:28 +0100
Subject: [OpenFDM-svn] r135 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200512281050.jBSAoSop014170@sheep.berlios.de>

Author: frohlich
Date: 2005-12-28 11:50:23 +0100 (Wed, 28 Dec 2005)
New Revision: 135

Added:
   trunk/OpenFDM/src/OpenFDM/MobileRootJointFrame.h
Modified:
   trunk/OpenFDM/src/OpenFDM/FreeJoint.cpp
   trunk/OpenFDM/src/OpenFDM/FreeJoint.h
   trunk/OpenFDM/src/OpenFDM/Makefile.am
Log:
Move the Free joint acceleration logic into an own frame


Modified: trunk/OpenFDM/src/OpenFDM/FreeJoint.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/FreeJoint.cpp	2005-12-28 10:28:44 UTC (rev 134)
+++ trunk/OpenFDM/src/OpenFDM/FreeJoint.cpp	2005-12-28 10:50:23 UTC (rev 135)
@@ -13,13 +13,14 @@
 #include "Frame.h"
 #include "RigidBody.h"
 #include "RootFrame.h"
+#include "MobileRootJointFrame.h"
 #include "FreeJoint.h"
 
 namespace OpenFDM {
 
 FreeJoint::FreeJoint(const std::string& name)
   : Joint(name),
-    mFrame(new FreeFrame(name))
+    mFrame(new MobileRootJointFrame(name))
 {
   setNumContinousStates(13);
   addSampleTime(SampleTime::Continous);
@@ -82,6 +83,36 @@
 }
 
 void
+FreeJoint::setRelVel(const Vector6& vel)
+{
+  mFrame->setRelVel(vel);
+}
+
+void
+FreeJoint::setLinearRelVel(const Vector3& vel)
+{
+  mFrame->setLinearRelVel(vel);
+}
+
+void
+FreeJoint::setAngularRelVel(const Vector3& vel)
+{
+  mFrame->setAngularRelVel(vel);
+}
+
+void
+FreeJoint::setRefPosition(const Vector3& p)
+{
+  mFrame->setRefPosition(p);
+}
+
+void
+FreeJoint::setRefOrientation(const Quaternion& o)
+{
+  mFrame->setRefOrientation(o);
+}
+
+void
 FreeJoint::jointArticulation(SpatialInertia& artI, Vector6& artF,
                              const SpatialInertia& outI,
                              const Vector6& outF)
@@ -90,24 +121,7 @@
   artF.clear();
 
   Log(ArtBody, Debug) << "FreeJoint::computeRelVelDot():\n" << outI << endl;
-
-  // Assumption: body is small compared to the distance to the planets
-  // center of mass. That means gravity could be considered equal for the whole
-  // vehicle.
-  // See Featherstone, Orin: Equations and Algorithms
-  Vector3 ga = mGravity->gravityAccel(mFrame->getRefPosition());
-  Vector6 grav = Vector6(Vector3::zeros(), mFrame->rotFromRef(ga));
-
-  Log(ArtBody, Debug) << "grav = " << trans(grav) << endl
-                      << "solve = " << trans(solve(outI, outF)) << endl
-                      << "parent spatial accel = "
-                      << trans(mFrame->getParentSpAccel()) << endl
-                      << "Hdot = " << trans(mFrame->getHdot()) << endl;
-  
-  Vector6 accel = grav - solve(outI, outF)
-    - mFrame->getParentSpAccel() - mFrame->getHdot();
-  
-  mFrame->setRelVelDot(accel);
+  mFrame->jointArticulation(outF, outI, mGravity);
 }
 
 void

Modified: trunk/OpenFDM/src/OpenFDM/FreeJoint.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/FreeJoint.h	2005-12-28 10:28:44 UTC (rev 134)
+++ trunk/OpenFDM/src/OpenFDM/FreeJoint.h	2005-12-28 10:50:23 UTC (rev 135)
@@ -18,6 +18,8 @@
 
 namespace OpenFDM {
 
+class MobileRootJointFrame;
+
 class FreeJoint
   : public Joint {
 public:
@@ -29,21 +31,16 @@
   virtual void recheckTopology(void);
 
   /// Set the relative velocity.
-  void setRelVel(const Vector6& vel)
-  { mFrame->setRelVel(vel); }
+  void setRelVel(const Vector6& vel);
   /// Set the relative velocity.
-  void setLinearRelVel(const Vector3& vel)
-  { mFrame->setLinearRelVel(vel); }
+  void setLinearRelVel(const Vector3& vel);
   /// Set the relative velocity.
-  void setAngularRelVel(const Vector3& vel)
-  { mFrame->setAngularRelVel(vel); }
+  void setAngularRelVel(const Vector3& vel);
 
   /// Set the reference position.
-  void setRefPosition(const Vector3& p)
-  { mFrame->setRefPosition(p); }
+  void setRefPosition(const Vector3& p);
   /// Set the reference orientation.
-  void setRefOrientation(const Quaternion& o)
-  { mFrame->setRefOrientation(o); }
+  void setRefOrientation(const Quaternion& o);
 
 private:
   /** Plugin function for the articulated body algorithm.
@@ -68,7 +65,7 @@
   SharedPtr<const Gravity> mGravity;
 
   /// The frame of the mobile root
-  SharedPtr<FreeFrame> mFrame;
+  SharedPtr<MobileRootJointFrame> mFrame;
 };
 
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/Makefile.am
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Makefile.am	2005-12-28 10:28:44 UTC (rev 134)
+++ trunk/OpenFDM/src/OpenFDM/Makefile.am	2005-12-28 10:50:23 UTC (rev 135)
@@ -82,6 +82,7 @@
   MaxModel.h \
   MidpointRule.h \
   MinModel.h \
+  MobileRootJointFrame.h \
   Model.h \
   ModelGroup.h \
   ModelVisitor.h \

Added: trunk/OpenFDM/src/OpenFDM/MobileRootJointFrame.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/MobileRootJointFrame.h	2005-12-28 10:28:44 UTC (rev 134)
+++ trunk/OpenFDM/src/OpenFDM/MobileRootJointFrame.h	2005-12-28 10:50:23 UTC (rev 135)
@@ -0,0 +1,63 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_MobileRootJointFrame_H
+#define OpenFDM_MobileRootJointFrame_H
+
+#include "Assert.h"
+#include "Vector.h"
+#include "Matrix.h"
+#include "Inertia.h"
+#include "Frame.h"
+
+namespace OpenFDM {
+
+class MobileRootJointFrame :
+  public Frame {
+public:
+  MobileRootJointFrame(const std::string& name) :
+    Frame(name),
+    mRelVelDot(Vector6::zeros())
+  { }
+  virtual ~MobileRootJointFrame(void)
+  { }
+
+  /// The interface routine for the Frame,
+  /// returns the relative velocity derivative of this frame
+  virtual const Vector6& getRelVelDot(void) const
+  { return mRelVelDot; }
+
+  /// Compute the articulated force and inertia past inboard to that joint
+  void jointArticulation(const Vector6& outF, const SpatialInertia& outI,
+                         const Gravity* gravity)
+  {
+    Log(ArtBody, Debug) << "MobileRootJointFrame::jointArticulation()" << endl;
+
+    // Assumption: body is small compared to the distance to the planets
+    // center of mass. That means gravity could be considered equal for the
+    // whole vehicle.
+    // See Featherstone, Orin: Equations and Algorithms
+    Vector3 ga = gravity->gravityAccel(getRefPosition());
+    Vector6 grav = Vector6(Vector3::zeros(), rotFromRef(ga));
+
+    mRelVelDot = grav - solve(outI, outF) - getParentSpAccel() - getHdot();
+    setAccelDirty();
+  }
+
+  using Frame::setPosition;
+  using Frame::setRefPosition;
+  using Frame::setOrientation;
+  using Frame::setRefOrientation;
+  using Frame::setRelVel;
+  using Frame::setLinearRelVel;
+  using Frame::setAngularRelVel;
+
+private:
+  /// The derivative of the frame velocity
+  Vector6 mRelVelDot;
+};
+
+} // namespace OpenFDM
+
+#endif


Property changes on: trunk/OpenFDM/src/OpenFDM/MobileRootJointFrame.h
___________________________________________________________________
Name: svn:eol-style
   + native



From frohlich at berlios.de  Wed Dec 28 11:57:11 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Wed, 28 Dec 2005 11:57:11 +0100
Subject: [OpenFDM-svn] r136 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200512281057.jBSAvBkK015054@sheep.berlios.de>

Author: frohlich
Date: 2005-12-28 11:57:02 +0100 (Wed, 28 Dec 2005)
New Revision: 136

Added:
   trunk/OpenFDM/src/OpenFDM/MobileRootJoint.cpp
   trunk/OpenFDM/src/OpenFDM/MobileRootJoint.h
Removed:
   trunk/OpenFDM/src/OpenFDM/FreeJoint.cpp
   trunk/OpenFDM/src/OpenFDM/FreeJoint.h
Modified:
   trunk/OpenFDM/src/OpenFDM/Makefile.am
   trunk/OpenFDM/src/OpenFDM/MultiBodySystem.cpp
   trunk/OpenFDM/src/OpenFDM/MultiBodySystem.h
   trunk/OpenFDM/src/OpenFDM/Vehicle.cpp
   trunk/OpenFDM/src/OpenFDM/Vehicle.h
   trunk/OpenFDM/src/OpenFDM/main.cpp
Log:
Rename FreeJoint to MobileRootJoint


Deleted: trunk/OpenFDM/src/OpenFDM/FreeJoint.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/FreeJoint.cpp	2005-12-28 10:50:23 UTC (rev 135)
+++ trunk/OpenFDM/src/OpenFDM/FreeJoint.cpp	2005-12-28 10:57:02 UTC (rev 136)
@@ -1,190 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
- *
- */
-
-#include "Assert.h"
-#include "LogStream.h"
-#include "Object.h"
-#include "Vector.h"
-#include "Matrix.h"
-#include "Quaternion.h"
-#include "Inertia.h"
-#include "Gravity.h"
-#include "Frame.h"
-#include "RigidBody.h"
-#include "RootFrame.h"
-#include "MobileRootJointFrame.h"
-#include "FreeJoint.h"
-
-namespace OpenFDM {
-
-FreeJoint::FreeJoint(const std::string& name)
-  : Joint(name),
-    mFrame(new MobileRootJointFrame(name))
-{
-  setNumContinousStates(13);
-  addSampleTime(SampleTime::Continous);
-}
-
-FreeJoint::~FreeJoint(void)
-{
-}
-
-bool
-FreeJoint::init(void)
-{
-  Environment* environment = getEnvironment();
-  if (!environment) {
-    Log(Model,Error) << "Can not get environment pointer! Most propably the"
-      " Model is not put together correctly!" << endl;
-    return false;
-  }
-  mGravity = environment->getGravity();
-  if (!mGravity) {
-    Log(Model,Error) << "Can not get gravity model!" << endl;
-    return false;
-  }
-  Frame* rootFrame = environment->getRootFrame();
-  if (!rootFrame) {
-    Log(Model,Error) << "Can not get rootFrame model!" << endl;
-    return false;
-  }
-  recheckTopology();
-
-  return Joint::init();
-}
-
-void
-FreeJoint::recheckTopology(void)
-{
-  // Hmm, works for the first cut, but rethink what happens with strange
-  // attach reattach sequences ...
-  RigidBody* rigidBody = getOutboardBody();
-  if (!rigidBody)
-    return;
-  // check if already done
-  if (mFrame != rigidBody->getFrame())
-    rigidBody->setFrame(mFrame);
-
-  // Check if we are attached to some rigid body ...
-  rigidBody = getInboardBody();
-  if (rigidBody) {
-    Frame* frame = rigidBody->getFrame();
-    if (frame && !frame->isParentFrame(mFrame))
-      frame->addChildFrame(mFrame);
-  } else {
-    Environment* environment = getEnvironment();
-    if (environment) {
-      Frame* rootFrame = environment->getRootFrame();
-      if (rootFrame)
-        rootFrame->addChildFrame(mFrame);
-    }
-  }
-}
-
-void
-FreeJoint::setRelVel(const Vector6& vel)
-{
-  mFrame->setRelVel(vel);
-}
-
-void
-FreeJoint::setLinearRelVel(const Vector3& vel)
-{
-  mFrame->setLinearRelVel(vel);
-}
-
-void
-FreeJoint::setAngularRelVel(const Vector3& vel)
-{
-  mFrame->setAngularRelVel(vel);
-}
-
-void
-FreeJoint::setRefPosition(const Vector3& p)
-{
-  mFrame->setRefPosition(p);
-}
-
-void
-FreeJoint::setRefOrientation(const Quaternion& o)
-{
-  mFrame->setRefOrientation(o);
-}
-
-void
-FreeJoint::jointArticulation(SpatialInertia& artI, Vector6& artF,
-                             const SpatialInertia& outI,
-                             const Vector6& outF)
-{
-  artI.clear();
-  artF.clear();
-
-  Log(ArtBody, Debug) << "FreeJoint::computeRelVelDot():\n" << outI << endl;
-  mFrame->jointArticulation(outF, outI, mGravity);
-}
-
-void
-FreeJoint::setState(const Vector& state, unsigned offset)
-{
-  mFrame->setOrientation(Vector4(state(offset+1), state(offset+2),
-                                 state(offset+3), state(offset+4)));
-  mFrame->setPosition(Vector3(state(offset+5), state(offset+6), state(offset+7)));
-  mFrame->setRelVel(Vector6(state(offset+8), state(offset+9), state(offset+10),
-                            state(offset+11), state(offset+12), state(offset+13)));
-}
-
-void
-FreeJoint::getState(Vector& state, unsigned offset) const
-{
-  Quaternion q = mFrame->getOrientation();
-  state(offset+1) = q(1);
-  state(offset+2) = q(2);
-  state(offset+3) = q(3);
-  state(offset+4) = q(4);
-  
-  Vector3 p = mFrame->getPosition();
-  state(offset+5) = p(1);
-  state(offset+6) = p(2);
-  state(offset+7) = p(3);
-  
-  Vector6 v = mFrame->getRelVel();
-  state(offset+8) = v(1);
-  state(offset+9) = v(2);
-  state(offset+10) = v(3);
-  state(offset+11) = v(4);
-  state(offset+12) = v(5);
-  state(offset+13) = v(6);
-}
-
-void
-FreeJoint::getStateDeriv(Vector& state, unsigned offset)
-{
-  Quaternion q = mFrame->getOrientation();
-  Vector3 angVel = mFrame->getRelVel().getAngular();
-  Vector3 vel = mFrame->rotToParent(mFrame->getRelVel().getLinear());
-
-  // Compute the derivative term originating from the angular velocity.
-  // Correction term to keep the quaternion normalized.
-  // That is if |q| < 1 add a little radial component outward,
-  // if |q| > 1 add a little radial component inward
-  Vector4 qderiv = derivative(q, angVel) + 0.1*(normalize(q) - q);
-  state(offset+1) = qderiv(1);
-  state(offset+2) = qderiv(2);
-  state(offset+3) = qderiv(3);
-  state(offset+4) = qderiv(4);
-  
-  state(offset+5) = vel(1);
-  state(offset+6) = vel(2);
-  state(offset+7) = vel(3);
-  
-  Vector6 accel = mFrame->getRelVelDot();
-  state(offset+8)  = accel(1);
-  state(offset+9)  = accel(2);
-  state(offset+10) = accel(3);
-  state(offset+11) = accel(4);
-  state(offset+12) = accel(5);
-  state(offset+13) = accel(6);
-}
-
-} // namespace OpenFDM

Deleted: trunk/OpenFDM/src/OpenFDM/FreeJoint.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/FreeJoint.h	2005-12-28 10:50:23 UTC (rev 135)
+++ trunk/OpenFDM/src/OpenFDM/FreeJoint.h	2005-12-28 10:57:02 UTC (rev 136)
@@ -1,73 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
- *
- */
-
-#ifndef OpenFDM_FreeJoint_H
-#define OpenFDM_FreeJoint_H
-
-#include "Assert.h"
-#include "Object.h"
-#include "Vector.h"
-#include "Matrix.h"
-#include "Quaternion.h"
-#include "Inertia.h"
-#include "Frame.h"
-#include "RigidBody.h"
-#include "Joint.h"
-#include "Environment.h"
-
-namespace OpenFDM {
-
-class MobileRootJointFrame;
-
-class FreeJoint
-  : public Joint {
-public:
-  FreeJoint(const std::string& name);
-  virtual ~FreeJoint(void);
-
-  virtual bool init(void);
-
-  virtual void recheckTopology(void);
-
-  /// Set the relative velocity.
-  void setRelVel(const Vector6& vel);
-  /// Set the relative velocity.
-  void setLinearRelVel(const Vector3& vel);
-  /// Set the relative velocity.
-  void setAngularRelVel(const Vector3& vel);
-
-  /// Set the reference position.
-  void setRefPosition(const Vector3& p);
-  /// Set the reference orientation.
-  void setRefOrientation(const Quaternion& o);
-
-private:
-  /** Plugin function for the articulated body algorithm.
-   */
-  virtual void jointArticulation(SpatialInertia& artI, Vector6& artF,
-                                 const SpatialInertia& outI,
-                                 const Vector6& outF);
-
-
-  /** Plugin function for the state propagation.
-   */
-  virtual void setState(const Vector& state, unsigned offset);
-  /** Plugin function for the state propagation.
-   */
-  virtual void getState(Vector& state, unsigned offset) const;
-  /** Plugin function for the state propagation.
-   */
-  virtual void getStateDeriv(Vector& state, unsigned offset);
-
-  /// The commonly used gravity model from the environment class
-  /// It is initialized at the init() call
-  SharedPtr<const Gravity> mGravity;
-
-  /// The frame of the mobile root
-  SharedPtr<MobileRootJointFrame> mFrame;
-};
-
-} // namespace OpenFDM
-
-#endif

Modified: trunk/OpenFDM/src/OpenFDM/Makefile.am
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Makefile.am	2005-12-28 10:50:23 UTC (rev 135)
+++ trunk/OpenFDM/src/OpenFDM/Makefile.am	2005-12-28 10:57:02 UTC (rev 136)
@@ -52,7 +52,7 @@
   Expression.h \
   Force.h \
   Frame.h \
-  FreeJoint.h \
+  MobileRootJoint.h \
   Function.h \
   Gain.h \
   Gravity.h \
@@ -158,7 +158,7 @@
   Expression.cpp \
   Force.cpp \
   Frame.cpp \
-  FreeJoint.cpp \
+  MobileRootJoint.cpp \
   Function.cpp \
   Gain.cpp \
   Gravity.cpp \

Copied: trunk/OpenFDM/src/OpenFDM/MobileRootJoint.cpp (from rev 135, trunk/OpenFDM/src/OpenFDM/FreeJoint.cpp)
===================================================================
--- trunk/OpenFDM/src/OpenFDM/FreeJoint.cpp	2005-12-28 10:50:23 UTC (rev 135)
+++ trunk/OpenFDM/src/OpenFDM/MobileRootJoint.cpp	2005-12-28 10:57:02 UTC (rev 136)
@@ -0,0 +1,190 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
+ *
+ */
+
+#include "Assert.h"
+#include "LogStream.h"
+#include "Object.h"
+#include "Vector.h"
+#include "Matrix.h"
+#include "Quaternion.h"
+#include "Inertia.h"
+#include "Gravity.h"
+#include "Frame.h"
+#include "RigidBody.h"
+#include "RootFrame.h"
+#include "MobileRootJointFrame.h"
+#include "MobileRootJoint.h"
+
+namespace OpenFDM {
+
+MobileRootJoint::MobileRootJoint(const std::string& name)
+  : Joint(name),
+    mFrame(new MobileRootJointFrame(name))
+{
+  setNumContinousStates(13);
+  addSampleTime(SampleTime::Continous);
+}
+
+MobileRootJoint::~MobileRootJoint(void)
+{
+}
+
+bool
+MobileRootJoint::init(void)
+{
+  Environment* environment = getEnvironment();
+  if (!environment) {
+    Log(Model,Error) << "Can not get environment pointer! Most propably the"
+      " Model is not put together correctly!" << endl;
+    return false;
+  }
+  mGravity = environment->getGravity();
+  if (!mGravity) {
+    Log(Model,Error) << "Can not get gravity model!" << endl;
+    return false;
+  }
+  Frame* rootFrame = environment->getRootFrame();
+  if (!rootFrame) {
+    Log(Model,Error) << "Can not get rootFrame model!" << endl;
+    return false;
+  }
+  recheckTopology();
+
+  return Joint::init();
+}
+
+void
+MobileRootJoint::recheckTopology(void)
+{
+  // Hmm, works for the first cut, but rethink what happens with strange
+  // attach reattach sequences ...
+  RigidBody* rigidBody = getOutboardBody();
+  if (!rigidBody)
+    return;
+  // check if already done
+  if (mFrame != rigidBody->getFrame())
+    rigidBody->setFrame(mFrame);
+
+  // Check if we are attached to some rigid body ...
+  rigidBody = getInboardBody();
+  if (rigidBody) {
+    Frame* frame = rigidBody->getFrame();
+    if (frame && !frame->isParentFrame(mFrame))
+      frame->addChildFrame(mFrame);
+  } else {
+    Environment* environment = getEnvironment();
+    if (environment) {
+      Frame* rootFrame = environment->getRootFrame();
+      if (rootFrame)
+        rootFrame->addChildFrame(mFrame);
+    }
+  }
+}
+
+void
+MobileRootJoint::setRelVel(const Vector6& vel)
+{
+  mFrame->setRelVel(vel);
+}
+
+void
+MobileRootJoint::setLinearRelVel(const Vector3& vel)
+{
+  mFrame->setLinearRelVel(vel);
+}
+
+void
+MobileRootJoint::setAngularRelVel(const Vector3& vel)
+{
+  mFrame->setAngularRelVel(vel);
+}
+
+void
+MobileRootJoint::setRefPosition(const Vector3& p)
+{
+  mFrame->setRefPosition(p);
+}
+
+void
+MobileRootJoint::setRefOrientation(const Quaternion& o)
+{
+  mFrame->setRefOrientation(o);
+}
+
+void
+MobileRootJoint::jointArticulation(SpatialInertia& artI, Vector6& artF,
+                             const SpatialInertia& outI,
+                             const Vector6& outF)
+{
+  artI.clear();
+  artF.clear();
+
+  Log(ArtBody, Debug) << "MobileRootJoint::computeRelVelDot():\n" << outI << endl;
+  mFrame->jointArticulation(outF, outI, mGravity);
+}
+
+void
+MobileRootJoint::setState(const Vector& state, unsigned offset)
+{
+  mFrame->setOrientation(Vector4(state(offset+1), state(offset+2),
+                                 state(offset+3), state(offset+4)));
+  mFrame->setPosition(Vector3(state(offset+5), state(offset+6), state(offset+7)));
+  mFrame->setRelVel(Vector6(state(offset+8), state(offset+9), state(offset+10),
+                            state(offset+11), state(offset+12), state(offset+13)));
+}
+
+void
+MobileRootJoint::getState(Vector& state, unsigned offset) const
+{
+  Quaternion q = mFrame->getOrientation();
+  state(offset+1) = q(1);
+  state(offset+2) = q(2);
+  state(offset+3) = q(3);
+  state(offset+4) = q(4);
+  
+  Vector3 p = mFrame->getPosition();
+  state(offset+5) = p(1);
+  state(offset+6) = p(2);
+  state(offset+7) = p(3);
+  
+  Vector6 v = mFrame->getRelVel();
+  state(offset+8) = v(1);
+  state(offset+9) = v(2);
+  state(offset+10) = v(3);
+  state(offset+11) = v(4);
+  state(offset+12) = v(5);
+  state(offset+13) = v(6);
+}
+
+void
+MobileRootJoint::getStateDeriv(Vector& state, unsigned offset)
+{
+  Quaternion q = mFrame->getOrientation();
+  Vector3 angVel = mFrame->getRelVel().getAngular();
+  Vector3 vel = mFrame->rotToParent(mFrame->getRelVel().getLinear());
+
+  // Compute the derivative term originating from the angular velocity.
+  // Correction term to keep the quaternion normalized.
+  // That is if |q| < 1 add a little radial component outward,
+  // if |q| > 1 add a little radial component inward
+  Vector4 qderiv = derivative(q, angVel) + 0.1*(normalize(q) - q);
+  state(offset+1) = qderiv(1);
+  state(offset+2) = qderiv(2);
+  state(offset+3) = qderiv(3);
+  state(offset+4) = qderiv(4);
+  
+  state(offset+5) = vel(1);
+  state(offset+6) = vel(2);
+  state(offset+7) = vel(3);
+  
+  Vector6 accel = mFrame->getRelVelDot();
+  state(offset+8)  = accel(1);
+  state(offset+9)  = accel(2);
+  state(offset+10) = accel(3);
+  state(offset+11) = accel(4);
+  state(offset+12) = accel(5);
+  state(offset+13) = accel(6);
+}
+
+} // namespace OpenFDM

Copied: trunk/OpenFDM/src/OpenFDM/MobileRootJoint.h (from rev 135, trunk/OpenFDM/src/OpenFDM/FreeJoint.h)
===================================================================
--- trunk/OpenFDM/src/OpenFDM/FreeJoint.h	2005-12-28 10:50:23 UTC (rev 135)
+++ trunk/OpenFDM/src/OpenFDM/MobileRootJoint.h	2005-12-28 10:57:02 UTC (rev 136)
@@ -0,0 +1,73 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_MobileRootJoint_H
+#define OpenFDM_MobileRootJoint_H
+
+#include "Assert.h"
+#include "Object.h"
+#include "Vector.h"
+#include "Matrix.h"
+#include "Quaternion.h"
+#include "Inertia.h"
+#include "Frame.h"
+#include "RigidBody.h"
+#include "Joint.h"
+#include "Environment.h"
+
+namespace OpenFDM {
+
+class MobileRootJointFrame;
+
+class MobileRootJoint
+  : public Joint {
+public:
+  MobileRootJoint(const std::string& name);
+  virtual ~MobileRootJoint(void);
+
+  virtual bool init(void);
+
+  virtual void recheckTopology(void);
+
+  /// Set the relative velocity.
+  void setRelVel(const Vector6& vel);
+  /// Set the relative velocity.
+  void setLinearRelVel(const Vector3& vel);
+  /// Set the relative velocity.
+  void setAngularRelVel(const Vector3& vel);
+
+  /// Set the reference position.
+  void setRefPosition(const Vector3& p);
+  /// Set the reference orientation.
+  void setRefOrientation(const Quaternion& o);
+
+private:
+  /** Plugin function for the articulated body algorithm.
+   */
+  virtual void jointArticulation(SpatialInertia& artI, Vector6& artF,
+                                 const SpatialInertia& outI,
+                                 const Vector6& outF);
+
+
+  /** Plugin function for the state propagation.
+   */
+  virtual void setState(const Vector& state, unsigned offset);
+  /** Plugin function for the state propagation.
+   */
+  virtual void getState(Vector& state, unsigned offset) const;
+  /** Plugin function for the state propagation.
+   */
+  virtual void getStateDeriv(Vector& state, unsigned offset);
+
+  /// The commonly used gravity model from the environment class
+  /// It is initialized at the init() call
+  SharedPtr<const Gravity> mGravity;
+
+  /// The frame of the mobile root
+  SharedPtr<MobileRootJointFrame> mFrame;
+};
+
+} // namespace OpenFDM
+
+#endif

Modified: trunk/OpenFDM/src/OpenFDM/MultiBodySystem.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/MultiBodySystem.cpp	2005-12-28 10:50:23 UTC (rev 135)
+++ trunk/OpenFDM/src/OpenFDM/MultiBodySystem.cpp	2005-12-28 10:57:02 UTC (rev 136)
@@ -53,7 +53,7 @@
   }
 
   // Compute forward dynamics, that is the articulated forces and inertia.
-  mFreeJoint->interactWith(mFreeJoint->getInboardBody());
+  mMobileRootJoint->interactWith(mMobileRootJoint->getInboardBody());
 
   // Hmm, just works now ... FIXME
   for (it = mModels.begin(); it != mModels.end(); ++it) {
@@ -100,8 +100,8 @@
   if (this == interact->getParent())
     return;
   // FIXME incorporate that somehow into the depencencies ...
-  if (dynamic_cast<FreeJoint*>(interact)) {
-    mFreeJoint = dynamic_cast<FreeJoint*>(interact);
+  if (dynamic_cast<MobileRootJoint*>(interact)) {
+    mMobileRootJoint = dynamic_cast<MobileRootJoint*>(interact);
   }
   addModel(interact);
 }

Modified: trunk/OpenFDM/src/OpenFDM/MultiBodySystem.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/MultiBodySystem.h	2005-12-28 10:50:23 UTC (rev 135)
+++ trunk/OpenFDM/src/OpenFDM/MultiBodySystem.h	2005-12-28 10:57:02 UTC (rev 136)
@@ -14,7 +14,7 @@
 #include "Frame.h"
 #include "RigidBody.h"
 #include "Joint.h"
-#include "FreeJoint.h"
+#include "MobileRootJoint.h"
 #include "RootFrame.h"
 #include "ModelGroup.h"
 
@@ -43,7 +43,7 @@
   void removeInteract(Interact* interact);
 private:
   /// That is the root for now ...
-  SharedPtr<FreeJoint> mFreeJoint;
+  SharedPtr<MobileRootJoint> mMobileRootJoint;
 
   /// A list of RigidBody objects in this MultiBodySystem
   typedef std::vector<SharedPtr<RigidBody> > RigidBodyList;

Modified: trunk/OpenFDM/src/OpenFDM/Vehicle.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Vehicle.cpp	2005-12-28 10:50:23 UTC (rev 135)
+++ trunk/OpenFDM/src/OpenFDM/Vehicle.cpp	2005-12-28 10:57:02 UTC (rev 136)
@@ -8,7 +8,7 @@
 #include "Quaternion.h"
 #include "Force.h"
 #include "RigidBody.h"
-#include "FreeJoint.h"
+#include "MobileRootJoint.h"
 #include "Planet.h"
 #include "Wind.h"
 #include "ExplicitEuler.h"
@@ -27,8 +27,8 @@
 {
   mTopBody = new RigidBody("Topmost rigid body");
 
-  mFreeJoint = new FreeJoint("Mobile vehicle base");
-  mTopBody->setInboardJoint(mFreeJoint);
+  mMobileRootJoint = new MobileRootJoint("Mobile vehicle base");
+  mTopBody->setInboardJoint(mMobileRootJoint);
 
   mSystem = new System("Top Vehicle System");
 
@@ -109,7 +109,7 @@
 void
 Vehicle::setCartPosition(const Vector3& pos)
 {
-  mFreeJoint->setRefPosition(pos);/*FIXME*/
+  mMobileRootJoint->setRefPosition(pos);/*FIXME*/
 }
 
 Geodetic
@@ -145,7 +145,7 @@
 void
 Vehicle::setCartOrientation(const Quaternion& o)
 {
-  mFreeJoint->setRefOrientation(o);/*FIXME*/
+  mMobileRootJoint->setRefOrientation(o);/*FIXME*/
 }
 
 Quaternion

Modified: trunk/OpenFDM/src/OpenFDM/Vehicle.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Vehicle.h	2005-12-28 10:50:23 UTC (rev 135)
+++ trunk/OpenFDM/src/OpenFDM/Vehicle.h	2005-12-28 10:57:02 UTC (rev 136)
@@ -11,7 +11,7 @@
 #include "Quaternion.h"
 #include "Force.h"
 #include "Frame.h"
-#include "FreeJoint.h"
+#include "MobileRootJoint.h"
 #include "RootFrame.h"
 #include "MultiBodySystem.h"
 #include "Planet.h"
@@ -77,10 +77,10 @@
 
   /** Get the vehicle base node.
    */
-  const FreeJoint* getFreeJoint(void) const
-  { return mFreeJoint; }
-  FreeJoint* getFreeJoint(void)
-  { return mFreeJoint; }
+  const MobileRootJoint* getMobileRootJoint(void) const
+  { return mMobileRootJoint; }
+  MobileRootJoint* getMobileRootJoint(void)
+  { return mMobileRootJoint; }
 
   const ModelGroup* getModelGroup(void) const
   { return mModelGroup; }
@@ -124,7 +124,7 @@
 
 private:
   SharedPtr<RigidBody> mTopBody;
-  SharedPtr<FreeJoint> mFreeJoint;
+  SharedPtr<MobileRootJoint> mMobileRootJoint;
   SharedPtr<MultiBodySystem> mMultiBodySystem;
 
   SharedPtr<ModelGroup> mModelGroup;

Modified: trunk/OpenFDM/src/OpenFDM/main.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/main.cpp	2005-12-28 10:50:23 UTC (rev 135)
+++ trunk/OpenFDM/src/OpenFDM/main.cpp	2005-12-28 10:57:02 UTC (rev 136)
@@ -22,7 +22,7 @@
 #include <OpenFDM/Planet.h>
 #include <OpenFDM/DefaultPlanet.h>
 #include <OpenFDM/RigidBody.h>
-#include <OpenFDM/FreeJoint.h>
+#include <OpenFDM/MobileRootJoint.h>
 #include <OpenFDM/AeroForce.h>
 #include <OpenFDM/SimpleContact.h>
 #include <OpenFDM/SimpleGear.h>
@@ -623,9 +623,9 @@
   Quaternion q = Quaternion::fromAngleAxis(heading, Vector3::unit(3));
   vehicle->setGeodOrientation(q);
 
-  vehicle->getFreeJoint()->setRelVel(Vector6::zeros());
+  vehicle->getMobileRootJoint()->setRelVel(Vector6::zeros());
   Vector3 vel(convertFrom(uFeetPSecond, 23900.0), 0, 0);
-  vehicle->getFreeJoint()->setLinearRelVel(vel);
+  vehicle->getMobileRootJoint()->setLinearRelVel(vel);
   vehicle->getTopBody()->addMultiBodyModel(new Mass("Testmass", SpatialInertia(InertiaMatrix(100,0,0,100,0,100), 100), "Mass"));
 
 



From frohlich at berlios.de  Thu Dec 29 00:28:42 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Thu, 29 Dec 2005 00:28:42 +0100
Subject: [OpenFDM-svn] r137 - in trunk/OpenFDM/src: JSBSim OpenFDM
Message-ID: <200512282328.jBSNSgTK022338@sheep.berlios.de>

Author: frohlich
Date: 2005-12-29 00:28:32 +0100 (Thu, 29 Dec 2005)
New Revision: 137

Added:
   trunk/OpenFDM/src/OpenFDM/CartesianActuatorFrame.h
   trunk/OpenFDM/src/OpenFDM/RevoluteActuator.cpp
   trunk/OpenFDM/src/OpenFDM/RevoluteActuator.h
   trunk/OpenFDM/src/OpenFDM/RevoluteActuatorFrame.h
Removed:
   trunk/OpenFDM/src/OpenFDM/LineActuator.cpp
   trunk/OpenFDM/src/OpenFDM/LineActuator.h
Modified:
   trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
   trunk/OpenFDM/src/OpenFDM/CartesianJointFrame.h
   trunk/OpenFDM/src/OpenFDM/Makefile.am
Log:
Change the actuator model


Modified: trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
===================================================================
--- trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2005-12-28 10:57:02 UTC (rev 136)
+++ trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2005-12-28 23:28:32 UTC (rev 137)
@@ -27,6 +27,7 @@
 #include <OpenFDM/AirSpring.h>
 #include <OpenFDM/PrismaticJoint.h>
 #include <OpenFDM/Product.h>
+#include <OpenFDM/RevoluteActuator.h>
 #include <OpenFDM/RevoluteJoint.h>
 #include <OpenFDM/Saturation.h>
 #include <OpenFDM/Sensor.h>
@@ -38,7 +39,6 @@
 #include <OpenFDM/Units.h>
 #include <OpenFDM/Vehicle.h>
 #include <OpenFDM/WheelContact.h>
-#include <OpenFDM/LineActuator.h>
 #include <OpenFDM/DiscBrake.h>
 
 #include <OpenFDM/ReaderWriter.h>
@@ -1003,7 +1003,7 @@
         // connect that via a revolute joint to the toplevel body.
         // Note the 0.05m below, most steering wheels have some kind of
         // castering auto line up behavour. That is doe with this 0.05m.
-        RevoluteJoint* sj = new RevoluteJoint(name + " Steer Joint");
+        RevoluteActuator* sj = new RevoluteActuator(name + " Steer Joint");
         strutParent->addInteract(sj);
         steer->setInboardJoint(sj);
         sj->setJointAxis(Vector3(0, 0, 1));
@@ -1013,13 +1013,8 @@
                         + Vector3(0.05, 0, 0));
         sj->setOrientation(Quaternion::unit());
 
-        // Add an actuator trying to interpret the steering command
-        LineActuator* steerAct = new LineActuator(name + " Steering Actuator");
         Port* port = lookupJSBExpression("fcs/steer-cmd-norm");
-        steerAct->getInputPort(0)->connect(port);
-        steerAct->setProportionalGain(-1e6);
-        steerAct->setDerivativeGain(-1e3);
-        sj->setLineForce(steerAct);
+        sj->getInputPort(0)->connect(port);
         
         strutParent = steer;
         

Added: trunk/OpenFDM/src/OpenFDM/CartesianActuatorFrame.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/CartesianActuatorFrame.h	2005-12-28 10:57:02 UTC (rev 136)
+++ trunk/OpenFDM/src/OpenFDM/CartesianActuatorFrame.h	2005-12-28 23:28:32 UTC (rev 137)
@@ -0,0 +1,168 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_CartesianActuatorFrame_H
+#define OpenFDM_CartesianActuatorFrame_H
+
+#include "Assert.h"
+#include "Vector.h"
+#include "Matrix.h"
+#include "Inertia.h"
+#include "Frame.h"
+
+namespace OpenFDM {
+
+template<unsigned n>
+class CartesianActuatorFrame :
+  public Frame {
+public:
+  typedef LinAlg::Vector<real_type,n> VectorN;
+  typedef LinAlg::Matrix<real_type,6,n> Matrix6N;
+  typedef LinAlg::Matrix<real_type,n,n> MatrixNN;
+  typedef LinAlg::MatrixFactors<real_type,n,n,LinAlg::LUTag> MatrixFactorsNN;
+
+  CartesianActuatorFrame(const std::string& name) :
+    Frame(name),
+//     mJointMatrix(Matrix6N::zeros()), /// ??? ... see LinAlg checkout ...
+    mOutboardInertia(SpatialInertia::zeros()),
+    mOutboardForce(Vector6::zeros()),
+    mPAlpha(Vector6::zeros()),
+    mJointForce(VectorN::zeros()),
+    mArticulationDirty(true),
+    mJointVelDotDirty(true),
+    mSpVelDotDirty(true),
+    mJointVelDot(VectorN::zeros()),
+    mRelVelDot(Vector6::zeros())
+  { }
+  virtual ~CartesianActuatorFrame(void)
+  { }
+
+  /// The interface routine for the Frame,
+  /// returns the relative velocity derivative of this frame
+  virtual const Vector6& getRelVelDot(void) const
+  {
+    if (mSpVelDotDirty) {
+      mRelVelDot = mJointMatrix*getJointVelDot();
+      mSpVelDotDirty = false;
+      // Note that we do not need to mark the accelerations dirty since
+      // we can only get here if something else the accelerations will depend
+      // on anyway is set dirty before
+      // setAccelDirty();
+    }
+    return mRelVelDot;
+  }
+
+  /// Returns the derivative of the joint velocity
+  const VectorN& getJointVelDot() const
+  {
+    OpenFDMAssert(!mArticulationDirty);
+    if (mJointVelDotDirty) {
+      if (hIh.singular()) {
+        Log(ArtBody,Error) << "Detected singular mass matrix for "
+                           << "CartesianActuatorFrame \"" << getName()
+                           << "\": Fix your model!" << endl;
+        mJointVelDot.clear();
+      } else {
+        Vector6 tmp = mOutboardInertia*getParentSpAccel() + mPAlpha;
+        mJointVelDot = hIh.solve(mJointForce - trans(mJointMatrix)*tmp);
+      }
+      mJointVelDotDirty = false;
+    }
+    return mJointVelDot;
+  }
+
+  /// Compute the articulated force and inertia past inboard to that joint
+  bool jointArticulation(SpatialInertia& artI, Vector6& artF,
+                         const Vector6& outF, const SpatialInertia& outI,
+                         const VectorN& jointAccel)
+  {
+    // Store the outboard values since we will need them later in velocity
+    // derivative computations
+    mOutboardInertia = outI;
+    mOutboardForce = outF;
+    // Make sure we have the correct internal state
+    mJointVelDotDirty = true;
+    mArticulationDirty = false;
+
+    // Compute the projection to the joint coodinate space
+    Matrix6N Ih = outI*mJointMatrix;
+    hIh = trans(mJointMatrix)*Ih;
+
+    mPAlpha = mOutboardForce + mOutboardInertia*getHdot();
+
+    mJointForce = trans(mJointMatrix)*(Ih*jointAccel + mPAlpha);
+
+    artF = mPAlpha;
+    artI = outI;
+
+    if (hIh.singular()) {
+      Log(ArtBody,Error) << "Detected singular mass matrix for "
+                         << "CartesianActuatorFrame \"" << getName()
+                         << "\": Fix your model!" << endl;
+      return false;
+    }
+    
+    // Project away the directions handled with this current joint
+    artF -= Ih*hIh.solve(trans(mJointMatrix)*mPAlpha - mJointForce);
+    artI -= SpatialInertia(Ih*hIh.solve(trans(Ih)));
+
+    return true;
+  }
+
+protected:
+  const Matrix6N& getJointMatrix(void) const
+  { return mJointMatrix; }
+
+  void setJointMatrix(const Matrix6N& jointAxis)
+  { mJointMatrix = jointAxis; setDirty(); }
+
+  void setPosition(const Vector3& pos)
+  { Frame::setPosition(pos); setDirty(); }
+  void setOrientation(const Quaternion& orientation)
+  { Frame::setOrientation(orientation); setDirty(); }
+  void setRelVel(const Vector6& vel)
+  { Frame::setRelVel(vel); setDirty(); }
+  void setLinearRelVel(const Vector3& vel)
+  { Frame::setLinearRelVel(vel); setDirty(); }
+  void setAngularRelVel(const Vector3& vel)
+  { Frame::setAngularRelVel(vel); setDirty(); }
+  void setDirty(void) const
+  {
+    mArticulationDirty = true;
+    mJointVelDotDirty = true;
+    mSpVelDotDirty = true;
+    setAccelDirty();
+  }
+
+private:
+  /// The cartesian joint map matrix, that is for the simple one dimensional
+  /// case just a spatial vector.
+  Matrix6N mJointMatrix;
+
+  /// The articulated intertia of the outboard frame, 
+  SpatialInertia mOutboardInertia;
+  /// The articulated force of the outboard frame, 
+  Vector6 mOutboardForce;
+  /// The joint internal force in joint generalized coordinates
+  VectorN mJointForce;
+  /// Some intermediate value we will need later
+  Vector6 mPAlpha;
+  /// The decomposition of the inertia matrix projected to joint coordinates
+  MatrixFactorsNN hIh;
+  /// This is true if the state has changed but the articulated intertia and
+  /// forces are not yet updated
+  mutable bool mArticulationDirty:1;
+  /// This is true if the joint velocity derivatives are not yet computed
+  mutable bool mJointVelDotDirty:1;
+  /// This is true if the spatial velocity derivative is not yet computed
+  mutable bool mSpVelDotDirty:1;
+  /// The derivative of the joint velocity
+  mutable VectorN mJointVelDot;
+  /// The derivative of the frame velocity
+  mutable Vector6 mRelVelDot;
+};
+
+} // namespace OpenFDM
+
+#endif


Property changes on: trunk/OpenFDM/src/OpenFDM/CartesianActuatorFrame.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/OpenFDM/src/OpenFDM/CartesianJointFrame.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/CartesianJointFrame.h	2005-12-28 10:57:02 UTC (rev 136)
+++ trunk/OpenFDM/src/OpenFDM/CartesianJointFrame.h	2005-12-28 23:28:32 UTC (rev 137)
@@ -150,11 +150,11 @@
   MatrixFactorsNN hIh;
   /// This is true if the state has changed but the articulated intertia and
   /// forces are not yet updated
-  mutable bool mArticulationDirty : 1;
+  mutable bool mArticulationDirty:1;
   /// This is true if the joint velocity derivatives are not yet computed
-  mutable bool mJointVelDotDirty : 1;
+  mutable bool mJointVelDotDirty:1;
   /// This is true if the spatial velocity derivative is not yet computed
-  mutable bool mSpVelDotDirty : 1;
+  mutable bool mSpVelDotDirty:1;
   /// The derivative of the joint velocity
   mutable VectorN mJointVelDot;
   /// The derivative of the frame velocity

Deleted: trunk/OpenFDM/src/OpenFDM/LineActuator.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/LineActuator.cpp	2005-12-28 10:57:02 UTC (rev 136)
+++ trunk/OpenFDM/src/OpenFDM/LineActuator.cpp	2005-12-28 23:28:32 UTC (rev 137)
@@ -1,57 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
- *
- */
-
-#include "Model.h"
-#include "Vector.h"
-#include "LineActuator.h"
-
-namespace OpenFDM {
-
-LineActuator::LineActuator(const std::string& name) :
-  LineForce(name),
-  mProportionalGain(1),
-  mDerivativeGain(0)
-{
-  setNumInputPorts(1);
-  setInputPortName(0, "targetPosition");
-}
-
-LineActuator::~LineActuator(void)
-{
-}
-
-void
-LineActuator::output(const TaskInfo& taskInfo)
-{
-  RealPortHandle rh = getInputPort(0)->toRealPortHandle();
-  real_type posInput = rh.getRealValue();
-  real_type displacement = getPosition() - posInput;
-  setForce(mProportionalGain*displacement + getVel()*mDerivativeGain);
-}
-
-real_type
-LineActuator::getProportionalGain(void) const
-{
-  return mProportionalGain;
-}
-
-void
-LineActuator::setProportionalGain(real_type proportionalGain)
-{
-  mProportionalGain = proportionalGain;
-}
-
-real_type
-LineActuator::getDerivativeGain(void) const
-{
-  return mDerivativeGain;
-}
-
-void
-LineActuator::setDerivativeGain(real_type derivativeGain)
-{
-  mDerivativeGain = derivativeGain;
-}
-
-} // namespace OpenFDM

Deleted: trunk/OpenFDM/src/OpenFDM/LineActuator.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/LineActuator.h	2005-12-28 10:57:02 UTC (rev 136)
+++ trunk/OpenFDM/src/OpenFDM/LineActuator.h	2005-12-28 23:28:32 UTC (rev 137)
@@ -1,36 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
- *
- */
-
-#ifndef OpenFDM_LineActuator_H
-#define OpenFDM_LineActuator_H
-
-#include "Model.h"
-#include "Vector.h"
-#include "LineForce.h"
-
-namespace OpenFDM {
-
-/// Linear spring damper model
-class LineActuator :
-    public LineForce {
-public:
-  LineActuator(const std::string& name);
-  virtual ~LineActuator(void);
-
-  virtual void output(const TaskInfo& taskInfo);
-
-  real_type getProportionalGain(void) const;
-  void setProportionalGain(real_type proportionalGain);
-
-  real_type getDerivativeGain(void) const;
-  void setDerivativeGain(real_type derivativeGain);
-
-private:
-  real_type mProportionalGain;
-  real_type mDerivativeGain;
-};
-
-} // namespace OpenFDM
-
-#endif

Modified: trunk/OpenFDM/src/OpenFDM/Makefile.am
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Makefile.am	2005-12-28 10:57:02 UTC (rev 136)
+++ trunk/OpenFDM/src/OpenFDM/Makefile.am	2005-12-28 23:28:32 UTC (rev 137)
@@ -31,6 +31,7 @@
   AtmosphereSTD1976.h \
   Bias.h \
   BinaryFunctionModel.h \
+  CartesianActuatorFrame.h \
   CartesianJointFrame.h \
   Contact.h \
   ConstantForce.h \
@@ -72,7 +73,6 @@
   LinAlg/IO.h \
   LinAlg/Misc.h \
   LinAlg/Proxy.h \
-  LineActuator.h \
   LinearSpring.h \
   LineForce.h \
   LogStream.h \
@@ -101,6 +101,8 @@
   Quaternion.h \
   ReaderWriter.h \
   Referenced.h \
+  RevoluteActuator.h \
+  RevoluteActuatorFrame.h \
   RevoluteJoint.h \
   RevoluteJointFrame.h \
   RigidBody.h \
@@ -168,7 +170,6 @@
   Interact.cpp \
   ImplicitEuler.cpp \
   Joint.cpp \
-  LineActuator.cpp \
   LinearSpring.cpp \
   LineForce.cpp \
   Logger.cpp \
@@ -188,6 +189,7 @@
   Product.cpp \
   Property.cpp \
   ReaderWriter.cpp \
+  RevoluteActuator.cpp \
   RevoluteJoint.cpp \
   RigidBody.cpp \
   RootFrame.cpp \

Added: trunk/OpenFDM/src/OpenFDM/RevoluteActuator.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RevoluteActuator.cpp	2005-12-28 10:57:02 UTC (rev 136)
+++ trunk/OpenFDM/src/OpenFDM/RevoluteActuator.cpp	2005-12-28 23:28:32 UTC (rev 137)
@@ -0,0 +1,151 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
+ *
+ */
+
+#include "Assert.h"
+#include "LogStream.h"
+#include "Limits.h"
+#include "Object.h"
+#include "Vector.h"
+#include "Matrix.h"
+#include "Quaternion.h"
+#include "Inertia.h"
+#include "Frame.h"
+#include "RigidBody.h"
+#include "RevoluteActuatorFrame.h"
+#include "RevoluteActuator.h"
+
+namespace OpenFDM {
+
+RevoluteActuator::RevoluteActuator(const std::string& name) :
+  Joint(name),
+  mMaxVel(1),
+  mVelGain(1e2),
+  mVelDotGain(1e2)
+{
+  setNumContinousStates(2);
+
+  mRevoluteActuatorFrame = new RevoluteActuatorFrame(name);
+
+  setNumInputPorts(1);
+  setInputPortName(0, "position");
+
+  setNumOutputPorts(2);
+  setOutputPort(0, "jointPos", this, &RevoluteActuator::getJointPos);
+  setOutputPort(1, "jointVel", this, &RevoluteActuator::getJointVel);
+}
+
+RevoluteActuator::~RevoluteActuator(void)
+{
+}
+
+void
+RevoluteActuator::recheckTopology(void)
+{
+  if (!getOutboardBody() || !getInboardBody())
+    return;
+  
+  // check for the inboard frame
+  Frame* inFrame = getInboardBody()->getFrame();
+  if (!inFrame)
+    return;
+  
+  Frame* outFrame = getOutboardBody()->getFrame();
+  if (!outFrame) {
+    getOutboardBody()->setFrame(mRevoluteActuatorFrame);
+  }
+  outFrame = getOutboardBody()->getFrame();
+  if (!outFrame->isParentFrame(inFrame)) {
+    inFrame->addChildFrame(mRevoluteActuatorFrame);
+  }
+}
+
+void
+RevoluteActuator::setJointAxis(const Vector3& axis)
+{
+  real_type nrm = norm(axis);
+  if (nrm < Limits<real_type>::min()) {
+    Log(Initialization, Error) << "JointAxis is zero ..." << endl;
+    return;
+  }
+  mRevoluteActuatorFrame->setJointAxis((1/nrm)*axis);
+}
+
+const real_type&
+RevoluteActuator::getJointPos(void) const
+{
+  return mRevoluteActuatorFrame->getJointPos();
+}
+
+void
+RevoluteActuator::setJointPos(real_type pos)
+{
+  mRevoluteActuatorFrame->setJointPos(pos);
+}
+
+const real_type&
+RevoluteActuator::getJointVel(void) const
+{
+  return mRevoluteActuatorFrame->getJointVel();
+}
+
+void
+RevoluteActuator::setJointVel(real_type vel)
+{
+  mRevoluteActuatorFrame->setJointVel(vel);
+}
+
+void
+RevoluteActuator::setPosition(const Vector3& position)
+{
+  mRevoluteActuatorFrame->setPosition(position);
+}
+
+void
+RevoluteActuator::setOrientation(const Quaternion& orientation)
+{
+  mRevoluteActuatorFrame->setZeroOrientation(orientation);
+}
+
+void
+RevoluteActuator::jointArticulation(SpatialInertia& artI, Vector6& artF,
+                                 const SpatialInertia& outI,
+                                 const Vector6& outF)
+{
+  OpenFDMAssert(getInputPort(0)->isConnected());
+  RealPortHandle rh = getInputPort(0)->toRealPortHandle();
+  real_type desiredPos = rh.getRealValue();
+
+  real_type posErr = desiredPos - mRevoluteActuatorFrame->getJointPos();
+
+  real_type desiredVel = mVelGain*sign(posErr)*min(fabs(posErr), mMaxVel);
+
+  real_type velErr = desiredVel - mRevoluteActuatorFrame->getJointVel();
+
+  CartesianActuatorFrame<1>::VectorN tau;
+  tau(1) = mVelDotGain*velErr;
+  mRevoluteActuatorFrame->jointArticulation(artI, artF, outF, outI, tau);
+}
+
+void
+RevoluteActuator::setState(const Vector& state, unsigned offset)
+{
+  mRevoluteActuatorFrame->setJointPos(state(offset+1));
+  mRevoluteActuatorFrame->setJointVel(state(offset+2));
+}
+
+void
+RevoluteActuator::getState(Vector& state, unsigned offset) const
+{
+  state(offset+1) = mRevoluteActuatorFrame->getJointPos();
+  state(offset+2) = mRevoluteActuatorFrame->getJointVel();
+}
+
+void
+RevoluteActuator::getStateDeriv(Vector& state, unsigned offset)
+{
+  state(offset+1) = mRevoluteActuatorFrame->getJointVel();
+  state(offset+2) = mRevoluteActuatorFrame->getJointVelDot()(1);
+}
+
+} // namespace OpenFDM


Property changes on: trunk/OpenFDM/src/OpenFDM/RevoluteActuator.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/OpenFDM/src/OpenFDM/RevoluteActuator.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RevoluteActuator.h	2005-12-28 10:57:02 UTC (rev 136)
+++ trunk/OpenFDM/src/OpenFDM/RevoluteActuator.h	2005-12-28 23:28:32 UTC (rev 137)
@@ -0,0 +1,103 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_RevoluteActuator_H
+#define OpenFDM_RevoluteActuator_H
+
+#include "Assert.h"
+#include "Object.h"
+#include "Vector.h"
+#include "Matrix.h"
+#include "Quaternion.h"
+#include "Inertia.h"
+#include "Frame.h"
+#include "RigidBody.h"
+#include "Joint.h"
+
+namespace OpenFDM {
+
+class RevoluteActuatorFrame;
+
+class RevoluteActuator :
+    public Joint {
+public:
+  RevoluteActuator(const std::string& name);
+  virtual ~RevoluteActuator(void);
+
+  virtual bool init(void)
+  { recheckTopology(); return Joint::init(); }
+
+  virtual void recheckTopology(void);
+
+  /** Sets the joint axis where this joint is allowed to rotate around.
+   */
+  void setJointAxis(const Vector3& axis);
+
+  /** Returns the joint position.
+   */
+  const real_type& getJointPos(void) const;
+
+  /** Sets the joint position.
+   */
+  void setJointPos(real_type pos);
+
+  /** Returns the joint velocity.
+   */
+  const real_type& getJointVel(void) const;
+
+  /** Sets the joint velocity.
+   */
+  void setJointVel(real_type vel);
+
+  /** Set the position of the joint.
+   */
+  void setPosition(const Vector3& position);
+
+  /** Sets the zero orientation of the joint.
+   */
+  void setOrientation(const Quaternion& orientation);
+
+  const real_type& getMaxVel(void) const
+  { return mMaxVel; }
+  void setMaxVel(real_type maxVel)
+  { mMaxVel = maxVel; }
+
+  const real_type& getVelGain(void) const
+  { return mVelGain; }
+  void setVelGain(real_type velGain)
+  { mVelGain = velGain; }
+
+  const real_type& getVelDotGain(void) const
+  { return mVelDotGain; }
+  void setVelDotGain(real_type velDotGain)
+  { mVelDotGain = velDotGain; }
+
+private:
+  /** Computes the inboard articulated inertia and force for
+      this articulated body. It is part of the articulated body algorithm.
+   */
+  virtual void jointArticulation(SpatialInertia& artI, Vector6& artF,
+                                 const SpatialInertia& outI,
+                                 const Vector6& outF);
+
+  /** Methods for the OpenFDM::Part.
+   */
+  virtual void setState(const Vector& state, unsigned offset);
+  virtual void getState(Vector& state, unsigned offset) const;
+  virtual void getStateDeriv(Vector& state, unsigned offset);
+
+  /// The maximum movement of the controler
+  real_type mMaxVel;
+  /// The velocity p gain
+  real_type mVelGain;
+  /// The velocity derivative p gain
+  real_type mVelDotGain;
+
+  /// The frame of the mobile root
+  SharedPtr<RevoluteActuatorFrame> mRevoluteActuatorFrame;
+};
+
+} // namespace OpenFDM
+
+#endif


Property changes on: trunk/OpenFDM/src/OpenFDM/RevoluteActuator.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/OpenFDM/src/OpenFDM/RevoluteActuatorFrame.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RevoluteActuatorFrame.h	2005-12-28 10:57:02 UTC (rev 136)
+++ trunk/OpenFDM/src/OpenFDM/RevoluteActuatorFrame.h	2005-12-28 23:28:32 UTC (rev 137)
@@ -0,0 +1,93 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_RevoluteActuatorFrame_H
+#define OpenFDM_RevoluteActuatorFrame_H
+
+#include "Assert.h"
+#include "Vector.h"
+#include "Matrix.h"
+#include "Quaternion.h"
+#include "Inertia.h"
+#include "Frame.h"
+#include "RigidBody.h"
+#include "Joint.h"
+#include "LineForce.h"
+#include "CartesianActuatorFrame.h"
+
+namespace OpenFDM {
+
+class RevoluteActuatorFrame :
+    public CartesianActuatorFrame<1> {
+public:
+  RevoluteActuatorFrame(const std::string& name) :
+    CartesianActuatorFrame<1>(name),
+    mZeroOrient(Quaternion::unit()),
+    mJointAxis(Vector3::unit(1)),
+    mJointPos(0),
+    mJointVel(0)
+  { }
+  virtual ~RevoluteActuatorFrame(void) {}
+
+  /// Gets the joint axis where this joint is allowed to rotate around.
+  const Vector3& getJointAxis(void) const
+  { return mJointAxis; }
+
+  /// Sets the joint axis where this joint is allowed to rotate around.
+  void setJointAxis(const Vector3& axis)
+  {
+    mJointAxis = axis;
+    setOrientation(mZeroOrient*Quaternion::fromAngleAxis(mJointPos, mJointAxis));
+    setAngularRelVel(mJointVel*mJointAxis);
+
+    setJointMatrix(Vector6(axis, Vector3::zeros()));
+  }
+
+  /// Returns the joint position.
+  const real_type& getJointPos(void) const
+  { return mJointPos; }
+
+  /// Sets the joint position.
+  void setJointPos(real_type pos)
+  {
+    mJointPos = pos;
+    setOrientation(mZeroOrient*Quaternion::fromAngleAxis(mJointPos, mJointAxis));
+  }
+
+  /// Returns the joint velocity.
+  const real_type& getJointVel(void) const
+  { return mJointVel; }
+
+  /// Sets the joint velocity.
+  void setJointVel(real_type vel)
+  { setAngularRelVel(mJointVel*mJointAxis); mJointVel = vel; }
+
+  /// Sets the zero orientation of the joint.
+  void setZeroOrientation(const Quaternion& zeroOrient)
+  {
+    setOrientation(zeroOrient*Quaternion::fromAngleAxis(mJointPos, mJointAxis));
+    mZeroOrient = zeroOrient;
+  }
+  const Quaternion& getZeroOrientation(void) const
+  { return mZeroOrient; }
+
+  using CartesianActuatorFrame<1>::setPosition;
+
+private:
+  /// The zero orientation with respect to the parent frame.
+  Quaternion mZeroOrient;
+
+  /// The joint rotation axis.
+  Vector3 mJointAxis;
+
+  /// The relative joint rotation with respect to the zero orientation.
+  real_type mJointPos;
+
+  /// The rotational velocity with respect to the rotation axis.
+  real_type mJointVel;
+};
+
+} // namespace OpenFDM
+
+#endif


Property changes on: trunk/OpenFDM/src/OpenFDM/RevoluteActuatorFrame.h
___________________________________________________________________
Name: svn:eol-style
   + native



From frohlich at berlios.de  Thu Dec 29 00:51:19 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Thu, 29 Dec 2005 00:51:19 +0100
Subject: [OpenFDM-svn] r138 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200512282351.jBSNpJXD009972@sheep.berlios.de>

Author: frohlich
Date: 2005-12-29 00:51:04 +0100 (Thu, 29 Dec 2005)
New Revision: 138

Modified:
   trunk/OpenFDM/src/OpenFDM/SampleTime.h
Log:
Add little hint


Modified: trunk/OpenFDM/src/OpenFDM/SampleTime.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/SampleTime.h	2005-12-28 23:28:32 UTC (rev 137)
+++ trunk/OpenFDM/src/OpenFDM/SampleTime.h	2005-12-28 23:51:04 UTC (rev 138)
@@ -17,6 +17,9 @@
 /// - positive real number, this is the discrete sample time itself
 /// - zero, continous updates
 /// - otherwise, inherited from its parent model group
+/// FIXME: need to have a sample time slot which is only evaluated if the
+/// simulation returns to the user. Just to avoid additional effort for
+/// animations
 class SampleTime {
 public:
   /// Default constructor, defaults to discrete sample time



From frohlich at berlios.de  Thu Dec 29 00:51:43 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Thu, 29 Dec 2005 00:51:43 +0100
Subject: [OpenFDM-svn] r139 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200512282351.jBSNphGV010186@sheep.berlios.de>

Author: frohlich
Date: 2005-12-29 00:51:39 +0100 (Thu, 29 Dec 2005)
New Revision: 139

Modified:
   trunk/OpenFDM/src/OpenFDM/AirSpring.cpp
Log:
Tune that thing a bit ...


Modified: trunk/OpenFDM/src/OpenFDM/AirSpring.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/AirSpring.cpp	2005-12-28 23:51:04 UTC (rev 138)
+++ trunk/OpenFDM/src/OpenFDM/AirSpring.cpp	2005-12-28 23:51:39 UTC (rev 139)
@@ -36,8 +36,8 @@
   real_type pushDispRatio = pushDisp/maxDisp;
   
   
-  pullDispRatio = max(min(pullDispRatio, 0.99), 0.0);
-  pushDispRatio = max(min(pushDispRatio, 0.99), 0.0);
+  pullDispRatio = max(min(pullDispRatio, 0.95), 0.0);
+  pushDispRatio = max(min(pushDispRatio, 0.95), 0.0);
   
   real_type pullPressure = mPullPressure/(1-pow(pullDispRatio, mGamma));
   real_type pushPressure = mPushPressure/(1-pow(pushDispRatio, mGamma));



From frohlich at berlios.de  Thu Dec 29 15:43:46 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Thu, 29 Dec 2005 15:43:46 +0100
Subject: [OpenFDM-svn] r140 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200512291443.jBTEhkdp029226@sheep.berlios.de>

Author: frohlich
Date: 2005-12-29 15:43:32 +0100 (Thu, 29 Dec 2005)
New Revision: 140

Added:
   trunk/OpenFDM/src/OpenFDM/StateStream.h
Modified:
   trunk/OpenFDM/src/OpenFDM/DiscreteIntegrator.cpp
   trunk/OpenFDM/src/OpenFDM/DiscreteIntegrator.h
   trunk/OpenFDM/src/OpenFDM/Integrator.cpp
   trunk/OpenFDM/src/OpenFDM/Integrator.h
   trunk/OpenFDM/src/OpenFDM/Makefile.am
   trunk/OpenFDM/src/OpenFDM/MobileRootJoint.cpp
   trunk/OpenFDM/src/OpenFDM/MobileRootJoint.h
   trunk/OpenFDM/src/OpenFDM/Model.cpp
   trunk/OpenFDM/src/OpenFDM/Model.h
   trunk/OpenFDM/src/OpenFDM/ModelGroup.cpp
   trunk/OpenFDM/src/OpenFDM/ModelGroup.h
   trunk/OpenFDM/src/OpenFDM/PrismaticJoint.cpp
   trunk/OpenFDM/src/OpenFDM/PrismaticJoint.h
   trunk/OpenFDM/src/OpenFDM/RevoluteActuator.cpp
   trunk/OpenFDM/src/OpenFDM/RevoluteActuator.h
   trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp
   trunk/OpenFDM/src/OpenFDM/RevoluteJoint.h
   trunk/OpenFDM/src/OpenFDM/System.cpp
   trunk/OpenFDM/src/OpenFDM/TransferFunction.cpp
   trunk/OpenFDM/src/OpenFDM/TransferFunction.h
Log:
Replace the state set/get methods with a more
compact class approach.


Modified: trunk/OpenFDM/src/OpenFDM/DiscreteIntegrator.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/DiscreteIntegrator.cpp	2005-12-28 23:51:39 UTC (rev 139)
+++ trunk/OpenFDM/src/OpenFDM/DiscreteIntegrator.cpp	2005-12-29 14:43:32 UTC (rev 140)
@@ -79,25 +79,15 @@
 }
 
 void
-DiscreteIntegrator::setDiscreteState(const Vector& state, unsigned offset)
+DiscreteIntegrator::setDiscreteState(const StateStream& state)
 {
-  // FIXME reshape ...
-  for (unsigned j = 1; j <= cols(mIntegralState); ++j) {
-    for (unsigned i = 1; i <= rows(mIntegralState); ++i) {
-      mIntegralState(i, j) = state(offset + i + (j-1)*rows(mIntegralState));
-    }
-  }
+  state.readSubState(mIntegralState);
 }
 
 void
-DiscreteIntegrator::getDiscreteState(Vector& state, unsigned offset) const
+DiscreteIntegrator::getDiscreteState(StateStream& state) const
 {
-  // FIXME reshape ...
-  for (unsigned j = 1; j <= cols(mIntegralState); ++j) {
-    for (unsigned i = 1; i <= rows(mIntegralState); ++i) {
-      state(offset + i + (j-1)*rows(mIntegralState)) = mIntegralState(i, j);
-    }
-  }
+  state.writeSubState(mIntegralState);
 }
 
 const Matrix&

Modified: trunk/OpenFDM/src/OpenFDM/DiscreteIntegrator.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/DiscreteIntegrator.h	2005-12-28 23:51:39 UTC (rev 139)
+++ trunk/OpenFDM/src/OpenFDM/DiscreteIntegrator.h	2005-12-29 14:43:32 UTC (rev 140)
@@ -20,8 +20,8 @@
   virtual void output(const TaskInfo&);
   virtual void update(const TaskInfo& taskInfo);
 
-  virtual void setDiscreteState(const Vector& state, unsigned offset);
-  virtual void getDiscreteState(Vector& state, unsigned offset) const;
+  virtual void setDiscreteState(const StateStream& state);
+  virtual void getDiscreteState(StateStream& state) const;
 
   const Matrix& getInitialValue(void) const;
   void setInitialValue(const Matrix& value);

Modified: trunk/OpenFDM/src/OpenFDM/Integrator.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Integrator.cpp	2005-12-28 23:51:39 UTC (rev 139)
+++ trunk/OpenFDM/src/OpenFDM/Integrator.cpp	2005-12-29 14:43:32 UTC (rev 140)
@@ -54,29 +54,19 @@
 }
 
 void
-Integrator::setState(const Vector& state, unsigned offset)
+Integrator::setState(const StateStream& state)
 {
-  // FIXME reshape ...
-  for (unsigned j = 1; j <= cols(mIntegralState); ++j) {
-    for (unsigned i = 1; i <= rows(mIntegralState); ++i) {
-      mIntegralState(i, j) = state(offset + i + (j-1)*rows(mIntegralState));
-    }
-  }
+  state.readSubState(mIntegralState);
 }
 
 void
-Integrator::getState(Vector& state, unsigned offset) const
+Integrator::getState(StateStream& state) const
 {
-  // FIXME reshape ...
-  for (unsigned j = 1; j <= cols(mIntegralState); ++j) {
-    for (unsigned i = 1; i <= rows(mIntegralState); ++i) {
-      state(offset + i + (j-1)*rows(mIntegralState)) = mIntegralState(i, j);
-    }
-  }
+  state.writeSubState(mIntegralState);
 }
 
 void
-Integrator::getStateDeriv(Vector& stateDeriv, unsigned offset)
+Integrator::getStateDeriv(StateStream& stateDeriv)
 {
   OpenFDMAssert(getInputPort(0)->isConnected());
 
@@ -85,12 +75,7 @@
   const Matrix& input = mh.getMatrixValue();
   OpenFDMAssert(size(input) == size(mIntegralState));
 
-  // FIXME reshape ...
-  for (unsigned j = 1; j <= cols(input); ++j) {
-    for (unsigned i = 1; i <= rows(input); ++i) {
-      stateDeriv(offset + i + (j-1)*rows(input)) = input(i, j);
-    }
-  }
+  stateDeriv.writeSubState(input);
 }
 
 const Matrix&

Modified: trunk/OpenFDM/src/OpenFDM/Integrator.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Integrator.h	2005-12-28 23:51:39 UTC (rev 139)
+++ trunk/OpenFDM/src/OpenFDM/Integrator.h	2005-12-29 14:43:32 UTC (rev 140)
@@ -19,9 +19,9 @@
   virtual bool init(void);
   virtual void output(const TaskInfo&);
 
-  virtual void setState(const Vector& state, unsigned offset);
-  virtual void getState(Vector& state, unsigned offset) const;
-  virtual void getStateDeriv(Vector& stateDeriv, unsigned offset);
+  virtual void setState(const StateStream& state);
+  virtual void getState(StateStream& state) const;
+  virtual void getStateDeriv(StateStream& stateDeriv);
 
   const Matrix& getInitialValue(void) const;
   void setInitialValue(const Matrix& value);

Modified: trunk/OpenFDM/src/OpenFDM/Makefile.am
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Makefile.am	2005-12-28 23:51:39 UTC (rev 139)
+++ trunk/OpenFDM/src/OpenFDM/Makefile.am	2005-12-29 14:43:32 UTC (rev 140)
@@ -114,6 +114,7 @@
   Sensor.h \
   SimpleContact.h \
   SimpleGear.h \
+  StateStream.h \
   Summer.h \
   System.h \
   Table.h \

Modified: trunk/OpenFDM/src/OpenFDM/MobileRootJoint.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/MobileRootJoint.cpp	2005-12-28 23:51:39 UTC (rev 139)
+++ trunk/OpenFDM/src/OpenFDM/MobileRootJoint.cpp	2005-12-29 14:43:32 UTC (rev 140)
@@ -125,40 +125,29 @@
 }
 
 void
-MobileRootJoint::setState(const Vector& state, unsigned offset)
+MobileRootJoint::setState(const StateStream& state)
 {
-  mFrame->setOrientation(Vector4(state(offset+1), state(offset+2),
-                                 state(offset+3), state(offset+4)));
-  mFrame->setPosition(Vector3(state(offset+5), state(offset+6), state(offset+7)));
-  mFrame->setRelVel(Vector6(state(offset+8), state(offset+9), state(offset+10),
-                            state(offset+11), state(offset+12), state(offset+13)));
+  Quaternion q;
+  state.readSubState(q);
+  mFrame->setOrientation(q);
+  Vector3 p;
+  state.readSubState(p);
+  mFrame->setPosition(p);
+  Vector6 v;
+  state.readSubState(v);
+  mFrame->setRelVel(v);
 }
 
 void
-MobileRootJoint::getState(Vector& state, unsigned offset) const
+MobileRootJoint::getState(StateStream& state) const
 {
-  Quaternion q = mFrame->getOrientation();
-  state(offset+1) = q(1);
-  state(offset+2) = q(2);
-  state(offset+3) = q(3);
-  state(offset+4) = q(4);
-  
-  Vector3 p = mFrame->getPosition();
-  state(offset+5) = p(1);
-  state(offset+6) = p(2);
-  state(offset+7) = p(3);
-  
-  Vector6 v = mFrame->getRelVel();
-  state(offset+8) = v(1);
-  state(offset+9) = v(2);
-  state(offset+10) = v(3);
-  state(offset+11) = v(4);
-  state(offset+12) = v(5);
-  state(offset+13) = v(6);
+  state.writeSubState(mFrame->getOrientation());
+  state.writeSubState(mFrame->getPosition());
+  state.writeSubState(mFrame->getRelVel());
 }
 
 void
-MobileRootJoint::getStateDeriv(Vector& state, unsigned offset)
+MobileRootJoint::getStateDeriv(StateStream& stateDeriv)
 {
   Quaternion q = mFrame->getOrientation();
   Vector3 angVel = mFrame->getRelVel().getAngular();
@@ -169,22 +158,9 @@
   // That is if |q| < 1 add a little radial component outward,
   // if |q| > 1 add a little radial component inward
   Vector4 qderiv = derivative(q, angVel) + 0.1*(normalize(q) - q);
-  state(offset+1) = qderiv(1);
-  state(offset+2) = qderiv(2);
-  state(offset+3) = qderiv(3);
-  state(offset+4) = qderiv(4);
-  
-  state(offset+5) = vel(1);
-  state(offset+6) = vel(2);
-  state(offset+7) = vel(3);
-  
-  Vector6 accel = mFrame->getRelVelDot();
-  state(offset+8)  = accel(1);
-  state(offset+9)  = accel(2);
-  state(offset+10) = accel(3);
-  state(offset+11) = accel(4);
-  state(offset+12) = accel(5);
-  state(offset+13) = accel(6);
+  stateDeriv.writeSubState(qderiv);
+  stateDeriv.writeSubState(vel);
+  stateDeriv.writeSubState(mFrame->getRelVelDot());
 }
 
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/MobileRootJoint.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/MobileRootJoint.h	2005-12-28 23:51:39 UTC (rev 139)
+++ trunk/OpenFDM/src/OpenFDM/MobileRootJoint.h	2005-12-29 14:43:32 UTC (rev 140)
@@ -52,13 +52,13 @@
 
   /** Plugin function for the state propagation.
    */
-  virtual void setState(const Vector& state, unsigned offset);
+  virtual void setState(const StateStream& state);
   /** Plugin function for the state propagation.
    */
-  virtual void getState(Vector& state, unsigned offset) const;
+  virtual void getState(StateStream& state) const;
   /** Plugin function for the state propagation.
    */
-  virtual void getStateDeriv(Vector& state, unsigned offset);
+  virtual void getStateDeriv(StateStream& state);
 
   /// The commonly used gravity model from the environment class
   /// It is initialized at the init() call

Modified: trunk/OpenFDM/src/OpenFDM/Model.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Model.cpp	2005-12-28 23:51:39 UTC (rev 139)
+++ trunk/OpenFDM/src/OpenFDM/Model.cpp	2005-12-29 14:43:32 UTC (rev 140)
@@ -90,27 +90,27 @@
 }
 
 void
-Model::setState(const Vector& state, unsigned offset)
+Model::setState(const StateStream& state)
 {
 }
 
 void
-Model::getState(Vector& state, unsigned offset) const
+Model::getState(StateStream& state) const
 {
 }
 
 void
-Model::getStateDeriv(Vector& stateDeriv, unsigned offset)
+Model::getStateDeriv(StateStream& stateDeriv)
 {
 }
 
 void
-Model::setDiscreteState(const Vector& state, unsigned offset)
+Model::setDiscreteState(const StateStream& state)
 {
 }
 
 void
-Model::getDiscreteState(Vector& state, unsigned offset) const
+Model::getDiscreteState(StateStream& state) const
 {
 }
 
@@ -118,13 +118,17 @@
 Model::evalFunction(real_type t, const Vector& v, Vector& out)
 {
   /// FIXME Hmm, may be different ...
-  setState(v, 0);
+  StateStream stateStream(v);
+  setState(v);
+
   TaskInfo taskInfo;
   taskInfo.setTime(t);
   taskInfo.addSampleTime(SampleTime::Continous);
   output(taskInfo);
-  out.resize(getNumContinousStates());
-  getStateDeriv(out, 0);
+
+  stateStream.reset();
+  getStateDeriv(stateStream);
+  out = stateStream.getState();
 }
 
 void

Modified: trunk/OpenFDM/src/OpenFDM/Model.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Model.h	2005-12-28 23:51:39 UTC (rev 139)
+++ trunk/OpenFDM/src/OpenFDM/Model.h	2005-12-29 14:43:32 UTC (rev 140)
@@ -17,6 +17,7 @@
 #include "Vector.h"
 #include "SampleTime.h"
 #include "TaskInfo.h"
+#include "StateStream.h"
 #include "Port.h"
 
 namespace OpenFDM {
@@ -62,12 +63,12 @@
   /// Called whenever discrete states need to be updated.
   virtual void update(const TaskInfo& taskInfo);
 
-  virtual void setState(const Vector& state, unsigned offset);
-  virtual void getState(Vector& state, unsigned offset) const;
-  virtual void getStateDeriv(Vector& stateDeriv, unsigned offset);
+  virtual void setState(const StateStream& state);
+  virtual void getState(StateStream& state) const;
+  virtual void getStateDeriv(StateStream& stateDeriv);
 
-  virtual void setDiscreteState(const Vector& state, unsigned offset);
-  virtual void getDiscreteState(Vector& state, unsigned offset) const;
+  virtual void setDiscreteState(const StateStream& state);
+  virtual void getDiscreteState(StateStream& state) const;
 
   /// FIXME Hmm, may be different ...
   /// May move into System ...

Modified: trunk/OpenFDM/src/OpenFDM/ModelGroup.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/ModelGroup.cpp	2005-12-28 23:51:39 UTC (rev 139)
+++ trunk/OpenFDM/src/OpenFDM/ModelGroup.cpp	2005-12-29 14:43:32 UTC (rev 140)
@@ -235,82 +235,57 @@
 }
 
 void
-ModelGroup::setState(const Vector& state, unsigned offset)
+ModelGroup::setState(const StateStream& state)
 {
-  OpenFDMAssert(offset + getNumContinousStates() <= rows(state));
-
   ModelList::iterator it;
   for (it = mModels.begin(); it != mModels.end(); ++it) {
     unsigned nStates = (*it)->getNumContinousStates();
-    if (0 < nStates) {
-      OpenFDMAssert(offset + nStates <= rows(state));
-      (*it)->setState(state, offset);
-      offset += nStates;
-    }
+    if (0 < nStates)
+      (*it)->setState(state);
   }
 }
 
 void
-ModelGroup::getState(Vector& state, unsigned offset) const
+ModelGroup::getState(StateStream& state) const
 {
-  OpenFDMAssert(offset + getNumContinousStates() <= rows(state));
-
   ModelList::const_iterator it;
   for (it = mModels.begin(); it != mModels.end(); ++it) {
     unsigned nStates = (*it)->getNumContinousStates();
-    if (0 < nStates) {
-      OpenFDMAssert(offset + nStates <= rows(state));
-      (*it)->getState(state, offset);
-      offset += nStates;
-    }
+    if (0 < nStates)
+      (*it)->getState(state);
   }
 }
 
 void
-ModelGroup::getStateDeriv(Vector& stateDeriv, unsigned offset)
+ModelGroup::getStateDeriv(StateStream& stateDeriv)
 {
-  OpenFDMAssert(offset + getNumContinousStates() <= rows(stateDeriv));
-
   ModelList::iterator it;
   for (it = mModels.begin(); it != mModels.end(); ++it) {
     unsigned nStates = (*it)->getNumContinousStates();
-    if (0 < nStates) {
-      OpenFDMAssert(offset + nStates <= rows(stateDeriv));
-      (*it)->getStateDeriv(stateDeriv, offset);
-      offset += nStates;
-    }
+    if (0 < nStates)
+      (*it)->getStateDeriv(stateDeriv);
   }
 }
 
 void
-ModelGroup::setDiscreteState(const Vector& state, unsigned offset)
+ModelGroup::setDiscreteState(const StateStream& state)
 {
-  OpenFDMAssert(offset + getNumDiscreteStates() <= rows(state));
-
   ModelList::iterator it;
   for (it = mModels.begin(); it != mModels.end(); ++it) {
     unsigned nStates = (*it)->getNumDiscreteStates();
-    if (0 < nStates) {
-      OpenFDMAssert(offset + nStates <= rows(state));
-      (*it)->setDiscreteState(state, offset);
-      offset += nStates;
-    }
+    if (0 < nStates)
+      (*it)->setDiscreteState(state);
   }
 }
 
 void
-ModelGroup::getDiscreteState(Vector& state, unsigned offset) const
+ModelGroup::getDiscreteState(StateStream& state) const
 {
-  OpenFDMAssert(offset + getNumDiscreteStates() <= rows(state));
-
   ModelList::const_iterator it;
   for (it = mModels.begin(); it != mModels.end(); ++it) {
     unsigned nStates = (*it)->getNumDiscreteStates();
-    if (0 < nStates) {
-      OpenFDMAssert(offset + nStates <= rows(state));
-      (*it)->getDiscreteState(state, offset);
-      offset += nStates;
-    }
+    if (0 < nStates)
+      (*it)->getDiscreteState(state);
   }
 }
 

Modified: trunk/OpenFDM/src/OpenFDM/ModelGroup.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/ModelGroup.h	2005-12-28 23:51:39 UTC (rev 139)
+++ trunk/OpenFDM/src/OpenFDM/ModelGroup.h	2005-12-29 14:43:32 UTC (rev 140)
@@ -54,12 +54,12 @@
   /// Called whenever discrete states need to be updated.
   virtual void update(const TaskInfo& taskInfo);
 
-  virtual void setState(const Vector& state, unsigned offset);
-  virtual void getState(Vector& state, unsigned offset) const;
-  virtual void getStateDeriv(Vector& stateDeriv, unsigned offset);
+  virtual void setState(const StateStream& state);
+  virtual void getState(StateStream& state) const;
+  virtual void getStateDeriv(StateStream& stateDeriv);
 
-  virtual void setDiscreteState(const Vector& state, unsigned offset);
-  virtual void getDiscreteState(Vector& state, unsigned offset) const;
+  virtual void setDiscreteState(const StateStream& state);
+  virtual void getDiscreteState(StateStream& state) const;
 
   /// make them public
   using Model::setNumInputPorts;

Modified: trunk/OpenFDM/src/OpenFDM/PrismaticJoint.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/PrismaticJoint.cpp	2005-12-28 23:51:39 UTC (rev 139)
+++ trunk/OpenFDM/src/OpenFDM/PrismaticJoint.cpp	2005-12-29 14:43:32 UTC (rev 140)
@@ -115,24 +115,27 @@
 }
 
 void
-PrismaticJoint::setState(const Vector& state, unsigned offset)
+PrismaticJoint::setState(const StateStream& state)
 {
-  mPrismaticJointFrame->setJointPos(state(offset+1));
-  mPrismaticJointFrame->setJointVel(state(offset+2));
+  CartesianJointFrame<1>::VectorN v;
+  state.readSubState(v);
+  mPrismaticJointFrame->setJointPos(v(1));
+  state.readSubState(v);
+  mPrismaticJointFrame->setJointVel(v(1));
 }
 
 void
-PrismaticJoint::getState(Vector& state, unsigned offset) const
+PrismaticJoint::getState(StateStream& state) const
 {
-  state(offset+1) = mPrismaticJointFrame->getJointPos();
-  state(offset+2) = mPrismaticJointFrame->getJointVel();
+  state.writeSubState(mPrismaticJointFrame->getJointPos());
+  state.writeSubState(mPrismaticJointFrame->getJointVel());
 }
 
 void
-PrismaticJoint::getStateDeriv(Vector& state, unsigned offset)
+PrismaticJoint::getStateDeriv(StateStream& stateDeriv)
 {
-  state(offset+1) = mPrismaticJointFrame->getJointVel();
-  state(offset+2) = mPrismaticJointFrame->getJointVelDot()(1);
+  stateDeriv.writeSubState(mPrismaticJointFrame->getJointVel());
+  stateDeriv.writeSubState(mPrismaticJointFrame->getJointVelDot());
 }
 
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/PrismaticJoint.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/PrismaticJoint.h	2005-12-28 23:51:39 UTC (rev 139)
+++ trunk/OpenFDM/src/OpenFDM/PrismaticJoint.h	2005-12-29 14:43:32 UTC (rev 140)
@@ -85,9 +85,9 @@
 
   /** Methods for the OpenFDM::Part.
    */
-  virtual void setState(const Vector& state, unsigned offset);
-  virtual void getState(Vector& state, unsigned offset) const;
-  virtual void getStateDeriv(Vector& state, unsigned offset);
+  virtual void setState(const StateStream& state);
+  virtual void getState(StateStream& state) const;
+  virtual void getStateDeriv(StateStream& stateDeriv);
 
   /** The direct joint interaction force
    */

Modified: trunk/OpenFDM/src/OpenFDM/RevoluteActuator.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RevoluteActuator.cpp	2005-12-28 23:51:39 UTC (rev 139)
+++ trunk/OpenFDM/src/OpenFDM/RevoluteActuator.cpp	2005-12-29 14:43:32 UTC (rev 140)
@@ -128,24 +128,27 @@
 }
 
 void
-RevoluteActuator::setState(const Vector& state, unsigned offset)
+RevoluteActuator::setState(const StateStream& state)
 {
-  mRevoluteActuatorFrame->setJointPos(state(offset+1));
-  mRevoluteActuatorFrame->setJointVel(state(offset+2));
+  CartesianActuatorFrame<1>::VectorN v;
+  state.readSubState(v);
+  mRevoluteActuatorFrame->setJointPos(v(1));
+  state.readSubState(v);
+  mRevoluteActuatorFrame->setJointVel(v(1));
 }
 
 void
-RevoluteActuator::getState(Vector& state, unsigned offset) const
+RevoluteActuator::getState(StateStream& state) const
 {
-  state(offset+1) = mRevoluteActuatorFrame->getJointPos();
-  state(offset+2) = mRevoluteActuatorFrame->getJointVel();
+  state.writeSubState(mRevoluteActuatorFrame->getJointPos());
+  state.writeSubState(mRevoluteActuatorFrame->getJointVel());
 }
 
 void
-RevoluteActuator::getStateDeriv(Vector& state, unsigned offset)
+RevoluteActuator::getStateDeriv(StateStream& stateDeriv)
 {
-  state(offset+1) = mRevoluteActuatorFrame->getJointVel();
-  state(offset+2) = mRevoluteActuatorFrame->getJointVelDot()(1);
+  stateDeriv.writeSubState(mRevoluteActuatorFrame->getJointVel());
+  stateDeriv.writeSubState(mRevoluteActuatorFrame->getJointVelDot());
 }
 
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/RevoluteActuator.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RevoluteActuator.h	2005-12-28 23:51:39 UTC (rev 139)
+++ trunk/OpenFDM/src/OpenFDM/RevoluteActuator.h	2005-12-29 14:43:32 UTC (rev 140)
@@ -83,9 +83,9 @@
 
   /** Methods for the OpenFDM::Part.
    */
-  virtual void setState(const Vector& state, unsigned offset);
-  virtual void getState(Vector& state, unsigned offset) const;
-  virtual void getStateDeriv(Vector& state, unsigned offset);
+  virtual void setState(const StateStream& state);
+  virtual void getState(StateStream& state) const;
+  virtual void getStateDeriv(StateStream& state);
 
   /// The maximum movement of the controler
   real_type mMaxVel;

Modified: trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp	2005-12-28 23:51:39 UTC (rev 139)
+++ trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp	2005-12-29 14:43:32 UTC (rev 140)
@@ -112,24 +112,27 @@
 }
 
 void
-RevoluteJoint::setState(const Vector& state, unsigned offset)
+RevoluteJoint::setState(const StateStream& state)
 {
-  mRevoluteJointFrame->setJointPos(state(offset+1));
-  mRevoluteJointFrame->setJointVel(state(offset+2));
+  CartesianJointFrame<1>::VectorN v;
+  state.readSubState(v);
+  mRevoluteJointFrame->setJointPos(v(1));
+  state.readSubState(v);
+  mRevoluteJointFrame->setJointVel(v(1));
 }
 
 void
-RevoluteJoint::getState(Vector& state, unsigned offset) const
+RevoluteJoint::getState(StateStream& state) const
 {
-  state(offset+1) = mRevoluteJointFrame->getJointPos();
-  state(offset+2) = mRevoluteJointFrame->getJointVel();
+  state.writeSubState(mRevoluteJointFrame->getJointPos());
+  state.writeSubState(mRevoluteJointFrame->getJointVel());
 }
 
 void
-RevoluteJoint::getStateDeriv(Vector& state, unsigned offset)
+RevoluteJoint::getStateDeriv(StateStream& stateDeriv)
 {
-  state(offset+1) = mRevoluteJointFrame->getJointVel();
-  state(offset+2) = mRevoluteJointFrame->getJointVelDot()(1);
+  stateDeriv.writeSubState(mRevoluteJointFrame->getJointVel());
+  stateDeriv.writeSubState(mRevoluteJointFrame->getJointVelDot());
 }
 
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/RevoluteJoint.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RevoluteJoint.h	2005-12-28 23:51:39 UTC (rev 139)
+++ trunk/OpenFDM/src/OpenFDM/RevoluteJoint.h	2005-12-29 14:43:32 UTC (rev 140)
@@ -85,9 +85,9 @@
 
   /** Methods for the OpenFDM::Part.
    */
-  virtual void setState(const Vector& state, unsigned offset);
-  virtual void getState(Vector& state, unsigned offset) const;
-  virtual void getStateDeriv(Vector& state, unsigned offset);
+  virtual void setState(const StateStream& state);
+  virtual void getState(StateStream& state) const;
+  virtual void getStateDeriv(StateStream& stateDeriv);
 
   /** The direct joint interaction force
    */

Added: trunk/OpenFDM/src/OpenFDM/StateStream.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/StateStream.h	2005-12-28 23:51:39 UTC (rev 139)
+++ trunk/OpenFDM/src/OpenFDM/StateStream.h	2005-12-29 14:43:32 UTC (rev 140)
@@ -0,0 +1,107 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_StateStream_H
+#define OpenFDM_StateStream_H
+
+#include "Vector.h"
+#include "Matrix.h"
+
+namespace OpenFDM {
+
+class StateStream {
+public:
+  StateStream(unsigned nStates) : mOffset(0), mState(nStates)
+  { }
+  StateStream(const Vector& state) : mOffset(0), mState(state)
+  { }
+  ~StateStream(void)
+  {
+    OpenFDMAssert(mOffset == rows(mState));
+  }
+
+  void setState(const Vector& state)
+  { mState = state; mOffset = 0; }
+  const Vector& getState(void) const
+  {
+    OpenFDMAssert(mOffset == rows(mState));
+    return mState;
+  }
+
+  /// Reset the offset to 0
+  void reset(void)
+  { mOffset = 0; }
+
+  /// Debgging functions
+  bool isAtEnd(void) const
+  { return mOffset == rows(mState); }
+  bool stillSpaceFor(unsigned nStates) const
+  { return mOffset + nStates <= rows(mState); }
+
+  OpenFDM_FORCE_INLINE
+  void readSubState(real_type& value) const
+  {
+    OpenFDMAssert(mOffset + 1 <= rows(mState));
+    value = mState(++mOffset);
+  }
+  template<typename Impl, LinAlg::size_type m, LinAlg::size_type n>
+  OpenFDM_FORCE_INLINE
+  void readSubState(LinAlg::MatrixLValue<Impl,m,n>& value) const
+  {
+    LinAlg::size_type r = rows(value);
+    LinAlg::size_type c = cols(value);
+    OpenFDMAssert(mOffset + r*c <= rows(mState));
+    Impl& valueImpl = value.asImpl();
+    for (LinAlg::size_type j = 1; j <= c; ++j) 
+      for (LinAlg::size_type i = 1; i <= r; ++i)
+        valueImpl(i, j) = mState(++mOffset);
+  }
+  template<typename Impl, LinAlg::size_type n>
+  OpenFDM_FORCE_INLINE
+  void readSubState(LinAlg::MatrixLValue<Impl,n,1>& value) const
+  {
+    LinAlg::size_type r = rows(value);
+    OpenFDMAssert(mOffset + r <= rows(mState));
+    Impl& valueImpl = value.asImpl();
+    for (LinAlg::size_type i = 1; i <= r; ++i)
+      valueImpl(i) = mState(++mOffset);
+  }
+
+  OpenFDM_FORCE_INLINE
+  void writeSubState(real_type value)
+  {
+    OpenFDMAssert(mOffset + 1 <= rows(mState));
+    mState(++mOffset) = value;
+  }
+  template<typename Impl, LinAlg::size_type m, LinAlg::size_type n>
+  OpenFDM_FORCE_INLINE
+  void writeSubState(const LinAlg::MatrixRValue<Impl,m,n>& value)
+  {
+    LinAlg::size_type r = rows(value);
+    LinAlg::size_type c = cols(value);
+    OpenFDMAssert(mOffset + r*c <= rows(mState));
+    const Impl& valueImpl = value.asImpl();
+    for (LinAlg::size_type j = 1; j <= c; ++j) 
+      for (LinAlg::size_type i = 1; i <= r; ++i)
+        mState(++mOffset) = valueImpl(i, j);
+  }
+  template<typename Impl, LinAlg::size_type n>
+  OpenFDM_FORCE_INLINE
+  void writeSubState(const LinAlg::MatrixRValue<Impl,n,1>& value)
+  {
+    LinAlg::size_type r = rows(value);
+    OpenFDMAssert(mOffset + r <= rows(mState));
+    const Impl& valueImpl = value.asImpl();
+    for (LinAlg::size_type i = 1; i <= r; ++i)
+      mState(++mOffset) = valueImpl(i);
+  }
+
+private:
+  mutable unsigned mOffset;
+  Vector mState;
+};
+
+} // namespace OpenFDM
+
+#endif


Property changes on: trunk/OpenFDM/src/OpenFDM/StateStream.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/OpenFDM/src/OpenFDM/System.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/System.cpp	2005-12-28 23:51:39 UTC (rev 139)
+++ trunk/OpenFDM/src/OpenFDM/System.cpp	2005-12-29 14:43:32 UTC (rev 140)
@@ -6,6 +6,7 @@
 #include "Model.h"
 #include "Property.h"
 #include "Vector.h"
+#include "Environment.h"
 #include "LogStream.h"
 #include "ODESolver.h"
 #include "ExplicitEuler.h"
@@ -13,8 +14,6 @@
 #include "Newton.h"
 #include "System.h"
 
-#include "ModelVisitor.h"
-
 namespace OpenFDM {
 
 System::System(const std::string& name) :
@@ -134,37 +133,6 @@
   return true;
 }
 
-class StateGetModelVisitor : public ModelVisitor {
-public:
-  StateGetModelVisitor(unsigned nStates) : mState(nStates), mOffset(0u)
-  {}
-  virtual void apply(Model& model)
-  {
-    OpenFDMAssert(mOffset + model.getNumContinousStates() <= mState.size());
-    model.getState(mState, mOffset);
-    mOffset += model.getNumContinousStates();
-  }
-
-  virtual void apply(ModelGroup& modelGroup)
-  {
-    traverse(modelGroup);
-  }
-  virtual void apply(Interact& interact)
-  {
-//     traverse(interact);
-  }
-  virtual void apply(MultiBodySystem& multiBodySystem)
-  {
-    traverse(multiBodySystem);
-  }
-
-  const Vector& getState(void) const
-  { return mState; }
-private:
-  Vector mState;
-  unsigned mOffset;
-};
-
 bool
 System::simulate(real_type tEnd)
 {
@@ -175,8 +143,9 @@
   // outside this method, we need to read that state and set it into the
   // timestepper. The timestepper needs to take care if it needs to be
   // restarted. So just set it here.
-  Vector state(getNumContinousStates());
-  getState(state, 0);
+  StateStream stateStream(getNumContinousStates());
+  getState(stateStream);
+  Vector state = stateStream.getState();
   // Exact check is currect here, the user does not have to fiddle with
   // the state during simulation, if the state changes despite of that,
   // Just spend that extra effort.
@@ -309,10 +278,11 @@
   output(taskInfo);
 
   // Get the current state
-  Vector state(getNumContinousStates());
-  getState(state, 0);
+  StateStream stateStream(getNumContinousStates());
+  getState(stateStream);
+  Vector state = stateStream.getState();
 
-  Vector trimState = state;
+  Vector trimState = stateStream.getState();
   // Buld up the trim function
   TrimFunction trimFunction(*this, trimState);
 
@@ -321,9 +291,11 @@
   real_type rtol = 1e-8;
   bool ret = GaussNewton(trimFunction, getTime(), trimState, atol, rtol);
   if (ret) {
-    setState(trimState, 0);
+    stateStream.setState(trimState);
+    setState(stateStream);
   } else {
-    setState(state, 0);
+    stateStream.setState(state);
+    setState(stateStream);
   }
 
   return ret;

Modified: trunk/OpenFDM/src/OpenFDM/TransferFunction.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/TransferFunction.cpp	2005-12-28 23:51:39 UTC (rev 139)
+++ trunk/OpenFDM/src/OpenFDM/TransferFunction.cpp	2005-12-29 14:43:32 UTC (rev 140)
@@ -162,15 +162,15 @@
 }
 
 void
-DiscreteTransferFunction::setDiscreteState(const Vector& state, unsigned offset)
+DiscreteTransferFunction::setDiscreteState(const StateStream& state)
 {
-  mState = state(Range(offset+1, offset+rows(mState)));
+  state.readSubState(mState);
 }
 
 void
-DiscreteTransferFunction::getDiscreteState(Vector& state, unsigned offset) const
+DiscreteTransferFunction::getDiscreteState(StateStream& state) const
 {
-  state(Range(offset+1, offset+rows(mState))) = mState;
+  state.writeSubState(mState);
 }
 
 const real_type&

Modified: trunk/OpenFDM/src/OpenFDM/TransferFunction.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/TransferFunction.h	2005-12-28 23:51:39 UTC (rev 139)
+++ trunk/OpenFDM/src/OpenFDM/TransferFunction.h	2005-12-29 14:43:32 UTC (rev 140)
@@ -39,8 +39,8 @@
   virtual void update(const TaskInfo& taskInfo);
 
   /// This one can have discrete states
-  virtual void setDiscreteState(const Vector& state, unsigned offset);
-  virtual void getDiscreteState(Vector& state, unsigned offset) const;
+  virtual void setDiscreteState(const StateStream& state);
+  virtual void getDiscreteState(StateStream& state) const;
 
   const real_type& getOutput(void) const;
 



From frohlich at berlios.de  Thu Dec 29 17:12:38 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Thu, 29 Dec 2005 17:12:38 +0100
Subject: [OpenFDM-svn] r141 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200512291612.jBTGCcAn005844@sheep.berlios.de>

Author: frohlich
Date: 2005-12-29 17:12:34 +0100 (Thu, 29 Dec 2005)
New Revision: 141

Modified:
   trunk/OpenFDM/src/OpenFDM/Model.cpp
   trunk/OpenFDM/src/OpenFDM/Model.h
Log:
Remove obsolete function


Modified: trunk/OpenFDM/src/OpenFDM/Model.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Model.cpp	2005-12-29 14:43:32 UTC (rev 140)
+++ trunk/OpenFDM/src/OpenFDM/Model.cpp	2005-12-29 16:12:34 UTC (rev 141)
@@ -217,23 +217,6 @@
   return mOutputPorts[i]->getName();
 }
 
-bool
-Model::dependsDirectOn(const Model* const model) const
-{
-  // If we have no direct feedthrought flag, we cannot depend on any input
-  // port directly.
-  if (!getDirectFeedThrough())
-    return false;
-  // Check if the given model is the source of any input property.
-  std::vector<SharedPtr<Port> >::const_iterator it = mInputPorts.begin();
-  while (it != mInputPorts.end()) {
-    if (model == (*it)->getProperty().getObject())
-      return true;
-    ++it;
-  }
-  return false;
-}
-
 void
 Model::setNumInputPorts(unsigned num)
 {

Modified: trunk/OpenFDM/src/OpenFDM/Model.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Model.h	2005-12-29 14:43:32 UTC (rev 140)
+++ trunk/OpenFDM/src/OpenFDM/Model.h	2005-12-29 16:12:34 UTC (rev 141)
@@ -121,8 +121,6 @@
   Port* getOutputPort(const std::string& name);
   const std::string& getOutputPortName(unsigned i) const;
 
-  bool dependsDirectOn(const Model* const model) const;
-
 protected:
   void setNumContinousStates(unsigned numContinousStates);
   void setNumDiscreteStates(unsigned numDiscreteStates);



From frohlich at berlios.de  Thu Dec 29 17:33:05 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Thu, 29 Dec 2005 17:33:05 +0100
Subject: [OpenFDM-svn] r142 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200512291633.jBTGX5XW007799@sheep.berlios.de>

Author: frohlich
Date: 2005-12-29 17:32:59 +0100 (Thu, 29 Dec 2005)
New Revision: 142

Modified:
   trunk/OpenFDM/src/OpenFDM/Frame.cpp
   trunk/OpenFDM/src/OpenFDM/Frame.h
   trunk/OpenFDM/src/OpenFDM/MobileRootJoint.cpp
   trunk/OpenFDM/src/OpenFDM/PrismaticJoint.cpp
   trunk/OpenFDM/src/OpenFDM/RevoluteActuator.cpp
   trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp
Log:
Make parent/child checks a bit more readable and flexible


Modified: trunk/OpenFDM/src/OpenFDM/Frame.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Frame.cpp	2005-12-29 16:12:34 UTC (rev 141)
+++ trunk/OpenFDM/src/OpenFDM/Frame.cpp	2005-12-29 16:32:59 UTC (rev 142)
@@ -77,6 +77,20 @@
 }
 
 bool
+Frame::isParentFrameOf(const Frame* const frame) const
+{
+  return isDirectParentFrameOf(frame) ||
+    (frame && isParentFrameOf(frame->mParentFrame));
+}
+
+bool
+Frame::isChildFrameOf(const Frame* const frame) const
+{
+  return isDirectChildFrameOf(frame) ||
+    (mParentFrame && mParentFrame->isChildFrameOf(frame));
+}
+
+bool
 Frame::addChildFrame(Frame* child)
 {
   if (!child) {

Modified: trunk/OpenFDM/src/OpenFDM/Frame.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Frame.h	2005-12-29 16:12:34 UTC (rev 141)
+++ trunk/OpenFDM/src/OpenFDM/Frame.h	2005-12-29 16:32:59 UTC (rev 142)
@@ -70,15 +70,34 @@
   /// Return the parent frame.
   const Frame* getParentFrame(void) const
   { return mParentFrame; }
-  /// Return true if the given frame is the parent frame.
-  /// FIXME: it will read more intuitive if it is called
-  /// this->isParentFrameOf(that)
-  bool isParentFrame(const Frame* frame) const
-  { return frame == mParentFrame; }
   /// True if the current frame has a parent frame.
   bool hasParent(void) const
   { return getParentFrame(); }
 
+  /// Return true if this Frame is the direct parent Frame of the Frame given
+  /// in the argument frame.
+  /// That means it reads:
+  ///  this->isDirectParentFrameOf(frame)
+  bool isDirectParentFrameOf(const Frame* const frame) const
+  { return frame && this == frame->mParentFrame; }
+  /// Return true if this Frame is a parent Frame of the Frame given
+  /// in the argument frame. It does not need to be the direct parent.
+  /// That means it reads:
+  ///  this->isParentFrameOf(frame)
+  bool isParentFrameOf(const Frame* const frame) const;
+
+  /// Return true if this Frame is a direct child Frame of the Frame given
+  /// in the argument frame.
+  /// That means it reads:
+  ///  this->isDirectChildFrameOf(frame)
+  bool isDirectChildFrameOf(const Frame* const frame) const
+  { return frame && frame == mParentFrame; }
+  /// Return true if this Frame is a child Frame of the Frame given
+  /// in the argument frame. It does not need to be a direct child.
+  /// That means it reads:
+  ///  this->isChildFrameOf(frame)
+  bool isChildFrameOf(const Frame* const frame) const;
+
   /// Adds the given frame to the list of child frames.
   /// returns true if that completed sucessfully.
   bool addChildFrame(Frame* child);

Modified: trunk/OpenFDM/src/OpenFDM/MobileRootJoint.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/MobileRootJoint.cpp	2005-12-29 16:12:34 UTC (rev 141)
+++ trunk/OpenFDM/src/OpenFDM/MobileRootJoint.cpp	2005-12-29 16:32:59 UTC (rev 142)
@@ -70,7 +70,7 @@
   rigidBody = getInboardBody();
   if (rigidBody) {
     Frame* frame = rigidBody->getFrame();
-    if (frame && !frame->isParentFrame(mFrame))
+    if (frame && !frame->isDirectParentFrameOf(mFrame))
       frame->addChildFrame(mFrame);
   } else {
     Environment* environment = getEnvironment();

Modified: trunk/OpenFDM/src/OpenFDM/PrismaticJoint.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/PrismaticJoint.cpp	2005-12-29 16:12:34 UTC (rev 141)
+++ trunk/OpenFDM/src/OpenFDM/PrismaticJoint.cpp	2005-12-29 16:32:59 UTC (rev 142)
@@ -49,7 +49,7 @@
     getOutboardBody()->setFrame(mPrismaticJointFrame);
   }
   outFrame = getOutboardBody()->getFrame();
-  if (!outFrame->isParentFrame(inFrame)) {
+  if (!outFrame->isDirectChildFrameOf(inFrame)) {
     inFrame->addChildFrame(mPrismaticJointFrame);
   }
 }

Modified: trunk/OpenFDM/src/OpenFDM/RevoluteActuator.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RevoluteActuator.cpp	2005-12-29 16:12:34 UTC (rev 141)
+++ trunk/OpenFDM/src/OpenFDM/RevoluteActuator.cpp	2005-12-29 16:32:59 UTC (rev 142)
@@ -55,7 +55,7 @@
     getOutboardBody()->setFrame(mRevoluteActuatorFrame);
   }
   outFrame = getOutboardBody()->getFrame();
-  if (!outFrame->isParentFrame(inFrame)) {
+  if (!outFrame->isDirectChildFrameOf(inFrame)) {
     inFrame->addChildFrame(mRevoluteActuatorFrame);
   }
 }

Modified: trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp	2005-12-29 16:12:34 UTC (rev 141)
+++ trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp	2005-12-29 16:32:59 UTC (rev 142)
@@ -49,7 +49,7 @@
     getOutboardBody()->setFrame(mRevoluteJointFrame);
   }
   outFrame = getOutboardBody()->getFrame();
-  if (!outFrame->isParentFrame(inFrame)) {
+  if (!outFrame->isDirectChildFrameOf(inFrame)) {
     inFrame->addChildFrame(mRevoluteJointFrame);
   }
 }



From frohlich at berlios.de  Fri Dec 30 09:02:15 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Fri, 30 Dec 2005 09:02:15 +0100
Subject: [OpenFDM-svn] r143 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200512300802.jBU82F41019801@sheep.berlios.de>

Author: frohlich
Date: 2005-12-30 09:02:07 +0100 (Fri, 30 Dec 2005)
New Revision: 143

Modified:
   trunk/OpenFDM/src/OpenFDM/Joint.cpp
   trunk/OpenFDM/src/OpenFDM/Joint.h
   trunk/OpenFDM/src/OpenFDM/MobileRootJoint.cpp
   trunk/OpenFDM/src/OpenFDM/MobileRootJoint.h
   trunk/OpenFDM/src/OpenFDM/Model.cpp
   trunk/OpenFDM/src/OpenFDM/Model.h
   trunk/OpenFDM/src/OpenFDM/ModelGroup.cpp
   trunk/OpenFDM/src/OpenFDM/ModelGroup.h
   trunk/OpenFDM/src/OpenFDM/MultiBodySystem.cpp
   trunk/OpenFDM/src/OpenFDM/MultiBodySystem.h
Log:
Include the multibody system structure into the
Model scheduling stuff


Modified: trunk/OpenFDM/src/OpenFDM/Joint.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Joint.cpp	2005-12-29 16:32:59 UTC (rev 142)
+++ trunk/OpenFDM/src/OpenFDM/Joint.cpp	2005-12-30 08:02:07 UTC (rev 143)
@@ -25,4 +25,67 @@
 {
 }
 
+const Joint*
+Joint::toJoint(void) const
+{
+  return this;
+}
+
+Joint*
+Joint::toJoint(void)
+{
+  return this;
+}
+
+void
+Joint::output(const TaskInfo& taskInfo)
+{
+  RigidBody* outboardBody = getOutboardBody();
+  if (!outboardBody)
+    return;
+  
+  Log(ArtBody, Debug) << "Preparing Body \""
+                      << outboardBody->getName() << "\" through joint \""
+                      << getName() << "\"" << endl;
+  
+  outboardBody->computeArtValues();
+}
+
+void
+Joint::interactWith(RigidBody* rigidBody)
+{
+  // HMmMm
+  if (rigidBody != getInboardBody())
+    return;
+  
+  RigidBody* outboardBody = getOutboardBody();
+  if (!outboardBody)
+    return;
+  
+  Log(ArtBody, Debug) << "Contributing articulation from \""
+                      << outboardBody->getName() << "\" through joint \""
+                      << getName() << "\"" << endl;
+  
+  // We need the articulated inertia and force from the outboard body.
+  SpatialInertia I;
+  Vector6 F;
+  
+  // Apply the joint degrees of freedom to that.
+  // If there was an error, (something was singular ???)
+  // just ignore that part. FIXME, ist this ok????
+  jointArticulation(I, F, outboardBody->getArtInertia(),
+                    outboardBody->getArtForce());
+  
+  Log(ArtBody, Debug3) << "Outboard Articulated values past joint "
+                       << "projection: Force:\n" << trans(F)
+                       << "\nInertia\n" << I << endl;
+  
+  // Contribute the transformed values to the parent.
+  if (!rigidBody)
+    return;
+  Frame* frame = outboardBody->getFrame();
+  rigidBody->contributeInertia(frame->inertiaToParent(I));
+  rigidBody->contributeForce(frame->forceToParent(F));
+}
+
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/Joint.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Joint.h	2005-12-29 16:32:59 UTC (rev 142)
+++ trunk/OpenFDM/src/OpenFDM/Joint.h	2005-12-30 08:02:07 UTC (rev 143)
@@ -18,57 +18,27 @@
 
 namespace OpenFDM {
 
+/// FIXME: joint's should be lockable, which means trylock == true and
+/// velocity small enough - keep position ...
+
 class Joint
   : public Interact {
 public:
   Joint(const std::string& name);
   virtual ~Joint(void);
 
-  /// FIXME: joint's should be lockable, which means trylock == true and
-  /// velocity small enough - keep position ...
+  virtual const Joint* toJoint(void) const;
+  virtual Joint* toJoint(void);
 
+  virtual void output(const TaskInfo& taskInfo);
+
   RigidBody* getOutboardBody(void)
   { return getParentRigidBody(0); }
   RigidBody* getInboardBody(void)
   { return getParentRigidBody(1); }
 
-  virtual void interactWith(RigidBody* rigidBody)
-  {
-    // HMmMm
-    if (rigidBody != getInboardBody())
-      return;
+  virtual void interactWith(RigidBody* rigidBody);
 
-    RigidBody* outboardBody = getOutboardBody();
-    if (!outboardBody)
-      return;
-
-    outboardBody->computeArtValues();
-    Log(ArtBody, Debug) << "Contributing articulation from \""
-                        << outboardBody->getName() << "\" through joint \""
-                        << getName() << "\"" << endl;
-
-    // We need the articulated inertia and force from the outboard body.
-    SpatialInertia I;
-    Vector6 F;
-
-    // Apply the joint degrees of freedom to that.
-    // If there was an error, (something was singular ???)
-    // just ignore that part. FIXME, ist this ok????
-    jointArticulation(I, F, outboardBody->getArtInertia(),
-                      outboardBody->getArtForce());
-
-    Log(ArtBody, Debug3) << "Outboard Articulated values past joint "
-                         << "projection: Force:\n" << trans(F)
-                         << "\nInertia\n" << I << endl;
-
-    // Contribute the transformed values to the parent.
-    if (!rigidBody)
-      return;
-    Frame* frame = outboardBody->getFrame();
-    rigidBody->contributeInertia(frame->inertiaToParent(I));
-    rigidBody->contributeForce(frame->forceToParent(F));
-  }
-
   // Joint slot ...
   virtual void jointArticulation(SpatialInertia& artI, Vector6& artF,
                                  const SpatialInertia& outI,

Modified: trunk/OpenFDM/src/OpenFDM/MobileRootJoint.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/MobileRootJoint.cpp	2005-12-29 16:32:59 UTC (rev 142)
+++ trunk/OpenFDM/src/OpenFDM/MobileRootJoint.cpp	2005-12-30 08:02:07 UTC (rev 143)
@@ -30,6 +30,18 @@
 {
 }
 
+const MobileRootJoint*
+MobileRootJoint::toMobileRootJoint(void) const
+{
+  return this;
+}
+
+MobileRootJoint*
+MobileRootJoint::toMobileRootJoint(void)
+{
+  return this;
+}
+
 bool
 MobileRootJoint::init(void)
 {
@@ -55,6 +67,20 @@
 }
 
 void
+MobileRootJoint::output(const TaskInfo& taskInfo)
+{
+  RigidBody* outboardBody = getOutboardBody();
+  if (!outboardBody)
+    return;
+  
+  Log(ArtBody, Debug) << "Computing mobile root accelerations for joint \""
+                      << getName() << "\"" << endl;
+  
+  outboardBody->computeArtValues();
+  interactWith(getInboardBody());
+}
+
+void
 MobileRootJoint::recheckTopology(void)
 {
   // Hmm, works for the first cut, but rethink what happens with strange

Modified: trunk/OpenFDM/src/OpenFDM/MobileRootJoint.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/MobileRootJoint.h	2005-12-29 16:32:59 UTC (rev 142)
+++ trunk/OpenFDM/src/OpenFDM/MobileRootJoint.h	2005-12-30 08:02:07 UTC (rev 143)
@@ -26,7 +26,11 @@
   MobileRootJoint(const std::string& name);
   virtual ~MobileRootJoint(void);
 
+  virtual const MobileRootJoint* toMobileRootJoint(void) const;
+  virtual MobileRootJoint* toMobileRootJoint(void);
+
   virtual bool init(void);
+  virtual void output(const TaskInfo& taskInfo);
 
   virtual void recheckTopology(void);
 

Modified: trunk/OpenFDM/src/OpenFDM/Model.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Model.cpp	2005-12-29 16:32:59 UTC (rev 142)
+++ trunk/OpenFDM/src/OpenFDM/Model.cpp	2005-12-30 08:02:07 UTC (rev 143)
@@ -73,6 +73,30 @@
   return 0;
 }
 
+const Joint*
+Model::toJoint(void) const
+{
+  return 0;
+}
+
+Joint*
+Model::toJoint(void)
+{
+  return 0;
+}
+
+const MobileRootJoint*
+Model::toMobileRootJoint(void) const
+{
+  return 0;
+}
+
+MobileRootJoint*
+Model::toMobileRootJoint(void)
+{
+  return 0;
+}
+
 bool
 Model::init(void)
 {

Modified: trunk/OpenFDM/src/OpenFDM/Model.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Model.h	2005-12-29 16:32:59 UTC (rev 142)
+++ trunk/OpenFDM/src/OpenFDM/Model.h	2005-12-30 08:02:07 UTC (rev 143)
@@ -28,6 +28,8 @@
 
 class Input;
 class Output;
+class Joint;
+class MobileRootJoint;
 
 class ModelVisitor;
 
@@ -55,6 +57,12 @@
   virtual const Output* toOutput(void) const;
   virtual Output* toOutput(void);
 
+  virtual const Joint* toJoint(void) const;
+  virtual Joint* toJoint(void);
+
+  virtual const MobileRootJoint* toMobileRootJoint(void) const;
+  virtual MobileRootJoint* toMobileRootJoint(void);
+
   /// Called on each system initialization.
   virtual bool init(void);
   /// Called when the outputs need to be prepared for the next step.
@@ -88,6 +96,8 @@
   bool getDirectFeedThrough(void) const
   { return mDirectFeedThrough; }
 
+  /// Returns true if it needs to know the accelerations ...
+  /// FIXME: do that in a different way ...
   bool getMultiBodyAcceleration(void) const
   { return mMultiBodyAcceleration; }
 

Modified: trunk/OpenFDM/src/OpenFDM/ModelGroup.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/ModelGroup.cpp	2005-12-29 16:32:59 UTC (rev 142)
+++ trunk/OpenFDM/src/OpenFDM/ModelGroup.cpp	2005-12-30 08:02:07 UTC (rev 143)
@@ -301,8 +301,69 @@
 }
 
 bool
+ModelGroup::dependsOnMultiBody(Joint* joint1, Joint* joint2)
+{
+  return joint1->getOutboardBody() == joint2->getInboardBody();
+}
+
+bool
 ModelGroup::appendDependecies(const Model* firstModel, Model* model, ModelList& newList)
 {
+  Joint* joint = model->toJoint();
+  if (joint) {
+    for (;;) {
+      ModelList::iterator it = mModels.begin();
+      while (it != mModels.end()) {
+        Joint* joint2 = (*it)->toJoint();
+        if (joint2 && dependsOnMultiBody(joint, joint2))
+          break;
+        ++it;
+      }
+      if (it == mModels.end())
+        break;
+
+      // We need to store that one here since the iterator possibly invalidates
+      // during the next append dependency call
+      SharedPtr<Model> tmpModel = *it;
+      mModels.erase(it);
+      
+      // Now recurse into that model.
+      if (!appendDependecies(firstModel, tmpModel, newList))
+        return false;
+ 
+      // Finally, past all the dependent models are already in the list,
+      // push that one in question.
+      newList.push_back(tmpModel);
+    }
+  }
+
+  // Special case: if we depend on the accelerations, like acceleration
+  // sensors, we depend on the mobile root ...
+  // Well a bit croase now, but until there is something better ...
+  if (model->getMultiBodyAcceleration()) {
+    ModelList::iterator it = mModels.begin();
+    while (it != mModels.end()) {
+      MobileRootJoint* joint = (*it)->toMobileRootJoint();
+      if (joint)
+        break;
+      ++it;
+    }
+    if (it != mModels.end()) {
+      // We need to store that one here since the iterator possibly invalidates
+      // during the next append dependency call
+      SharedPtr<Model> tmpModel = *it;
+      mModels.erase(it);
+      
+      // Now recurse into that model.
+      if (!appendDependecies(firstModel, tmpModel, newList))
+        return false;
+      
+      // Finally, past all the dependent models are already in the list,
+      // push that one in question.
+      newList.push_back(tmpModel);
+    }
+  }
+
   // If the model in question does not have dependencies, stop.
   if (!model->getDirectFeedThrough())
     return true;

Modified: trunk/OpenFDM/src/OpenFDM/ModelGroup.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/ModelGroup.h	2005-12-29 16:32:59 UTC (rev 142)
+++ trunk/OpenFDM/src/OpenFDM/ModelGroup.h	2005-12-30 08:02:07 UTC (rev 143)
@@ -71,6 +71,10 @@
 
   /// Helper functions to sort the models according their dependencies
   static bool dependsOn(Port* inputPort, Model* model);
+  /// return true if interact1 depends on interact2 which means that
+  /// interact1 is higher in the tree of multibody models
+  static bool dependsOnMultiBody(Joint* joint1, Joint* joint2);
+
   bool appendDependecies(const Model* firstModel, Model* model,
                          ModelList& newList);
   /// Sorts the models depending their dependencies

Modified: trunk/OpenFDM/src/OpenFDM/MultiBodySystem.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/MultiBodySystem.cpp	2005-12-29 16:32:59 UTC (rev 142)
+++ trunk/OpenFDM/src/OpenFDM/MultiBodySystem.cpp	2005-12-30 08:02:07 UTC (rev 143)
@@ -36,32 +36,17 @@
   visitor.apply(*this);
 }
 
-bool
-MultiBodySystem::init(void)
-{
-  return ModelGroup::init();
-}
+// bool
+// MultiBodySystem::init(void)
+// {
+//   return true;
+// }
 
-void
-MultiBodySystem::output(const TaskInfo& taskInfo)
-{
-  // Hmm, just works now ... FIXME
-  ModelList::iterator it;
-  for (it = mModels.begin(); it != mModels.end(); ++it) {
-    if (!(*it)->getMultiBodyAcceleration())
-      (*it)->output(taskInfo);
-  }
+// void
+// MultiBodySystem::output(const TaskInfo& taskInfo)
+// {
+// }
 
-  // Compute forward dynamics, that is the articulated forces and inertia.
-  mMobileRootJoint->interactWith(mMobileRootJoint->getInboardBody());
-
-  // Hmm, just works now ... FIXME
-  for (it = mModels.begin(); it != mModels.end(); ++it) {
-    if ((*it)->getMultiBodyAcceleration())
-      (*it)->output(taskInfo);
-  }
-}
-
 void
 MultiBodySystem::addRigidBody(RigidBody* rigidBody)
 {

Modified: trunk/OpenFDM/src/OpenFDM/MultiBodySystem.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/MultiBodySystem.h	2005-12-29 16:32:59 UTC (rev 142)
+++ trunk/OpenFDM/src/OpenFDM/MultiBodySystem.h	2005-12-30 08:02:07 UTC (rev 143)
@@ -31,8 +31,8 @@
   /// Double dispatch helper for the multibody system visitor
 //   virtual void accept(ConstModelVisitor& visitor) const;
 
-  virtual bool init(void);
-  virtual void output(const TaskInfo& taskInfo);
+//   virtual bool init(void);
+//   virtual void output(const TaskInfo& taskInfo);
 
   /// Add a RigidBody to that MultiBodySystem
   void addRigidBody(RigidBody* rigidBody);



From frohlich at berlios.de  Fri Dec 30 18:38:09 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Fri, 30 Dec 2005 18:38:09 +0100
Subject: [OpenFDM-svn] r144 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200512301738.jBUHc91m017953@sheep.berlios.de>

Author: frohlich
Date: 2005-12-30 18:38:02 +0100 (Fri, 30 Dec 2005)
New Revision: 144

Modified:
   trunk/OpenFDM/src/OpenFDM/LogStream.h
   trunk/OpenFDM/src/OpenFDM/Logger.cpp
Log:
Also include warnings in the NDEBUG case


Modified: trunk/OpenFDM/src/OpenFDM/LogStream.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/LogStream.h	2005-12-30 08:02:07 UTC (rev 143)
+++ trunk/OpenFDM/src/OpenFDM/LogStream.h	2005-12-30 17:38:02 UTC (rev 144)
@@ -153,6 +153,21 @@
   }
 };
 
+template<Category category>
+class LogFactory<category,Warning> : public Logger {
+public:
+  typedef LogProxy<char> proxy_type;
+  static proxy_type
+  CreateInstance(void)
+  {
+    Logger* logger = Instance();
+    if (logger->enabled(category, Warning))
+      return proxy_type(logger->getStream());
+    else
+      return proxy_type(0);
+  }
+};
+
 #else /* defined(NDEBUG) */
 
 template<Category category, Priority priority>

Modified: trunk/OpenFDM/src/OpenFDM/Logger.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Logger.cpp	2005-12-30 08:02:07 UTC (rev 143)
+++ trunk/OpenFDM/src/OpenFDM/Logger.cpp	2005-12-30 17:38:02 UTC (rev 144)
@@ -32,7 +32,7 @@
 Logger::Logger(std::basic_ostream<char>* stream) :
   mStream(stream),
   mCategory(~0u),
-  mPriority(Log::Error)
+  mPriority(Log::Warning)
 {
   // Set some defaults from the environment
   unsigned value = atou(std::getenv("OPENFDM_DEBUG_PRIORITY"));



From frohlich at berlios.de  Sat Dec 31 10:56:04 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Sat, 31 Dec 2005 10:56:04 +0100
Subject: [OpenFDM-svn] r145 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200512310956.jBV9u46x020568@sheep.berlios.de>

Author: frohlich
Date: 2005-12-31 10:56:02 +0100 (Sat, 31 Dec 2005)
New Revision: 145

Modified:
   trunk/OpenFDM/src/OpenFDM/Logger.cpp
Log:
Revert default log level to Error.


Modified: trunk/OpenFDM/src/OpenFDM/Logger.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Logger.cpp	2005-12-30 17:38:02 UTC (rev 144)
+++ trunk/OpenFDM/src/OpenFDM/Logger.cpp	2005-12-31 09:56:02 UTC (rev 145)
@@ -32,7 +32,7 @@
 Logger::Logger(std::basic_ostream<char>* stream) :
   mStream(stream),
   mCategory(~0u),
-  mPriority(Log::Warning)
+  mPriority(Log::Error)
 {
   // Set some defaults from the environment
   unsigned value = atou(std::getenv("OPENFDM_DEBUG_PRIORITY"));



From frohlich at berlios.de  Sat Dec 31 10:56:58 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Sat, 31 Dec 2005 10:56:58 +0100
Subject: [OpenFDM-svn] r146 - in trunk/OpenFDM/src: JSBSim OpenFDM
Message-ID: <200512310956.jBV9uwUZ020593@sheep.berlios.de>

Author: frohlich
Date: 2005-12-31 10:56:49 +0100 (Sat, 31 Dec 2005)
New Revision: 146

Modified:
   trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
   trunk/OpenFDM/src/OpenFDM/AirSpring.cpp
   trunk/OpenFDM/src/OpenFDM/AirSpring.h
   trunk/OpenFDM/src/OpenFDM/Interact.cpp
   trunk/OpenFDM/src/OpenFDM/Interact.h
   trunk/OpenFDM/src/OpenFDM/Model.cpp
   trunk/OpenFDM/src/OpenFDM/Model.h
   trunk/OpenFDM/src/OpenFDM/ModelGroup.cpp
   trunk/OpenFDM/src/OpenFDM/ModelGroup.h
   trunk/OpenFDM/src/OpenFDM/PrismaticJoint.cpp
   trunk/OpenFDM/src/OpenFDM/PrismaticJoint.h
   trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp
   trunk/OpenFDM/src/OpenFDM/RevoluteJoint.h
Log:
Change the AirSpring to be a normal model instead
of something special. Adapt output scheduling.


Modified: trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
===================================================================
--- trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2005-12-31 09:56:02 UTC (rev 145)
+++ trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2005-12-31 09:56:49 UTC (rev 146)
@@ -461,7 +461,7 @@
 LegacyJSBSimReader::addInputModel(const std::string& name,
                                   const std::string& propName, real_type gain)
 {
-  Input* input = new Input(name);
+  Input* input = new Input(name + " Input");
   input->setInputName(propName);
   input->setInputGain(gain);
   addFCSModel(input);
@@ -475,7 +475,7 @@
                                    const std::string& name,
                                    const std::string& propName, real_type gain)
 {
-  Output* output = new Output(std::string(name) + " output");
+  Output* output = new Output(name + " Output");
   output->getInputPort(0)->connect(out);
   output->setOutputName(propName);
   output->setOutputGain(gain);
@@ -738,7 +738,7 @@
 {
   RigidBody* wheel = new RigidBody(name + " Wheel");
   InertiaMatrix wheelInertia(10, 0, 0, 100, 0, 10);
-  wheel->addInteract(new Mass("Wheel Inertia", SpatialInertia(wheelInertia, 50)));
+  wheel->addInteract(new Mass(name + " Wheel Inertia", SpatialInertia(wheelInertia, 50)));
   mVehicle->getMultiBodySystem()->addRigidBody(wheel);
   
   RevoluteJoint* wj = new RevoluteJoint(name + " Wheel Joint");
@@ -925,7 +925,7 @@
       // This is the movable part of the strut, doing the compression
       RigidBody* arm = new RigidBody(name + " Arm");
       mVehicle->getMultiBodySystem()->addRigidBody(arm);
-      arm->addInteract(new Mass("Strut Mass", inertiaFrom(Vector3(-1, 0, 0), SpatialInertia(200))));
+      arm->addInteract(new Mass(name + " Strut Mass", inertiaFrom(Vector3(-1, 0, 0), SpatialInertia(200))));
 
       // Connect that with a revolute joint to the main body
       RevoluteJoint* rj = new RevoluteJoint(name + " Arm Joint");
@@ -947,7 +947,12 @@
       aoDamp->setMaxCompression(maxCompr);
       aoDamp->setMinDamperConstant(minDamp);
       aoDamp->setMaxDamperConstant(maxDamp);
-      rj->setLineForce(aoDamp);
+      // That one reads the joint position and velocity ...
+      aoDamp->getInputPort(0)->connect(rj->getOutputPort(0));
+      aoDamp->getInputPort(1)->connect(rj->getOutputPort(1));
+      // ... and provides an output force
+      rj->getInputPort(0)->connect(aoDamp->getOutputPort(0));
+      mVehicle->getMultiBodySystem()->addModel(aoDamp);
 
       // Attach a wheel to that strut part.
       attachWheel(name, Vector3(-armLength, 0, 0), brake, numStr, wheelDiam,
@@ -957,6 +962,7 @@
       addOutputModel(port, "Gear " + numStr + " Compression",
                      "/gear/gear[" + numStr + "]/compression-rad");
 
+      /// FIXME add a retract joint ...
       port = lookupJSBExpression("gear/gear-pos-norm");
       addOutputModel(port, "Gear " + numStr + " Position",
                      "/gear/gear[" + numStr + "]/position-norm");
@@ -1036,7 +1042,7 @@
       // Now the compressible part of the strut
       RigidBody* arm = new RigidBody(name + " Strut");
       mVehicle->getMultiBodySystem()->addRigidBody(arm);
-      arm->addInteract(new Mass("Strut Mass", inertiaFrom(Vector3(0, 0, 1), SpatialInertia(200))));
+      arm->addInteract(new Mass(name + " Strut Mass", inertiaFrom(Vector3(0, 0, 1), SpatialInertia(200))));
 
       // This time it is a prismatic joint
       PrismaticJoint* pj = new PrismaticJoint(name + " Compress Joint");
@@ -1057,7 +1063,10 @@
       aoDamp->setMaxCompression(maxCompr);
       aoDamp->setMinDamperConstant(minDamp);
       aoDamp->setMaxDamperConstant(maxDamp);
-      pj->setLineForce(aoDamp);
+      pj->getInputPort(0)->connect(aoDamp->getOutputPort(0));
+      aoDamp->getInputPort(0)->connect(pj->getOutputPort(0));
+      aoDamp->getInputPort(1)->connect(pj->getOutputPort(1));
+      mVehicle->getMultiBodySystem()->addModel(aoDamp);
 
       // Attach a wheel to that strut part.
       attachWheel(name, Vector3::zeros(), brake, numStr, wheelDiam,
@@ -2074,6 +2083,7 @@
   port = new Port;
   port->setProperty(e);
   registerJSBExpression("velocities/mach-norm", port);
+  registerJSBExpression("velocities/mach", port);
 
   // Rotational rates wrt air.
   e = mAeroForce->getProperty("p");

Modified: trunk/OpenFDM/src/OpenFDM/AirSpring.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/AirSpring.cpp	2005-12-31 09:56:02 UTC (rev 145)
+++ trunk/OpenFDM/src/OpenFDM/AirSpring.cpp	2005-12-31 09:56:49 UTC (rev 146)
@@ -2,14 +2,14 @@
  *
  */
 
-#include "Model.h"
-#include "Vector.h"
+#include <string>
+
 #include "AirSpring.h"
 
 namespace OpenFDM {
 
 AirSpring::AirSpring(const std::string& name) :
-  LineForce(name),
+  Model(name),
   mPushPressure(2e5),
   mPullPressure(1e5),
   mArea(0),
@@ -19,18 +19,51 @@
   mMaxDamperConstant(0),
   mGamma(1.3)
 {
+  setDirectFeedThrough(true);
+
+  setNumInputPorts(2);
+  setInputPortName(0, "position");
+  setInputPortName(1, "velocity");
+  
+  setNumOutputPorts(1);
+  setOutputPort(0, "force", this, &AirSpring::getForce);
 }
 
 AirSpring::~AirSpring(void)
 {
 }
 
+bool
+AirSpring::init(void)
+{
+  if (!getInputPort(0)->isConnected()) {
+    Log(Model, Error) << "Initialization of AirSpring model \"" << getName()
+                      << "\" failed: Input port \"" << getInputPortName(0)
+                      << "\" is not connected!" << endl;
+    return false;
+  }
+  mPositionPort = getInputPort(0)->toRealPortHandle();
+
+  if (!getInputPort(1)->isConnected()) {
+    Log(Model, Error) << "Initialization of AirSpring model \"" << getName()
+                      << "\" failed: Input port \"" << getInputPortName(1)
+                      << "\" is not connected!" << endl;
+    return false;
+  }
+  mVelocityPort = getInputPort(1)->toRealPortHandle();
+
+  return true;
+}
+
 void
 AirSpring::output(const TaskInfo& taskInfo)
 {
+  real_type position = mPositionPort.getRealValue();
+  real_type vel = mVelocityPort.getRealValue();
+
   real_type maxDisp = mMaxCompression - mMinCompression;
-  real_type pullDisp = mMaxCompression - getPosition();
-  real_type pushDisp = getPosition() - mMinCompression;
+  real_type pullDisp = mMaxCompression - position;
+  real_type pushDisp = position - mMinCompression;
   
   real_type pullDispRatio = pullDisp/maxDisp;
   real_type pushDispRatio = pushDisp/maxDisp;
@@ -42,15 +75,19 @@
   real_type pullPressure = mPullPressure/(1-pow(pullDispRatio, mGamma));
   real_type pushPressure = mPushPressure/(1-pow(pushDispRatio, mGamma));
   
-  real_type force = sign(maxDisp)*mArea*(pullPressure - pushPressure);
+  mForce = sign(maxDisp)*mArea*(pullPressure - pushPressure);
   // Add a position dependent damping force
-  force += getVel()*interpolate(getPosition(),
-                                mMinCompression, mMinDamperConstant,
-                                mMaxCompression, mMaxDamperConstant);
-  
-  setForce(force);
+  mForce += vel*interpolate(position,
+                            mMinCompression, mMinDamperConstant,
+                            mMaxCompression, mMaxDamperConstant);
 }
 
+const real_type&
+AirSpring::getForce(void) const
+{
+  return mForce;
+}
+
 real_type
 AirSpring::getPushPressure(void) const
 {

Modified: trunk/OpenFDM/src/OpenFDM/AirSpring.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/AirSpring.h	2005-12-31 09:56:02 UTC (rev 145)
+++ trunk/OpenFDM/src/OpenFDM/AirSpring.h	2005-12-31 09:56:49 UTC (rev 146)
@@ -7,19 +7,21 @@
 
 #include "Model.h"
 #include "Vector.h"
-#include "LineForce.h"
 
 namespace OpenFDM {
 
 /// AirSpring
 class AirSpring :
-    public LineForce {
+    public Model {
 public:
   AirSpring(const std::string& name);
   virtual ~AirSpring(void);
 
+  virtual bool init(void);
   virtual void output(const TaskInfo& taskInfo);
 
+  const real_type& getForce(void) const;
+
   real_type getPushPressure(void) const;
   void setPushPressure(real_type pushPressure);
 
@@ -57,6 +59,13 @@
   real_type mMinDamperConstant;
 
   real_type mGamma;
+
+  real_type mForce;
+
+  /// The intput port which must provide the position
+  RealPortHandle mPositionPort;
+  /// The intput port which must provide the velocity
+  RealPortHandle mVelocityPort;
 };
 
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/Interact.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Interact.cpp	2005-12-31 09:56:02 UTC (rev 145)
+++ trunk/OpenFDM/src/OpenFDM/Interact.cpp	2005-12-31 09:56:49 UTC (rev 146)
@@ -28,6 +28,18 @@
 {
 }
 
+const Interact*
+Interact::toInteract(void) const
+{
+  return this;
+}
+
+Interact*
+Interact::toInteract(void)
+{
+  return this;
+}
+
 void
 Interact::accept(ModelVisitor& visitor)
 {

Modified: trunk/OpenFDM/src/OpenFDM/Interact.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Interact.h	2005-12-31 09:56:02 UTC (rev 145)
+++ trunk/OpenFDM/src/OpenFDM/Interact.h	2005-12-31 09:56:49 UTC (rev 146)
@@ -27,6 +27,9 @@
   Interact(const std::string& name, unsigned numParents);
   virtual ~Interact(void);
 
+  virtual const Interact* toInteract(void) const;
+  virtual Interact* toInteract(void);
+
   /// Double dispatch helper for the multibody system visitor
   virtual void accept(ModelVisitor& visitor);
   /// Double dispatch helper for the multibody system visitor
@@ -45,6 +48,18 @@
     OpenFDMAssert(id < mParents.size());
     return mParents[id];
   }
+  bool isChildOf(const RigidBody* const rigidBody) const
+  {
+    if (!rigidBody)
+      return false;
+    ParentList::const_iterator it = mParents.begin();
+    while (it != mParents.end()) {
+      if ((*it) == rigidBody)
+        return true;
+      ++it;
+    }
+    return false;
+  }
 
 private:
   bool attachTo(RigidBody* rigidBody, bool upstream);

Modified: trunk/OpenFDM/src/OpenFDM/Model.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Model.cpp	2005-12-31 09:56:02 UTC (rev 145)
+++ trunk/OpenFDM/src/OpenFDM/Model.cpp	2005-12-31 09:56:49 UTC (rev 146)
@@ -73,6 +73,18 @@
   return 0;
 }
 
+const Interact*
+Model::toInteract(void) const
+{
+  return 0;
+}
+
+Interact*
+Model::toInteract(void)
+{
+  return 0;
+}
+
 const Joint*
 Model::toJoint(void) const
 {

Modified: trunk/OpenFDM/src/OpenFDM/Model.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Model.h	2005-12-31 09:56:02 UTC (rev 145)
+++ trunk/OpenFDM/src/OpenFDM/Model.h	2005-12-31 09:56:49 UTC (rev 146)
@@ -28,6 +28,7 @@
 
 class Input;
 class Output;
+class Interact;
 class Joint;
 class MobileRootJoint;
 
@@ -57,6 +58,9 @@
   virtual const Output* toOutput(void) const;
   virtual Output* toOutput(void);
 
+  virtual const Interact* toInteract(void) const;
+  virtual Interact* toInteract(void);
+
   virtual const Joint* toJoint(void) const;
   virtual Joint* toJoint(void);
 

Modified: trunk/OpenFDM/src/OpenFDM/ModelGroup.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/ModelGroup.cpp	2005-12-31 09:56:02 UTC (rev 145)
+++ trunk/OpenFDM/src/OpenFDM/ModelGroup.cpp	2005-12-31 09:56:49 UTC (rev 146)
@@ -307,8 +307,10 @@
 }
 
 bool
-ModelGroup::appendDependecies(const Model* firstModel, Model* model, ModelList& newList)
+ModelGroup::appendModel(const Model* firstModel, SharedPtr<Model> model,
+                        ModelList& newList)
 {
+  Interact* interact = model->toInteract();
   Joint* joint = model->toJoint();
   if (joint) {
     for (;;) {
@@ -317,23 +319,34 @@
         Joint* joint2 = (*it)->toJoint();
         if (joint2 && dependsOnMultiBody(joint, joint2))
           break;
+
+        Interact* interact2 = (*it)->toInteract();
+        if (interact2 && interact2->isChildOf(joint->getOutboardBody())
+            && !interact2->getMultiBodyAcceleration())
+          break;
+
         ++it;
       }
       if (it == mModels.end())
         break;
 
+      // FIXME: does not work in this algorithm
+      // Detect a circular dependency.
+//       if (*it == firstModel) {
+//         Log(Model, Warning)
+//           << "Detected circilar model dependency.\nRunning with a sample "
+//           "delay at input of \"" << (*it)->getName() << "\"!" << endl;
+//         return false;
+//       }
+
       // We need to store that one here since the iterator possibly invalidates
       // during the next append dependency call
       SharedPtr<Model> tmpModel = *it;
       mModels.erase(it);
       
       // Now recurse into that model.
-      if (!appendDependecies(firstModel, tmpModel, newList))
+      if (!appendModel(firstModel, tmpModel, newList))
         return false;
- 
-      // Finally, past all the dependent models are already in the list,
-      // push that one in question.
-      newList.push_back(tmpModel);
     }
   }
 
@@ -349,63 +362,72 @@
       ++it;
     }
     if (it != mModels.end()) {
+      // FIXME: does not work in this algorithm
+      // Detect a circular dependency.
+//       if (*it == firstModel) {
+//         Log(Model, Warning)
+//           << "Detected circilar model dependency.\nRunning with a sample "
+//           "delay at input of \"" << (*it)->getName() << "\"!" << endl;
+//         return false;
+//       }
+
       // We need to store that one here since the iterator possibly invalidates
       // during the next append dependency call
       SharedPtr<Model> tmpModel = *it;
       mModels.erase(it);
-      
+
       // Now recurse into that model.
-      if (!appendDependecies(firstModel, tmpModel, newList))
+      if (!appendModel(firstModel, tmpModel, newList))
         return false;
-      
-      // Finally, past all the dependent models are already in the list,
-      // push that one in question.
-      newList.push_back(tmpModel);
     }
   }
 
   // If the model in question does not have dependencies, stop.
-  if (!model->getDirectFeedThrough())
-    return true;
+  if (model->getDirectFeedThrough() || joint) {
 
-  // Check, all inputs for dependencies.
-  unsigned numInputs = model->getNumInputPorts();
-  for (unsigned i = 0; i < numInputs; ++i) {
-    // Determine the model which is the source for this port
-    Port* port = model->getInputPort(i);
-
-    // Check if it is still in the list to be scheduled.
-    ModelList::iterator it = mModels.begin();
-    while (it != mModels.end()) {
-      if (dependsOn(port, *it))
-        break;
-      ++it;
+    // Check, all inputs for dependencies.
+    unsigned numInputs = model->getNumInputPorts();
+    for (unsigned i = 0; i < numInputs; ++i) {
+      // Determine the model which is the source for this port
+      Port* port = model->getInputPort(i);
+      
+      // Check if it is still in the list to be scheduled.
+      ModelList::iterator it = mModels.begin();
+      while (it != mModels.end()) {
+        /// Horrible special case for now:
+        /// Output's from joints are only state dependent,
+        /// thus these 'output ports' do not have direct feedthrough:
+        /// Possible workarounds: extra sensor models or direct feedthrough
+        /// is a property of the port ...
+        Joint* joint2 = (*it)->toJoint();
+        if (dependsOn(port, *it) && !joint2)
+          break;
+        ++it;
+      }
+      if (it == mModels.end())
+        continue;
+      
+      // FIXME: does not work in this algorithm
+      // Detect a circular dependency.
+//       if (*it == firstModel) {
+//         Log(Model, Warning)
+//           << "Detected circilar model dependency.\nRunning with a sample "
+//           "delay at input of \"" << (*it)->getName() << "\"!" << endl;
+//         return false;
+//       }
+      
+      // We need to store that one here since the iterator possibly invalidates
+      // during the next append dependency call
+      SharedPtr<Model> tmpModel = *it;
+      mModels.erase(it);
+      
+      // Now recurse into that model.
+      if (!appendModel(firstModel, tmpModel, newList))
+        return false;
     }
-    if (it == mModels.end())
-      continue;
-
-    // Detect a circular dependency.
-    if (*it == firstModel) {
-      Log(Model, Warning)
-        << "Detected circilar model dependency.\nRunning with a sample "
-        "delay at input of \"" << (*it)->getName() << "\"!" << endl;
-      return false;
-    }
-
-    // We need to store that one here since the iterator possibly invalidates
-    // during the next append dependency call
-    SharedPtr<Model> tmpModel = *it;
-    mModels.erase(it);
-
-    // Now recurse into that model.
-    if (!appendDependecies(firstModel, tmpModel, newList))
-      return false;
- 
-    // Finally, past all the dependent models are already in the list,
-    // push that one in question.
-    newList.push_back(tmpModel);
   }
 
+  newList.push_back(model);
   return true;
 }
 
@@ -413,14 +435,14 @@
 ModelGroup::sortModels(void)
 {
   // TODO: use better sort algorithm.
+  /// erhm, FIXME: This is a horrible sort thing!!!
   ModelList newList;
   while (!mModels.empty()) {
-    if (!appendDependecies(mModels.front(), mModels.front(), newList))
+    SharedPtr<Model> tmpModel = mModels.front();
+    mModels.erase(mModels.begin());
+
+    if (!appendModel(tmpModel, tmpModel, newList))
       return false;
-    // Finally, past all the dependent models are already in the list,
-    // push that one in question.
-    newList.push_back(mModels.front());
-    mModels.erase(mModels.begin());
   }
   // Now the new ordered list is the current one.
   mModels.swap(newList);

Modified: trunk/OpenFDM/src/OpenFDM/ModelGroup.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/ModelGroup.h	2005-12-31 09:56:02 UTC (rev 145)
+++ trunk/OpenFDM/src/OpenFDM/ModelGroup.h	2005-12-31 09:56:49 UTC (rev 146)
@@ -14,6 +14,8 @@
 
 namespace OpenFDM {
 
+class Joint;
+
 class ModelGroup
   : public Model {
 public:
@@ -75,8 +77,8 @@
   /// interact1 is higher in the tree of multibody models
   static bool dependsOnMultiBody(Joint* joint1, Joint* joint2);
 
-  bool appendDependecies(const Model* firstModel, Model* model,
-                         ModelList& newList);
+  bool appendModel(const Model* firstModel, SharedPtr<Model> model,
+                   ModelList& newList);
   /// Sorts the models depending their dependencies
   bool sortModels(void);
 

Modified: trunk/OpenFDM/src/OpenFDM/PrismaticJoint.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/PrismaticJoint.cpp	2005-12-31 09:56:02 UTC (rev 145)
+++ trunk/OpenFDM/src/OpenFDM/PrismaticJoint.cpp	2005-12-31 09:56:49 UTC (rev 146)
@@ -24,6 +24,11 @@
 
   mPrismaticJointFrame = new PrismaticJointFrame(name);
 
+  setNumInputPorts(1);
+  setInputPortName(0, "jointForce");
+
+  // Since these output ports are just fed by the current state of the
+  // multibody system, we do not have a direct feedthrough model
   setNumOutputPorts(2);
   setOutputPort(0, "jointPos", this, &PrismaticJoint::getJointPos);
   setOutputPort(1, "jointVel", this, &PrismaticJoint::getJointVel);
@@ -33,6 +38,19 @@
 {
 }
 
+bool
+PrismaticJoint::init(void)
+{
+  /// Check if we have an input port connected to the joint force ...
+  if (getInputPort(0)->isConnected())
+    mJointForcePort = getInputPort(0)->toRealPortHandle();
+  else
+    mJointForcePort = 0;
+
+  recheckTopology();
+  return Joint::init();
+}
+
 void
 PrismaticJoint::recheckTopology(void)
 {
@@ -110,7 +128,10 @@
   // That projects away tha components where the degrees of freedom
   // of the joint are.
   CartesianJointFrame<1>::VectorN tau;
-  tau(1) = getJointForce();
+  if (mJointForcePort.isConnected()) {
+    tau(1) = mJointForcePort.getRealValue();
+  } else
+    tau.clear();
   mPrismaticJointFrame->jointArticulation(artI, artF, outF, outI, tau);
 }
 

Modified: trunk/OpenFDM/src/OpenFDM/PrismaticJoint.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/PrismaticJoint.h	2005-12-31 09:56:02 UTC (rev 145)
+++ trunk/OpenFDM/src/OpenFDM/PrismaticJoint.h	2005-12-31 09:56:49 UTC (rev 146)
@@ -26,8 +26,7 @@
   PrismaticJoint(const std::string& name);
   virtual ~PrismaticJoint(void);
 
-  virtual bool init(void)
-  { recheckTopology(); return Joint::init(); }
+  virtual bool init(void);
 
   virtual void recheckTopology(void);
 
@@ -59,22 +58,6 @@
    */
   void setPosition(const Vector3& position);
 
-  const LineForce* getLineForce(void) const
-  { return mLineForce; }
-  LineForce* getLineForce(void)
-  { return mLineForce; }
-  void setLineForce(LineForce* lineForce)
-  { mLineForce = lineForce; }
-
-  real_type getJointForce(void)
-  {
-    if (!mLineForce)
-      return 0;
-    
-    mLineForce->computeForce(getJointPos(), getJointVel());
-    return mLineForce->getForce();
-  }
-
 private:
   /** Computes the inboard articulated inertia and force for
       this articulated body. It is part of the articulated body algorithm.
@@ -83,15 +66,12 @@
                                  const SpatialInertia& outI,
                                  const Vector6& outF);
 
-  /** Methods for the OpenFDM::Part.
-   */
   virtual void setState(const StateStream& state);
   virtual void getState(StateStream& state) const;
   virtual void getStateDeriv(StateStream& stateDeriv);
 
-  /** The direct joint interaction force
-   */
-  SharedPtr<LineForce> mLineForce;
+  /// The intput port which might provide some joint internal force
+  RealPortHandle mJointForcePort;
 
   /// The frame of the mobile root
   SharedPtr<PrismaticJointFrame> mPrismaticJointFrame;

Modified: trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp	2005-12-31 09:56:02 UTC (rev 145)
+++ trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp	2005-12-31 09:56:49 UTC (rev 146)
@@ -24,6 +24,9 @@
 
   mRevoluteJointFrame = new RevoluteJointFrame(name);
 
+  setNumInputPorts(1);
+  setInputPortName(0, "jointForce");
+
   setNumOutputPorts(2);
   setOutputPort(0, "jointPos", this, &RevoluteJoint::getJointPos);
   setOutputPort(1, "jointVel", this, &RevoluteJoint::getJointVel);
@@ -33,6 +36,19 @@
 {
 }
 
+bool
+RevoluteJoint::init(void)
+{
+  /// Check if we have an input port connected to the joint force ...
+  if (getInputPort(0)->isConnected())
+    mJointForcePort = getInputPort(0)->toRealPortHandle();
+  else
+    mJointForcePort = 0;
+
+  recheckTopology();
+  return Joint::init();
+}
+
 void
 RevoluteJoint::recheckTopology(void)
 {
@@ -107,7 +123,12 @@
                                  const Vector6& outF)
 {
   CartesianJointFrame<1>::VectorN tau;
-  tau(1) = getJointForce();
+  if (mJointForcePort.isConnected()) {
+    tau(1) = mJointForcePort.getRealValue();
+  } else
+    tau.clear();
+  /// FIXME the old obsolete joint force computation
+  tau(1) += getJointForce();
   mRevoluteJointFrame->jointArticulation(artI, artF, outF, outI, tau);
 }
 

Modified: trunk/OpenFDM/src/OpenFDM/RevoluteJoint.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RevoluteJoint.h	2005-12-31 09:56:02 UTC (rev 145)
+++ trunk/OpenFDM/src/OpenFDM/RevoluteJoint.h	2005-12-31 09:56:49 UTC (rev 146)
@@ -26,8 +26,7 @@
   RevoluteJoint(const std::string& name);
   virtual ~RevoluteJoint(void);
 
-  virtual bool init(void)
-  { recheckTopology(); return Joint::init(); }
+  virtual bool init(void);
 
   virtual void recheckTopology(void);
 
@@ -93,6 +92,9 @@
    */
   SharedPtr<LineForce> mLineForce;
 
+  /// The intput port which might provide some joint internal force
+  RealPortHandle mJointForcePort;
+
   /// The frame of the mobile root
   SharedPtr<RevoluteJointFrame> mRevoluteJointFrame;
 };



From frohlich at berlios.de  Sat Dec 31 11:22:45 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Sat, 31 Dec 2005 11:22:45 +0100
Subject: [OpenFDM-svn] r147 - in trunk/OpenFDM/src: JSBSim OpenFDM
Message-ID: <200512311022.jBVAMjPH022500@sheep.berlios.de>

Author: frohlich
Date: 2005-12-31 11:22:33 +0100 (Sat, 31 Dec 2005)
New Revision: 147

Removed:
   trunk/OpenFDM/src/OpenFDM/LineForce.cpp
   trunk/OpenFDM/src/OpenFDM/LineForce.h
Modified:
   trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
   trunk/OpenFDM/src/OpenFDM/DiscBrake.cpp
   trunk/OpenFDM/src/OpenFDM/DiscBrake.h
   trunk/OpenFDM/src/OpenFDM/LinearSpring.cpp
   trunk/OpenFDM/src/OpenFDM/LinearSpring.h
   trunk/OpenFDM/src/OpenFDM/Makefile.am
   trunk/OpenFDM/src/OpenFDM/PrismaticJoint.h
   trunk/OpenFDM/src/OpenFDM/PrismaticJointFrame.h
   trunk/OpenFDM/src/OpenFDM/RevoluteActuatorFrame.h
   trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp
   trunk/OpenFDM/src/OpenFDM/RevoluteJoint.h
   trunk/OpenFDM/src/OpenFDM/RevoluteJointFrame.h
Log:
Convert the remaining LineForces to ordinary Model's


Modified: trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
===================================================================
--- trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2005-12-31 09:56:49 UTC (rev 146)
+++ trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2005-12-31 10:22:33 UTC (rev 147)
@@ -751,16 +751,30 @@
   wj->setJointVel(0);
 
   // Add an brake force
-  DiscBrake* brakeF = new DiscBrake(name + " Brake Force");
-  brakeF->setFrictionConstant(-1e4);
-  if (brake == "LEFT") {
-    Port* port = lookupJSBExpression("gear/left-brake-pos-norm");
-    brakeF->getInputPort(0)->connect(port);
-  } else if (brake == "RIGHT") {
-    Port* port = lookupJSBExpression("gear/right-brake-pos-norm");
-    brakeF->getInputPort(0)->connect(port);
+  if (brake == "LEFT" || brake == "RIGHT") {
+    DiscBrake* brakeF = new DiscBrake(name + " Brake Force");
+    brakeF->setFrictionConstant(-1e4);
+    if (brake == "LEFT") {
+      Port* port = lookupJSBExpression("gear/left-brake-pos-norm");
+      brakeF->getInputPort(0)->connect(port);
+    } else if (brake == "RIGHT") {
+      Port* port = lookupJSBExpression("gear/right-brake-pos-norm");
+      brakeF->getInputPort(0)->connect(port);
+    }
+    // That one reads the joint position and velocity ...
+    brakeF->getInputPort(1)->connect(wj->getOutputPort(1));
+    // ... and provides an output force
+    wj->getInputPort(0)->connect(brakeF->getOutputPort(0));
+    mVehicle->getMultiBodySystem()->addModel(brakeF);
+  } else {
+    // Just some 'rolloing friction' FIXME: does this belong here?
+    Gain* rollingFric = new Gain(name + " Rolling Friction Force");
+    rollingFric->setGain(-10);
+    rollingFric->getInputPort(0)->connect(wj->getOutputPort(1));
+    // ... and provides an output force
+    wj->getInputPort(0)->connect(rollingFric->getOutputPort(0));
+    mVehicle->getMultiBodySystem()->addModel(rollingFric);
   }
-  wj->setLineForce(brakeF);
   
   WheelContact* wc = new WheelContact(name + " Wheel Contact");
   wc->setWheelRadius(0.5*wheelDiam);

Modified: trunk/OpenFDM/src/OpenFDM/DiscBrake.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/DiscBrake.cpp	2005-12-31 09:56:49 UTC (rev 146)
+++ trunk/OpenFDM/src/OpenFDM/DiscBrake.cpp	2005-12-31 10:22:33 UTC (rev 147)
@@ -9,29 +9,60 @@
 namespace OpenFDM {
 
 DiscBrake::DiscBrake(const std::string& name) :
-  LineForce(name),
+  Model(name),
   mFrictionConstant(-1)
 {
-  setNumInputPorts(1);
+  setDirectFeedThrough(true);
+
+  setNumInputPorts(2);
   setInputPortName(0, "brakePressure");
+  setInputPortName(1, "velocity");
+  
+  setNumOutputPorts(1);
+  setOutputPort(0, "force", this, &DiscBrake::getForce);
 }
 
 DiscBrake::~DiscBrake(void)
 {
 }
 
+bool
+DiscBrake::init(void)
+{
+  if (!getInputPort(0)->isConnected()) {
+    Log(Model, Error) << "Initialization of DiscBrake model \"" << getName()
+                      << "\" failed: Input port \"" << getInputPortName(0)
+                      << "\" is not connected!" << endl;
+    return false;
+  }
+  mBrakePressurePort = getInputPort(0)->toRealPortHandle();
+
+  if (!getInputPort(1)->isConnected()) {
+    Log(Model, Error) << "Initialization of DiscBrake model \"" << getName()
+                      << "\" failed: Input port \"" << getInputPortName(1)
+                      << "\" is not connected!" << endl;
+    return false;
+  }
+  mVelocityPort = getInputPort(1)->toRealPortHandle();
+
+  return true;
+}
+
 void
 DiscBrake::output(const TaskInfo& taskInfo)
 {
-  Port* port = getInputPort(0);
-  real_type brakeInput = 0;
-  if (port->isConnected()) {
-    RealPortHandle rh = port->toRealPortHandle();
-    brakeInput = rh.getRealValue();
-  }
-  setForce(getVel()*(-1e1 + brakeInput*mFrictionConstant));
+  real_type brakeInput = mBrakePressurePort.getRealValue();
+  real_type vel = mVelocityPort.getRealValue();
+  /// Hmm, this seems to be an intermediate model for a disc brake ...
+  mForce = vel*(-1e1 + brakeInput*mFrictionConstant);
 }
 
+const real_type&
+DiscBrake::getForce(void) const
+{
+  return mForce;
+}
+
 real_type
 DiscBrake::getFrictionConstant(void) const
 {

Modified: trunk/OpenFDM/src/OpenFDM/DiscBrake.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/DiscBrake.h	2005-12-31 09:56:49 UTC (rev 146)
+++ trunk/OpenFDM/src/OpenFDM/DiscBrake.h	2005-12-31 10:22:33 UTC (rev 147)
@@ -5,26 +5,39 @@
 #ifndef OpenFDM_DiscBrake_H
 #define OpenFDM_DiscBrake_H
 
+#include <string>
+
+#include "Types.h"
 #include "Model.h"
-#include "Vector.h"
-#include "LineForce.h"
 
 namespace OpenFDM {
 
 /// Linear spring damper model
 class DiscBrake :
-    public LineForce {
+    public Model {
 public:
   DiscBrake(const std::string& name);
   virtual ~DiscBrake(void);
 
+  virtual bool init(void);
   virtual void output(const TaskInfo& taskInfo);
 
+  const real_type& getForce(void) const;
+
   real_type getFrictionConstant(void) const;
   void setFrictionConstant(real_type frictionConstant);
 
 private:
+  /// The friction constant for that viscosous friction model
   real_type mFrictionConstant;
+
+  /// The output brake force
+  real_type mForce;
+
+  /// The intput port which must provide the position
+  RealPortHandle mBrakePressurePort;
+  /// The intput port which must provide the velocity
+  RealPortHandle mVelocityPort;
 };
 
 } // namespace OpenFDM

Deleted: trunk/OpenFDM/src/OpenFDM/LineForce.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/LineForce.cpp	2005-12-31 09:56:49 UTC (rev 146)
+++ trunk/OpenFDM/src/OpenFDM/LineForce.cpp	2005-12-31 10:22:33 UTC (rev 147)
@@ -1,32 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
- *
- */
-
-#include "Model.h"
-#include "Vector.h"
-#include "LineForce.h"
-
-namespace OpenFDM {
-
-LineForce::LineForce(const std::string& name) :
-  Model(name)
-{
-}
-
-LineForce::~LineForce(void)
-{
-}
-
-void
-LineForce::computeForce(real_type position, real_type vel)
-{
-  // Set the position and velocity
-  mPosition = position;
-  mVel = vel;
-  // call the output function
-  TaskInfo taskInfo;
-  taskInfo.addSampleTime(SampleTime::Continous);
-  output(taskInfo);
-}
-
-} // namespace OpenFDM

Deleted: trunk/OpenFDM/src/OpenFDM/LineForce.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/LineForce.h	2005-12-31 09:56:49 UTC (rev 146)
+++ trunk/OpenFDM/src/OpenFDM/LineForce.h	2005-12-31 10:22:33 UTC (rev 147)
@@ -1,41 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
- *
- */
-
-#ifndef OpenFDM_LineForce_H
-#define OpenFDM_LineForce_H
-
-#include "Model.h"
-#include "Vector.h"
-
-namespace OpenFDM {
-
-class LineForce :
-    public Model {
-public:
-  LineForce(const std::string& name);
-  virtual ~LineForce(void);
-
-  void computeForce(real_type position, real_type vel);
-
-  real_type getPosition(void) const
-  { return mPosition; }
-  real_type getVel(void) const
-  { return mVel; }
-
-  real_type getForce(void) const
-  { return mForce; }
-
-protected:
-  void setForce(real_type force)
-  { mForce = force; }
-
-private:
-  real_type mPosition;
-  real_type mVel;
-  real_type mForce;
-};
-
-} // namespace OpenFDM
-
-#endif

Modified: trunk/OpenFDM/src/OpenFDM/LinearSpring.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/LinearSpring.cpp	2005-12-31 09:56:49 UTC (rev 146)
+++ trunk/OpenFDM/src/OpenFDM/LinearSpring.cpp	2005-12-31 10:22:33 UTC (rev 147)
@@ -9,7 +9,7 @@
 namespace OpenFDM {
 
 LinearSpring::LinearSpring(const std::string& name) :
-  LineForce(name),
+  Model(name),
   mSpringReference(0),
   mSpringConstant(0),
   mDamperConstant(0)
@@ -20,13 +20,43 @@
 {
 }
 
+bool
+LinearSpring::init(void)
+{
+  if (!getInputPort(0)->isConnected()) {
+    Log(Model, Error) << "Initialization of AirSpring model \"" << getName()
+                      << "\" failed: Input port \"" << getInputPortName(0)
+                      << "\" is not connected!" << endl;
+    return false;
+  }
+  mPositionPort = getInputPort(0)->toRealPortHandle();
+
+  if (!getInputPort(1)->isConnected()) {
+    Log(Model, Error) << "Initialization of AirSpring model \"" << getName()
+                      << "\" failed: Input port \"" << getInputPortName(1)
+                      << "\" is not connected!" << endl;
+    return false;
+  }
+  mVelocityPort = getInputPort(1)->toRealPortHandle();
+
+  return true;
+}
+
 void
 LinearSpring::output(const TaskInfo& taskInfo)
 {
-  real_type displacement = getPosition() - mSpringReference;
-  setForce(mSpringConstant*displacement + getVel()*mDamperConstant);
+  real_type position = mPositionPort.getRealValue();
+  real_type vel = mVelocityPort.getRealValue();
+  real_type displacement = position - mSpringReference;
+  mForce = mSpringConstant*displacement + vel*mDamperConstant;
 }
 
+const real_type&
+LinearSpring::getForce(void) const
+{
+  return mForce;
+}
+
 real_type
 LinearSpring::getSpringReference(void) const
 {

Modified: trunk/OpenFDM/src/OpenFDM/LinearSpring.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/LinearSpring.h	2005-12-31 09:56:49 UTC (rev 146)
+++ trunk/OpenFDM/src/OpenFDM/LinearSpring.h	2005-12-31 10:22:33 UTC (rev 147)
@@ -5,21 +5,25 @@
 #ifndef OpenFDM_LinearSpring_H
 #define OpenFDM_LinearSpring_H
 
+#include <string>
+
+#include "Types.h"
 #include "Model.h"
-#include "Vector.h"
-#include "LineForce.h"
 
 namespace OpenFDM {
 
 /// Linear spring damper model
 class LinearSpring :
-    public LineForce {
+    public Model {
 public:
   LinearSpring(const std::string& name);
   virtual ~LinearSpring(void);
 
+  virtual bool init(void);
   virtual void output(const TaskInfo& taskInfo);
 
+  const real_type& getForce(void) const;
+
   real_type getSpringReference(void) const;
   void setSpringReference(real_type springReference);
 
@@ -33,6 +37,13 @@
   real_type mSpringReference;
   real_type mSpringConstant;
   real_type mDamperConstant;
+
+  real_type mForce;
+
+  /// The intput port which must provide the position
+  RealPortHandle mPositionPort;
+  /// The intput port which must provide the velocity
+  RealPortHandle mVelocityPort;
 };
 
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/Makefile.am
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Makefile.am	2005-12-31 09:56:49 UTC (rev 146)
+++ trunk/OpenFDM/src/OpenFDM/Makefile.am	2005-12-31 10:22:33 UTC (rev 147)
@@ -74,7 +74,6 @@
   LinAlg/Misc.h \
   LinAlg/Proxy.h \
   LinearSpring.h \
-  LineForce.h \
   LogStream.h \
   Mass.h \
   Math.h \
@@ -172,7 +171,6 @@
   ImplicitEuler.cpp \
   Joint.cpp \
   LinearSpring.cpp \
-  LineForce.cpp \
   Logger.cpp \
   Mass.cpp \
   MaxModel.cpp \

Modified: trunk/OpenFDM/src/OpenFDM/PrismaticJoint.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/PrismaticJoint.h	2005-12-31 09:56:49 UTC (rev 146)
+++ trunk/OpenFDM/src/OpenFDM/PrismaticJoint.h	2005-12-31 10:22:33 UTC (rev 147)
@@ -14,7 +14,6 @@
 #include "Frame.h"
 #include "RigidBody.h"
 #include "Joint.h"
-#include "LineForce.h"
 
 namespace OpenFDM {
 

Modified: trunk/OpenFDM/src/OpenFDM/PrismaticJointFrame.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/PrismaticJointFrame.h	2005-12-31 09:56:49 UTC (rev 146)
+++ trunk/OpenFDM/src/OpenFDM/PrismaticJointFrame.h	2005-12-31 10:22:33 UTC (rev 147)
@@ -5,16 +5,6 @@
 #ifndef OpenFDM_PrismaticJointFrame_H
 #define OpenFDM_PrismaticJointFrame_H
 
-#include "Assert.h"
-#include "Object.h"
-#include "Vector.h"
-#include "Matrix.h"
-#include "Quaternion.h"
-#include "Inertia.h"
-#include "Frame.h"
-#include "RigidBody.h"
-#include "Joint.h"
-#include "LineForce.h"
 #include "CartesianJointFrame.h"
 
 namespace OpenFDM {

Modified: trunk/OpenFDM/src/OpenFDM/RevoluteActuatorFrame.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RevoluteActuatorFrame.h	2005-12-31 09:56:49 UTC (rev 146)
+++ trunk/OpenFDM/src/OpenFDM/RevoluteActuatorFrame.h	2005-12-31 10:22:33 UTC (rev 147)
@@ -5,15 +5,6 @@
 #ifndef OpenFDM_RevoluteActuatorFrame_H
 #define OpenFDM_RevoluteActuatorFrame_H
 
-#include "Assert.h"
-#include "Vector.h"
-#include "Matrix.h"
-#include "Quaternion.h"
-#include "Inertia.h"
-#include "Frame.h"
-#include "RigidBody.h"
-#include "Joint.h"
-#include "LineForce.h"
 #include "CartesianActuatorFrame.h"
 
 namespace OpenFDM {

Modified: trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp	2005-12-31 09:56:49 UTC (rev 146)
+++ trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp	2005-12-31 10:22:33 UTC (rev 147)
@@ -127,8 +127,6 @@
     tau(1) = mJointForcePort.getRealValue();
   } else
     tau.clear();
-  /// FIXME the old obsolete joint force computation
-  tau(1) += getJointForce();
   mRevoluteJointFrame->jointArticulation(artI, artF, outF, outI, tau);
 }
 

Modified: trunk/OpenFDM/src/OpenFDM/RevoluteJoint.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RevoluteJoint.h	2005-12-31 09:56:49 UTC (rev 146)
+++ trunk/OpenFDM/src/OpenFDM/RevoluteJoint.h	2005-12-31 10:22:33 UTC (rev 147)
@@ -14,7 +14,6 @@
 #include "Frame.h"
 #include "RigidBody.h"
 #include "Joint.h"
-#include "LineForce.h"
 
 namespace OpenFDM {
 
@@ -58,22 +57,6 @@
    */
   void setOrientation(const Quaternion& orientation);
 
-  const LineForce* getLineForce(void) const
-  { return mLineForce; }
-  LineForce* getLineForce(void)
-  { return mLineForce; }
-  void setLineForce(LineForce* lineForce)
-  { mLineForce = lineForce; }
-
-  real_type getJointForce(void)
-  {
-    if (!mLineForce)
-      return 0;
-    
-    mLineForce->computeForce(getJointPos(), getJointVel());
-    return mLineForce->getForce();
-  }
-
 private:
   /** Computes the inboard articulated inertia and force for
       this articulated body. It is part of the articulated body algorithm.
@@ -88,10 +71,6 @@
   virtual void getState(StateStream& state) const;
   virtual void getStateDeriv(StateStream& stateDeriv);
 
-  /** The direct joint interaction force
-   */
-  SharedPtr<LineForce> mLineForce;
-
   /// The intput port which might provide some joint internal force
   RealPortHandle mJointForcePort;
 

Modified: trunk/OpenFDM/src/OpenFDM/RevoluteJointFrame.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RevoluteJointFrame.h	2005-12-31 09:56:49 UTC (rev 146)
+++ trunk/OpenFDM/src/OpenFDM/RevoluteJointFrame.h	2005-12-31 10:22:33 UTC (rev 147)
@@ -5,16 +5,6 @@
 #ifndef OpenFDM_RevoluteJointFrame_H
 #define OpenFDM_RevoluteJointFrame_H
 
-#include "Assert.h"
-#include "Object.h"
-#include "Vector.h"
-#include "Matrix.h"
-#include "Quaternion.h"
-#include "Inertia.h"
-#include "Frame.h"
-#include "RigidBody.h"
-#include "Joint.h"
-#include "LineForce.h"
 #include "CartesianJointFrame.h"
 
 namespace OpenFDM {



From frohlich at berlios.de  Sat Dec 31 12:02:40 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Sat, 31 Dec 2005 12:02:40 +0100
Subject: [OpenFDM-svn] r148 - trunk/OpenFDM/src/OpenFDM/LinAlg
Message-ID: <200512311102.jBVB2eQm025506@sheep.berlios.de>

Author: frohlich
Date: 2005-12-31 12:02:37 +0100 (Sat, 31 Dec 2005)
New Revision: 148

Modified:
   trunk/OpenFDM/src/OpenFDM/LinAlg/Container.h
Log:
Make the containers return a cont ref instead
of the value itself


Modified: trunk/OpenFDM/src/OpenFDM/LinAlg/Container.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/LinAlg/Container.h	2005-12-31 10:22:33 UTC (rev 147)
+++ trunk/OpenFDM/src/OpenFDM/LinAlg/Container.h	2005-12-31 11:02:37 UTC (rev 148)
@@ -48,7 +48,7 @@
   /** Const accessor.
    */
   OpenFDM_FORCE_INLINE
-  value_type operator()(size_type i, size_type j) const
+  const value_type& operator()(size_type i, size_type j) const
   { return *data_.find(i, j); }
   /** Nonconst accessor.
    */
@@ -190,7 +190,7 @@
   /** Const accessor.
    */
   OpenFDM_FORCE_INLINE
-  value_type operator()(size_type i) const
+  const value_type& operator()(size_type i) const
   { return *data_.find(i); }
   /** Nonconst accessor.
    */
@@ -201,7 +201,7 @@
   /** Const accessor.
    */
   OpenFDM_FORCE_INLINE
-  value_type operator()(size_type i, size_type j) const
+  const value_type& operator()(size_type i, size_type j) const
   { return *data_.find(i); }
   /** Nonconst accessor.
    */
@@ -400,7 +400,7 @@
   /** Const accessor.
    */
   OpenFDM_FORCE_INLINE
-  value_type operator()(size_type i, size_type j) const
+  const value_type& operator()(size_type i, size_type j) const
   { return *data_.find(i, j); }
   /** Nonconst accessor.
    */



From frohlich at berlios.de  Sat Dec 31 12:31:32 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Sat, 31 Dec 2005 12:31:32 +0100
Subject: [OpenFDM-svn] r149 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200512311131.jBVBVW0m030078@sheep.berlios.de>

Author: frohlich
Date: 2005-12-31 12:31:20 +0100 (Sat, 31 Dec 2005)
New Revision: 149

Modified:
   trunk/OpenFDM/src/OpenFDM/AeroForce.cpp
   trunk/OpenFDM/src/OpenFDM/AeroForce.h
Log:
Make those sensed values return const refs.


Modified: trunk/OpenFDM/src/OpenFDM/AeroForce.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/AeroForce.cpp	2005-12-31 11:02:37 UTC (rev 148)
+++ trunk/OpenFDM/src/OpenFDM/AeroForce.cpp	2005-12-31 11:31:20 UTC (rev 149)
@@ -151,7 +151,7 @@
   mWingSpan = winSpan;
 }
 
-real_type
+const real_type&
 AeroForce::getWingSpan(void) const
 {
   return mWingSpan;
@@ -163,7 +163,7 @@
   mWingArea = winArea;
 }
 
-real_type
+const real_type&
 AeroForce::getWingArea(void) const
 {
   return mWingArea;
@@ -175,7 +175,7 @@
   mCoord = coord;
 }
 
-real_type
+const real_type&
 AeroForce::getCoord(void) const
 {
   return mCoord;
@@ -237,7 +237,7 @@
   return mMach;
 }
 
-real_type
+const real_type&
 AeroForce::getTrueSpeed(void) const
 {
   if (mDirtyTrueSpeed) {
@@ -249,7 +249,7 @@
   return mTrueSpeed;
 }
 
-real_type
+const real_type&
 AeroForce::getEquivalentAirSpeed(void) const
 {
   if (mDirtyEquivalentAirSpeed)
@@ -259,7 +259,7 @@
   return mEquivalentAirSpeed;
 }
 
-real_type
+const real_type&
 AeroForce::getCalibratedAirSpeed(void) const
 {
   if (mDirtyCalibratedAirSpeed)
@@ -269,7 +269,7 @@
   return mCalibratedAirSpeed;
 }
 
-real_type
+const real_type&
 AeroForce::getDynamicPressure(void) const
 {
   if (mDirtyDynamicPressure) {
@@ -282,7 +282,7 @@
   return mDynamicPressure;
 }
 
-real_type
+const real_type&
 AeroForce::getAlpha(void) const
 {
   if (mDirtyAlpha) {
@@ -297,7 +297,7 @@
   return mAlpha;
 }
 
-real_type
+const real_type&
 AeroForce::getAlphaDot(void) const
 {
   if (mDirtyAlphaDot) {
@@ -315,7 +315,7 @@
   return mAlphaDot;
 }
 
-real_type
+const real_type&
 AeroForce::getBeta(void) const
 {
   if (mDirtyBeta) {
@@ -332,7 +332,7 @@
   return mBeta;
 }
 
-real_type
+const real_type&
 AeroForce::getBetaDot(void) const
 {
   if (mDirtyBetaDot) {
@@ -352,88 +352,112 @@
   return mBetaDot;
 }
 
-real_type
+const real_type&
 AeroForce::getBodyU(void) const
 {
   const Vector6& speed = getAirSpeed();
   return speed(4);
 }
 
-real_type
+const real_type&
 AeroForce::getBodyV(void) const
 {
   const Vector6& speed = getAirSpeed();
   return speed(5);
 }
 
-real_type
+const real_type&
 AeroForce::getBodyW(void) const
 {
   const Vector6& speed = getAirSpeed();
   return speed(6);
 }
 
-real_type
+const real_type&
 AeroForce::getBodyP(void) const
 {
   const Vector6& speed = getAirSpeed();
   return speed(1);
 }
 
-real_type
+const real_type&
 AeroForce::getBodyQ(void) const
 {
   const Vector6& speed = getAirSpeed();
   return speed(2);
 }
 
-real_type
+const real_type&
 AeroForce::getBodyR(void) const
 {
   const Vector6& speed = getAirSpeed();
   return speed(3);
 }
 
-real_type
+const real_type&
 AeroForce::getMachNumber(void) const
 {
-  return norm(getMach());
+  if (mDirtyMachNumber) {
+    mMachNumber = norm(getMach());
+    mDirtyMachNumber = false;
+  }
+  Log(ArtBody, Debug3) << "AeroForce::getMachNumber()"
+                       << mMachNumber << endl;
+  return mMachNumber;
 }
 
-real_type
+const real_type&
 AeroForce::getTrueSpeedUW(void) const
 {
-  const Vector6& speed = getAirSpeed();
-  return sqrt(speed(4)*speed(4)+speed(6)*speed(6));
+  if (mDirtyTrueSpeedUW) {
+    const Vector6& speed = getAirSpeed();
+    mTrueSpeedUW = sqrt(speed(4)*speed(4)+speed(6)*speed(6));
+    mDirtyTrueSpeedUW = false;
+  }
+  Log(ArtBody, Debug3) << "AeroForce::getTrueSpeedUW()"
+                       << mTrueSpeedUW << endl;
+  return mTrueSpeedUW;
 }
 
-real_type
+const real_type&
 AeroForce::getWingSpanOver2Speed(void) const
 {
-  real_type Vt2 = 2*getTrueSpeed();
-  if (fabs(Vt2) < Limits<real_type>::min())
-    return 0;
-  else
-    return getWingSpan()/Vt2;
+  if (mDirtyWingSpanOver2Speed) {
+    real_type Vt2 = 2*getTrueSpeed();
+    if (fabs(Vt2) < Limits<real_type>::min())
+      mWingSpanOver2Speed = 0;
+    else
+      mWingSpanOver2Speed = getWingSpan()/Vt2;
+    mDirtyWingSpanOver2Speed = false;
+  }
+  return mWingSpanOver2Speed;
 }
 
-real_type
+const real_type&
 AeroForce::getCoordOver2Speed(void) const
 {
-  real_type Vt2 = 2*getTrueSpeed();
-  if (fabs(Vt2) < Limits<real_type>::min())
-    return 0;
-  else
-    return getCoord()/Vt2;
+  if (mDirtyCoordOver2Speed) {
+    real_type Vt2 = 2*getTrueSpeed();
+    if (fabs(Vt2) < Limits<real_type>::min())
+      mCoordOver2Speed = 0;
+    else
+      mCoordOver2Speed = getCoord()/Vt2;
+    mDirtyCoordOver2Speed = false;
+  }
+  return mCoordOver2Speed;
 }
 
-real_type
+const real_type&
 AeroForce::getHOverWingSpan(void) const
 {
-  return getAboveGroundLevel()/getWingSpan();
+  if (mDirtyHOverWingSpan) {
+    mHOverWingSpan = getAboveGroundLevel()/getWingSpan();
+    mDirtyHOverWingSpan = false;
+  }
+  return mHOverWingSpan;
 }
 
-real_type
+const real_type&
 AeroForce::getAltitude(void) const
 {
   if (mDirtyAltitude) {
@@ -452,7 +476,7 @@
   return mAltitude;
 }
 
-real_type
+const real_type&
 AeroForce::getAboveGroundLevel(void) const
 {
   if (mDirtyAboveGroundLevel) {
@@ -473,7 +497,7 @@
   return mAboveGroundLevel;
 }
 
-real_type
+const real_type&
 AeroForce::getPressure(void) const
 {
   computeAtmosphere();
@@ -482,7 +506,7 @@
   return mAtmos.pressure;
 }
 
-real_type
+const real_type&
 AeroForce::getDensity(void) const
 {
   computeAtmosphere();
@@ -491,7 +515,7 @@
   return mAtmos.density;
 }
 
-real_type
+const real_type&
 AeroForce::getSoundSpeed(void) const
 {
   computeAtmosphere();
@@ -500,7 +524,7 @@
   return mAtmos.soundspeed;
 }
 
-real_type
+const real_type&
 AeroForce::getTemperature(void) const
 {
   computeAtmosphere();
@@ -509,28 +533,28 @@
   return mAtmos.temperature;
 }
 
-real_type
+const real_type&
 AeroForce::getPressureSeaLevel(void) const
 {
   computeSLAtmosphere();
   return mSLAtmos.pressure;
 }
 
-real_type
+const real_type&
 AeroForce::getDensitySeaLevel(void) const
 {
   computeSLAtmosphere();
   return mSLAtmos.density;
 }
 
-real_type
+const real_type&
 AeroForce::getSoundSpeedSeaLevel(void) const
 {
   computeSLAtmosphere();
   return mSLAtmos.soundspeed;
 }
 
-real_type
+const real_type&
 AeroForce::getTemperatureSeaLevel(void) const
 {
   computeSLAtmosphere();
@@ -610,10 +634,15 @@
   mDirtyAtmosphere = true;
   mDirtyAltitude = true;
   mDirtyAboveGroundLevel = true;
+  mDirtyWingSpanOver2Speed = true;
+  mDirtyCoordOver2Speed = true;
+  mDirtyHOverWingSpan = true;
   mDirtySLAtmosphere = true;
   mDirtyAirSpeed = true;
   mDirtyMach = true;
+  mDirtyMachNumber = true;
   mDirtyTrueSpeed = true;
+  mDirtyTrueSpeedUW = true;
   mDirtyCalibratedAirSpeed = true;
   mDirtyEquivalentAirSpeed = true;
   mDirtyDynamicPressure = true;

Modified: trunk/OpenFDM/src/OpenFDM/AeroForce.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/AeroForce.h	2005-12-31 11:02:37 UTC (rev 148)
+++ trunk/OpenFDM/src/OpenFDM/AeroForce.h	2005-12-31 11:31:20 UTC (rev 149)
@@ -43,57 +43,57 @@
   const Rotation& getOrientation(void) const;
 
   void setWingSpan(const real_type& winSpan);
-  real_type getWingSpan(void) const;
+  const real_type& getWingSpan(void) const;
 
   void setWingArea(const real_type& winArea);
-  real_type getWingArea(void) const;
+  const real_type& getWingArea(void) const;
 
   void setCoord(const real_type& coord);
-  real_type getCoord(void) const;
+  const real_type& getCoord(void) const;
 
   const Vector3& getRefPosition(void) const;
   const Vector6& getAirSpeed(void) const;
   const Vector3& getMach(void) const;
-  real_type getTrueSpeed(void) const;
-  real_type getEquivalentAirSpeed(void) const;
-  real_type getCalibratedAirSpeed(void) const;
-  real_type getDynamicPressure(void) const;
-  real_type getAlpha(void) const;
-  real_type getAlphaDot(void) const;
-  real_type getBeta(void) const;
-  real_type getBetaDot(void) const;
+  const real_type& getTrueSpeed(void) const;
+  const real_type& getEquivalentAirSpeed(void) const;
+  const real_type& getCalibratedAirSpeed(void) const;
+  const real_type& getDynamicPressure(void) const;
+  const real_type& getAlpha(void) const;
+  const real_type& getAlphaDot(void) const;
+  const real_type& getBeta(void) const;
+  const real_type& getBetaDot(void) const;
 
-  real_type getBodyU(void) const;
-  real_type getBodyV(void) const;
-  real_type getBodyW(void) const;
+  const real_type& getBodyU(void) const;
+  const real_type& getBodyV(void) const;
+  const real_type& getBodyW(void) const;
 
-  real_type getBodyP(void) const;
-  real_type getBodyQ(void) const;
-  real_type getBodyR(void) const;
+  const real_type& getBodyP(void) const;
+  const real_type& getBodyQ(void) const;
+  const real_type& getBodyR(void) const;
 
-  real_type getMachNumber(void) const;
-  real_type getTrueSpeedUW(void) const;
+  const real_type& getMachNumber(void) const;
+  const real_type& getTrueSpeedUW(void) const;
 
   /// FIXME, may be just provide 1/(2Vt)???
   /// Or provide the whole set of nondimentionalized values ...
   /// May be better since we can throw out the singularities ...
-  real_type getWingSpanOver2Speed(void) const;
-  real_type getCoordOver2Speed(void) const;
-  real_type getHOverWingSpan(void) const;
+  const real_type& getWingSpanOver2Speed(void) const;
+  const real_type& getCoordOver2Speed(void) const;
+  const real_type& getHOverWingSpan(void) const;
 
-  real_type getAltitude(void) const;
-  real_type getAboveGroundLevel(void) const;
+  const real_type& getAltitude(void) const;
+  const real_type& getAboveGroundLevel(void) const;
 
-  real_type getPressure(void) const;
-  real_type getDensity(void) const;
-  real_type getSoundSpeed(void) const;
-  real_type getTemperature(void) const;
+  const real_type& getPressure(void) const;
+  const real_type& getDensity(void) const;
+  const real_type& getSoundSpeed(void) const;
+  const real_type& getTemperature(void) const;
 
 
-  real_type getPressureSeaLevel(void) const;
-  real_type getDensitySeaLevel(void) const;
-  real_type getSoundSpeedSeaLevel(void) const;
-  real_type getTemperatureSeaLevel(void) const;
+  const real_type& getPressureSeaLevel(void) const;
+  const real_type& getDensitySeaLevel(void) const;
+  const real_type& getSoundSpeedSeaLevel(void) const;
+  const real_type& getTemperatureSeaLevel(void) const;
 
   const Vector3& getUnitDown(void) const;
   const Plane& getLocalGroundPlane(void) const;
@@ -146,11 +146,16 @@
   mutable bool mDirtyLocalGroundPlane:1;
   mutable bool mDirtyAltitude:1;
   mutable bool mDirtyAboveGroundLevel:1;
+  mutable bool mDirtyWingSpanOver2Speed:1;
+  mutable bool mDirtyCoordOver2Speed:1;
+  mutable bool mDirtyHOverWingSpan:1;
   mutable bool mDirtyAtmosphere:1;
   mutable bool mDirtySLAtmosphere:1;
   mutable bool mDirtyAirSpeed:1;
   mutable bool mDirtyMach:1;
+  mutable bool mDirtyMachNumber:1;
   mutable bool mDirtyTrueSpeed:1;
+  mutable bool mDirtyTrueSpeedUW:1;
   mutable bool mDirtyCalibratedAirSpeed:1;
   mutable bool mDirtyEquivalentAirSpeed:1;
   mutable bool mDirtyDynamicPressure:1;
@@ -165,9 +170,14 @@
   mutable AtmosphereData mSLAtmos;
   mutable Vector6 mAirSpeed;
   mutable Vector3 mMach;
+  mutable real_type mMachNumber;
   mutable real_type mAltitude;
   mutable real_type mAboveGroundLevel;
+  mutable real_type mWingSpanOver2Speed;
+  mutable real_type mCoordOver2Speed;
+  mutable real_type mHOverWingSpan;
   mutable real_type mTrueSpeed;
+  mutable real_type mTrueSpeedUW;
   mutable real_type mCalibratedAirSpeed;
   mutable real_type mEquivalentAirSpeed;
   mutable real_type mDynamicPressure;



From frohlich at berlios.de  Sat Dec 31 14:24:06 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Sat, 31 Dec 2005 14:24:06 +0100
Subject: [OpenFDM-svn] r150 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200512311324.jBVDO6YW024365@sheep.berlios.de>

Author: frohlich
Date: 2005-12-31 14:24:02 +0100 (Sat, 31 Dec 2005)
New Revision: 150

Modified:
   trunk/OpenFDM/src/OpenFDM/Model.h
Log:
Add convenience methods to add output ports


Modified: trunk/OpenFDM/src/OpenFDM/Model.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Model.h	2005-12-31 11:31:20 UTC (rev 149)
+++ trunk/OpenFDM/src/OpenFDM/Model.h	2005-12-31 13:24:02 UTC (rev 150)
@@ -165,6 +165,22 @@
                      const Matrix& (M::*getter)(void) const)
   { setOutputPort(i, name, new MatrixGetterPortInterface<M>(model, getter)); }
 
+  /// Convenience shortcuts
+  void addOutputPort(const std::string& name, PortInterface* portInterface)
+  {
+    unsigned num = getNumOutputPorts();
+    setNumOutputPorts(num+1);
+    setOutputPort(num, name, portInterface);
+  }
+  template<typename M>
+  void addOutputPort(const std::string& name, M* model,
+                     const real_type& (M::*getter)(void) const)
+  { addOutputPort(name, new RealGetterPortInterface<M>(model, getter)); }
+  template<typename M>
+  void addOutputPort(const std::string& name, M* model,
+                     const Matrix& (M::*getter)(void) const)
+  { addOutputPort(name, new MatrixGetterPortInterface<M>(model, getter)); }
+
   virtual Environment* getEnvironment(void) const;
 
 private:



