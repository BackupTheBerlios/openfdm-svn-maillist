<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [OpenFDM-svn] r375 - in trunk/OpenFDM/src: OpenFDM test
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/openfdm-svn/2008-March/index.html" >
   <LINK REL="made" HREF="mailto:openfdm-svn%40lists.berlios.de?Subject=Re%3A%20%5BOpenFDM-svn%5D%20r375%20-%20in%20trunk/OpenFDM/src%3A%20OpenFDM%20test&In-Reply-To=%3C200803081359.m28DxYvA025212%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000347.html">
   <LINK REL="Next"  HREF="000348.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[OpenFDM-svn] r375 - in trunk/OpenFDM/src: OpenFDM test</H1>
    <B>frohlich at BerliOS</B> 
    <A HREF="mailto:openfdm-svn%40lists.berlios.de?Subject=Re%3A%20%5BOpenFDM-svn%5D%20r375%20-%20in%20trunk/OpenFDM/src%3A%20OpenFDM%20test&In-Reply-To=%3C200803081359.m28DxYvA025212%40sheep.berlios.de%3E"
       TITLE="[OpenFDM-svn] r375 - in trunk/OpenFDM/src: OpenFDM test">frohlich at mail.berlios.de
       </A><BR>
    <I>Sat Mar  8 14:59:34 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000347.html">[OpenFDM-svn] r374 - trunk/OpenFDM/src/test
</A></li>
        <LI>Next message: <A HREF="000348.html">[OpenFDM-svn] r376 - trunk/OpenFDM/src/OpenFDM
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#349">[ date ]</a>
              <a href="thread.html#349">[ thread ]</a>
              <a href="subject.html#349">[ subject ]</a>
              <a href="author.html#349">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: frohlich
Date: 2008-03-08 14:59:33 +0100 (Sat, 08 Mar 2008)
New Revision: 375

Added:
   trunk/OpenFDM/src/OpenFDM/MPFRFloat.h
Modified:
   trunk/OpenFDM/src/OpenFDM/DoPri5.cpp
   trunk/OpenFDM/src/OpenFDM/ExplicitAdams.cpp
   trunk/OpenFDM/src/OpenFDM/Math.h
   trunk/OpenFDM/src/OpenFDM/Types.h
   trunk/OpenFDM/src/OpenFDM/Unit.cpp
   trunk/OpenFDM/src/test/harmonic.cpp
Log:
Add mpfr float type for testing purpose.


Modified: trunk/OpenFDM/src/OpenFDM/DoPri5.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/DoPri5.cpp	2008-03-08 11:32:49 UTC (rev 374)
+++ trunk/OpenFDM/src/OpenFDM/DoPri5.cpp	2008-03-08 13:59:33 UTC (rev 375)
@@ -58,7 +58,7 @@
     real_type rtol = 1e-14;
     real_type en = scaledErr(y7, err, atol, rtol);
 
-    if (1.0 &lt; en)
+    if (1 &lt; en)
       Log(TimeStep, Warning) &lt;&lt; &quot;DOPRI5: error too big: &quot; &lt;&lt; en &lt;&lt; endl;
     else
       Log(TimeStep, Info) &lt;&lt; &quot;DOPRI5: local error: &quot; &lt;&lt; en &lt;&lt; endl;
@@ -99,44 +99,44 @@
 }
 
 // The values of the Runge-Kutta tables
-const real_type DoPri5::a21 = 2.0/10.0;
-const real_type DoPri5::a31 = 3.0/40.0;
-const real_type DoPri5::a32 = 9.0/40.0;
-const real_type DoPri5::a41 = 44.0/45.0;
-const real_type DoPri5::a42 = -56.0/15.0;
-const real_type DoPri5::a43 = 32.0/9.0;
-const real_type DoPri5::a51 = 19372.0/6561.0;
-const real_type DoPri5::a52 = -25360.0/2187.0;
-const real_type DoPri5::a53 = 64448.0/6561.0;
-const real_type DoPri5::a54 = -212.0/729.0;
-const real_type DoPri5::a61 = 9017.0/3168.0;
-const real_type DoPri5::a62 = -355.0/33.0;
-const real_type DoPri5::a63 = 46732.0/5247.0;
-const real_type DoPri5::a64 = 49.0/176.0;
-const real_type DoPri5::a65 = -5103.0/18656.0;
-const real_type DoPri5::a71 = 35.0/384.0;
-const real_type DoPri5::a73 = 500.0/1113.0;
-const real_type DoPri5::a74 = 125.0/192.0;
-const real_type DoPri5::a75 = -2187.0/6784.0;
-const real_type DoPri5::a76 = 11.0/84.0;
+const real_type DoPri5::a21 = real_type(2.0)/real_type(10.0);
+const real_type DoPri5::a31 = real_type(3.0)/real_type(40.0);
+const real_type DoPri5::a32 = real_type(9.0)/real_type(40.0);
+const real_type DoPri5::a41 = real_type(44.0)/real_type(45.0);
+const real_type DoPri5::a42 = real_type(-56.0)/real_type(15.0);
+const real_type DoPri5::a43 = real_type(32.0)/real_type(9.0);
+const real_type DoPri5::a51 = real_type(19372.0)/real_type(6561.0);
+const real_type DoPri5::a52 = real_type(-25360.0)/real_type(2187.0);
+const real_type DoPri5::a53 = real_type(64448.0)/real_type(6561.0);
+const real_type DoPri5::a54 = real_type(-212.0)/real_type(729.0);
+const real_type DoPri5::a61 = real_type(9017.0)/real_type(3168.0);
+const real_type DoPri5::a62 = real_type(-355.0)/real_type(33.0);
+const real_type DoPri5::a63 = real_type(46732.0)/real_type(5247.0);
+const real_type DoPri5::a64 = real_type(49.0)/real_type(176.0);
+const real_type DoPri5::a65 = real_type(-5103.0)/real_type(18656.0);
+const real_type DoPri5::a71 = real_type(35.0)/real_type(384.0);
+const real_type DoPri5::a73 = real_type(500.0)/real_type(1113.0);
+const real_type DoPri5::a74 = real_type(125.0)/real_type(192.0);
+const real_type DoPri5::a75 = real_type(-2187.0)/real_type(6784.0);
+const real_type DoPri5::a76 = real_type(11.0)/real_type(84.0);
 
-const real_type DoPri5::c2 = 2.0/10.0;
-const real_type DoPri5::c3 = 3.0/10.0;
-const real_type DoPri5::c4 = 8.0/10.0;
-const real_type DoPri5::c5 = 8.0/9.0;
+const real_type DoPri5::c2 = real_type(2.0)/real_type(10.0);
+const real_type DoPri5::c3 = real_type(3.0)/real_type(10.0);
+const real_type DoPri5::c4 = real_type(8.0)/real_type(10.0);
+const real_type DoPri5::c5 = real_type(8.0)/real_type(9.0);
 
-const real_type DoPri5::d1 = -12715105075.0/11282082432.0;
-const real_type DoPri5::d3 = 87487479700.0/32700410799.0;
-const real_type DoPri5::d4 = -10690763975.0/1880347072.0;
-const real_type DoPri5::d5 = 701980252875.0/199316789632.0;
-const real_type DoPri5::d6 = -1453857185.0/822651844.0;
-const real_type DoPri5::d7 = 69997945.0/29380423.0;
+const real_type DoPri5::d1 = real_type(-12715105075.0)/real_type(11282082432.0);
+const real_type DoPri5::d3 = real_type(87487479700.0)/real_type(32700410799.0);
+const real_type DoPri5::d4 = real_type(-10690763975.0)/real_type(1880347072.0);
+const real_type DoPri5::d5 = real_type(701980252875.0)/real_type(199316789632.0);
+const real_type DoPri5::d6 = real_type(-1453857185.0)/real_type(822651844.0);
+const real_type DoPri5::d7 = real_type(69997945.0L)/real_type(29380423.0);
 
-const real_type DoPri5::e1 = 71.0/57600.0;
-const real_type DoPri5::e3 = -71.0/16695.0;
-const real_type DoPri5::e4 = 71.0/1920.0;
-const real_type DoPri5::e5 = -17253.0/339200.0;
-const real_type DoPri5::e6 = 22.0/525.0;
-const real_type DoPri5::e7 = -1.0/40.0;
+const real_type DoPri5::e1 = real_type(71.0)/real_type(57600.0);
+const real_type DoPri5::e3 = real_type(-71.0)/real_type(16695.0);
+const real_type DoPri5::e4 = real_type(71.0)/real_type(1920.0);
+const real_type DoPri5::e5 = real_type(-17253.0)/real_type(339200.0);
+const real_type DoPri5::e6 = real_type(22.0)/real_type(525.0);
+const real_type DoPri5::e7 = real_type(-1.0)/real_type(40.0);
 
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/ExplicitAdams.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/ExplicitAdams.cpp	2008-03-08 11:32:49 UTC (rev 374)
+++ trunk/OpenFDM/src/OpenFDM/ExplicitAdams.cpp	2008-03-08 13:59:33 UTC (rev 375)
@@ -12,19 +12,19 @@
 ExplicitAdams::ExplicitAdams(void)
 {
   // Initialize the coeficients for the explicit adams methods
-  mCoefs[0][0] =  static_cast&lt;real_type&gt;(1);
+  mCoefs[0][0] =  real_type(1);
 
-  mCoefs[1][0] =  static_cast&lt;real_type&gt;(3)/static_cast&lt;real_type&gt;(2);
-  mCoefs[1][1] = -static_cast&lt;real_type&gt;(1)/static_cast&lt;real_type&gt;(2);
+  mCoefs[1][0] =  real_type(3)/real_type(2);
+  mCoefs[1][1] = -real_type(1)/real_type(2);
 
-  mCoefs[2][0] =  static_cast&lt;real_type&gt;(23)/static_cast&lt;real_type&gt;(12);
-  mCoefs[2][1] = -static_cast&lt;real_type&gt;(16)/static_cast&lt;real_type&gt;(12);
-  mCoefs[2][2] =  static_cast&lt;real_type&gt;(5)/static_cast&lt;real_type&gt;(12);
+  mCoefs[2][0] =  real_type(23)/real_type(12);
+  mCoefs[2][1] = -real_type(16)/real_type(12);
+  mCoefs[2][2] =  real_type(5)/real_type(12);
 
-  mCoefs[3][0] =  static_cast&lt;real_type&gt;(55)/static_cast&lt;real_type&gt;(24);
-  mCoefs[3][1] = -static_cast&lt;real_type&gt;(59)/static_cast&lt;real_type&gt;(24);
-  mCoefs[3][2] =  static_cast&lt;real_type&gt;(37)/static_cast&lt;real_type&gt;(24);
-  mCoefs[3][3] = -static_cast&lt;real_type&gt;(9)/static_cast&lt;real_type&gt;(24);
+  mCoefs[3][0] =  real_type(55)/real_type(24);
+  mCoefs[3][1] = -real_type(59)/real_type(24);
+  mCoefs[3][2] =  real_type(37)/real_type(24);
+  mCoefs[3][3] = -real_type(9)/real_type(24);
 
   mOrder = 1;
   mMaxOrder = MaxAvailOrder;

Added: trunk/OpenFDM/src/OpenFDM/MPFRFloat.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/MPFRFloat.h	2008-03-08 11:32:49 UTC (rev 374)
+++ trunk/OpenFDM/src/OpenFDM/MPFRFloat.h	2008-03-08 13:59:33 UTC (rev 375)
@@ -0,0 +1,1152 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_MPFloat_H
+#define OpenFDM_MPFloat_H
+
+#include &lt;cstring&gt;
+#include &lt;iostream&gt;
+#include &lt;mpfr.h&gt;
+
+namespace OpenFDM {
+
+/// Class for a floating point type that uses mpfr with an fixed but huge
+/// precision. This is just for doing test of the numeric included algorithms.
+/// Never use that for realtime simulations ...
+
+class MPFRFloat;
+
+#define _BINARY_OPERATOR_DECL(qualifier, ret, op)                           \
+qualifier ret                                                               \
+operator op(const MPFRFloat&amp; value1, const MPFRFloat&amp; value2);              \
+qualifier ret                                                               \
+operator op(const MPFRFloat&amp; value1, const float&amp; value2);                  \
+qualifier ret                                                               \
+operator op(const float&amp; value1, const MPFRFloat&amp; value2);                  \
+qualifier ret                                                               \
+operator op(const MPFRFloat&amp; value1, const double&amp; value2);                 \
+qualifier ret                                                               \
+operator op(const double&amp; value1, const MPFRFloat&amp; value2);                 \
+qualifier ret                                                               \
+operator op(const MPFRFloat&amp; value1, const long double&amp; value2);            \
+qualifier ret                                                               \
+operator op(const long double&amp; value1, const MPFRFloat&amp; value2);            \
+qualifier ret                                                               \
+operator op(const MPFRFloat&amp; value1, const signed char&amp; value2);            \
+qualifier ret                                                               \
+operator op(const MPFRFloat&amp; value1, const signed short&amp; value2);           \
+qualifier ret                                                               \
+operator op(const MPFRFloat&amp; value1, const signed int&amp; value2);             \
+qualifier ret                                                               \
+operator op(const MPFRFloat&amp; value1, const signed long&amp; value2);            \
+qualifier ret                                                               \
+operator op(const MPFRFloat&amp; value1, const unsigned char&amp; value2);          \
+qualifier ret                                                               \
+operator op(const MPFRFloat&amp; value1, const unsigned short&amp; value2);         \
+qualifier ret                                                               \
+operator op(const MPFRFloat&amp; value1, const unsigned int&amp; value2);           \
+qualifier ret                                                               \
+operator op(const MPFRFloat&amp; value1, const unsigned long&amp; value2);          \
+qualifier ret                                                               \
+operator op(const signed char&amp; value1, const MPFRFloat&amp; value2);            \
+qualifier ret                                                               \
+operator op(const signed short&amp; value1, const MPFRFloat&amp; value2);           \
+qualifier ret                                                               \
+operator op(const signed int&amp; value1, const MPFRFloat&amp; value2);             \
+qualifier ret                                                               \
+operator op(const signed long&amp; value1, const MPFRFloat&amp; value2);            \
+qualifier ret                                                               \
+operator op(const unsigned char&amp; value1, const MPFRFloat&amp; value2);          \
+qualifier ret                                                               \
+operator op(const unsigned short&amp; value1, const MPFRFloat&amp; value2);         \
+qualifier ret                                                               \
+operator op(const unsigned int&amp; value1, const MPFRFloat&amp; value2);           \
+qualifier ret                                                               \
+operator op(const unsigned long&amp; value1, const MPFRFloat&amp; value2);
+
+_BINARY_OPERATOR_DECL(inline,MPFRFloat,+)
+_BINARY_OPERATOR_DECL(inline,MPFRFloat,-)
+_BINARY_OPERATOR_DECL(inline,MPFRFloat,*)
+_BINARY_OPERATOR_DECL(inline,MPFRFloat,/)
+_BINARY_OPERATOR_DECL(inline,bool,==)
+_BINARY_OPERATOR_DECL(inline,bool,!=)
+_BINARY_OPERATOR_DECL(inline,bool,&lt;)
+_BINARY_OPERATOR_DECL(inline,bool,&lt;=)
+_BINARY_OPERATOR_DECL(inline,bool,&gt;)
+_BINARY_OPERATOR_DECL(inline,bool,&gt;=)
+
+#define _FUNCTIONS_DECL(qualifier)                                           \
+qualifier MPFRFloat abs(const MPFRFloat&amp; value);                             \
+qualifier MPFRFloat acos(const MPFRFloat&amp; value);                            \
+qualifier MPFRFloat asin(const MPFRFloat&amp; value);                            \
+qualifier MPFRFloat atan(const MPFRFloat&amp; value);                            \
+qualifier MPFRFloat atan2(const MPFRFloat&amp; value1, const MPFRFloat&amp; value2); \
+qualifier MPFRFloat ceil(const MPFRFloat&amp; value);                            \
+qualifier MPFRFloat cos(const MPFRFloat&amp; value);                             \
+qualifier MPFRFloat cosh(const MPFRFloat&amp; value);                            \
+qualifier MPFRFloat exp(const MPFRFloat&amp; value);                             \
+qualifier MPFRFloat fabs(const MPFRFloat&amp; value);                            \
+qualifier MPFRFloat floor(const MPFRFloat&amp; value);                           \
+qualifier MPFRFloat fmod(const MPFRFloat&amp; value1, const MPFRFloat&amp; value2);  \
+qualifier MPFRFloat frexp(const MPFRFloat&amp; value1, int * value2);            \
+qualifier MPFRFloat ldexp(const MPFRFloat&amp; value1, int value2);              \
+qualifier MPFRFloat log(const MPFRFloat&amp; value);                             \
+qualifier MPFRFloat log10(const MPFRFloat&amp; value);                           \
+qualifier MPFRFloat pow(const MPFRFloat&amp; value1, const MPFRFloat&amp; value2);   \
+qualifier MPFRFloat sin(const MPFRFloat&amp; value);                             \
+qualifier MPFRFloat sinh(const MPFRFloat&amp; value);                            \
+qualifier MPFRFloat sqrt(const MPFRFloat&amp; value);                            \
+qualifier MPFRFloat tan(const MPFRFloat&amp; value);                             \
+qualifier MPFRFloat tanh(const MPFRFloat&amp; value);                            \
+qualifier int isfinite(const MPFRFloat&amp; value);                              \
+qualifier MPFRFloat copysign(const MPFRFloat&amp; value1, const MPFRFloat&amp; value2);\
+template&lt;typename char_t, typename traits_t&gt;                                 \
+qualifier                                                                    \
+std::basic_ostream&lt;char_t, traits_t&gt;&amp;                                        \
+operator&lt;&lt;(std::basic_ostream&lt;char_t, traits_t&gt;&amp; os, const MPFRFloat&amp; f);    \
+template&lt;typename char_t, typename traits_t&gt;                                 \
+qualifier                                                                    \
+std::basic_istream&lt;char_t, traits_t&gt;&amp;                                        \
+operator&gt;&gt;(std::basic_istream&lt;char_t, traits_t&gt;&amp; os, MPFRFloat&amp; f);
+
+_FUNCTIONS_DECL(inline)
+
+class MPFRFloat {
+public:
+  MPFRFloat()
+  { mpfr_init2(_value, prec()); }
+  MPFRFloat(const MPFRFloat&amp; value)
+  { mpfr_init2(_value, prec()); mpfr_set(_value, value._value, rm()); }
+  MPFRFloat(const float&amp; d)
+  { mpfr_init2(_value, prec()); mpfr_set_d(_value, d, rm()); }
+  MPFRFloat(const double&amp; d)
+  { mpfr_init2(_value, prec()); mpfr_set_d(_value, d, rm()); }
+  MPFRFloat(const long double&amp; ld)
+  { mpfr_init2(_value, prec()); mpfr_set_ld(_value, ld, rm()); }
+  MPFRFloat(const bool&amp; si)
+  { mpfr_init2(_value, prec()); mpfr_set_si(_value, si, rm()); }
+  MPFRFloat(const signed char&amp; si)
+  { mpfr_init2(_value, prec()); mpfr_set_si(_value, si, rm()); }
+  MPFRFloat(const short&amp; si)
+  { mpfr_init2(_value, prec()); mpfr_set_si(_value, si, rm()); }
+  MPFRFloat(const int&amp; si)
+  { mpfr_init2(_value, prec()); mpfr_set_si(_value, si, rm()); }
+  MPFRFloat(const long&amp; si)
+  { mpfr_init2(_value, prec()); mpfr_set_si(_value, si, rm()); }
+  MPFRFloat(const unsigned char&amp; ui)
+  { mpfr_init2(_value, prec()); mpfr_set_ui(_value, ui, rm()); }
+  MPFRFloat(const unsigned short&amp; ui)
+  { mpfr_init2(_value, prec()); mpfr_set_ui(_value, ui, rm()); }
+  MPFRFloat(const unsigned int&amp; ui)
+  { mpfr_init2(_value, prec()); mpfr_set_ui(_value, ui, rm()); }
+  MPFRFloat(const unsigned long&amp; ui)
+  { mpfr_init2(_value, prec()); mpfr_set_ui(_value, ui, rm()); }
+  explicit MPFRFloat(const char* str)
+  {
+    mpfr_init2(_value, prec());
+    mpfr_set_str(_value, str, std::strlen(str), rm());
+  }
+  explicit MPFRFloat(const std::string&amp; str)
+  {
+    mpfr_init2(_value, prec());
+    mpfr_set_str(_value, str.c_str(), str.size(), rm());
+  }
+  ~MPFRFloat()
+  { mpfr_clear(_value); }
+
+  MPFRFloat&amp; operator=(const MPFRFloat&amp; value)
+  { mpfr_set(_value, value._value, rm()); return *this; }
+  MPFRFloat&amp; operator=(const bool&amp; si)
+  { mpfr_set_si(_value, si, rm()); return *this; }
+  MPFRFloat&amp; operator=(const signed char&amp; si)
+  { mpfr_set_si(_value, si, rm()); return *this; }
+  MPFRFloat&amp; operator=(const short&amp; si)
+  { mpfr_set_si(_value, si, rm()); return *this; }
+  MPFRFloat&amp; operator=(const int&amp; si)
+  { mpfr_set_si(_value, si, rm()); return *this; }
+  MPFRFloat&amp; operator=(const long&amp; si)
+  { mpfr_set_si(_value, si, rm()); return *this; }
+  MPFRFloat&amp; operator=(const unsigned char&amp; ui)
+  { mpfr_set_ui(_value, ui, rm()); return *this; }
+  MPFRFloat&amp; operator=(const unsigned short&amp; ui)
+  { mpfr_set_ui(_value, ui, rm()); return *this; }
+  MPFRFloat&amp; operator=(const unsigned int&amp; ui)
+  { mpfr_set_ui(_value, ui, rm()); return *this; }
+  MPFRFloat&amp; operator=(const unsigned long&amp; ui)
+  { mpfr_set_ui(_value, ui, rm()); return *this; }
+  MPFRFloat&amp; operator=(const float&amp; d)
+  { mpfr_set_d(_value, d, rm()); return *this; }
+  MPFRFloat&amp; operator=(const double&amp; d)
+  { mpfr_set_d(_value, d, rm()); return *this; }
+  MPFRFloat&amp; operator=(const long double&amp; ld)
+  { mpfr_set_ld(_value, ld, rm()); return *this; }
+  MPFRFloat&amp; operator=(const char* str)
+  { mpfr_set_str(_value, str, std::strlen(str), rm()); return *this; }
+  MPFRFloat&amp; operator=(const std::string&amp; str)
+  { mpfr_set_str(_value, str.c_str(), str.size(), rm()); return *this; }
+
+  operator bool() const
+  { return mpfr_cmp_si(_value, 0); }
+  operator signed char() const
+  { return mpfr_get_si(_value, rm()); }
+  operator short() const
+  { return mpfr_get_si(_value, rm()); }
+  operator int() const
+  { return mpfr_get_si(_value, rm()); }
+  operator long() const
+  { return mpfr_get_si(_value, rm()); }
+  operator unsigned char() const
+  { return mpfr_get_ui(_value, rm()); }
+  operator unsigned short() const
+  { return mpfr_get_ui(_value, rm()); }
+  operator unsigned long() const
+  { return mpfr_get_ui(_value, rm()); }
+  operator unsigned int() const
+  { return mpfr_get_ui(_value, rm()); }
+  operator float() const
+  { return mpfr_get_d(_value, rm()); }
+  operator double() const
+  { return mpfr_get_d(_value, rm()); }
+  operator long double() const
+  { return mpfr_get_ld(_value, rm()); }
+
+#define _INPLACE_OPERATOR(op, mop)                                  \
+  MPFRFloat&amp; operator op(const MPFRFloat&amp; value)                    \
+  { mpfr_##mop(_value, _value, value._value, rm()); return *this; } \
+  MPFRFloat&amp; operator op(const bool&amp; value)                         \
+  { mpfr_##mop##_si(_value, _value, value, rm()); return *this; }   \
+  MPFRFloat&amp; operator op(const signed char&amp; value)                  \
+  { mpfr_##mop##_si(_value, _value, value, rm()); return *this; }   \
+  MPFRFloat&amp; operator op(const signed short&amp; value)                 \
+  { mpfr_##mop##_si(_value, _value, value, rm()); return *this; }   \
+  MPFRFloat&amp; operator op(const int&amp; value)                          \
+  { mpfr_##mop##_si(_value, _value, value, rm()); return *this; }   \
+  MPFRFloat&amp; operator op(const long&amp; value)                         \
+  { mpfr_##mop##_si(_value, _value, value, rm()); return *this; }   \
+  MPFRFloat&amp; operator op(const unsigned char&amp; value)                \
+  { mpfr_##mop##_ui(_value, _value, value, rm()); return *this; }   \
+  MPFRFloat&amp; operator op(const unsigned short&amp; value)               \
+  { mpfr_##mop##_ui(_value, _value, value, rm()); return *this; }   \
+  MPFRFloat&amp; operator op(const unsigned int&amp; value)                 \
+  { mpfr_##mop##_ui(_value, _value, value, rm()); return *this; }   \
+  MPFRFloat&amp; operator op(const unsigned long&amp; value)                \
+  { mpfr_##mop##_ui(_value, _value, value, rm()); return *this; }   \
+  MPFRFloat&amp; operator op(const float&amp; value)                        \
+  { return operator op(MPFRFloat(value)); }                         \
+  MPFRFloat&amp; operator op(const double&amp; value)                       \
+  { return operator op(MPFRFloat(value)); }                         \
+  MPFRFloat&amp; operator op(const long double&amp; value)                  \
+  { return operator op(MPFRFloat(value)); }
+
+  _INPLACE_OPERATOR(+=, add)
+  _INPLACE_OPERATOR(-=, sub)
+  _INPLACE_OPERATOR(*=, mul)
+  _INPLACE_OPERATOR(/=, div)
+#undef _INPLACE_OPERATOR
+
+  MPFRFloat operator-() const
+  {
+    mpfr_t tmp;
+    mpfr_init2(tmp, prec());
+    mpfr_neg(tmp, _value, rm());
+    return MPFRFloat(tmp);
+  }
+
+  static mpfr_rnd_t rm() { return GMP_RNDN; }
+  static mpfr_prec_t prec() { return 128; }
+
+  static MPFRFloat pi()
+  {
+    mpfr_t tmp;
+    mpfr_init2(tmp, MPFRFloat::prec());
+    mpfr_const_pi(tmp, rm());
+    return MPFRFloat(tmp);
+  }
+  static MPFRFloat euler()
+  {
+    mpfr_t tmp;
+    mpfr_init2(tmp, MPFRFloat::prec());
+    mpfr_const_euler(tmp, rm());
+    return MPFRFloat(tmp);
+  }
+  static MPFRFloat infinity()
+  {
+    mpfr_t tmp;
+    mpfr_init2(tmp, MPFRFloat::prec());
+    mpfr_set_inf(tmp, 1);
+    return MPFRFloat(tmp);
+  }
+  static MPFRFloat NaN()
+  {
+    mpfr_t tmp;
+    mpfr_init2(tmp, MPFRFloat::prec());
+    mpfr_set_nan(tmp);
+    return MPFRFloat(tmp);
+  }
+
+private:
+  _BINARY_OPERATOR_DECL(friend,MPFRFloat,+)
+  _BINARY_OPERATOR_DECL(friend,MPFRFloat,-)
+  _BINARY_OPERATOR_DECL(friend,MPFRFloat,*)
+  _BINARY_OPERATOR_DECL(friend,MPFRFloat,/)
+  _BINARY_OPERATOR_DECL(friend,bool,==)
+  _BINARY_OPERATOR_DECL(friend,bool,!=)
+  _BINARY_OPERATOR_DECL(friend,bool,&lt;)
+  _BINARY_OPERATOR_DECL(friend,bool,&lt;=)
+  _BINARY_OPERATOR_DECL(friend,bool,&gt;)
+  _BINARY_OPERATOR_DECL(friend,bool,&gt;=)
+  _FUNCTIONS_DECL(friend)
+
+  MPFRFloat(const mpfr_t value) { _value[0] = value[0]; }
+  mpfr_t _value;
+};
+
+#undef _BINARY_OPERATOR_DECL
+#undef _FUNCTIONS_DECL
+
+#define _BINARY_OPERATOR_FPFP(op, mop)                                      \
+inline MPFRFloat                                                            \
+operator op(const MPFRFloat&amp; value1, const MPFRFloat&amp; value2)               \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init2(tmp, MPFRFloat::prec());                                       \
+  mpfr_##mop(tmp, value1._value, value2._value, MPFRFloat::rm());           \
+  return MPFRFloat(tmp);                                                    \
+}                                                                           \
+inline MPFRFloat                                                            \
+operator op(const MPFRFloat&amp; value1, const float&amp; value2)                   \
+{                                                                           \
+  mpfr_t tmp1;                                                              \
+  mpfr_init_set_d(tmp1, value2, MPFRFloat::rm());                           \
+  mpfr_t tmp2;                                                              \
+  mpfr_init2(tmp2, MPFRFloat::prec());                                      \
+  mpfr_##mop(tmp2, value1._value, tmp1, MPFRFloat::rm());                   \
+  mpfr_clear(tmp1);                                                         \
+  return MPFRFloat(tmp2);                                                   \
+}                                                                           \
+inline MPFRFloat                                                            \
+operator op(const float&amp; value1, const MPFRFloat&amp; value2)                   \
+{                                                                           \
+  mpfr_t tmp1;                                                              \
+  mpfr_init_set_d(tmp1, value1, MPFRFloat::rm());                           \
+  mpfr_t tmp2;                                                              \
+  mpfr_init2(tmp2, MPFRFloat::prec());                                      \
+  mpfr_##mop(tmp2, tmp1, value2._value, MPFRFloat::rm());                   \
+  mpfr_clear(tmp1);                                                         \
+  return MPFRFloat(tmp2);                                                   \
+}                                                                           \
+inline MPFRFloat                                                            \
+operator op(const MPFRFloat&amp; value1, const double&amp; value2)                  \
+{                                                                           \
+  mpfr_t tmp1;                                                              \
+  mpfr_init_set_d(tmp1, value2, MPFRFloat::rm());                           \
+  mpfr_t tmp2;                                                              \
+  mpfr_init2(tmp2, MPFRFloat::prec());                                      \
+  mpfr_##mop(tmp2, value1._value, tmp1, MPFRFloat::rm());                   \
+  mpfr_clear(tmp1);                                                         \
+  return MPFRFloat(tmp2);                                                   \
+}                                                                           \
+inline MPFRFloat                                                            \
+operator op(const double&amp; value1, const MPFRFloat&amp; value2)                  \
+{                                                                           \
+  mpfr_t tmp1;                                                              \
+  mpfr_init_set_d(tmp1, value1, MPFRFloat::rm());                           \
+  mpfr_t tmp2;                                                              \
+  mpfr_init2(tmp2, MPFRFloat::prec());                                      \
+  mpfr_##mop(tmp2, tmp1, value2._value, MPFRFloat::rm());                   \
+  mpfr_clear(tmp1);                                                         \
+  return MPFRFloat(tmp2);                                                   \
+}                                                                           \
+inline MPFRFloat                                                            \
+operator op(const MPFRFloat&amp; value1, const long double&amp; value2)             \
+{                                                                           \
+  mpfr_t tmp1;                                                              \
+  mpfr_init_set_ld(tmp1, value2, MPFRFloat::rm());                          \
+  mpfr_t tmp2;                                                              \
+  mpfr_init2(tmp2, MPFRFloat::prec());                                      \
+  mpfr_##mop(tmp2, value1._value, tmp1, MPFRFloat::rm());                   \
+  mpfr_clear(tmp1);                                                         \
+  return MPFRFloat(tmp2);                                                   \
+}                                                                           \
+inline MPFRFloat                                                            \
+operator op(const long double&amp; value1, const MPFRFloat&amp; value2)             \
+{                                                                           \
+  mpfr_t tmp1;                                                              \
+  mpfr_init_set_ld(tmp1, value1, MPFRFloat::rm());                          \
+  mpfr_t tmp2;                                                              \
+  mpfr_init2(tmp2, MPFRFloat::prec());                                      \
+  mpfr_##mop(tmp2, tmp1, value2._value, MPFRFloat::rm());                   \
+  mpfr_clear(tmp1);                                                         \
+  return MPFRFloat(tmp2);                                                   \
+}
+
+
+#define _BINARY_OPERATOR_FPI(op, mop)                                       \
+inline MPFRFloat                                                            \
+operator op(const MPFRFloat&amp; value1, const signed char&amp; value2)             \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init2(tmp, MPFRFloat::prec());                                       \
+  mpfr_##mop##_si(tmp, value1._value, value2, MPFRFloat::rm());             \
+  return MPFRFloat(tmp);                                                    \
+}                                                                           \
+inline MPFRFloat                                                            \
+operator op(const MPFRFloat&amp; value1, const signed short&amp; value2)            \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init2(tmp, MPFRFloat::prec());                                       \
+  mpfr_##mop##_si(tmp, value1._value, value2, MPFRFloat::rm());             \
+  return MPFRFloat(tmp);                                                    \
+}                                                                           \
+inline MPFRFloat                                                            \
+operator op(const MPFRFloat&amp; value1, const signed int&amp; value2)              \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init2(tmp, MPFRFloat::prec());                                       \
+  mpfr_##mop##_si(tmp, value1._value, value2, MPFRFloat::rm());             \
+  return MPFRFloat(tmp);                                                    \
+}                                                                           \
+inline MPFRFloat                                                            \
+operator op(const MPFRFloat&amp; value1, const signed long&amp; value2)             \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init2(tmp, MPFRFloat::prec());                                       \
+  mpfr_##mop##_si(tmp, value1._value, value2, MPFRFloat::rm());             \
+  return MPFRFloat(tmp);                                                    \
+}                                                                           \
+inline MPFRFloat                                                            \
+operator op(const MPFRFloat&amp; value1, const unsigned char&amp; value2)           \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init2(tmp, MPFRFloat::prec());                                       \
+  mpfr_##mop##_ui(tmp, value1._value, value2, MPFRFloat::rm());             \
+  return MPFRFloat(tmp);                                                    \
+}                                                                           \
+inline MPFRFloat                                                            \
+operator op(const MPFRFloat&amp; value1, const unsigned short&amp; value2)          \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init2(tmp, MPFRFloat::prec());                                       \
+  mpfr_##mop##_ui(tmp, value1._value, value2, MPFRFloat::rm());             \
+  return MPFRFloat(tmp);                                                    \
+}                                                                           \
+inline MPFRFloat                                                            \
+operator op(const MPFRFloat&amp; value1, const unsigned int&amp; value2)            \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init2(tmp, MPFRFloat::prec());                                       \
+  mpfr_##mop##_ui(tmp, value1._value, value2, MPFRFloat::rm());             \
+  return MPFRFloat(tmp);                                                    \
+}                                                                           \
+inline MPFRFloat                                                            \
+operator op(const MPFRFloat&amp; value1, const unsigned long&amp; value2)           \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init2(tmp, MPFRFloat::prec());                                       \
+  mpfr_##mop##_ui(tmp, value1._value, value2, MPFRFloat::rm());             \
+  return MPFRFloat(tmp);                                                    \
+}
+
+
+#define _SYM_BINARY_OPERATOR_IFP(op, mop)                                   \
+inline MPFRFloat                                                            \
+operator op(const signed char&amp; value1, const MPFRFloat&amp; value2)             \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init2(tmp, MPFRFloat::prec());                                       \
+  mpfr_##mop##_si(tmp, value2._value, value1, MPFRFloat::rm());             \
+  return MPFRFloat(tmp);                                                    \
+}                                                                           \
+inline MPFRFloat                                                            \
+operator op(const signed short&amp; value1, const MPFRFloat&amp; value2)            \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init2(tmp, MPFRFloat::prec());                                       \
+  mpfr_##mop##_si(tmp, value2._value, value1, MPFRFloat::rm());             \
+  return MPFRFloat(tmp);                                                    \
+}                                                                           \
+inline MPFRFloat                                                            \
+operator op(const signed int&amp; value1, const MPFRFloat&amp; value2)              \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init2(tmp, MPFRFloat::prec());                                       \
+  mpfr_##mop##_si(tmp, value2._value, value1, MPFRFloat::rm());             \
+  return MPFRFloat(tmp);                                                    \
+}                                                                           \
+inline MPFRFloat                                                            \
+operator op(const signed long&amp; value1, const MPFRFloat&amp; value2)             \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init2(tmp, MPFRFloat::prec());                                       \
+  mpfr_##mop##_si(tmp, value2._value, value1, MPFRFloat::rm());             \
+  return MPFRFloat(tmp);                                                    \
+}                                                                           \
+inline MPFRFloat                                                            \
+operator op(const unsigned char&amp; value1, const MPFRFloat&amp; value2)           \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init2(tmp, MPFRFloat::prec());                                       \
+  mpfr_##mop##_ui(tmp, value2._value, value1, MPFRFloat::rm());             \
+  return MPFRFloat(tmp);                                                    \
+}                                                                           \
+inline MPFRFloat                                                            \
+operator op(const unsigned short&amp; value1, const MPFRFloat&amp; value2)          \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init2(tmp, MPFRFloat::prec());                                       \
+  mpfr_##mop##_ui(tmp, value2._value, value1, MPFRFloat::rm());             \
+  return MPFRFloat(tmp);                                                    \
+}                                                                           \
+inline MPFRFloat                                                            \
+operator op(const unsigned int&amp; value1, const MPFRFloat&amp; value2)            \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init2(tmp, MPFRFloat::prec());                                       \
+  mpfr_##mop##_ui(tmp, value2._value, value1, MPFRFloat::rm());             \
+  return MPFRFloat(tmp);                                                    \
+}                                                                           \
+inline MPFRFloat                                                            \
+operator op(const unsigned long&amp; value1, const MPFRFloat&amp; value2)           \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init2(tmp, MPFRFloat::prec());                                       \
+  mpfr_##mop##_ui(tmp, value2._value, value1, MPFRFloat::rm());             \
+  return MPFRFloat(tmp);                                                    \
+}
+
+
+#define _UNSYM_BINARY_OPERATOR_IFP(op, mop)                                 \
+inline MPFRFloat                                                            \
+operator op(const signed char&amp; value1, const MPFRFloat&amp; value2)             \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init2(tmp, MPFRFloat::prec());                                       \
+  mpfr_si_##mop(tmp, value1, value2._value, MPFRFloat::rm());               \
+  return MPFRFloat(tmp);                                                    \
+}                                                                           \
+inline MPFRFloat                                                            \
+operator op(const signed short&amp; value1, const MPFRFloat&amp; value2)            \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init2(tmp, MPFRFloat::prec());                                       \
+  mpfr_si_##mop(tmp, value1, value2._value, MPFRFloat::rm());               \
+  return MPFRFloat(tmp);                                                    \
+}                                                                           \
+inline MPFRFloat                                                            \
+operator op(const signed int&amp; value1, const MPFRFloat&amp; value2)              \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init2(tmp, MPFRFloat::prec());                                       \
+  mpfr_si_##mop(tmp, value1, value2._value, MPFRFloat::rm());               \
+  return MPFRFloat(tmp);                                                    \
+}                                                                           \
+inline MPFRFloat                                                            \
+operator op(const signed long&amp; value1, const MPFRFloat&amp; value2)             \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init2(tmp, MPFRFloat::prec());                                       \
+  mpfr_si_##mop(tmp, value1, value2._value, MPFRFloat::rm());               \
+  return MPFRFloat(tmp);                                                    \
+}                                                                           \
+inline MPFRFloat                                                            \
+operator op(const unsigned char&amp; value1, const MPFRFloat&amp; value2)           \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init2(tmp, MPFRFloat::prec());                                       \
+  mpfr_ui_##mop(tmp, value1, value2._value, MPFRFloat::rm());               \
+  return MPFRFloat(tmp);                                                    \
+}                                                                           \
+inline MPFRFloat                                                            \
+operator op(const unsigned short&amp; value1, const MPFRFloat&amp; value2)          \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init2(tmp, MPFRFloat::prec());                                       \
+  mpfr_ui_##mop(tmp, value1, value2._value, MPFRFloat::rm());               \
+  return MPFRFloat(tmp);                                                    \
+}                                                                           \
+inline MPFRFloat                                                            \
+operator op(const unsigned int&amp; value1, const MPFRFloat&amp; value2)            \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init2(tmp, MPFRFloat::prec());                                       \
+  mpfr_ui_##mop(tmp, value1, value2._value, MPFRFloat::rm());               \
+  return MPFRFloat(tmp);                                                    \
+}                                                                           \
+inline MPFRFloat                                                            \
+operator op(const unsigned long&amp; value1, const MPFRFloat&amp; value2)           \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init2(tmp, MPFRFloat::prec());                                       \
+  mpfr_ui_##mop(tmp, value1, value2._value, MPFRFloat::rm());               \
+  return MPFRFloat(tmp);                                                    \
+}
+
+#define _SYM_BINARY_OPERATOR(op, mop) \
+_BINARY_OPERATOR_FPFP(op, mop) \
+_BINARY_OPERATOR_FPI(op, mop) \
+_SYM_BINARY_OPERATOR_IFP(op, mop)
+
+#define _UNSYM_BINARY_OPERATOR(op, mop) \
+_BINARY_OPERATOR_FPFP(op, mop) \
+_BINARY_OPERATOR_FPI(op, mop) \
+_UNSYM_BINARY_OPERATOR_IFP(op, mop)
+
+// now implement ...
+_SYM_BINARY_OPERATOR(+, add)
+_SYM_BINARY_OPERATOR(*, mul)
+_UNSYM_BINARY_OPERATOR(-, sub)
+_UNSYM_BINARY_OPERATOR(/, div)
+
+#undef _BINARY_OPERATOR_FPFP
+#undef _BINARY_OPERATOR_FPI
+#undef _SYM_BINARY_OPERATOR_IFP
+#undef _UNSYM_BINARY_OPERATOR_IFP
+#undef _SYM_BINARY_OPERATOR
+#undef _UNSYM_BINARY_OPERATOR
+
+// Comparison
+#define _COMPARISON_OPERATOR(op, mop)                                       \
+inline bool                                                                 \
+operator op(const MPFRFloat&amp; value1, const MPFRFloat&amp; value2)               \
+{                                                                           \
+  return mpfr_##mop##_p(value1._value, value2._value);                      \
+}                                                                           \
+inline bool                                                                 \
+operator op(const MPFRFloat&amp; value1, const float&amp; value2)                   \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init_set_d(tmp, value2, MPFRFloat::rm());                            \
+  int ret = mpfr_##mop##_p(value1._value, tmp);                             \
+  mpfr_clear(tmp);                                                          \
+  return ret;                                                               \
+}                                                                           \
+inline bool                                                                 \
+operator op(const float&amp; value1, const MPFRFloat&amp; value2)                   \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init_set_d(tmp, value1, MPFRFloat::rm());                            \
+  int ret = mpfr_##mop##_p(tmp, value2._value);                             \
+  mpfr_clear(tmp);                                                          \
+  return ret;                                                               \
+}                                                                           \
+inline bool                                                                 \
+operator op(const MPFRFloat&amp; value1, const double&amp; value2)                  \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init_set_d(tmp, value2, MPFRFloat::rm());                            \
+  int ret = mpfr_##mop##_p(value1._value, tmp);                             \
+  mpfr_clear(tmp);                                                          \
+  return ret;                                                               \
+}                                                                           \
+inline bool                                                                 \
+operator op(const double&amp; value1, const MPFRFloat&amp; value2)                  \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init_set_d(tmp, value1, MPFRFloat::rm());                            \
+  int ret = mpfr_##mop##_p(tmp, value2._value);                             \
+  mpfr_clear(tmp);                                                          \
+  return ret;                                                               \
+}                                                                           \
+inline bool                                                                 \
+operator op(const MPFRFloat&amp; value1, const long double&amp; value2)             \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init_set_ld(tmp, value2, MPFRFloat::rm());                           \
+  int ret = mpfr_##mop##_p(value1._value, tmp);                             \
+  mpfr_clear(tmp);                                                          \
+  return ret;                                                               \
+}                                                                           \
+inline bool                                                                 \
+operator op(const long double&amp; value1, const MPFRFloat&amp; value2)             \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init_set_ld(tmp, value1, MPFRFloat::rm());                           \
+  int ret = mpfr_##mop##_p(tmp, value2._value);                             \
+  mpfr_clear(tmp);                                                          \
+  return ret;                                                               \
+}                                                                           \
+inline bool                                                                 \
+operator op(const MPFRFloat&amp; value1, const signed char&amp; value2)             \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init_set_si(tmp, value2, MPFRFloat::rm());                           \
+  int ret = mpfr_##mop##_p(value1._value, tmp);                             \
+  mpfr_clear(tmp);                                                          \
+  return ret;                                                               \
+}                                                                           \
+inline bool                                                                 \
+operator op(const MPFRFloat&amp; value1, const signed short&amp; value2)            \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init_set_si(tmp, value2, MPFRFloat::rm());                           \
+  int ret = mpfr_##mop##_p(value1._value, tmp);                             \
+  mpfr_clear(tmp);                                                          \
+  return ret;                                                               \
+}                                                                           \
+inline bool                                                                 \
+operator op(const MPFRFloat&amp; value1, const signed int&amp; value2)              \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init_set_si(tmp, value2, MPFRFloat::rm());                           \
+  int ret = mpfr_##mop##_p(value1._value, tmp);                             \
+  mpfr_clear(tmp);                                                          \
+  return ret;                                                               \
+}                                                                           \
+inline bool                                                                 \
+operator op(const MPFRFloat&amp; value1, const signed long&amp; value2)             \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init_set_si(tmp, value2, MPFRFloat::rm());                           \
+  int ret = mpfr_##mop##_p(value1._value, tmp);                             \
+  mpfr_clear(tmp);                                                          \
+  return ret;                                                               \
+}                                                                           \
+inline bool                                                                 \
+operator op(const MPFRFloat&amp; value1, const unsigned char&amp; value2)           \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init_set_ui(tmp, value2, MPFRFloat::rm());                           \
+  int ret = mpfr_##mop##_p(value1._value, tmp);                             \
+  mpfr_clear(tmp);                                                          \
+  return ret;                                                               \
+}                                                                           \
+inline bool                                                                 \
+operator op(const MPFRFloat&amp; value1, const unsigned short&amp; value2)          \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init_set_ui(tmp, value2, MPFRFloat::rm());                           \
+  int ret = mpfr_##mop##_p(value1._value, tmp);                             \
+  mpfr_clear(tmp);                                                          \
+  return ret;                                                               \
+}                                                                           \
+inline bool                                                                 \
+operator op(const MPFRFloat&amp; value1, const unsigned int&amp; value2)            \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init_set_ui(tmp, value2, MPFRFloat::rm());                           \
+  int ret = mpfr_##mop##_p(value1._value, tmp);                             \
+  mpfr_clear(tmp);                                                          \
+  return ret;                                                               \
+}                                                                           \
+inline bool                                                                 \
+operator op(const MPFRFloat&amp; value1, const unsigned long&amp; value2)           \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init_set_ui(tmp, value2, MPFRFloat::rm());                           \
+  int ret = mpfr_##mop##_p(value1._value, tmp);                             \
+  mpfr_clear(tmp);                                                          \
+  return ret;                                                               \
+}                                                                           \
+inline bool                                                                 \
+operator op(const signed char&amp; value1, const MPFRFloat&amp; value2)             \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init_set_si(tmp, value1, MPFRFloat::rm());                           \
+  int ret = mpfr_##mop##_p(tmp, value2._value);                             \
+  mpfr_clear(tmp);                                                          \
+  return ret;                                                               \
+}                                                                           \
+inline bool                                                                 \
+operator op(const signed short&amp; value1, const MPFRFloat&amp; value2)            \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init_set_si(tmp, value1, MPFRFloat::rm());                           \
+  int ret = mpfr_##mop##_p(tmp, value2._value);                             \
+  mpfr_clear(tmp);                                                          \
+  return ret;                                                               \
+}                                                                           \
+inline bool                                                                 \
+operator op(const signed int&amp; value1, const MPFRFloat&amp; value2)              \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init_set_si(tmp, value1, MPFRFloat::rm());                           \
+  int ret = mpfr_##mop##_p(tmp, value2._value);                             \
+  mpfr_clear(tmp);                                                          \
+  return ret;                                                               \
+}                                                                           \
+inline bool                                                                 \
+operator op(const signed long&amp; value1, const MPFRFloat&amp; value2)             \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init_set_si(tmp, value1, MPFRFloat::rm());                           \
+  int ret = mpfr_##mop##_p(tmp, value2._value);                             \
+  mpfr_clear(tmp);                                                          \
+  return ret;                                                               \
+}                                                                           \
+inline bool                                                                 \
+operator op(const unsigned char&amp; value1, const MPFRFloat&amp; value2)           \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init_set_ui(tmp, value1, MPFRFloat::rm());                           \
+  int ret = mpfr_##mop##_p(tmp, value2._value);                             \
+  mpfr_clear(tmp);                                                          \
+  return ret;                                                               \
+}                                                                           \
+inline bool                                                                 \
+operator op(const unsigned short&amp; value1, const MPFRFloat&amp; value2)          \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init_set_ui(tmp, value1, MPFRFloat::rm());                           \
+  int ret = mpfr_##mop##_p(tmp, value2._value);                             \
+  mpfr_clear(tmp);                                                          \
+  return ret;                                                               \
+}                                                                           \
+inline bool                                                                 \
+operator op(const unsigned int&amp; value1, const MPFRFloat&amp; value2)            \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init_set_ui(tmp, value1, MPFRFloat::rm());                           \
+  int ret = mpfr_##mop##_p(tmp, value2._value);                             \
+  mpfr_clear(tmp);                                                          \
+  return ret;                                                               \
+}                                                                           \
+inline bool                                                                 \
+operator op(const unsigned long&amp; value1, const MPFRFloat&amp; value2)           \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init_set_ui(tmp, value1, MPFRFloat::rm());                           \
+  int ret = mpfr_##mop##_p(tmp, value2._value);                             \
+  mpfr_clear(tmp);                                                          \
+  return ret;                                                               \
+}
+
+// now implement ...
+_COMPARISON_OPERATOR(==, equal)
+_COMPARISON_OPERATOR(!=, lessgreater)
+_COMPARISON_OPERATOR(&lt;, less)
+_COMPARISON_OPERATOR(&lt;=, lessequal)
+_COMPARISON_OPERATOR(&gt;, greater)
+_COMPARISON_OPERATOR(&gt;=, greaterequal)
+
+#undef _COMPARISON_OPERATOR
+
+inline
+MPFRFloat
+abs(const MPFRFloat&amp; value)
+{
+  mpfr_t tmp;
+  mpfr_init2(tmp, MPFRFloat::prec());
+  mpfr_abs(tmp, value._value, MPFRFloat::rm());
+  return MPFRFloat(tmp);
+}
+
+inline
+MPFRFloat
+acos(const MPFRFloat&amp; value)
+{
+  mpfr_t tmp;
+  mpfr_init2(tmp, MPFRFloat::prec());
+  mpfr_acos(tmp, value._value, MPFRFloat::rm());
+  return MPFRFloat(tmp);
+}
+
+inline
+MPFRFloat
+asin(const MPFRFloat&amp; value)
+{
+  mpfr_t tmp;
+  mpfr_init2(tmp, MPFRFloat::prec());
+  mpfr_asin(tmp, value._value, MPFRFloat::rm());
+  return MPFRFloat(tmp);
+}
+
+inline
+MPFRFloat
+atan(const MPFRFloat&amp; value)
+{
+  mpfr_t tmp;
+  mpfr_init2(tmp, MPFRFloat::prec());
+  mpfr_atan(tmp, value._value, MPFRFloat::rm());
+  return MPFRFloat(tmp);
+}
+
+inline
+MPFRFloat
+atan2(const MPFRFloat&amp; value1, const MPFRFloat&amp; value2)
+{
+  mpfr_t tmp;
+  mpfr_init2(tmp, MPFRFloat::prec());
+  mpfr_atan2(tmp, value1._value, value2._value, MPFRFloat::rm());
+  return MPFRFloat(tmp);
+}
+
+inline
+MPFRFloat
+ceil(const MPFRFloat&amp; value)
+{
+  mpfr_t tmp;
+  mpfr_init2(tmp, MPFRFloat::prec());
+  mpfr_ceil(tmp, value._value);
+  return MPFRFloat(tmp);
+}
+
+inline
+MPFRFloat
+cos(const MPFRFloat&amp; value)
+{
+  mpfr_t tmp;
+  mpfr_init2(tmp, MPFRFloat::prec());
+  mpfr_cos(tmp, value._value, MPFRFloat::rm());
+  return MPFRFloat(tmp);
+}
+
+inline
+MPFRFloat
+cosh(const MPFRFloat&amp; value)
+{
+  mpfr_t tmp;
+  mpfr_init2(tmp, MPFRFloat::prec());
+  mpfr_cosh(tmp, value._value, MPFRFloat::rm());
+  return MPFRFloat(tmp);
+}
+
+inline
+MPFRFloat
+exp(const MPFRFloat&amp; value)
+{
+  mpfr_t tmp;
+  mpfr_init2(tmp, MPFRFloat::prec());
+  mpfr_exp(tmp, value._value, MPFRFloat::rm());
+  return MPFRFloat(tmp);
+}
+
+inline
+MPFRFloat
+fabs(const MPFRFloat&amp; value)
+{
+  mpfr_t tmp;
+  mpfr_init2(tmp, MPFRFloat::prec());
+  mpfr_abs(tmp, value._value, MPFRFloat::rm());
+  return MPFRFloat(tmp);
+}
+
+inline
+MPFRFloat
+floor(const MPFRFloat&amp; value)
+{
+  mpfr_t tmp;
+  mpfr_init2(tmp, MPFRFloat::prec());
+  mpfr_floor(tmp, value._value);
+  return MPFRFloat(tmp);
+}
+
+inline
+MPFRFloat
+fmod(const MPFRFloat&amp; value1, const MPFRFloat&amp; value2)
+{
+  mpfr_t tmp;
+  mpfr_init2(tmp, MPFRFloat::prec());
+  mpfr_remainder(tmp, value1._value, value2._value, MPFRFloat::rm());
+  return MPFRFloat(tmp);
+}
+
+inline
+MPFRFloat
+frexp(const MPFRFloat&amp; value1, int * value2)
+{
+  *value2 = mpfr_get_exp(value1._value);
+  mpfr_t tmp;
+  mpfr_init2(tmp, MPFRFloat::prec());
+  mpfr_set_exp(tmp, -*value2);
+  mpfr_mul(tmp, tmp, value1._value, MPFRFloat::rm());
+  return MPFRFloat(tmp);
+}
+
+inline
+MPFRFloat
+ldexp(const MPFRFloat&amp; value1, int value2)
+{
+  mpfr_t tmp;
+  mpfr_init2(tmp, MPFRFloat::prec());
+  mpfr_set_si(tmp, 1, MPFRFloat::rm());
+  mpfr_set_exp(tmp, value2);
+  mpfr_mul(tmp, tmp, value1._value, MPFRFloat::rm());
+  return MPFRFloat(tmp);
+}
+
+inline
+MPFRFloat
+log(const MPFRFloat&amp; value)
+{
+  mpfr_t tmp; mpfr_init2(tmp, MPFRFloat::prec());
+  mpfr_log(tmp, value._value, MPFRFloat::rm());
+  return MPFRFloat(tmp);
+}
+
+inline
+MPFRFloat
+log10(const MPFRFloat&amp; value)
+{
+  mpfr_t tmp;
+  mpfr_init2(tmp, MPFRFloat::prec());
+  mpfr_log10(tmp, value._value, MPFRFloat::rm());
+  return MPFRFloat(tmp);
+}
+
+inline
+MPFRFloat
+pow(const MPFRFloat&amp; value1, const MPFRFloat&amp; value2)
+{
+  mpfr_t tmp;
+  mpfr_init2(tmp, MPFRFloat::prec());
+  mpfr_pow(tmp, value1._value, value2._value, MPFRFloat::rm());
+  return MPFRFloat(tmp);
+}
+
+inline
+MPFRFloat
+sin(const MPFRFloat&amp; value)
+{
+  mpfr_t tmp;
+  mpfr_init2(tmp, MPFRFloat::prec());
+  mpfr_sin(tmp, value._value, MPFRFloat::rm());
+  return MPFRFloat(tmp);
+}
+
+inline
+MPFRFloat
+sinh(const MPFRFloat&amp; value)
+{
+  mpfr_t tmp;
+  mpfr_init2(tmp, MPFRFloat::prec());
+  mpfr_sinh(tmp, value._value, MPFRFloat::rm());
+  return MPFRFloat(tmp);
+}
+
+inline
+MPFRFloat
+sqrt(const MPFRFloat&amp; value)
+{
+  mpfr_t tmp;
+  mpfr_init2(tmp, MPFRFloat::prec());
+  mpfr_sqrt(tmp, value._value, MPFRFloat::rm());
+  return MPFRFloat(tmp);
+}
+
+inline
+MPFRFloat
+tan(const MPFRFloat&amp; value)
+{
+  mpfr_t tmp;
+  mpfr_init2(tmp, MPFRFloat::prec());
+  mpfr_tan(tmp, value._value, MPFRFloat::rm());
+  return MPFRFloat(tmp);
+}
+
+inline
+MPFRFloat
+tanh(const MPFRFloat&amp; value)
+{
+  mpfr_t tmp;
+  mpfr_init2(tmp, MPFRFloat::prec());
+  mpfr_tanh(tmp, value._value, MPFRFloat::rm());
+  return MPFRFloat(tmp);
+}
+
+// Not stdc++ functions but hopefully present ...
+inline
+int
+isfinite(const MPFRFloat&amp; value)
+{
+  return mpfr_number_p(value._value);
+}
+
+inline
+MPFRFloat
+copysign(const MPFRFloat&amp; value1, const MPFRFloat&amp; value2)
+{
+  mpfr_t tmp;
+  mpfr_init2(tmp, MPFRFloat::prec());
+  mpfr_copysign(tmp, value1._value, value2._value, MPFRFloat::rm());
+  return MPFRFloat(tmp);
+}
+
+template&lt;typename char_t, typename traits_t&gt;
+inline
+std::basic_ostream&lt;char_t, traits_t&gt;&amp;
+operator&lt;&lt;(std::basic_ostream&lt;char_t, traits_t&gt;&amp; os, const MPFRFloat&amp; f)
+{
+  int sign = copysign(f, MPFRFloat(1));
+  if (sign &lt; 0)
+    os &lt;&lt; os.widen('-');
+
+  if (mpfr_nan_p(f._value))
+    return os &lt;&lt; os.widen('N') &lt;&lt; os.widen('a') &lt;&lt; os.widen('N');
+  if (mpfr_inf_p(f._value))
+    return os &lt;&lt; os.widen('i') &lt;&lt; os.widen('n') &lt;&lt; os.widen('f');
+  if (mpfr_zero_p(f._value))
+    return os &lt;&lt; os.widen('0');
+
+  std::streamsize prec = os.precision();
+
+  MPFRFloat tmp = abs(f);
+  mp_exp_t exponent;
+  char* s = mpfr_get_str(0, &amp;exponent, 10 /*base*/,
+                         prec, tmp._value, MPFRFloat::rm());
+
+  if (0 &lt; prec) {
+    os &lt;&lt; os.widen(s[0]);
+    --prec;
+    os &lt;&lt; os.widen('.');
+    for (unsigned i = 1; s[i] &amp;&amp; 0 &lt; prec; ++i) {
+      os &lt;&lt; os.widen(s[i]);
+      --prec;
+    }
+    os &lt;&lt; os.widen('e');
+    os &lt;&lt; exponent-1;
+  }
+  mpfr_free_str(s);
+  return os;
+}
+
+template&lt;typename char_t, typename traits_t&gt;
+inline
+std::basic_istream&lt;char_t, traits_t&gt;&amp;
+operator&gt;&gt;(std::basic_istream&lt;char_t, traits_t&gt;&amp; os, MPFRFloat&amp; f)
+{
+  // FIXME
+  long double tmp;
+  os &gt;&gt; tmp;
+  f = tmp;
+  return os;
+}
+
+template&lt;typename T&gt;
+struct Limits;
+
+template&lt;&gt;
+struct Limits&lt;MPFRFloat&gt; {
+  static MPFRFloat epsilon()
+  { return ldexp(MPFRFloat(1), 2 - MPFRFloat::prec()); }
+  static MPFRFloat min()
+  { return ldexp(MPFRFloat(1), mpfr_get_emin()); }
+  static MPFRFloat safe_min()
+  { return ldexp(MPFRFloat(1), MPFRFloat::prec() + mpfr_get_emin()); }
+  static MPFRFloat max()
+  { return ldexp(2*(MPFRFloat(1) - epsilon()), mpfr_get_emax()); }
+  static MPFRFloat round_error()
+  { return MPFRFloat::rm() == GMP_RNDN ? MPFRFloat(0.5) : MPFRFloat(1); }
+  static MPFRFloat infinity() 
+  { return MPFRFloat::infinity(); }
+  static MPFRFloat quiet_NaN()
+  { return MPFRFloat::NaN(); }
+  static MPFRFloat signaling_NaN()
+  { return MPFRFloat::NaN(); }
+  static MPFRFloat denorm_min()
+  { return min(); /*FIXME*/ }
+};
+
+
+template&lt;typename T&gt;
+struct Constants;
+
+template&lt;&gt;
+struct Constants&lt;MPFRFloat&gt; {
+  static MPFRFloat pi() { return MPFRFloat::pi(); }
+  static MPFRFloat e() { return MPFRFloat::pi(); }
+};
+
+} // namespace OpenFDM
+
+#endif

Modified: trunk/OpenFDM/src/OpenFDM/Math.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Math.h	2008-03-08 11:32:49 UTC (rev 374)
+++ trunk/OpenFDM/src/OpenFDM/Math.h	2008-03-08 13:59:33 UTC (rev 375)
@@ -53,6 +53,12 @@
 using std::max;
 
 template&lt;typename T&gt;
+struct Constants {
+  static T pi() { return T(3.1415926535897932384626433832795029L); }
+  static T e() { return T(2.7182818284590452353602874713526625L); }
+};
+
+template&lt;typename T&gt;
 inline int
 sign(const T&amp; val)
 {
@@ -89,13 +95,10 @@
 inline T
 smoothSaturate(const T&amp; val, const T&amp; saturation)
 {
-  /// FIXME
-#define PI static_cast&lt;T&gt;(3.1415926535897932384626433832795029L)
   if (saturation &lt;= Limits&lt;T&gt;::min())
     return 0;
   else
-    return atan(val*0.5*PI/saturation)*2*saturation/PI;
-#undef PI
+    return atan(val*Constants&lt;T&gt;::pi()/(2*saturation))*2*saturation/Constants&lt;T&gt;::pi();
 }
 
 template&lt;typename T&gt;

Modified: trunk/OpenFDM/src/OpenFDM/Types.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Types.h	2008-03-08 11:32:49 UTC (rev 374)
+++ trunk/OpenFDM/src/OpenFDM/Types.h	2008-03-08 13:59:33 UTC (rev 375)
@@ -5,6 +5,12 @@
 #ifndef OpenFDM_Types_H
 #define OpenFDM_Types_H
 
+#include &quot;OpenFDMConfig.h&quot;
+
+#if defined(OPENFDM_USE_MPFR)
+#include &quot;MPFRFloat.h&quot;
+#endif
+
 namespace OpenFDM {
 
 #if defined(__GNUC__) &amp;&amp; (3 &lt;= __GNUC__)
@@ -32,14 +38,12 @@
 // Definition of real_type.
 // This one is used for *all* real numbers in OpenFDM.
 //
-#if defined(OPENFDM_USE_LONGDOUBLE)
+#if defined(OPENFDM_USE_MPFR)
+typedef MPFRFloat real_type;
+#elif defined(OPENFDM_USE_LONGDOUBLE)
 typedef long double real_type;
-#elif defined(OPENFDM_USE_DOUBLEDOUBLE)
-// I have not tested that, just as an idea ...
-# include &lt;doubledouble.h&gt;
-typedef doubledouble real_type;
 #else
-typedef double OpenFDM_Align_Double real_type;
+typedef double real_type;
 #endif
 
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/Unit.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Unit.cpp	2008-03-08 11:32:49 UTC (rev 374)
+++ trunk/OpenFDM/src/OpenFDM/Unit.cpp	2008-03-08 13:59:33 UTC (rev 375)
@@ -10,21 +10,16 @@
 
 namespace OpenFDM {
 
-#ifdef PI
-#undef PI
-#endif
-#define PI static_cast&lt;real_type&gt;(3.1415926535897932384626433832795029L)
+const real_type pi2 = 2*Constants&lt;real_type&gt;::pi();
+const real_type pi = Constants&lt;real_type&gt;::pi();
+const real_type pi05 = Constants&lt;real_type&gt;::pi()/real_type(2);
+const real_type pi025 = Constants&lt;real_type&gt;::pi()/real_type(4);
 
-const real_type pi2 = 2*PI;
-const real_type pi = PI;
-const real_type pi05 = static_cast&lt;real_type&gt;(0.5L)*PI;
-const real_type pi025 = static_cast&lt;real_type&gt;(0.25L)*PI;
+const real_type deg2rad = Constants&lt;real_type&gt;::pi()/real_type(180);
+const real_type rad2deg = real_type(180)/Constants&lt;real_type&gt;::pi();
 
-const real_type deg2rad = PI/static_cast&lt;real_type&gt;(180);
-const real_type rad2deg = static_cast&lt;real_type&gt;(180)/PI;
-
 // The newtonian gravity constant.
-const real_type gravity_constant = 6.673e-11;
+const real_type gravity_constant = real_type(6.673e-11);
 
 } // namespace OpenFDM
 

Modified: trunk/OpenFDM/src/test/harmonic.cpp
===================================================================
--- trunk/OpenFDM/src/test/harmonic.cpp	2008-03-08 11:32:49 UTC (rev 374)
+++ trunk/OpenFDM/src/test/harmonic.cpp	2008-03-08 13:59:33 UTC (rev 375)
@@ -19,7 +19,7 @@
 int
 main(int argc, char *argv[])
 {
-  real_type omega = 20;
+  real_type omega = 2;
 
   SharedPtr&lt;System&gt; system = new System(&quot;Harmonic Oszilator&quot;);
   system-&gt;addSampleTime(real_type(1)/real_type(100));


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000347.html">[OpenFDM-svn] r374 - trunk/OpenFDM/src/test
</A></li>
	<LI>Next message: <A HREF="000348.html">[OpenFDM-svn] r376 - trunk/OpenFDM/src/OpenFDM
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#349">[ date ]</a>
              <a href="thread.html#349">[ thread ]</a>
              <a href="subject.html#349">[ subject ]</a>
              <a href="author.html#349">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/openfdm-svn">More information about the OpenFDM-svn
mailing list</a><br>
</body></html>
