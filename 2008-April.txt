From frohlich at mail.berlios.de  Tue Apr  1 19:23:44 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Tue, 1 Apr 2008 19:23:44 +0200
Subject: [OpenFDM-svn] r378 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200804011723.m31HNiQk011009@sheep.berlios.de>

Author: frohlich
Date: 2008-04-01 19:23:43 +0200 (Tue, 01 Apr 2008)
New Revision: 378

Modified:
   trunk/OpenFDM/src/OpenFDM/Makefile.am
Log:
Group sources in core and models.


Modified: trunk/OpenFDM/src/OpenFDM/Makefile.am
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Makefile.am	2008-03-19 07:00:10 UTC (rev 377)
+++ trunk/OpenFDM/src/OpenFDM/Makefile.am	2008-04-01 17:23:43 UTC (rev 378)
@@ -7,51 +7,24 @@
 lib_LTLIBRARIES = libOpenFDM.la
 libOpenFDM_la_LIBADD = -lrt
 
-# Will need these at the moment ...
-nobase_OpenFDMinclude_HEADERS = \
-  AeroForce.h \
-  AirSpring.h \
+OpenFDMCoreHEADERS = \
   Assert.h \
-  Atmosphere.h \
-  AtmosphereSTD1976.h \
   Atomic.h \
-  Bias.h \
-  BinaryFunctionModel.h \
-  CartesianActuatorFrame.h \
-  CartesianJointFrame.h \
   Connection.h \
-  Contact.h \
-  ConstModel.h \
   ConstFrameVisitor.h \
   CowPtr.h \
-  DeadBand.h \
-  DefaultGravity.h \
-  DefaultGround.h \
-  DefaultPlanet.h \
-  DiscBrake.h \
-  DiscreteIntegrator.h \
   DoPri5.h \
   Environment.h \
   EnvironmentObject.h \
   ExplicitAdams.h \
   ExplicitEuler.h \
-  ExternalForceModel.h \
-  Force.h \
   Frame.h \
   FrameVisitor.h \
   Function.h \
-  Gain.h \
-  Gravity.h \
-  Ground.h \
   GroupInput.h \
   GroupOutput.h \
-  Input.h \
-  Integrator.h \
-  Interact.h \
   ImplicitEuler.h \
   Inertia.h \
-  Joint.h \
-  Launchbar.h \
   Limits.h \
   LinAlg/Algorithm.h \
   LinAlg/Array.h \
@@ -61,17 +34,12 @@
   LinAlg/IO.h \
   LinAlg/Misc.h \
   LinAlg/Proxy.h \
-  LinearSpringDamper.h \
   LogStream.h \
   Mass.h \
   Math.h \
   Matrix.h \
-  MaxModel.h \
   Newton.h \
   MidpointRule.h \
-  MinModel.h \
-  MobileRootJoint.h \
-  MobileRootJointFrame.h \
   Model.h \
   ModelGroup.h \
   ModelVisitor.h \
@@ -83,138 +51,174 @@
   Object.h \
   ODESolver.h \
   OpenFDMConfig.h \
-  Output.h \
   PhysicalDimension.h \
   Plane.h \
   Planet.h \
   Port.h \
   PortAcceptor.h \
   PortProvider.h \
+  Quaternion.h \
+  ReaderWriter.h \
+  Referenced.h \
+  Rotation.h \
+  SampleTime.h \
+  ScopeLock.h \
+  SharedPtr.h \
+  SimulationTime.h \
+  StateStream.h \
+  System.h \
+  TableData.h \
+  TaskInfo.h \
+  Time.h \
+  Transform.h \
+  TypeInfo.h \
+  Types.h \
+  Unit.h \
+  Variant.h \
+  Vector.h \
+  WeakPtr.h \
+  WeakReferenced.h \
+  XMLDumpModelVisitor.h
+
+OpenFDMCoreSOURCES = \
+  Assert.cpp \
+  Atomic.cpp \
+  Connection.cpp \
+  DoPri5.cpp \
+  Environment.cpp \
+  EnvironmentObject.cpp \
+  ExplicitAdams.cpp \
+  ExplicitEuler.cpp \
+  Frame.cpp \
+  Function.cpp \
+  GroupInput.cpp \
+  GroupOutput.cpp \
+  ImplicitEuler.cpp \
+  Logger.cpp \
+  Mass.cpp \
+  Newton.cpp \
+  MidpointRule.cpp \
+  Model.cpp \
+  ModelGroup.cpp \
+  Object.cpp \
+  ODESolver.cpp \
+  Planet.cpp \
+  Port.cpp \
+  PortAcceptor.cpp \
+  PortProvider.cpp \
+  ReaderWriter.cpp \
+  SampleTime.cpp \
+  SimulationTime.cpp \
+  System.cpp \
+  TaskInfo.cpp \
+  Time.cpp \
+  Unit.cpp \
+  Variant.cpp
+
+OpenFDMModelsHEADERS = \
+  AeroForce.h \
+  AirSpring.h \
+  Atmosphere.h \
+  AtmosphereSTD1976.h \
+  Bias.h \
+  BinaryFunctionModel.h \
+  ConstModel.h \
+  Contact.h \
+  DeadBand.h \
+  DefaultGravity.h \
+  DefaultGround.h \
+  DefaultPlanet.h \
+  DiscBrake.h \
+  DiscreteIntegrator.h \
+  ExternalForceModel.h \
+  Force.h \
+  Gain.h \
+  Gravity.h \
+  Ground.h \
+  Input.h \
+  Integrator.h \
+  Interact.h \
+  Joint.h \
+  Launchbar.h \
+  LinearSpringDamper.h \
+  MaxModel.h \
+  MinModel.h \
+  MobileRootJoint.h \
+  MobileRootJointFrame.h \
+  Output.h \
   Product.h \
   PrismaticJoint.h \
   PrismaticJointFrame.h \
-  Quaternion.h \
-  ReaderWriter.h \
-  Referenced.h \
   RevoluteActuator.h \
   RevoluteActuatorFrame.h \
   RevoluteJoint.h \
   RevoluteJointFrame.h \
   RigidBody.h \
-  Rotation.h \
   RootFrame.h \
-  SampleTime.h \
   Saturation.h \
-  ScopeLock.h \
   Sensor.h \
-  SharedPtr.h \
   SimpleContact.h \
   SimpleGear.h \
-  SimulationTime.h \
-  StateStream.h \
   Summer.h \
-  System.h \
   Table.h \
-  TableData.h \
   Tailhook.h \
   Tank.h \
-  TaskInfo.h \
-  Time.h \
   TimeDerivative.h \
   TransferFunction.h \
-  Transform.h \
   Turbulence.h \
-  TypeInfo.h \
-  Types.h \
   UnaryFunctionModel.h \
-  Unit.h \
-  Variant.h \
-  Vector.h \
   Vehicle.h \
-  WeakPtr.h \
-  WeakReferenced.h \
   WheelContact.h \
-  Wind.h \
-  XMLDumpModelVisitor.h
+  Wind.h
 
-libOpenFDM_la_SOURCES = \
+OpenFDMModelsSOURCES = \
   AeroForce.cpp \
   AirSpring.cpp \
-  Assert.cpp \
   Atmosphere.cpp \
   AtmosphereSTD1976.cpp \
-  Atomic.cpp \
   Bias.cpp \
   BinaryFunctionModel.cpp \
-  Connection.cpp \
+  ConstModel.cpp \
   Contact.cpp \
-  ConstModel.cpp \
   DeadBand.cpp \
   DefaultGravity.cpp \
   DefaultGround.cpp \
   DefaultPlanet.cpp \
   DiscBrake.cpp \
   DiscreteIntegrator.cpp \
-  DoPri5.cpp \
-  Environment.cpp \
-  EnvironmentObject.cpp \
-  ExplicitAdams.cpp \
-  ExplicitEuler.cpp \
   ExternalForceModel.cpp \
   Force.cpp \
-  Frame.cpp \
-  Function.cpp \
   Gain.cpp \
   Gravity.cpp \
   Ground.cpp \
-  GroupInput.cpp \
-  GroupOutput.cpp \
   Input.cpp \
   Integrator.cpp \
   Interact.cpp \
-  ImplicitEuler.cpp \
   Joint.cpp \
   Launchbar.cpp \
   LinearSpringDamper.cpp \
-  Logger.cpp \
-  Mass.cpp \
   MaxModel.cpp \
-  MidpointRule.cpp \
   MinModel.cpp \
   MobileRootJoint.cpp \
-  Model.cpp \
-  ModelGroup.cpp \
-  Newton.cpp \
-  Object.cpp \
-  ODESolver.cpp \
   Output.cpp \
-  Planet.cpp \
-  Port.cpp \
-  PortAcceptor.cpp \
-  PortProvider.cpp \
+  Product.cpp \
   PrismaticJoint.cpp \
-  Product.cpp \
-  ReaderWriter.cpp \
   RevoluteActuator.cpp \
   RevoluteJoint.cpp \
   RigidBody.cpp \
   RootFrame.cpp \
-  SampleTime.cpp \
   Saturation.cpp \
   SimpleContact.cpp \
   SimpleGear.cpp \
-  SimulationTime.cpp \
   Summer.cpp \
-  System.cpp \
   Table.cpp \
   Tailhook.cpp \
   Tank.cpp \
-  TaskInfo.cpp \
-  Time.cpp \
   TimeDerivative.cpp \
   TransferFunction.cpp \
   UnaryFunctionModel.cpp \
-  Unit.cpp \
-  Variant.cpp \
   Vehicle.cpp \
   WheelContact.cpp
+
+nobase_OpenFDMinclude_HEADERS = $(OpenFDMCoreHEADERS) $(OpenFDMModelsHEADERS)
+libOpenFDM_la_SOURCES = $(OpenFDMCoreSOURCES) $(OpenFDMModelsSOURCES)



From frohlich at mail.berlios.de  Sun Apr  6 10:22:57 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 6 Apr 2008 10:22:57 +0200
Subject: [OpenFDM-svn] r379 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200804060822.m368MvgV026658@sheep.berlios.de>

Author: frohlich
Date: 2008-04-06 10:22:56 +0200 (Sun, 06 Apr 2008)
New Revision: 379

Modified:
   trunk/OpenFDM/src/OpenFDM/Time.h
Log:
Improove Time utility for time accounting.


Modified: trunk/OpenFDM/src/OpenFDM/Time.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Time.h	2008-04-01 17:23:43 UTC (rev 378)
+++ trunk/OpenFDM/src/OpenFDM/Time.h	2008-04-06 08:22:56 UTC (rev 379)
@@ -6,11 +6,9 @@
 #define OpenFDM_Time_H
 
 #include <ctime>
-#include <iosfwd>
+#include <istream>
+#include <ostream>
 #include <iomanip>
-#include <sstream>
-// FIXME
-#include <iostream>
 #include "Math.h"
 
 // FIXME move into own tools library.
@@ -55,9 +53,15 @@
   }
   void setTime(const sec_type& sec, const nsec_type& nsec)
   {
-    nsec_type carry = nsec/NanoSecondsPerSecond;
-    _nsec = nsec - NanoSecondsPerSecond*carry;
-    _sec = sec + carry;
+    if (nsec < 0) {
+      nsec_type carry = nsec/NanoSecondsPerSecond - 1;
+      _nsec = nsec - NanoSecondsPerSecond*carry;
+      _sec = sec + carry;
+    } else {
+      nsec_type carry = nsec/NanoSecondsPerSecond;
+      _nsec = nsec - NanoSecondsPerSecond*carry;
+      _sec = sec + carry;
+    }
   }
   const sec_type& getSeconds() const
   { return _sec; }
@@ -115,28 +119,98 @@
 
 inline Time
 operator-(const Time& c1)
-{ Time c(0, 0); c -= c1; return c; /*FIXME*/ }
+{ return Time(0, 0) -= c1; }
 
 inline Time
 operator+(const Time& c1, const Time& c2)
-{ Time c = c1; c += c2; return c; }
+{ return Time(c1) += c2; }
 
 inline Time
 operator-(const Time& c1, const Time& c2)
-{ Time c = c1; c -= c2; return c; }
+{ return Time(c1) -= c2; }
 
-template<typename char_type, typename traits_type> 
+template<typename char_type, typename traits_type>
 inline
 std::basic_ostream<char_type, traits_type>&
 operator<<(std::basic_ostream<char_type, traits_type>& os, const Time& t)
 {
-  std::basic_stringstream<char_type, traits_type> stream;
-  stream << t.getSeconds() << '.'
-         << std::setw(9) << std::right << std::setfill('0')
-         << t.getNanoSeconds();
-  return os << stream.str();
+  if (0 <= t.getSeconds()) {
+    std::basic_stringstream<char_type, traits_type> stream;
+    stream << t.getSeconds() << stream.widen('.')
+           << std::setw(9) << std::right << std::setfill('0')
+           << t.getNanoSeconds();
+    return os << stream.str();
+  } else {
+    return os << os.widen('-') << -t;
+  }
 }
 
+class TimeCounter {
+public:
+  TimeCounter(Time::Type type = Time::CPUTime) :
+    mType(type),
+    mTime(real_type(0)),
+    mRunCounter(0)
+  { }
+  
+  Time getTime() const
+  {
+    if (0 < mRunCounter)
+      return Time::now(mType) + mTime;
+    else
+      return mTime;
+  }
+  
+  void start()
+  {
+    if (1 != ++mRunCounter)
+      return;
+    mTime -= Time::now(mType);
+  }
+  
+  void stop()
+  {
+    if (--mRunCounter != 0)
+      return;
+    mTime += Time::now(mType);
+  }
+  
+private:
+  Time::Type mType;
+  Time mTime;
+  int mRunCounter;
+};
+
+class ScopeTimeCounter {
+public:
+  ScopeTimeCounter(TimeCounter& timer) : mTimeCounter(timer)
+  { mTimeCounter.start(); }
+  ~ScopeTimeCounter(void)
+  { mTimeCounter.stop(); }
+
+private:
+  ScopeTimeCounter(void);
+  ScopeTimeCounter(const ScopeTimeCounter&);
+  ScopeTimeCounter& operator=(const ScopeTimeCounter&);
+
+  TimeCounter& mTimeCounter;
+};
+
+class ScopeUnTimeCounter {
+public:
+  ScopeUnTimeCounter(TimeCounter& timer) : mTimeCounter(timer)
+  { mTimeCounter.stop(); }
+  ~ScopeUnTimeCounter(void)
+  { mTimeCounter.start(); }
+
+private:
+  ScopeUnTimeCounter(void);
+  ScopeUnTimeCounter(const ScopeUnTimeCounter&);
+  ScopeUnTimeCounter& operator=(const ScopeUnTimeCounter&);
+
+  TimeCounter& mTimeCounter;
+};
+
 }
 
 #endif



From frohlich at mail.berlios.de  Tue Apr 15 23:01:18 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Tue, 15 Apr 2008 23:01:18 +0200
Subject: [OpenFDM-svn] r380 - in trunk/OpenFDM/src: OpenFDM test
Message-ID: <200804152101.m3FL1IT2004341@sheep.berlios.de>

Author: frohlich
Date: 2008-04-15 23:01:18 +0200 (Tue, 15 Apr 2008)
New Revision: 380

Added:
   trunk/OpenFDM/src/OpenFDM/FixedRootJoint.cpp
   trunk/OpenFDM/src/OpenFDM/FixedRootJoint.h
   trunk/OpenFDM/src/OpenFDM/FixedRootJointFrame.h
   trunk/OpenFDM/src/test/tiretestrig.cpp
Modified:
   trunk/OpenFDM/src/OpenFDM/Makefile.am
   trunk/OpenFDM/src/test/Makefile.am
Log:
First attempt for model testing.

A    src/test/tiretestrig.cpp
M    src/test/Makefile.am
A    src/OpenFDM/FixedRootJoint.h
M    src/OpenFDM/Makefile.am
A    src/OpenFDM/FixedRootJoint.cpp
A    src/OpenFDM/FixedRootJointFrame.h


Added: trunk/OpenFDM/src/OpenFDM/FixedRootJoint.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/FixedRootJoint.cpp	2008-04-06 08:22:56 UTC (rev 379)
+++ trunk/OpenFDM/src/OpenFDM/FixedRootJoint.cpp	2008-04-15 21:01:18 UTC (rev 380)
@@ -0,0 +1,151 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
+ *
+ */
+
+#include "FixedRootJoint.h"
+
+#include "Assert.h"
+#include "LogStream.h"
+#include "Object.h"
+#include "Vector.h"
+#include "Matrix.h"
+#include "Quaternion.h"
+#include "Inertia.h"
+#include "Gravity.h"
+#include "Frame.h"
+#include "RigidBody.h"
+#include "ModelVisitor.h"
+#include "RootFrame.h"
+#include "FixedRootJointFrame.h"
+
+namespace OpenFDM {
+
+FixedRootJoint::FixedRootJoint(const std::string& name)
+  : Joint(name),
+    mFrame(new FixedRootJointFrame(name))
+{
+}
+
+FixedRootJoint::~FixedRootJoint(void)
+{
+}
+
+void
+FixedRootJoint::accept(ModelVisitor& visitor)
+{
+  visitor.apply(*this);
+}
+
+bool
+FixedRootJoint::init(void)
+{
+  mGravity = mEnvironment->getGravity();
+  if (!mGravity) {
+    Log(Model,Error) << "Can not get gravity model!" << endl;
+    return false;
+  }
+  const Frame* rootFrame = mEnvironment->getRootFrame();
+  if (!rootFrame) {
+    Log(Model,Error) << "Can not get rootFrame model!" << endl;
+    return false;
+  }
+  recheckTopology();
+
+  return Joint::init();
+}
+
+void
+FixedRootJoint::recheckTopology(void)
+{
+  // Hmm, works for the first cut, but rethink what happens with strange
+  // attach reattach sequences ...
+  RigidBody* rigidBody = getOutboardBody();
+  if (!rigidBody)
+    return;
+  // check if already done
+  if (mFrame != rigidBody->getFrame())
+    rigidBody->setFrame(mFrame);
+
+  // Check if we are attached to some rigid body ...
+  rigidBody = getInboardBody();
+  if (rigidBody) {
+    Frame* frame = rigidBody->getFrame();
+    if (frame && !frame->isDirectParentFrameOf(mFrame))
+      frame->addChildFrame(mFrame);
+  } else {
+    if (mEnvironment) {
+      Frame* rootFrame = mEnvironment->getRootFrame();
+      if (rootFrame && !rootFrame->isDirectParentFrameOf(mFrame))
+        rootFrame->addChildFrame(mFrame);
+    }
+  }
+}
+
+const Vector3&
+FixedRootJoint::getRefPosition(void) const
+{
+  return mFrame->getRefPosition();
+}
+
+void
+FixedRootJoint::setRefPosition(const Vector3& p)
+{
+  mFrame->setRefPosition(p);
+}
+
+const Quaternion&
+FixedRootJoint::getRefOrientation(void) const
+{
+  return mFrame->getRefOrientation();
+}
+
+void
+FixedRootJoint::setRefOrientation(const Quaternion& o)
+{
+  mFrame->setRefOrientation(o);
+}
+
+Geodetic
+FixedRootJoint::getGeodPosition(void) const
+{
+  if (!mEnvironment)
+    return Geodetic();
+  return mEnvironment->getPlanet()->toGeod(getRefPosition());
+}
+
+void
+FixedRootJoint::setGeodPosition(const Geodetic& geod)
+{
+  if (!mEnvironment)
+    return;
+  setRefPosition(mEnvironment->getPlanet()->toCart(geod));
+}
+
+Quaternion
+FixedRootJoint::getGeodOrientation(void) const
+{
+  if (!mEnvironment)
+    return Quaternion::unit();
+  Quaternion hlOr = mEnvironment->getPlanet()->getGeodHLOrientation(getRefPosition());
+  return inverse(hlOr)*getRefOrientation();
+}
+
+void
+FixedRootJoint::jointArticulation(SpatialInertia& artI, Vector6& artF,
+                             const SpatialInertia& outI,
+                             const Vector6& outF)
+{
+  artI.clear();
+  artF.clear();
+
+  Log(ArtBody, Debug) << "FixedRootJoint::computeRelVelDot():\n" << outI << endl;
+  mFrame->jointArticulation(outF, outI, mGravity);
+}
+
+void
+FixedRootJoint::setEnvironment(Environment* environment)
+{
+  mEnvironment = environment;
+}
+
+} // namespace OpenFDM

Added: trunk/OpenFDM/src/OpenFDM/FixedRootJoint.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/FixedRootJoint.h	2008-04-06 08:22:56 UTC (rev 379)
+++ trunk/OpenFDM/src/OpenFDM/FixedRootJoint.h	2008-04-15 21:01:18 UTC (rev 380)
@@ -0,0 +1,81 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_FixedRootJoint_H
+#define OpenFDM_FixedRootJoint_H
+
+#include "Assert.h"
+#include "Object.h"
+#include "Vector.h"
+#include "Matrix.h"
+#include "Quaternion.h"
+#include "Inertia.h"
+#include "Frame.h"
+#include "RigidBody.h"
+#include "Planet.h"
+#include "Joint.h"
+#include "Environment.h"
+
+namespace OpenFDM {
+
+class ModelVisitor;
+class FixedRootJointFrame;
+
+class FixedRootJoint
+  : public Joint {
+public:
+  FixedRootJoint(const std::string& name);
+  virtual ~FixedRootJoint(void);
+
+  /// Double dispatch helper for the multibody system visitor
+  virtual void accept(ModelVisitor& visitor);
+  /// Double dispatch helper for the multibody system visitor
+//   virtual void accept(ConstModelVisitor& visitor) const;
+
+  virtual bool init(void);
+
+  virtual void recheckTopology(void);
+
+  /// Get the reference position.
+  const Vector3& getRefPosition(void) const;
+  /// Set the reference position.
+  void setRefPosition(const Vector3& p);
+
+  /// Get the reference orientation.
+  const Quaternion& getRefOrientation(void) const;
+  /// Set the reference orientation.
+  void setRefOrientation(const Quaternion& o);
+
+  /// Get the geodetic position.
+  Geodetic getGeodPosition(void) const;
+  /// Set the geodetic position.
+  void setGeodPosition(const Geodetic& geod);
+  /// Get orientation wrt the geodetic hl frame.
+  Quaternion getGeodOrientation(void) const;
+
+  /** Plugin function for the articulated body algorithm.
+   */
+  virtual void jointArticulation(SpatialInertia& artI, Vector6& artF,
+                                 const SpatialInertia& outI,
+                                 const Vector6& outF);
+
+
+protected:
+  virtual void setEnvironment(Environment* environment);
+
+private:
+  /// The commonly used gravity model from the environment class
+  /// It is initialized at the init() call
+  SharedPtr<const Gravity> mGravity;
+
+  /// The frame of the mobile root
+  SharedPtr<FixedRootJointFrame> mFrame;
+
+  /// The environment pointer
+  SharedPtr<Environment> mEnvironment;
+};
+
+} // namespace OpenFDM
+
+#endif

Added: trunk/OpenFDM/src/OpenFDM/FixedRootJointFrame.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/FixedRootJointFrame.h	2008-04-06 08:22:56 UTC (rev 379)
+++ trunk/OpenFDM/src/OpenFDM/FixedRootJointFrame.h	2008-04-15 21:01:18 UTC (rev 380)
@@ -0,0 +1,60 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_FixedRootJointFrame_H
+#define OpenFDM_FixedRootJointFrame_H
+
+#include "Assert.h"
+#include "Vector.h"
+#include "Matrix.h"
+#include "Inertia.h"
+#include "Frame.h"
+
+namespace OpenFDM {
+
+class FixedRootJointFrame :
+  public Frame {
+public:
+  FixedRootJointFrame(const std::string& name) :
+    Frame(name),
+    mRelVelDot(Vector6::zeros())
+  { }
+  virtual ~FixedRootJointFrame(void)
+  { }
+
+  /// The interface routine for the Frame,
+  /// returns the relative velocity derivative of this frame
+  virtual const Vector6& getRelVelDot(void) const
+  { return mRelVelDot; }
+
+  /// Compute the articulated force and inertia past inboard to that joint
+  void jointArticulation(const Vector6&, const SpatialInertia&,
+                         const Gravity* gravity)
+  {
+    Log(ArtBody, Debug) << "FixedRootJointFrame::jointArticulation()" << endl;
+
+    // Assumption: body is small compared to the distance to the planets
+    // center of mass. That means gravity could be considered equal for the
+    // whole vehicle.
+    // See Featherstone, Orin: Equations and Algorithms
+    Vector3 ga = gravity->gravityAccel(getRefPosition());
+    Vector6 grav = Vector6(Vector3::zeros(), rotFromRef(ga));
+
+    mRelVelDot = grav - getParentSpAccel() - getHdot();
+    setAccelDirty();
+  }
+
+  using Frame::setPosition;
+  using Frame::setRefPosition;
+  using Frame::setOrientation;
+  using Frame::setRefOrientation;
+
+private:
+  /// The derivative of the frame velocity
+  Vector6 mRelVelDot;
+};
+
+} // namespace OpenFDM
+
+#endif

Modified: trunk/OpenFDM/src/OpenFDM/Makefile.am
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Makefile.am	2008-04-06 08:22:56 UTC (rev 379)
+++ trunk/OpenFDM/src/OpenFDM/Makefile.am	2008-04-15 21:01:18 UTC (rev 380)
@@ -131,6 +131,8 @@
   DiscBrake.h \
   DiscreteIntegrator.h \
   ExternalForceModel.h \
+  FixedRootJoint.h \
+  FixedRootJointFrame.h \
   Force.h \
   Gain.h \
   Gravity.h \
@@ -187,6 +189,7 @@
   DiscBrake.cpp \
   DiscreteIntegrator.cpp \
   ExternalForceModel.cpp \
+  FixedRootJoint.cpp \
   Force.cpp \
   Gain.cpp \
   Gravity.cpp \

Modified: trunk/OpenFDM/src/test/Makefile.am
===================================================================
--- trunk/OpenFDM/src/test/Makefile.am	2008-04-06 08:22:56 UTC (rev 379)
+++ trunk/OpenFDM/src/test/Makefile.am	2008-04-15 21:01:18 UTC (rev 380)
@@ -1,9 +1,15 @@
 INCLUDES = -I$(srcdir)/..
 
+# define some util programs
+bin_PROGRAMS = tiretestrig
+
 # define some unit tests
 check_PROGRAMS = quattest unitstest simulationtime constintegral harmonic limit
 TESTS          = $(check_PROGRAMS)
 
+tiretestrig_SOURCES = tiretestrig.cpp
+tiretestrig_LDADD = ../OpenFDM/libOpenFDM.la
+
 unitstest_SOURCES = unitstest.cpp
 unitstest_LDADD = ../OpenFDM/libOpenFDM.la
 

Added: trunk/OpenFDM/src/test/tiretestrig.cpp
===================================================================
--- trunk/OpenFDM/src/test/tiretestrig.cpp	2008-04-06 08:22:56 UTC (rev 379)
+++ trunk/OpenFDM/src/test/tiretestrig.cpp	2008-04-15 21:01:18 UTC (rev 380)
@@ -0,0 +1,209 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
+ *
+ */
+
+#include <cstdlib>
+#include <iostream>
+#include <fstream>
+#include <OpenFDM/ConstModel.h>
+#include <OpenFDM/DoPri5.h>
+#include <OpenFDM/FixedRootJoint.h>
+#include <OpenFDM/Gain.h>
+#include <OpenFDM/Gravity.h>
+#include <OpenFDM/Ground.h>
+#include <OpenFDM/Integrator.h>
+#include <OpenFDM/LinearSpringDamper.h>
+#include <OpenFDM/Mass.h>
+#include <OpenFDM/ModelGroup.h>
+#include <OpenFDM/ModelVisitor.h>
+#include <OpenFDM/Output.h>
+#include <OpenFDM/PrismaticJoint.h>
+#include <OpenFDM/RevoluteActuator.h>
+#include <OpenFDM/RevoluteJoint.h>
+#include <OpenFDM/RigidBody.h>
+#include <OpenFDM/SimulationTime.h>
+#include <OpenFDM/Summer.h>
+#include <OpenFDM/System.h>
+#include <OpenFDM/UnaryFunctionModel.h>
+#include <OpenFDM/WheelContact.h>
+
+using namespace OpenFDM;
+
+class CSVWriter : public ModelVisitor {
+public:
+  CSVWriter(const std::string& filename) :
+    _csvFile(filename.c_str())
+  { }
+  virtual void apply(Model& model)
+  {
+    unsigned numOutputs = model.getNumOutputPorts();
+    for (unsigned i = 0; i < numOutputs; ++i) {
+      NumericPortProvider* numericPort = model.getOutputPort(i);
+      if (!numericPort)
+        continue;
+      PortInterface* portInterface = numericPort->getPortInterface();
+      if (!portInterface)
+        continue;
+      MatrixPortInterface* matrixPortInterface;
+      matrixPortInterface = portInterface->toMatrixPortInterface();
+      if (!matrixPortInterface)
+        continue;
+
+      const Matrix& m = matrixPortInterface->getMatrixValue();
+      for (unsigned i = 0; i < rows(m); ++i)
+        for (unsigned j = 0; j < cols(m); ++j)
+          _csvFile << ", " << m(i, j);
+    }
+  }
+  virtual void apply(ModelGroup& modelGroup)
+  { traverse(modelGroup); }
+  virtual void apply(System& system)
+  {
+    _csvFile << system.getTime();
+    ModelVisitor::apply(system);
+    _csvFile << std::endl;
+  }
+private:
+  std::ofstream _csvFile;
+};
+
+class MovingGround : public Ground {
+public:
+  MovingGround(const Vector3& linearVelocity) : mVelocity(linearVelocity)
+  { }
+  virtual GroundValues getGroundPlane(real_type, const Vector3& refPos) const
+  {
+    return GroundValues(Plane(Vector3(0, 0, -1), Vector3::zeros()),
+                        Vector6(Vector3::zeros(), mVelocity),
+                        real_type(1));
+  }
+private:
+  Vector3 mVelocity;
+};
+
+class ZGravity : public Gravity {
+public:
+  virtual Vector3 gravityAccel(const Vector3& cart) const
+  { return Vector3(0, 0, 9.81); }
+};
+
+int
+main(int argc, char *argv[])
+{
+  real_type omega = 2;
+
+  SharedPtr<System> system = new System("Tire Testrig");
+  system->addSampleTime(real_type(1)/real_type(100));
+  system->setTimestepper(new DoPri5);
+
+  // set the moving ground
+  system->getEnvironment()->setGround(new MovingGround(Vector3(10, 0, 0)));
+  system->getEnvironment()->setGravity(new ZGravity());
+  
+  // First build up the mechanical system
+  FixedRootJoint* fixedRootJoint = new FixedRootJoint("Fixed Root Joint");
+  system->addModel(fixedRootJoint);
+  fixedRootJoint->setRefPosition(Vector3(0, 0, 1));
+
+  PrismaticJoint* prismaticJoint = new PrismaticJoint("Normal Force joint");
+  prismaticJoint->setJointAxis(Vector3::unit(2));
+  system->addModel(prismaticJoint);
+
+  Summer* normalForceSum = new Summer("Normal Force Sum");
+  normalForceSum->setNumSummands(2);
+  system->addModel(normalForceSum);
+  Connection::connect(prismaticJoint->getInputPort(0),
+                      normalForceSum->getOutputPort(0));
+
+  ConstModel* normalForce = new ConstModel("Normal force");
+  normalForce->setScalarValue(5000);
+  system->addModel(normalForce);
+  Connection::connect(normalForceSum->getInputPort(0),
+                      normalForce->getOutputPort(0));
+ 
+  LinearSpringDamper* strutDamper = new LinearSpringDamper("Strut Damper");
+  strutDamper->setSpringConstant(0);
+  strutDamper->setDamperConstant(-30);
+  system->addModel(strutDamper);
+  Connection::connect(normalForceSum->getInputPort(1),
+                      strutDamper->getOutputPort(0));
+  Connection::connect(strutDamper->getInputPort(0),
+                      prismaticJoint->getOutputPort(0));
+  Connection::connect(strutDamper->getInputPort(1),
+                      prismaticJoint->getOutputPort(1));
+
+  RigidBody* rootMount = new RigidBody("Root Mount");
+  system->addModel(rootMount);
+  rootMount->setInboardJoint(fixedRootJoint);
+  rootMount->addInteract(prismaticJoint);
+
+
+  RevoluteActuator* camberActuator = new RevoluteActuator("Camber Actuator");
+  system->addModel(camberActuator);
+
+  ConstModel* camberAngle = new ConstModel("Camber Angle");
+  camberAngle->setScalarValue(0);
+  system->addModel(camberAngle);
+  Connection::connect(camberActuator->getInputPort(0),
+                      camberAngle->getOutputPort(0));
+
+  RigidBody* normalForceStrut = new RigidBody("Normal Force Strut");
+  system->addModel(normalForceStrut);
+  normalForceStrut->setInboardJoint(prismaticJoint);
+  normalForceStrut->addInteract(camberActuator);
+
+ 
+  RevoluteActuator* sideActuator = new RevoluteActuator("Sideslip Actuator");
+  system->addModel(sideActuator);
+
+  ConstModel* sideslipAngle = new ConstModel("Sideslip Angle");
+  sideslipAngle->setScalarValue(0);
+  system->addModel(sideslipAngle);
+  Connection::connect(sideActuator->getInputPort(0),
+                      sideslipAngle->getOutputPort(0));
+
+  RigidBody* camberStrut = new RigidBody("Camber Strut");
+  system->addModel(camberStrut);
+  camberStrut->setInboardJoint(camberActuator);
+  camberStrut->addInteract(sideActuator);
+
+
+  RevoluteJoint* hubJoint = new RevoluteJoint("Hub Joint");
+  hubJoint->setJointAxis(Vector3(0, 1, 0));
+  system->addModel(hubJoint);
+
+  RigidBody* hubStrut = new RigidBody("Hub Strut");
+  system->addModel(hubStrut);
+  hubStrut->setInboardJoint(sideActuator);
+  hubStrut->addInteract(hubJoint);
+
+  RigidBody* rimAndTire = new RigidBody("Rim and Tire");
+  system->addModel(rimAndTire);
+  rimAndTire->setInboardJoint(hubJoint);
+
+  Mass* tireAndRimMass = new Mass("Tire And Rim Mass");
+  tireAndRimMass->setInertia(1, InertiaMatrix(1, 0, 0, 1, 0, 1));
+  system->addModel(tireAndRimMass);
+  rimAndTire->addInteract(tireAndRimMass);
+  
+  WheelContact* wheelContact = new WheelContact("Wheel Contact");
+  wheelContact->setWheelRadius(0.3);
+  wheelContact->setSpringConstant(1000);
+  wheelContact->setSpringDamping(sqrt(wheelContact->getSpringConstant())/10);
+  system->addModel(wheelContact);
+  rimAndTire->addInteract(wheelContact);
+
+  if (!system->init()) {
+    std::cout << "Could not initialize the system" << std::endl;
+    return EXIT_FAILURE;
+  }
+
+  CSVWriter writer("out.csv");
+  system->accept(writer);
+  while (system->getTime() < 100) {
+    system->simulate(system->getTime() + 0.01);
+    system->accept(writer);
+  }
+  
+  return EXIT_SUCCESS;
+}



From frohlich at mail.berlios.de  Sun Apr 20 09:34:25 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 20 Apr 2008 09:34:25 +0200
Subject: [OpenFDM-svn] r381 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200804200734.m3K7YPvo025202@sheep.berlios.de>

Author: frohlich
Date: 2008-04-20 09:34:25 +0200 (Sun, 20 Apr 2008)
New Revision: 381

Modified:
   trunk/OpenFDM/src/OpenFDM/ConstModel.cpp
Log:
Fix off by one error.


Modified: trunk/OpenFDM/src/OpenFDM/ConstModel.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/ConstModel.cpp	2008-04-15 21:01:18 UTC (rev 380)
+++ trunk/OpenFDM/src/OpenFDM/ConstModel.cpp	2008-04-20 07:34:25 UTC (rev 381)
@@ -37,7 +37,7 @@
 ConstModel::setScalarValue(real_type value)
 {
   mValue.resize(1, 1);
-  mValue(1, 1) = value;
+  mValue(0, 0) = value;
 }
 
 } // namespace OpenFDM



From frohlich at mail.berlios.de  Sun Apr 20 10:13:58 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 20 Apr 2008 10:13:58 +0200
Subject: [OpenFDM-svn] r382 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200804200813.m3K8DwPE027896@sheep.berlios.de>

Author: frohlich
Date: 2008-04-20 10:13:58 +0200 (Sun, 20 Apr 2008)
New Revision: 382

Modified:
   trunk/OpenFDM/src/OpenFDM/Mass.cpp
Log:
Add inertia property ...


Modified: trunk/OpenFDM/src/OpenFDM/Mass.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Mass.cpp	2008-04-20 07:34:25 UTC (rev 381)
+++ trunk/OpenFDM/src/OpenFDM/Mass.cpp	2008-04-20 08:13:58 UTC (rev 382)
@@ -8,6 +8,7 @@
 
 BEGIN_OPENFDM_OBJECT_DEF(Mass, Interact)
   DEF_OPENFDM_PROPERTY(Vector3, Position, Serialized)
+  DEF_OPENFDM_PROPERTY(SpatialInertia, Inertia, Serialized)
   END_OPENFDM_OBJECT_DEF
 
 Mass::Mass(const std::string& name, const SpatialInertia& inertia) :



From frohlich at mail.berlios.de  Sun Apr 20 10:14:54 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 20 Apr 2008 10:14:54 +0200
Subject: [OpenFDM-svn] r383 - trunk/OpenFDM/src/test
Message-ID: <200804200814.m3K8EsKF028006@sheep.berlios.de>

Author: frohlich
Date: 2008-04-20 10:14:53 +0200 (Sun, 20 Apr 2008)
New Revision: 383

Added:
   trunk/OpenFDM/src/test/HDF5Writer.h
Log:
Add HDF5 file dumper. Preliminary but sufficient for now ...


Added: trunk/OpenFDM/src/test/HDF5Writer.h
===================================================================
--- trunk/OpenFDM/src/test/HDF5Writer.h	2008-04-20 08:13:58 UTC (rev 382)
+++ trunk/OpenFDM/src/test/HDF5Writer.h	2008-04-20 08:14:53 UTC (rev 383)
@@ -0,0 +1,304 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_HDF5Writer_H
+#define OpenFDM_HDF5Writer_H
+
+#include <sstream>
+#include <set>
+#include <hdf5.h>
+#include <OpenFDM/ModelGroup.h>
+#include <OpenFDM/ModelVisitor.h>
+#include <OpenFDM/System.h>
+
+namespace OpenFDM {
+
+class HDF5Object : public Referenced {
+public:
+  HDF5Object() : _id(-1) { }
+  HDF5Object(hid_t id) : _id(-1) { assign(id); }
+  HDF5Object(const HDF5Object& object) : _id(-1)
+  { assign(object.getId()); }
+  virtual ~HDF5Object()
+  { release(); }
+
+  HDF5Object& operator=(const HDF5Object& object)
+  { assign(object.getId()); return *this; }
+
+  hid_t getId() const
+  { return _id; }
+
+  int getNumReferences() const
+  { return H5Iget_ref(_id); }
+  bool valid() const
+  { return 0 <= _id && H5I_BADID != H5Iget_type(_id); }
+
+  std::string getName() const
+  {
+    if (_id < 0)
+      return std::string();
+    ssize_t size = H5Iget_name(_id, 0, 0);
+    char* tmp = new char[size];
+    size = H5Iget_name(_id, tmp, size);
+    std::string name(tmp, size);
+    delete [] tmp;
+    return name;
+  }
+
+  void release()
+  {
+    if (0 <= _id)
+      H5Idec_ref(_id);
+    _id = -1;
+  }
+
+protected:
+  void assign(hid_t id)
+  {
+    if (_id == id)
+      return;
+    if (_id < 0 || H5I_BADID == H5Iget_type(_id))
+      release();
+    H5Iinc_ref(id);
+    release();
+    _id = id;
+  }
+// private:
+  hid_t _id;
+};
+
+
+class HDF5Group : public HDF5Object {
+public:
+  HDF5Group()
+  { }
+  HDF5Group(const HDF5Object& parent, const std::string& filename)
+  { create(parent, filename); }
+
+  bool create(const HDF5Object& parent, const std::string& name)
+  {
+    _id = H5Gcreate(parent.getId(), name.c_str(), 0);
+    if (_id < 0)
+      return false;
+    return true;
+  }
+};
+
+class HDF5File : public HDF5Object {
+public:
+  HDF5File()
+  { }
+  HDF5File(const std::string& filename)
+  { open(filename); }
+  void open(const std::string& name)
+  { _id = H5Fcreate(name.c_str(), H5F_ACC_TRUNC, H5P_DEFAULT, H5P_DEFAULT); }
+};
+
+class HDFMatrixStream : public HDF5Object {
+public:
+  HDFMatrixStream(const HDF5Object& parent, const std::string& name) :
+    _name(name),
+    _chunklen(100),
+    _parent(parent)
+  {
+  }
+
+  void append(const real_type& scalar)
+  {
+    Matrix tmp(1, 1);
+    tmp(0, 0) = scalar;
+    append(tmp);
+  }
+
+  void append(const Matrix& matrix)
+  {
+    herr_t status;
+    if (_id < 0) {
+      hsize_t rank = 3;
+      if (cols(matrix) == 1) {
+        rank = 2;
+        if (rows(matrix) == 1)
+          rank = 1;
+      }
+      _dims[0] = 1;
+      _dims[1] = rows(matrix);
+      _dims[2] = cols(matrix);
+      hsize_t maxdims[3] = { H5S_UNLIMITED, _dims[1], _dims[2] };
+      _dataspace = H5Screate_simple(rank, _dims, maxdims);
+      if (!_dataspace.valid())
+        return;
+
+      hsize_t chunk_dims[3] = { _chunklen, rows(matrix), cols(matrix) };
+
+      hid_t cparms = H5Pcreate(H5P_DATASET_CREATE);
+      status = H5Pset_chunk(cparms, rank, chunk_dims);
+      _id = H5Dcreate(_parent.getId(), _name.c_str(), H5T_NATIVE_DOUBLE,
+                      _dataspace.getId(), cparms);
+      H5Pclose(cparms);
+    } else {
+      // increment size
+      _dims[0] += 1;
+      status = H5Dextend(_id, _dims);
+    }
+
+    HDF5Object filespace = H5Dget_space(_id);
+    hsize_t offset[3] = { _dims[0] - 1, 0, 0 };
+    hsize_t dims1[3] = { 1, _dims[1], _dims[2] };
+    status = H5Sselect_hyperslab(filespace.getId(), H5S_SELECT_SET,
+                                 offset, NULL, dims1, NULL);
+
+    std::vector<double> data(_dims[1]*_dims[2]);
+    for (hsize_t i = 0; i < _dims[1]; ++i)
+      for (hsize_t j = 0; j < _dims[2]; ++j)
+        // FIXME?? row or column major ...
+        data[j + i*_dims[2]] = matrix(i, j);
+        // data[i + j*_dims[1]] = matrix(i, j);
+    status = H5Dwrite(getId(), H5T_NATIVE_DOUBLE,
+                      _dataspace.getId(), filespace.getId(),
+                      H5P_DEFAULT, &data.front());
+  }
+
+private:
+  std::string _name;
+  hsize_t _dims[3];
+  HDF5Object _dataspace;
+
+  hsize_t _chunklen;
+
+  HDF5Object _parent;
+};
+
+class HDF5Writer : public ModelVisitor {
+public:
+  HDF5Writer(const std::string& filename) :
+    _hdf5File(filename),
+    _group(_hdf5File, "System"),
+    _ts(_group.getId(), "t")
+  { }
+  ~HDF5Writer()
+  { }
+
+  virtual void apply(Model& model)
+  {
+    HDF5Group modelGroup(_group, model.getName());
+
+    dumpObject(modelGroup, model);
+
+    unsigned numOutputs = model.getNumOutputPorts();
+    if (numOutputs > 0) {
+      HDF5Group outputGroup(modelGroup, "outputs");
+      UniqueStringSet outputStringSet;
+      for (unsigned i = 0; i < numOutputs; ++i) {
+        NumericPortProvider* numericPort = model.getOutputPort(i);
+        if (!numericPort)
+          continue;
+        PortInterface* portInterface = numericPort->getPortInterface();
+        if (!portInterface)
+          continue;
+        MatrixPortInterface* matrixPortInterface;
+        matrixPortInterface = portInterface->toMatrixPortInterface();
+        if (!matrixPortInterface)
+          continue;
+        
+        std::string name;
+        name = outputStringSet.makeUnique(model.getOutputPort(i)->getName());
+        _dumperList.push_back(new MatrixDumper(matrixPortInterface, outputGroup.getId(), name));
+      }
+    }
+  }
+  virtual void apply(ModelGroup& modelGroup)
+  {
+    HDF5Group parentGroup = _group;
+    _group = HDF5Group(_group, modelGroup.getName()),
+
+    dumpObject(_group, modelGroup);
+
+    traverse(modelGroup);
+    _group = parentGroup;
+  }
+  virtual void apply(System& system)
+  {
+    if (_dumperList.empty())
+      ModelVisitor::apply(system);
+    _ts.append(system.getTime());
+    for (DumperList::iterator i = _dumperList.begin(); i != _dumperList.end();
+         ++i) {
+      (*i)->append();
+    }
+  }
+
+private:
+  struct UniqueStringSet {
+    std::string makeUnique(const std::string& s)
+    {
+      if (_strings.find(s) == _strings.end()) {
+        _strings.insert(s);
+        return s;
+      }
+      std::string unique;
+      unsigned id = 0;
+      do {
+        std::stringstream ss;
+        ss << s << ++id;
+        unique = ss.str();
+      } while (_strings.find(unique) != _strings.end());
+      return unique;
+    }
+  private:
+    std::set<std::string> _strings;
+  };
+
+  void dumpObject(HDF5Object& parent, Object& object)
+  {
+    HDF5Group propertyGroup(parent, "properties");
+    std::vector<PropertyInfo> propertyInfoList;
+    object.getPropertyInfoList(propertyInfoList);
+    std::vector<PropertyInfo>::const_iterator i;
+    for (i = propertyInfoList.begin(); i != propertyInfoList.end(); ++i) {
+      std::string name = i->getName();
+      Variant v;
+      if (!object.getPropertyValue(name, v))
+        continue;
+      if (v.isMatrix()) {
+        HDFMatrixStream value(propertyGroup, name);
+        value.append(v.toMatrix());
+      } if (v.isReal()) {
+        HDFMatrixStream value(propertyGroup, name);
+        value.append(v.toReal());
+      } if (v.isInteger()) {
+        // FIXME, converts to double ...
+        HDFMatrixStream value(propertyGroup, name);
+        value.append(v.toInteger());
+      } if (v.isUnsigned()) {
+        // FIXME, converts to double ...
+        HDFMatrixStream value(propertyGroup, name);
+        value.append(v.toUnsigned());
+      }
+    }
+  }
+
+  HDF5File _hdf5File;
+  HDF5Group _group;
+
+  HDFMatrixStream _ts;
+
+  struct MatrixDumper : public Referenced {
+    MatrixDumper(MatrixPortInterface* matrixPortInterface, const HDF5Object& parent, const std::string& name) :
+      _matrixPortInterface(matrixPortInterface),
+      _stream(parent, name)
+    { }
+    void append()
+    { _stream.append(_matrixPortInterface->getMatrixValue()); }
+
+    SharedPtr<MatrixPortInterface> _matrixPortInterface;
+    HDFMatrixStream _stream;
+  };
+
+  typedef std::list<SharedPtr<MatrixDumper> > DumperList;
+  DumperList _dumperList;
+};
+
+} // namespace OpenFDM
+
+#endif



From frohlich at mail.berlios.de  Sun Apr 20 10:15:32 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 20 Apr 2008 10:15:32 +0200
Subject: [OpenFDM-svn] r384 - trunk/OpenFDM/src/test
Message-ID: <200804200815.m3K8FWdu028067@sheep.berlios.de>

Author: frohlich
Date: 2008-04-20 10:15:32 +0200 (Sun, 20 Apr 2008)
New Revision: 384

Added:
   trunk/OpenFDM/src/test/CSVWriter.h
Modified:
   trunk/OpenFDM/src/test/Makefile.am
   trunk/OpenFDM/src/test/tiretestrig.cpp
Log:
Move CSV dumper into an own file. Use the HDF5 one for the testrig.


Added: trunk/OpenFDM/src/test/CSVWriter.h
===================================================================
--- trunk/OpenFDM/src/test/CSVWriter.h	2008-04-20 08:14:53 UTC (rev 383)
+++ trunk/OpenFDM/src/test/CSVWriter.h	2008-04-20 08:15:32 UTC (rev 384)
@@ -0,0 +1,55 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_CSVWriter_H
+#define OpenFDM_CSVWriter_H
+
+#include <fstream>
+#include <OpenFDM/ModelGroup.h>
+#include <OpenFDM/ModelVisitor.h>
+#include <OpenFDM/System.h>
+
+namespace OpenFDM {
+
+class CSVWriter : public ModelVisitor {
+public:
+  CSVWriter(const std::string& filename) :
+    _csvFile(filename.c_str())
+  { }
+  virtual void apply(Model& model)
+  {
+    unsigned numOutputs = model.getNumOutputPorts();
+    for (unsigned i = 0; i < numOutputs; ++i) {
+      NumericPortProvider* numericPort = model.getOutputPort(i);
+      if (!numericPort)
+        continue;
+      PortInterface* portInterface = numericPort->getPortInterface();
+      if (!portInterface)
+        continue;
+      MatrixPortInterface* matrixPortInterface;
+      matrixPortInterface = portInterface->toMatrixPortInterface();
+      if (!matrixPortInterface)
+        continue;
+
+      const Matrix& m = matrixPortInterface->getMatrixValue();
+      for (unsigned i = 0; i < rows(m); ++i)
+        for (unsigned j = 0; j < cols(m); ++j)
+          _csvFile << ", " << m(i, j);
+    }
+  }
+  virtual void apply(ModelGroup& modelGroup)
+  { traverse(modelGroup); }
+  virtual void apply(System& system)
+  {
+    _csvFile << system.getTime();
+    ModelVisitor::apply(system);
+    _csvFile << std::endl;
+  }
+private:
+  std::ofstream _csvFile;
+};
+
+} // namespace OpenFDM
+
+#endif

Modified: trunk/OpenFDM/src/test/Makefile.am
===================================================================
--- trunk/OpenFDM/src/test/Makefile.am	2008-04-20 08:14:53 UTC (rev 383)
+++ trunk/OpenFDM/src/test/Makefile.am	2008-04-20 08:15:32 UTC (rev 384)
@@ -8,7 +8,7 @@
 TESTS          = $(check_PROGRAMS)
 
 tiretestrig_SOURCES = tiretestrig.cpp
-tiretestrig_LDADD = ../OpenFDM/libOpenFDM.la
+tiretestrig_LDADD = ../OpenFDM/libOpenFDM.la -lhdf5
 
 unitstest_SOURCES = unitstest.cpp
 unitstest_LDADD = ../OpenFDM/libOpenFDM.la

Modified: trunk/OpenFDM/src/test/tiretestrig.cpp
===================================================================
--- trunk/OpenFDM/src/test/tiretestrig.cpp	2008-04-20 08:14:53 UTC (rev 383)
+++ trunk/OpenFDM/src/test/tiretestrig.cpp	2008-04-20 08:15:32 UTC (rev 384)
@@ -2,9 +2,6 @@
  *
  */
 
-#include <cstdlib>
-#include <iostream>
-#include <fstream>
 #include <OpenFDM/ConstModel.h>
 #include <OpenFDM/DoPri5.h>
 #include <OpenFDM/FixedRootJoint.h>
@@ -27,46 +24,10 @@
 #include <OpenFDM/UnaryFunctionModel.h>
 #include <OpenFDM/WheelContact.h>
 
+#include "HDF5Writer.h"
+
 using namespace OpenFDM;
 
-class CSVWriter : public ModelVisitor {
-public:
-  CSVWriter(const std::string& filename) :
-    _csvFile(filename.c_str())
-  { }
-  virtual void apply(Model& model)
-  {
-    unsigned numOutputs = model.getNumOutputPorts();
-    for (unsigned i = 0; i < numOutputs; ++i) {
-      NumericPortProvider* numericPort = model.getOutputPort(i);
-      if (!numericPort)
-        continue;
-      PortInterface* portInterface = numericPort->getPortInterface();
-      if (!portInterface)
-        continue;
-      MatrixPortInterface* matrixPortInterface;
-      matrixPortInterface = portInterface->toMatrixPortInterface();
-      if (!matrixPortInterface)
-        continue;
-
-      const Matrix& m = matrixPortInterface->getMatrixValue();
-      for (unsigned i = 0; i < rows(m); ++i)
-        for (unsigned j = 0; j < cols(m); ++j)
-          _csvFile << ", " << m(i, j);
-    }
-  }
-  virtual void apply(ModelGroup& modelGroup)
-  { traverse(modelGroup); }
-  virtual void apply(System& system)
-  {
-    _csvFile << system.getTime();
-    ModelVisitor::apply(system);
-    _csvFile << std::endl;
-  }
-private:
-  std::ofstream _csvFile;
-};
-
 class MovingGround : public Ground {
 public:
   MovingGround(const Vector3& linearVelocity) : mVelocity(linearVelocity)
@@ -111,12 +72,13 @@
 
   Summer* normalForceSum = new Summer("Normal Force Sum");
   normalForceSum->setNumSummands(2);
+  normalForceSum->setInputSign(0, Summer::Minus);
   system->addModel(normalForceSum);
   Connection::connect(prismaticJoint->getInputPort(0),
                       normalForceSum->getOutputPort(0));
 
   ConstModel* normalForce = new ConstModel("Normal force");
-  normalForce->setScalarValue(5000);
+  normalForce->setScalarValue(2000);
   system->addModel(normalForce);
   Connection::connect(normalForceSum->getInputPort(0),
                       normalForce->getOutputPort(0));
@@ -177,11 +139,11 @@
   hubStrut->setInboardJoint(sideActuator);
   hubStrut->addInteract(hubJoint);
 
-  RigidBody* rimAndTire = new RigidBody("Rim and Tire");
+  RigidBody* rimAndTire = new RigidBody("Rim And Tire");
   system->addModel(rimAndTire);
   rimAndTire->setInboardJoint(hubJoint);
 
-  Mass* tireAndRimMass = new Mass("Tire And Rim Mass");
+  Mass* tireAndRimMass = new Mass("Rim And Tire Mass");
   tireAndRimMass->setInertia(1, InertiaMatrix(1, 0, 0, 1, 0, 1));
   system->addModel(tireAndRimMass);
   rimAndTire->addInteract(tireAndRimMass);
@@ -198,11 +160,11 @@
     return EXIT_FAILURE;
   }
 
-  CSVWriter writer("out.csv");
-  system->accept(writer);
-  while (system->getTime() < 100) {
+  HDF5Writer hwriter("system.h5");
+  system->accept(hwriter);
+  while (system->getTime() < 10) {
     system->simulate(system->getTime() + 0.01);
-    system->accept(writer);
+    system->accept(hwriter);
   }
   
   return EXIT_SUCCESS;



From frohlich at mail.berlios.de  Sun Apr 20 12:52:13 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 20 Apr 2008 12:52:13 +0200
Subject: [OpenFDM-svn] r385 - trunk/OpenFDM/src/test
Message-ID: <200804201052.m3KAqDY6008136@sheep.berlios.de>

Author: frohlich
Date: 2008-04-20 12:52:11 +0200 (Sun, 20 Apr 2008)
New Revision: 385

Modified:
   trunk/OpenFDM/src/test/limit.cpp
Log:
Add missing include.


Modified: trunk/OpenFDM/src/test/limit.cpp
===================================================================
--- trunk/OpenFDM/src/test/limit.cpp	2008-04-20 08:15:32 UTC (rev 384)
+++ trunk/OpenFDM/src/test/limit.cpp	2008-04-20 10:52:11 UTC (rev 385)
@@ -6,6 +6,7 @@
 #include <fstream>
 #include <OpenFDM/Types.h>
 #include <OpenFDM/Limits.h>
+#include <OpenFDM/Math.h>
 
 using namespace OpenFDM;
 



