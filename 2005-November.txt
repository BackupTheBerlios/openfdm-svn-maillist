From frohlich at berlios.de  Tue Nov  1 09:27:23 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Tue, 1 Nov 2005 09:27:23 +0100
Subject: [OpenFDM-svn] r49 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200511010827.jA18RNtC011973@sheep.berlios.de>

Author: frohlich
Date: 2005-11-01 09:27:13 +0100 (Tue, 01 Nov 2005)
New Revision: 49

Modified:
   trunk/OpenFDM/src/OpenFDM/SimpleGear.cpp
Log:
Simpliy the transform to wheel ccordinates.


Modified: trunk/OpenFDM/src/OpenFDM/SimpleGear.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/SimpleGear.cpp	2005-10-29 19:30:51 UTC (rev 48)
+++ trunk/OpenFDM/src/OpenFDM/SimpleGear.cpp	2005-11-01 08:27:13 UTC (rev 49)
@@ -148,15 +148,14 @@
   // The wheel coordinates x asxis is defined by the forward orientation
   // of the wheel, the z axis points perpandicular to the ground
   // plane downwards.
-  real_type sinsa = sin(mSteeringAngle);
-  real_type cossa = cos(mSteeringAngle);
-  Rotation wheelOrientation
-    = Quaternion::fromRotateTo(1, Vector3(cossa, sinsa, 0),
-                               3, groundNormal);
-  
-  // Compute the wheel velocity in wheel coordinates.
-  Vector3 wheelVel = wheelOrientation.transform(vel);
-  
+  Vector3 forward(cos(mSteeringAngle), sin(mSteeringAngle), 0);
+  Vector3 side = cross(groundNormal, forward);
+  forward = normalize(cross(side, groundNormal));
+  side = normalize(side);
+
+  // Transformed to the ground plane
+  Vector2 wheelVel(dot(forward, vel), dot(side, vel));
+
   // Now we compute something like the JSBSim gear friction model.
   // The x coordinate is in wheel forward direction,
   // the y coordinate points towards right. 
@@ -184,10 +183,9 @@
   
   // The friction force for fast movement.
   Vector2 fricForce = (-friction*mFrictionCoef*normForce)*slip;
-  Vector3 fricForce3(fricForce(1), fricForce(2), 0);
   
   // Transform the friction force back and return
-  return wheelOrientation.backTransform(fricForce3);
+  return fricForce(1)*forward + fricForce(2)*side;
 }
 
 } // namespace OpenFDM



From frohlich at berlios.de  Tue Nov  1 09:39:53 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Tue, 1 Nov 2005 09:39:53 +0100
Subject: [OpenFDM-svn] r50 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200511010839.jA18drkw021571@sheep.berlios.de>

Author: frohlich
Date: 2005-11-01 09:39:47 +0100 (Tue, 01 Nov 2005)
New Revision: 50

Added:
   trunk/OpenFDM/src/OpenFDM/quattest.cpp
Modified:
   trunk/OpenFDM/src/OpenFDM/Makefile.am
   trunk/OpenFDM/src/OpenFDM/Quaternion.h
Log:
Update Quaternions.


Modified: trunk/OpenFDM/src/OpenFDM/Makefile.am
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Makefile.am	2005-11-01 08:27:13 UTC (rev 49)
+++ trunk/OpenFDM/src/OpenFDM/Makefile.am	2005-11-01 08:39:47 UTC (rev 50)
@@ -1,17 +1,22 @@
 
 INCLUDES = -I$(srcdir)/..
 
-# check_PROGRAMS = main
-# TESTS           = $(check_PROGRAMS)
-
 noinst_PROGRAMS = main units
 
+# define some unit tests
+check_PROGRAMS = quattest
+TESTS          = $(check_PROGRAMS)
+
 main_SOURCES = main.cpp
 main_LDADD = libOpenFDM.la
 
 units_SOURCES = units.cpp
 units_LDADD = libOpenFDM.la
 
+quattest_SOURCES = quattest.cpp
+quattest_LDADD = Units.o
+#quattest_LDADD = libOpenFDM.la
+
 OpenFDMincludedir = $(includedir)/OpenFDM
 
 lib_LTLIBRARIES = libOpenFDM.la

Modified: trunk/OpenFDM/src/OpenFDM/Quaternion.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Quaternion.h	2005-11-01 08:27:13 UTC (rev 49)
+++ trunk/OpenFDM/src/OpenFDM/Quaternion.h	2005-11-01 08:39:47 UTC (rev 50)
@@ -201,6 +201,9 @@
       + (2*r*qr)*cross(qimag, v);
   }
 
+  OpenFDM_FORCE_INLINE
+  static Quaternion unit(unsigned i = 1)
+  { return Quaternion(Vector4<T>::unit(i)); }
 
   static Quaternion fromRealImag(value_type r, const Vector3& i)
   { return Quaternion(r, i(1), i(2), i(3)); }
@@ -295,18 +298,9 @@
     return Quaternion::fromRotateToNorm((1/nfrom)*from, (1/nto)*to);
   }
 
-  static Quaternion fromRotateTo(size_type i, const Vector3& v)
-  {
-    value_type nv = norm(v);
-    if (nv < Limits<T>::min())
-      return Quaternion::unit(1);
-    
-    return Quaternion::fromRotateToNorm(v/nv, Vector3::unit(i));
-  }
-
   // FIXME more finegrained error behavour.
-  static Quaternion fromRotateTo(size_type i1, const Vector3& v1,
-                                 size_type i2, const Vector3& v2)
+  static Quaternion fromRotateTo(const Vector3& v1, size_type i1,
+                                 const Vector3& v2, size_type i2)
   {
     value_type nrmv1 = norm(v1);
     value_type nrmv2 = norm(v2);
@@ -319,44 +313,35 @@
     if (fabs(fabs(dv1v2)-1) < Limits<value_type>::epsilon())
       return Quaternion::unit(1);
 
+    // The target vector for the first rotation
+    Vector3 nto1 = Vector3::unit(i1);
+    Vector3 nto2 = Vector3::unit(i2);
+
     // The first rotation can be done with the usual routine.
-    Quaternion q = Quaternion::fromRotateToNorm(Vector3::unit(i1), nv1);
+    Quaternion q = Quaternion::fromRotateToNorm(nv1, nto1);
 
-    // Make nv2 orthogonal to nv1.
-    nv2 = nv2 - dv1v2*nv1;
-    nv2 *= 1/norm(nv2);
+    // The rotation axis for the second rotation is the
+    // target for the first one, so the rotation axis is nto1
+    // We need to get the angle.
 
-    // For rotation of the second axis, we need to preserve the picture
-    // of the first one.
-    Vector3 tui2 = q.transform(Vector3::unit(i2));
-    Vector3 tnv2 = q.transform(nv2);
+    // Make nv2 exactly orthogonal to nv1.
+    nv2 = normalize(nv2 - dv1v2*nv1);
 
-    // FIXME there is a possibility that copysign is not correct ...
-    // true??
-    value_type cosang = dot(tui2, tnv2);
-
+    Vector3 tnv2 = q.transform(nv2);
+    value_type cosang = dot(nto2, tnv2);
     value_type cos05ang = max(static_cast<value_type>(0.5+0.5*cosang),
                               static_cast<value_type>(0));
     cos05ang = sqrt(cos05ang);
-
-    value_type sig = dot(nv1, cross(tui2, tnv2));
+    value_type sig = dot(nto1, cross(nto2, tnv2));
     value_type sin05ang = max(static_cast<value_type>(0.5-0.5*cosang),
                               static_cast<value_type>(0));
     sin05ang = copysign(sqrt(sin05ang), sig);
-    q *= Quaternion::fromRealImag(cos05ang, sin05ang*nv1);
+    q *= Quaternion::fromRealImag(cos05ang, sin05ang*nto1);
 
     return q;
   }
 
 
-//   OpenFDM_FORCE_INLINE
-//   static Quaternion zeros(void)
-//   { return Quaternion(Vector4<T>::zeros()); }
-  OpenFDM_FORCE_INLINE
-  static Quaternion unit(unsigned i = 1)
-  { return Quaternion(Vector4<T>::unit(i)); }
-
-
   // Return a quaternion which rotates the vector given by v
   // to the vector -v. Other directions are *not* preserved.
   static Quaternion fromChangeSign(const Vector3& v)
@@ -370,13 +355,13 @@
     Vector3 axis;
     if (absv2 < absv1 && absv3 < absv1) {
       value_type quot = v(2)/v(1);
-      axis = (1/sqrt(1+quot*quot))*Vector3(quot, 1, 0);
+      axis = (1/sqrt(1+quot*quot))*Vector3(quot, -1, 0);
     } else if (absv1 < absv2 && absv3 < absv2) {
       value_type quot = v(3)/v(2);
-      axis = (1/sqrt(1+quot*quot))*Vector3(0, quot, 1);
+      axis = (1/sqrt(1+quot*quot))*Vector3(0, quot, -1);
     } else if (absv1 < absv3 && absv2 < absv3) {
       value_type quot = v(1)/v(3);
-      axis = (1/sqrt(1+quot*quot))*Vector3(1, 0, quot);
+      axis = (1/sqrt(1+quot*quot))*Vector3(-1, 0, quot);
     } else {
       // The all zero case.
       return Quaternion::unit(1);
@@ -416,7 +401,7 @@
 
     // Compute the rotation axis, that is
     // sin(angle)*normalized rotation axis
-    Vector3 axis = cross(from, to);
+    Vector3 axis = cross(to, from);
 
     // We need sin(0.5*angle)*normalized rotation axis.
     // So rescale with sin(0.5*x)/sin(x).
@@ -442,11 +427,7 @@
     // For larger rotations. first rotate from to -from.
     // Past that we will have a smaller angle again.
     Quaternion q1 = Quaternion::fromChangeSign(from);
-    Vector3 t2 = q1.transform(to);
-    Vector3 f2 = -from;
-    value_type cosang2 = dot(f2, t2);
-    Quaternion q2 = Quaternion::fromRotateToSmaller90Deg(cosang2, f2, t2);
-
+    Quaternion q2 = Quaternion::fromRotateToSmaller90Deg(-cosang, -from, to);
     return q1*q2;
   }
 };

Added: trunk/OpenFDM/src/OpenFDM/quattest.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/quattest.cpp	2005-11-01 08:27:13 UTC (rev 49)
+++ trunk/OpenFDM/src/OpenFDM/quattest.cpp	2005-11-01 08:39:47 UTC (rev 50)
@@ -0,0 +1,97 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
+ *
+ */
+
+#include <cstdlib>
+#include <iostream>
+#include "Quaternion.h"
+
+namespace OpenFDM {
+
+/// Return random vector
+Vector3
+rVec(void)
+{
+  return Vector3(drand48()-0.5, drand48()-0.5, drand48()-0.5);
+}
+
+/// Return normalized random vector
+Vector3
+rnVec(void)
+{
+  return normalize(rVec());
+}
+
+int
+quattest(void)
+{
+  real_type eps = Limits<real_type>::epsilon();
+  unsigned nTests = 10000;
+
+  // Testing fromRotateTo factory
+  for (unsigned i = 0; i < nTests; ++i) {
+    Vector3 from = rnVec();
+    Vector3 to = rnVec();
+    Quaternion q = Quaternion::fromRotateTo(from, to);
+
+    if (!equal(q.transform(from), to, 100*eps)) {
+      std::cerr << "Failing on test " << i << " Quaternion::fromRotateTo("
+                << trans(from) << ", " << trans(to) << "):\n"
+                << "q = " << q << "\n"
+                << "q.transform(from) = " << trans(q.transform(from)) << "\n"
+                << "q.backTransform(from) = " << trans(q.backTransform(from))
+                << std::endl;
+      return -1;
+    }
+  }
+
+  // Testing fromRotateTo factory
+  for (unsigned i = 0; i < nTests; ++i) {
+    Vector3 from1 = rnVec();
+    unsigned i1 = 1;
+    Vector3 from2 = rnVec();
+    unsigned i2 = 2;
+    // Make sure they are not linearily dependent
+    while (dot(from1, from2) < 0.1) {
+      from2 = rnVec();
+    }
+
+    Quaternion q = Quaternion::fromRotateTo(from1, i1, from2, i2);
+
+    if (!equal(q.transform(from1), Vector3::unit(i1), 1e2*eps)) {
+      std::cerr << "Failing on test " << i << " Quaternion::fromRotateTo("
+                << trans(from1) << ", " << i1 << ", "
+                << trans(from2) << ", " << i2 << "):\n"
+                << "q = " << q << "\n"
+                << "q.transform(from1) = " << trans(q.transform(from1)) << "\n"
+                << "q.backTransform(from1) = " << trans(q.backTransform(from1))
+                << std::endl;
+      return -1;
+    }
+    Vector3 from2Orth = normalize(cross(cross(from1, from2), from1));
+    if (!equal(q.transform(from2Orth), Vector3::unit(i2), 1e3*eps)
+        || (0 > dot(q.transform(from2), Vector3::unit(i2)))) {
+      std::cerr << "Failing on test " << i << " Quaternion::fromRotateTo("
+                << trans(from1) << ", " << i1 << ", "
+                << trans(from2) << ", " << i2 << "):\n"
+                << "q = " << q << "\n"
+                << "q.transform(from2Orth) = "
+                << trans(q.transform(from2Orth)) << "\n"
+                << "q.backTransform(from2Orth) = "
+                << trans(q.backTransform(from2Orth))
+                << std::endl;
+      return -1;
+    }
+
+  }
+
+  return 0;
+}
+
+}
+
+int
+main(int argc, char *argv[])
+{
+  return OpenFDM::quattest();
+}


Property changes on: trunk/OpenFDM/src/OpenFDM/quattest.cpp
___________________________________________________________________
Name: svn:eol-style
   + native



From frohlich at berlios.de  Tue Nov  1 12:31:53 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Tue, 1 Nov 2005 12:31:53 +0100
Subject: [OpenFDM-svn] r51 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200511011131.jA1BVrdg003477@sheep.berlios.de>

Author: frohlich
Date: 2005-11-01 12:31:30 +0100 (Tue, 01 Nov 2005)
New Revision: 51

Modified:
   trunk/OpenFDM/src/OpenFDM/Joint.h
   trunk/OpenFDM/src/OpenFDM/JointT.h
   trunk/OpenFDM/src/OpenFDM/PrismaticJoint.cpp
   trunk/OpenFDM/src/OpenFDM/PrismaticJoint.h
   trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp
   trunk/OpenFDM/src/OpenFDM/RevoluteJoint.h
   trunk/OpenFDM/src/OpenFDM/RigidBody.cpp
   trunk/OpenFDM/src/OpenFDM/RigidBody.h
Log:
Make the ABA work (still very ugly).


Modified: trunk/OpenFDM/src/OpenFDM/Joint.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Joint.h	2005-11-01 08:39:47 UTC (rev 50)
+++ trunk/OpenFDM/src/OpenFDM/Joint.h	2005-11-01 11:31:30 UTC (rev 51)
@@ -107,7 +107,8 @@
     if (!outboardBody)
       return false;
 
-    Log(ArtBody, Debug) << "Contributing articulation through joint \""
+    Log(ArtBody, Debug) << "Contributing articulation from \""
+                        << outboardBody->getName() << "\" through joint \""
                         << getName() << "\"" << endl;
 
     // We need the articulated inertia and force from the outboard body.
@@ -115,7 +116,7 @@
     Vector6 F = outboardBody->getArtForce();
 
     Log(ArtBody, Debug3) << "Outboard Articulated values: Force:\n"
-                         << F << "\nInertia\n" << I << endl;
+                         << trans(F) << "\nInertia\n" << I << endl;
 
     // Apply the joint degrees of freedom to that.
     // If there was an error, (something was singular ???)
@@ -124,7 +125,7 @@
       return false;
 
     Log(ArtBody, Debug3) << "Outboard Articulated values past joint "
-                         << "projection: Force:\n" << F
+                         << "projection: Force:\n" << trans(F)
                          << "\nInertia\n" << I << endl;
 
     // Contribute the transformed values to the parent.

Modified: trunk/OpenFDM/src/OpenFDM/JointT.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/JointT.h	2005-11-01 08:39:47 UTC (rev 50)
+++ trunk/OpenFDM/src/OpenFDM/JointT.h	2005-11-01 11:31:30 UTC (rev 51)
@@ -24,40 +24,58 @@
 
   bool jointArticulation(SpatialInertia& artI,
                          Vector6& artF,
+                         const Vector6& pAlpha,
                          const Vector6& jointForce,
-                         const Vector6& frameDotQ,
                          const Matrix6N& jointAxis)
   {
+    Log(ArtBody, Debug1) << artI << endl;
+
+    mJointForce = jointForce;
+
     Matrix6N Ih = artI*jointAxis;
     hIh = trans(jointAxis)*Ih;
-    
+
     if (hIh.singular())
       return false;
 
-    artF += artI*frameDotQ;
-    Vector6 pAlpha = artF;
+    artF = pAlpha;
     
-    mForcePAlpha = jointForce - pAlpha;
-    artF += Ih*hIh.solve(trans(jointAxis)*mForcePAlpha);
+    Vector6 mForcePAlpha = pAlpha - jointForce;
+
+    Log(ArtBody, Debug1) << trans(jointAxis)*Ih
+                         << endl
+                         << trans(jointForce)
+                         << endl
+                         << trans(pAlpha)
+                         << endl
+                         << trans(Ih*hIh.solve(trans(jointAxis)*mForcePAlpha))
+                         << endl
+                         << SpatialInertia(Ih*hIh.solve(trans(Ih)))
+                         << endl;
+
+
+    artF -= Ih*hIh.solve(trans(jointAxis)*mForcePAlpha);
     artI -= SpatialInertia(Ih*hIh.solve(trans(Ih)));
+
     return true;
   }
   
   void computeRelAccel(const SpatialInertia& outBoardArtInertia,
                        const Vector6& parentSpAccel,
+                       const Vector6& pAlpha,
                        const Matrix6N& jointAxis,
                        VectorN& jointAccel) const
   {
     if (hIh.singular()) {
       jointAccel.clear();
     } else {
-      Vector6 tmp = mForcePAlpha - outBoardArtInertia*parentSpAccel;
+      Vector6 tmp = mJointForce - outBoardArtInertia*parentSpAccel - pAlpha;
       jointAccel = hIh.solve(trans(jointAxis)*tmp);
     }
   }
 
 private:
-  Vector6 mForcePAlpha;
+  Vector6 mJointForce;
   MatrixFactorsNN hIh;
 };
 

Modified: trunk/OpenFDM/src/OpenFDM/PrismaticJoint.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/PrismaticJoint.cpp	2005-11-01 08:39:47 UTC (rev 50)
+++ trunk/OpenFDM/src/OpenFDM/PrismaticJoint.cpp	2005-11-01 11:31:30 UTC (rev 51)
@@ -25,6 +25,12 @@
   mJointAcceleration = 0;
   mJointAxis = Vector3::unit(1);
   mPosition = Vector3::zeros();
+  mSpringCoef = 0;
+  mDampCoef = 0;
+
+  setNumOutputPorts(2);
+  setOutputPort(0, "jointPos", Property(this, &PrismaticJoint::getJointPos));
+  setOutputPort(1, "jointVel", Property(this, &PrismaticJoint::getJointVel));
 }
 
 PrismaticJoint::~PrismaticJoint(void)
@@ -75,19 +81,28 @@
 {
   // That projects away tha components where the degrees of freedom
   // of the joint are.
+  RigidBody* out = getOutboardGroup()->toRigidBody();
   real_type tau = getJointForce();
-  return JointT<1>::jointArticulation(artI, artF, tau*getJointAxis(),
-                                      getHdot(), getJointAxis());
+  return JointT<1>::jointArticulation(artI, artF, out->getPAlpha(),
+                                      tau*getJointAxis(),
+                                      getJointAxis());
 }
 
-
 Vector6
-PrismaticJoint::computeRelAccel(const SpatialInertia& artI,
-                                const Vector6& artF)
+PrismaticJoint::computeRelAccel(const SpatialInertia&,
+                                const Vector6&)
 {
+  RigidBody* out = getOutboardGroup()->toRigidBody();
+  Vector6 parentAccel = out->getParentSpAccel();
+
+  SpatialInertia artI = out->getArtInertia();
+  Vector6 pAlpha = out->getPAlpha();
+
   JointT<1>::VectorN acc;
-  JointT<1>::computeRelAccel(artI, artF, getJointAxis(), acc);
+  JointT<1>::computeRelAccel(artI, parentAccel, pAlpha, getJointAxis(), acc);
   mJointAcceleration = acc(1);
+  Log(ArtBody, Debug) << "Relative acceleration for Joint \""
+                      << getName() << "\" is " << trans(acc) << endl;
   return getJointAxis()*acc;
 }
 

Modified: trunk/OpenFDM/src/OpenFDM/PrismaticJoint.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/PrismaticJoint.h	2005-11-01 08:39:47 UTC (rev 50)
+++ trunk/OpenFDM/src/OpenFDM/PrismaticJoint.h	2005-11-01 11:31:30 UTC (rev 51)
@@ -59,9 +59,24 @@
    */
   void setPosition(const Vector3& position);
 
+  void setSpringConstant(real_type springConstant)
+  { mSpringCoef = springConstant; }
+  real_type getSpringConstant(void) const
+  { return mSpringCoef; }
+  void setDampConstant(real_type dampConstant)
+  { mDampCoef = dampConstant; }
+  real_type getDampConstant(void) const
+  { return mDampCoef; }
+
   virtual real_type getJointForce(void) const
-//   { return 0; }
-  { return -1e1*mJointPosition - 1e2*mJointVelocity; }
+  {
+    Log(ArtBody, Debug) << "RevoluteJoint " << getName()
+                        << " pos " << convertTo(uDegree, mJointPosition)
+                        << " vel " << mJointVelocity
+                        << " torque " << mSpringCoef*mJointPosition + mDampCoef*mJointVelocity
+                        << endl;
+    return mSpringCoef*mJointPosition + mDampCoef*mJointVelocity;
+  }
 
 private:
   /** Computes the inboard articulated inertia and force for
@@ -100,6 +115,11 @@
   /** The zero orientation with respect to the parent frame.
    */
   Vector3 mPosition;
+
+  /** Well, for now, just to test. Include these here
+   */
+  real_type mSpringCoef;
+  real_type mDampCoef;
 };
 
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp	2005-11-01 08:39:47 UTC (rev 50)
+++ trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp	2005-11-01 11:31:30 UTC (rev 51)
@@ -26,6 +26,12 @@
   mJointAcceleration = 0;
   mJointAxis = Vector3::unit(1);
   mOrientation = Quaternion::unit();
+  mSpringCoef = 0;
+  mDampCoef = 0;
+
+  setNumOutputPorts(2);
+  setOutputPort(0, "jointPos", Property(this, &RevoluteJoint::getJointPos));
+  setOutputPort(1, "jointVel", Property(this, &RevoluteJoint::getJointVel));
 }
 
 RevoluteJoint::~RevoluteJoint(void)
@@ -80,18 +86,28 @@
 {
   // That projects away tha components where the degrees of freedom
   // of the joint are.
+  RigidBody* out = getOutboardGroup()->toRigidBody();
   real_type tau = getJointForce();
-  return JointT<1>::jointArticulation(artI, artF, tau*getJointAxis(),
-                                      getHdot(), getJointAxis());
+  return JointT<1>::jointArticulation(artI, artF, out->getPAlpha(),
+                                      tau*getJointAxis(),
+                                      getJointAxis());
 }
 
 Vector6
-RevoluteJoint::computeRelAccel(const SpatialInertia& artI,
-                               const Vector6& artF)
+RevoluteJoint::computeRelAccel(const SpatialInertia&,
+                               const Vector6&)
 {
+  RigidBody* out = getOutboardGroup()->toRigidBody();
+  Vector6 parentAccel = out->getParentSpAccel();
+
+  SpatialInertia artI = out->getArtInertia();
+  Vector6 pAlpha = out->getPAlpha();
+
   JointT<1>::VectorN acc;
-  JointT<1>::computeRelAccel(artI, artF, getJointAxis(), acc);
+  JointT<1>::computeRelAccel(artI, parentAccel, pAlpha, getJointAxis(), acc);
   mJointAcceleration = acc(1);
+  Log(ArtBody, Debug) << "Relative acceleration for Joint \""
+                      << getName() << "\" is " << trans(acc) << endl;
   return getJointAxis()*acc;
 }
 

Modified: trunk/OpenFDM/src/OpenFDM/RevoluteJoint.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RevoluteJoint.h	2005-11-01 08:39:47 UTC (rev 50)
+++ trunk/OpenFDM/src/OpenFDM/RevoluteJoint.h	2005-11-01 11:31:30 UTC (rev 51)
@@ -59,9 +59,24 @@
    */
   void setOrientation(const Quaternion& orientation);
 
+  void setSpringConstant(real_type springConstant)
+  { mSpringCoef = springConstant; }
+  real_type getSpringConstant(void) const
+  { return mSpringCoef; }
+  void setDampConstant(real_type dampConstant)
+  { mDampCoef = dampConstant; }
+  real_type getDampConstant(void) const
+  { return mDampCoef; }
+
   virtual real_type getJointForce(void) const
-//   { return 0; }
-  { return -1e1*mJointPosition - 1e2*mJointVelocity; }
+  {
+    Log(ArtBody, Debug) << "RevoluteJoint " << getName()
+                        << " pos " << convertTo(uDegree, mJointPosition)
+                        << " vel " << mJointVelocity
+                        << " torque " << mSpringCoef*mJointPosition + mDampCoef*mJointVelocity
+                        << endl;
+    return mSpringCoef*mJointPosition + mDampCoef*mJointVelocity;
+  }
 
 private:
   /** Computes the inboard articulated inertia and force for
@@ -107,6 +122,11 @@
       only used for animations and thus could be postprocessed.
    */
   bool mTrackPosition;
+
+  /** Well, for now, just to test. Include these here
+   */
+  real_type mSpringCoef;
+  real_type mDampCoef;
 };
 
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/RigidBody.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RigidBody.cpp	2005-11-01 08:39:47 UTC (rev 50)
+++ trunk/OpenFDM/src/OpenFDM/RigidBody.cpp	2005-11-01 11:31:30 UTC (rev 51)
@@ -73,6 +73,7 @@
   // 
   Vector6 iv = getSpVel();
   Vector6 Jiv = mArtInertia*iv;
+  Log(ArtBody, Debug3) << "Spatial velocity is " << trans(iv) << endl;
   mArtForce = Vector6(cross(iv.getAngular(), Jiv.getAngular()) +
                       cross(iv.getLinear(), Jiv.getLinear()),
                       cross(iv.getAngular(), Jiv.getLinear()));

Modified: trunk/OpenFDM/src/OpenFDM/RigidBody.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RigidBody.h	2005-11-01 08:39:47 UTC (rev 50)
+++ trunk/OpenFDM/src/OpenFDM/RigidBody.h	2005-11-01 11:31:30 UTC (rev 51)
@@ -70,6 +70,11 @@
   const Vector6& getArtForce(void) const
   { return mArtForce; }
 
+  /** HMM
+   */
+  Vector6 getPAlpha(void) const
+  { return mArtForce + mArtInertia*getHdot(); }
+
   /**
    */
   void contributeForce(const Vector6& force)



From frohlich at berlios.de  Wed Nov  2 23:13:45 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Wed, 2 Nov 2005 23:13:45 +0100
Subject: [OpenFDM-svn] r53 - trunk/flightgear
Message-ID: <200511022213.jA2MDjAY002496@sheep.berlios.de>

Author: frohlich
Date: 2005-11-02 23:13:43 +0100 (Wed, 02 Nov 2005)
New Revision: 53

Modified:
   trunk/flightgear/FGOpenFDM.cpp
Log:
Make it compile with current fg.
Some debugging stuff ...


Modified: trunk/flightgear/FGOpenFDM.cpp
===================================================================
--- trunk/flightgear/FGOpenFDM.cpp	2005-11-02 22:12:53 UTC (rev 52)
+++ trunk/flightgear/FGOpenFDM.cpp	2005-11-02 22:13:43 UTC (rev 53)
@@ -6,7 +6,7 @@
 #include <simgear/math/sg_geodesy.hxx>
 #include <simgear/props/props.hxx>
 
-#include <Controls/controls.hxx>
+#include <Aircraft/controls.hxx>
 #include <Main/globals.hxx>
 #include <Main/fg_props.hxx>
 
@@ -161,20 +161,20 @@
   virtual ~StatePrintVisitor(void) {}
   virtual void apply(const MultiBodyModel& node)
   {
-    if (node.getName() != "Aerodynamic force")
-      return;
-    const AeroForce* aeroForce = (const AeroForce*)&node;
-    std::cout << "Alpha " << convertTo(uDegree, aeroForce->getAlpha())
-              << ", Beta " << convertTo(uDegree, aeroForce->getBeta())
-//               << ", Mach " << aeroForce->getMachNumber()
-              << ", speed " << trans(aeroForce->getAirSpeed())
-              << std::endl;
+//     if (node.getName() != "Aerodynamic force")
+//       return;
+//     const AeroForce* aeroForce = (const AeroForce*)&node;
+//     std::cout << "Alpha " << convertTo(uDegree, aeroForce->getAlpha())
+//               << ", Beta " << convertTo(uDegree, aeroForce->getBeta())
+// //               << ", Mach " << aeroForce->getMachNumber()
+//               << ", speed " << trans(aeroForce->getAirSpeed())
+//               << std::endl;
 
-//     Vector v(node.getNumContinousStates());
-//     node.getState(v, 0);
-//     std::cout << std::setw(_indent) << ""
-//               << "\"" << node.getName() << "\", "
-//               << trans(v) << endl;
+    Vector v(node.getNumContinousStates());
+    node.getState(v, 0);
+    std::cout << std::setw(_indent) << ""
+              << "\"" << node.getName() << "\", "
+              << trans(v) << endl;
   }
   virtual void apply(const Frame& group)
   {
@@ -182,12 +182,12 @@
               << "Traversing \""
               << group.getName() << "\" ("
               << trans(group.getRelVel().getLinear())
-              << ", "
-              << trans(group.getSpVel().getLinear())
-              << ", "
-              << trans(group.getRelAccel().getLinear())
-              << ", "
-              << trans(group.getSpAccel().getLinear())
+//               << ", "
+//               << trans(group.getSpVel().getLinear())
+//               << ", "
+//               << trans(group.getRelAccel().getLinear())
+//               << ", "
+//               << trans(group.getSpAccel().getLinear())
               << "), "
               << endl;
     _indent += 3;



From frohlich at berlios.de  Wed Nov  2 23:13:07 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Wed, 2 Nov 2005 23:13:07 +0100
Subject: [OpenFDM-svn] r52 - in trunk/OpenFDM/src: JSBSim OpenFDM
Message-ID: <200511022213.jA2MD7ou002456@sheep.berlios.de>

Author: frohlich
Date: 2005-11-02 23:12:53 +0100 (Wed, 02 Nov 2005)
New Revision: 52

Added:
   trunk/OpenFDM/src/OpenFDM/AirSpring.cpp
   trunk/OpenFDM/src/OpenFDM/AirSpring.h
   trunk/OpenFDM/src/OpenFDM/LineForce.cpp
   trunk/OpenFDM/src/OpenFDM/LineForce.h
   trunk/OpenFDM/src/OpenFDM/LinearSpring.cpp
   trunk/OpenFDM/src/OpenFDM/LinearSpring.h
Modified:
   trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
   trunk/OpenFDM/src/OpenFDM/Makefile.am
   trunk/OpenFDM/src/OpenFDM/PrismaticJoint.cpp
   trunk/OpenFDM/src/OpenFDM/PrismaticJoint.h
   trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp
   trunk/OpenFDM/src/OpenFDM/RevoluteJoint.h
Log:
Add some 1d forces.


Modified: trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
===================================================================
--- trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2005-11-01 11:31:30 UTC (rev 51)
+++ trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2005-11-02 22:12:53 UTC (rev 52)
@@ -21,7 +21,11 @@
 #include <OpenFDM/Gain.h>
 #include <OpenFDM/Input.h>
 #include <OpenFDM/Mass.h>
+#include <OpenFDM/LinearSpring.h>
+#include <OpenFDM/AirSpring.h>
+#include <OpenFDM/PrismaticJoint.h>
 #include <OpenFDM/Product.h>
+#include <OpenFDM/RevoluteJoint.h>
 #include <OpenFDM/Saturation.h>
 #include <OpenFDM/Sensor.h>
 #include <OpenFDM/SimpleContact.h>
@@ -681,6 +685,12 @@
     std::string uctype;
     datastr >> uctype;
     
+    std::stringstream sstr;
+    sstr << gearNumber;
+    std::string numStr = sstr.str();
+    // Increment the gear number
+    ++gearNumber;
+
     if (uctype == "AC_GEAR") {
       std::string name, type, brake, retract;
       real_type x, y, z, k, d, fs, fd, rr, sa;
@@ -719,10 +729,6 @@
         
         // Connect apprioriate input and output models
 
-        std::stringstream sstr;
-        sstr << gearNumber;
-        std::string numStr = sstr.str();
-
         // FIXME
         // missing output properties are "wow" and "tire-pressure-norm"
 
@@ -785,6 +791,179 @@
       std::string d;
       datastr >> d >> d >> d >> d >> d >> d >> d >> d >> d >> d >> d >> d >> d;
 
+    } else if (uctype == "AC_F18MLG") { 
+      /// Well, that here is exactly how it should not be,
+      /// but for initial testing of a new unfinished fdm ...
+      std::string name, brake;
+      Vector3 compressJointPos;
+      real_type pullPress;
+      real_type pushPress;
+      real_type area;
+      real_type minCompr;
+      real_type maxCompr;
+      real_type minDamp;
+      real_type maxDamp;
+      real_type armLength;
+      real_type wheelDiam;
+      real_type tireSpring, tireDamp;
+
+
+      datastr >> name >> brake
+              >> compressJointPos(1)
+              >> compressJointPos(2)
+              >> compressJointPos(3)
+              >> pullPress >> pushPress
+              >> area
+              >> minCompr
+              >> maxCompr
+              >> minDamp
+              >> maxDamp
+              >> armLength
+              >> wheelDiam
+              >> tireSpring >> tireDamp;
+
+
+      RigidBody* arm = new RigidBody(name + " Arm");
+      mVehicle->getTopBody()->addChildFrame(arm);
+      arm->addMultiBodyModel(new Mass(inertiaFrom(Vector3(-1, 0, 0), SpatialInertia(200))));
+
+      RevoluteJoint* rj = new RevoluteJoint(name + " Arm Joint");
+      mVehicle->getTopBody()->addMultiBodyModel(rj, 0);
+      arm->addMultiBodyModel(rj, 1);
+      rj->setJointAxis(Vector3(0, 1, 0));
+      rj->setJointPos(0);
+      rj->setJointVel(0);
+      rj->setPosition(structToBody(compressJointPos)
+                      + Vector3(0, 0, 0.5*wheelDiam));
+      rj->setOrientation(Quaternion::unit());
+
+      AirSpring* aoDamp = new AirSpring(name + " Air Spring Force");
+      aoDamp->setPullPressure(pullPress);
+      aoDamp->setPushPressure(pushPress);
+      aoDamp->setArea(area);
+      aoDamp->setMinCompression(minCompr);
+      aoDamp->setMaxCompression(maxCompr);
+      aoDamp->setMinDamperConstant(minDamp);
+      aoDamp->setMaxDamperConstant(maxDamp);
+      rj->setLineForce(aoDamp);
+
+      SimpleGear* sg = new SimpleGear(name, mVehicle->getEnvironment());
+      arm->addMultiBodyModel(sg);
+//       sg->setPosition(Vector3(-armLength, 0, 0.5*wheelDiam));
+      sg->setPosition(Vector3(-armLength, 0, 0));
+      sg->setSpringConstant(convertFrom(uPoundForcePFt, tireSpring));
+      sg->setSpringDamping(convertFrom(uPoundForcePFt, tireDamp));
+      sg->setFrictionCoeficient(0.9);
+
+      if (brake == "LEFT") {
+        MaxExpressionImpl* mex = new MaxExpressionImpl;
+        Property prop = lookupJSBExpression("/controls/gear/brake-left");
+        mex->addInputProperty(prop);
+        prop = lookupJSBExpression("/controls/gear/copilot-brake-left");
+        mex->addInputProperty(prop);
+        prop = lookupJSBExpression("/controls/gear/brake-parking");
+        mex->addInputProperty(prop);
+        sg->setInputPort("brakeCommand", Property(mex));
+      } else if (brake == "RIGHT") {
+        MaxExpressionImpl* mex = new MaxExpressionImpl;
+        Property prop = lookupJSBExpression("/controls/gear/brake-right");
+        mex->addInputProperty(prop);
+        prop = lookupJSBExpression("/controls/gear/copilot-brake-right");
+        mex->addInputProperty(prop);
+        prop = lookupJSBExpression("/controls/gear/brake-parking");
+        mex->addInputProperty(prop);
+        sg->setInputPort("brakeCommand", Property(mex));
+      }
+
+      Property prop = rj->getOutputPort(0);
+      addOutputModel(prop, "Gear " + numStr + " Compression",
+                     "/gear/gear[" + numStr + "]/compression-rad");
+
+      prop = lookupJSBExpression("gear/gear-pos-norm");
+      addOutputModel(prop, "Gear " + numStr + " Position",
+                     "/gear/gear[" + numStr + "]/position-norm");
+
+    } else if (uctype == "AC_CLG") { 
+      std::string name, brake;
+      Vector3 compressJointPos;
+      real_type pullPress;
+      real_type pushPress;
+      real_type area;
+      real_type minCompr;
+      real_type maxCompr;
+      real_type minDamp;
+      real_type maxDamp;
+      real_type wheelDiam;
+      real_type tireSpring, tireDamp;
+
+      datastr >> name >> brake
+              >> compressJointPos(1)
+              >> compressJointPos(2)
+              >> compressJointPos(3)
+              >> pullPress >> pushPress
+              >> area
+              >> minCompr
+              >> maxCompr
+              >> minDamp
+              >> maxDamp
+              >> wheelDiam
+              >> tireSpring >> tireDamp;
+
+      RigidBody* arm = new RigidBody(name + " Strut");
+      mVehicle->getTopBody()->addChildFrame(arm);
+      arm->addMultiBodyModel(new Mass(inertiaFrom(Vector3(0, 0, 1), SpatialInertia(200))));
+
+      PrismaticJoint* pj = new PrismaticJoint(name + " Compress Joint");
+      mVehicle->getTopBody()->addMultiBodyModel(pj, 0);
+      arm->addMultiBodyModel(pj, 1);
+      pj->setJointAxis(Vector3(0, 0, -1));
+      pj->setPosition(structToBody(compressJointPos) + Vector3(0, 0, 0.5*wheelDiam));
+
+      AirSpring* aoDamp = new AirSpring(name + " Air Spring Force");
+      aoDamp->setPullPressure(pullPress);
+      aoDamp->setPushPressure(pushPress);
+      aoDamp->setArea(area);
+      aoDamp->setMinCompression(minCompr);
+      aoDamp->setMaxCompression(maxCompr);
+      aoDamp->setMinDamperConstant(minDamp);
+      aoDamp->setMaxDamperConstant(maxDamp);
+      pj->setLineForce(aoDamp);
+
+      SimpleGear* sg = new SimpleGear(name, mVehicle->getEnvironment());
+      arm->addMultiBodyModel(sg);
+      sg->setPosition(Vector3(0, 0, 0));
+      sg->setSpringConstant(convertFrom(uPoundForcePFt, tireSpring));
+      sg->setSpringDamping(convertFrom(uPoundForcePFt, tireDamp));
+      sg->setFrictionCoeficient(0.9);
+
+      if (brake == "LEFT") {
+        MaxExpressionImpl* mex = new MaxExpressionImpl;
+        Property prop = lookupJSBExpression("/controls/gear/brake-left");
+        mex->addInputProperty(prop);
+        prop = lookupJSBExpression("/controls/gear/copilot-brake-left");
+        mex->addInputProperty(prop);
+        prop = lookupJSBExpression("/controls/gear/brake-parking");
+        mex->addInputProperty(prop);
+        sg->setInputPort("brakeCommand", Property(mex));
+      } else if (brake == "RIGHT") {
+        MaxExpressionImpl* mex = new MaxExpressionImpl;
+        Property prop = lookupJSBExpression("/controls/gear/brake-right");
+        mex->addInputProperty(prop);
+        prop = lookupJSBExpression("/controls/gear/copilot-brake-right");
+        mex->addInputProperty(prop);
+        prop = lookupJSBExpression("/controls/gear/brake-parking");
+        mex->addInputProperty(prop);
+        sg->setInputPort("brakeCommand", Property(mex));
+      }
+
+      Property prop = pj->getOutputPort(0);
+      addOutputModel(prop, "Gear " + numStr + " Compression",
+                     "/gear/gear[" + numStr + "]/compression-m");
+
+      prop = lookupJSBExpression("gear/gear-pos-norm");
+      addOutputModel(prop, "Gear " + numStr + " Position",
+                     "/gear/gear[" + numStr + "]/position-norm");
+
     } else if (uctype == "AC_CONTACT") {
       std::string name, type, brake, retract;
       real_type x, y, z, k, d, fs, fd, rr, sa;
@@ -804,9 +983,6 @@
 
       mVehicle->getTopBody()->addMultiBodyModel(sc);
     }
-
-    // Increment the gear number
-    ++gearNumber;
   }
 
   return true;

Added: trunk/OpenFDM/src/OpenFDM/AirSpring.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/AirSpring.cpp	2005-11-01 11:31:30 UTC (rev 51)
+++ trunk/OpenFDM/src/OpenFDM/AirSpring.cpp	2005-11-02 22:12:53 UTC (rev 52)
@@ -0,0 +1,150 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
+ *
+ */
+
+#include "Model.h"
+#include "Vector.h"
+#include "AirSpring.h"
+
+namespace OpenFDM {
+
+AirSpring::AirSpring(const std::string& name) :
+  LineForce(name),
+  mPushPressure(2e5),
+  mPullPressure(1e5),
+  mArea(0),
+  mMinCompression(0),
+  mMaxCompression(0),
+  mMinDamperConstant(0),
+  mMaxDamperConstant(0),
+  mGamma(1.3)
+{
+}
+
+AirSpring::~AirSpring(void)
+{
+}
+
+void
+AirSpring::output(const TaskInfo& taskInfo)
+{
+  real_type maxDisp = mMaxCompression - mMinCompression;
+  real_type pullDisp = mMaxCompression - getPosition();
+  real_type pushDisp = getPosition() - mMinCompression;
+  
+  real_type pullDispRatio = pullDisp/maxDisp;
+  real_type pushDispRatio = pushDisp/maxDisp;
+  
+  
+  pullDispRatio = max(min(pullDispRatio, 0.99), 0.0);
+  pushDispRatio = max(min(pushDispRatio, 0.99), 0.0);
+  
+  real_type pullPressure = mPullPressure/(1-pow(pullDispRatio, mGamma));
+  real_type pushPressure = mPushPressure/(1-pow(pushDispRatio, mGamma));
+  
+  real_type force = sign(maxDisp)*mArea*(pullPressure - pushPressure);
+  // Add a position dependent damping force
+  force += getVel()*interpolate(getPosition(),
+                                mMinCompression, mMinDamperConstant,
+                                mMaxCompression, mMaxDamperConstant);
+  
+  setForce(force);
+}
+
+real_type
+AirSpring::getPushPressure(void) const
+{
+  return mPushPressure;
+}
+
+void
+AirSpring::setPushPressure(real_type pushPressure)
+{
+  mPushPressure = pushPressure;
+}
+
+real_type
+AirSpring::getPullPressure(void) const
+{
+  return mPullPressure;
+}
+
+void
+AirSpring::setPullPressure(real_type pullPressure)
+{
+  mPullPressure = pullPressure;
+}
+
+real_type
+AirSpring::getArea(void) const
+{
+  return mArea;
+}
+
+void
+AirSpring::setArea(real_type area)
+{
+  mArea = area;
+}
+
+real_type
+AirSpring::getMaxCompression(void) const
+{
+  return mMaxCompression;
+}
+
+void
+AirSpring::setMaxCompression(real_type maxCompression)
+{
+  mMaxCompression = maxCompression;
+}
+
+real_type
+AirSpring::getMinCompression(void) const
+{
+  return mMinCompression;
+}
+
+void
+AirSpring::setMinCompression(real_type minCompression)
+{
+  mMinCompression = minCompression;
+}
+
+real_type
+AirSpring::getMaxDamperConstant(void) const
+{
+  return mMaxDamperConstant;
+}
+
+void
+AirSpring::setMaxDamperConstant(real_type maxDamperConstant)
+{
+  mMaxDamperConstant = maxDamperConstant;
+}
+
+real_type
+AirSpring::getMinDamperConstant(void) const
+{
+  return mMinDamperConstant;
+}
+
+void
+AirSpring::setMinDamperConstant(real_type minDamperConstant)
+{
+  mMinDamperConstant = minDamperConstant;
+}
+
+real_type
+AirSpring::getGamma(void) const
+{
+  return mGamma;
+}
+
+void
+AirSpring::setGamma(real_type gamma)
+{
+  mGamma = gamma;
+}
+
+} // namespace OpenFDM


Property changes on: trunk/OpenFDM/src/OpenFDM/AirSpring.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/OpenFDM/src/OpenFDM/AirSpring.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/AirSpring.h	2005-11-01 11:31:30 UTC (rev 51)
+++ trunk/OpenFDM/src/OpenFDM/AirSpring.h	2005-11-02 22:12:53 UTC (rev 52)
@@ -0,0 +1,64 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_AirSpring_H
+#define OpenFDM_AirSpring_H
+
+#include "Model.h"
+#include "Vector.h"
+#include "LineForce.h"
+
+namespace OpenFDM {
+
+/// AirSpring
+class AirSpring :
+    public LineForce {
+public:
+  AirSpring(const std::string& name);
+  virtual ~AirSpring(void);
+
+  virtual void output(const TaskInfo& taskInfo);
+
+  real_type getPushPressure(void) const;
+  void setPushPressure(real_type pushPressure);
+
+  real_type getPullPressure(void) const;
+  void setPullPressure(real_type pullPressure);
+
+  real_type getArea(void) const;
+  void setArea(real_type area);
+
+  real_type getMaxCompression(void) const;
+  void setMaxCompression(real_type maxCompression);
+
+  real_type getMinCompression(void) const;
+  void setMinCompression(real_type minCompression);
+
+  real_type getMaxDamperConstant(void) const;
+  void setMaxDamperConstant(real_type maxDamperConstant);
+
+  real_type getMinDamperConstant(void) const;
+  void setMinDamperConstant(real_type minDamperConstant);
+
+  real_type getGamma(void) const;
+  void setGamma(real_type gamma);
+
+private:
+  real_type mPushPressure;
+  real_type mPullPressure;
+
+  real_type mArea;
+
+  real_type mMaxCompression;
+  real_type mMinCompression;
+
+  real_type mMaxDamperConstant;
+  real_type mMinDamperConstant;
+
+  real_type mGamma;
+};
+
+} // namespace OpenFDM
+
+#endif


Property changes on: trunk/OpenFDM/src/OpenFDM/AirSpring.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/OpenFDM/src/OpenFDM/LineForce.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/LineForce.cpp	2005-11-01 11:31:30 UTC (rev 51)
+++ trunk/OpenFDM/src/OpenFDM/LineForce.cpp	2005-11-02 22:12:53 UTC (rev 52)
@@ -0,0 +1,32 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
+ *
+ */
+
+#include "Model.h"
+#include "Vector.h"
+#include "LineForce.h"
+
+namespace OpenFDM {
+
+LineForce::LineForce(const std::string& name) :
+  Model(name)
+{
+}
+
+LineForce::~LineForce(void)
+{
+}
+
+void
+LineForce::computeForce(real_type position, real_type vel)
+{
+  // Set the position and velocity
+  mPosition = position;
+  mVel = vel;
+  // call the output function
+  TaskInfo taskInfo;
+  taskInfo.addSampleTime(SampleTime::Continous);
+  output(taskInfo);
+}
+
+} // namespace OpenFDM


Property changes on: trunk/OpenFDM/src/OpenFDM/LineForce.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/OpenFDM/src/OpenFDM/LineForce.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/LineForce.h	2005-11-01 11:31:30 UTC (rev 51)
+++ trunk/OpenFDM/src/OpenFDM/LineForce.h	2005-11-02 22:12:53 UTC (rev 52)
@@ -0,0 +1,41 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_LineForce_H
+#define OpenFDM_LineForce_H
+
+#include "Model.h"
+#include "Vector.h"
+
+namespace OpenFDM {
+
+class LineForce :
+    public Model {
+public:
+  LineForce(const std::string& name);
+  virtual ~LineForce(void);
+
+  void computeForce(real_type position, real_type vel);
+
+  real_type getPosition(void) const
+  { return mPosition; }
+  real_type getVel(void) const
+  { return mVel; }
+
+  real_type getForce(void) const
+  { return mForce; }
+
+protected:
+  void setForce(real_type force)
+  { mForce = force; }
+
+private:
+  real_type mPosition;
+  real_type mVel;
+  real_type mForce;
+};
+
+} // namespace OpenFDM
+
+#endif


Property changes on: trunk/OpenFDM/src/OpenFDM/LineForce.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/OpenFDM/src/OpenFDM/LinearSpring.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/LinearSpring.cpp	2005-11-01 11:31:30 UTC (rev 51)
+++ trunk/OpenFDM/src/OpenFDM/LinearSpring.cpp	2005-11-02 22:12:53 UTC (rev 52)
@@ -0,0 +1,66 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
+ *
+ */
+
+#include "Model.h"
+#include "Vector.h"
+#include "LinearSpring.h"
+
+namespace OpenFDM {
+
+LinearSpring::LinearSpring(const std::string& name) :
+  LineForce(name),
+  mSpringReference(0),
+  mSpringConstant(0),
+  mDamperConstant(0)
+{
+}
+
+LinearSpring::~LinearSpring(void)
+{
+}
+
+void
+LinearSpring::output(const TaskInfo& taskInfo)
+{
+  real_type displacement = getPosition() - mSpringReference;
+  setForce(mSpringConstant*displacement + getVel()*mDamperConstant);
+}
+
+real_type
+LinearSpring::getSpringReference(void) const
+{
+  return mSpringReference;
+}
+
+void
+LinearSpring::setSpringReference(real_type springReference)
+{
+  mSpringReference = springReference;
+}
+
+real_type
+LinearSpring::getSpringConstant(void) const
+{
+  return mSpringConstant;
+}
+
+void
+LinearSpring::setSpringConstant(real_type springConstant)
+{
+  mSpringConstant = springConstant;
+}
+
+real_type
+LinearSpring::getDamperConstant(void) const
+{
+  return mDamperConstant;
+}
+
+void
+LinearSpring::setDamperConstant(real_type damperConstant)
+{
+  mDamperConstant = damperConstant;
+}
+
+} // namespace OpenFDM


Property changes on: trunk/OpenFDM/src/OpenFDM/LinearSpring.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/OpenFDM/src/OpenFDM/LinearSpring.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/LinearSpring.h	2005-11-01 11:31:30 UTC (rev 51)
+++ trunk/OpenFDM/src/OpenFDM/LinearSpring.h	2005-11-02 22:12:53 UTC (rev 52)
@@ -0,0 +1,40 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_LinearSpring_H
+#define OpenFDM_LinearSpring_H
+
+#include "Model.h"
+#include "Vector.h"
+#include "LineForce.h"
+
+namespace OpenFDM {
+
+/// Linear spring damper model
+class LinearSpring :
+    public LineForce {
+public:
+  LinearSpring(const std::string& name);
+  virtual ~LinearSpring(void);
+
+  virtual void output(const TaskInfo& taskInfo);
+
+  real_type getSpringReference(void) const;
+  void setSpringReference(real_type springReference);
+
+  real_type getSpringConstant(void) const;
+  void setSpringConstant(real_type springConstant);
+
+  real_type getDamperConstant(void) const;
+  void setDamperConstant(real_type damperConstant);
+
+private:
+  real_type mSpringReference;
+  real_type mSpringConstant;
+  real_type mDamperConstant;
+};
+
+} // namespace OpenFDM
+
+#endif


Property changes on: trunk/OpenFDM/src/OpenFDM/LinearSpring.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/OpenFDM/src/OpenFDM/Makefile.am
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Makefile.am	2005-11-01 11:31:30 UTC (rev 51)
+++ trunk/OpenFDM/src/OpenFDM/Makefile.am	2005-11-02 22:12:53 UTC (rev 52)
@@ -25,6 +25,7 @@
 libOpenFDM_la_LIBADD = -lsgxml -lsgstructure
 nobase_OpenFDMinclude_HEADERS = \
   AeroForce.h \
+  AirSpring.h \
   Assert.h \
   Atmosphere.h \
   AtmosphereSTD1976.h \
@@ -68,6 +69,8 @@
   LinAlg/IO.h \
   LinAlg/Misc.h \
   LinAlg/Proxy.h \
+  LinearSpring.h \
+  LineForce.h \
   LogStream.h \
   Mass.h \
   Math.h \
@@ -118,6 +121,7 @@
 
 libOpenFDM_la_SOURCES = \
   AeroForce.cpp \
+  AirSpring.cpp \
   Assert.cpp \
   Atmosphere.cpp \
   AtmosphereSTD1976.cpp \
@@ -148,6 +152,8 @@
   Input.cpp \
   Integrator.cpp \
   ImplicitEuler.cpp \
+  LineForce.cpp \
+  LinearSpring.cpp \
   Logger.cpp \
   Mass.cpp \
   MidpointRule.cpp \

Modified: trunk/OpenFDM/src/OpenFDM/PrismaticJoint.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/PrismaticJoint.cpp	2005-11-01 11:31:30 UTC (rev 51)
+++ trunk/OpenFDM/src/OpenFDM/PrismaticJoint.cpp	2005-11-02 22:12:53 UTC (rev 52)
@@ -25,8 +25,6 @@
   mJointAcceleration = 0;
   mJointAxis = Vector3::unit(1);
   mPosition = Vector3::zeros();
-  mSpringCoef = 0;
-  mDampCoef = 0;
 
   setNumOutputPorts(2);
   setOutputPort(0, "jointPos", Property(this, &PrismaticJoint::getJointPos));

Modified: trunk/OpenFDM/src/OpenFDM/PrismaticJoint.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/PrismaticJoint.h	2005-11-01 11:31:30 UTC (rev 51)
+++ trunk/OpenFDM/src/OpenFDM/PrismaticJoint.h	2005-11-02 22:12:53 UTC (rev 52)
@@ -15,6 +15,7 @@
 #include "RigidBody.h"
 #include "JointT.h"
 #include "Joint.h"
+#include "LineForce.h"
 
 namespace OpenFDM {
 
@@ -59,23 +60,20 @@
    */
   void setPosition(const Vector3& position);
 
-  void setSpringConstant(real_type springConstant)
-  { mSpringCoef = springConstant; }
-  real_type getSpringConstant(void) const
-  { return mSpringCoef; }
-  void setDampConstant(real_type dampConstant)
-  { mDampCoef = dampConstant; }
-  real_type getDampConstant(void) const
-  { return mDampCoef; }
+  const LineForce* getLineForce(void) const
+  { return mLineForce; }
+  LineForce* getLineForce(void)
+  { return mLineForce; }
+  void setLineForce(LineForce* lineForce)
+  { mLineForce = lineForce; }
 
-  virtual real_type getJointForce(void) const
+  real_type getJointForce(void)
   {
-    Log(ArtBody, Debug) << "RevoluteJoint " << getName()
-                        << " pos " << convertTo(uDegree, mJointPosition)
-                        << " vel " << mJointVelocity
-                        << " torque " << mSpringCoef*mJointPosition + mDampCoef*mJointVelocity
-                        << endl;
-    return mSpringCoef*mJointPosition + mDampCoef*mJointVelocity;
+    if (!mLineForce)
+      return 0;
+    
+    mLineForce->computeForce(mJointPosition, mJointVelocity);
+    return mLineForce->getForce();
   }
 
 private:
@@ -116,10 +114,9 @@
    */
   Vector3 mPosition;
 
-  /** Well, for now, just to test. Include these here
+  /** The direct joint interaction force
    */
-  real_type mSpringCoef;
-  real_type mDampCoef;
+  shared_ptr<LineForce> mLineForce;
 };
 
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp	2005-11-01 11:31:30 UTC (rev 51)
+++ trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp	2005-11-02 22:12:53 UTC (rev 52)
@@ -26,8 +26,6 @@
   mJointAcceleration = 0;
   mJointAxis = Vector3::unit(1);
   mOrientation = Quaternion::unit();
-  mSpringCoef = 0;
-  mDampCoef = 0;
 
   setNumOutputPorts(2);
   setOutputPort(0, "jointPos", Property(this, &RevoluteJoint::getJointPos));

Modified: trunk/OpenFDM/src/OpenFDM/RevoluteJoint.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RevoluteJoint.h	2005-11-01 11:31:30 UTC (rev 51)
+++ trunk/OpenFDM/src/OpenFDM/RevoluteJoint.h	2005-11-02 22:12:53 UTC (rev 52)
@@ -15,6 +15,7 @@
 #include "RigidBody.h"
 #include "Joint.h"
 #include "JointT.h"
+#include "LineForce.h"
 
 namespace OpenFDM {
 
@@ -59,23 +60,20 @@
    */
   void setOrientation(const Quaternion& orientation);
 
-  void setSpringConstant(real_type springConstant)
-  { mSpringCoef = springConstant; }
-  real_type getSpringConstant(void) const
-  { return mSpringCoef; }
-  void setDampConstant(real_type dampConstant)
-  { mDampCoef = dampConstant; }
-  real_type getDampConstant(void) const
-  { return mDampCoef; }
+  const LineForce* getLineForce(void) const
+  { return mLineForce; }
+  LineForce* getLineForce(void)
+  { return mLineForce; }
+  void setLineForce(LineForce* lineForce)
+  { mLineForce = lineForce; }
 
-  virtual real_type getJointForce(void) const
+  real_type getJointForce(void)
   {
-    Log(ArtBody, Debug) << "RevoluteJoint " << getName()
-                        << " pos " << convertTo(uDegree, mJointPosition)
-                        << " vel " << mJointVelocity
-                        << " torque " << mSpringCoef*mJointPosition + mDampCoef*mJointVelocity
-                        << endl;
-    return mSpringCoef*mJointPosition + mDampCoef*mJointVelocity;
+    if (!mLineForce)
+      return 0;
+    
+    mLineForce->computeForce(mJointPosition, mJointVelocity);
+    return mLineForce->getForce();
   }
 
 private:
@@ -123,10 +121,9 @@
    */
   bool mTrackPosition;
 
-  /** Well, for now, just to test. Include these here
+  /** The direct joint interaction force
    */
-  real_type mSpringCoef;
-  real_type mDampCoef;
+  shared_ptr<LineForce> mLineForce;
 };
 
 } // namespace OpenFDM



From frohlich at berlios.de  Sat Nov  5 17:10:35 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Sat, 5 Nov 2005 17:10:35 +0100
Subject: [OpenFDM-svn] r54 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200511051610.jA5GAZRB012072@sheep.berlios.de>

Author: frohlich
Date: 2005-11-05 17:10:23 +0100 (Sat, 05 Nov 2005)
New Revision: 54

Modified:
   trunk/OpenFDM/src/OpenFDM/RigidBody.cpp
   trunk/OpenFDM/src/OpenFDM/RigidBody.h
   trunk/OpenFDM/src/OpenFDM/RootFrame.cpp
Log:
Fix ABA. Still ugly ...


Modified: trunk/OpenFDM/src/OpenFDM/RigidBody.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RigidBody.cpp	2005-11-02 22:13:43 UTC (rev 53)
+++ trunk/OpenFDM/src/OpenFDM/RigidBody.cpp	2005-11-05 16:10:23 UTC (rev 54)
@@ -113,4 +113,27 @@
                        << "\nInertia:\n" << mArtInertia << endl;
 }
 
+void
+RigidBody::computeAccel(void)
+{
+  Log(ArtBody, Debug) << "Entry of computeAccel of \"" << getName()
+                      << "\"" << endl;
+
+  unsigned n = getNumMultiBodyModels();
+  for (unsigned i = 0; i < n; ++i) {
+    Joint* joint = getMultiBodyModel(i)->toJoint();
+    if (joint) {
+      Log(ArtBody, Debug) << "Processing joint \"" << joint->getName()
+                          << "\" to body \"" << getName()
+                          << "\" for acceleration update" << endl;
+      // Check if this is an articulated joint and if we are the parent.
+      if (joint->isArticulatedJoint() && this == joint->getOutboardGroup())
+        joint->updateAccels();
+    }
+  }
+  
+  Log(ArtBody, Debug3) << "On exit of computeAccel of \"" << getName()
+                       << "\"" << endl;
+}
+
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/RigidBody.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RigidBody.h	2005-11-02 22:13:43 UTC (rev 53)
+++ trunk/OpenFDM/src/OpenFDM/RigidBody.h	2005-11-05 16:10:23 UTC (rev 54)
@@ -54,6 +54,8 @@
    */
   void computeArtValues(void);
 
+  void computeAccel(void);
+
   /** Get the outboard articulated inertia.
       Returns a reference to the outboard articulated inertia.
       The returned inertia matrix is computed prevously by a call to

Modified: trunk/OpenFDM/src/OpenFDM/RootFrame.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RootFrame.cpp	2005-11-02 22:13:43 UTC (rev 53)
+++ trunk/OpenFDM/src/OpenFDM/RootFrame.cpp	2005-11-05 16:10:23 UTC (rev 54)
@@ -41,9 +41,12 @@
 class AccelerationPropagationVisitor
   : public Visitor {
 public:
-  virtual void apply(Joint& joint)
+  virtual void apply(RigidBody& body)
   {
-    joint.updateAccels();
+    body.computeAccel();
+    // Note the order. First compute the acceleration and than traverse
+    // to the children.
+    traverse(body);
   }
 };
 



From frohlich at berlios.de  Sun Nov  6 13:21:19 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Sun, 6 Nov 2005 13:21:19 +0100
Subject: [OpenFDM-svn] r55 - in trunk/OpenFDM/src: JSBSim OpenFDM OpenFDM/LinAlg
Message-ID: <200511061221.jA6CLJWZ026974@sheep.berlios.de>

Author: frohlich
Date: 2005-11-06 13:21:01 +0100 (Sun, 06 Nov 2005)
New Revision: 55

Added:
   trunk/OpenFDM/src/OpenFDM/DiscBrake.cpp
   trunk/OpenFDM/src/OpenFDM/DiscBrake.h
   trunk/OpenFDM/src/OpenFDM/LineActuator.cpp
   trunk/OpenFDM/src/OpenFDM/LineActuator.h
   trunk/OpenFDM/src/OpenFDM/WheelContact.cpp
   trunk/OpenFDM/src/OpenFDM/WheelContact.h
Modified:
   trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
   trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.h
   trunk/OpenFDM/src/OpenFDM/FreeJoint.cpp
   trunk/OpenFDM/src/OpenFDM/LinAlg/Container.h
   trunk/OpenFDM/src/OpenFDM/Makefile.am
Log:
Add some sneak preview what will be possible with
the multibody system. ... works only with that FA-18
:)


Modified: trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
===================================================================
--- trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2005-11-05 16:10:23 UTC (rev 54)
+++ trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2005-11-06 12:21:01 UTC (rev 55)
@@ -35,6 +35,9 @@
 #include <OpenFDM/UnaryFunctionModel.h>
 #include <OpenFDM/Units.h>
 #include <OpenFDM/Vehicle.h>
+#include <OpenFDM/WheelContact.h>
+#include <OpenFDM/LineActuator.h>
+#include <OpenFDM/DiscBrake.h>
 
 #include <OpenFDM/ReaderWriter.h>
 #include <OpenFDM/XML/Tablereader.h>
@@ -388,7 +391,40 @@
     } else if (propName == "fdm/jsbsim/gear/gear-pos-norm") {
       return lookupJSBExpression("gear/gear-cmd-norm");
 
+    } else if (propName == "controls/gear/brake-parking") {
+      prop = addInputModel("Parking Brake Input",
+                           "controls/gear/brake-parking");
 
+    } else if (propName == "fdm/jsbsim/gear/right-brake-pos-norm") {
+      Property pilotBr = addInputModel("Right Brake Input",
+                                       "controls/gear/brake-right");
+      Property copilotBr = addInputModel("Right Copilot Brake Input",
+                                         "controls/gear/copilot-brake-right");
+
+      Property parkBr = lookupJSBExpression("/controls/gear/brake-parking");
+
+      // FIXME: we don't have a max model ...
+      MaxExpressionImpl* mex = new MaxExpressionImpl;
+      mex->addInputProperty(pilotBr);
+      mex->addInputProperty(copilotBr);
+      mex->addInputProperty(parkBr);
+      prop = Property(mex);
+
+    } else if (propName == "fdm/jsbsim/gear/left-brake-pos-norm") {
+      Property pilotBr = addInputModel("Left Brake Input",
+                                       "controls/gear/brake-left");
+      Property copilotBr = addInputModel("Left Copilot Brake Input",
+                                         "controls/gear/copilot-brake-left");
+
+      Property parkBr = lookupJSBExpression("/controls/gear/brake-parking");
+
+      // FIXME: we don't have a max model ...
+      MaxExpressionImpl* mex = new MaxExpressionImpl;
+      mex->addInputProperty(pilotBr);
+      mex->addInputProperty(copilotBr);
+      mex->addInputProperty(parkBr);
+      prop = Property(mex);
+
     } else if (propName.substr(0, 19) == "fdm/jsbsim/fcs/mag-") {
       // Special absolute modules for fcs/mag-*
       // remove the 'mag-' substring here and use that as input for the
@@ -397,10 +433,6 @@
       Property in = lookupJSBExpression(name);
       prop = addAbsModel(propName.substr(15), in);
 
-
-
-//     } else if (propName == "fdm/jsbsim/") {
-//       prop = addInputModel(" Input", "");
     }
 
     if (prop.isValid())
@@ -674,6 +706,56 @@
   return true;
 }
 
+void
+LegacyJSBSimReader::attachWheel(const std::string& name, const Vector3& pos,
+                                const std::string& brake,
+                                const std::string& numStr, real_type wheelDiam,
+                                real_type tireSpring, real_type tireDamp,
+                                RigidBody* parent)
+{
+  RigidBody* wheel = new RigidBody(name + " Wheel");
+  InertiaMatrix wheelInertia(10, 0, 0, 100, 0, 10);
+  wheel->addMultiBodyModel(new Mass(SpatialInertia(wheelInertia, 50)));
+  parent->addChildFrame(wheel);
+  
+  RevoluteJoint* wj = new RevoluteJoint(name + " Wheel Joint");
+  parent->addMultiBodyModel(wj, 0);
+  wheel->addMultiBodyModel(wj, 1);
+  wj->setJointAxis(Vector3(0, 1, 0));
+  wj->setPosition(pos);
+  wj->setOrientation(Quaternion::unit());
+  wj->setJointPos(0);
+  wj->setJointVel(0);
+
+  // Add an brake force
+  DiscBrake* brakeF = new DiscBrake(name + " Brake Force");
+  brakeF->setFrictionConstant(-1e4);
+  if (brake == "LEFT") {
+    Property prop = lookupJSBExpression("gear/left-brake-pos-norm");
+    brakeF->setInputPort(0, prop);
+  } else if (brake == "RIGHT") {
+    Property prop = lookupJSBExpression("gear/right-brake-pos-norm");
+    brakeF->setInputPort(0, prop);
+  }
+  wj->setLineForce(brakeF);
+  
+  WheelContact* wc = new WheelContact(name + " Wheel Contact",
+                                      mVehicle->getEnvironment());
+  wc->setWheelRadius(0.5*wheelDiam);
+  wc->setSpringConstant(convertFrom(uPoundForcePFt, tireSpring));
+  wc->setSpringDamping(convertFrom(uPoundForcePFt, tireDamp));
+  wc->setFrictionCoeficient(0.9);
+  wheel->addMultiBodyModel(wc);
+  
+  Property prop = wj->getOutputPort(0);
+  addOutputModel(prop, "Wheel " + numStr + " Position",
+                 "gear/gear[" + numStr + "]/wheel-position-rad");
+  SiToUnitExpressionImpl* c = new SiToUnitExpressionImpl(uDegree);
+  c->setInputProperty(prop);
+  addOutputModel(Property(c), "Wheel " + numStr + " Position Deg",
+                 "gear/gear[" + numStr + "]/wheel-position-deg");
+}
+
 bool
 LegacyJSBSimReader::convertUndercarriage(const std::string& data)
 {
@@ -761,23 +843,11 @@
         }
         
         if (brake == "LEFT") {
-          MaxExpressionImpl* mex = new MaxExpressionImpl;
-          Property prop = lookupJSBExpression("/controls/gear/brake-left");
-          mex->addInputProperty(prop);
-          prop = lookupJSBExpression("/controls/gear/copilot-brake-left");
-          mex->addInputProperty(prop);
-          prop = lookupJSBExpression("/controls/gear/brake-parking");
-          mex->addInputProperty(prop);
-          sg->setInputPort("brakeCommand", Property(mex));
+          Property prop = lookupJSBExpression("gear/left-brake-pos-norm");
+          sg->setInputPort("brakeCommand", prop);
         } else if (brake == "RIGHT") {
-          MaxExpressionImpl* mex = new MaxExpressionImpl;
-          Property prop = lookupJSBExpression("/controls/gear/brake-right");
-          mex->addInputProperty(prop);
-          prop = lookupJSBExpression("/controls/gear/copilot-brake-right");
-          mex->addInputProperty(prop);
-          prop = lookupJSBExpression("/controls/gear/brake-parking");
-          mex->addInputProperty(prop);
-          sg->setInputPort("brakeCommand", Property(mex));
+          Property prop = lookupJSBExpression("gear/right-brake-pos-norm");
+          sg->setInputPort("brakeCommand", prop);
         }
         
         mVehicle->getTopBody()->addMultiBodyModel(sg);
@@ -822,21 +892,26 @@
               >> wheelDiam
               >> tireSpring >> tireDamp;
 
+      // Well this is come hardcoding, but as a demo built from within the
+      // legacy JSBSim format this is ok :)
 
+      // This is the movable part of the strut, doing the compression
       RigidBody* arm = new RigidBody(name + " Arm");
       mVehicle->getTopBody()->addChildFrame(arm);
       arm->addMultiBodyModel(new Mass(inertiaFrom(Vector3(-1, 0, 0), SpatialInertia(200))));
 
+      // Connect that with a revolute joint to the main body
       RevoluteJoint* rj = new RevoluteJoint(name + " Arm Joint");
       mVehicle->getTopBody()->addMultiBodyModel(rj, 0);
       arm->addMultiBodyModel(rj, 1);
       rj->setJointAxis(Vector3(0, 1, 0));
       rj->setJointPos(0);
       rj->setJointVel(0);
-      rj->setPosition(structToBody(compressJointPos)
-                      + Vector3(0, 0, 0.5*wheelDiam));
+      rj->setPosition(structToBody(compressJointPos));
       rj->setOrientation(Quaternion::unit());
 
+      // Well, we use an air spring for that. It is directly in the
+      // revolute joint. That is wring, but at the moment aprioriate.
       AirSpring* aoDamp = new AirSpring(name + " Air Spring Force");
       aoDamp->setPullPressure(pullPress);
       aoDamp->setPushPressure(pushPress);
@@ -847,34 +922,10 @@
       aoDamp->setMaxDamperConstant(maxDamp);
       rj->setLineForce(aoDamp);
 
-      SimpleGear* sg = new SimpleGear(name, mVehicle->getEnvironment());
-      arm->addMultiBodyModel(sg);
-//       sg->setPosition(Vector3(-armLength, 0, 0.5*wheelDiam));
-      sg->setPosition(Vector3(-armLength, 0, 0));
-      sg->setSpringConstant(convertFrom(uPoundForcePFt, tireSpring));
-      sg->setSpringDamping(convertFrom(uPoundForcePFt, tireDamp));
-      sg->setFrictionCoeficient(0.9);
+      // Attach a wheel to that strut part.
+      attachWheel(name, Vector3(-armLength, 0, 0), brake, numStr, wheelDiam,
+                  tireSpring, tireDamp, arm);
 
-      if (brake == "LEFT") {
-        MaxExpressionImpl* mex = new MaxExpressionImpl;
-        Property prop = lookupJSBExpression("/controls/gear/brake-left");
-        mex->addInputProperty(prop);
-        prop = lookupJSBExpression("/controls/gear/copilot-brake-left");
-        mex->addInputProperty(prop);
-        prop = lookupJSBExpression("/controls/gear/brake-parking");
-        mex->addInputProperty(prop);
-        sg->setInputPort("brakeCommand", Property(mex));
-      } else if (brake == "RIGHT") {
-        MaxExpressionImpl* mex = new MaxExpressionImpl;
-        Property prop = lookupJSBExpression("/controls/gear/brake-right");
-        mex->addInputProperty(prop);
-        prop = lookupJSBExpression("/controls/gear/copilot-brake-right");
-        mex->addInputProperty(prop);
-        prop = lookupJSBExpression("/controls/gear/brake-parking");
-        mex->addInputProperty(prop);
-        sg->setInputPort("brakeCommand", Property(mex));
-      }
-
       Property prop = rj->getOutputPort(0);
       addOutputModel(prop, "Gear " + numStr + " Compression",
                      "/gear/gear[" + numStr + "]/compression-rad");
@@ -883,8 +934,8 @@
       addOutputModel(prop, "Gear " + numStr + " Position",
                      "/gear/gear[" + numStr + "]/position-norm");
 
-    } else if (uctype == "AC_CLG") { 
-      std::string name, brake;
+    } else if (uctype == "AC_CLG") {
+      std::string name, brake, steer;
       Vector3 compressJointPos;
       real_type pullPress;
       real_type pushPress;
@@ -907,18 +958,71 @@
               >> minDamp
               >> maxDamp
               >> wheelDiam
-              >> tireSpring >> tireDamp;
+              >> tireSpring >> tireDamp
+              >> steer;
 
+      // Well this is come hardcoding, but as a demo built from within the
+      // legacy JSBSim format this is ok :)
+
+      // Model steering here ...
+      // normally we connect the compressible part to the top level body, but
+      // in case of steering this is no longer true.
+      RigidBody* strutParent = mVehicle->getTopBody();
+      if (steer == "STEERABLE") {
+        // A new part modelling the steering
+        RigidBody* steer = new RigidBody(name + " Steer");
+        strutParent->addChildFrame(steer);
+
+        // connect that via a revolute joint to the toplevel body.
+        // Note the 0.05m below, most steering wheels have some kind of
+        // castering auto line up behavour. That is doe with this 0.05m.
+        RevoluteJoint* sj = new RevoluteJoint(name + " Steer Joint");
+        strutParent->addMultiBodyModel(sj, 0);
+        steer->addMultiBodyModel(sj, 1);
+        sj->setJointAxis(Vector3(0, 0, 1));
+        sj->setJointPos(0);
+        sj->setJointVel(0);
+        sj->setPosition(structToBody(compressJointPos)
+                        + Vector3(0.05, 0, 0));
+        sj->setOrientation(Quaternion::unit());
+
+        // Add an actuator trying to interpret the steering command
+        LineActuator* steerAct = new LineActuator(name + " Steering Actuator");
+        Property prop = lookupJSBExpression("fcs/steer-cmd-norm");
+        steerAct->setInputPort(0, prop);
+        steerAct->setProportionalGain(-1e6);
+        steerAct->setDerivativeGain(-1e3);
+        sj->setLineForce(steerAct);
+        
+        strutParent = steer;
+        
+        // Prepare outputs
+        prop = sj->getOutputPort(0);
+        addOutputModel(prop, "Steering " + numStr + " Position",
+                       "/gear/gear[" + numStr + "]/steering-pos-rad");
+        SiToUnitExpressionImpl* c = new SiToUnitExpressionImpl(uDegree);
+        c->setInputProperty(prop);
+        addOutputModel(Property(c), "Steering " + numStr + " Position Deg",
+                     "/gear/gear[" + numStr + "]/steering-pos-deg");
+      }
+
+
+      // Now the compressible part of the strut
       RigidBody* arm = new RigidBody(name + " Strut");
-      mVehicle->getTopBody()->addChildFrame(arm);
+      strutParent->addChildFrame(arm);
       arm->addMultiBodyModel(new Mass(inertiaFrom(Vector3(0, 0, 1), SpatialInertia(200))));
 
+      // This time it is a prismatic joint
       PrismaticJoint* pj = new PrismaticJoint(name + " Compress Joint");
-      mVehicle->getTopBody()->addMultiBodyModel(pj, 0);
+      strutParent->addMultiBodyModel(pj, 0);
       arm->addMultiBodyModel(pj, 1);
       pj->setJointAxis(Vector3(0, 0, -1));
-      pj->setPosition(structToBody(compressJointPos) + Vector3(0, 0, 0.5*wheelDiam));
+      if (strutParent == mVehicle->getTopBody())
+        pj->setPosition(structToBody(compressJointPos));
+      else
+        pj->setPosition(Vector3(-0.05, 0, 0));
 
+      // With an air spring
       AirSpring* aoDamp = new AirSpring(name + " Air Spring Force");
       aoDamp->setPullPressure(pullPress);
       aoDamp->setPushPressure(pushPress);
@@ -929,33 +1033,11 @@
       aoDamp->setMaxDamperConstant(maxDamp);
       pj->setLineForce(aoDamp);
 
-      SimpleGear* sg = new SimpleGear(name, mVehicle->getEnvironment());
-      arm->addMultiBodyModel(sg);
-      sg->setPosition(Vector3(0, 0, 0));
-      sg->setSpringConstant(convertFrom(uPoundForcePFt, tireSpring));
-      sg->setSpringDamping(convertFrom(uPoundForcePFt, tireDamp));
-      sg->setFrictionCoeficient(0.9);
+      // Attach a wheel to that strut part.
+      attachWheel(name, Vector3::zeros(), brake, numStr, wheelDiam,
+                  tireSpring, tireDamp, arm);
 
-      if (brake == "LEFT") {
-        MaxExpressionImpl* mex = new MaxExpressionImpl;
-        Property prop = lookupJSBExpression("/controls/gear/brake-left");
-        mex->addInputProperty(prop);
-        prop = lookupJSBExpression("/controls/gear/copilot-brake-left");
-        mex->addInputProperty(prop);
-        prop = lookupJSBExpression("/controls/gear/brake-parking");
-        mex->addInputProperty(prop);
-        sg->setInputPort("brakeCommand", Property(mex));
-      } else if (brake == "RIGHT") {
-        MaxExpressionImpl* mex = new MaxExpressionImpl;
-        Property prop = lookupJSBExpression("/controls/gear/brake-right");
-        mex->addInputProperty(prop);
-        prop = lookupJSBExpression("/controls/gear/copilot-brake-right");
-        mex->addInputProperty(prop);
-        prop = lookupJSBExpression("/controls/gear/brake-parking");
-        mex->addInputProperty(prop);
-        sg->setInputPort("brakeCommand", Property(mex));
-      }
-
+      // Prepare some outputs ...
       Property prop = pj->getOutputPort(0);
       addOutputModel(prop, "Gear " + numStr + " Compression",
                      "/gear/gear[" + numStr + "]/compression-m");
@@ -970,6 +1052,7 @@
       datastr >> name >> x >> y >> z >> k >> d >> fs >> fd >> rr
               >> type >> brake >> sa >> retract;
 
+      // Very simple contact force. Penalty method.
       SimpleContact* sc = new SimpleContact(name, mVehicle->getEnvironment());
       sc->setPosition(structToBody(Vector3(x, y, z)));
 

Modified: trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.h
===================================================================
--- trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.h	2005-11-05 16:10:23 UTC (rev 54)
+++ trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.h	2005-11-06 12:21:01 UTC (rev 55)
@@ -166,6 +166,12 @@
   bool convertDocument(const XMLDocument* jsbDoc);
   /// converts the METRICS data
   bool convertMetrics(const std::string& data);
+  /// Helper for convertUndercarriage
+  void attachWheel(const std::string& name, const Vector3& pos,
+                   const std::string& brake,
+                   const std::string& numStr, real_type wheelDiam,
+                   real_type tireSpring, real_type tireDamp,
+                   RigidBody* parent);
   /// converts the UNDERCARRIAGE data
   bool convertUndercarriage(const std::string& data);
   /// converts the FLIGHT_CONTROL or AUTOPILOT elements

Added: trunk/OpenFDM/src/OpenFDM/DiscBrake.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/DiscBrake.cpp	2005-11-05 16:10:23 UTC (rev 54)
+++ trunk/OpenFDM/src/OpenFDM/DiscBrake.cpp	2005-11-06 12:21:01 UTC (rev 55)
@@ -0,0 +1,42 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
+ *
+ */
+
+#include "Model.h"
+#include "Vector.h"
+#include "DiscBrake.h"
+
+namespace OpenFDM {
+
+DiscBrake::DiscBrake(const std::string& name) :
+  LineForce(name),
+  mFrictionConstant(-1)
+{
+  setNumInputPorts(1);
+  setInputPortName(0, "brakePressure");
+}
+
+DiscBrake::~DiscBrake(void)
+{
+}
+
+void
+DiscBrake::output(const TaskInfo& taskInfo)
+{
+  real_type brakeInput = getInputPort(0).getValue().toReal();
+  setForce(getVel()*(-1e1 + brakeInput*mFrictionConstant));
+}
+
+real_type
+DiscBrake::getFrictionConstant(void) const
+{
+  return mFrictionConstant;
+}
+
+void
+DiscBrake::setFrictionConstant(real_type frictionConstant)
+{
+  mFrictionConstant = frictionConstant;
+}
+
+} // namespace OpenFDM


Property changes on: trunk/OpenFDM/src/OpenFDM/DiscBrake.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/OpenFDM/src/OpenFDM/DiscBrake.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/DiscBrake.h	2005-11-05 16:10:23 UTC (rev 54)
+++ trunk/OpenFDM/src/OpenFDM/DiscBrake.h	2005-11-06 12:21:01 UTC (rev 55)
@@ -0,0 +1,32 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_DiscBrake_H
+#define OpenFDM_DiscBrake_H
+
+#include "Model.h"
+#include "Vector.h"
+#include "LineForce.h"
+
+namespace OpenFDM {
+
+/// Linear spring damper model
+class DiscBrake :
+    public LineForce {
+public:
+  DiscBrake(const std::string& name);
+  virtual ~DiscBrake(void);
+
+  virtual void output(const TaskInfo& taskInfo);
+
+  real_type getFrictionConstant(void) const;
+  void setFrictionConstant(real_type frictionConstant);
+
+private:
+  real_type mFrictionConstant;
+};
+
+} // namespace OpenFDM
+
+#endif


Property changes on: trunk/OpenFDM/src/OpenFDM/DiscBrake.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/OpenFDM/src/OpenFDM/FreeJoint.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/FreeJoint.cpp	2005-11-05 16:10:23 UTC (rev 54)
+++ trunk/OpenFDM/src/OpenFDM/FreeJoint.cpp	2005-11-06 12:21:01 UTC (rev 55)
@@ -37,7 +37,7 @@
 
 Vector6
 FreeJoint::computeRelAccel(const SpatialInertia& artI,
-                            const Vector6& artF)
+                           const Vector6& artF)
 {
   RigidBody* topBody = getOutboardGroup()->toRigidBody();
   if (!topBody)

Modified: trunk/OpenFDM/src/OpenFDM/LinAlg/Container.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/LinAlg/Container.h	2005-11-05 16:10:23 UTC (rev 54)
+++ trunk/OpenFDM/src/OpenFDM/LinAlg/Container.h	2005-11-06 12:21:01 UTC (rev 55)
@@ -1101,11 +1101,11 @@
   }
   OpenFDM_FORCE_INLINE
   SymMatrix6(T S11,
-              T S21, T S22,
-              T S31, T S32, T S33,
-              T S41, T S42, T S43, T S44,
-              T S51, T S52, T S53, T S54, T S55,
-              T S61, T S62, T S63, T S64, T S65, T S66)
+             T S21, T S22,
+             T S31, T S32, T S33,
+             T S41, T S42, T S43, T S44,
+             T S51, T S52, T S53, T S54, T S55,
+             T S61, T S62, T S63, T S64, T S65, T S66)
   {
     (*this)(1,1) = S11;
     (*this)(2,1) = S21; (*this)(2,2) = S22;

Added: trunk/OpenFDM/src/OpenFDM/LineActuator.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/LineActuator.cpp	2005-11-05 16:10:23 UTC (rev 54)
+++ trunk/OpenFDM/src/OpenFDM/LineActuator.cpp	2005-11-06 12:21:01 UTC (rev 55)
@@ -0,0 +1,56 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
+ *
+ */
+
+#include "Model.h"
+#include "Vector.h"
+#include "LineActuator.h"
+
+namespace OpenFDM {
+
+LineActuator::LineActuator(const std::string& name) :
+  LineForce(name),
+  mProportionalGain(1),
+  mDerivativeGain(0)
+{
+  setNumInputPorts(1);
+  setInputPortName(0, "targetPosition");
+}
+
+LineActuator::~LineActuator(void)
+{
+}
+
+void
+LineActuator::output(const TaskInfo& taskInfo)
+{
+  real_type posInput = getInputPort(0).getValue().toReal();
+  real_type displacement = getPosition() - posInput;
+  setForce(mProportionalGain*displacement + getVel()*mDerivativeGain);
+}
+
+real_type
+LineActuator::getProportionalGain(void) const
+{
+  return mProportionalGain;
+}
+
+void
+LineActuator::setProportionalGain(real_type proportionalGain)
+{
+  mProportionalGain = proportionalGain;
+}
+
+real_type
+LineActuator::getDerivativeGain(void) const
+{
+  return mDerivativeGain;
+}
+
+void
+LineActuator::setDerivativeGain(real_type derivativeGain)
+{
+  mDerivativeGain = derivativeGain;
+}
+
+} // namespace OpenFDM


Property changes on: trunk/OpenFDM/src/OpenFDM/LineActuator.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/OpenFDM/src/OpenFDM/LineActuator.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/LineActuator.h	2005-11-05 16:10:23 UTC (rev 54)
+++ trunk/OpenFDM/src/OpenFDM/LineActuator.h	2005-11-06 12:21:01 UTC (rev 55)
@@ -0,0 +1,36 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_LineActuator_H
+#define OpenFDM_LineActuator_H
+
+#include "Model.h"
+#include "Vector.h"
+#include "LineForce.h"
+
+namespace OpenFDM {
+
+/// Linear spring damper model
+class LineActuator :
+    public LineForce {
+public:
+  LineActuator(const std::string& name);
+  virtual ~LineActuator(void);
+
+  virtual void output(const TaskInfo& taskInfo);
+
+  real_type getProportionalGain(void) const;
+  void setProportionalGain(real_type proportionalGain);
+
+  real_type getDerivativeGain(void) const;
+  void setDerivativeGain(real_type derivativeGain);
+
+private:
+  real_type mProportionalGain;
+  real_type mDerivativeGain;
+};
+
+} // namespace OpenFDM
+
+#endif


Property changes on: trunk/OpenFDM/src/OpenFDM/LineActuator.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/OpenFDM/src/OpenFDM/Makefile.am
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Makefile.am	2005-11-05 16:10:23 UTC (rev 54)
+++ trunk/OpenFDM/src/OpenFDM/Makefile.am	2005-11-06 12:21:01 UTC (rev 55)
@@ -40,6 +40,7 @@
   DefaultGround.h \
   DefaultPlanet.h \
   DirectForce.h \
+  DiscBrake.h \
   DiscreteIntegrator.h \
   DoPri5.h \
   Environment.h \
@@ -69,6 +70,7 @@
   LinAlg/IO.h \
   LinAlg/Misc.h \
   LinAlg/Proxy.h \
+  LineActuator.h \
   LinearSpring.h \
   LineForce.h \
   LogStream.h \
@@ -115,6 +117,7 @@
   Vector.h \
   Vehicle.h \
   Visitor.h \
+  WheelContact.h \
   Wind.h \
   XML/Tablereader.h \
   XML/XMLReader.h
@@ -135,6 +138,7 @@
   DefaultGround.cpp \
   DefaultPlanet.cpp \
   DirectForce.cpp \
+  DiscBrake.cpp \
   DiscreteIntegrator.cpp \
   DoPri5.cpp \
   Environment.cpp \
@@ -152,8 +156,9 @@
   Input.cpp \
   Integrator.cpp \
   ImplicitEuler.cpp \
+  LineActuator.cpp \
+  LinearSpring.cpp \
   LineForce.cpp \
-  LinearSpring.cpp \
   Logger.cpp \
   Mass.cpp \
   MidpointRule.cpp \
@@ -183,5 +188,6 @@
   Units.cpp \
   Variant.cpp \
   Vehicle.cpp \
+  WheelContact.cpp \
   XML/Tablereader.cpp \
   XML/XMLReader.cpp

Added: trunk/OpenFDM/src/OpenFDM/WheelContact.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/WheelContact.cpp	2005-11-05 16:10:23 UTC (rev 54)
+++ trunk/OpenFDM/src/OpenFDM/WheelContact.cpp	2005-11-06 12:21:01 UTC (rev 55)
@@ -0,0 +1,175 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
+ *
+ */
+
+#include "Assert.h"
+#include "LogStream.h"
+#include "Object.h"
+#include "Vector.h"
+#include "Frame.h"
+#include "Force.h"
+#include "Environment.h"
+#include "WheelContact.h"
+
+namespace OpenFDM {
+
+WheelContact::WheelContact(const std::string& name, Environment* env)
+  : ExternalForce(name)
+{
+  mWheelRadius = 0.3;
+  mSpringConstant = 0;
+  mSpringDamping = 0;
+  mFrictionCoeficient = 0.8;
+
+  mEnvironment = env;
+
+  // FIXME??
+  addSampleTime(SampleTime::PerTimestep);
+  addSampleTime(SampleTime::Continous);
+}
+
+WheelContact::~WheelContact(void)
+{
+}
+
+void
+WheelContact::output(const TaskInfo& taskInfo)
+{
+  if (nonZeroIntersection(taskInfo.getSampleTimeSet(),
+                          SampleTime::PerTimestep)) {
+    Log(Model, Debug) << "WheelContact::output(): \"" << getName()
+                      << "\" computing ground plane below" << endl;
+    getGround(0 /*FIXME*/);
+  }
+}
+
+void
+WheelContact::computeForce(void)
+{
+  // FIXME: check all signs here, I get the feeling that we have
+  // just even much minuses here instead of exactly the right ones ...
+  const Frame* frame = getParentFrame(0);
+  OpenFDMAssert(frame);
+  if (!frame) {
+    applyForce(Vector6::zeros());
+    return;
+  }
+
+  // Transform the plane equation to the local frame.
+  Plane lp = frame->planeFromRef(mGroundVal.plane);
+  
+  // Get the intersection length.
+  real_type distHubGround = fabs(lp.getDist(Vector3::zeros()));
+  real_type compressLength = mWheelRadius - distHubGround;
+  
+  // Don't bother if we do not intersect the ground.
+  if (compressLength < 0) {
+    applyForce(Vector6::zeros());
+    return;
+  }
+
+  Vector3 contactPoint = distHubGround*lp.getNormal();
+  
+  // The velocity of the ground patch in the current frame.
+  Vector6 groundVel = frame->motionFromRef(mGroundVal.vel);
+  // Now get the relative velocity of the ground wrt the hub
+  Vector6 relVel = - groundVel;
+//   Log(Model,Error) << trans(frame->getRelVel()) << " "
+//                    << trans(groundVel) << " "
+//                    << trans(frame->motionToParent(relVel)) << endl;
+
+
+  // The velocity perpandicular to the plane.
+  // Positive when the contact spring is compressed,
+  // negative when decompressed.
+  real_type compressVel = - lp.scalarProjectToNormal(relVel.getLinear());
+  
+  // Get the plane normal force.
+  real_type normForce = computeNormalForce(compressLength, compressVel);
+  // The normal force cannot get negative here.
+  normForce = max(static_cast<real_type>(0), normForce);
+  
+  // Get a transform from the current frames coordinates into
+  // wheel coordinates.
+  // The wheel coordinates x asxis is defined by the forward orientation
+  // of the wheel, the z axis points perpandicular to the ground
+  // plane downwards.
+  Vector3 forward = normalize(cross(Vector3::unit(2), lp.getNormal()));
+  Vector3 side = normalize(cross(lp.getNormal(), forward));
+
+  // Transformed velocity to the ground plane
+  Vector2 wheelVel(dot(forward, relVel.getLinear()),
+                   dot(side, relVel.getLinear()));
+
+  // The wheel rotation speed wrt ground
+  Vector3 rotVel = relVel.getAngular();
+  real_type omegaR = rotVel(2) * distHubGround;
+
+//   Log(Model,Error) << trans(groundVel) << " "
+//                    << trans(wheelVel) << " "
+//                    << omegaR << " "
+//                    << compressLength << " "
+//                    << distHubGround << endl;
+
+
+
+  // Get the friction force.
+  Vector2 fricForce = computeFrictionForce(normForce, wheelVel,
+                                           omegaR, mGroundVal.friction);
+  
+  // The resulting force is the sum of both.
+  // The minus sign is because of the direction of the surface normal.
+  Vector3 force = fricForce(1)*forward + fricForce(2)*side
+    - normForce*lp.getNormal();
+  
+  // We don't have an angular moment.
+  applyForce(forceFrom(contactPoint, force));
+}
+
+real_type
+WheelContact::computeNormalForce(real_type compressLen, real_type compressVel) const
+{
+  return compressLen*mSpringConstant
+    - mSpringDamping*min(compressVel, static_cast<real_type>(0));
+}
+
+Vector2
+WheelContact::computeFrictionForce(real_type normForce, const Vector2& vel,
+                                   real_type omegaR, real_type friction) const
+{
+  // We just get the wheel slip directly here
+  real_type wheelSlip = vel(1)+omegaR;
+  
+  // The slip angle is the angle between the 'velocity vector' and 
+  // the wheel forward direction.
+  real_type slipAngle = rad2deg*atan2(vel(2), fabs(vel(1)));
+  if (10*fabs(vel(2)) < fabs(slipAngle))
+    slipAngle = 10*vel(2);
+  
+  Vector2 slip(wheelSlip, slipAngle);
+//   if (1 < norm(slip))
+//     slip = normalize(slip);
+  if (1 < fabs(wheelSlip))
+    slip(1) = sign(wheelSlip);
+  if (1 < fabs(slipAngle))
+    slip(2) = sign(slipAngle);
+  
+  // The friction force for fast movement.
+  return (-friction*mFrictionCoeficient*normForce)*slip;
+}
+
+void
+WheelContact::getGround(real_type t)
+{
+  const Frame* frame = getParentFrame(0);
+  OpenFDMAssert(frame);
+  if (!frame)
+    return;
+
+  // Get the position of the contact in the reference system.
+  Vector3 pos = frame->posToRef(Vector3::zeros());
+  // Query for the ground parameters at this point.
+  mGroundVal = mEnvironment->getGround()->getGroundPlane(t, pos);
+}
+
+} // namespace OpenFDM


Property changes on: trunk/OpenFDM/src/OpenFDM/WheelContact.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/OpenFDM/src/OpenFDM/WheelContact.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/WheelContact.h	2005-11-05 16:10:23 UTC (rev 54)
+++ trunk/OpenFDM/src/OpenFDM/WheelContact.h	2005-11-06 12:21:01 UTC (rev 55)
@@ -0,0 +1,70 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_WheelContact_H
+#define OpenFDM_WheelContact_H
+
+#include "Assert.h"
+#include "Object.h"
+#include "Vector.h"
+#include "Frame.h"
+#include "Force.h"
+#include "Ground.h"
+#include "Environment.h"
+
+namespace OpenFDM {
+
+class WheelContact
+  : public ExternalForce {
+public:
+  WheelContact(const std::string& name, Environment* env);
+  virtual ~WheelContact(void);
+
+  virtual void output(const TaskInfo&);
+
+  virtual void computeForce(void);
+
+  // Compute the plane normal force.
+  virtual real_type
+  computeNormalForce(real_type compressLen, real_type compressVel) const;
+
+  // Compute the friction force.
+  virtual Vector2
+  computeFrictionForce(real_type normForce, const Vector2& vel,
+                       real_type omegaR, real_type friction) const;
+
+  void setWheelRadius(real_type wheelRadius)
+  { mWheelRadius = wheelRadius; }
+  real_type getWheelRadius(void) const
+  { return mWheelRadius; }
+
+  void setSpringConstant(real_type springConstant)
+  { mSpringConstant = springConstant; }
+  real_type getSpringConstant(void) const
+  { return mSpringConstant; }
+
+  void setSpringDamping(real_type springDamping)
+  { mSpringDamping = springDamping; }
+  real_type getSpringDamping(void) const
+  { return mSpringDamping; }
+
+  void setFrictionCoeficient(real_type frictionCoeficient)
+  { mFrictionCoeficient = frictionCoeficient; }
+  real_type getFrictionCoeficient(void) const
+  { return mFrictionCoeficient; }
+private:
+  void getGround(real_type t);
+
+  GroundValues mGroundVal;
+  shared_ptr<Environment> mEnvironment;
+
+  real_type mWheelRadius;
+  real_type mSpringConstant;
+  real_type mSpringDamping;
+  real_type mFrictionCoeficient;
+};
+
+} // namespace OpenFDM
+
+#endif


Property changes on: trunk/OpenFDM/src/OpenFDM/WheelContact.h
___________________________________________________________________
Name: svn:eol-style
   + native



From frohlich at berlios.de  Mon Nov  7 20:54:55 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Mon, 7 Nov 2005 20:54:55 +0100
Subject: [OpenFDM-svn] r56 - in trunk/OpenFDM/src/OpenFDM: . LinAlg
Message-ID: <200511071954.jA7Jst8l026995@sheep.berlios.de>

Author: frohlich
Date: 2005-11-07 20:54:42 +0100 (Mon, 07 Nov 2005)
New Revision: 56

Modified:
   trunk/OpenFDM/src/OpenFDM/LinAlg/Algorithm.h
   trunk/OpenFDM/src/OpenFDM/Newton.cpp
   trunk/OpenFDM/src/OpenFDM/System.cpp
   trunk/OpenFDM/src/OpenFDM/Vehicle.cpp
   trunk/OpenFDM/src/OpenFDM/Vehicle.h
Log:
Some initial guess on trimming.


Modified: trunk/OpenFDM/src/OpenFDM/LinAlg/Algorithm.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/LinAlg/Algorithm.h	2005-11-06 12:21:01 UTC (rev 55)
+++ trunk/OpenFDM/src/OpenFDM/LinAlg/Algorithm.h	2005-11-07 19:54:42 UTC (rev 56)
@@ -825,12 +825,14 @@
   size_type n = A.cols();
   
   size_type j;
-  for (j = 1; j < n; ++j) {
+  for (j = 1; j <= n; ++j) {
     // See Golub, van Loan: Matrix Computations, pp 210
 
-    Vector<T> v(A(Range(j, m), j));
-    v(1) = 1;
-    x(Range(j, m)) -= (beta(j)*dot(v, x(Range(j, m))))*v;
+    if (j < m) {
+      Vector<T> v(A(Range(j, m), j));
+      v(1) = 1;
+      x(Range(j, m)) -= (beta(j)*dot(v, x(Range(j, m))))*v;
+    }
   }
 
   return nonsingular;

Modified: trunk/OpenFDM/src/OpenFDM/Newton.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Newton.cpp	2005-11-06 12:21:01 UTC (rev 55)
+++ trunk/OpenFDM/src/OpenFDM/Newton.cpp	2005-11-07 19:54:42 UTC (rev 56)
@@ -69,6 +69,7 @@
   f.eval(t, x, err);
   Log(NewtonMethod, Debug1) << "err " << trans(err) << endl;
   Vector dx_bar = jacInv.solve(err);
+  Log(NewtonMethod, Debug2) << "dx_bar " << trans(dx_bar) << endl;
   do {
     // Increment the iteration counter. Just statistics ...
     if (itCount)
@@ -108,6 +109,7 @@
       // This jacobian evaluation will also be used for the next step if
       // this lambda truns out to be acceptable.
       dx_bar = jacInv.solve(err);
+      Log(NewtonMethod, Debug2) << "dx_bar " << trans(dx_bar) << endl;
 
       // The convergence criterion parameter theta.
       real_type theta = 1.0 - 0.5*lambda;
@@ -149,9 +151,14 @@
       x = x_new;
     } else if (0 <= maxjac) {
       --maxjac;
+
+      Log(NewtonMethod, Debug) << "Computing new jacobian" << endl;
+
       // get a new jacobian ...
       f.jac(t, x, jacInv.data());
+      Log(NewtonMethod, Debug2) << jacInv.data() << endl;
       jacInv.factorize();
+      Log(NewtonMethod, Debug2) << "decomposed qr\n" << jacInv.data() << endl;
 
       if (jacInv.singular())
         Log(NewtonMethod, Warning) << "Have singular jacobian!" << endl;
@@ -162,6 +169,9 @@
     // Iterate as long as either the iteration converged or the
     // maximum iteration count is reached.
   } while (!converged && converging && 0 < maxit);
+
+  Log(NewtonMethod, Info) << "Newton type method: converged = "
+                          << converged << endl;
   
   // Tell the caller if it worked or not.
   return converged;
@@ -182,6 +192,48 @@
                       itCount, maxit, maxjac, lambdamin);
 }
 
+static
+Vector
+LineSearch(Function& f, real_type t, const Vector& xk, const Vector& dk,
+           real_type maxWide, real_type thresh)
+{
+  static const real_type vfac = (3-sqrt(5.0))/2;
+  static const real_type wfac = (sqrt(5.0)-1)/2;
+
+  thresh = fabs(maxWide)*thresh;
+
+  Vector v = xk;
+  Vector w = xk + maxWide*dk;
+
+  Vector fx;
+  while (norm1(v - w) > thresh) {
+    f.eval(t, v, fx);
+    real_type fv = dot(fx, fx);
+    f.eval(t, w, fx);
+    real_type fw = dot(fx, fx);
+    Log(NewtonMethod, Debug2) << " Line Search: errv = " << fv
+                             << ", errw = " << fw << endl;
+  
+    // check for isfinite ...
+//   if failv
+//     v = v + vfac*(w-v);
+//   elseif failw
+//     w = v + wfac*(w-v);
+//   elseif fv > fw
+//     v = v + vfac*(w-v);
+//   else
+//     w = v + wfac*(w-v);
+//   end
+
+    if (fv > fw)
+      v = v + vfac*(w-v);
+    else
+      w = v + wfac*(w-v);
+  }
+
+  return 0.5*(v+w);
+}
+
 bool
 GaussNewton(Function& f,
             real_type t,
@@ -192,12 +244,38 @@
             unsigned maxjac,
             real_type lambdamin)
 {
-  LinAlg::MatrixFactors<real_type,0,0,LinAlg::QRTag> jacFactors;
-  f.jac(t, x, jacFactors.data());
-  
-  jacFactors.factorize();
-  return NewtonTypeMethod(f, jacFactors, t, x, atol, rtol,
-                          itCount, maxit, maxjac, lambdamin);
+  Vector err, dx;
+  Matrix J;
+  LinAlg::MatrixFactors<real_type,0,0,LinAlg::LUTag> jacFactors;
+//   LinAlg::MatrixFactors<real_type,0,0,LinAlg::QRTag> jacFactors;
+
+  bool converged;
+  do {
+    // Compute in each step a new jacobian
+    f.jac(t, x, J);
+    jacFactors = trans(J)*J;
+    
+    // Compute the actual error
+    f.eval(t, x, err);
+
+    // Compute the search direction
+    dx = jacFactors.solve(trans(J)*err);
+
+    // Get a better search guess
+//     if (1 < norm(dx))
+//       dx = normalize(dx);
+    Vector xnew = LineSearch(f, t, x, -dx, 1.0, atol);
+
+    // check convergence
+    converged = norm1(xnew - x) < atol;
+
+    Log(NewtonMethod, Debug) << "Convergence test: |dx| = " << norm(xnew - x)
+                             << ", converged = " << converged << endl;
+    // New guess is the better one
+    x = xnew;
+  } while (!converged);
+
+  return converged;
 }
 
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/System.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/System.cpp	2005-11-06 12:21:01 UTC (rev 55)
+++ trunk/OpenFDM/src/OpenFDM/System.cpp	2005-11-07 19:54:42 UTC (rev 56)
@@ -9,6 +9,8 @@
 #include "LogStream.h"
 #include "ODESolver.h"
 #include "ExplicitEuler.h"
+#include "Function.h"
+#include "Newton.h"
 #include "System.h"
 
 namespace OpenFDM {
@@ -214,10 +216,67 @@
   }
 }
 
+class TrimFunction
+  : public Function {
+public:
+  TrimFunction(System& system, const Vector& state)
+    : mSystem(system), mState(state) {}
+  virtual unsigned inSize(void) const
+  { return mSystem.getNumContinousStates(); }
+#if 1
+  virtual unsigned outSize(void) const
+  { return 2*mSystem.getNumContinousStates(); }
+  virtual void eval(real_type t, const Vector& v, Vector& out)
+  {
+    unsigned nStates = mSystem.getNumContinousStates();
+    Vector deriv(nStates);
+    mSystem.evalFunction(t, v, deriv);
+
+    out.resize(2*nStates);
+    out(Range(1, nStates)) = 1e-1*(mState - v);
+    out(Range(nStates + 1, 2*nStates)) = deriv;
+  }
+#else
+  virtual unsigned outSize(void) const
+  { return mSystem.getNumContinousStates(); }
+  virtual void eval(real_type t, const Vector& v, Vector& out)
+  {
+    mSystem.evalFunction(t, v, out);
+  }
+#endif
+private:
+  System& mSystem;
+  Vector mState;
+};
+
 bool
 System::trim(void)
 {
-  /// FIXME
+  // need to prepare the System especially for the per step tasks
+  TaskInfo taskInfo;
+  taskInfo.addSampleTime(SampleTime::Continous);
+  taskInfo.addSampleTime(SampleTime::PerTimestep);
+  output(taskInfo);
+
+  // Get the current state
+  Vector state(getNumContinousStates());
+  getState(state, 0);
+
+  Vector trimState = state;
+  // Buld up the trim function
+  TrimFunction trimFunction(*this, trimState);
+
+  // Try to find a minimum
+  real_type atol = 1e-3;
+  real_type rtol = 1e-8;
+  bool ret = GaussNewton(trimFunction, getTime(), trimState, atol, rtol);
+  if (ret) {
+    setState(getTime(), trimState, 0);
+  } else {
+    setState(getTime(), state, 0);
+  }
+
+  return ret;
 }
 
 void

Modified: trunk/OpenFDM/src/OpenFDM/Vehicle.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Vehicle.cpp	2005-11-06 12:21:01 UTC (rev 55)
+++ trunk/OpenFDM/src/OpenFDM/Vehicle.cpp	2005-11-07 19:54:42 UTC (rev 56)
@@ -80,6 +80,12 @@
   mSystem->simulate(mSystem->getTime() + dt);
 }
 
+bool
+Vehicle::trim(void)
+{
+  return mSystem->trim();
+}
+
 void
 Vehicle::setPlanet(Planet* p)
 {

Modified: trunk/OpenFDM/src/OpenFDM/Vehicle.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Vehicle.h	2005-11-06 12:21:01 UTC (rev 55)
+++ trunk/OpenFDM/src/OpenFDM/Vehicle.h	2005-11-07 19:54:42 UTC (rev 56)
@@ -35,6 +35,8 @@
   void output(void); /// FIXME??
   void update(real_type dt);
 
+  bool trim(void);
+
   /** Set planet callback.
    */
   void setPlanet(Planet* p);



From frohlich at berlios.de  Mon Nov  7 20:56:09 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Mon, 7 Nov 2005 20:56:09 +0100
Subject: [OpenFDM-svn] r57 - trunk/flightgear
Message-ID: <200511071956.jA7Ju9JE027203@sheep.berlios.de>

Author: frohlich
Date: 2005-11-07 20:56:06 +0100 (Mon, 07 Nov 2005)
New Revision: 57

Modified:
   trunk/flightgear/FGOpenFDM.cpp
Log:
This is the point where trimming might happen.


Modified: trunk/flightgear/FGOpenFDM.cpp
===================================================================
--- trunk/flightgear/FGOpenFDM.cpp	2005-11-07 19:54:42 UTC (rev 56)
+++ trunk/flightgear/FGOpenFDM.cpp	2005-11-07 19:56:06 UTC (rev 57)
@@ -351,7 +351,10 @@
 
   if (stateChanged) {
     SG_LOG(SG_FLIGHT, SG_INFO, "State changed ------------------------------");
-    vehicle->init();
+//     printVehicle(vehicle);
+//     vehicle->init();
+//     vehicle->trim();
+//     printVehicle(vehicle);
   }
 
   // Here a miracle occures :)



From frohlich at berlios.de  Sat Nov 12 18:43:33 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Sat, 12 Nov 2005 18:43:33 +0100
Subject: [OpenFDM-svn] r58 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200511121743.jACHhXBv031056@sheep.berlios.de>

Author: frohlich
Date: 2005-11-12 18:43:27 +0100 (Sat, 12 Nov 2005)
New Revision: 58

Modified:
   trunk/OpenFDM/src/OpenFDM/System.cpp
Log:
Initialize uninitialized variable.


Modified: trunk/OpenFDM/src/OpenFDM/System.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/System.cpp	2005-11-07 19:56:06 UTC (rev 57)
+++ trunk/OpenFDM/src/OpenFDM/System.cpp	2005-11-12 17:43:27 UTC (rev 58)
@@ -16,7 +16,8 @@
 namespace OpenFDM {
 
 System::System(const std::string& name) :
-  ModelGroup(name)
+  ModelGroup(name),
+  mTime(0)
 {
   setTimestepper(new ExplicitEuler);
 }



From frohlich at berlios.de  Sat Nov 12 18:48:09 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Sat, 12 Nov 2005 18:48:09 +0100
Subject: [OpenFDM-svn] r59 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200511121748.jACHm94Z000828@sheep.berlios.de>

Author: frohlich
Date: 2005-11-12 18:48:06 +0100 (Sat, 12 Nov 2005)
New Revision: 59

Modified:
   trunk/OpenFDM/src/OpenFDM/Quaternion.h
Log:
More inline ...


Modified: trunk/OpenFDM/src/OpenFDM/Quaternion.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Quaternion.h	2005-11-12 17:43:27 UTC (rev 58)
+++ trunk/OpenFDM/src/OpenFDM/Quaternion.h	2005-11-12 17:48:06 UTC (rev 59)
@@ -59,11 +59,14 @@
       fabs((*this)(4)) < Limits<T>::epsilon();
   }
 
+  OpenFDM_FORCE_INLINE
   void setAngleAxis(value_type angle, const Vector3& axis)
   { (*this) = Quaternion::fromAngleAxis(angle, axis); }
+  OpenFDM_FORCE_INLINE
   void setAngleAxisDeg(value_type deg, const Vector3& axis)
   { setAngleAxis(deg*deg2rad, axis); }
 
+  OpenFDM_FORCE_INLINE
   Vector3 getAxis(void) const
   {
     value_type nrm = norm(*this);
@@ -81,13 +84,17 @@
     else
       return 2.0*acos(cosAngle2)*axis;
   }
+  OpenFDM_FORCE_INLINE
   void setAxis(const Vector3& axis)
   { (*this) = Quaternion::fromAxis(axis); }
 
+  OpenFDM_FORCE_INLINE
   void setRotateTo(const Vector3& from, const Vector3& to)
   { (*this) = Quaternion::fromRotateTo(from, to); }
+  OpenFDM_FORCE_INLINE
   void setRotateTo(size_type i, const Vector3& v)
   { (*this) = Quaternion::fromRotateTo(i, v); }
+  OpenFDM_FORCE_INLINE
   void setRotateTo(size_type i1, const Vector3& v1,
                    size_type i2, const Vector3& v2)
   { (*this) = Quaternion::fromRotateTo(i1, v1, i2, v2); }
@@ -151,6 +158,9 @@
   OpenFDM_FORCE_INLINE
   Matrix33 getTransform(void) const
   {
+//  [ 1 - 2y^2 - 2z^2    2xy - 2wz      2xz + 2wy
+//    2xy + 2wz    1 - 2x^2 - 2z^2    2yz - 2wx
+//    2xz - 2wy      2yz + 2wx    1 - 2x^2 - 2y^2 ]
     value_type q1 = (*this)(1);
     value_type q2 = (*this)(2);
     value_type q3 = (*this)(3);
@@ -182,38 +192,50 @@
   Matrix33 getBackTransform(void) const
   { return trans(getTransform()); }
 
+  /// Rotate a vector into a coordinate representation of a frame
+  /// rotated with this quaternion
+  OpenFDM_FORCE_INLINE
   Vector3 transform(const Vector3& v) const
   {
-    value_type r = 1/dot(*this, *this);
+    value_type r = 2/dot(*this, *this);
     Vector3 qimag = imag(*this);
     value_type qr = real(*this);
-    return (2*r*qr*qr - 1)*v
-      + (2*r*dot(qimag, v))*qimag
-      - (2*r*qr)*cross(qimag, v);
+    return (r*qr*qr - 1)*v + (r*dot(qimag, v))*qimag - (r*qr)*cross(qimag, v);
   }
+  /// Rotate a vector from a coordinate representation of a frame
+  /// rotated with this quaternion
+  OpenFDM_FORCE_INLINE
   Vector3 backTransform(const Vector3& v) const
   {
-    value_type r = 1/dot(*this, *this);
+    value_type r = 2/dot(*this, *this);
     Vector3 qimag = imag(*this);
     value_type qr = real(*this);
-    return (2*r*qr*qr - 1)*v
-      + (2*r*dot(qimag, v))*qimag
-      + (2*r*qr)*cross(qimag, v);
+    return (r*qr*qr - 1)*v + (r*dot(qimag, v))*qimag + (r*qr)*cross(qimag, v);
   }
 
+  /// Rotate a vector with the quaternion
   OpenFDM_FORCE_INLINE
+  Vector3 rotate(const Vector3& v) const
+  { return backTransform(v); }
+  /// Rotate a vector with the inverse quaternion
+  OpenFDM_FORCE_INLINE
+  Vector3 rotateBack(const Vector3& v) const
+  { return transform(v); }
+
+  /// Unit quaternion
+  OpenFDM_FORCE_INLINE
   static Quaternion unit(unsigned i = 1)
   { return Quaternion(Vector4<T>::unit(i)); }
 
+  /// Create from real part and imaginary part
+  OpenFDM_FORCE_INLINE
   static Quaternion fromRealImag(value_type r, const Vector3& i)
   { return Quaternion(r, i(1), i(2), i(3)); }
-  static Quaternion fromImag(const Vector3& i)
-  { return Quaternion(0, i(1), i(2), i(3)); }
-  static Quaternion fromReal(value_type r)
-  { return Quaternion(r, 0, 0, 0); }
 
+  OpenFDM_FORCE_INLINE
   static Quaternion fromEulerSeq(unsigned i, value_type angle)
   { return Quaternion::fromAngleAxis(angle, Vector3::unit(i)); }
+  OpenFDM_FORCE_INLINE
   static Quaternion fromEulerSeq(unsigned i1, value_type angle1,
                                  unsigned i2, value_type angle2)
   {
@@ -221,6 +243,7 @@
     Quaternion q2 = Quaternion::fromEulerSeq(i2, angle2);
     return q1*q2;
   }
+  OpenFDM_FORCE_INLINE
   static Quaternion fromEulerSeq(unsigned i1, value_type angle1,
                                  unsigned i2, value_type angle2,
                                  unsigned i3, value_type angle3)
@@ -256,12 +279,15 @@
                        Cxd2Szd2*Cyd2 - Sxd2Czd2*Syd2);
   }
 
+  OpenFDM_FORCE_INLINE
   static Quaternion fromYawPitchRoll(value_type y, value_type p, value_type r)
   { return fromEuler(y, p, r); }
 
+  OpenFDM_FORCE_INLINE
   static Quaternion fromHeadAttBank(value_type h, value_type a, value_type b)
   { return fromEuler(h, a, b); }
 
+  OpenFDM_FORCE_INLINE
   static Quaternion fromLonLat(value_type lon, value_type lat)
   {
     value_type zd2 = 0.5*lon;
@@ -276,18 +302,22 @@
     return Quaternion( Czd2*Cyd2, -Szd2*Syd2, Czd2*Syd2, Szd2*Cyd2);
   }
 
+  OpenFDM_FORCE_INLINE
   static Quaternion fromAngleAxis(value_type angle, const Vector3& axis)
   {
     value_type angle2 = 0.5*angle;
     return Quaternion::fromRealImag(cos(angle2), sin(angle2)*axis);
   }
 
+  OpenFDM_FORCE_INLINE
   static Quaternion fromAngleAxisDeg(value_type deg, const Vector3& axis)
   { return Quaternion::fromAngleAxis(deg*deg2rad, axis); }
 
+  OpenFDM_FORCE_INLINE
   static Quaternion fromAxis(const Vector3& axis)
   { return Quaternion::fromAngleAxis(norm(axis), normalize(axis)); }
 
+  OpenFDM_FORCE_INLINE
   static Quaternion fromRotateTo(const Vector3& from, const Vector3& to)
   {
     value_type nfrom = norm(from);
@@ -444,6 +474,10 @@
 operator*(const Quaternion<T>& q1, const Quaternion<T>& q2)
 {
   Quaternion<T> q;
+/*  w = w1w2 - x1x2 - y1y2 - z1z2 */
+/*  x = w1x2 + x1w2 + y1z2 - z1y2 */
+/*  y = w1y2 - x1z2 + y1w2 + z1x2 */
+/*  z = w1z2 + x1y2 - y1x2 + z1w2 */
 
   q(1) = q1(1)*q2(1) - q1(2)*q2(2) - q1(3)*q2(3) - q1(4)*q2(4);
   q(2) = q1(1)*q2(2) + q1(2)*q2(1) + q1(3)*q2(4) - q1(4)*q2(3);



From frohlich at berlios.de  Sun Nov 13 11:46:27 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Sun, 13 Nov 2005 11:46:27 +0100
Subject: [OpenFDM-svn] r60 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200511131046.jADAkRta030796@sheep.berlios.de>

Author: frohlich
Date: 2005-11-13 11:45:59 +0100 (Sun, 13 Nov 2005)
New Revision: 60

Modified:
   trunk/OpenFDM/src/OpenFDM/AeroForce.cpp
   trunk/OpenFDM/src/OpenFDM/AeroForce.h
   trunk/OpenFDM/src/OpenFDM/Contact.cpp
   trunk/OpenFDM/src/OpenFDM/FreeJoint.cpp
   trunk/OpenFDM/src/OpenFDM/FreeJoint.h
   trunk/OpenFDM/src/OpenFDM/Integrator.cpp
   trunk/OpenFDM/src/OpenFDM/Integrator.h
   trunk/OpenFDM/src/OpenFDM/Model.cpp
   trunk/OpenFDM/src/OpenFDM/Model.h
   trunk/OpenFDM/src/OpenFDM/ModelGroup.cpp
   trunk/OpenFDM/src/OpenFDM/ModelGroup.h
   trunk/OpenFDM/src/OpenFDM/PrismaticJoint.cpp
   trunk/OpenFDM/src/OpenFDM/PrismaticJoint.h
   trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp
   trunk/OpenFDM/src/OpenFDM/RevoluteJoint.h
   trunk/OpenFDM/src/OpenFDM/RootFrame.cpp
   trunk/OpenFDM/src/OpenFDM/RootFrame.h
   trunk/OpenFDM/src/OpenFDM/System.cpp
Log:
Move function evaluation time into TaskInfo


Modified: trunk/OpenFDM/src/OpenFDM/AeroForce.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/AeroForce.cpp	2005-11-12 17:48:06 UTC (rev 59)
+++ trunk/OpenFDM/src/OpenFDM/AeroForce.cpp	2005-11-13 10:45:59 UTC (rev 60)
@@ -19,7 +19,7 @@
   mEnvironment = env;
 
   // Initialize all the expression nodes we will need.
-  for (int i = 0; i < 6; ++i) {
+  for (unsigned i = 0; i < 6; ++i) {
     mStabilityAxisSummers[i] = new SumExpressionImpl;
     mBodyAxisSummers[i] = new SumExpressionImpl;
   }
@@ -118,6 +118,18 @@
 }
 
 void
+AeroForce::output(const TaskInfo& taskInfo)
+{
+  if (nonZeroIntersection(taskInfo.getSampleTimeSet(),
+                          SampleTime::PerTimestep)) {
+    Log(Model, Debug) << "AeroForce::output(): \"" << getName()
+                      << "\" computing ground plane below" << endl;
+    real_type t = taskInfo.getTime();
+    mGroundVal = mEnvironment->getGround()->getGroundPlane(t, getRefPosition());
+  }
+}
+
+void
 AeroForce::setPosition(const Vector3& p)
 {
   mPosition = p;
@@ -560,11 +572,8 @@
 }
 
 void
-AeroForce::setState(real_type t, const Vector& state, unsigned offset)
+AeroForce::setState(const Vector& state, unsigned offset)
 {
-  // First determine the intersection depth with the ground.
-  mGroundVal = mEnvironment->getGround()->getGroundPlane(t, getRefPosition());
-
   // Dirty everything.
   mDirtyRefPosition = true;
   mDirtyUnitDown = true;

Modified: trunk/OpenFDM/src/OpenFDM/AeroForce.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/AeroForce.h	2005-11-12 17:48:06 UTC (rev 59)
+++ trunk/OpenFDM/src/OpenFDM/AeroForce.h	2005-11-13 10:45:59 UTC (rev 60)
@@ -33,6 +33,8 @@
   AeroForce(Environment* env, const std::string&);
   virtual ~AeroForce(void);
 
+  virtual void output(const TaskInfo&);
+
   void setPosition(const Vector3& p);
   const Vector3& getPosition(void) const;
 
@@ -113,7 +115,7 @@
   }
 
   virtual void
-  setState(real_type t, const Vector& state, unsigned offset);
+  setState(const Vector& state, unsigned offset);
 
   // The interface to the mechanical system.
   virtual void computeForce(void);

Modified: trunk/OpenFDM/src/OpenFDM/Contact.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Contact.cpp	2005-11-12 17:48:06 UTC (rev 59)
+++ trunk/OpenFDM/src/OpenFDM/Contact.cpp	2005-11-13 10:45:59 UTC (rev 60)
@@ -40,7 +40,7 @@
                           SampleTime::PerTimestep)) {
     Log(Model, Debug) << "Contact::output(): \"" << getName()
                       << "\" computing ground plane below" << endl;
-    getGround(0 /*FIXME*/);
+    getGround(taskInfo.getTime());
 
     // FIXME
     if (getInputPort("enabled").isValid())

Modified: trunk/OpenFDM/src/OpenFDM/FreeJoint.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/FreeJoint.cpp	2005-11-12 17:48:06 UTC (rev 59)
+++ trunk/OpenFDM/src/OpenFDM/FreeJoint.cpp	2005-11-13 10:45:59 UTC (rev 60)
@@ -64,7 +64,7 @@
 }
 
 void
-FreeJoint::setState(real_type t, const Vector& state, unsigned offset)
+FreeJoint::setState(const Vector& state, unsigned offset)
 {
   setOutboardOrientation(Vector4(state(offset+1), state(offset+2),
                          state(offset+3), state(offset+4)));

Modified: trunk/OpenFDM/src/OpenFDM/FreeJoint.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/FreeJoint.h	2005-11-12 17:48:06 UTC (rev 59)
+++ trunk/OpenFDM/src/OpenFDM/FreeJoint.h	2005-11-13 10:45:59 UTC (rev 60)
@@ -66,9 +66,6 @@
     topBody->setRefOrientation(o);
   }
 
-  /** Sets the state of this multibody system from the state vector state.
-   */
-  void setEvalState(real_type t, const Vector& state);
   /** Sets the state of this multibody system from the state vector state
       and returns the time derivative in deriv.
    */
@@ -86,7 +83,7 @@
 
   /** Plugin function for the state propagation.
    */
-  virtual void setState(real_type t, const Vector& state, unsigned offset);
+  virtual void setState(const Vector& state, unsigned offset);
   /** Plugin function for the state propagation.
    */
   virtual void getState(Vector& state, unsigned offset) const;

Modified: trunk/OpenFDM/src/OpenFDM/Integrator.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Integrator.cpp	2005-11-12 17:48:06 UTC (rev 59)
+++ trunk/OpenFDM/src/OpenFDM/Integrator.cpp	2005-11-13 10:45:59 UTC (rev 60)
@@ -55,7 +55,7 @@
 }
 
 void
-Integrator::setState(real_type, const Vector& state, unsigned offset)
+Integrator::setState(const Vector& state, unsigned offset)
 {
   // FIXME reshape ...
   for (unsigned j = 1; j <= cols(mIntegralState); ++j) {

Modified: trunk/OpenFDM/src/OpenFDM/Integrator.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Integrator.h	2005-11-12 17:48:06 UTC (rev 59)
+++ trunk/OpenFDM/src/OpenFDM/Integrator.h	2005-11-13 10:45:59 UTC (rev 60)
@@ -19,7 +19,7 @@
   virtual bool init(void);
   virtual void output(const TaskInfo&);
 
-  virtual void setState(real_type t, const Vector& state, unsigned offset);
+  virtual void setState(const Vector& state, unsigned offset);
   virtual void getState(Vector& state, unsigned offset) const;
   virtual void getStateDeriv(Vector& stateDeriv, unsigned offset);
 

Modified: trunk/OpenFDM/src/OpenFDM/Model.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Model.cpp	2005-11-12 17:48:06 UTC (rev 59)
+++ trunk/OpenFDM/src/OpenFDM/Model.cpp	2005-11-13 10:45:59 UTC (rev 60)
@@ -85,7 +85,7 @@
 }
 
 void
-Model::setState(real_type t, const Vector& state, unsigned offset)
+Model::setState(const Vector& state, unsigned offset)
 {
 }
 
@@ -113,8 +113,9 @@
 Model::evalFunction(real_type t, const Vector& v, Vector& out)
 {
   /// FIXME Hmm, may be different ...
-  setState(t, v, 0);
+  setState(v, 0);
   TaskInfo taskInfo;
+  taskInfo.setTime(t);
   taskInfo.addSampleTime(SampleTime::Continous);
   output(taskInfo);
   out.resize(getNumContinousStates());

Modified: trunk/OpenFDM/src/OpenFDM/Model.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Model.h	2005-11-12 17:48:06 UTC (rev 59)
+++ trunk/OpenFDM/src/OpenFDM/Model.h	2005-11-13 10:45:59 UTC (rev 60)
@@ -184,8 +184,14 @@
 public:
   TaskInfo(void) :
     mSliceSize(0),
+    mTime(0),
     mNumBasicSteps(0)
   {}
+
+  void setTime(real_type t)
+  { mTime = t; }
+  real_type getTime(void) const
+  { return mTime; }
   
   void addSampleTime(const SampleTime& sampleTime)
   { mSampleTimeSet.addSampleTime(sampleTime); }
@@ -209,6 +215,7 @@
 private:
   SampleTimeSet mSampleTimeSet;
   real_type mSliceSize;
+  real_type mTime;
   unsigned mNumBasicSteps;
 };
 
@@ -235,7 +242,7 @@
   /// Called whenever discrete states need to be updated.
   virtual void update(const TaskInfo& taskInfo);
 
-  virtual void setState(real_type t, const Vector& state, unsigned offset);
+  virtual void setState(const Vector& state, unsigned offset);
   virtual void getState(Vector& state, unsigned offset) const;
   virtual void getStateDeriv(Vector& stateDeriv, unsigned offset);
 

Modified: trunk/OpenFDM/src/OpenFDM/ModelGroup.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/ModelGroup.cpp	2005-11-12 17:48:06 UTC (rev 59)
+++ trunk/OpenFDM/src/OpenFDM/ModelGroup.cpp	2005-11-13 10:45:59 UTC (rev 60)
@@ -221,7 +221,7 @@
 }
 
 void
-ModelGroup::setState(real_type t, const Vector& state, unsigned offset)
+ModelGroup::setState(const Vector& state, unsigned offset)
 {
   OpenFDMAssert(offset + getNumContinousStates() <= rows(state));
 
@@ -230,7 +230,7 @@
     unsigned nStates = (*it)->getNumContinousStates();
     if (0 < nStates) {
       OpenFDMAssert(offset + nStates <= rows(state));
-      (*it)->setState(t, state, offset);
+      (*it)->setState(state, offset);
       offset += nStates;
     }
   }

Modified: trunk/OpenFDM/src/OpenFDM/ModelGroup.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/ModelGroup.h	2005-11-12 17:48:06 UTC (rev 59)
+++ trunk/OpenFDM/src/OpenFDM/ModelGroup.h	2005-11-13 10:45:59 UTC (rev 60)
@@ -42,7 +42,7 @@
   /// Called whenever discrete states need to be updated.
   virtual void update(const TaskInfo& taskInfo);
 
-  virtual void setState(real_type t, const Vector& state, unsigned offset);
+  virtual void setState(const Vector& state, unsigned offset);
   virtual void getState(Vector& state, unsigned offset) const;
   virtual void getStateDeriv(Vector& stateDeriv, unsigned offset);
 

Modified: trunk/OpenFDM/src/OpenFDM/PrismaticJoint.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/PrismaticJoint.cpp	2005-11-12 17:48:06 UTC (rev 59)
+++ trunk/OpenFDM/src/OpenFDM/PrismaticJoint.cpp	2005-11-13 10:45:59 UTC (rev 60)
@@ -105,7 +105,7 @@
 }
 
 void
-PrismaticJoint::setState(real_type t, const Vector& state, unsigned offset)
+PrismaticJoint::setState(const Vector& state, unsigned offset)
 {
   setJointPos(state(offset+1));
   setJointVel(state(offset+2));

Modified: trunk/OpenFDM/src/OpenFDM/PrismaticJoint.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/PrismaticJoint.h	2005-11-12 17:48:06 UTC (rev 59)
+++ trunk/OpenFDM/src/OpenFDM/PrismaticJoint.h	2005-11-13 10:45:59 UTC (rev 60)
@@ -90,7 +90,7 @@
 
   /** Methods for the OpenFDM::Part.
    */
-  virtual void setState(real_type t, const Vector& state, unsigned offset);
+  virtual void setState(const Vector& state, unsigned offset);
   virtual void getState(Vector& state, unsigned offset) const;
   virtual void getStateDeriv(Vector& state, unsigned offset);
 

Modified: trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp	2005-11-12 17:48:06 UTC (rev 59)
+++ trunk/OpenFDM/src/OpenFDM/RevoluteJoint.cpp	2005-11-13 10:45:59 UTC (rev 60)
@@ -110,7 +110,7 @@
 }
 
 void
-RevoluteJoint::setState(real_type t, const Vector& state, unsigned offset)
+RevoluteJoint::setState(const Vector& state, unsigned offset)
 {
   if (mTrackPosition) {
     setJointPos(state(offset+1));

Modified: trunk/OpenFDM/src/OpenFDM/RevoluteJoint.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RevoluteJoint.h	2005-11-12 17:48:06 UTC (rev 59)
+++ trunk/OpenFDM/src/OpenFDM/RevoluteJoint.h	2005-11-13 10:45:59 UTC (rev 60)
@@ -90,7 +90,7 @@
 
   /** Methods for the OpenFDM::Part.
    */
-  virtual void setState(real_type t, const Vector& state, unsigned offset);
+  virtual void setState(const Vector& state, unsigned offset);
   virtual void getState(Vector& state, unsigned offset) const;
   virtual void getStateDeriv(Vector& state, unsigned offset);
 

Modified: trunk/OpenFDM/src/OpenFDM/RootFrame.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RootFrame.cpp	2005-11-12 17:48:06 UTC (rev 59)
+++ trunk/OpenFDM/src/OpenFDM/RootFrame.cpp	2005-11-13 10:45:59 UTC (rev 60)
@@ -53,13 +53,13 @@
 class SetStateVisitor
   : public Visitor {
 public:
-  SetStateVisitor(const Vector& state, real_type t)
-    : mState(state), mTime(t), mOffset(0u)
+  SetStateVisitor(const Vector& state)
+    : mState(state), mOffset(0u)
   { }
   virtual void apply(MultiBodyModel& abNode)
   {
     OpenFDMAssert(mOffset + abNode.getNumContinousStates() <= mState.size());
-    abNode.setState(mTime, mState, mOffset);
+    abNode.setState(mState, mOffset);
     mOffset += abNode.getNumContinousStates();
   }
 private:
@@ -172,10 +172,10 @@
 }
 
 void
-MultiBodySystem::setEvalState(real_type t, const Vector& state)
+MultiBodySystem::setEvalState(const Vector& state)
 {
   // First we need to inject the current state into the tree of parts.
-  setState(t, state, 0);
+  setState(state, 0);
 
   // Compute the external and interaction forces.
   ForceComputationVisitor forceVisitor;
@@ -193,7 +193,7 @@
 void
 MultiBodySystem::computeStateDeriv(real_type t, const Vector& state, Vector& deriv)
 {
-  setEvalState(t, state);
+  setEvalState(state);
 
   // And finally extract the derivative vector from the tree.
   GetStateDerivVisitor gsdv(getNumContinousStates());
@@ -202,9 +202,9 @@
 }
 
 void
-MultiBodySystem::setState(real_type t, const Vector& state, unsigned offset)
+MultiBodySystem::setState(const Vector& state, unsigned offset)
 {
-  SetStateVisitor ssv(state(Range(offset+1, offset+getNumContinousStates())), t);
+  SetStateVisitor ssv(state(Range(offset+1, offset+getNumContinousStates())));
   mRootFrame->accept(ssv);
 }
 

Modified: trunk/OpenFDM/src/OpenFDM/RootFrame.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/RootFrame.h	2005-11-12 17:48:06 UTC (rev 59)
+++ trunk/OpenFDM/src/OpenFDM/RootFrame.h	2005-11-13 10:45:59 UTC (rev 60)
@@ -32,13 +32,13 @@
 
   /** Sets the state of this multibody system from the state vector state.
    */
-  void setEvalState(real_type t, const Vector& state);
+  void setEvalState(const Vector& state);
   /** Sets the state of this multibody system from the state vector state
       and returns the time derivative in deriv.
    */
   void computeStateDeriv(real_type t, const Vector& state, Vector& deriv);
   
-  virtual void setState(real_type t, const Vector& state, unsigned offset);
+  virtual void setState(const Vector& state, unsigned offset);
   virtual void getState(Vector& state, unsigned offset) const;
   virtual void getStateDeriv(Vector& stateDeriv, unsigned offset);
 

Modified: trunk/OpenFDM/src/OpenFDM/System.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/System.cpp	2005-11-12 17:48:06 UTC (rev 59)
+++ trunk/OpenFDM/src/OpenFDM/System.cpp	2005-11-13 10:45:59 UTC (rev 60)
@@ -162,7 +162,8 @@
       loopTEnd = tEnd;
     } else {
       // need that  ...
-      const TaskInfo& taskInfo = mDiscreteTaskList[mCurrentTaskNum];
+      TaskInfo taskInfo = mDiscreteTaskList[mCurrentTaskNum];
+      taskInfo.setTime(getTime());
       
       if (mCurrentSliceTime == 0) {
         Log(Model, Info) << "Computing discrete output for Task # "
@@ -198,6 +199,7 @@
       TaskInfo taskInfo;
       taskInfo.addSampleTime(SampleTime::Continous);
       taskInfo.addSampleTime(SampleTime::PerTimestep);
+      taskInfo.setTime(getTime());
       output(taskInfo);
 
       Log(Model, Info) << "Integration: from time " << mTimestepper->getTime()
@@ -272,9 +274,9 @@
   real_type rtol = 1e-8;
   bool ret = GaussNewton(trimFunction, getTime(), trimState, atol, rtol);
   if (ret) {
-    setState(getTime(), trimState, 0);
+    setState(trimState, 0);
   } else {
-    setState(getTime(), state, 0);
+    setState(state, 0);
   }
 
   return ret;



From frohlich at berlios.de  Sun Nov 13 20:33:31 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Sun, 13 Nov 2005 20:33:31 +0100
Subject: [OpenFDM-svn] r61 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200511131933.jADJXVZ3030510@sheep.berlios.de>

Author: frohlich
Date: 2005-11-13 20:33:28 +0100 (Sun, 13 Nov 2005)
New Revision: 61

Modified:
   trunk/OpenFDM/src/OpenFDM/ExplicitAdams.h
Log:
Fix bug in adams methods.


Modified: trunk/OpenFDM/src/OpenFDM/ExplicitAdams.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/ExplicitAdams.h	2005-11-13 10:45:59 UTC (rev 60)
+++ trunk/OpenFDM/src/OpenFDM/ExplicitAdams.h	2005-11-13 19:33:28 UTC (rev 61)
@@ -42,7 +42,7 @@
   enum { MaxAvailOrder = 4 };
 
   unsigned index(unsigned backidx) const
-  { return backidx%mOrder; }
+  { return backidx % MaxAvailOrder; }
  
   unsigned mOrder;
   unsigned mStepNumber;



From frohlich at berlios.de  Mon Nov 14 22:46:41 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Mon, 14 Nov 2005 22:46:41 +0100
Subject: [OpenFDM-svn] r62 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200511142146.jAELkfHX011974@sheep.berlios.de>

Author: frohlich
Date: 2005-11-14 22:46:36 +0100 (Mon, 14 Nov 2005)
New Revision: 62

Modified:
   trunk/OpenFDM/src/OpenFDM/LogStream.h
Log:
Always mit error level messages.


Modified: trunk/OpenFDM/src/OpenFDM/LogStream.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/LogStream.h	2005-11-13 19:33:28 UTC (rev 61)
+++ trunk/OpenFDM/src/OpenFDM/LogStream.h	2005-11-14 21:46:36 UTC (rev 62)
@@ -21,6 +21,7 @@
   NewtonMethod = 1 << 6,
   Misc = 1 << 7,
   Model = 1 << 8,
+  Schedule = 1 << 9,
   Assert = ~0
 };
 
@@ -105,7 +106,10 @@
   static void setPriority(Priority priority);
 
   bool enabled(Category category, Priority priority) const
-  { return (category & mCategory) && (priority <= mPriority); }
+  {
+    return ((category & mCategory) && (priority <= mPriority))
+      || (priority == Error);
+  }
 
   std::basic_ostream<char>* getStream(void)
   { return mStream; }



From frohlich at berlios.de  Mon Nov 14 22:51:28 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Mon, 14 Nov 2005 22:51:28 +0100
Subject: [OpenFDM-svn] r63 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200511142151.jAELpS4l012915@sheep.berlios.de>

Author: frohlich
Date: 2005-11-14 22:51:23 +0100 (Mon, 14 Nov 2005)
New Revision: 63

Modified:
   trunk/OpenFDM/src/OpenFDM/System.cpp
Log:
Use Schedule log category.


Modified: trunk/OpenFDM/src/OpenFDM/System.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/System.cpp	2005-11-14 21:46:36 UTC (rev 62)
+++ trunk/OpenFDM/src/OpenFDM/System.cpp	2005-11-14 21:51:23 UTC (rev 63)
@@ -33,7 +33,7 @@
   // and collects sample time information.
   // If it fails to initialize, the system cannot be initialized.
   if (!ModelGroup::init()) {
-    Log(Model, Error) << "Error initializing submodels.\nAborting!" << endl;
+    Log(Schedule, Error) << "Error initializing submodels.\nAborting!" << endl;
     return false;
   }
 
@@ -66,9 +66,9 @@
   }
 
   // Now that we know the basic sample time, build the job schedules
-  Log(Model, Info) << "Basic time is: " << gcd << endl;
+  Log(Schedule, Info) << "Basic time is: " << gcd << endl;
   if (100*gcd < minSampleTime)
-    Log(Model, Warning) << "Basic sample time is less than 100 times smaller "
+    Log(Schedule, Warning) << "Basic sample time is less than 100 times smaller "
       "than the smalles submodels sample time" << endl;
 
   // We do not have any discrete sample time, just do continous scheduling
@@ -80,7 +80,7 @@
   // simulations anyway
   real_type stepsPerCycle = floor(scm/gcd + 0.5);
   if (Limits<unsigned>::max() <= stepsPerCycle) {
-    Log(Model, Error) << "Too many basic steps for our datatypes.\n"
+    Log(Schedule, Error) << "Too many basic steps for our datatypes.\n"
       "You propably want to use sample times fitting together.\n"
       "Aborting!" << endl;
     return false;
@@ -108,10 +108,10 @@
   mDiscreteTaskList.swap(cTL);
 
   // Just a verbose print here ...
-  Log(Model, Info) << "gcd of sample times is: " << gcd
+  Log(Schedule, Info) << "gcd of sample times is: " << gcd
                    << ", scm of sample times is: " << scm << endl;
   for (unsigned i = 0; i < mDiscreteTaskList.size(); ++i)
-    Log(Model, Info) << "Task # " << i << ": # basicSteps "
+    Log(Schedule, Info) << "Task # " << i << ": # basicSteps "
                      << mDiscreteTaskList[i].getNumBasicSteps()
                      << ", sliceSize "
                      << mDiscreteTaskList[i].getSliceSize()
@@ -121,7 +121,7 @@
   // At the moment we need a timestepper, else the time does not get
   // incremented
   if (!mTimestepper) {
-    Log(Model, Error) << "Timestepping method is unset.\nAborting!" << endl;
+    Log(Schedule, Error) << "Timestepping method is unset.\nAborting!" << endl;
     return false;
   }
 
@@ -166,7 +166,7 @@
       taskInfo.setTime(getTime());
       
       if (mCurrentSliceTime == 0) {
-        Log(Model, Info) << "Computing discrete output for Task # "
+        Log(Schedule, Info) << "Computing discrete output for Task # "
                          << mCurrentTaskNum << ": # basicSteps "
                          << taskInfo.getNumBasicSteps() << ", sliceSize "
                          << taskInfo.getSliceSize() << ", sample times "
@@ -195,14 +195,14 @@
       mTime = loopTEnd;
     } else {
       // Do the pre integration output round
-      Log(Model, Info) << "Preparing Models: pre integration step" << endl;
+      Log(Schedule, Info) << "Preparing Models: pre integration step" << endl;
       TaskInfo taskInfo;
       taskInfo.addSampleTime(SampleTime::Continous);
       taskInfo.addSampleTime(SampleTime::PerTimestep);
       taskInfo.setTime(getTime());
       output(taskInfo);
 
-      Log(Model, Info) << "Integration: from time " << mTimestepper->getTime()
+      Log(Schedule, Info) << "Integration: from time " << mTimestepper->getTime()
                        << " up to time " << loopTEnd
                        << " dt = " << loopTEnd - mTimestepper->getTime()
                        << endl;
@@ -210,7 +210,7 @@
       mTime = mTimestepper->getTime();
       // It set's the current state into the models and computes the
       // accelerations for the mechanical system
-      Log(Model, Info) << "Integration: finished" << endl;
+      Log(Schedule, Info) << "Integration: finished" << endl;
       evalFunction(mTimestepper->getTime(), mTimestepper->getState(), state);
     }
 



From frohlich at berlios.de  Thu Nov 17 20:09:07 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Thu, 17 Nov 2005 20:09:07 +0100
Subject: [OpenFDM-svn] r64 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200511171909.jAHJ97Zw010956@sheep.berlios.de>

Author: frohlich
Date: 2005-11-17 20:08:25 +0100 (Thu, 17 Nov 2005)
New Revision: 64

Modified:
   trunk/OpenFDM/src/OpenFDM/DoPri5.cpp
   trunk/OpenFDM/src/OpenFDM/DoPri5.h
   trunk/OpenFDM/src/OpenFDM/ExplicitEuler.cpp
   trunk/OpenFDM/src/OpenFDM/ExplicitEuler.h
   trunk/OpenFDM/src/OpenFDM/ImplicitEuler.cpp
   trunk/OpenFDM/src/OpenFDM/ImplicitEuler.h
   trunk/OpenFDM/src/OpenFDM/MidpointRule.cpp
   trunk/OpenFDM/src/OpenFDM/MidpointRule.h
   trunk/OpenFDM/src/OpenFDM/ODESolver.cpp
   trunk/OpenFDM/src/OpenFDM/ODESolver.h
Log:
Some simple and untested dense output code.


Modified: trunk/OpenFDM/src/OpenFDM/DoPri5.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/DoPri5.cpp	2005-11-14 21:51:23 UTC (rev 63)
+++ trunk/OpenFDM/src/OpenFDM/DoPri5.cpp	2005-11-17 19:08:25 UTC (rev 64)
@@ -21,13 +21,10 @@
 bool
 DoPri5::integrate(real_type toTEnd)
 {
-  Vector k1, k2, k3, k4, k5, k6, k7;
-  Vector y2, y3, y4, y5, y6, y7;
-  Vector err;
-
+  real_type h = 0;
   while (!reached(toTEnd)) {
     real_type t = getTime();
-    real_type h = maxStepsize(toTEnd);
+    h = maxStepsize(toTEnd);
 
     // Compute the inner stages k1, ..., k7
     evalFunction(t, mState, k1);
@@ -52,12 +49,6 @@
       + (h*a75)*k5 + (h*a76)*k6;
     evalFunction(t+h, y7, k7);
     
-    // Dense output ...
-    // We do not support this one ...
-//     rcont = (h*d1)*k1
-//       + (h*d3)*k3 + (h*d4)*k4 + (h*d5)*k5
-//       + (h*d6)*k6 + (h*d7)*k7;
- 
     // The error estimate. Is the error to a 4-th order embedded scheme.
     err = (h*e1)*k1 + (h*e3)*k3 + (h*e4)*k4 + (h*e5)*k5
       + (h*e6)*k6 + (h*e7)*k7;
@@ -66,18 +57,46 @@
     real_type rtol = 1e-14;
     real_type en = scaledErr(y7, err, atol, rtol);
 
-    if ( 1.0 < en )
+    if (1.0 < en)
       Log(TimeStep, Warning) << "DOPRI5: error too big: " << en << endl;
     else
       Log(TimeStep, Info) << "DOPRI5: local error: " << en << endl;
 
+    // Need to save that here
+    mRCont[0] = mState;
+
     // We do unconditionally accept all steps, y7 is the new mState value.
     mState = y7;
     mTime += h;
   }
+
+  // Dense output ...
+  mRCont[1] = mState - mRCont[0];
+  mRCont[2] = h*k1 - mRCont[1];
+  mRCont[3] = (-h)*k2 + mRCont[1] - mRCont[2];
+  mRCont[4] = (h*d1)*k1 + (h*d3)*k3 + (h*d4)*k4 + (h*d5)*k5
+    + (h*d6)*k6 + (h*d7)*k2;
+
   return true;
 }
 
+bool
+DoPri5::denseOutput(real_type t, Vector& out)
+{
+  if (t < mTime - mStepsize || mTime < t) {
+    Log(TimeStep, Error) << "Request for dense output at t = " << t
+                         << " out of range [" << mTime - mStepsize
+                         << "," << mTime << "]" << endl;
+//     return false;
+  }
+
+  /// Compute dense output. That is
+  real_type theta = (t - (mTime - mStepsize))/mStepsize;
+  real_type theta1 = 1 - theta;
+  out = mRCont[0] + theta*(mRCont[1] + theta1*(mRCont[2] + theta*(mRCont[3] + theta1*mRCont[4])));
+  return true;
+}
+
 // The values of the Runge-Kutta tables
 const real_type DoPri5::a21 = 2.0/10.0;
 const real_type DoPri5::a31 = 3.0/40.0;

Modified: trunk/OpenFDM/src/OpenFDM/DoPri5.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/DoPri5.h	2005-11-14 21:51:23 UTC (rev 63)
+++ trunk/OpenFDM/src/OpenFDM/DoPri5.h	2005-11-17 19:08:25 UTC (rev 64)
@@ -38,8 +38,17 @@
   virtual ~DoPri5(void);
 
   virtual bool integrate(real_type toTEnd);
+  virtual bool denseOutput(real_type t, Vector& out);
 
 private:
+  /// For dense output
+  Vector mRCont[5];
+
+  /// actually only used in integrate, but for performance reasons
+  Vector k1, k2, k3, k4, k5, k6, k7;
+  Vector y2, y3, y4, y5, y6, y7;
+  Vector err;
+
   // The coefficients of the method.
   static const real_type c2, c3, c4, c5;
   static const real_type d1, d3, d4, d5, d6, d7;

Modified: trunk/OpenFDM/src/OpenFDM/ExplicitEuler.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/ExplicitEuler.cpp	2005-11-14 21:51:23 UTC (rev 63)
+++ trunk/OpenFDM/src/OpenFDM/ExplicitEuler.cpp	2005-11-17 19:08:25 UTC (rev 64)
@@ -20,16 +20,23 @@
 bool
 ExplicitEuler::integrate(real_type toTEnd)
 {
-  Vector deriv;
   while (!reached(toTEnd)) {
     real_type t = getTime();
     real_type h = maxStepsize(toTEnd);
 
-    evalFunction(t, getState(), deriv);
-    mState += h*deriv;
+    evalFunction(t, getState(), mDeriv);
+    mState += h*mDeriv;
     mTime += h;
   }
   return true;
 }
 
+bool
+ExplicitEuler::denseOutput(real_type t, Vector& out)
+{
+  // Do linear interpolation
+  out = mState - (mTime - t)*mDeriv;
+  return true;
+}
+
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/ExplicitEuler.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/ExplicitEuler.h	2005-11-14 21:51:23 UTC (rev 63)
+++ trunk/OpenFDM/src/OpenFDM/ExplicitEuler.h	2005-11-17 19:08:25 UTC (rev 64)
@@ -17,6 +17,12 @@
   virtual ~ExplicitEuler(void);
 
   virtual bool integrate(real_type toTEnd);
+  virtual bool denseOutput(real_type t, Vector& out);
+
+private:
+  /// Vector storing the derivative of that step. That is used for
+  /// dense output.
+  Vector mDeriv;
 };
 
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/ImplicitEuler.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/ImplicitEuler.cpp	2005-11-14 21:51:23 UTC (rev 63)
+++ trunk/OpenFDM/src/OpenFDM/ImplicitEuler.cpp	2005-11-17 19:08:25 UTC (rev 64)
@@ -23,6 +23,12 @@
 {
 }
 
+void
+ImplicitEuler::invalidateHistory(void)
+{
+  mJacStepsize = 0;
+}
+
 bool
 ImplicitEuler::integrate(real_type toTEnd)
 {
@@ -33,8 +39,9 @@
 
   unsigned dim = mModel->getNumContinousStates();
 
+  real_type h = 0;
   while (!reached(toTEnd)) {
-    real_type h = maxStepsize(toTEnd);
+    h = maxStepsize(toTEnd);
 
     mCurrentStepsize = h;
     if (mJacStepsize != mCurrentStepsize) {
@@ -52,13 +59,22 @@
     mState += fState;
     mTime += h;
   }
+
+  // Save that for dense output
+  if (h == 0)
+    mDeriv.clear();
+  else
+    mDeriv = 1/h*fState;
+
   return true;
 }
 
-void
-ImplicitEuler::invalidateHistory(void)
+bool
+ImplicitEuler::denseOutput(real_type t, Vector& out)
 {
-  mJacStepsize = 0;
+  // Do linear interpolation
+  out = mState - (mTime - t)*mDeriv;
+  return true;
 }
 
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/ImplicitEuler.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/ImplicitEuler.h	2005-11-14 21:51:23 UTC (rev 63)
+++ trunk/OpenFDM/src/OpenFDM/ImplicitEuler.h	2005-11-17 19:08:25 UTC (rev 64)
@@ -18,11 +18,11 @@
   ImplicitEuler(void);
   virtual ~ImplicitEuler(void);
 
+  virtual void invalidateHistory(void);
   virtual bool integrate(real_type toTEnd);
-  virtual void invalidateHistory(void);
+  virtual bool denseOutput(real_type t, Vector& out);
 
 private:
-
   class IEFunction
     : public Function {
   public:
@@ -54,6 +54,10 @@
   real_type mJacStepsize;
   Matrix mJac;
   MatrixFactors mJacDecomp;
+
+  /// Vector storing the derivative of that step. That is used for
+  /// dense output.
+  Vector mDeriv;
 };
 
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/MidpointRule.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/MidpointRule.cpp	2005-11-14 21:51:23 UTC (rev 63)
+++ trunk/OpenFDM/src/OpenFDM/MidpointRule.cpp	2005-11-17 19:08:25 UTC (rev 64)
@@ -32,7 +32,6 @@
   real_type atol = 1e-10;
 
   Vector dy(mState.size());
-  Vector f;
   while (!reached(toTEnd)) {
     real_type t = getTime();
     real_type h = maxStepsize(toTEnd);
@@ -66,10 +65,10 @@
       Vector y = mState + 0.5*dy;
 
       // Compute new approximations to the state derivatives
-      evalFunction(t+h2, y, f);
+      evalFunction(t+h2, y, mDeriv);
 
       // Check if the increment is small enough ...
-      real_type err = scaledDiff(y, mState + h2*f, atol, rtol);
+      real_type err = scaledDiff(y, mState + h2*mDeriv, atol, rtol);
       converged = err < 1;
 
       // Check if we do converge in any way.
@@ -77,7 +76,7 @@
       prev_err = err;
 
       // Use the new approximation
-      dy = h*f;
+      dy = h*mDeriv;
 
       ++mStats.numIter;
     } while (!converged && 0 < --maxit && converging);
@@ -98,8 +97,8 @@
 
       Log(TimeStep, Warning) << "MidpointRule did not converge" << endl;
 
-      evalFunction(t, mState, f);
-      mState += h*f;
+      evalFunction(t, mState, mDeriv);
+      mState += h*mDeriv;
 
       ++mStats.numFailed;
       ++mStats.numSteps;
@@ -111,4 +110,12 @@
   return true;
 }
 
+bool
+MidpointRule::denseOutput(real_type t, Vector& out)
+{
+  // Use the collocation polynomials
+  out = mState - (mTime - t)*mDeriv;
+  return true;
+}
+
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/MidpointRule.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/MidpointRule.h	2005-11-14 21:51:23 UTC (rev 63)
+++ trunk/OpenFDM/src/OpenFDM/MidpointRule.h	2005-11-17 19:08:25 UTC (rev 64)
@@ -49,10 +49,14 @@
 
   virtual void invalidateHistory(void);
   virtual bool integrate(real_type toTEnd);
+  virtual bool denseOutput(real_type t, Vector& out);
 
 private:
   bool mCollocationPolynomialValid;
   Vector old_dy;
+  /// Vector storing the derivative of that step. That is used for
+  /// dense output.
+  Vector mDeriv;
 };
 
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/ODESolver.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/ODESolver.cpp	2005-11-14 21:51:23 UTC (rev 63)
+++ trunk/OpenFDM/src/OpenFDM/ODESolver.cpp	2005-11-17 19:08:25 UTC (rev 64)
@@ -41,4 +41,12 @@
 {
 }
 
+bool
+ODESolver::denseOutput(real_type t, Vector& out)
+{
+  // Simplest dense output you can imagine ...
+  out = mState;
+  return true;
+}
+
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/ODESolver.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/ODESolver.h	2005-11-14 21:51:23 UTC (rev 63)
+++ trunk/OpenFDM/src/OpenFDM/ODESolver.h	2005-11-17 19:08:25 UTC (rev 64)
@@ -29,6 +29,7 @@
 
   virtual void invalidateHistory(void);
   virtual bool integrate(real_type toTEnd) = 0;
+  virtual bool denseOutput(real_type t, Vector& out);
 
   bool reached(real_type tEnd);
   real_type maxStepsize(real_type tEnd);



From frohlich at berlios.de  Thu Nov 17 20:44:51 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Thu, 17 Nov 2005 20:44:51 +0100
Subject: [OpenFDM-svn] r65 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200511171944.jAHJipqD009799@sheep.berlios.de>

Author: frohlich
Date: 2005-11-17 20:44:38 +0100 (Thu, 17 Nov 2005)
New Revision: 65

Added:
   trunk/OpenFDM/src/OpenFDM/SampleTime.h
   trunk/OpenFDM/src/OpenFDM/TaskInfo.h
Modified:
   trunk/OpenFDM/src/OpenFDM/Makefile.am
   trunk/OpenFDM/src/OpenFDM/Model.h
Log:
Reorganize.


Modified: trunk/OpenFDM/src/OpenFDM/Makefile.am
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Makefile.am	2005-11-17 19:08:25 UTC (rev 64)
+++ trunk/OpenFDM/src/OpenFDM/Makefile.am	2005-11-17 19:44:38 UTC (rev 65)
@@ -99,6 +99,7 @@
   RigidBody.h \
   Rotation.h \
   RootFrame.h \
+  SampleTime.h \
   Saturation.h \
   Sensor.h \
   SimpleContact.h \
@@ -106,6 +107,7 @@
   Summer.h \
   System.h \
   Table.h \
+  TaskInfo.h \
   TimeDerivative.h \
   TransferFunction.h \
   Transform.h \

Modified: trunk/OpenFDM/src/OpenFDM/Model.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Model.h	2005-11-17 19:08:25 UTC (rev 64)
+++ trunk/OpenFDM/src/OpenFDM/Model.h	2005-11-17 19:44:38 UTC (rev 65)
@@ -13,6 +13,8 @@
 #include "Object.h"
 #include "Property.h"
 #include "Vector.h"
+#include "SampleTime.h"
+#include "TaskInfo.h"
 
 namespace OpenFDM {
 
@@ -20,205 +22,6 @@
 class Input;
 class Output;
 
-/// The discrete sample time for this model
-/// There are special meanings encoded into that value:
-/// - positive real number, this is the discrete sample time itself
-/// - zero, continous updates
-/// - otherwise, inherited from its parent model group
-class SampleTime {
-public:
-  /// Default constructor, defaults to discrete sample time
-  SampleTime(void) : mSampleTime(0) {}
-  /// Constructor with given sample time
-  SampleTime(real_type sampleTime) : mSampleTime(sampleTime) {}
-  /// Returns true if the sample time is a continous sample time
-  bool isContinous(void) const
-  { return mSampleTime == 0; }
-  /// Returns true if the sample time is discrete
-  bool isDiscrete(void) const
-  { return 0 < mSampleTime; }
-  /// Returns true if the sample time is just inheritted
-  /// FIXME: empty sample time list??
-  bool isInherited(void) const
-  { return mSampleTime == -1; }
-  /// Returns true if the task is a per timestep task
-  bool isPerTimestep(void) const
-  { return mSampleTime == -2; }
-  /// Returns the actual sample time
-  real_type getSampleTime(void) const
-  { return mSampleTime; }
-
-  /// Returns true if th sample time is valid
-  bool isValid(void) const
-  { return isContinous() || isDiscrete() || isInherited() || isPerTimestep(); }
-
-  bool operator==(const SampleTime& st) const
-  { return mSampleTime == st.mSampleTime; }
-  bool operator!=(const SampleTime& st) const
-  { return mSampleTime != st.mSampleTime; }
-
-  static const SampleTime PerTimestep;
-  static const SampleTime Inherited;
-  static const SampleTime Continous;
-
-private:
-  real_type mSampleTime;
-};
-
-class SampleTimeSet {
-  typedef std::vector<SampleTime> SampleTimeData;
-
-public:
-  typedef SampleTimeData::iterator iterator;
-  typedef SampleTimeData::const_iterator const_iterator;
-
-  iterator begin(void)
-  { return mSampleTimes.begin(); }
-  iterator end(void)
-  { return mSampleTimes.end(); }
-
-  const_iterator begin(void) const
-  { return mSampleTimes.begin(); }
-  const_iterator end(void) const
-  { return mSampleTimes.end(); }
-
-  bool empty(void) const
-  { return mSampleTimes.empty(); }
-
-  bool addSampleTime(const SampleTime& sampleTime)
-  {
-    OpenFDMAssert(sampleTime.isValid());
-    if (!sampleTime.isValid())
-      return false;
-    SampleTimeData::iterator it;
-    for (it = mSampleTimes.begin(); it != mSampleTimes.end(); ++it) {
-      // If the sample time is already included don't include twice
-      if (it->getSampleTime() == sampleTime.getSampleTime())
-        return true;
-      // If we found a sample time bigger than the new one, insert the
-      // new one before it
-      if (sampleTime.getSampleTime() < it->getSampleTime())
-        break;
-    }
-    // insert before it
-    mSampleTimes.insert(it, sampleTime);
-    return true;
-  }
-  bool removeSampleTime(const SampleTime& sampleTime)
-  {
-    OpenFDMAssert(sampleTime.isValid());
-    if (!sampleTime.isValid())
-      return false;
-    SampleTimeData::iterator it;
-    for (it = mSampleTimes.begin(); it != mSampleTimes.end(); ++it) {
-      // If the sample time is already included don't include twice
-      if (it->getSampleTime() == sampleTime.getSampleTime()) {
-        mSampleTimes.erase(it);
-        return true;
-      }
-    }
-    return false;
-  }
-
-  void clear(void)
-  { mSampleTimes.resize(0); }
-
-private:
-  /// Contains an ascending sorted vector of sample times belonging
-  /// to the current set
-  // FIXME May be std::set is a good alternative?
-  SampleTimeData mSampleTimes;
-};
-
-template<typename char_type, typename traits_type> 
-inline
-std::basic_ostream<char_type, traits_type>&
-operator<<(std::basic_ostream<char_type, traits_type>& stream,
-           const SampleTimeSet& sts)
-{
-  stream << "{ ";
-  SampleTimeSet::const_iterator it;
-  for (it = sts.begin(); it != sts.end(); ++it)
-    stream << it->getSampleTime() << " ";
-  stream << "}";
-  return stream;
-}
-
-inline
-bool
-nonZeroIntersection(const SampleTimeSet& set1, const SampleTime& sampleTime)
-{
-  SampleTimeSet::const_iterator it;
-  for (it = set1.begin(); it != set1.end(); ++it) {
-    if (*it == sampleTime)
-      return true;
-  }
-  return false;
-}
-
-inline
-bool
-nonZeroIntersection(const SampleTime& sampleTime, const SampleTimeSet& set1)
-{
-  return nonZeroIntersection(set1, sampleTime);
-}
-
-inline
-bool
-nonZeroIntersection(const SampleTimeSet& set1, const SampleTimeSet& set2)
-{
-  SampleTimeSet::const_iterator it1 = set1.begin();
-  SampleTimeSet::const_iterator it2 = set2.begin();
-  while (it1 != set1.end() && it2 != set2.end()) {
-    if (it1->getSampleTime() == it2->getSampleTime())
-      return true;
-    if (it1->getSampleTime() < it2->getSampleTime())
-      ++it1;
-    else
-      ++it2;
-  }
-  return false;
-}
-
-class TaskInfo {
-public:
-  TaskInfo(void) :
-    mSliceSize(0),
-    mTime(0),
-    mNumBasicSteps(0)
-  {}
-
-  void setTime(real_type t)
-  { mTime = t; }
-  real_type getTime(void) const
-  { return mTime; }
-  
-  void addSampleTime(const SampleTime& sampleTime)
-  { mSampleTimeSet.addSampleTime(sampleTime); }
-
-  void clear(void)
-  { mSampleTimeSet.clear(); }
-
-  const SampleTimeSet& getSampleTimeSet(void) const
-  { return mSampleTimeSet; }
-
-  real_type getSliceSize(void) const
-  { return mSliceSize; }
-  void setSliceSize(real_type sliceSize)
-  { mSliceSize = sliceSize; }
-
-  unsigned getNumBasicSteps(void) const
-  { return mNumBasicSteps; }
-  void setNumBasicSteps(unsigned numBasicSteps)
-  { mNumBasicSteps = numBasicSteps; }
-
-private:
-  SampleTimeSet mSampleTimeSet;
-  real_type mSliceSize;
-  real_type mTime;
-  unsigned mNumBasicSteps;
-};
-
 class Model
   : public Object {
 public:

Added: trunk/OpenFDM/src/OpenFDM/SampleTime.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/SampleTime.h	2005-11-17 19:08:25 UTC (rev 64)
+++ trunk/OpenFDM/src/OpenFDM/SampleTime.h	2005-11-17 19:44:38 UTC (rev 65)
@@ -0,0 +1,177 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_SampleTime_H
+#define OpenFDM_SampleTime_H
+
+#include <iosfwd>
+#include <vector>
+
+#include "Assert.h"
+
+namespace OpenFDM {
+
+/// The discrete sample time for this model
+/// There are special meanings encoded into that value:
+/// - positive real number, this is the discrete sample time itself
+/// - zero, continous updates
+/// - otherwise, inherited from its parent model group
+class SampleTime {
+public:
+  /// Default constructor, defaults to discrete sample time
+  SampleTime(void) : mSampleTime(0) {}
+  /// Constructor with given sample time
+  SampleTime(real_type sampleTime) : mSampleTime(sampleTime) {}
+  /// Returns true if the sample time is a continous sample time
+  bool isContinous(void) const
+  { return mSampleTime == 0; }
+  /// Returns true if the sample time is discrete
+  bool isDiscrete(void) const
+  { return 0 < mSampleTime; }
+  /// Returns true if the sample time is just inheritted
+  /// FIXME: empty sample time list??
+  bool isInherited(void) const
+  { return mSampleTime == -1; }
+  /// Returns true if the task is a per timestep task
+  bool isPerTimestep(void) const
+  { return mSampleTime == -2; }
+  /// Returns the actual sample time
+  real_type getSampleTime(void) const
+  { return mSampleTime; }
+
+  /// Returns true if th sample time is valid
+  bool isValid(void) const
+  { return isContinous() || isDiscrete() || isInherited() || isPerTimestep(); }
+
+  bool operator==(const SampleTime& st) const
+  { return mSampleTime == st.mSampleTime; }
+  bool operator!=(const SampleTime& st) const
+  { return mSampleTime != st.mSampleTime; }
+
+  static const SampleTime PerTimestep;
+  static const SampleTime Inherited;
+  static const SampleTime Continous;
+
+private:
+  real_type mSampleTime;
+};
+
+class SampleTimeSet {
+  typedef std::vector<SampleTime> SampleTimeData;
+
+public:
+  typedef SampleTimeData::iterator iterator;
+  typedef SampleTimeData::const_iterator const_iterator;
+
+  iterator begin(void)
+  { return mSampleTimes.begin(); }
+  iterator end(void)
+  { return mSampleTimes.end(); }
+
+  const_iterator begin(void) const
+  { return mSampleTimes.begin(); }
+  const_iterator end(void) const
+  { return mSampleTimes.end(); }
+
+  bool empty(void) const
+  { return mSampleTimes.empty(); }
+
+  bool addSampleTime(const SampleTime& sampleTime)
+  {
+    OpenFDMAssert(sampleTime.isValid());
+    if (!sampleTime.isValid())
+      return false;
+    SampleTimeData::iterator it;
+    for (it = mSampleTimes.begin(); it != mSampleTimes.end(); ++it) {
+      // If the sample time is already included don't include twice
+      if (it->getSampleTime() == sampleTime.getSampleTime())
+        return true;
+      // If we found a sample time bigger than the new one, insert the
+      // new one before it
+      if (sampleTime.getSampleTime() < it->getSampleTime())
+        break;
+    }
+    // insert before it
+    mSampleTimes.insert(it, sampleTime);
+    return true;
+  }
+  bool removeSampleTime(const SampleTime& sampleTime)
+  {
+    OpenFDMAssert(sampleTime.isValid());
+    if (!sampleTime.isValid())
+      return false;
+    SampleTimeData::iterator it;
+    for (it = mSampleTimes.begin(); it != mSampleTimes.end(); ++it) {
+      // If the sample time is already included don't include twice
+      if (it->getSampleTime() == sampleTime.getSampleTime()) {
+        mSampleTimes.erase(it);
+        return true;
+      }
+    }
+    return false;
+  }
+
+  void clear(void)
+  { mSampleTimes.resize(0); }
+
+private:
+  /// Contains an ascending sorted vector of sample times belonging
+  /// to the current set
+  // FIXME May be std::set is a good alternative?
+  SampleTimeData mSampleTimes;
+};
+
+template<typename char_type, typename traits_type> 
+inline
+std::basic_ostream<char_type, traits_type>&
+operator<<(std::basic_ostream<char_type, traits_type>& stream,
+           const SampleTimeSet& sts)
+{
+  stream << "{ ";
+  SampleTimeSet::const_iterator it;
+  for (it = sts.begin(); it != sts.end(); ++it)
+    stream << it->getSampleTime() << " ";
+  stream << "}";
+  return stream;
+}
+
+inline
+bool
+nonZeroIntersection(const SampleTimeSet& set1, const SampleTime& sampleTime)
+{
+  SampleTimeSet::const_iterator it;
+  for (it = set1.begin(); it != set1.end(); ++it) {
+    if (*it == sampleTime)
+      return true;
+  }
+  return false;
+}
+
+inline
+bool
+nonZeroIntersection(const SampleTime& sampleTime, const SampleTimeSet& set1)
+{
+  return nonZeroIntersection(set1, sampleTime);
+}
+
+inline
+bool
+nonZeroIntersection(const SampleTimeSet& set1, const SampleTimeSet& set2)
+{
+  SampleTimeSet::const_iterator it1 = set1.begin();
+  SampleTimeSet::const_iterator it2 = set2.begin();
+  while (it1 != set1.end() && it2 != set2.end()) {
+    if (it1->getSampleTime() == it2->getSampleTime())
+      return true;
+    if (it1->getSampleTime() < it2->getSampleTime())
+      ++it1;
+    else
+      ++it2;
+  }
+  return false;
+}
+
+} // namespace OpenFDM
+
+#endif


Property changes on: trunk/OpenFDM/src/OpenFDM/SampleTime.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/OpenFDM/src/OpenFDM/TaskInfo.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/TaskInfo.h	2005-11-17 19:08:25 UTC (rev 64)
+++ trunk/OpenFDM/src/OpenFDM/TaskInfo.h	2005-11-17 19:44:38 UTC (rev 65)
@@ -0,0 +1,54 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_TaskInfo_H
+#define OpenFDM_TaskInfo_H
+
+#include "Assert.h"
+#include "SampleTime.h"
+
+namespace OpenFDM {
+
+class TaskInfo {
+public:
+  TaskInfo(void) :
+    mSliceSize(0),
+    mTime(0),
+    mNumBasicSteps(0)
+  {}
+
+  void setTime(real_type t)
+  { mTime = t; }
+  real_type getTime(void) const
+  { return mTime; }
+  
+  void addSampleTime(const SampleTime& sampleTime)
+  { mSampleTimeSet.addSampleTime(sampleTime); }
+
+  void clear(void)
+  { mSampleTimeSet.clear(); }
+
+  const SampleTimeSet& getSampleTimeSet(void) const
+  { return mSampleTimeSet; }
+
+  real_type getSliceSize(void) const
+  { return mSliceSize; }
+  void setSliceSize(real_type sliceSize)
+  { mSliceSize = sliceSize; }
+
+  unsigned getNumBasicSteps(void) const
+  { return mNumBasicSteps; }
+  void setNumBasicSteps(unsigned numBasicSteps)
+  { mNumBasicSteps = numBasicSteps; }
+
+private:
+  SampleTimeSet mSampleTimeSet;
+  real_type mSliceSize;
+  real_type mTime;
+  unsigned mNumBasicSteps;
+};
+
+} // namespace OpenFDM
+
+#endif


Property changes on: trunk/OpenFDM/src/OpenFDM/TaskInfo.h
___________________________________________________________________
Name: svn:eol-style
   + native



From frohlich at berlios.de  Sat Nov 19 09:09:15 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Sat, 19 Nov 2005 09:09:15 +0100
Subject: [OpenFDM-svn] r67 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200511190809.jAJ89FRD004476@sheep.berlios.de>

Author: frohlich
Date: 2005-11-19 09:09:11 +0100 (Sat, 19 Nov 2005)
New Revision: 67

Modified:
   trunk/OpenFDM/src/OpenFDM/Variant.h
Log:
Fix typo.


Modified: trunk/OpenFDM/src/OpenFDM/Variant.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Variant.h	2005-11-18 18:12:21 UTC (rev 66)
+++ trunk/OpenFDM/src/OpenFDM/Variant.h	2005-11-19 08:09:11 UTC (rev 67)
@@ -108,8 +108,8 @@
     virtual const IntegerVariantData* toIntegerVariant(void) const
     { return this; }
   };
-  struct UnsignedVariantData : VariantDataImpl<int> {
-    UnsignedVariantData(const int& data) { mData = data; }
+  struct UnsignedVariantData : VariantDataImpl<unsigned> {
+    UnsignedVariantData(const unsigned& data) { mData = data; }
     virtual const UnsignedVariantData* toUnsignedVariant(void) const
     { return this; }
   };



From frohlich at berlios.de  Sun Nov 20 20:37:15 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Sun, 20 Nov 2005 20:37:15 +0100
Subject: [OpenFDM-svn] r68 - in trunk/OpenFDM/src/OpenFDM: . LinAlg
Message-ID: <200511201937.jAKJbFGC024361@sheep.berlios.de>

Author: frohlich
Date: 2005-11-20 20:37:02 +0100 (Sun, 20 Nov 2005)
New Revision: 68

Modified:
   trunk/OpenFDM/src/OpenFDM/DiscreteIntegrator.cpp
   trunk/OpenFDM/src/OpenFDM/LinAlg/Expressions.h
   trunk/OpenFDM/src/OpenFDM/Saturation.cpp
Log:
Implement min/max for matrices.


Modified: trunk/OpenFDM/src/OpenFDM/DiscreteIntegrator.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/DiscreteIntegrator.cpp	2005-11-19 08:09:11 UTC (rev 67)
+++ trunk/OpenFDM/src/OpenFDM/DiscreteIntegrator.cpp	2005-11-20 19:37:02 UTC (rev 68)
@@ -74,18 +74,10 @@
 
   // Hmm, should that be done on state setting too???
   if (size(mMaxSaturation) == size(mInitialValue)) {
-    for (unsigned j = 1; j <= cols(mIntegralState); ++j) {
-      for (unsigned i = 1; i <= rows(mIntegralState); ++i) {
-        mIntegralState(i, j) = min(mIntegralState(i, j), mMaxSaturation(i, j));
-      }
-    }
+    mIntegralState = LinAlg::min(mIntegralState, mMaxSaturation);
   }
   if (size(mMinSaturation) == size(mInitialValue)) {
-    for (unsigned j = 1; j <= cols(mIntegralState); ++j) {
-      for (unsigned i = 1; i <= rows(mIntegralState); ++i) {
-        mIntegralState(i, j) = max(mIntegralState(i, j), mMinSaturation(i, j));
-      }
-    }
+    mIntegralState = LinAlg::max(mIntegralState, mMinSaturation);
   }
 }
 

Modified: trunk/OpenFDM/src/OpenFDM/LinAlg/Expressions.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/LinAlg/Expressions.h	2005-11-19 08:09:11 UTC (rev 67)
+++ trunk/OpenFDM/src/OpenFDM/LinAlg/Expressions.h	2005-11-20 19:37:02 UTC (rev 68)
@@ -9,6 +9,14 @@
 
 namespace LinAlg {
 
+OpenFDM_FORCE_INLINE
+real_type min(real_type a, real_type b)
+{ return a < b ? a : b; }
+
+OpenFDM_FORCE_INLINE
+real_type max(real_type a, real_type b)
+{ return a < b ? b : a; }
+
 #ifdef USE_EXPRESSIONS
 
 template<typename Impl, size_type m, size_type n>
@@ -692,6 +700,54 @@
   return ret;
 }
 
+template<typename Impl1, size_type m1, size_type n1,
+         typename Impl2, size_type m2, size_type n2>
+OpenFDM_FORCE_INLINE
+Matrix<typename Impl1::value_type,m1,n1>
+max(const MatrixRValue<Impl1,m1,n1>& A1,
+    const MatrixRValue<Impl2,m2,n2>& A2)
+{
+  const Impl1& A1i = A1.asImpl();
+  const Impl2& A2i = A2.asImpl();
+
+  size_type rows = A1i.rows();
+  size_type cols = A1i.cols();
+  SizeCheck<m1,m2>::Equal(rows, A2i.rows());
+  SizeCheck<n1,n2>::Equal(cols, A2i.cols());
+
+  Matrix<typename Impl1::value_type,m1,n1> ret(rows, cols);
+  size_type i, j;
+  for (j = 1; j <= cols; ++j)
+    for (i = 1; i <= rows; ++i)
+      ret(i, j) = max(A1i(i, j), A2i(i, j));
+
+  return ret;
+}
+
+template<typename Impl1, size_type m1, size_type n1,
+         typename Impl2, size_type m2, size_type n2>
+OpenFDM_FORCE_INLINE
+Matrix<typename Impl1::value_type,m1,n1>
+min(const MatrixRValue<Impl1,m1,n1>& A1,
+    const MatrixRValue<Impl2,m2,n2>& A2)
+{
+  const Impl1& A1i = A1.asImpl();
+  const Impl2& A2i = A2.asImpl();
+
+  size_type rows = A1i.rows();
+  size_type cols = A1i.cols();
+  SizeCheck<m1,m2>::Equal(rows, A2i.rows());
+  SizeCheck<n1,n2>::Equal(cols, A2i.cols());
+
+  Matrix<typename Impl1::value_type,m1,n1> ret(rows, cols);
+  size_type i, j;
+  for (j = 1; j <= cols; ++j)
+    for (i = 1; i <= rows; ++i)
+      ret(i, j) = min(A1i(i, j), A2i(i, j));
+
+  return ret;
+}
+
 #endif
 
 } // namespace LinAlg

Modified: trunk/OpenFDM/src/OpenFDM/Saturation.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Saturation.cpp	2005-11-19 08:09:11 UTC (rev 67)
+++ trunk/OpenFDM/src/OpenFDM/Saturation.cpp	2005-11-20 19:37:02 UTC (rev 68)
@@ -60,14 +60,10 @@
   unsigned r = rows(mOutput);
   unsigned c = cols(mOutput);
   if (0 < rows(mMaxSaturation) && 0 < cols(mMaxSaturation)) {
-    for (unsigned i = 1; i <= r; ++i)
-      for (unsigned j = 1; j <= c; ++j)
-        mOutput(i, j) = min(mOutput(i, j), mMaxSaturation(i, j));
+    mOutput = LinAlg::min(mOutput, mMaxSaturation);
   }
   if (0 < rows(mMinSaturation) && 0 < cols(mMinSaturation)) {
-    for (unsigned i = 1; i <= r; ++i)
-      for (unsigned j = 1; j <= c; ++j)
-        mOutput(i, j) = max(mOutput(i, j), mMinSaturation(i, j));
+    mOutput = LinAlg::max(mOutput, mMinSaturation);
   }
 }
 



From frohlich at berlios.de  Sat Nov 26 12:59:39 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Sat, 26 Nov 2005 12:59:39 +0100
Subject: [OpenFDM-svn] r70 - trunk/flightgear
Message-ID: <200511261159.jAQBxdl3012714@sheep.berlios.de>

Author: frohlich
Date: 2005-11-26 12:59:34 +0100 (Sat, 26 Nov 2005)
New Revision: 70

Modified:
   trunk/flightgear/FGPropertyAdapter.h
Log:
Make it work with the past chenges ...


Modified: trunk/flightgear/FGPropertyAdapter.h
===================================================================
--- trunk/flightgear/FGPropertyAdapter.h	2005-11-26 11:58:10 UTC (rev 69)
+++ trunk/flightgear/FGPropertyAdapter.h	2005-11-26 11:59:34 UTC (rev 70)
@@ -186,15 +186,15 @@
 
   virtual bool init(void)
   {
-    OpenFDMAssert(getInputPort(0).isValid());
-    return getInputPort(0).isValid();
+    OpenFDMAssert(getInputPort(0)->isConnected());
+    return getInputPort(0)->isConnected();
   }
 
   virtual void output(void)
   {
-    OpenFDMAssert(getInputPort(0).isValid());
+    OpenFDMAssert(getInputPort(0)->isConnected());
     if (mPropertyNode.valid())
-      mPropertyNode->setDoubleValue(getInputPort(0).getValue().toReal());
+      mPropertyNode->setDoubleValue(getInputPort(0)->getValue().toReal());
   }
 
 private:



From frohlich at berlios.de  Sat Nov 26 13:11:17 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Sat, 26 Nov 2005 13:11:17 +0100
Subject: [OpenFDM-svn] r71 - in trunk/OpenFDM/src: JSBSim OpenFDM
Message-ID: <200511261211.jAQCBHif017327@sheep.berlios.de>

Author: frohlich
Date: 2005-11-26 13:11:09 +0100 (Sat, 26 Nov 2005)
New Revision: 71

Modified:
   trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
   trunk/OpenFDM/src/OpenFDM/Model.cpp
   trunk/OpenFDM/src/OpenFDM/Model.h
   trunk/OpenFDM/src/OpenFDM/main.cpp
Log:
Obsolete getOutputProperty.


Modified: trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
===================================================================
--- trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2005-11-26 11:59:34 UTC (rev 70)
+++ trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2005-11-26 12:11:09 UTC (rev 71)
@@ -452,7 +452,7 @@
   input->setInputName(propName);
   input->setInputGain(gain);
   addFCSModel(input);
-  Property prop = input->getOutputProperty(0);
+  Property prop = input->getOutputPort(0)->getProperty();
   registerExpression(propName, prop);
   return prop;
 }
@@ -476,7 +476,7 @@
   gain->setInputPort(0, in);
   gain->setGain(-1);
   addFCSModel(gain);
-  return gain->getOutputProperty(0);
+  return gain->getOutputPort(0)->getProperty();
 }
 
 Property
@@ -486,7 +486,7 @@
     = new UnaryFunctionModel(name + " Abs", new AbsExpressionImpl);
   unary->setInputPort(0, in);
   addFCSModel(unary);
-  return unary->getOutputProperty(0);
+  return unary->getOutputPort(0)->getProperty();
 }
 
 void
@@ -693,7 +693,7 @@
   epFrame->setRelAccel(Vector6::zeros());
   Sensor* accelSensor = new Sensor("Acceleration Sensor");
   accelSensor->addSampleTime(SampleTime(1.0/120));
-  Property prop = accelSensor->getOutputProperty("nz");
+  Property prop = accelSensor->getOutputPort("nz")->getProperty();
   registerJSBExpression("accelerations/n-pilot-z-norm", prop);
 //   epFrame->addMultiBodyModel(accelSensor);
   mVehicle->getTopBody()->addMultiBodyModel(accelSensor);
@@ -747,7 +747,7 @@
   wc->setFrictionCoeficient(0.9);
   wheel->addMultiBodyModel(wc);
   
-  Property prop = wj->getOutputProperty(0);
+  Property prop = wj->getOutputPort(0)->getProperty();
   addOutputModel(prop, "Wheel " + numStr + " Position",
                  "gear/gear[" + numStr + "]/wheel-position-rad");
   SiToUnitExpressionImpl* c = new SiToUnitExpressionImpl(uDegree);
@@ -836,10 +836,10 @@
           UnaryFunctionModel *unary
             = new UnaryFunctionModel(name + " Degree Conversion",
                                      new UnitToSiExpressionImpl(uDegree));
-          unary->setInputPort(0, gain->getOutputProperty(0));
+          unary->setInputPort(0, gain->getOutputPort(0)->getProperty());
           addFCSModel(unary);
 
-          sg->setInputPort("steeringAngle", unary->getOutputProperty(0));
+          sg->setInputPort("steeringAngle", unary->getOutputPort(0)->getProperty());
         }
         
         if (brake == "LEFT") {
@@ -926,7 +926,7 @@
       attachWheel(name, Vector3(-armLength, 0, 0), brake, numStr, wheelDiam,
                   tireSpring, tireDamp, arm);
 
-      Property prop = rj->getOutputProperty(0);
+      Property prop = rj->getOutputPort(0)->getProperty();
       addOutputModel(prop, "Gear " + numStr + " Compression",
                      "/gear/gear[" + numStr + "]/compression-rad");
 
@@ -997,7 +997,7 @@
         strutParent = steer;
         
         // Prepare outputs
-        prop = sj->getOutputProperty(0);
+        prop = sj->getOutputPort(0)->getProperty();
         addOutputModel(prop, "Steering " + numStr + " Position",
                        "/gear/gear[" + numStr + "]/steering-pos-rad");
         SiToUnitExpressionImpl* c = new SiToUnitExpressionImpl(uDegree);
@@ -1038,7 +1038,7 @@
                   tireSpring, tireDamp, arm);
 
       // Prepare some outputs ...
-      Property prop = pj->getOutputProperty(0);
+      Property prop = pj->getOutputPort(0)->getProperty();
       addOutputModel(prop, "Gear " + numStr + " Compression",
                      "/gear/gear[" + numStr + "]/compression-m");
 
@@ -1130,18 +1130,18 @@
     summer->setNumSummands(0);
     model = summer;
     addFCSModel(model);
-    out = model->getOutputProperty(0);
+    out = model->getOutputPort(0)->getProperty();
 
   } else if (type == "DEADBAND") {
     deadband = new DeadBand(name);
     model = deadband;
     addFCSModel(model);
-    out = model->getOutputProperty(0);
+    out = model->getOutputPort(0)->getProperty();
 
   } else if (type == "GRADIENT") {
     model = new TimeDerivative(name);
     addFCSModel(model);
-    out = model->getOutputProperty(0);
+    out = model->getOutputPort(0)->getProperty();
 
   } else if (type == "SWITCH") {
     std::cout << "Ignoring SWITCH" << std::endl;
@@ -1158,44 +1158,44 @@
 
     inputSaturation = new Saturation(name + " Input Saturation");
     addFCSModel(inputSaturation);
-    inputSaturation->setInputPort(0, gain->getOutputProperty(0));
+    inputSaturation->setInputPort(0, gain->getOutputPort(0)->getProperty());
 
     Summer* inputError = new Summer(name + " Input Sum");
     addFCSModel(inputError);
-    inputError->setInputPort(0, inputSaturation->getOutputProperty(0));
+    inputError->setInputPort(0, inputSaturation->getOutputPort(0)->getProperty());
     inputError->setNumSummands(2);
 
     Gain* errorGain = new Gain(name + " Error Gain");
     addFCSModel(errorGain);
     errorGain->setGain(100);
-    errorGain->setInputPort(0, inputError->getOutputProperty(0));
+    errorGain->setInputPort(0, inputError->getOutputPort(0)->getProperty());
 
     kinematRateLimit = new Saturation(name + " Rate Limit");
     addFCSModel(kinematRateLimit);
-    kinematRateLimit->setInputPort(0, errorGain->getOutputProperty(0));
+    kinematRateLimit->setInputPort(0, errorGain->getOutputPort(0)->getProperty());
 
     DiscreteIntegrator* integrator
       = new DiscreteIntegrator(name + " Integrator");
     addFCSModel(integrator);
-    integrator->setInputPort(0, kinematRateLimit->getOutputProperty(0));
+    integrator->setInputPort(0, kinematRateLimit->getOutputPort(0)->getProperty());
     Matrix tmp(1, 1);
     tmp(1, 1) = 1;
 //     tmp.clear();
     integrator->setInitialValue(tmp);
-    out = integrator->getOutputProperty(0);
+    out = integrator->getOutputPort(0)->getProperty();
 
     Gain* feedbackGain = new Gain(name + " Feedback Gain");
     addFCSModel(feedbackGain);
     feedbackGain->setGain(-1);
-    feedbackGain->setInputPort(0, integrator->getOutputProperty(0));
-    inputError->setInputPort(1, feedbackGain->getOutputProperty(0));
+    feedbackGain->setInputPort(0, integrator->getOutputPort(0)->getProperty());
+    inputError->setInputPort(1, feedbackGain->getOutputPort(0)->getProperty());
 
   } else if (type == "PURE_GAIN") {
     gain = new Gain(name);
     gain->setGain(1);
     model = gain;
     addFCSModel(model);
-    out = model->getOutputProperty(0);
+    out = model->getOutputPort(0)->getProperty();
 
   } else if (type == "AEROSURFACE_SCALE") {
     // An AEROSURFACE_SCALE component is done with n input saturation clipping
@@ -1206,7 +1206,7 @@
     inputSaturation = new Saturation(name + "Input Saturation");
     model = inputSaturation;
     addFCSModel(inputSaturation);
-    normOut = inputSaturation->getOutputProperty(0);
+    normOut = inputSaturation->getOutputPort(0)->getProperty();
     Matrix tmp(1, 1);
     tmp(1, 1) = -1;
     inputSaturation->setMinSaturation(tmp);
@@ -1230,24 +1230,24 @@
     iv(1) = 3;
     tableData(iv) = 1;
     table1D->setTableData(tableData);
-    table1D->setInputPort(0, inputSaturation->getOutputProperty(0));
+    table1D->setInputPort(0, inputSaturation->getOutputPort(0)->getProperty());
 
     addFCSModel(table1D);
-    out = table1D->getOutputProperty(0);
+    out = table1D->getOutputPort(0)->getProperty();
 
   } else if (type == "SCHEDULED_GAIN") {
     Product* prod = new Product(name);
     prod->setNumFactors(2);
     table1D = new Table1D(std::string("Lookup table for ") + name);
     addFCSModel(table1D);
-    prod->setInputPort(1, table1D->getOutputProperty(0));
+    prod->setInputPort(1, table1D->getOutputPort(0)->getProperty());
     model = prod;
     addFCSModel(model);
-    out = model->getOutputProperty(0);
+    out = model->getOutputPort(0)->getProperty();
 
   } else if (type == "INTEGRATOR") {
     model = new DiscreteIntegrator(name);
-    out = model->getOutputProperty(0);
+    out = model->getOutputPort(0)->getProperty();
     addFCSModel(model);
 
   } else if (type == "LAG_FILTER") {
@@ -1262,7 +1262,7 @@
     discreteTransfFunc->setDenominator(v);
     model = discreteTransfFunc;
     addFCSModel(model);
-    out = model->getOutputProperty(0);
+    out = model->getOutputPort(0)->getProperty();
 
   } else if (type == "LEAD_LAG_FILTER") {
     // C1*s + C2
@@ -1273,7 +1273,7 @@
     discreteTransfFunc->setDenominator(Vector(2));
     model = discreteTransfFunc;
     addFCSModel(model);
-    out = model->getOutputProperty(0);
+    out = model->getOutputPort(0)->getProperty();
 
   } else if (type == "WASHOUT_FILTER") {
     //   s
@@ -1287,7 +1287,7 @@
     discreteTransfFunc->setDenominator(v);
     model = discreteTransfFunc;
     addFCSModel(model);
-    out = model->getOutputProperty(0);
+    out = model->getOutputPort(0)->getProperty();
 
   } else if (type == "SECOND_ORDER_FILTER") {
     // C1*s + C2*s + C3
@@ -1298,7 +1298,7 @@
     discreteTransfFunc->setDenominator(Vector(3));
     model = discreteTransfFunc;
     addFCSModel(model);
-    out = model->getOutputProperty(0);
+    out = model->getOutputPort(0)->getProperty();
 
   } else
     return error("Unknown FCS COMPONENT type: \"" + type
@@ -1672,15 +1672,15 @@
   // Doing that now will put them together in a well defined order.
   if (outbias) {
     outbias->setInputPort(0, out);
-    out = outbias->getOutputProperty(0);
+    out = outbias->getOutputPort(0)->getProperty();
   }
   if (outgain) {
     outgain->setInputPort(0, out);
-    out = outgain->getOutputProperty(0);
+    out = outgain->getOutputPort(0)->getProperty();
   }
   if (saturation) {
     saturation->setInputPort(0, out);
-    out = saturation->getOutputProperty(0);
+    out = saturation->getOutputPort(0)->getProperty();
   }
   if (outInvert) {
     out = addInverterModel(name, out);
@@ -1698,7 +1698,7 @@
       normGain->setGain(1/gain->getGain());
       addFCSModel(normGain);
       normGain->setInputPort(0, out);
-      normOut = normGain->getOutputProperty(0);
+      normOut = normGain->getOutputPort(0)->getProperty();
     }
   }
 

Modified: trunk/OpenFDM/src/OpenFDM/Model.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Model.cpp	2005-11-26 11:59:34 UTC (rev 70)
+++ trunk/OpenFDM/src/OpenFDM/Model.cpp	2005-11-26 12:11:09 UTC (rev 71)
@@ -230,18 +230,6 @@
   return 0;
 }
 
-Property
-Model::getOutputProperty(unsigned i) const
-{
-  if (mOutputPorts.size() <= i) {
-    Log(Model, Error) << "Output port index " << i << "out of range in \""
-                      << getName() << "\"" << endl;
-    return Property();
-  }
-
-  return mOutputPorts[i]->getProperty();
-}
-
 const std::string&
 Model::getOutputPortName(unsigned i) const
 {
@@ -249,22 +237,6 @@
   return mOutputPorts[i]->getName();
 }
 
-Property
-Model::getOutputProperty(const std::string& name) const
-{
-  // Check if this one exists and return its value.
-  std::vector<shared_ptr<Port> >::const_iterator it = mOutputPorts.begin();
-  while (it != mOutputPorts.end()) {
-    if ((*it)->getName() == name)
-      return (*it)->getProperty();
-    ++it;
-  }
-
-  Log(Model, Error) << "Output port name " << name << "not found in \""
-                    << getName() << "\"" << endl;
-  return Property();
-}
-
 bool
 Model::dependsDirectOn(const Model* const model) const
 {

Modified: trunk/OpenFDM/src/OpenFDM/Model.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Model.h	2005-11-26 11:59:34 UTC (rev 70)
+++ trunk/OpenFDM/src/OpenFDM/Model.h	2005-11-26 12:11:09 UTC (rev 71)
@@ -217,9 +217,6 @@
   Port* getOutputPort(const std::string& name);
   const std::string& getOutputPortName(unsigned i) const;
 
-  Property getOutputProperty(unsigned i) const; /* OBSOLETE */
-  Property getOutputProperty(const std::string& name) const; /* OBSOLETE */
-
   bool dependsDirectOn(const Model* const model) const;
 
 protected:

Modified: trunk/OpenFDM/src/OpenFDM/main.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/main.cpp	2005-11-26 11:59:34 UTC (rev 70)
+++ trunk/OpenFDM/src/OpenFDM/main.cpp	2005-11-26 12:11:09 UTC (rev 71)
@@ -632,7 +632,7 @@
     system->simulate(j*0.01);
 
     for (unsigned i = 0; i < modelGroup->getNumModels(); ++i)
-      cout << modelGroup->getModel(i)->getOutputProperty("output").getValue().toMatrix() << " ";
+      cout << modelGroup->getModel(i)->getOutputPort("output")->getValue().toMatrix() << " ";
 
     cout << endl;
   }



From frohlich at berlios.de  Sat Nov 26 16:22:53 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Sat, 26 Nov 2005 16:22:53 +0100
Subject: [OpenFDM-svn] r72 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200511261522.jAQFMr1a015841@sheep.berlios.de>

Author: frohlich
Date: 2005-11-26 16:22:35 +0100 (Sat, 26 Nov 2005)
New Revision: 72

Modified:
   trunk/OpenFDM/src/OpenFDM/BinaryFunctionModel.cpp
   trunk/OpenFDM/src/OpenFDM/BinaryFunctionModel.h
   trunk/OpenFDM/src/OpenFDM/Model.cpp
   trunk/OpenFDM/src/OpenFDM/Model.h
   trunk/OpenFDM/src/OpenFDM/UnaryFunctionModel.cpp
   trunk/OpenFDM/src/OpenFDM/UnaryFunctionModel.h
Log:
Remove inputPortChanged notifier callback.


Modified: trunk/OpenFDM/src/OpenFDM/BinaryFunctionModel.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/BinaryFunctionModel.cpp	2005-11-26 12:11:09 UTC (rev 71)
+++ trunk/OpenFDM/src/OpenFDM/BinaryFunctionModel.cpp	2005-11-26 15:22:35 UTC (rev 72)
@@ -31,6 +31,9 @@
 bool
 BinaryFunctionModel::init(void)
 {
+  OpenFDMAssert(mBinaryExpression);
+  mBinaryExpression->setInputProperty(0, getInputPort(0)->getProperty());
+  mBinaryExpression->setInputProperty(1, getInputPort(1)->getProperty());
   OpenFDMAssert(mBinaryExpression->isValid());
   return mBinaryExpression->isValid();
 }
@@ -48,12 +51,4 @@
   return mFunctionValue;
 }
 
-void
-BinaryFunctionModel::inputPortChanged(unsigned i)
-{
-  if (getNumInputPorts() <= i)
-    return;
-  mBinaryExpression->setInputProperty(i, getInputPort(i)->getProperty());
-}
-
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/BinaryFunctionModel.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/BinaryFunctionModel.h	2005-11-26 12:11:09 UTC (rev 71)
+++ trunk/OpenFDM/src/OpenFDM/BinaryFunctionModel.h	2005-11-26 15:22:35 UTC (rev 72)
@@ -29,8 +29,6 @@
   const real_type& getFunctionValue(void) const;
 
 private:
-  virtual void inputPortChanged(unsigned i);
-
   shared_ptr<BinaryExpressionImpl<real_type> > mBinaryExpression;
 
   real_type mFunctionValue;

Modified: trunk/OpenFDM/src/OpenFDM/Model.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Model.cpp	2005-11-26 12:11:09 UTC (rev 71)
+++ trunk/OpenFDM/src/OpenFDM/Model.cpp	2005-11-26 15:22:35 UTC (rev 72)
@@ -170,7 +170,6 @@
   }
 
   mInputPorts[i]->setProperty(prop);
-  inputPortChanged(i);
   return true;
 }
 
@@ -262,7 +261,6 @@
   mInputPorts.resize(num);
   for (; oldSize < mInputPorts.size(); ++oldSize)
     mInputPorts[oldSize] = new Port;
-  inputPortChanged(num);
 }
 
 void
@@ -270,15 +268,9 @@
 {
   OpenFDMAssert(i < mInputPorts.size());
   mInputPorts[i]->setName(name);
-  inputPortChanged(i);
 }
 
 void
-Model::inputPortChanged(unsigned)
-{
-}
-
-void
 Model::setNumOutputPorts(unsigned num)
 {
   // Ok, strange, but required ...

Modified: trunk/OpenFDM/src/OpenFDM/Model.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Model.h	2005-11-26 12:11:09 UTC (rev 71)
+++ trunk/OpenFDM/src/OpenFDM/Model.h	2005-11-26 15:22:35 UTC (rev 72)
@@ -231,10 +231,6 @@
   /// Sets the name of the i-th input property.
   void setInputPortName(unsigned i, const std::string& name);
 
-  /// Gets called whenever an input property is changed.
-  /// Lets a Model implementation catch up changes to the model.
-  virtual void inputPortChanged(unsigned i);
-
   /// Sets the number of output properties.
   void setNumOutputPorts(unsigned num);
 

Modified: trunk/OpenFDM/src/OpenFDM/UnaryFunctionModel.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/UnaryFunctionModel.cpp	2005-11-26 12:11:09 UTC (rev 71)
+++ trunk/OpenFDM/src/OpenFDM/UnaryFunctionModel.cpp	2005-11-26 15:22:35 UTC (rev 72)
@@ -31,6 +31,8 @@
 bool
 UnaryFunctionModel::init(void)
 {
+  OpenFDMAssert(mUnaryExpression);
+  mUnaryExpression->setInputProperty(getInputPort(0)->getProperty());
   OpenFDMAssert(mUnaryExpression->isValid());
   return mUnaryExpression->isValid();
 }
@@ -48,12 +50,4 @@
   return mFunctionValue;
 }
 
-void
-UnaryFunctionModel::inputPortChanged(unsigned i)
-{
-  if (getNumInputPorts() <= i)
-    return;
-  mUnaryExpression->setInputProperty(getInputPort(0)->getProperty());
-}
-
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/UnaryFunctionModel.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/UnaryFunctionModel.h	2005-11-26 12:11:09 UTC (rev 71)
+++ trunk/OpenFDM/src/OpenFDM/UnaryFunctionModel.h	2005-11-26 15:22:35 UTC (rev 72)
@@ -29,8 +29,6 @@
   const real_type& getFunctionValue(void) const;
 
 private:
-  virtual void inputPortChanged(unsigned i);
-
   shared_ptr<UnaryExpressionImpl<real_type> > mUnaryExpression;
 
   real_type mFunctionValue;



From frohlich at berlios.de  Sun Nov 27 09:20:47 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Sun, 27 Nov 2005 09:20:47 +0100
Subject: [OpenFDM-svn] r74 - trunk/OpenFDM/src/JSBSim
Message-ID: <200511270820.jAR8Kls4012089@sheep.berlios.de>

Author: frohlich
Date: 2005-11-27 09:20:33 +0100 (Sun, 27 Nov 2005)
New Revision: 74

Modified:
   trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
Log:
Add missing std::


Modified: trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
===================================================================
--- trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2005-11-26 15:23:12 UTC (rev 73)
+++ trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2005-11-27 08:20:33 UTC (rev 74)
@@ -164,7 +164,7 @@
   if (jsbSymbol.empty())
     return jsbSymbol;
 
-  string propName = jsbSymbol;
+  std::string propName = jsbSymbol;
 
   // Strip the minus sign
   if (propName[0] == '-')



From frohlich at berlios.de  Sun Nov 27 11:38:19 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Sun, 27 Nov 2005 11:38:19 +0100
Subject: [OpenFDM-svn] r75 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200511271038.jARAcJvD007475@sheep.berlios.de>

Author: frohlich
Date: 2005-11-27 11:38:14 +0100 (Sun, 27 Nov 2005)
New Revision: 75

Modified:
   trunk/OpenFDM/src/OpenFDM/ModelGroup.cpp
Log:
Hmm, empty sample time sets mean inheritted ...


Modified: trunk/OpenFDM/src/OpenFDM/ModelGroup.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/ModelGroup.cpp	2005-11-27 08:20:33 UTC (rev 74)
+++ trunk/OpenFDM/src/OpenFDM/ModelGroup.cpp	2005-11-27 10:38:14 UTC (rev 75)
@@ -197,7 +197,9 @@
 void
 ModelGroup::output(const TaskInfo& taskInfo)
 {
-  if (!nonZeroIntersection(taskInfo.getSampleTimeSet(), getSampleTimeSet()))
+  // FIXME empty means inherited somehow ...
+  if (!getSampleTimeSet().empty() &&
+      !nonZeroIntersection(taskInfo.getSampleTimeSet(), getSampleTimeSet()))
     return;
 
   // Just do output on all children.
@@ -210,7 +212,9 @@
 void
 ModelGroup::update(const TaskInfo& taskInfo)
 {
-  if (!nonZeroIntersection(taskInfo.getSampleTimeSet(), getSampleTimeSet()))
+  // FIXME empty means inherited somehow ...
+  if (!getSampleTimeSet().empty() &&
+      !nonZeroIntersection(taskInfo.getSampleTimeSet(), getSampleTimeSet()))
     return;
 
   // Just update all children.



From frohlich at berlios.de  Sun Nov 27 11:39:03 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Sun, 27 Nov 2005 11:39:03 +0100
Subject: [OpenFDM-svn] r76 - trunk/OpenFDM/src/JSBSim
Message-ID: <200511271039.jARAd3Dv007524@sheep.berlios.de>

Author: frohlich
Date: 2005-11-27 11:38:51 +0100 (Sun, 27 Nov 2005)
New Revision: 76

Added:
   trunk/OpenFDM/src/JSBSim/LegacyKinemat.cpp
   trunk/OpenFDM/src/JSBSim/LegacyKinemat.h
Modified:
   trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
   trunk/OpenFDM/src/JSBSim/Makefile.am
Log:
Factor out some subcomponent.


Modified: trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
===================================================================
--- trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2005-11-27 10:38:14 UTC (rev 75)
+++ trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2005-11-27 10:38:51 UTC (rev 76)
@@ -43,6 +43,8 @@
 #include <OpenFDM/XML/Tablereader.h>
 #include <OpenFDM/XML/XMLReader.h>
 
+#include "LegacyKinemat.h"
+
 #include "LegacyJSBSimReader.h"
 
 namespace OpenFDM {
@@ -1123,7 +1125,7 @@
   shared_ptr<Gain> gain;
   shared_ptr<DiscreteTransferFunction> discreteTransfFunc;
   shared_ptr<Table1D> table1D;
-  shared_ptr<Saturation> kinematRateLimit;
+  shared_ptr<LegacyKinemat> kinemat;
   shared_ptr<Saturation> inputSaturation;
 
   // The final output property.
@@ -1160,49 +1162,13 @@
     std::cout << "Ignoring SWITCH" << std::endl;
 
   } else if (type == "KINEMAT") {
-    // A KINEMAT is done as a first order ODE packed into a discrete system
-    // The derivative is limited to match the avarage movement speed of the
-    // KINEMAT. This is not exactly like JSBSim does that, but it is
-    // sufficient for now.
-    gain = new Gain(name + " Input Gain");
-    addFCSModel(gain);
-    gain->setGain(1);
-    model = gain;
 
-    inputSaturation = new Saturation(name + " Input Saturation");
-    addFCSModel(inputSaturation);
-    inputSaturation->getInputPort(0)->connect(gain->getOutputPort(0));
+    // Use that special proxy class
+    kinemat = new LegacyKinemat(name);
+    model = kinemat;
+    addFCSModel(model);
+    out = kinemat->getOutputPort(0);
 
-    Summer* inputError = new Summer(name + " Input Sum");
-    addFCSModel(inputError);
-    inputError->getInputPort(0)->connect(inputSaturation->getOutputPort(0));
-    inputError->setNumSummands(2);
-
-    Gain* errorGain = new Gain(name + " Error Gain");
-    addFCSModel(errorGain);
-    errorGain->setGain(100);
-    errorGain->getInputPort(0)->connect(inputError->getOutputPort(0));
-
-    kinematRateLimit = new Saturation(name + " Rate Limit");
-    addFCSModel(kinematRateLimit);
-    kinematRateLimit->getInputPort(0)->connect(errorGain->getOutputPort(0));
-
-    DiscreteIntegrator* integrator
-      = new DiscreteIntegrator(name + " Integrator");
-    addFCSModel(integrator);
-    integrator->getInputPort(0)->connect(kinematRateLimit->getOutputPort(0));
-    Matrix tmp(1, 1);
-    tmp(1, 1) = 1;
-//     tmp.clear();
-    integrator->setInitialValue(tmp);
-    out = integrator->getOutputPort(0);
-
-    Gain* feedbackGain = new Gain(name + " Feedback Gain");
-    addFCSModel(feedbackGain);
-    feedbackGain->setGain(-1);
-    feedbackGain->getInputPort(0)->connect(integrator->getOutputPort(0));
-    inputError->getInputPort(1)->connect(feedbackGain->getOutputPort(0));
-
   } else if (type == "PURE_GAIN") {
     gain = new Gain(name);
     gain->setGain(1);
@@ -1328,7 +1294,6 @@
   shared_ptr<Bias> outbias;
   shared_ptr<Gain> outgain;
   bool outInvert = false;
-  bool noScale = false;
 
   for (;;) {
     std::string token;
@@ -1526,20 +1491,13 @@
           minVal = min(minVal, val);
           maxVal = max(maxVal, val);
         }
-        Matrix tmp(1, 1);
-        if (allTime != 0) {
-          real_type avgTransRate = abs((maxVal-minVal)/allTime);
-          tmp(1, 1) = -avgTransRate;
-          kinematRateLimit->setMinSaturation(tmp);
-          tmp(1, 1) = avgTransRate;
-          kinematRateLimit->setMaxSaturation(tmp);
-        }
-        tmp(1, 1) = minVal;
-        inputSaturation->setMinSaturation(tmp);
-        tmp(1, 1) = maxVal;
-        inputSaturation->setMaxSaturation(tmp);
+        if (allTime != 0)
+          kinemat->setRateLimit(fabs((maxVal-minVal)/allTime));
+        else
+          kinemat->setRateLimit(Limits<real_type>::max());
+        kinemat->setMinValue(minVal);
+        kinemat->setMaxValue(maxVal);
 
-        gain->setGain(maxVal);
       } else
         return error("No DETENTS parameter allowed for \"" + type + "\"");
 
@@ -1611,7 +1569,7 @@
     } else if (token == "NOSCALE") {
 
       if (type == "KINEMAT") {
-        noScale = true;
+        kinemat->setNoScale(true);
       } else
         return error("No NOSCALE parameter allowed for \"" + type + "\"");
       
@@ -1701,20 +1659,6 @@
   // FIXME put in here a normalized out property, or at least a gain to
   // normalize
 
-  // For KINEMATS ...
-  if (type == "KINEMAT") {
-    if (noScale) {
-      gain->setGain(1);
-      normOut = out;
-    } else {
-      Gain* normGain = new Gain(name + " Normalize Gain");
-      normGain->setGain(1/gain->getGain());
-      addFCSModel(normGain);
-      normGain->getInputPort(0)->connect(out);
-      normOut = normGain->getOutputPort(0);
-    }
-  }
-
   if (!normOut || !normOut->isConnected())
     normOut = inputs.front();
 

Added: trunk/OpenFDM/src/JSBSim/LegacyKinemat.cpp
===================================================================
--- trunk/OpenFDM/src/JSBSim/LegacyKinemat.cpp	2005-11-27 10:38:14 UTC (rev 75)
+++ trunk/OpenFDM/src/JSBSim/LegacyKinemat.cpp	2005-11-27 10:38:51 UTC (rev 76)
@@ -0,0 +1,122 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
+ *
+ */
+
+#include <OpenFDM/Summer.h>
+#include <OpenFDM/Saturation.h>
+#include <OpenFDM/DiscreteIntegrator.h>
+#include <OpenFDM/Gain.h>
+
+#include "LegacyKinemat.h"
+
+namespace OpenFDM {
+
+LegacyKinemat::LegacyKinemat(const std::string& name) :
+  ModelGroup(name),
+  mNoScale(false)
+{
+  // A KINEMAT is done as a first order ODE packed into a discrete system
+  // The derivative is limited to match the avarage movement speed of the
+  // KINEMAT. This is not exactly like JSBSim does that, but it is
+  // sufficient for now.
+  // FIXME: simplify
+  // FIXME: implement tables
+  // FIXME: implement triggers for initialization of the integrator at the
+  // first time
+  mInputGain = new Gain("Input Gain");
+  addModel(mInputGain);
+  mInputGain->setGain(1);
+  
+  mInputSaturation = new Saturation("Input Saturation");
+  addModel(mInputSaturation);
+  mInputSaturation->getInputPort(0)->connect(mInputGain->getOutputPort(0));
+  
+  Summer* inputError = new Summer("Input Sum");
+  addModel(inputError);
+  inputError->getInputPort(0)->connect(mInputSaturation->getOutputPort(0));
+  inputError->setNumSummands(2);
+  
+  Gain* errorGain = new Gain("Error Gain");
+  addModel(errorGain);
+  errorGain->setGain(100);
+  errorGain->getInputPort(0)->connect(inputError->getOutputPort(0));
+  
+  mKinematRateLimit = new Saturation("Rate Limit");
+  addModel(mKinematRateLimit);
+  mKinematRateLimit->getInputPort(0)->connect(errorGain->getOutputPort(0));
+  
+  DiscreteIntegrator* integrator = new DiscreteIntegrator("Integrator");
+  addModel(integrator);
+  integrator->getInputPort(0)->connect(mKinematRateLimit->getOutputPort(0));
+  Matrix tmp(1, 1);
+  tmp(1, 1) = 1;
+  integrator->setInitialValue(tmp);
+  
+  Gain* feedbackGain = new Gain("Feedback Gain");
+  addModel(feedbackGain);
+  feedbackGain->setGain(-1);
+  feedbackGain->getInputPort(0)->connect(integrator->getOutputPort(0));
+  inputError->getInputPort(1)->connect(feedbackGain->getOutputPort(0));
+
+  mOutputGain = new Gain("Normalize Gain");
+  addModel(mOutputGain);
+  mOutputGain->setGain(1);
+  mOutputGain->getInputPort(0)->connect(integrator->getOutputPort(0));
+
+
+  // Now connect the input and the output to this groups in and outputs
+  setNumInputPorts(1);
+  getInputPort(0)->setName("Input");
+  mInputGain->getInputPort(0)->connect(getInputPort(0));
+
+  setNumOutputPorts(1);
+  getOutputPort(0)->setName("Output");
+  getOutputPort(0)->connect(mOutputGain->getOutputPort(0));
+}
+
+LegacyKinemat::~LegacyKinemat(void)
+{
+}
+
+void
+LegacyKinemat::setRateLimit(real_type rateLimit)
+{
+  rateLimit = fabs(rateLimit);
+  Matrix tmp(1, 1);
+  tmp(1, 1) = -rateLimit;
+  mKinematRateLimit->setMinSaturation(tmp);
+  tmp(1, 1) = rateLimit;
+  mKinematRateLimit->setMaxSaturation(tmp);
+}
+
+void
+LegacyKinemat::setMinValue(real_type minValue)
+{
+  Matrix tmp(1, 1);
+  tmp(1, 1) = minValue;
+  mInputSaturation->setMinSaturation(tmp);
+}
+
+void
+LegacyKinemat::setMaxValue(real_type maxValue)
+{
+  mInputGain->setGain(maxValue);
+  if (!mNoScale)
+    mOutputGain->setGain(1/maxValue);
+
+  Matrix tmp(1, 1);
+  tmp(1, 1) = maxValue;
+  mInputSaturation->setMaxSaturation(tmp);
+}
+
+void
+LegacyKinemat::setNoScale(bool noScale)
+{
+  mNoScale = noScale;
+  if (mNoScale)
+    mOutputGain->setGain(1);
+  else
+    mOutputGain->setGain(1/mInputGain->getGain());
+}
+
+} //namespace OpenFDM


Property changes on: trunk/OpenFDM/src/JSBSim/LegacyKinemat.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/OpenFDM/src/JSBSim/LegacyKinemat.h
===================================================================
--- trunk/OpenFDM/src/JSBSim/LegacyKinemat.h	2005-11-27 10:38:14 UTC (rev 75)
+++ trunk/OpenFDM/src/JSBSim/LegacyKinemat.h	2005-11-27 10:38:51 UTC (rev 76)
@@ -0,0 +1,35 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_LegacyKinemat_H
+#define OpenFDM_LegacyKinemat_H
+
+#include <OpenFDM/ModelGroup.h>
+
+namespace OpenFDM {
+
+/// Just a small container mapping the JSBSim Kinemat parameters to
+/// the OpenFDM models.
+class LegacyKinemat :
+    public ModelGroup {
+public:
+  LegacyKinemat(const std::string& name);
+  virtual ~LegacyKinemat(void);
+
+  void setRateLimit(real_type rateLimit);
+  void setMinValue(real_type minValue);
+  void setMaxValue(real_type maxValue);
+  void setNoScale(bool noScale);
+
+private:
+  bool mNoScale;
+  shared_ptr<Gain> mInputGain;
+  shared_ptr<Saturation> mInputSaturation;
+  shared_ptr<Saturation> mKinematRateLimit;
+  shared_ptr<Gain> mOutputGain;
+};
+
+} //namespace OpenFDM
+
+#endif


Property changes on: trunk/OpenFDM/src/JSBSim/LegacyKinemat.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/OpenFDM/src/JSBSim/Makefile.am
===================================================================
--- trunk/OpenFDM/src/JSBSim/Makefile.am	2005-11-27 10:38:14 UTC (rev 75)
+++ trunk/OpenFDM/src/JSBSim/Makefile.am	2005-11-27 10:38:51 UTC (rev 76)
@@ -9,8 +9,10 @@
 OpenFDMincludedir = $(includedir)/JSBSim
 
 OpenFDMinclude_HEADERS = \
-  LegacyJSBSimReader.h
+  LegacyJSBSimReader.h \
+  LegacyKinemat.h
 
 lib_LTLIBRARIES = libJSBReader.la
 libJSBReader_la_SOURCES = \
-  LegacyJSBSimReader.cpp
+  LegacyJSBSimReader.cpp \
+  LegacyKinemat.cpp



From frohlich at berlios.de  Sun Nov 27 12:13:46 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Sun, 27 Nov 2005 12:13:46 +0100
Subject: [OpenFDM-svn] r77 - trunk/OpenFDM/src/JSBSim
Message-ID: <200511271113.jARBDkE8012218@sheep.berlios.de>

Author: frohlich
Date: 2005-11-27 12:13:42 +0100 (Sun, 27 Nov 2005)
New Revision: 77

Modified:
   trunk/OpenFDM/src/JSBSim/LegacyKinemat.cpp
Log:
Comment better.


Modified: trunk/OpenFDM/src/JSBSim/LegacyKinemat.cpp
===================================================================
--- trunk/OpenFDM/src/JSBSim/LegacyKinemat.cpp	2005-11-27 10:38:51 UTC (rev 76)
+++ trunk/OpenFDM/src/JSBSim/LegacyKinemat.cpp	2005-11-27 11:13:42 UTC (rev 77)
@@ -19,6 +19,15 @@
   // The derivative is limited to match the avarage movement speed of the
   // KINEMAT. This is not exactly like JSBSim does that, but it is
   // sufficient for now.
+  //
+  // -|InputGain|-|InputSaturation|-|
+  //                                |
+  //  -------------------------------
+  //  |
+  //  +-|ErrorGain|-|RateLimit|-|Integrator|-o-|Outgain|-
+  //  |                                      |
+  //  -----------|FeedbackGain|---------------
+  //
   // FIXME: simplify
   // FIXME: implement tables
   // FIXME: implement triggers for initialization of the integrator at the



From frohlich at berlios.de  Sun Nov 27 14:48:37 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Sun, 27 Nov 2005 14:48:37 +0100
Subject: [OpenFDM-svn] r78 - in trunk/OpenFDM/src: JSBSim OpenFDM
Message-ID: <200511271348.jARDmbuJ006600@sheep.berlios.de>

Author: frohlich
Date: 2005-11-27 14:48:07 +0100 (Sun, 27 Nov 2005)
New Revision: 78

Added:
   trunk/OpenFDM/src/OpenFDM/MaxModel.cpp
   trunk/OpenFDM/src/OpenFDM/MaxModel.h
   trunk/OpenFDM/src/OpenFDM/MinModel.cpp
   trunk/OpenFDM/src/OpenFDM/MinModel.h
Modified:
   trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
   trunk/OpenFDM/src/OpenFDM/Makefile.am
Log:
Provide some min and max model.
Remove a fixme according to that.


Modified: trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
===================================================================
--- trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2005-11-27 11:13:42 UTC (rev 77)
+++ trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2005-11-27 13:48:07 UTC (rev 78)
@@ -22,6 +22,7 @@
 #include <OpenFDM/Input.h>
 #include <OpenFDM/Mass.h>
 #include <OpenFDM/LinearSpring.h>
+#include <OpenFDM/MaxModel.h>
 #include <OpenFDM/AirSpring.h>
 #include <OpenFDM/PrismaticJoint.h>
 #include <OpenFDM/Product.h>
@@ -400,36 +401,40 @@
                            "controls/gear/brake-parking");
 
     } else if (propName == "fdm/jsbsim/gear/right-brake-pos-norm") {
+      MaxModel* maxModel = new MaxModel("Right Brake Max");
+      maxModel->setNumMaxInputs(3);
+
       Port* pilotBr = addInputModel("Right Brake Input",
                                     "controls/gear/brake-right");
+      maxModel->getInputPort(0)->connect(pilotBr);
+
       Port* copilotBr = addInputModel("Right Copilot Brake Input",
                                       "controls/gear/copilot-brake-right");
+      maxModel->getInputPort(1)->connect(copilotBr);
 
       Port* parkBr = lookupJSBExpression("/controls/gear/brake-parking");
+      maxModel->getInputPort(2)->connect(parkBr);
 
-      // FIXME: we don't have a max model ...
-      MaxExpressionImpl* mex = new MaxExpressionImpl;
-      mex->addInputProperty(pilotBr->getProperty());
-      mex->addInputProperty(copilotBr->getProperty());
-      mex->addInputProperty(parkBr->getProperty());
-      port = new Port;
-      port->setProperty(Property(mex));
+      addFCSModel(maxModel);
+      port = maxModel->getOutputPort(0);
 
     } else if (propName == "fdm/jsbsim/gear/left-brake-pos-norm") {
+      MaxModel* maxModel = new MaxModel("Left Brake Max");
+      maxModel->setNumMaxInputs(3);
+
       Port* pilotBr = addInputModel("Left Brake Input",
                                     "controls/gear/brake-left");
+      maxModel->getInputPort(0)->connect(pilotBr);
+
       Port* copilotBr = addInputModel("Left Copilot Brake Input",
                                       "controls/gear/copilot-brake-left");
+      maxModel->getInputPort(1)->connect(copilotBr);
       
       Port* parkBr = lookupJSBExpression("/controls/gear/brake-parking");
+      maxModel->getInputPort(2)->connect(parkBr);
 
-      // FIXME: we don't have a max model ...
-      MaxExpressionImpl* mex = new MaxExpressionImpl;
-      mex->addInputProperty(pilotBr->getProperty());
-      mex->addInputProperty(copilotBr->getProperty());
-      mex->addInputProperty(parkBr->getProperty());
-      port = new Port;
-      port->setProperty(Property(mex));
+      addFCSModel(maxModel);
+      port = maxModel->getOutputPort(0);
 
     } else if (propName.substr(0, 19) == "fdm/jsbsim/fcs/mag-") {
       // Special absolute modules for fcs/mag-*

Modified: trunk/OpenFDM/src/OpenFDM/Makefile.am
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Makefile.am	2005-11-27 11:13:42 UTC (rev 77)
+++ trunk/OpenFDM/src/OpenFDM/Makefile.am	2005-11-27 13:48:07 UTC (rev 78)
@@ -77,7 +77,9 @@
   Mass.h \
   Math.h \
   Matrix.h \
+  MaxModel.h \
   MidpointRule.h \
+  MinModel.h \
   Model.h \
   ModelGroup.h \
   MultiBodyModel.h \
@@ -163,7 +165,9 @@
   LineForce.cpp \
   Logger.cpp \
   Mass.cpp \
+  MaxModel.cpp \
   MidpointRule.cpp \
+  MinModel.cpp \
   Model.cpp \
   ModelGroup.cpp \
   MultiBodyModel.cpp \

Added: trunk/OpenFDM/src/OpenFDM/MaxModel.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/MaxModel.cpp	2005-11-27 11:13:42 UTC (rev 77)
+++ trunk/OpenFDM/src/OpenFDM/MaxModel.cpp	2005-11-27 13:48:07 UTC (rev 78)
@@ -0,0 +1,80 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
+ *
+ */
+
+#include <string>
+
+#include "Types.h"
+#include "Matrix.h"
+#include "Property.h"
+#include "Model.h"
+#include "MaxModel.h"
+
+namespace OpenFDM {
+
+MaxModel::MaxModel(const std::string& name) :
+  Model(name)
+{
+  setDirectFeedThrough(true);
+
+  setNumInputPorts(2);
+  setInputPortName(0, "Input 0");
+  setInputPortName(1, "Input 1");
+  
+  setNumOutputPorts(1);
+  setOutputPort(0, "output", Property(this, &MaxModel::getMax));
+  addProperty("output", Property(this, &MaxModel::getMax));
+
+  addProperty("numMaxInputs", Property(this, &MaxModel::getNumMaxInputs, &MaxModel::setNumMaxInputs));
+}
+
+MaxModel::~MaxModel(void)
+{
+}
+
+bool
+MaxModel::init(void)
+{
+  for (unsigned i = 0; i < getNumInputPorts(); ++i)
+    OpenFDMAssert(getInputPort(i)->isConnected());
+  
+  // Make sure it is invalid if sizes do not match.
+  mMax.resize(0, 0);
+  // Check if the sizes match.
+  Matrix a0 = getInputPort(0)->getValue().toMatrix();
+  for (unsigned i = 1; i < getNumInputPorts(); ++i) {
+    Matrix a = getInputPort(i)->getValue().toMatrix();
+    if (size(a0) != size(a))
+      return false;
+  }
+  mMax.resize(a0);
+  return true;
+}
+
+void
+MaxModel::output(const TaskInfo&)
+{
+  mMax = getInputPort(0)->getValue().toMatrix();
+  for (unsigned i = 1; i < getNumInputPorts(); ++i)
+    mMax = LinAlg::max(mMax, getInputPort(i)->getValue().toMatrix());
+}
+
+const Matrix&
+MaxModel::getMax(void) const
+{
+  return mMax;
+}
+
+unsigned
+MaxModel::getNumMaxInputs(void) const
+{
+  return getNumInputPorts();
+}
+
+void
+MaxModel::setNumMaxInputs(const unsigned& num)
+{
+  setNumInputPorts(num);
+}
+
+} // namespace OpenFDM


Property changes on: trunk/OpenFDM/src/OpenFDM/MaxModel.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/OpenFDM/src/OpenFDM/MaxModel.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/MaxModel.h	2005-11-27 11:13:42 UTC (rev 77)
+++ trunk/OpenFDM/src/OpenFDM/MaxModel.h	2005-11-27 13:48:07 UTC (rev 78)
@@ -0,0 +1,35 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_MaxModel_H
+#define OpenFDM_MaxModel_H
+
+#include <string>
+
+#include "Matrix.h"
+#include "Model.h"
+
+namespace OpenFDM {
+
+class MaxModel :
+    public Model {
+public:
+  MaxModel(const std::string& name);
+  virtual ~MaxModel(void);
+  
+  virtual bool init(void);
+  virtual void output(const TaskInfo&);
+
+  const Matrix& getMax(void) const;
+
+  unsigned getNumMaxInputs(void) const;
+  void setNumMaxInputs(const unsigned& num);
+
+private:
+  Matrix mMax;
+};
+
+} // namespace OpenFDM
+
+#endif


Property changes on: trunk/OpenFDM/src/OpenFDM/MaxModel.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/OpenFDM/src/OpenFDM/MinModel.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/MinModel.cpp	2005-11-27 11:13:42 UTC (rev 77)
+++ trunk/OpenFDM/src/OpenFDM/MinModel.cpp	2005-11-27 13:48:07 UTC (rev 78)
@@ -0,0 +1,80 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
+ *
+ */
+
+#include <string>
+
+#include "Types.h"
+#include "Matrix.h"
+#include "Property.h"
+#include "Model.h"
+#include "MinModel.h"
+
+namespace OpenFDM {
+
+MinModel::MinModel(const std::string& name) :
+  Model(name)
+{
+  setDirectFeedThrough(true);
+
+  setNumInputPorts(2);
+  setInputPortName(0, "Input 0");
+  setInputPortName(1, "Input 1");
+  
+  setNumOutputPorts(1);
+  setOutputPort(0, "output", Property(this, &MinModel::getMin));
+  addProperty("output", Property(this, &MinModel::getMin));
+
+  addProperty("numMinInputs", Property(this, &MinModel::getNumMinInputs, &MinModel::setNumMinInputs));
+}
+
+MinModel::~MinModel(void)
+{
+}
+
+bool
+MinModel::init(void)
+{
+  for (unsigned i = 0; i < getNumInputPorts(); ++i)
+    OpenFDMAssert(getInputPort(i)->isConnected());
+  
+  // Make sure it is invalid if sizes do not match.
+  mMin.resize(0, 0);
+  // Check if the sizes match.
+  Matrix a0 = getInputPort(0)->getValue().toMatrix();
+  for (unsigned i = 1; i < getNumInputPorts(); ++i) {
+    Matrix a = getInputPort(i)->getValue().toMatrix();
+    if (size(a0) != size(a))
+      return false;
+  }
+  mMin.resize(a0);
+  return true;
+}
+
+void
+MinModel::output(const TaskInfo&)
+{
+  mMin = getInputPort(0)->getValue().toMatrix();
+  for (unsigned i = 1; i < getNumInputPorts(); ++i)
+    mMin = LinAlg::min(mMin, getInputPort(i)->getValue().toMatrix());
+}
+
+const Matrix&
+MinModel::getMin(void) const
+{
+  return mMin;
+}
+
+unsigned
+MinModel::getNumMinInputs(void) const
+{
+  return getNumInputPorts();
+}
+
+void
+MinModel::setNumMinInputs(const unsigned& num)
+{
+  setNumInputPorts(num);
+}
+
+} // namespace OpenFDM


Property changes on: trunk/OpenFDM/src/OpenFDM/MinModel.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/OpenFDM/src/OpenFDM/MinModel.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/MinModel.h	2005-11-27 11:13:42 UTC (rev 77)
+++ trunk/OpenFDM/src/OpenFDM/MinModel.h	2005-11-27 13:48:07 UTC (rev 78)
@@ -0,0 +1,35 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_MinModel_H
+#define OpenFDM_MinModel_H
+
+#include <string>
+
+#include "Matrix.h"
+#include "Model.h"
+
+namespace OpenFDM {
+
+class MinModel :
+    public Model {
+public:
+  MinModel(const std::string& name);
+  virtual ~MinModel(void);
+  
+  virtual bool init(void);
+  virtual void output(const TaskInfo&);
+
+  const Matrix& getMin(void) const;
+
+  unsigned getNumMinInputs(void) const;
+  void setNumMinInputs(const unsigned& num);
+
+private:
+  Matrix mMin;
+};
+
+} // namespace OpenFDM
+
+#endif


Property changes on: trunk/OpenFDM/src/OpenFDM/MinModel.h
___________________________________________________________________
Name: svn:eol-style
   + native



From frohlich at berlios.de  Sun Nov 27 21:31:25 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Sun, 27 Nov 2005 21:31:25 +0100
Subject: [OpenFDM-svn] r79 - in trunk/OpenFDM/src: JSBSim OpenFDM
Message-ID: <200511272031.jARKVP7E017619@sheep.berlios.de>

Author: frohlich
Date: 2005-11-27 21:31:10 +0100 (Sun, 27 Nov 2005)
New Revision: 79

Added:
   trunk/OpenFDM/src/JSBSim/JSBSimAerosurfaceScale.cpp
   trunk/OpenFDM/src/JSBSim/JSBSimAerosurfaceScale.h
   trunk/OpenFDM/src/JSBSim/JSBSimKinemat.cpp
   trunk/OpenFDM/src/JSBSim/JSBSimKinemat.h
Removed:
   trunk/OpenFDM/src/JSBSim/LegacyKinemat.cpp
   trunk/OpenFDM/src/JSBSim/LegacyKinemat.h
Modified:
   trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
   trunk/OpenFDM/src/JSBSim/Makefile.am
   trunk/OpenFDM/src/OpenFDM/ModelGroup.h
Log:
Factor out aerosurface scale and common FCS
component framework.


Added: trunk/OpenFDM/src/JSBSim/JSBSimAerosurfaceScale.cpp
===================================================================
--- trunk/OpenFDM/src/JSBSim/JSBSimAerosurfaceScale.cpp	2005-11-27 13:48:07 UTC (rev 78)
+++ trunk/OpenFDM/src/JSBSim/JSBSimAerosurfaceScale.cpp	2005-11-27 20:31:10 UTC (rev 79)
@@ -0,0 +1,88 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
+ *
+ */
+
+#include <OpenFDM/ModelGroup.h>
+#include <OpenFDM/Product.h>
+#include <OpenFDM/Saturation.h>
+#include <OpenFDM/Table.h>
+
+#include "JSBSimAerosurfaceScale.h"
+
+
+
+
+#include <OpenFDM/Gain.h>
+
+namespace OpenFDM {
+
+JSBSimAerosurfaceScale::JSBSimAerosurfaceScale(const std::string& name) :
+  JSBSimFCSComponent(name, true)
+{
+  // Such a component is a simple table lookup
+  //
+  // -|InputSaturation|-|TableLookup|-
+  //
+
+  Saturation* inputSaturation = new Saturation("Input Saturation");
+  getModelGroup()->addModel(inputSaturation);
+  Matrix tmp(1, 1);
+  tmp(1, 1) = -1;
+  inputSaturation->setMinSaturation(tmp);
+  tmp(1, 1) = 1;
+  inputSaturation->setMaxSaturation(tmp);
+
+  mTable = new Table1D("Table");
+  TableLookup tl;
+  tl.setAtIndex(1, -1);
+  tl.setAtIndex(2, 0);
+  tl.setAtIndex(3, 1);
+  mTable->setTableLookup(tl);
+  TableData<1>::SizeVector sv;
+  sv(1) = 3;
+  TableData<1> tableData(sv);
+  TableData<1>::Index iv;
+  iv(1) = 1;
+  tableData(iv) = -1;
+  iv(1) = 2;
+  tableData(iv) = 0;
+  iv(1) = 3;
+  tableData(iv) = 1;
+  mTable->setTableData(tableData);
+  mTable->getInputPort(0)->connect(inputSaturation->getOutputPort(0));
+  getModelGroup()->addModel(mTable);
+
+  // Now connect the input and the output to this groups in and outputs
+  getModelGroup()->setNumInputPorts(1);
+  getModelGroup()->getInputPort(0)->setName("Input");
+  inputSaturation->getInputPort(0)->connect(getModelGroup()->getInputPort(0));
+
+  getOutputPort()->connect(mTable->getOutputPort(0));
+  getOutputNormPort()->connect(inputSaturation->getOutputPort(0));
+}
+
+JSBSimAerosurfaceScale::~JSBSimAerosurfaceScale(void)
+{
+}
+
+void
+JSBSimAerosurfaceScale::setMinValue(real_type minValue)
+{
+  TableData<1> tableData = mTable->getTableData();
+  TableData<1>::Index iv;
+  iv(1) = 1;
+  tableData(iv) = minValue;
+  mTable->setTableData(tableData);
+}
+
+void
+JSBSimAerosurfaceScale::setMaxValue(real_type maxValue)
+{
+  TableData<1> tableData = mTable->getTableData();
+  TableData<1>::Index iv;
+  iv(1) = 3;
+  tableData(iv) = maxValue;
+  mTable->setTableData(tableData);
+}
+
+} //namespace OpenFDM


Property changes on: trunk/OpenFDM/src/JSBSim/JSBSimAerosurfaceScale.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/OpenFDM/src/JSBSim/JSBSimAerosurfaceScale.h
===================================================================
--- trunk/OpenFDM/src/JSBSim/JSBSimAerosurfaceScale.h	2005-11-27 13:48:07 UTC (rev 78)
+++ trunk/OpenFDM/src/JSBSim/JSBSimAerosurfaceScale.h	2005-11-27 20:31:10 UTC (rev 79)
@@ -0,0 +1,31 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_JSBSimAerosurfaceScale_H
+#define OpenFDM_JSBSimAerosurfaceScale_H
+
+#include "JSBSimFCSComponent.h"
+
+namespace OpenFDM {
+
+class Table1D;
+
+/// Just a small container mapping the JSBSim AerosurfaceScale parameters to
+/// the OpenFDM models.
+class JSBSimAerosurfaceScale :
+    public JSBSimFCSComponent {
+public:
+  JSBSimAerosurfaceScale(const std::string& name);
+  virtual ~JSBSimAerosurfaceScale(void);
+
+  void setMinValue(real_type minValue);
+  void setMaxValue(real_type maxValue);
+
+private:
+  shared_ptr<Table1D> mTable;
+};
+
+} //namespace OpenFDM
+
+#endif


Property changes on: trunk/OpenFDM/src/JSBSim/JSBSimAerosurfaceScale.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/OpenFDM/src/JSBSim/JSBSimKinemat.cpp
===================================================================
--- trunk/OpenFDM/src/JSBSim/JSBSimKinemat.cpp	2005-11-27 13:48:07 UTC (rev 78)
+++ trunk/OpenFDM/src/JSBSim/JSBSimKinemat.cpp	2005-11-27 20:31:10 UTC (rev 79)
@@ -0,0 +1,138 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
+ *
+ */
+
+#include <OpenFDM/DiscreteIntegrator.h>
+#include <OpenFDM/Gain.h>
+#include <OpenFDM/ModelGroup.h>
+#include <OpenFDM/Saturation.h>
+#include <OpenFDM/Summer.h>
+
+#include "JSBSimKinemat.h"
+
+namespace OpenFDM {
+
+JSBSimKinemat::JSBSimKinemat(const std::string& name) :
+  JSBSimFCSComponent(name, true),
+  mNoScale(false)
+{
+  // A KINEMAT is done as a first order ODE packed into a discrete system
+  // The derivative is limited to match the avarage movement speed of the
+  // KINEMAT. This is not exactly like JSBSim does that, but it is
+  // sufficient for now.
+  //
+  // -|InputGain|-|InputSaturation|-|
+  //                                |
+  //  -------------------------------
+  //  |
+  //  o-|TableLookup|-o-|Minus|-| FIXME: that table lookup is still missing
+  //  |               |         |
+  //  +-|ErrorGain|--|Min|----|Max|-|Integrator|-o-|Outgain|-
+  //  |                                          |
+  //  -----------|FeedbackGain|-------------------
+  //
+  // FIXME: simplify
+  // FIXME: implement tables
+  // FIXME: implement triggers for initialization of the integrator at the
+  // first time
+  mInputGain = new Gain("Input Gain");
+  getModelGroup()->addModel(mInputGain);
+  mInputGain->setGain(1);
+  
+  mInputSaturation = new Saturation("Input Saturation");
+  getModelGroup()->addModel(mInputSaturation);
+  mInputSaturation->getInputPort(0)->connect(mInputGain->getOutputPort(0));
+  
+  Summer* inputError = new Summer("Input Sum");
+  getModelGroup()->addModel(inputError);
+  inputError->getInputPort(0)->connect(mInputSaturation->getOutputPort(0));
+  inputError->setNumSummands(2);
+  
+  Gain* errorGain = new Gain("Error Gain");
+  getModelGroup()->addModel(errorGain);
+  errorGain->setGain(100);
+  errorGain->getInputPort(0)->connect(inputError->getOutputPort(0));
+  
+  mKinematRateLimit = new Saturation("Rate Limit");
+  getModelGroup()->addModel(mKinematRateLimit);
+  mKinematRateLimit->getInputPort(0)->connect(errorGain->getOutputPort(0));
+  
+  DiscreteIntegrator* integrator = new DiscreteIntegrator("Integrator");
+  getModelGroup()->addModel(integrator);
+  integrator->getInputPort(0)->connect(mKinematRateLimit->getOutputPort(0));
+  Matrix tmp(1, 1);
+  tmp(1, 1) = 1;
+  integrator->setInitialValue(tmp);
+  
+  Gain* feedbackGain = new Gain("Feedback Gain");
+  getModelGroup()->addModel(feedbackGain);
+  feedbackGain->setGain(-1);
+  feedbackGain->getInputPort(0)->connect(integrator->getOutputPort(0));
+  inputError->getInputPort(1)->connect(feedbackGain->getOutputPort(0));
+
+  mOutputNormGain = new Gain("Output Norm Gain");
+  getModelGroup()->addModel(mOutputNormGain);
+  mOutputNormGain->setGain(1);
+  mOutputNormGain->getInputPort(0)->connect(integrator->getOutputPort(0));
+
+
+  // Now connect the input and the output to this groups in and outputs
+  getModelGroup()->setNumInputPorts(1);
+  getModelGroup()->getInputPort(0)->setName("Input");
+  mInputGain->getInputPort(0)->connect(getModelGroup()->getInputPort(0));
+
+  getOutputPort()->connect(integrator->getOutputPort(0));
+  getOutputNormPort()->connect(mOutputNormGain->getOutputPort(0));
+}
+
+JSBSimKinemat::~JSBSimKinemat(void)
+{
+}
+
+void
+JSBSimKinemat::setRateLimit(real_type rateLimit)
+{
+  rateLimit = fabs(rateLimit);
+  Matrix tmp(1, 1);
+  tmp(1, 1) = -rateLimit;
+  mKinematRateLimit->setMinSaturation(tmp);
+  tmp(1, 1) = rateLimit;
+  mKinematRateLimit->setMaxSaturation(tmp);
+}
+
+void
+JSBSimKinemat::setMinValue(real_type minValue)
+{
+  Matrix tmp(1, 1);
+  tmp(1, 1) = minValue;
+  mInputSaturation->setMinSaturation(tmp);
+}
+
+void
+JSBSimKinemat::setMaxValue(real_type maxValue)
+{
+  if (mNoScale) {
+    mInputGain->setGain(1);
+  } else {
+    mInputGain->setGain(maxValue);
+  }
+  mOutputNormGain->setGain(1/maxValue);
+
+  Matrix tmp(1, 1);
+  tmp(1, 1) = maxValue;
+  mInputSaturation->setMaxSaturation(tmp);
+}
+
+void
+JSBSimKinemat::setNoScale(bool noScale)
+{
+  mNoScale = noScale;
+  if (mNoScale) {
+    mInputGain->setGain(1);
+  } else {
+    Matrix maxValue = mInputSaturation->getMaxSaturation();
+    mInputGain->setGain(maxValue(1, 1));
+  }
+}
+
+} //namespace OpenFDM


Property changes on: trunk/OpenFDM/src/JSBSim/JSBSimKinemat.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/OpenFDM/src/JSBSim/JSBSimKinemat.h
===================================================================
--- trunk/OpenFDM/src/JSBSim/JSBSimKinemat.h	2005-11-27 13:48:07 UTC (rev 78)
+++ trunk/OpenFDM/src/JSBSim/JSBSimKinemat.h	2005-11-27 20:31:10 UTC (rev 79)
@@ -0,0 +1,35 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_JSBSimKinemat_H
+#define OpenFDM_JSBSimKinemat_H
+
+#include "JSBSimFCSComponent.h"
+
+namespace OpenFDM {
+
+/// Just a small container mapping the JSBSim Kinemat parameters to
+/// the OpenFDM models.
+class JSBSimKinemat :
+    public JSBSimFCSComponent {
+public:
+  JSBSimKinemat(const std::string& name);
+  virtual ~JSBSimKinemat(void);
+
+  void setRateLimit(real_type rateLimit);
+  void setMinValue(real_type minValue);
+  void setMaxValue(real_type maxValue);
+  void setNoScale(bool noScale);
+
+private:
+  bool mNoScale;
+  shared_ptr<Gain> mInputGain;
+  shared_ptr<Saturation> mInputSaturation;
+  shared_ptr<Saturation> mKinematRateLimit;
+  shared_ptr<Gain> mOutputNormGain;
+};
+
+} //namespace OpenFDM
+
+#endif


Property changes on: trunk/OpenFDM/src/JSBSim/JSBSimKinemat.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
===================================================================
--- trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2005-11-27 13:48:07 UTC (rev 78)
+++ trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2005-11-27 20:31:10 UTC (rev 79)
@@ -44,7 +44,8 @@
 #include <OpenFDM/XML/Tablereader.h>
 #include <OpenFDM/XML/XMLReader.h>
 
-#include "LegacyKinemat.h"
+#include "JSBSimAerosurfaceScale.h"
+#include "JSBSimKinemat.h"
 
 #include "LegacyJSBSimReader.h"
 
@@ -1130,8 +1131,9 @@
   shared_ptr<Gain> gain;
   shared_ptr<DiscreteTransferFunction> discreteTransfFunc;
   shared_ptr<Table1D> table1D;
-  shared_ptr<LegacyKinemat> kinemat;
   shared_ptr<Saturation> inputSaturation;
+  shared_ptr<JSBSimAerosurfaceScale> asScale;
+  shared_ptr<JSBSimKinemat> kinemat;
 
   // The final output property.
   shared_ptr<Port> out;
@@ -1169,10 +1171,11 @@
   } else if (type == "KINEMAT") {
 
     // Use that special proxy class
-    kinemat = new LegacyKinemat(name);
-    model = kinemat;
+    kinemat = new JSBSimKinemat(name);
+    model = kinemat->getModelGroup();
     addFCSModel(model);
-    out = kinemat->getOutputPort(0);
+    out = kinemat->getOutputPort();
+    normOut = kinemat->getOutputNormPort();
 
   } else if (type == "PURE_GAIN") {
     gain = new Gain(name);
@@ -1186,39 +1189,11 @@
     // the input from -1 to 1. This is the one which is magically mapped to
     // an output property in /surface-positions/...
     // This one's output is directly connected to a lookup table
-
-    inputSaturation = new Saturation(name + "Input Saturation");
-    model = inputSaturation;
-    addFCSModel(inputSaturation);
-    normOut = inputSaturation->getOutputPort(0);
-    Matrix tmp(1, 1);
-    tmp(1, 1) = -1;
-    inputSaturation->setMinSaturation(tmp);
-    tmp(1, 1) = 1;
-    inputSaturation->setMaxSaturation(tmp);
-
-    table1D = new Table1D(name);
-    TableLookup tl;
-    tl.setAtIndex(1, -1);
-    tl.setAtIndex(2, 0);
-    tl.setAtIndex(3, 1);
-    table1D->setTableLookup(tl);
-    TableData<1>::SizeVector sv;
-    sv(1) = 3;
-    TableData<1> tableData(sv);
-    TableData<1>::Index iv;
-    iv(1) = 1;
-    tableData(iv) = -1;
-    iv(1) = 2;
-    tableData(iv) = 0;
-    iv(1) = 3;
-    tableData(iv) = 1;
-    table1D->setTableData(tableData);
-    table1D->getInputPort(0)->connect(inputSaturation->getOutputPort(0));
-
-    addFCSModel(table1D);
-    out = table1D->getOutputPort(0);
-
+    asScale = new JSBSimAerosurfaceScale(name);
+    model = asScale->getModelGroup();
+    addFCSModel(model);
+    out = asScale->getOutputPort();
+    normOut = asScale->getOutputNormPort();
   } else if (type == "SCHEDULED_GAIN") {
     Product* prod = new Product(name);
     prod->setNumFactors(2);
@@ -1532,11 +1507,8 @@
       datastr >> clipmax;
       
       if (type == "AEROSURFACE_SCALE") {
-        TableData<1> tableData = table1D->getTableData();
-        TableData<1>::Index iv;
-        iv(1) = 3;
-        tableData(iv) = clipmax;
-        table1D->setTableData(tableData);
+        asScale->setMaxValue(clipmax);
+
       } else {
         if (!saturation) {
           std::string modelName = std::string(name) + " OSat";
@@ -1554,11 +1526,8 @@
       datastr >> clipmin;
       
       if (type == "AEROSURFACE_SCALE") {
-        TableData<1> tableData = table1D->getTableData();
-        TableData<1>::Index iv;
-        iv(1) = 1;
-        tableData(iv) = clipmin;
-        table1D->setTableData(tableData);
+        asScale->setMinValue(clipmin);
+
       } else {
         if (!saturation) {
           std::string modelName = std::string(name) + " OSat";

Deleted: trunk/OpenFDM/src/JSBSim/LegacyKinemat.cpp
===================================================================
--- trunk/OpenFDM/src/JSBSim/LegacyKinemat.cpp	2005-11-27 13:48:07 UTC (rev 78)
+++ trunk/OpenFDM/src/JSBSim/LegacyKinemat.cpp	2005-11-27 20:31:10 UTC (rev 79)
@@ -1,131 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
- *
- */
-
-#include <OpenFDM/Summer.h>
-#include <OpenFDM/Saturation.h>
-#include <OpenFDM/DiscreteIntegrator.h>
-#include <OpenFDM/Gain.h>
-
-#include "LegacyKinemat.h"
-
-namespace OpenFDM {
-
-LegacyKinemat::LegacyKinemat(const std::string& name) :
-  ModelGroup(name),
-  mNoScale(false)
-{
-  // A KINEMAT is done as a first order ODE packed into a discrete system
-  // The derivative is limited to match the avarage movement speed of the
-  // KINEMAT. This is not exactly like JSBSim does that, but it is
-  // sufficient for now.
-  //
-  // -|InputGain|-|InputSaturation|-|
-  //                                |
-  //  -------------------------------
-  //  |
-  //  +-|ErrorGain|-|RateLimit|-|Integrator|-o-|Outgain|-
-  //  |                                      |
-  //  -----------|FeedbackGain|---------------
-  //
-  // FIXME: simplify
-  // FIXME: implement tables
-  // FIXME: implement triggers for initialization of the integrator at the
-  // first time
-  mInputGain = new Gain("Input Gain");
-  addModel(mInputGain);
-  mInputGain->setGain(1);
-  
-  mInputSaturation = new Saturation("Input Saturation");
-  addModel(mInputSaturation);
-  mInputSaturation->getInputPort(0)->connect(mInputGain->getOutputPort(0));
-  
-  Summer* inputError = new Summer("Input Sum");
-  addModel(inputError);
-  inputError->getInputPort(0)->connect(mInputSaturation->getOutputPort(0));
-  inputError->setNumSummands(2);
-  
-  Gain* errorGain = new Gain("Error Gain");
-  addModel(errorGain);
-  errorGain->setGain(100);
-  errorGain->getInputPort(0)->connect(inputError->getOutputPort(0));
-  
-  mKinematRateLimit = new Saturation("Rate Limit");
-  addModel(mKinematRateLimit);
-  mKinematRateLimit->getInputPort(0)->connect(errorGain->getOutputPort(0));
-  
-  DiscreteIntegrator* integrator = new DiscreteIntegrator("Integrator");
-  addModel(integrator);
-  integrator->getInputPort(0)->connect(mKinematRateLimit->getOutputPort(0));
-  Matrix tmp(1, 1);
-  tmp(1, 1) = 1;
-  integrator->setInitialValue(tmp);
-  
-  Gain* feedbackGain = new Gain("Feedback Gain");
-  addModel(feedbackGain);
-  feedbackGain->setGain(-1);
-  feedbackGain->getInputPort(0)->connect(integrator->getOutputPort(0));
-  inputError->getInputPort(1)->connect(feedbackGain->getOutputPort(0));
-
-  mOutputGain = new Gain("Normalize Gain");
-  addModel(mOutputGain);
-  mOutputGain->setGain(1);
-  mOutputGain->getInputPort(0)->connect(integrator->getOutputPort(0));
-
-
-  // Now connect the input and the output to this groups in and outputs
-  setNumInputPorts(1);
-  getInputPort(0)->setName("Input");
-  mInputGain->getInputPort(0)->connect(getInputPort(0));
-
-  setNumOutputPorts(1);
-  getOutputPort(0)->setName("Output");
-  getOutputPort(0)->connect(mOutputGain->getOutputPort(0));
-}
-
-LegacyKinemat::~LegacyKinemat(void)
-{
-}
-
-void
-LegacyKinemat::setRateLimit(real_type rateLimit)
-{
-  rateLimit = fabs(rateLimit);
-  Matrix tmp(1, 1);
-  tmp(1, 1) = -rateLimit;
-  mKinematRateLimit->setMinSaturation(tmp);
-  tmp(1, 1) = rateLimit;
-  mKinematRateLimit->setMaxSaturation(tmp);
-}
-
-void
-LegacyKinemat::setMinValue(real_type minValue)
-{
-  Matrix tmp(1, 1);
-  tmp(1, 1) = minValue;
-  mInputSaturation->setMinSaturation(tmp);
-}
-
-void
-LegacyKinemat::setMaxValue(real_type maxValue)
-{
-  mInputGain->setGain(maxValue);
-  if (!mNoScale)
-    mOutputGain->setGain(1/maxValue);
-
-  Matrix tmp(1, 1);
-  tmp(1, 1) = maxValue;
-  mInputSaturation->setMaxSaturation(tmp);
-}
-
-void
-LegacyKinemat::setNoScale(bool noScale)
-{
-  mNoScale = noScale;
-  if (mNoScale)
-    mOutputGain->setGain(1);
-  else
-    mOutputGain->setGain(1/mInputGain->getGain());
-}
-
-} //namespace OpenFDM

Deleted: trunk/OpenFDM/src/JSBSim/LegacyKinemat.h
===================================================================
--- trunk/OpenFDM/src/JSBSim/LegacyKinemat.h	2005-11-27 13:48:07 UTC (rev 78)
+++ trunk/OpenFDM/src/JSBSim/LegacyKinemat.h	2005-11-27 20:31:10 UTC (rev 79)
@@ -1,35 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
- *
- */
-
-#ifndef OpenFDM_LegacyKinemat_H
-#define OpenFDM_LegacyKinemat_H
-
-#include <OpenFDM/ModelGroup.h>
-
-namespace OpenFDM {
-
-/// Just a small container mapping the JSBSim Kinemat parameters to
-/// the OpenFDM models.
-class LegacyKinemat :
-    public ModelGroup {
-public:
-  LegacyKinemat(const std::string& name);
-  virtual ~LegacyKinemat(void);
-
-  void setRateLimit(real_type rateLimit);
-  void setMinValue(real_type minValue);
-  void setMaxValue(real_type maxValue);
-  void setNoScale(bool noScale);
-
-private:
-  bool mNoScale;
-  shared_ptr<Gain> mInputGain;
-  shared_ptr<Saturation> mInputSaturation;
-  shared_ptr<Saturation> mKinematRateLimit;
-  shared_ptr<Gain> mOutputGain;
-};
-
-} //namespace OpenFDM
-
-#endif

Modified: trunk/OpenFDM/src/JSBSim/Makefile.am
===================================================================
--- trunk/OpenFDM/src/JSBSim/Makefile.am	2005-11-27 13:48:07 UTC (rev 78)
+++ trunk/OpenFDM/src/JSBSim/Makefile.am	2005-11-27 20:31:10 UTC (rev 79)
@@ -9,10 +9,14 @@
 OpenFDMincludedir = $(includedir)/JSBSim
 
 OpenFDMinclude_HEADERS = \
-  LegacyJSBSimReader.h \
-  LegacyKinemat.h
+  JSBSimFCSComponent.h \
+  JSBSimAerosurfaceScale.h \
+  JSBSimKinemat.h \
+  LegacyJSBSimReader.h
 
 lib_LTLIBRARIES = libJSBReader.la
 libJSBReader_la_SOURCES = \
-  LegacyJSBSimReader.cpp \
-  LegacyKinemat.cpp
+  JSBSimFCSComponent.cpp \
+  JSBSimAerosurfaceScale.cpp \
+  JSBSimKinemat.cpp \
+  LegacyJSBSimReader.cpp

Modified: trunk/OpenFDM/src/OpenFDM/ModelGroup.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/ModelGroup.h	2005-11-27 13:48:07 UTC (rev 78)
+++ trunk/OpenFDM/src/OpenFDM/ModelGroup.h	2005-11-27 20:31:10 UTC (rev 79)
@@ -49,6 +49,10 @@
   virtual void setDiscreteState(const Vector& state, unsigned offset);
   virtual void getDiscreteState(Vector& state, unsigned offset) const;
 
+  /// make them public
+  using Model::setNumInputPorts;
+  using Model::setNumOutputPorts;
+
 private:
   typedef std::vector<shared_ptr<Model> > ModelList;
 



From frohlich at berlios.de  Mon Nov 28 20:37:46 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Mon, 28 Nov 2005 20:37:46 +0100
Subject: [OpenFDM-svn] r80 - in trunk/OpenFDM/src: JSBSim OpenFDM
Message-ID: <200511281937.jASJbkgp001830@sheep.berlios.de>

Author: frohlich
Date: 2005-11-28 20:37:39 +0100 (Mon, 28 Nov 2005)
New Revision: 80

Added:
   trunk/OpenFDM/src/JSBSim/JSBSimScheduledGain.cpp
   trunk/OpenFDM/src/JSBSim/JSBSimScheduledGain.h
Modified:
   trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
   trunk/OpenFDM/src/JSBSim/Makefile.am
   trunk/OpenFDM/src/OpenFDM/Model.h
Log:
Also convert that scheduled gain as FCS module.


Added: trunk/OpenFDM/src/JSBSim/JSBSimScheduledGain.cpp
===================================================================
--- trunk/OpenFDM/src/JSBSim/JSBSimScheduledGain.cpp	2005-11-27 20:31:10 UTC (rev 79)
+++ trunk/OpenFDM/src/JSBSim/JSBSimScheduledGain.cpp	2005-11-28 19:37:39 UTC (rev 80)
@@ -0,0 +1,53 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
+ *
+ */
+
+#include <OpenFDM/ModelGroup.h>
+#include <OpenFDM/Product.h>
+#include <OpenFDM/Table.h>
+
+#include "JSBSimScheduledGain.h"
+
+namespace OpenFDM {
+
+JSBSimScheduledGain::JSBSimScheduledGain(const std::string& name) :
+  JSBSimFCSComponent(name, false)
+{
+  // Such a component is a simple product and a table lookup
+  //
+  // -----------|
+  // --|Table|-|Product|-
+  //
+
+  Product* product = new Product("Product");
+  getModelGroup()->addModel(product);
+
+  mTable = new Table1D("Table");
+  getModelGroup()->addModel(mTable);
+  product->getInputPort(0)->connect(mTable->getOutputPort(0));
+
+  // Now connect the input and the output to this groups in and outputs
+  getModelGroup()->setNumInputPorts(2);
+  getModelGroup()->getInputPort(1)->setName("Schedule Input");
+  mTable->getInputPort(0)->connect(getModelGroup()->getInputPort(1));
+
+  getModelGroup()->getInputPort(0)->setName("Input");
+  product->getInputPort(1)->connect(getModelGroup()->getInputPort(0));
+
+  // That single output port is this one
+  getOutputPort()->connect(product->getOutputPort(0));
+}
+
+JSBSimScheduledGain::~JSBSimScheduledGain(void)
+{
+}
+
+void
+JSBSimScheduledGain::setTableData(const TableData<1>& tableData,
+                                  const TableLookup& lookup)
+{
+  mTable->setTableData(tableData);
+  mTable->setTableLookup(lookup);
+}
+
+} //namespace OpenFDM


Property changes on: trunk/OpenFDM/src/JSBSim/JSBSimScheduledGain.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/OpenFDM/src/JSBSim/JSBSimScheduledGain.h
===================================================================
--- trunk/OpenFDM/src/JSBSim/JSBSimScheduledGain.h	2005-11-27 20:31:10 UTC (rev 79)
+++ trunk/OpenFDM/src/JSBSim/JSBSimScheduledGain.h	2005-11-28 19:37:39 UTC (rev 80)
@@ -0,0 +1,33 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_JSBSimScheduledGain_H
+#define OpenFDM_JSBSimScheduledGain_H
+
+#include "JSBSimFCSComponent.h"
+
+namespace OpenFDM {
+
+class Table1D;
+template<unsigned>
+class TableData;
+class TableLookup;
+
+/// Just a small container mapping the JSBSim ScheduledGain parameters to
+/// the OpenFDM models.
+class JSBSimScheduledGain :
+    public JSBSimFCSComponent {
+public:
+  JSBSimScheduledGain(const std::string& name);
+  virtual ~JSBSimScheduledGain(void);
+
+  void setTableData(const TableData<1>& tableData, const TableLookup& lookup);
+
+private:
+  shared_ptr<Table1D> mTable;
+};
+
+} //namespace OpenFDM
+
+#endif


Property changes on: trunk/OpenFDM/src/JSBSim/JSBSimScheduledGain.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp
===================================================================
--- trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2005-11-27 20:31:10 UTC (rev 79)
+++ trunk/OpenFDM/src/JSBSim/LegacyJSBSimReader.cpp	2005-11-28 19:37:39 UTC (rev 80)
@@ -46,6 +46,7 @@
 
 #include "JSBSimAerosurfaceScale.h"
 #include "JSBSimKinemat.h"
+#include "JSBSimScheduledGain.h"
 
 #include "LegacyJSBSimReader.h"
 
@@ -1130,10 +1131,9 @@
   shared_ptr<Summer> summer;
   shared_ptr<Gain> gain;
   shared_ptr<DiscreteTransferFunction> discreteTransfFunc;
-  shared_ptr<Table1D> table1D;
-  shared_ptr<Saturation> inputSaturation;
   shared_ptr<JSBSimAerosurfaceScale> asScale;
   shared_ptr<JSBSimKinemat> kinemat;
+  shared_ptr<JSBSimScheduledGain> sGain;
 
   // The final output property.
   shared_ptr<Port> out;
@@ -1194,13 +1194,10 @@
     addFCSModel(model);
     out = asScale->getOutputPort();
     normOut = asScale->getOutputNormPort();
+
   } else if (type == "SCHEDULED_GAIN") {
-    Product* prod = new Product(name);
-    prod->setNumFactors(2);
-    table1D = new Table1D(std::string("Lookup table for ") + name);
-    addFCSModel(table1D);
-    prod->getInputPort(1)->connect(table1D->getOutputPort(0));
-    model = prod;
+    sGain = new JSBSimScheduledGain(name);
+    model = sGain->getModelGroup();
     addFCSModel(model);
     out = model->getOutputPort(0);
 
@@ -1565,16 +1562,13 @@
       if (!parseTable1D(datastr, tableData, lookup))
         return error("Cannot parse lookup table for \"" + type + "\"");
 
-      if (table1D) {
-        table1D->setTableData(tableData);
-        table1D->setTableLookup(lookup);
-      }
+      sGain->setTableData(tableData, lookup);
 
     } else if (token == "SCHEDULED_BY") {
       datastr >> token;
       
-      if (table1D) {
-        table1D->getInputPort(0)->connect(lookupJSBExpression(token));
+      if (sGain) {
+        model->getInputPort(1)->connect(lookupJSBExpression(token));
       } else
         return error("SCHEDULED_BY without table ??");
       

Modified: trunk/OpenFDM/src/JSBSim/Makefile.am
===================================================================
--- trunk/OpenFDM/src/JSBSim/Makefile.am	2005-11-27 20:31:10 UTC (rev 79)
+++ trunk/OpenFDM/src/JSBSim/Makefile.am	2005-11-28 19:37:39 UTC (rev 80)
@@ -12,6 +12,7 @@
   JSBSimFCSComponent.h \
   JSBSimAerosurfaceScale.h \
   JSBSimKinemat.h \
+  JSBSimScheduledGain.h \
   LegacyJSBSimReader.h
 
 lib_LTLIBRARIES = libJSBReader.la
@@ -19,4 +20,5 @@
   JSBSimFCSComponent.cpp \
   JSBSimAerosurfaceScale.cpp \
   JSBSimKinemat.cpp \
+  JSBSimScheduledGain.cpp \
   LegacyJSBSimReader.cpp

Modified: trunk/OpenFDM/src/OpenFDM/Model.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Model.h	2005-11-27 20:31:10 UTC (rev 79)
+++ trunk/OpenFDM/src/OpenFDM/Model.h	2005-11-28 19:37:39 UTC (rev 80)
@@ -24,6 +24,11 @@
 class Input;
 class Output;
 
+/// Class for an inout or output port of a Model.
+/// Ports can be connected together. This means in effect that the reader
+/// gains access to value at the source model.
+/// Additional information must be carried through that class.
+/// ...
 class Port :
     public Object {
 public:



From frohlich at berlios.de  Tue Nov 29 20:15:03 2005
From: frohlich at berlios.de (frohlich at berlios.de)
Date: Tue, 29 Nov 2005 20:15:03 +0100
Subject: [OpenFDM-svn] r81 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200511291915.jATJF373021612@sheep.berlios.de>

Author: frohlich
Date: 2005-11-29 20:14:59 +0100 (Tue, 29 Nov 2005)
New Revision: 81

Added:
   trunk/OpenFDM/src/OpenFDM/CowPtr.h
Modified:
   trunk/OpenFDM/src/OpenFDM/Makefile.am
Log:
Add copy on write helper.


Added: trunk/OpenFDM/src/OpenFDM/CowPtr.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/CowPtr.h	2005-11-28 19:37:39 UTC (rev 80)
+++ trunk/OpenFDM/src/OpenFDM/CowPtr.h	2005-11-29 19:14:59 UTC (rev 81)
@@ -0,0 +1,44 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2005 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_CowPtr_H
+#define OpenFDM_CowPtr_H
+
+#include "Assert.h"
+#include "Referenced.h"
+#include "RefPtr.h"
+
+namespace OpenFDM {
+
+/// Helper template for a copy on write handle to some class.
+/// The class cannot be used by itself, it is intendend to be a bease class
+/// a copy on write handle can be derived from.
+/// The template argument is assumed to be derived from Referenced and
+/// it must implement a clone method.
+/// You can use this class on a simple handle class forwarding it's accesses
+/// to the original class as well as it can be used on a hierarchy of classes
+/// implementing its destructors and clone method as a virtual class member.
+template<typename T>
+class CowPtr {
+protected:
+  explicit CowPtr(T* ptr) : mPtr(ptr)
+  { OpenFDMAssert(mPtr); }
+
+  T* ptr(void)
+  {
+    if (mPtr->isShared())
+      mPtr = mPtr->clone();
+    return mPtr;
+  }
+
+  const T* ptr(void) const
+  { return mPtr; }
+
+private:
+  shared_ptr<T> mPtr;
+};
+
+} // namespace OpenFDM
+
+#endif


Property changes on: trunk/OpenFDM/src/OpenFDM/CowPtr.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/OpenFDM/src/OpenFDM/Makefile.am
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Makefile.am	2005-11-28 19:37:39 UTC (rev 80)
+++ trunk/OpenFDM/src/OpenFDM/Makefile.am	2005-11-29 19:14:59 UTC (rev 81)
@@ -35,6 +35,7 @@
   ConstantForce.h \
   ConstSystem.h \
   ConstVisitor.h \
+  CowPtr.h \
   DeadBand.h \
   DefaultGravity.h \
   DefaultGround.h \



