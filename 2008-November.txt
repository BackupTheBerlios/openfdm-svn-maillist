From frohlich at mail.berlios.de  Mon Nov  3 23:08:14 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Mon, 3 Nov 2008 23:08:14 +0100
Subject: [OpenFDM-svn] r658 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811032208.mA3M8ERZ010973@sheep.berlios.de>

Author: frohlich
Date: 2008-11-03 23:08:13 +0100 (Mon, 03 Nov 2008)
New Revision: 658

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Joint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Joint.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicContext.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.h
Log:
Remove unused argument.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Joint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Joint.cpp	2008-10-28 11:58:32 UTC (rev 657)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Joint.cpp	2008-11-03 22:08:13 UTC (rev 658)
@@ -34,10 +34,10 @@
 void
 Joint::velocity(const Task&,
                 const ContinousStateValueVector& continousState,
-                PortValueList& portValues, FrameData& frameData) const
+                PortValueList& portValues) const
 {
   velocity(portValues[mParentLink], portValues[mChildLink],
-           continousState, portValues, frameData);
+           continousState, portValues);
 }
 
 void

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Joint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Joint.h	2008-10-28 11:58:32 UTC (rev 657)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Joint.h	2008-11-03 22:08:13 UTC (rev 658)
@@ -18,9 +18,6 @@
 
 namespace OpenFDM {
 
-/// FIXME: joint's should be lockable, which means trylock == true and
-/// velocity small enough - keep position ...
-
 class Joint : public Interact {
   OPENFDM_OBJECT(Joint, Interact);
 public:
@@ -32,8 +29,7 @@
   virtual void velocity(const MechanicLinkValue& parentLink,
                         MechanicLinkValue& childLink,
                         const ContinousStateValueVector& states,
-                        PortValueList& portValues,
-                        FrameData& frameData) const = 0;
+                        PortValueList& portValues) const = 0;
   virtual void articulation(MechanicLinkValue& parentLink,
                             const MechanicLinkValue& childLink,
                             const ContinousStateValueVector& states,
@@ -47,7 +43,7 @@
 
   /// They implement the mechanic stuff
   virtual void velocity(const Task&, const ContinousStateValueVector&,
-                        PortValueList&, FrameData&) const;
+                        PortValueList&) const;
   virtual void articulation(const Task&, const ContinousStateValueVector&,
                             PortValueList&, FrameData&) const;
   virtual void acceleration(const Task&, const ContinousStateValueVector&,

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicContext.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicContext.h	2008-10-28 11:58:32 UTC (rev 657)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicContext.h	2008-11-03 22:08:13 UTC (rev 658)
@@ -35,12 +35,12 @@
   void initVelocities(const /*Init*/Task& task)
   {
     mMechanicNode->init(task, mDiscreteState, mContinousState, mPortValueList);
-    mMechanicNode->velocity(task, mContinousState, mPortValueList, mFrameData);
+    mMechanicNode->velocity(task, mContinousState, mPortValueList);
   }
 
   void velocities(const Task& task)
   {
-    mMechanicNode->velocity(task, mContinousState, mPortValueList, mFrameData);
+    mMechanicNode->velocity(task, mContinousState, mPortValueList);
   }
   void articulation(const Task& task)
   {

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.h	2008-10-28 11:58:32 UTC (rev 657)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.h	2008-11-03 22:08:13 UTC (rev 658)
@@ -30,7 +30,7 @@
   virtual MechanicContext* newMechanicContext() const;
 
   virtual void velocity(const Task&, const ContinousStateValueVector&,
-                        PortValueList&, FrameData&) const
+                        PortValueList&) const
   { }
   virtual void articulation(const Task&, const ContinousStateValueVector&,
                             PortValueList&, FrameData&) const

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.cpp	2008-10-28 11:58:32 UTC (rev 657)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.cpp	2008-11-03 22:08:13 UTC (rev 658)
@@ -72,8 +72,7 @@
 RevoluteJoint::velocity(const MechanicLinkValue& parentLink,
                         MechanicLinkValue& childLink,
                         const ContinousStateValueVector& states,
-                        PortValueList& portValues,
-                        FrameData& frameData) const
+                        PortValueList& portValues) const
 {
   VectorN jointPos = states[*mPositionStateInfo];
   if (!mPositionPort.empty())

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.h	2008-10-28 11:58:32 UTC (rev 657)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.h	2008-11-03 22:08:13 UTC (rev 658)
@@ -52,8 +52,7 @@
   virtual void velocity(const MechanicLinkValue& parentLink,
                         MechanicLinkValue& childLink,
                         const ContinousStateValueVector& states,
-                        PortValueList& portValues,
-                        FrameData& frameData) const;
+                        PortValueList& portValues) const;
   virtual void articulation(MechanicLinkValue& parentLink,
                             const MechanicLinkValue& childLink,
                             const ContinousStateValueVector& states,



From frohlich at mail.berlios.de  Tue Nov  4 08:12:51 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Tue, 4 Nov 2008 08:12:51 +0100
Subject: [OpenFDM-svn] r659 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811040712.mA47Cp9L006494@sheep.berlios.de>

Author: frohlich
Date: 2008-11-04 08:12:49 +0100 (Tue, 04 Nov 2008)
New Revision: 659

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Joint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Joint.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Mass.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Mass.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicContext.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJoint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJoint.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/RigidBody.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/RigidBody.h
Log:
Clean up the mechanic system interface a bit.
More to come.

M    src/OpenFDM/MobileRootJoint.cpp
M    src/OpenFDM/Joint.cpp
M    src/OpenFDM/Mass.h
M    src/OpenFDM/Mass.cpp
M    src/OpenFDM/RigidBody.h
M    src/OpenFDM/MechanicContext.h
M    src/OpenFDM/MobileRootJoint.h
M    src/OpenFDM/RevoluteJoint.cpp
M    src/OpenFDM/RigidBody.cpp
M    src/OpenFDM/RevoluteJoint.h
M    src/OpenFDM/MechanicNode.h
M    src/OpenFDM/Joint.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Joint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Joint.cpp	2008-11-03 22:08:13 UTC (rev 658)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Joint.cpp	2008-11-04 07:12:49 UTC (rev 659)
@@ -43,19 +43,20 @@
 void
 Joint::articulation(const Task&,
                     const ContinousStateValueVector& continousState,
-                    PortValueList& portValues, FrameData& frameData) const
+                    PortValueList& portValues, Matrix& hIh) const
 {
   articulation(portValues[mParentLink], portValues[mChildLink],
-               continousState, portValues, frameData);
+               continousState, portValues, hIh);
 }
 
 void
 Joint::acceleration(const Task&,
                     const ContinousStateValueVector& continousState,
-                    PortValueList& portValues, FrameData& frameData) const
+                    PortValueList& portValues, const Matrix& hIh,
+                    Vector& velDot) const
 {
   acceleration(portValues[mParentLink], portValues[mChildLink],
-               continousState, portValues, frameData);
+               continousState, portValues, hIh, velDot);
 }
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Joint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Joint.h	2008-11-03 22:08:13 UTC (rev 658)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Joint.h	2008-11-04 07:12:49 UTC (rev 659)
@@ -34,20 +34,21 @@
                             const MechanicLinkValue& childLink,
                             const ContinousStateValueVector& states,
                             PortValueList& portValues,
-                            FrameData& frameData) const = 0;
+                            Matrix& hIh) const = 0;
   virtual void acceleration(const MechanicLinkValue& parentLink,
                             MechanicLinkValue& childLink,
                             const ContinousStateValueVector& states,
                             PortValueList& portValues,
-                            FrameData& frameData) const = 0;
+                            const Matrix& hIh, Vector& velDot) const = 0;
 
   /// They implement the mechanic stuff
   virtual void velocity(const Task&, const ContinousStateValueVector&,
                         PortValueList&) const;
   virtual void articulation(const Task&, const ContinousStateValueVector&,
-                            PortValueList&, FrameData&) const;
+                            PortValueList&, Matrix& hIh) const;
   virtual void acceleration(const Task&, const ContinousStateValueVector&,
-                            PortValueList&, FrameData&) const;
+                            PortValueList&, const Matrix& hIh,
+                            Vector& velDot) const;
 private:
   MechanicLink mParentLink;
   MechanicLink mChildLink;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Mass.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Mass.cpp	2008-11-03 22:08:13 UTC (rev 658)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Mass.cpp	2008-11-04 07:12:49 UTC (rev 659)
@@ -33,7 +33,7 @@
 
 void
 Mass::articulation(const Task&, const ContinousStateValueVector&,
-                   PortValueList& portValues, FrameData&) const
+                   PortValueList& portValues, Matrix&) const
 {
   // FIXME: Hardcoding that gravity happens in the roots??
   // Vectro3 position = portValues[mMechanicLink].mPosition;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Mass.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Mass.h	2008-11-03 22:08:13 UTC (rev 658)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Mass.h	2008-11-04 07:12:49 UTC (rev 659)
@@ -19,7 +19,7 @@
   virtual ~Mass(void);
 
   virtual void articulation(const Task&, const ContinousStateValueVector&,
-                            PortValueList&, FrameData&) const;
+                            PortValueList&, Matrix&) const;
 
   const InertiaMatrix& getInertia(void) const;
   void setInertia(const InertiaMatrix& inertia);

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicContext.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicContext.h	2008-11-03 22:08:13 UTC (rev 658)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicContext.h	2008-11-04 07:12:49 UTC (rev 659)
@@ -18,11 +18,6 @@
 class DiscreteTask;
 class InitTask;
 
-struct FrameData {
-  Matrix hIh;
-  Vector velDot;
-};
-
 class MechanicContext : public LeafContext {
 public:
   MechanicContext(const MechanicNode* mechanicNode);
@@ -44,17 +39,17 @@
   }
   void articulation(const Task& task)
   {
-    mMechanicNode->articulation(task, mContinousState, mPortValueList, mFrameData);
+    mMechanicNode->articulation(task, mContinousState, mPortValueList, hIh);
   }
   void accelerations(const Task& task)
   {
-    mMechanicNode->acceleration(task, mContinousState, mPortValueList, mFrameData);
+    mMechanicNode->acceleration(task, mContinousState, mPortValueList, hIh, velDot);
   }
 
   void derivative(const Task&)
   {
     mMechanicNode->derivative(mDiscreteState, mContinousState, mPortValueList,
-                              mFrameData, mContinousStateDerivative);
+                              velDot, mContinousStateDerivative);
   }
  
   void update(const DiscreteTask& discreteTask)
@@ -67,7 +62,8 @@
 
 private:
   // Stores some values persistent accross velocity/articulation/acceleration
-  FrameData mFrameData;
+  Matrix hIh;
+  Vector velDot;
 
   SharedPtr<const MechanicNode> mMechanicNode;
 

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.h	2008-11-03 22:08:13 UTC (rev 658)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.h	2008-11-04 07:12:49 UTC (rev 659)
@@ -15,7 +15,6 @@
 class PortValueList;
 class Task;
 class MechanicContext;
-class FrameData;
 
 class MechanicNode : public LeafNode {
   OPENFDM_OBJECT(MechanicNode, LeafNode);
@@ -33,15 +32,15 @@
                         PortValueList&) const
   { }
   virtual void articulation(const Task&, const ContinousStateValueVector&,
-                            PortValueList&, FrameData&) const
+                            PortValueList&, Matrix&) const
   { }
   // hmm, may be this should be output???
   virtual void acceleration(const Task&, const ContinousStateValueVector&,
-                            PortValueList&, FrameData&) const
+                            PortValueList&, const Matrix&, Vector&) const
   { }
   virtual void derivative(const DiscreteStateValueVector&,
                           const ContinousStateValueVector&,
-                          const PortValueList&, FrameData&,
+                          const PortValueList&, const Vector&,
                           ContinousStateValueVector&) const
   { }
   virtual void update(const DiscreteTask&, DiscreteStateValueVector&,

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJoint.cpp	2008-11-03 22:08:13 UTC (rev 658)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJoint.cpp	2008-11-04 07:12:49 UTC (rev 659)
@@ -49,7 +49,7 @@
 void
 MobileRootJoint::velocity(const Task&,
                           const ContinousStateValueVector& continousState,
-                          PortValueList& portValues, FrameData&) const
+                          PortValueList& portValues) const
 {
   Vector3 position = continousState[*mPositionStateInfo];
   Quaternion orientation = continousState[*mOrientationStateInfo];
@@ -61,7 +61,7 @@
 
 void
 MobileRootJoint::articulation(const Task&, const ContinousStateValueVector&,
-                              PortValueList&, FrameData&) const
+                              PortValueList&, Matrix&) const
 {
   /// In this case a noop.
 }
@@ -69,7 +69,7 @@
 void
 MobileRootJoint::acceleration(const Task&, const ContinousStateValueVector&,
                               PortValueList& portValues,
-                              FrameData&) const
+                              const Matrix&, Vector&) const
 {
   // Assumption: body is small compared to the distance to the planets
   // center of mass. That means gravity could be considered equal for the
@@ -92,7 +92,7 @@
 MobileRootJoint::derivative(const DiscreteStateValueVector&,
                             const ContinousStateValueVector& continousState,
                             const PortValueList& portValues,
-                            FrameData& context,
+                            const Vector& context,
                             ContinousStateValueVector& derivatives) const
 {
   Quaternion orientation = continousState[*mOrientationStateInfo];

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJoint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJoint.h	2008-11-03 22:08:13 UTC (rev 658)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJoint.h	2008-11-04 07:12:49 UTC (rev 659)
@@ -26,14 +26,15 @@
                     ContinousStateValueVector&,
                     const PortValueList&) const;
   virtual void velocity(const Task&, const ContinousStateValueVector& states,
-                        PortValueList& portValues, FrameData&) const;
+                        PortValueList& portValues) const;
   virtual void articulation(const Task&, const ContinousStateValueVector&,
-                            PortValueList& portValues, FrameData&) const;
+                            PortValueList& portValues, Matrix&) const;
   virtual void acceleration(const Task&, const ContinousStateValueVector&,
-                            PortValueList& portValues, FrameData&) const;
+                            PortValueList& portValues, const Matrix&,
+                            Vector&) const;
   virtual void derivative(const DiscreteStateValueVector&,
                           const ContinousStateValueVector&,
-                          const PortValueList& portValues, FrameData&,
+                          const PortValueList& portValues, const Vector&,
                           ContinousStateValueVector&) const;
 private:
   MechanicLink mMechanicLink;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.cpp	2008-11-03 22:08:13 UTC (rev 658)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.cpp	2008-11-04 07:12:49 UTC (rev 659)
@@ -94,7 +94,7 @@
                             const MechanicLinkValue& childLink,
                             const ContinousStateValueVector& states,
                             PortValueList& portValues,
-                            FrameData& frameData) const
+                            Matrix& hIh) const
 {
   VectorN jointForce;
   if (mForcePort.empty())
@@ -110,15 +110,15 @@
 
   // Compute the projection to the joint coordinate space
   Matrix6N Ih = I*mJointMatrix;
-  frameData.hIh = trans(mJointMatrix)*Ih;
-  MatrixFactorsNN hIh = MatrixNN(frameData.hIh);
+  hIh = trans(mJointMatrix)*Ih;
+  MatrixFactorsNN hIhFac = MatrixNN(hIh);
 
   // Note that the momentum of the local mass is already included in the
   // child links force due the the mass model ...
   Vector6 mPAlpha = childLink.getForce() + I*childLink.getFrame().getHdot();
   Vector6 force = mPAlpha;
 
-  if (hIh.singular()) {
+  if (hIhFac.singular()) {
     Log(ArtBody,Error) << "Detected singular mass matrix for "
                        << "CartesianJointFrame \"" << getName()
                        << "\": Fix your model!" << endl;
@@ -126,8 +126,8 @@
   }
   
   // Project away the directions handled with this current joint
-  force -= Ih*hIh.solve(trans(mJointMatrix)*mPAlpha - jointForce);
-  I -= SpatialInertia(Ih*hIh.solve(trans(Ih)));
+  force -= Ih*hIhFac.solve(trans(mJointMatrix)*mPAlpha - jointForce);
+  I -= SpatialInertia(Ih*hIhFac.solve(trans(Ih)));
 
   // Transform to parent link's coordinates and apply to the parent link
   parentLink.applyForce(childLink.getFrame().forceToParent(force));
@@ -139,32 +139,31 @@
                             MechanicLinkValue& childLink,
                             const ContinousStateValueVector& states,
                             PortValueList& portValues,
-                            FrameData& frameData) const
+                            const Matrix& hIh, Vector& velDot) const
 {
   Vector6 parentSpAccel
     = childLink.getFrame().motionFromParent(parentLink.getFrame().getSpAccel());
 
   Vector6 f = childLink.getForce();
   f += childLink.getInertia()*(parentSpAccel + childLink.getFrame().getHdot());
-  MatrixFactorsNN hIh = MatrixNN(frameData.hIh);
+  MatrixFactorsNN hIhFac = MatrixNN(hIh);
   VectorN jointForce;
   if (mForcePort.empty())
     jointForce.clear();
   else
     jointForce = portValues[mForcePort];
-  VectorN velDot = hIh.solve(jointForce - trans(mJointMatrix)*f);
-  frameData.velDot = velDot;
+  velDot = hIhFac.solve(jointForce - trans(mJointMatrix)*f);
   childLink.setAccel(parentLink, mJointMatrix*velDot);
 }
 
 void
 RevoluteJoint::derivative(const DiscreteStateValueVector&,
                           const ContinousStateValueVector& states,
-                          const PortValueList&, FrameData& frameData,
+                          const PortValueList&, const Vector& velDot,
                           ContinousStateValueVector& derivative) const
 {
   derivative[*mPositionStateInfo] = states[*mVelocityStateInfo];
-  derivative[*mVelocityStateInfo] = frameData.velDot;
+  derivative[*mVelocityStateInfo] = velDot;
 }
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.h	2008-11-03 22:08:13 UTC (rev 658)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.h	2008-11-04 07:12:49 UTC (rev 659)
@@ -57,16 +57,16 @@
                             const MechanicLinkValue& childLink,
                             const ContinousStateValueVector& states,
                             PortValueList& portValues,
-                            FrameData& frameData) const;
+                            Matrix& hIh) const;
   virtual void acceleration(const MechanicLinkValue& parentLink,
                             MechanicLinkValue& childLink,
                             const ContinousStateValueVector& states,
                             PortValueList& portValues,
-                            FrameData& frameData) const;
+                            const Matrix& hIh, Vector& velDot) const;
 
   virtual void derivative(const DiscreteStateValueVector&,
                           const ContinousStateValueVector&,
-                          const PortValueList& portValues, FrameData&,
+                          const PortValueList& portValues, const Vector& velDot,
                           ContinousStateValueVector&) const;
 
 private:

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RigidBody.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RigidBody.cpp	2008-11-03 22:08:13 UTC (rev 658)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RigidBody.cpp	2008-11-04 07:12:49 UTC (rev 659)
@@ -59,7 +59,7 @@
 
 void
 RigidBody::velocity(const Task&, const ContinousStateValueVector&,
-                    PortValueList& portValues, FrameData&) const
+                    PortValueList& portValues) const
 {
   unsigned numLinkValues = mMechanicLinks.size();
   const MechanicLinkValue& parentLink = portValues[mMechanicLinks.front()];
@@ -69,7 +69,7 @@
 
 void
 RigidBody::articulation(const Task&, const ContinousStateValueVector&,
-                        PortValueList& portValues, FrameData&) const
+                        PortValueList& portValues, Matrix&) const
 {
   unsigned numLinkValues = mMechanicLinks.size();
   MechanicLinkValue& parentLink = portValues[mMechanicLinks.front()];
@@ -79,7 +79,7 @@
 
 void
 RigidBody::acceleration(const Task&, const ContinousStateValueVector&,
-                        PortValueList& portValues, FrameData&) const
+                        PortValueList& portValues, const Matrix&, Vector&) const
 {
   unsigned numLinkValues = mMechanicLinks.size();
   const MechanicLinkValue& parentLink = portValues[mMechanicLinks.front()];

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RigidBody.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RigidBody.h	2008-11-03 22:08:13 UTC (rev 658)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RigidBody.h	2008-11-04 07:12:49 UTC (rev 659)
@@ -31,11 +31,12 @@
   /// parent link???
 
   virtual void velocity(const Task&, const ContinousStateValueVector& states,
-                        PortValueList& portValues, FrameData&) const;
+                        PortValueList& portValues) const;
   virtual void articulation(const Task&, const ContinousStateValueVector&,
-                            PortValueList& portValues, FrameData&) const;
+                            PortValueList& portValues, Matrix&) const;
   virtual void acceleration(const Task&, const ContinousStateValueVector&,
-                            PortValueList& portValues, FrameData&) const;
+                            PortValueList& portValues, const Matrix&,
+                            Vector&) const;
 private:
   typedef std::vector<MechanicLink> MechanicLinkVector;
   MechanicLinkVector mMechanicLinks;



From frohlich at mail.berlios.de  Tue Nov  4 20:09:43 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Tue, 4 Nov 2008 20:09:43 +0100
Subject: [OpenFDM-svn] r660 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811041909.mA4J9h9e000123@sheep.berlios.de>

Author: frohlich
Date: 2008-11-04 20:09:42 +0100 (Tue, 04 Nov 2008)
New Revision: 660

Added:
   branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h
Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicContext.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.h
Log:
Factor out an cartesian axis aligned Joint ...

A    src/OpenFDM/CartesianJoint.h
M    src/OpenFDM/Makefile.am
M    src/OpenFDM/MechanicContext.h
M    src/OpenFDM/RevoluteJoint.cpp
M    src/OpenFDM/RevoluteJoint.h
M    src/OpenFDM/MechanicNode.h


Added: branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h	2008-11-04 07:12:49 UTC (rev 659)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h	2008-11-04 19:09:42 UTC (rev 660)
@@ -0,0 +1,108 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_CartesianJoint_H
+#define OpenFDM_CartesianJoint_H
+
+#include "Assert.h"
+#include "Object.h"
+#include "Vector.h"
+#include "Matrix.h"
+#include "MatrixStateInfo.h"
+#include "Quaternion.h"
+#include "Inertia.h"
+#include "Joint.h"
+#include "MechanicContext.h"
+
+namespace OpenFDM {
+
+template<unsigned n>
+class CartesianJoint : public Joint {
+public:
+  typedef LinAlg::Vector<real_type,n> VectorN;
+  typedef LinAlg::Matrix<real_type,6,n> Matrix6N;
+  typedef LinAlg::Matrix<real_type,n,n> MatrixNN;
+  typedef LinAlg::MatrixFactors<real_type,n,n,LinAlg::LUTag> MatrixFactorsNN;
+
+protected:
+  CartesianJoint(const std::string& name, const Matrix6N& jointMatrix) :
+    Joint(name),
+    mJointMatrix(jointMatrix)
+  { }
+  virtual ~CartesianJoint(void)
+  { }
+
+  const Matrix6N& getJointMatrix() const
+  { return mJointMatrix; }
+  void setJointMatrix(const Matrix6N& jointMatrix)
+  { mJointMatrix = jointMatrix; }
+
+  // Minimal implementation, factored out all unneeded
+  void velocity(const MechanicLinkValue& parentLink,
+                MechanicLinkValue& childLink, const Vector3& position,
+                const Quaternion& orientation, const Vector6& vel) const
+  {
+    childLink.setPosAndVel(parentLink, position, orientation, vel);
+  }
+
+  
+  // Minimal implementation, factored out all unneeded
+  void articulation(MechanicLinkValue& parentLink,
+                    const MechanicLinkValue& childLink,
+                    const VectorN& jointForce,
+                    Matrix& hIh) const
+  {
+    // The formulas conform to Roy Featherstones book eqn (6.37), (6.38)
+    
+    // Store the outboard values since we will need them later in velocity
+    // derivative computations
+    SpatialInertia I = childLink.getInertia();
+    
+    // Compute the projection to the joint coordinate space
+    Matrix6N Ih = I*mJointMatrix;
+    hIh = trans(mJointMatrix)*Ih;
+    MatrixFactorsNN hIhFac = MatrixNN(hIh);
+    
+    // Note that the momentum of the local mass is already included in the
+    // child links force due the the mass model ...
+    Vector6 pAlpha = childLink.getForce() + I*childLink.getFrame().getHdot();
+    Vector6 force = pAlpha;
+    
+    if (hIhFac.singular()) {
+      Log(ArtBody,Error) << "Detected singular mass matrix for "
+                         << "CartesianJointFrame \"" << getName()
+                         << "\": Fix your model!" << endl;
+      return;
+    }
+    
+    // Project away the directions handled with this current joint
+    force -= Ih*hIhFac.solve(trans(mJointMatrix)*pAlpha - jointForce);
+    I -= SpatialInertia(Ih*hIhFac.solve(trans(Ih)));
+    
+    // Transform to parent link's coordinates and apply to the parent link
+    parentLink.applyForce(childLink.getFrame().forceToParent(force));
+    parentLink.applyInertia(childLink.getFrame().inertiaToParent(I));
+  }
+
+  void acceleration(const MechanicLinkValue& parentLink,
+                    MechanicLinkValue& childLink, const VectorN& jointForce,
+                    const Matrix& hIh, Vector& velDot) const
+  {
+    Vector6 parentSpAccel
+      = childLink.getFrame().motionFromParent(parentLink.getFrame().getSpAccel());
+    
+    Vector6 f = childLink.getForce();
+    f += childLink.getInertia()*(parentSpAccel + childLink.getFrame().getHdot());
+    MatrixFactorsNN hIhFac = MatrixNN(hIh);
+    velDot = hIhFac.solve(jointForce - trans(mJointMatrix)*f);
+    childLink.setAccel(parentLink, mJointMatrix*velDot);
+  }
+  
+private:
+  Matrix6N mJointMatrix;
+};
+
+} // namespace OpenFDM
+
+#endif

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-11-04 07:12:49 UTC (rev 659)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-11-04 19:09:42 UTC (rev 660)
@@ -182,6 +182,7 @@
   AtmosphereSTD1976.h \
   Bias.h \
   BinaryFunctionModel.h \
+  CartesianJoint.h \
   ConstModel.h \
   Contact.h \
   DeadBand.h \

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicContext.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicContext.h	2008-11-04 07:12:49 UTC (rev 659)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicContext.h	2008-11-04 19:09:42 UTC (rev 660)
@@ -25,40 +25,40 @@
 
   virtual const MechanicNode& getNode() const;
 
-  bool alloc()
+  virtual bool alloc()
   { if (!allocStates()) return false; return mMechanicNode->alloc(*this); }
-  void initVelocities(const /*Init*/Task& task)
+  virtual void initVelocities(const /*Init*/Task& task)
   {
     mMechanicNode->init(task, mDiscreteState, mContinousState, mPortValueList);
     mMechanicNode->velocity(task, mContinousState, mPortValueList);
   }
 
-  void velocities(const Task& task)
+  virtual void velocities(const Task& task)
   {
     mMechanicNode->velocity(task, mContinousState, mPortValueList);
   }
-  void articulation(const Task& task)
+  virtual void articulation(const Task& task)
   {
     mMechanicNode->articulation(task, mContinousState, mPortValueList, hIh);
   }
-  void accelerations(const Task& task)
+  virtual void accelerations(const Task& task)
   {
     mMechanicNode->acceleration(task, mContinousState, mPortValueList, hIh, velDot);
   }
 
-  void derivative(const Task&)
+  virtual void derivative(const Task&)
   {
     mMechanicNode->derivative(mDiscreteState, mContinousState, mPortValueList,
                               velDot, mContinousStateDerivative);
   }
  
-  void update(const DiscreteTask& discreteTask)
+  virtual void update(const DiscreteTask& discreteTask)
   {
     mMechanicNode->update(discreteTask, mDiscreteState,
                           mContinousState, mPortValueList);
   }
 
-  bool isConnectedTo(const MechanicContext& mechanicContext) const;
+  virtual bool isConnectedTo(const MechanicContext& mechanicContext) const;
 
 private:
   // Stores some values persistent accross velocity/articulation/acceleration

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.h	2008-11-04 07:12:49 UTC (rev 659)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.h	2008-11-04 19:09:42 UTC (rev 660)
@@ -11,6 +11,46 @@
 
 namespace OpenFDM {
 
+// Ok, types of mechanic nodes:
+// Joints, mostly two ports need ordered execution
+// RigidBody, no own logic, just moving ports from parent to children.
+//   should not show up in computations at all
+// Interact, forces internal, external, mass, sensor, no ordering required,
+//   could execute parallel
+
+// For contexts:
+// JointContext has internal data for the AB algorithm
+// No RigidBody context at all
+// Interact, something similar we have now for the mechanic context??
+
+// Current inheritence tree:
+// Leaf - Model ...
+//      |
+//      |- MechanicNode -- RigidBody
+//                      |- Interact  -- Mass
+//                                   |- Force
+//                                   |- Joint
+//                                   |- RootJoint
+
+// Desired inheritence tree:
+// Leaf?- Model ...
+//      |
+//      |- MechanicNode?-- RigidBody
+//                      |
+//                      |- Interact  -- Mass
+//                      |            |- Sensor
+//                      |            |- Force
+//                      |
+//                      |- Joint ------ RootJoint
+//                                   |- CartesianJoint -- RevoluteJoint
+//                                                     | ...
+
+
+// TODO:
+// * Remove AbstractNodeContext ...
+// * Make Inheritance for mechanics like that ...
+// * allocate contexts later ...
+
 class DiscreteTask;
 class PortValueList;
 class Task;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.cpp	2008-11-04 07:12:49 UTC (rev 659)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.cpp	2008-11-04 19:09:42 UTC (rev 660)
@@ -22,7 +22,7 @@
   END_OPENFDM_OBJECT_DEF
 
 RevoluteJoint::RevoluteJoint(const std::string& name) :
-  Joint(name),
+  CartesianJoint<1>(name, Vector6(Vector3(1, 0, 0), Vector3::zeros())),
   mForcePort(this, "force", Size(1, 1), true),
   mPositionPort(this, "position", Size(1, 1)),
   mVelocityPort(this, "velocity", Size(1, 1)),
@@ -56,7 +56,7 @@
     return;
   }
   mAxis = (1/nrm)*axis;
-  mJointMatrix = Vector6(mAxis, Vector3::zeros());
+  setJointMatrix(Vector6(mAxis, Vector3::zeros()));
 }
 
 void
@@ -77,16 +77,15 @@
   VectorN jointPos = states[*mPositionStateInfo];
   if (!mPositionPort.empty())
     portValues[mPositionPort] = jointPos;
-
+  
   VectorN jointVel = states[*mVelocityStateInfo];
   if (!mVelocityPort.empty())
     portValues[mVelocityPort] = jointVel;
-
+  
   Vector3 position(0, 0, 0);
   Quaternion orientation(Quaternion::fromAngleAxis(jointPos(0), mAxis));
-  Vector6 velocity(mAxis*jointVel, Vector3::zeros());
 
-  childLink.setPosAndVel(parentLink, position, orientation, velocity);
+  velocity(parentLink, childLink, position, orientation, getJointMatrix()*jointVel);
 }
 
 void
@@ -101,37 +100,8 @@
     jointForce.clear();
   else
     jointForce = portValues[mForcePort];
-
-  // The formulas conform to Roy Featherstones book eqn (6.37), (6.38)
-
-  // Store the outboard values since we will need them later in velocity
-  // derivative computations
-  SpatialInertia I = childLink.getInertia();
-
-  // Compute the projection to the joint coordinate space
-  Matrix6N Ih = I*mJointMatrix;
-  hIh = trans(mJointMatrix)*Ih;
-  MatrixFactorsNN hIhFac = MatrixNN(hIh);
-
-  // Note that the momentum of the local mass is already included in the
-  // child links force due the the mass model ...
-  Vector6 mPAlpha = childLink.getForce() + I*childLink.getFrame().getHdot();
-  Vector6 force = mPAlpha;
-
-  if (hIhFac.singular()) {
-    Log(ArtBody,Error) << "Detected singular mass matrix for "
-                       << "CartesianJointFrame \"" << getName()
-                       << "\": Fix your model!" << endl;
-    return;
-  }
   
-  // Project away the directions handled with this current joint
-  force -= Ih*hIhFac.solve(trans(mJointMatrix)*mPAlpha - jointForce);
-  I -= SpatialInertia(Ih*hIhFac.solve(trans(Ih)));
-
-  // Transform to parent link's coordinates and apply to the parent link
-  parentLink.applyForce(childLink.getFrame().forceToParent(force));
-  parentLink.applyInertia(childLink.getFrame().inertiaToParent(I));
+  articulation(parentLink, childLink, jointForce, hIh);
 }
 
 void
@@ -141,19 +111,13 @@
                             PortValueList& portValues,
                             const Matrix& hIh, Vector& velDot) const
 {
-  Vector6 parentSpAccel
-    = childLink.getFrame().motionFromParent(parentLink.getFrame().getSpAccel());
-
-  Vector6 f = childLink.getForce();
-  f += childLink.getInertia()*(parentSpAccel + childLink.getFrame().getHdot());
-  MatrixFactorsNN hIhFac = MatrixNN(hIh);
   VectorN jointForce;
   if (mForcePort.empty())
     jointForce.clear();
   else
     jointForce = portValues[mForcePort];
-  velDot = hIhFac.solve(jointForce - trans(mJointMatrix)*f);
-  childLink.setAccel(parentLink, mJointMatrix*velDot);
+  
+  acceleration(parentLink, childLink, jointForce, hIh, velDot);
 }
 
 void

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.h	2008-11-04 07:12:49 UTC (rev 659)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.h	2008-11-04 19:09:42 UTC (rev 660)
@@ -15,10 +15,14 @@
 #include "Joint.h"
 #include "MatrixInputPort.h"
 #include "MatrixOutputPort.h"
+#include "ContinousStateValueVector.h"
+#include "PortValueList.h"
+#include "MechanicContext.h"
+#include "CartesianJoint.h"
 
 namespace OpenFDM {
 
-class RevoluteJoint : public Joint {
+class RevoluteJoint : public CartesianJoint<1> {
   OPENFDM_OBJECT(RevoluteJoint, Joint);
 public:
   RevoluteJoint(const std::string& name);
@@ -29,22 +33,8 @@
   const Vector3& getAxis() const;
   void setAxis(const Vector3& axis);
 
-  /** Set the position of the joint.
-   */
-//   void setPosition(const Vector3& position);
-
-  /** Sets the zero orientation of the joint.
-   */
-//   void setOrientation(const Quaternion& orientation);
-
 protected:
 
-  enum { n = 1 };
-  typedef LinAlg::Vector<real_type,n> VectorN;
-  typedef LinAlg::Matrix<real_type,6,n> Matrix6N;
-  typedef LinAlg::Matrix<real_type,n,n> MatrixNN;
-  typedef LinAlg::MatrixFactors<real_type,n,n,LinAlg::LUTag> MatrixFactorsNN;
-
   virtual void init(const Task&, DiscreteStateValueVector&,
                     ContinousStateValueVector& continousState,
                     const PortValueList&) const;
@@ -69,6 +59,10 @@
                           const PortValueList& portValues, const Vector& velDot,
                           ContinousStateValueVector&) const;
 
+  using CartesianJoint<1>::velocity;
+  using CartesianJoint<1>::articulation;
+  using CartesianJoint<1>::acceleration;
+
 private:
   MatrixInputPort mForcePort;
   MatrixOutputPort mPositionPort;
@@ -78,8 +72,6 @@
   SharedPtr<Vector1StateInfo> mVelocityStateInfo;
 
   Vector3 mAxis;
-
-  Matrix6N mJointMatrix;
 };
 
 } // namespace OpenFDM



From frohlich at mail.berlios.de  Tue Nov  4 22:56:04 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Tue, 4 Nov 2008 22:56:04 +0100
Subject: [OpenFDM-svn] r661 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811042156.mA4Lu4bU023938@sheep.berlios.de>

Author: frohlich
Date: 2008-11-04 22:56:03 +0100 (Tue, 04 Nov 2008)
New Revision: 661

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
   branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteActuator.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteActuator.h
Log:
Implement pre version of a actuator.

M    src/OpenFDM/CartesianJoint.h
M    src/OpenFDM/Makefile.am
M    src/OpenFDM/RevoluteActuator.cpp
M    src/OpenFDM/RevoluteActuator.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h	2008-11-04 19:09:42 UTC (rev 660)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h	2008-11-04 21:56:03 UTC (rev 661)
@@ -38,7 +38,6 @@
   void setJointMatrix(const Matrix6N& jointMatrix)
   { mJointMatrix = jointMatrix; }
 
-  // Minimal implementation, factored out all unneeded
   void velocity(const MechanicLinkValue& parentLink,
                 MechanicLinkValue& childLink, const Vector3& position,
                 const Quaternion& orientation, const Vector6& vel) const
@@ -46,8 +45,9 @@
     childLink.setPosAndVel(parentLink, position, orientation, vel);
   }
 
-  
-  // Minimal implementation, factored out all unneeded
+  /** Compute the articulation step for a given joint force.
+   *  Use this for usual joints.
+   */
   void articulation(MechanicLinkValue& parentLink,
                     const MechanicLinkValue& childLink,
                     const VectorN& jointForce,
@@ -85,6 +85,9 @@
     parentLink.applyInertia(childLink.getFrame().inertiaToParent(I));
   }
 
+  /** Compute the acceleration step for a given joint force.
+   *  Use this for usual joints.
+   */
   void acceleration(const MechanicLinkValue& parentLink,
                     MechanicLinkValue& childLink, const VectorN& jointForce,
                     const Matrix& hIh, Vector& velDot) const
@@ -99,6 +102,36 @@
     childLink.setAccel(parentLink, mJointMatrix*velDot);
   }
   
+  /** Compute the articulation step for a given velocity derivative.
+   *  Use this for actuators.
+   */
+  void articulation(MechanicLinkValue& parentLink,
+                    const MechanicLinkValue& childLink,
+                    const VectorN& velDot) const
+  {
+    // The formulas conform to Roy Featherstones book eqn (7.36), (7.37)
+
+    // Compute the articulated force and inertia.
+    // This Since there is no projection step with the joint axis, it is clear
+    // that this is just a rigid connection ...
+    SpatialInertia I = childLink.getInertia();
+    Vector6 force = childLink.getForce();
+    force += I*(childLink.getFrame().getHdot() + mJointMatrix*velDot);
+    
+    // Transform to parent link's coordinates and apply to the parent link
+    parentLink.applyForce(childLink.getFrame().forceToParent(force));
+    parentLink.applyInertia(childLink.getFrame().inertiaToParent(I));
+  }
+
+  /** Compute the acceleration step for a given velocity derivative.
+   *  Use this for actuators.
+   */
+  void acceleration(const MechanicLinkValue& parentLink,
+                    MechanicLinkValue& childLink, VectorN& velDot) const
+  {
+    childLink.setAccel(parentLink, mJointMatrix*velDot);
+  }
+
 private:
   Matrix6N mJointMatrix;
 };

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-11-04 19:09:42 UTC (rev 660)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-11-04 21:56:03 UTC (rev 661)
@@ -249,6 +249,7 @@
   Joint.cpp \
   Mass.cpp \
   MobileRootJoint.cpp \
+  RevoluteActuator.cpp \
   RevoluteJoint.cpp
 
 
@@ -276,7 +277,6 @@
 #   Output.cpp \
 #   Product.cpp \
 #   PrismaticJoint.cpp \
-#   RevoluteActuator.cpp \
 #   RigidBody.cpp \
 #   RootFrame.cpp \
 #   Saturation.cpp \

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteActuator.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteActuator.cpp	2008-11-04 19:09:42 UTC (rev 660)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteActuator.cpp	2008-11-04 21:56:03 UTC (rev 661)
@@ -11,174 +11,116 @@
 #include "Matrix.h"
 #include "Quaternion.h"
 #include "Inertia.h"
-#include "Frame.h"
-#include "RigidBody.h"
-#include "RevoluteActuatorFrame.h"
+#include "PortValueList.h"
+#include "ContinousStateValueVector.h"
+#include "MechanicContext.h"
 
 namespace OpenFDM {
 
 BEGIN_OPENFDM_OBJECT_DEF(RevoluteActuator, Joint)
-  DEF_OPENFDM_PROPERTY(Real, MaxVel, Serialized)
-  DEF_OPENFDM_PROPERTY(Real, VelGain, Serialized)
-  DEF_OPENFDM_PROPERTY(Real, VelDotGain, Serialized)
+  DEF_OPENFDM_PROPERTY(Vector3, Axis, Serialized)
   END_OPENFDM_OBJECT_DEF
 
-BEGIN_OPENFDM_OBJECT_DEF(RevoluteActuatorFrame, Frame)
-  END_OPENFDM_OBJECT_DEF
-
 RevoluteActuator::RevoluteActuator(const std::string& name) :
-  Joint(name),
-  mMaxVel(10),
-  mVelGain(1e2),
-  mVelDotGain(1e2)
+  CartesianJoint<1>(name, Vector6(Vector3(1, 0, 0), Vector3::zeros())),
+  mInputPort(this, "input", Size(1, 1), true),
+  mPositionPort(this, "position", Size(1, 1)),
+  mVelocityPort(this, "velocity", Size(1, 1)),
+  mPositionStateInfo(new Vector1StateInfo),
+  mVelocityStateInfo(new Vector1StateInfo),
+  mAxis(Vector3(1, 0, 0))
 {
-  setNumContinousStates(2);
+  addContinousStateInfo(mPositionStateInfo);
+  addContinousStateInfo(mVelocityStateInfo);
 
-  mRevoluteActuatorFrame = new RevoluteActuatorFrame(name);
-
-  setNumInputPorts(1);
-  setInputPortName(0, "position");
-
-  setNumOutputPorts(2);
-  setOutputPort(0, "jointPos", this, &RevoluteActuator::getJointPos);
-  setOutputPort(1, "jointVel", this, &RevoluteActuator::getJointVel);
+  // FIXME
+  setAxis(mAxis);
 }
 
 RevoluteActuator::~RevoluteActuator(void)
 {
 }
 
-bool
-RevoluteActuator::init(void)
+const Vector3&
+RevoluteActuator::getAxis() const
 {
-  mDesiredPositionPort = getInputPort(0)->toRealPortHandle();
-  if (!mDesiredPositionPort.isConnected()) {
-    Log(Model, Error) << "Initialization of RevoluteActuator model \""
-                      << getName()
-                      << "\" failed: Input port \"" << getInputPortName(0)
-                      << "\" is not connected!" << endl;
-    return false;
-  }
-
-  recheckTopology();
-  return Joint::init();
+  return mAxis;
 }
 
 void
-RevoluteActuator::recheckTopology(void)
+RevoluteActuator::setAxis(const Vector3& axis)
 {
-  if (!getOutboardBody() || !getInboardBody())
-    return;
-  
-  // check for the inboard frame
-  Frame* inFrame = getInboardBody()->getFrame();
-  if (!inFrame)
-    return;
-  
-  Frame* outFrame = getOutboardBody()->getFrame();
-  if (!outFrame) {
-    getOutboardBody()->setFrame(mRevoluteActuatorFrame);
-  }
-  outFrame = getOutboardBody()->getFrame();
-  if (!outFrame->isDirectChildFrameOf(inFrame)) {
-    inFrame->addChildFrame(mRevoluteActuatorFrame);
-  }
-}
-
-void
-RevoluteActuator::setJointAxis(const Vector3& axis)
-{
   real_type nrm = norm(axis);
   if (nrm <= Limits<real_type>::min()) {
     Log(Initialization, Error) << "JointAxis is zero ..." << endl;
     return;
   }
-  mRevoluteActuatorFrame->setJointAxis((1/nrm)*axis);
+  mAxis = (1/nrm)*axis;
+  setJointMatrix(Vector6(mAxis, Vector3::zeros()));
 }
 
-const real_type&
-RevoluteActuator::getJointPos(void) const
-{
-  return mRevoluteActuatorFrame->getJointPos();
-}
-
 void
-RevoluteActuator::setJointPos(real_type pos)
+RevoluteActuator::init(const Task&, DiscreteStateValueVector&,
+                       ContinousStateValueVector& continousState,
+                       const PortValueList&) const
 {
-  mRevoluteActuatorFrame->setJointPos(pos);
+  continousState[*mPositionStateInfo] = 0;
+  continousState[*mVelocityStateInfo] = 0;
 }
 
-const real_type&
-RevoluteActuator::getJointVel(void) const
-{
-  return mRevoluteActuatorFrame->getJointVel();
-}
-
 void
-RevoluteActuator::setJointVel(real_type vel)
+RevoluteActuator::velocity(const MechanicLinkValue& parentLink,
+                           MechanicLinkValue& childLink,
+                           const ContinousStateValueVector& states,
+                           PortValueList& portValues) const
 {
-  mRevoluteActuatorFrame->setJointVel(vel);
-}
+  VectorN jointPos = states[*mPositionStateInfo];
+  if (!mPositionPort.empty())
+    portValues[mPositionPort] = jointPos;
+  
+  VectorN jointVel = states[*mVelocityStateInfo];
+  if (!mVelocityPort.empty())
+    portValues[mVelocityPort] = jointVel;
+  
+  Vector3 position(0, 0, 0);
+  Quaternion orientation(Quaternion::fromAngleAxis(jointPos(0), mAxis));
 
-void
-RevoluteActuator::setPosition(const Vector3& position)
-{
-  mRevoluteActuatorFrame->setPosition(position);
+  velocity(parentLink, childLink, position, orientation, getJointMatrix()*jointVel);
 }
 
 void
-RevoluteActuator::setOrientation(const Quaternion& orientation)
+RevoluteActuator::articulation(MechanicLinkValue& parentLink,
+                            const MechanicLinkValue& childLink,
+                            const ContinousStateValueVector& states,
+                            PortValueList& portValues,
+                            Matrix&) const
 {
-  mRevoluteActuatorFrame->setZeroOrientation(orientation);
+  VectorN velDot;
+  velDot.clear();
+  articulation(parentLink, childLink, velDot);
 }
 
 void
-RevoluteActuator::jointArticulation(SpatialInertia& artI, Vector6& artF,
-                                 const SpatialInertia& outI,
-                                 const Vector6& outF)
+RevoluteActuator::acceleration(const MechanicLinkValue& parentLink,
+                               MechanicLinkValue& childLink,
+                               const ContinousStateValueVector& states,
+                               PortValueList& portValues,
+                               const Matrix&, Vector& _velDot) const
 {
-  // This is a simple second order system with velocity limits.
-  // the joints accelerations, velocities and positions must fit together
-  // otherwise the articulated body dynamics get fooled ...
-
-  // The desired position input
-  real_type desiredPos = mDesiredPositionPort.getRealValue();
-  // Compute the error ...
-  real_type posErr = desiredPos - mRevoluteActuatorFrame->getJointPos();
-  // ... and compute a desired velocity within the given limits from that.
-  real_type desiredVel = smoothSaturate(mVelGain*posErr, mMaxVel);
-  // The usual control loops: there we get a velocity error
-  real_type velErr = desiredVel - mRevoluteActuatorFrame->getJointVel();
-  // and accelerate that proportional to that error ...
-  mRevoluteActuatorFrame->setJointVelDot(mVelDotGain*velErr);
-
-  // now that the joints acceleration is known, compute the articulated
-  // body force and inertia ...
-  mRevoluteActuatorFrame->jointArticulation(artI, artF, outF, outI);
+  VectorN velDot;
+  velDot.clear();
+  _velDot = velDot;
+  acceleration(parentLink, childLink, velDot);
 }
 
 void
-RevoluteActuator::setState(const StateStream& state)
+RevoluteActuator::derivative(const DiscreteStateValueVector&,
+                             const ContinousStateValueVector& states,
+                             const PortValueList&, const Vector& velDot,
+                             ContinousStateValueVector& derivative) const
 {
-  CartesianActuatorFrame<1>::VectorN v;
-  state.readSubState(v);
-  mRevoluteActuatorFrame->setJointPos(v(0));
-  state.readSubState(v);
-  mRevoluteActuatorFrame->setJointVel(v(0));
+  derivative[*mPositionStateInfo] = states[*mVelocityStateInfo];
+  derivative[*mVelocityStateInfo] = velDot;
 }
 
-void
-RevoluteActuator::getState(StateStream& state) const
-{
-  state.writeSubState(mRevoluteActuatorFrame->getJointPos());
-  state.writeSubState(mRevoluteActuatorFrame->getJointVel());
-}
-
-void
-RevoluteActuator::getStateDeriv(StateStream& stateDeriv)
-{
-  stateDeriv.writeSubState(mRevoluteActuatorFrame->getJointVel());
-  stateDeriv.writeSubState(mRevoluteActuatorFrame->getJointVelDot());
-}
-
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteActuator.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteActuator.h	2008-11-04 19:09:42 UTC (rev 660)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteActuator.h	2008-11-04 21:56:03 UTC (rev 661)
@@ -9,95 +9,69 @@
 #include "Object.h"
 #include "Vector.h"
 #include "Matrix.h"
+#include "MatrixStateInfo.h"
 #include "Quaternion.h"
 #include "Inertia.h"
-#include "Frame.h"
-#include "RigidBody.h"
 #include "Joint.h"
+#include "MatrixInputPort.h"
+#include "MatrixOutputPort.h"
+#include "ContinousStateValueVector.h"
+#include "PortValueList.h"
+#include "MechanicContext.h"
+#include "CartesianJoint.h"
 
 namespace OpenFDM {
 
-class RevoluteActuatorFrame;
-
-class RevoluteActuator : public Joint {
+class RevoluteActuator : public CartesianJoint<1> {
   OPENFDM_OBJECT(RevoluteActuator, Joint);
 public:
   RevoluteActuator(const std::string& name);
   virtual ~RevoluteActuator(void);
 
-  virtual bool init(void);
-
-  virtual void recheckTopology(void);
-
   /** Sets the joint axis where this joint is allowed to rotate around.
    */
-  void setJointAxis(const Vector3& axis);
+  const Vector3& getAxis() const;
+  void setAxis(const Vector3& axis);
 
-  /** Returns the joint position.
-   */
-  const real_type& getJointPos(void) const;
+protected:
 
-  /** Sets the joint position.
-   */
-  void setJointPos(real_type pos);
+  virtual void init(const Task&, DiscreteStateValueVector&,
+                    ContinousStateValueVector& continousState,
+                    const PortValueList&) const;
 
-  /** Returns the joint velocity.
-   */
-  const real_type& getJointVel(void) const;
+  virtual void velocity(const MechanicLinkValue& parentLink,
+                        MechanicLinkValue& childLink,
+                        const ContinousStateValueVector& states,
+                        PortValueList& portValues) const;
+  virtual void articulation(MechanicLinkValue& parentLink,
+                            const MechanicLinkValue& childLink,
+                            const ContinousStateValueVector& states,
+                            PortValueList& portValues,
+                            Matrix& hIh) const;
+  virtual void acceleration(const MechanicLinkValue& parentLink,
+                            MechanicLinkValue& childLink,
+                            const ContinousStateValueVector& states,
+                            PortValueList& portValues,
+                            const Matrix& hIh, Vector& velDot) const;
 
-  /** Sets the joint velocity.
-   */
-  void setJointVel(real_type vel);
+  virtual void derivative(const DiscreteStateValueVector&,
+                          const ContinousStateValueVector&,
+                          const PortValueList& portValues, const Vector& velDot,
+                          ContinousStateValueVector&) const;
 
-  /** Set the position of the joint.
-   */
-  void setPosition(const Vector3& position);
+  using CartesianJoint<1>::velocity;
+  using CartesianJoint<1>::articulation;
+  using CartesianJoint<1>::acceleration;
 
-  /** Sets the zero orientation of the joint.
-   */
-  void setOrientation(const Quaternion& orientation);
-
-  const real_type& getMaxVel(void) const
-  { return mMaxVel; }
-  void setMaxVel(const real_type& maxVel)
-  { mMaxVel = maxVel; }
-
-  const real_type& getVelGain(void) const
-  { return mVelGain; }
-  void setVelGain(const real_type& velGain)
-  { mVelGain = velGain; }
-
-  const real_type& getVelDotGain(void) const
-  { return mVelDotGain; }
-  void setVelDotGain(const real_type& velDotGain)
-  { mVelDotGain = velDotGain; }
-
 private:
-  /** Computes the inboard articulated inertia and force for
-      this articulated body. It is part of the articulated body algorithm.
-   */
-  virtual void jointArticulation(SpatialInertia& artI, Vector6& artF,
-                                 const SpatialInertia& outI,
-                                 const Vector6& outF);
+  MatrixInputPort mInputPort;
+  MatrixOutputPort mPositionPort;
+  MatrixOutputPort mVelocityPort;
 
-  /** Methods for the OpenFDM::Part.
-   */
-  virtual void setState(const StateStream& state);
-  virtual void getState(StateStream& state) const;
-  virtual void getStateDeriv(StateStream& state);
+  SharedPtr<Vector1StateInfo> mPositionStateInfo;
+  SharedPtr<Vector1StateInfo> mVelocityStateInfo;
 
-  /// The maximum movement of the controler
-  real_type mMaxVel;
-  /// The velocity p gain
-  real_type mVelGain;
-  /// The velocity derivative p gain
-  real_type mVelDotGain;
-
-  /// The frame of the mobile root
-  SharedPtr<RevoluteActuatorFrame> mRevoluteActuatorFrame;
-
-  /// Input port for the desired position
-  RealPortHandle mDesiredPositionPort;
+  Vector3 mAxis;
 };
 
 } // namespace OpenFDM



From frohlich at mail.berlios.de  Tue Nov  4 23:16:06 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Tue, 4 Nov 2008 23:16:06 +0100
Subject: [OpenFDM-svn] r662 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811042216.mA4MG6wS029737@sheep.berlios.de>

Author: frohlich
Date: 2008-11-04 23:16:05 +0100 (Tue, 04 Nov 2008)
New Revision: 662

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteActuator.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteActuator.h
Log:
Move over actuator control.

M    src/OpenFDM/RevoluteActuator.cpp
M    src/OpenFDM/RevoluteActuator.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteActuator.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteActuator.cpp	2008-11-04 21:56:03 UTC (rev 661)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteActuator.cpp	2008-11-04 22:16:05 UTC (rev 662)
@@ -96,7 +96,32 @@
                             Matrix&) const
 {
   VectorN velDot;
-  velDot.clear();
+
+  // This is a simple second order system with velocity limits.
+  // the joints accelerations, velocities and positions must fit together
+  // otherwise the articulated body dynamics get fooled ...
+
+  if (mPositionControl) {
+    // The desired position input
+    VectorN desiredPos = portValues[mInputPort];
+    // Compute the error ...
+    VectorN posErr = desiredPos - states[*mPositionStateInfo];
+    // ... and compute a desired velocity within the given limits from that.
+    VectorN desiredVel;
+    desiredVel(0) = smoothSaturate(mVelGain*posErr(0), mMaxVel);
+    // The usual control loops: there we get a velocity error
+    VectorN velErr = desiredVel - states[*mVelocityStateInfo];
+    // and accelerate that proportional to that error ...
+    velDot = mVelDotGain*velErr;
+  } else {
+    // The desired velocity input
+    VectorN desiredVel = portValues[mInputPort];
+    // The usual control loops: there we get a velocity error
+    VectorN velErr = desiredVel - states[*mVelocityStateInfo];
+    // and accelerate that proportional to that error ...
+    velDot = mVelDotGain*velErr;
+  }
+
   articulation(parentLink, childLink, velDot);
 }
 
@@ -105,12 +130,36 @@
                                MechanicLinkValue& childLink,
                                const ContinousStateValueVector& states,
                                PortValueList& portValues,
-                               const Matrix&, Vector& _velDot) const
+                               const Matrix&, Vector& velDot) const
 {
-  VectorN velDot;
-  velDot.clear();
-  _velDot = velDot;
-  acceleration(parentLink, childLink, velDot);
+  // This is a simple second order system with velocity limits.
+  // the joints accelerations, velocities and positions must fit together
+  // otherwise the articulated body dynamics get fooled ...
+
+  if (mPositionControl) {
+    // The desired position input
+    VectorN desiredPos = portValues[mInputPort];
+    // Compute the error ...
+    VectorN posErr = desiredPos - states[*mPositionStateInfo];
+    // ... and compute a desired velocity within the given limits from that.
+    VectorN desiredVel;
+    desiredVel(0) = smoothSaturate(mVelGain*posErr(0), mMaxVel);
+    // The usual control loops: there we get a velocity error
+    VectorN velErr = desiredVel - states[*mVelocityStateInfo];
+    // and accelerate that proportional to that error ...
+    velDot = mVelDotGain*velErr;
+  } else {
+    // The desired velocity input
+    VectorN desiredVel = portValues[mInputPort];
+    // The usual control loops: there we get a velocity error
+    VectorN velErr = desiredVel - states[*mVelocityStateInfo];
+    // and accelerate that proportional to that error ...
+    velDot = mVelDotGain*velErr;
+  }
+  // FIXME
+  VectorN _velDot = velDot;
+
+  acceleration(parentLink, childLink, _velDot);
 }
 
 void

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteActuator.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteActuator.h	2008-11-04 21:56:03 UTC (rev 661)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteActuator.h	2008-11-04 22:16:05 UTC (rev 662)
@@ -72,6 +72,10 @@
   SharedPtr<Vector1StateInfo> mVelocityStateInfo;
 
   Vector3 mAxis;
+  bool mPositionControl;
+  real_type mVelGain;
+  real_type mVelDotGain;
+  real_type mMaxVel;
 };
 
 } // namespace OpenFDM



From frohlich at mail.berlios.de  Tue Nov  4 23:17:08 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Tue, 4 Nov 2008 23:17:08 +0100
Subject: [OpenFDM-svn] r663 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811042217.mA4MH8fZ029918@sheep.berlios.de>

Author: frohlich
Date: 2008-11-04 23:17:07 +0100 (Tue, 04 Nov 2008)
New Revision: 663

Removed:
   branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianActuatorFrame.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJointFrame.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJointFrame.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJointFrame.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/PrismaticJointFrame.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteActuatorFrame.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJointFrame.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/RootFrame.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/RootFrame.h
Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
Log:
Remove unused frame implementations.


Deleted: branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianActuatorFrame.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianActuatorFrame.h	2008-11-04 22:16:05 UTC (rev 662)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianActuatorFrame.h	2008-11-04 22:17:07 UTC (rev 663)
@@ -1,74 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
- *
- */
-
-#ifndef OpenFDM_CartesianActuatorFrame_H
-#define OpenFDM_CartesianActuatorFrame_H
-
-#include "Assert.h"
-#include "Vector.h"
-#include "Matrix.h"
-#include "Inertia.h"
-#include "Frame.h"
-
-namespace OpenFDM {
-
-template<unsigned n>
-class CartesianActuatorFrame :
-  public Frame {
-public:
-  typedef LinAlg::Vector<real_type,n> VectorN;
-  typedef LinAlg::Matrix<real_type,6,n> Matrix6N;
-
-  CartesianActuatorFrame(const std::string& name) :
-    Frame(name),
-    mRelVelDot(Vector6::zeros())
-  { }
-  virtual ~CartesianActuatorFrame(void)
-  { }
-
-  /// The interface routine for the Frame,
-  /// returns the relative velocity derivative of this frame
-  virtual const Vector6& getRelVelDot(void) const
-  { return mRelVelDot; }
-
-  /// Compute the articulated force and inertia past inboard to that joint
-  bool jointArticulation(SpatialInertia& artI, Vector6& artF,
-                         const Vector6& outF, const SpatialInertia& outI)
-  {
-    // The formulas conform to Roy Featherstones book eqn (7.36), (7.37)
-
-    // Compute the articulated force and inertia.
-    // This Since there is no projection step with the joint axis, it is clear
-    // that this is just a rigid connection ...
-    artF = outF + outI*(getHdot() + mRelVelDot);
-    artI = outI;
-
-    return true;
-  }
-
-protected:
-  void setRelVelDot(const Vector6& relVelDot)
-  {
-    mRelVelDot = relVelDot;
-    setAccelDirty();
-  }
-  void setLinearRelVelDot(const Vector3& relVelDot)
-  {
-    mRelVelDot.setLinear(relVelDot);
-    setAccelDirty();
-  }
-  void setAngularRelVelDot(const Vector3& relVelDot)
-  {
-    mRelVelDot.setAngular(relVelDot);
-    setAccelDirty();
-  }
-
-private:
-  /// The derivative of the frame spatial velocity
-  Vector6 mRelVelDot;
-};
-
-} // namespace OpenFDM
-
-#endif

Deleted: branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJointFrame.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJointFrame.h	2008-11-04 22:16:05 UTC (rev 662)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJointFrame.h	2008-11-04 22:17:07 UTC (rev 663)
@@ -1,164 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
- *
- */
-
-#ifndef OpenFDM_CartesianJointFrame_H
-#define OpenFDM_CartesianJointFrame_H
-
-#include "Assert.h"
-#include "Vector.h"
-#include "Matrix.h"
-#include "Inertia.h"
-#include "Frame.h"
-
-namespace OpenFDM {
-
-template<unsigned n>
-class CartesianJointFrame :
-  public Frame {
-public:
-  typedef LinAlg::Vector<real_type,n> VectorN;
-  typedef LinAlg::Matrix<real_type,6,n> Matrix6N;
-  typedef LinAlg::Matrix<real_type,n,n> MatrixNN;
-  typedef LinAlg::MatrixFactors<real_type,n,n,LinAlg::LUTag> MatrixFactorsNN;
-
-  CartesianJointFrame(const std::string& name) :
-    Frame(name),
-//     mJointMatrix(Matrix6N::zeros()), /// ??? ... see LinAlg checkout ...
-    mOutboardInertia(SpatialInertia::zeros()),
-    mPAlpha(Vector6::zeros()),
-    mJointForce(VectorN::zeros()),
-    mArticulationDirty(true),
-    mJointVelDotDirty(true),
-    mSpVelDotDirty(true),
-    mJointVelDot(VectorN::zeros()),
-    mRelVelDot(Vector6::zeros())
-  { }
-  virtual ~CartesianJointFrame(void)
-  { }
-
-  /// The interface routine for the Frame,
-  /// returns the relative velocity derivative of this frame
-  virtual const Vector6& getRelVelDot(void) const
-  {
-    if (mSpVelDotDirty) {
-      mRelVelDot = mJointMatrix*getJointVelDot();
-      mSpVelDotDirty = false;
-      // Note that we do not need to mark the accelerations dirty since
-      // we can only get here if something else the accelerations will depend
-      // on anyway is set dirty before
-      // setAccelDirty();
-    }
-    return mRelVelDot;
-  }
-
-  /// Returns the derivative of the joint velocity
-  const VectorN& getJointVelDot() const
-  {
-    OpenFDMAssert(!mArticulationDirty);
-    if (mJointVelDotDirty) {
-      if (hIh.singular()) {
-        Log(ArtBody,Error) << "Detected singular mass matrix for "
-                           << "CartesianJointFrame \"" << getName()
-                           << "\": Fix your model!" << endl;
-        mJointVelDot.clear();
-      } else {
-        Vector6 tmp = mOutboardInertia*getParentSpAccel() + mPAlpha;
-        mJointVelDot = hIh.solve(mJointForce - trans(mJointMatrix)*tmp);
-      }
-      mJointVelDotDirty = false;
-    }
-    return mJointVelDot;
-  }
-
-  /// Compute the articulated force and inertia past inboard to that joint
-  bool jointArticulation(SpatialInertia& artI, Vector6& artF,
-                         const Vector6& outF, const SpatialInertia& outI,
-                         const VectorN& jointForce)
-  {
-    // The formulas conform to Roy Featherstones book eqn (6.37), (6.38)
-
-    // Store the outboard values since we will need them later in velocity
-    // derivative computations
-    mOutboardInertia = outI;
-    mJointForce = jointForce;
-    // Make sure we have the correct internal state
-    mJointVelDotDirty = true;
-    mArticulationDirty = false;
-
-    // Compute the projection to the joint coodinate space
-    Matrix6N Ih = outI*mJointMatrix;
-    hIh = trans(mJointMatrix)*Ih;
-
-    mPAlpha = outF + mOutboardInertia*getHdot();
-    artF = mPAlpha;
-    artI = outI;
-
-    if (hIh.singular()) {
-      Log(ArtBody,Error) << "Detected singular mass matrix for "
-                         << "CartesianJointFrame \"" << getName()
-                         << "\": Fix your model!" << endl;
-      return false;
-    }
-    
-    // Project away the directions handled with this current joint
-    artF -= Ih*hIh.solve(trans(mJointMatrix)*mPAlpha - jointForce);
-    artI -= SpatialInertia(Ih*hIh.solve(trans(Ih)));
-
-    return true;
-  }
-
-protected:
-  const Matrix6N& getJointMatrix(void) const
-  { return mJointMatrix; }
-
-  void setJointMatrix(const Matrix6N& jointAxis)
-  { mJointMatrix = jointAxis; setDirty(); }
-
-  void setPosition(const Vector3& pos)
-  { Frame::setPosition(pos); setDirty(); }
-  void setOrientation(const Quaternion& orientation)
-  { Frame::setOrientation(orientation); setDirty(); }
-  void setRelVel(const Vector6& vel)
-  { Frame::setRelVel(vel); setDirty(); }
-  void setLinearRelVel(const Vector3& vel)
-  { Frame::setLinearRelVel(vel); setDirty(); }
-  void setAngularRelVel(const Vector3& vel)
-  { Frame::setAngularRelVel(vel); setDirty(); }
-  void setDirty(void) const
-  {
-    mArticulationDirty = true;
-    mJointVelDotDirty = true;
-    mSpVelDotDirty = true;
-    setAccelDirty();
-  }
-
-private:
-  /// The cartesian joint map matrix, that is for the simple one dimensional
-  /// case just a spatial vector.
-  Matrix6N mJointMatrix;
-
-  /// The articulated intertia of the outboard frame, 
-  SpatialInertia mOutboardInertia;
-  /// The joint internal force in joint generalized coordinates
-  VectorN mJointForce;
-  /// Some intermediate value we will need later
-  Vector6 mPAlpha;
-  /// The decomposition of the inertia matrix projected to joint coordinates
-  MatrixFactorsNN hIh;
-  /// This is true if the state has changed but the articulated intertia and
-  /// forces are not yet updated
-  mutable bool mArticulationDirty:1;
-  /// This is true if the joint velocity derivatives are not yet computed
-  mutable bool mJointVelDotDirty:1;
-  /// This is true if the spatial velocity derivative is not yet computed
-  mutable bool mSpVelDotDirty:1;
-  /// The derivative of the joint velocity
-  mutable VectorN mJointVelDot;
-  /// The derivative of the frame velocity
-  mutable Vector6 mRelVelDot;
-};
-
-} // namespace OpenFDM
-
-#endif

Deleted: branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJointFrame.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJointFrame.h	2008-11-04 22:16:05 UTC (rev 662)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJointFrame.h	2008-11-04 22:17:07 UTC (rev 663)
@@ -1,60 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
- *
- */
-
-#ifndef OpenFDM_FixedRootJointFrame_H
-#define OpenFDM_FixedRootJointFrame_H
-
-#include "Assert.h"
-#include "Vector.h"
-#include "Matrix.h"
-#include "Inertia.h"
-#include "Frame.h"
-
-namespace OpenFDM {
-
-class FixedRootJointFrame :
-  public Frame {
-public:
-  FixedRootJointFrame(const std::string& name) :
-    Frame(name),
-    mRelVelDot(Vector6::zeros())
-  { }
-  virtual ~FixedRootJointFrame(void)
-  { }
-
-  /// The interface routine for the Frame,
-  /// returns the relative velocity derivative of this frame
-  virtual const Vector6& getRelVelDot(void) const
-  { return mRelVelDot; }
-
-  /// Compute the articulated force and inertia past inboard to that joint
-  void jointArticulation(const Vector6&, const SpatialInertia&,
-                         const Gravity* gravity)
-  {
-    Log(ArtBody, Debug) << "FixedRootJointFrame::jointArticulation()" << endl;
-
-    // Assumption: body is small compared to the distance to the planets
-    // center of mass. That means gravity could be considered equal for the
-    // whole vehicle.
-    // See Featherstone, Orin: Equations and Algorithms
-    Vector3 ga = gravity->gravityAccel(getRefPosition());
-    Vector6 grav = Vector6(Vector3::zeros(), rotFromRef(ga));
-
-    mRelVelDot = grav - getParentSpAccel() - getHdot();
-    setAccelDirty();
-  }
-
-  using Frame::setPosition;
-  using Frame::setRefPosition;
-  using Frame::setOrientation;
-  using Frame::setRefOrientation;
-
-private:
-  /// The derivative of the frame velocity
-  Vector6 mRelVelDot;
-};
-
-} // namespace OpenFDM
-
-#endif

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-11-04 22:16:05 UTC (rev 662)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-11-04 22:17:07 UTC (rev 663)
@@ -194,7 +194,6 @@
   DiscreteIntegrator.h \
   ExternalForceModel.h \
   FixedRootJoint.h \
-  FixedRootJointFrame.h \
   Force.h \
   Gain.h \
   Gravity.h \
@@ -208,16 +207,11 @@
   MaxModel.h \
   MinModel.h \
   MobileRootJoint.h \
-  MobileRootJointFrame.h \
   Output.h \
   Product.h \
   PrismaticJoint.h \
-  PrismaticJointFrame.h \
   RevoluteActuator.h \
-  RevoluteActuatorFrame.h \
   RevoluteJoint.h \
-  RevoluteJointFrame.h \
-  RootFrame.h \
   Saturation.h \
   Sensor.h \
   SimpleContact.h \
@@ -278,7 +272,6 @@
 #   Product.cpp \
 #   PrismaticJoint.cpp \
 #   RigidBody.cpp \
-#   RootFrame.cpp \
 #   Saturation.cpp \
 #   SimpleContact.cpp \
 #   SimpleGear.cpp \

Deleted: branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJointFrame.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJointFrame.h	2008-11-04 22:16:05 UTC (rev 662)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJointFrame.h	2008-11-04 22:17:07 UTC (rev 663)
@@ -1,63 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
- *
- */
-
-#ifndef OpenFDM_MobileRootJointFrame_H
-#define OpenFDM_MobileRootJointFrame_H
-
-#include "Assert.h"
-#include "Vector.h"
-#include "Matrix.h"
-#include "Inertia.h"
-#include "Frame.h"
-
-namespace OpenFDM {
-
-class MobileRootJointFrame :
-  public Frame {
-public:
-  MobileRootJointFrame(const std::string& name) :
-    Frame(name),
-    mRelVelDot(Vector6::zeros())
-  { }
-  virtual ~MobileRootJointFrame(void)
-  { }
-
-  /// The interface routine for the Frame,
-  /// returns the relative velocity derivative of this frame
-  virtual const Vector6& getRelVelDot(void) const
-  { return mRelVelDot; }
-
-  /// Compute the articulated force and inertia past inboard to that joint
-  void jointArticulation(const Vector6& outF, const SpatialInertia& outI,
-                         const Gravity* gravity)
-  {
-    Log(ArtBody, Debug) << "MobileRootJointFrame::jointArticulation()" << endl;
-
-    // Assumption: body is small compared to the distance to the planets
-    // center of mass. That means gravity could be considered equal for the
-    // whole vehicle.
-    // See Featherstone, Orin: Equations and Algorithms
-    Vector3 ga = gravity->gravityAccel(getRefPosition());
-    Vector6 grav = Vector6(Vector3::zeros(), rotFromRef(ga));
-
-    mRelVelDot = grav - solve(outI, outF) - getParentSpAccel() - getHdot();
-    setAccelDirty();
-  }
-
-  using Frame::setPosition;
-  using Frame::setRefPosition;
-  using Frame::setOrientation;
-  using Frame::setRefOrientation;
-  using Frame::setRelVel;
-  using Frame::setLinearRelVel;
-  using Frame::setAngularRelVel;
-
-private:
-  /// The derivative of the frame velocity
-  Vector6 mRelVelDot;
-};
-
-} // namespace OpenFDM
-
-#endif

Deleted: branches/OpenFDM-StateSeparation/src/OpenFDM/PrismaticJointFrame.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/PrismaticJointFrame.h	2008-11-04 22:16:05 UTC (rev 662)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/PrismaticJointFrame.h	2008-11-04 22:17:07 UTC (rev 663)
@@ -1,79 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
- *
- */
-
-#ifndef OpenFDM_PrismaticJointFrame_H
-#define OpenFDM_PrismaticJointFrame_H
-
-#include "CartesianJointFrame.h"
-
-namespace OpenFDM {
-
-class PrismaticJointFrame : public CartesianJointFrame<1> {
-  OPENFDM_OBJECT(PrismaticJointFrame, CartesianJointFrame<1>);
-public:
-  PrismaticJointFrame(const std::string& name) :
-    CartesianJointFrame<1>(name),
-    mZeroPos(Vector3::zeros()),
-    mJointAxis(Vector3::unit(0)),
-    mJointPos(0),
-    mJointVel(0)
-  {
-    setJointMatrix(Vector6(Vector3::zeros(), mJointAxis));
-  }
-  virtual ~PrismaticJointFrame(void) {}
-
-  /// Gets the joint axis where this joint is allowed to rotate around.
-  const Vector3& getJointAxis(void) const
-  { return mJointAxis; }
-
-  /// Sets the joint axis where this joint is allowed to rotate around.
-  void setJointAxis(const Vector3& axis)
-  {
-    mJointAxis = axis;
-    setJointMatrix(Vector6(Vector3::zeros(), axis));
-    setPosition(mZeroPos + mJointPos*mJointAxis);
-    setLinearRelVel(mJointVel*mJointAxis);
-  }
-
-  /// Returns the joint position.
-  const real_type& getJointPos(void) const
-  { return mJointPos; }
-
-  /// Sets the joint position.
-  void setJointPos(const real_type& pos)
-  { mJointPos = pos; setPosition(mZeroPos + mJointPos*mJointAxis); }
-
-  /// Returns the joint velocity.
-  const real_type& getJointVel(void) const
-  { return mJointVel; }
-
-  /// Sets the joint velocity.
-  void setJointVel(const real_type& vel)
-  { mJointVel = vel; setLinearRelVel(mJointVel*mJointAxis); }
-
-  /// Sets the zero position of the joint.
-  void setZeroPosition(const Vector3& zeroPos)
-  { mZeroPos = zeroPos; setPosition(mZeroPos + mJointPos*mJointAxis); }
-  const Vector3& getZeroPosition(void) const
-  { return mZeroPos; }
-
-  using CartesianJointFrame<1>::setOrientation;
-  
-private:
-  /// The zero position with respect to the parent frame.
-  Vector3 mZeroPos;
-
-  /// The joint rotation axis.
-  Vector3 mJointAxis;
-
-  /// The relative joint translation along the joint axis
-  real_type mJointPos;
-
-  /// The realtive linear velocity along the joint axis
-  real_type mJointVel;
-};
-
-} // namespace OpenFDM
-
-#endif

Deleted: branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteActuatorFrame.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteActuatorFrame.h	2008-11-04 22:16:05 UTC (rev 662)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteActuatorFrame.h	2008-11-04 22:17:07 UTC (rev 663)
@@ -1,93 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
- *
- */
-
-#ifndef OpenFDM_RevoluteActuatorFrame_H
-#define OpenFDM_RevoluteActuatorFrame_H
-
-#include "CartesianActuatorFrame.h"
-
-namespace OpenFDM {
-
-class RevoluteActuatorFrame : public CartesianActuatorFrame<1> {
-  OPENFDM_OBJECT(RevoluteActuatorFrame, CartesianActuatorFrame<1>);
-public:
-  RevoluteActuatorFrame(const std::string& name) :
-    CartesianActuatorFrame<1>(name),
-    mZeroOrient(Quaternion::unit()),
-    mJointAxis(Vector3::unit(0)),
-    mJointPos(0),
-    mJointVel(0)
-  { }
-  virtual ~RevoluteActuatorFrame(void) {}
-
-  /// Gets the joint axis where this joint is allowed to rotate around.
-  const Vector3& getJointAxis(void) const
-  { return mJointAxis; }
-
-  /// Sets the joint axis where this joint is allowed to rotate around.
-  void setJointAxis(const Vector3& axis)
-  {
-    mJointAxis = axis;
-    setOrientation(mZeroOrient*Quaternion::fromAngleAxis(mJointPos, mJointAxis));
-    setAngularRelVel(mJointVel*mJointAxis);
-  }
-
-  /// Returns the joint position.
-  const real_type& getJointPos(void) const
-  { return mJointPos; }
-
-  /// Sets the joint position.
-  void setJointPos(const real_type& pos)
-  {
-    mJointPos = pos;
-    setOrientation(mZeroOrient*Quaternion::fromAngleAxis(mJointPos, mJointAxis));
-  }
-
-  /// Returns the joint velocity.
-  const real_type& getJointVel(void) const
-  { return mJointVel; }
-
-  /// Sets the joint velocity.
-  void setJointVel(const real_type& vel)
-  { mJointVel = vel; setAngularRelVel(mJointVel*mJointAxis); }
-
-  /// Returns the joint acceleration.
-  const real_type& getJointVelDot(void) const
-  { return mJointVelDot; }
-
-  /// Sets the joint velocity.
-  void setJointVelDot(const real_type& velDot)
-  { mJointVelDot = velDot; setAngularRelVelDot(mJointVelDot*mJointAxis); }
-
-  /// Sets the zero orientation of the joint.
-  void setZeroOrientation(const Quaternion& zeroOrient)
-  {
-    mZeroOrient = zeroOrient;
-    setOrientation(zeroOrient*Quaternion::fromAngleAxis(mJointPos, mJointAxis));
-  }
-  const Quaternion& getZeroOrientation(void) const
-  { return mZeroOrient; }
-
-  using CartesianActuatorFrame<1>::setPosition;
-
-private:
-  /// The zero orientation with respect to the parent frame.
-  Quaternion mZeroOrient;
-
-  /// The joint rotation axis.
-  Vector3 mJointAxis;
-
-  /// The relative joint rotation with respect to the zero orientation.
-  real_type mJointPos;
-
-  /// The rotational velocity with respect to the rotation axis.
-  real_type mJointVel;
-
-  /// The rotational acceleration with respect to the rotation axis.
-  real_type mJointVelDot;
-};
-
-} // namespace OpenFDM
-
-#endif

Deleted: branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJointFrame.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJointFrame.h	2008-11-04 22:16:05 UTC (rev 662)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJointFrame.h	2008-11-04 22:17:07 UTC (rev 663)
@@ -1,86 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
- *
- */
-
-#ifndef OpenFDM_RevoluteJointFrame_H
-#define OpenFDM_RevoluteJointFrame_H
-
-#include "CartesianJointFrame.h"
-
-namespace OpenFDM {
-
-class RevoluteJointFrame : public CartesianJointFrame<1> {
-  OPENFDM_OBJECT(RevoluteJointFrame, CartesianJointFrame<1>);
-public:
-  RevoluteJointFrame(const std::string& name) :
-    CartesianJointFrame<1>(name),
-    mZeroOrient(Quaternion::unit()),
-    mJointAxis(Vector3::unit(0)),
-    mJointPos(0),
-    mJointVel(0)
-  {
-    setJointMatrix(Vector6(mJointAxis, Vector3::zeros()));
-  }
-  virtual ~RevoluteJointFrame(void) {}
-
-  /// Gets the joint axis where this joint is allowed to rotate around.
-  const Vector3& getJointAxis(void) const
-  { return mJointAxis; }
-
-  /// Sets the joint axis where this joint is allowed to rotate around.
-  void setJointAxis(const Vector3& axis)
-  {
-    mJointAxis = axis;
-    setJointMatrix(Vector6(axis, Vector3::zeros()));
-    setOrientation(mZeroOrient*Quaternion::fromAngleAxis(mJointPos, mJointAxis));
-    setAngularRelVel(mJointVel*mJointAxis);
-
-  }
-
-  /// Returns the joint position.
-  const real_type& getJointPos(void) const
-  { return mJointPos; }
-
-  /// Sets the joint position.
-  void setJointPos(const real_type& pos)
-  {
-    mJointPos = pos;
-    setOrientation(mZeroOrient*Quaternion::fromAngleAxis(mJointPos, mJointAxis));
-  }
-
-  /// Returns the joint velocity.
-  const real_type& getJointVel(void) const
-  { return mJointVel; }
-
-  /// Sets the joint velocity.
-  void setJointVel(const real_type& vel)
-  { mJointVel = vel; setAngularRelVel(mJointVel*mJointAxis); }
-
-  /// Sets the zero orientation of the joint.
-  void setZeroOrientation(const Quaternion& zeroOrient)
-  {
-    mZeroOrient = zeroOrient;
-    setOrientation(zeroOrient*Quaternion::fromAngleAxis(mJointPos, mJointAxis));
-  }
-  const Quaternion& getZeroOrientation(void) const
-  { return mZeroOrient; }
-
-  using CartesianJointFrame<1>::setPosition;
-
-private:
-  /// The zero orientation with respect to the parent frame.
-  Quaternion mZeroOrient;
-
-  /// The joint rotation axis.
-  Vector3 mJointAxis;
-
-  /// The relative joint rotation with respect to the zero orientation.
-  real_type mJointPos;
-
-  /// The rotational velocity with respect to the rotation axis.
-  real_type mJointVel;
-};
-
-} // namespace OpenFDM
-
-#endif

Deleted: branches/OpenFDM-StateSeparation/src/OpenFDM/RootFrame.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RootFrame.cpp	2008-11-04 22:16:05 UTC (rev 662)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RootFrame.cpp	2008-11-04 22:17:07 UTC (rev 663)
@@ -1,20 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
- *
- */
-
-#include "RootFrame.h"
-
-#include "Frame.h"
-
-namespace OpenFDM {
-
-RootFrame::RootFrame(const std::string& name)
-  : FreeFrame(name)
-{
-}
-
-RootFrame::~RootFrame(void)
-{
-}
-
-} // namespace OpenFDM

Deleted: branches/OpenFDM-StateSeparation/src/OpenFDM/RootFrame.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RootFrame.h	2008-11-04 22:16:05 UTC (rev 662)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RootFrame.h	2008-11-04 22:17:07 UTC (rev 663)
@@ -1,29 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
- *
- */
-
-#ifndef OpenFDM_RootFrame_H
-#define OpenFDM_RootFrame_H
-
-#include "Assert.h"
-#include "Object.h"
-#include "Vector.h"
-#include "Matrix.h"
-#include "Quaternion.h"
-#include "Inertia.h"
-#include "Frame.h"
-#include "RigidBody.h"
-#include "Joint.h"
-
-namespace OpenFDM {
-
-class RootFrame :
-    public FreeFrame {
-public:
-  RootFrame(const std::string& name = std::string());
-  virtual ~RootFrame(void);
-};
-
-} // namespace OpenFDM
-
-#endif



From frohlich at mail.berlios.de  Wed Nov  5 06:52:49 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Wed, 5 Nov 2008 06:52:49 +0100
Subject: [OpenFDM-svn] r664 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811050552.mA55qn7Q019291@sheep.berlios.de>

Author: frohlich
Date: 2008-11-05 06:52:47 +0100 (Wed, 05 Nov 2008)
New Revision: 664

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicContext.cpp
Log:
Use accessors instead of members.

M    MechanicContext.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicContext.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicContext.cpp	2008-11-04 22:17:07 UTC (rev 663)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicContext.cpp	2008-11-05 05:52:47 UTC (rev 664)
@@ -25,16 +25,16 @@
 bool
 MechanicContext::isConnectedTo(const MechanicContext& mechanicContext) const
 {
-  unsigned numPorts = mMechanicNode->getNumPorts();
+  unsigned numPorts = getNode().getNumPorts();
   for (unsigned i = 0; i < numPorts; ++i) {
-    SharedPtr<const PortInfo> portInfo = mMechanicNode->getPort(i);
+    SharedPtr<const PortInfo> portInfo = getNode().getPort(i);
     OpenFDMAssert(portInfo);
     const PortValue* portValue = getPortValueList().getPortValue(i);
     if (!portValue)
       continue;
-    unsigned otherNumPorts = mechanicContext.mMechanicNode->getNumPorts();
+    unsigned otherNumPorts = mechanicContext.getNode().getNumPorts();
     for (unsigned j = 0; j < otherNumPorts; ++j) {
-      if (!mechanicContext.mMechanicNode->getPort(j)->toMechanicLinkInfo())
+      if (!mechanicContext.getNode().getPort(j)->toMechanicLinkInfo())
         continue;
       
       const PortValue* otherPortValue;



From frohlich at mail.berlios.de  Wed Nov  5 07:33:16 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Wed, 5 Nov 2008 07:33:16 +0100
Subject: [OpenFDM-svn] r665 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811050633.mA56XGSN029655@sheep.berlios.de>

Author: frohlich
Date: 2008-11-05 07:33:06 +0100 (Wed, 05 Nov 2008)
New Revision: 665

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicContext.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicContext.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/RigidBody.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/RigidBody.h
Log:
Move context implementation into mechanics classes

M    src/OpenFDM/Interact.cpp
M    src/OpenFDM/MechanicNode.cpp
M    src/OpenFDM/Interact.h
M    src/OpenFDM/RigidBody.h
M    src/OpenFDM/MechanicContext.h
M    src/OpenFDM/RigidBody.cpp
M    src/OpenFDM/MechanicContext.cpp
M    src/OpenFDM/MechanicNode.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.cpp	2008-11-05 05:52:47 UTC (rev 664)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.cpp	2008-11-05 06:33:06 UTC (rev 665)
@@ -5,10 +5,57 @@
 #include "Interact.h"
 
 #include "ConstNodeVisitor.h"
+#include "MechanicContext.h"
 #include "NodeVisitor.h"
 
 namespace OpenFDM {
 
+class Interact::Context : public MechanicContext {
+public:
+  Context(const Interact* interact) : mInteract(interact) {}
+  virtual ~Context() {}
+
+  virtual const Interact& getNode() const
+  { return *mInteract; }
+
+  virtual bool alloc()
+  { if (!allocStates()) return false; return mInteract->alloc(*this); }
+  virtual void initVelocities(const /*Init*/Task& task)
+  {
+    mInteract->init(task, mDiscreteState, mContinousState, mPortValueList);
+    mInteract->velocity(task, mContinousState, mPortValueList);
+  }
+
+  virtual void velocities(const Task& task)
+  {
+    mInteract->velocity(task, mContinousState, mPortValueList);
+  }
+  virtual void articulation(const Task& task)
+  {
+    mInteract->articulation(task, mContinousState, mPortValueList, hIh);
+  }
+  virtual void accelerations(const Task& task)
+  {
+    mInteract->acceleration(task, mContinousState, mPortValueList, hIh, velDot);
+  }
+
+  virtual void derivative(const Task&)
+  {
+    mInteract->derivative(mDiscreteState, mContinousState, mPortValueList,
+                              velDot, mContinousStateDerivative);
+  }
+ 
+  virtual void update(const DiscreteTask&)
+  { }
+
+private:
+  // Stores some values persistent accross velocity/articulation/acceleration
+  Matrix hIh;
+  Vector velDot;
+
+  SharedPtr<const Interact> mInteract;
+};
+
 BEGIN_OPENFDM_OBJECT_DEF(Interact, MechanicNode)
   END_OPENFDM_OBJECT_DEF
 
@@ -33,4 +80,10 @@
   visitor.handleNodePathAndApply(this);
 }
 
+MechanicContext*
+Interact::newMechanicContext() const
+{
+  return new Context(this);
+}
+
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.h	2008-11-05 05:52:47 UTC (rev 664)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.h	2008-11-05 06:33:06 UTC (rev 665)
@@ -18,6 +18,27 @@
 
   virtual void accept(NodeVisitor& visitor);
   virtual void accept(ConstNodeVisitor& visitor) const;
+
+  virtual MechanicContext* newMechanicContext() const;
+
+  virtual void velocity(const Task&, const ContinousStateValueVector&,
+                        PortValueList&) const
+  { }
+  virtual void articulation(const Task&, const ContinousStateValueVector&,
+                            PortValueList&, Matrix&) const
+  { }
+  // hmm, may be this should be output???
+  virtual void acceleration(const Task&, const ContinousStateValueVector&,
+                            PortValueList&, const Matrix&, Vector&) const
+  { }
+  virtual void derivative(const DiscreteStateValueVector&,
+                          const ContinousStateValueVector&,
+                          const PortValueList&, const Vector&,
+                          ContinousStateValueVector&) const
+  { }
+
+private:
+  class Context;
 };
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicContext.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicContext.cpp	2008-11-05 05:52:47 UTC (rev 664)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicContext.cpp	2008-11-05 06:33:06 UTC (rev 665)
@@ -6,22 +6,10 @@
 
 namespace OpenFDM {
 
-MechanicContext::MechanicContext(const MechanicNode* mechanicNode) :
-  mMechanicNode(mechanicNode)
-{
-  OpenFDMAssert(mMechanicNode);
-}
-
 MechanicContext::~MechanicContext()
 {
 }
 
-const MechanicNode&
-MechanicContext::getNode() const
-{
-  return *mMechanicNode;
-}
-
 bool
 MechanicContext::isConnectedTo(const MechanicContext& mechanicContext) const
 {

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicContext.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicContext.h	2008-11-05 05:52:47 UTC (rev 664)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicContext.h	2008-11-05 06:33:06 UTC (rev 665)
@@ -20,55 +20,22 @@
 
 class MechanicContext : public LeafContext {
 public:
-  MechanicContext(const MechanicNode* mechanicNode);
+  MechanicContext() {}
   virtual ~MechanicContext();
 
-  virtual const MechanicNode& getNode() const;
+  virtual const MechanicNode& getNode() const = 0;
 
-  virtual bool alloc()
-  { if (!allocStates()) return false; return mMechanicNode->alloc(*this); }
-  virtual void initVelocities(const /*Init*/Task& task)
-  {
-    mMechanicNode->init(task, mDiscreteState, mContinousState, mPortValueList);
-    mMechanicNode->velocity(task, mContinousState, mPortValueList);
-  }
+  virtual bool alloc() = 0;
+  virtual void initVelocities(const /*Init*/Task& task) = 0;
+  virtual void velocities(const Task& task) = 0;
+  virtual void articulation(const Task& task) = 0;
+  virtual void accelerations(const Task& task) = 0;
+  virtual void derivative(const Task&) = 0;
+  virtual void update(const DiscreteTask& discreteTask) = 0;
 
-  virtual void velocities(const Task& task)
-  {
-    mMechanicNode->velocity(task, mContinousState, mPortValueList);
-  }
-  virtual void articulation(const Task& task)
-  {
-    mMechanicNode->articulation(task, mContinousState, mPortValueList, hIh);
-  }
-  virtual void accelerations(const Task& task)
-  {
-    mMechanicNode->acceleration(task, mContinousState, mPortValueList, hIh, velDot);
-  }
-
-  virtual void derivative(const Task&)
-  {
-    mMechanicNode->derivative(mDiscreteState, mContinousState, mPortValueList,
-                              velDot, mContinousStateDerivative);
-  }
- 
-  virtual void update(const DiscreteTask& discreteTask)
-  {
-    mMechanicNode->update(discreteTask, mDiscreteState,
-                          mContinousState, mPortValueList);
-  }
-
   virtual bool isConnectedTo(const MechanicContext& mechanicContext) const;
 
 private:
-  // Stores some values persistent accross velocity/articulation/acceleration
-  Matrix hIh;
-  Vector velDot;
-
-  SharedPtr<const MechanicNode> mMechanicNode;
-
-private:
-  MechanicContext();
   MechanicContext(const MechanicContext&);
   MechanicContext& operator=(const MechanicContext&);
 };

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.cpp	2008-11-05 05:52:47 UTC (rev 664)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.cpp	2008-11-05 06:33:06 UTC (rev 665)
@@ -40,10 +40,4 @@
   return newMechanicContext();
 }
 
-MechanicContext*
-MechanicNode::newMechanicContext() const
-{
-  return new MechanicContext(this);
-}
-
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.h	2008-11-05 05:52:47 UTC (rev 664)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.h	2008-11-05 06:33:06 UTC (rev 665)
@@ -66,27 +66,8 @@
   virtual void accept(ConstNodeVisitor& visitor) const;
 
   virtual AbstractNodeContext* newNodeContext() const;
-  virtual MechanicContext* newMechanicContext() const;
+  virtual MechanicContext* newMechanicContext() const = 0;
 
-  virtual void velocity(const Task&, const ContinousStateValueVector&,
-                        PortValueList&) const
-  { }
-  virtual void articulation(const Task&, const ContinousStateValueVector&,
-                            PortValueList&, Matrix&) const
-  { }
-  // hmm, may be this should be output???
-  virtual void acceleration(const Task&, const ContinousStateValueVector&,
-                            PortValueList&, const Matrix&, Vector&) const
-  { }
-  virtual void derivative(const DiscreteStateValueVector&,
-                          const ContinousStateValueVector&,
-                          const PortValueList&, const Vector&,
-                          ContinousStateValueVector&) const
-  { }
-  virtual void update(const DiscreteTask&, DiscreteStateValueVector&,
-                      const ContinousStateValueVector&,
-                      const PortValueList&) const
-  { }
 protected:
   MechanicLink newMechanicLink(const std::string& name)
   { return MechanicLink(this, name); }

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RigidBody.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RigidBody.cpp	2008-11-05 05:52:47 UTC (rev 664)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RigidBody.cpp	2008-11-05 06:33:06 UTC (rev 665)
@@ -5,11 +5,54 @@
 #include "RigidBody.h"
 
 #include "ConstNodeVisitor.h"
+#include "MechanicContext.h"
 #include "NodeVisitor.h"
 #include "PortValueList.h"
 
 namespace OpenFDM {
 
+class RigidBody::Context : public MechanicContext {
+public:
+  Context(const RigidBody* rigidBody) : mRigidBody(rigidBody) {}
+  virtual ~Context() {}
+
+  virtual const RigidBody& getNode() const
+  { return *mRigidBody; }
+
+  virtual bool alloc()
+  { if (!allocStates()) return false; return mRigidBody->alloc(*this); }
+  virtual void initVelocities(const /*Init*/Task& task)
+  {
+    mRigidBody->init(task, mDiscreteState, mContinousState, mPortValueList);
+    mRigidBody->velocity(task, mContinousState, mPortValueList);
+  }
+
+  virtual void velocities(const Task& task)
+  {
+    mRigidBody->velocity(task, mContinousState, mPortValueList);
+  }
+  virtual void articulation(const Task& task)
+  {
+    mRigidBody->articulation(task, mContinousState, mPortValueList, hIh);
+  }
+  virtual void accelerations(const Task& task)
+  {
+    mRigidBody->acceleration(task, mContinousState, mPortValueList, hIh, velDot);
+  }
+
+  virtual void derivative(const Task&)
+  { }
+  virtual void update(const DiscreteTask&)
+  { }
+
+private:
+  // Stores some values persistent accross velocity/articulation/acceleration
+  Matrix hIh;
+  Vector velDot;
+
+  SharedPtr<const RigidBody> mRigidBody;
+};
+
 BEGIN_OPENFDM_OBJECT_DEF(RigidBody, MechanicNode)
   END_OPENFDM_OBJECT_DEF
 
@@ -36,6 +79,12 @@
   visitor.handleNodePathAndApply(this);
 }
 
+MechanicContext*
+RigidBody::newMechanicContext() const
+{
+  return new Context(this);
+}
+
 PortId
 RigidBody::addLink(const std::string& name)
 {

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RigidBody.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RigidBody.h	2008-11-05 05:52:47 UTC (rev 664)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RigidBody.h	2008-11-05 06:33:06 UTC (rev 665)
@@ -19,6 +19,8 @@
   virtual void accept(NodeVisitor& visitor);
   virtual void accept(ConstNodeVisitor& visitor) const;
 
+  virtual MechanicContext* newMechanicContext() const;
+
   PortId addLink(const std::string& name);
   void removeLink(const PortId& portId);
 
@@ -38,6 +40,8 @@
                             PortValueList& portValues, const Matrix&,
                             Vector&) const;
 private:
+  class Context;
+
   typedef std::vector<MechanicLink> MechanicLinkVector;
   MechanicLinkVector mMechanicLinks;
 };



From frohlich at mail.berlios.de  Wed Nov  5 07:37:50 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Wed, 5 Nov 2008 07:37:50 +0100
Subject: [OpenFDM-svn] r666 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811050637.mA56boqj006756@sheep.berlios.de>

Author: frohlich
Date: 2008-11-05 07:37:49 +0100 (Wed, 05 Nov 2008)
New Revision: 666

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/RigidBody.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/RigidBody.h
Log:
Remove unused variables from RigidBody::Context

M    src/OpenFDM/RigidBody.h
M    src/OpenFDM/RigidBody.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RigidBody.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RigidBody.cpp	2008-11-05 06:33:06 UTC (rev 665)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RigidBody.cpp	2008-11-05 06:37:49 UTC (rev 666)
@@ -33,11 +33,11 @@
   }
   virtual void articulation(const Task& task)
   {
-    mRigidBody->articulation(task, mContinousState, mPortValueList, hIh);
+    mRigidBody->articulation(task, mContinousState, mPortValueList);
   }
   virtual void accelerations(const Task& task)
   {
-    mRigidBody->acceleration(task, mContinousState, mPortValueList, hIh, velDot);
+    mRigidBody->acceleration(task, mContinousState, mPortValueList);
   }
 
   virtual void derivative(const Task&)
@@ -46,10 +46,6 @@
   { }
 
 private:
-  // Stores some values persistent accross velocity/articulation/acceleration
-  Matrix hIh;
-  Vector velDot;
-
   SharedPtr<const RigidBody> mRigidBody;
 };
 
@@ -118,7 +114,7 @@
 
 void
 RigidBody::articulation(const Task&, const ContinousStateValueVector&,
-                        PortValueList& portValues, Matrix&) const
+                        PortValueList& portValues) const
 {
   unsigned numLinkValues = mMechanicLinks.size();
   MechanicLinkValue& parentLink = portValues[mMechanicLinks.front()];
@@ -128,7 +124,7 @@
 
 void
 RigidBody::acceleration(const Task&, const ContinousStateValueVector&,
-                        PortValueList& portValues, const Matrix&, Vector&) const
+                        PortValueList& portValues) const
 {
   unsigned numLinkValues = mMechanicLinks.size();
   const MechanicLinkValue& parentLink = portValues[mMechanicLinks.front()];

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RigidBody.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RigidBody.h	2008-11-05 06:33:06 UTC (rev 665)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RigidBody.h	2008-11-05 06:37:49 UTC (rev 666)
@@ -32,13 +32,12 @@
   /// contributeForce/contributeInertia method to add inertia to a
   /// parent link???
 
-  virtual void velocity(const Task&, const ContinousStateValueVector& states,
-                        PortValueList& portValues) const;
-  virtual void articulation(const Task&, const ContinousStateValueVector&,
-                            PortValueList& portValues, Matrix&) const;
-  virtual void acceleration(const Task&, const ContinousStateValueVector&,
-                            PortValueList& portValues, const Matrix&,
-                            Vector&) const;
+  void velocity(const Task&, const ContinousStateValueVector& states,
+                PortValueList& portValues) const;
+  void articulation(const Task&, const ContinousStateValueVector&,
+                    PortValueList& portValues) const;
+  void acceleration(const Task&, const ContinousStateValueVector&,
+                    PortValueList& portValues) const;
 private:
   class Context;
 



From frohlich at mail.berlios.de  Wed Nov  5 18:29:19 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Wed, 5 Nov 2008 18:29:19 +0100
Subject: [OpenFDM-svn] r667 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811051729.mA5HTJSE002542@sheep.berlios.de>

Author: frohlich
Date: 2008-11-05 18:29:18 +0100 (Wed, 05 Nov 2008)
New Revision: 667

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.cpp
Log:
Rename leafContext to context.

M    Delay.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.cpp	2008-11-05 06:37:49 UTC (rev 666)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.cpp	2008-11-05 17:29:18 UTC (rev 667)
@@ -35,23 +35,23 @@
 }
 
 bool
-Delay::alloc(LeafContext& leafContext) const
+Delay::alloc(LeafContext& context) const
 {
   Size sz = size(mInitialValue);
   Log(Initialization, Debug)
     << "Size for Delay is detemined by the static initial value "
     << "with size: " << trans(sz) << std::endl;
-  if (!leafContext.mPortValueList.setOrCheckPortSize(mInputPort, sz)) {
+  if (!context.mPortValueList.setOrCheckPortSize(mInputPort, sz)) {
     Log(Initialization, Error)
       << "Size for input port does not match!" << std::endl;
     return false;
   }
-  if (!leafContext.mPortValueList.setOrCheckPortSize(mOutputPort, sz)) {
+  if (!context.mPortValueList.setOrCheckPortSize(mOutputPort, sz)) {
     Log(Initialization, Error)
       << "Size for output port does not match!" << std::endl;
     return false;
   }
-  leafContext.mDiscreteState.setValue(*mMatrixStateInfo, leafContext);
+  context.mDiscreteState.setValue(*mMatrixStateInfo, context);
   return true;
 }
 



From frohlich at mail.berlios.de  Wed Nov  5 20:28:12 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Wed, 5 Nov 2008 20:28:12 +0100
Subject: [OpenFDM-svn] r668 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811051928.mA5JSC0n004173@sheep.berlios.de>

Author: frohlich
Date: 2008-11-05 20:28:11 +0100 (Wed, 05 Nov 2008)
New Revision: 668

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/ConstNodeVisitor.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/ConstNodeVisitor.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Joint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Joint.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteActuator.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteActuator.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
Log:
Reorder class inheritence

M    src/OpenFDM/Joint.cpp
M    src/OpenFDM/CartesianJoint.h
M    src/OpenFDM/RootJoint.cpp
M    src/OpenFDM/RevoluteActuator.cpp
M    src/OpenFDM/NodeVisitor.h
M    src/OpenFDM/RevoluteJoint.cpp
M    src/OpenFDM/ConstNodeVisitor.h
M    src/OpenFDM/RootJoint.h
M    src/OpenFDM/NodeVisitor.cpp
M    src/OpenFDM/RevoluteActuator.h
M    src/OpenFDM/RevoluteJoint.h
M    src/OpenFDM/System.cpp
M    src/OpenFDM/ConstNodeVisitor.cpp
M    src/OpenFDM/MechanicNode.h
M    src/OpenFDM/Joint.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h	2008-11-05 17:29:18 UTC (rev 667)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h	2008-11-05 19:28:11 UTC (rev 668)
@@ -19,15 +19,21 @@
 
 template<unsigned n>
 class CartesianJoint : public Joint {
+  class Context;
 public:
   typedef LinAlg::Vector<real_type,n> VectorN;
   typedef LinAlg::Matrix<real_type,6,n> Matrix6N;
   typedef LinAlg::Matrix<real_type,n,n> MatrixNN;
   typedef LinAlg::MatrixFactors<real_type,n,n,LinAlg::LUTag> MatrixFactorsNN;
 
+  virtual MechanicContext* newMechanicContext() const
+  { return new Context(this); }
+
 protected:
   CartesianJoint(const std::string& name, const Matrix6N& jointMatrix) :
     Joint(name),
+    mParentLink(newMechanicLink("link0")),
+    mChildLink(newMechanicLink("link1")),
     mJointMatrix(jointMatrix)
   { }
   virtual ~CartesianJoint(void)
@@ -51,7 +57,7 @@
   void articulation(MechanicLinkValue& parentLink,
                     const MechanicLinkValue& childLink,
                     const VectorN& jointForce,
-                    Matrix& hIh) const
+                    MatrixFactorsNN& hIh) const
   {
     // The formulas conform to Roy Featherstones book eqn (6.37), (6.38)
     
@@ -61,15 +67,14 @@
     
     // Compute the projection to the joint coordinate space
     Matrix6N Ih = I*mJointMatrix;
-    hIh = trans(mJointMatrix)*Ih;
-    MatrixFactorsNN hIhFac = MatrixNN(hIh);
+    hIh = MatrixNN(trans(mJointMatrix)*Ih);
     
     // Note that the momentum of the local mass is already included in the
     // child links force due the the mass model ...
     Vector6 pAlpha = childLink.getForce() + I*childLink.getFrame().getHdot();
     Vector6 force = pAlpha;
     
-    if (hIhFac.singular()) {
+    if (hIh.singular()) {
       Log(ArtBody,Error) << "Detected singular mass matrix for "
                          << "CartesianJointFrame \"" << getName()
                          << "\": Fix your model!" << endl;
@@ -77,8 +82,8 @@
     }
     
     // Project away the directions handled with this current joint
-    force -= Ih*hIhFac.solve(trans(mJointMatrix)*pAlpha - jointForce);
-    I -= SpatialInertia(Ih*hIhFac.solve(trans(Ih)));
+    force -= Ih*hIh.solve(trans(mJointMatrix)*pAlpha - jointForce);
+    I -= SpatialInertia(Ih*hIh.solve(trans(Ih)));
     
     // Transform to parent link's coordinates and apply to the parent link
     parentLink.applyForce(childLink.getFrame().forceToParent(force));
@@ -90,15 +95,14 @@
    */
   void acceleration(const MechanicLinkValue& parentLink,
                     MechanicLinkValue& childLink, const VectorN& jointForce,
-                    const Matrix& hIh, Vector& velDot) const
+                    const MatrixFactorsNN& hIh, VectorN& velDot) const
   {
     Vector6 parentSpAccel
       = childLink.getFrame().motionFromParent(parentLink.getFrame().getSpAccel());
     
     Vector6 f = childLink.getForce();
     f += childLink.getInertia()*(parentSpAccel + childLink.getFrame().getHdot());
-    MatrixFactorsNN hIhFac = MatrixNN(hIh);
-    velDot = hIhFac.solve(jointForce - trans(mJointMatrix)*f);
+    velDot = hIh.solve(jointForce - trans(mJointMatrix)*f);
     childLink.setAccel(parentLink, mJointMatrix*velDot);
   }
   
@@ -132,7 +136,101 @@
     childLink.setAccel(parentLink, mJointMatrix*velDot);
   }
 
+  virtual void velocity(const MechanicLinkValue& parentLink,
+                        MechanicLinkValue& childLink,
+                        const ContinousStateValueVector& states,
+                        PortValueList& portValues) const = 0;
+  virtual void articulation(MechanicLinkValue& parentLink,
+                            const MechanicLinkValue& childLink,
+                            const ContinousStateValueVector& states,
+                            PortValueList& portValues,
+                            MatrixFactorsNN& hIh) const = 0;
+  virtual void acceleration(const MechanicLinkValue& parentLink,
+                            MechanicLinkValue& childLink,
+                            const ContinousStateValueVector& states,
+                            PortValueList& portValues,
+                            const MatrixFactorsNN& hIh,
+                            VectorN& velDot) const = 0;
+  virtual void derivative(const DiscreteStateValueVector&,
+                          const ContinousStateValueVector&,
+                          const PortValueList& portValues, const VectorN&,
+                          ContinousStateValueVector&) const = 0;
+
+  void velocity(const Task&,
+                const ContinousStateValueVector& continousState,
+                PortValueList& portValues) const
+  {
+    velocity(portValues[mParentLink], portValues[mChildLink],
+             continousState, portValues);
+  }
+
+  void articulation(const Task&,
+                    const ContinousStateValueVector& continousState,
+                    PortValueList& portValues, MatrixFactorsNN& hIh) const
+  {
+    articulation(portValues[mParentLink], portValues[mChildLink],
+                 continousState, portValues, hIh);
+  }
+
+  void acceleration(const Task&,
+                    const ContinousStateValueVector& continousState,
+                    PortValueList& portValues, const MatrixFactorsNN& hIh,
+                    VectorN& velDot) const
+  {
+    acceleration(portValues[mParentLink], portValues[mChildLink],
+                 continousState, portValues, hIh, velDot);
+  }
+  
 private:
+  class Context : public MechanicContext {
+  public:
+    Context(const CartesianJoint* cartesianJoint) : mCartesianJoint(cartesianJoint) {}
+    virtual ~Context() {}
+    
+    virtual const CartesianJoint& getNode() const
+    { return *mCartesianJoint; }
+    
+    virtual bool alloc()
+    { if (!allocStates()) return false; return mCartesianJoint->alloc(*this); }
+    virtual void initVelocities(const /*Init*/Task& task)
+    {
+      mCartesianJoint->init(task, mDiscreteState, mContinousState, mPortValueList);
+      mCartesianJoint->velocity(task, mContinousState, mPortValueList);
+    }
+    
+    virtual void velocities(const Task& task)
+    {
+      mCartesianJoint->velocity(task, mContinousState, mPortValueList);
+    }
+    virtual void articulation(const Task& task)
+    {
+      mCartesianJoint->articulation(task, mContinousState, mPortValueList, hIh);
+    }
+    virtual void accelerations(const Task& task)
+    {
+      mCartesianJoint->acceleration(task, mContinousState, mPortValueList, hIh, velDot);
+    }
+    
+    virtual void derivative(const Task&)
+    {
+      mCartesianJoint->derivative(mDiscreteState, mContinousState, mPortValueList,
+                         velDot, mContinousStateDerivative);
+    }
+    
+    virtual void update(const DiscreteTask&)
+    { }
+    
+  private:
+    // Stores some values persistent accross velocity/articulation/acceleration
+    MatrixFactorsNN hIh;
+    VectorN velDot;
+    
+    SharedPtr<const CartesianJoint> mCartesianJoint;
+  };
+  
+  MechanicLink mParentLink;
+  MechanicLink mChildLink;
+
   Matrix6N mJointMatrix;
 };
 

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/ConstNodeVisitor.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ConstNodeVisitor.cpp	2008-11-05 17:29:18 UTC (rev 667)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ConstNodeVisitor.cpp	2008-11-05 19:28:11 UTC (rev 668)
@@ -11,6 +11,7 @@
 #include "MechanicNode.h"
 #include "Model.h"
 #include "Input.h"
+#include "Joint.h"
 #include "Output.h"
 #include "RigidBody.h"
 #include "RootJoint.h"
@@ -84,7 +85,7 @@
 }
 
 void
-ConstNodeVisitor::apply(const Interact& node)
+ConstNodeVisitor::apply(const Joint& node)
 {
   apply(static_cast<const MechanicNode&>(node));
 }
@@ -92,10 +93,16 @@
 void
 ConstNodeVisitor::apply(const RootJoint& node)
 {
-  apply(static_cast<const Interact&>(node));
+  apply(static_cast<const Joint&>(node));
 }
 
 void
+ConstNodeVisitor::apply(const Interact& node)
+{
+  apply(static_cast<const MechanicNode&>(node));
+}
+
+void
 ConstNodeVisitor::apply(const PortInfo& portInfo)
 {
 }

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/ConstNodeVisitor.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ConstNodeVisitor.h	2008-11-05 17:29:18 UTC (rev 667)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ConstNodeVisitor.h	2008-11-05 19:28:11 UTC (rev 668)
@@ -17,6 +17,7 @@
 class LeafNode;
 class Model;
 class Input;
+class Joint;
 class Output;
 class MechanicNode;
 class RigidBody;
@@ -47,9 +48,11 @@
 
   virtual void apply(const RigidBody&);
 
-  virtual void apply(const Interact&);
+  virtual void apply(const Joint&);
   virtual void apply(const RootJoint&);
 
+  virtual void apply(const Interact&);
+
   virtual void apply(const PortInfo&);
   virtual void apply(const NumericPortInfo&);
   virtual void apply(const MechanicLinkInfo&);

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Joint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Joint.cpp	2008-11-05 17:29:18 UTC (rev 667)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Joint.cpp	2008-11-05 19:28:11 UTC (rev 668)
@@ -5,6 +5,7 @@
 #include "Joint.h"
 
 #include "Assert.h"
+#include "ConstNodeVisitor.h"
 #include "Object.h"
 #include "Vector.h"
 #include "Matrix.h"
@@ -14,16 +15,15 @@
 #include "LogStream.h"
 #include "PortValueList.h"
 #include "MechanicContext.h"
+#include "NodeVisitor.h"
 
 namespace OpenFDM {
 
-BEGIN_OPENFDM_OBJECT_DEF(Joint, Interact)
+BEGIN_OPENFDM_OBJECT_DEF(Joint, MechanicNode)
   END_OPENFDM_OBJECT_DEF
 
 Joint::Joint(const std::string& name) :
-  Interact(name),
-  mParentLink(newMechanicLink("link0")),
-  mChildLink(newMechanicLink("link1"))
+  MechanicNode(name)
 {
 }
 
@@ -32,31 +32,15 @@
 }
 
 void
-Joint::velocity(const Task&,
-                const ContinousStateValueVector& continousState,
-                PortValueList& portValues) const
+Joint::accept(NodeVisitor& visitor)
 {
-  velocity(portValues[mParentLink], portValues[mChildLink],
-           continousState, portValues);
+  visitor.handleNodePathAndApply(this);
 }
 
 void
-Joint::articulation(const Task&,
-                    const ContinousStateValueVector& continousState,
-                    PortValueList& portValues, Matrix& hIh) const
+Joint::accept(ConstNodeVisitor& visitor) const
 {
-  articulation(portValues[mParentLink], portValues[mChildLink],
-               continousState, portValues, hIh);
+  visitor.handleNodePathAndApply(this);
 }
 
-void
-Joint::acceleration(const Task&,
-                    const ContinousStateValueVector& continousState,
-                    PortValueList& portValues, const Matrix& hIh,
-                    Vector& velDot) const
-{
-  acceleration(portValues[mParentLink], portValues[mChildLink],
-               continousState, portValues, hIh, velDot);
-}
-
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Joint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Joint.h	2008-11-05 17:29:18 UTC (rev 667)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Joint.h	2008-11-05 19:28:11 UTC (rev 668)
@@ -18,40 +18,14 @@
 
 namespace OpenFDM {
 
-class Joint : public Interact {
-  OPENFDM_OBJECT(Joint, Interact);
+class Joint : public MechanicNode {
+  OPENFDM_OBJECT(Joint, MechanicNode);
 public:
   Joint(const std::string& name);
   virtual ~Joint(void);
 
-  // Joints cannot do something different than apply forces and inertia to
-  // its parent.
-  virtual void velocity(const MechanicLinkValue& parentLink,
-                        MechanicLinkValue& childLink,
-                        const ContinousStateValueVector& states,
-                        PortValueList& portValues) const = 0;
-  virtual void articulation(MechanicLinkValue& parentLink,
-                            const MechanicLinkValue& childLink,
-                            const ContinousStateValueVector& states,
-                            PortValueList& portValues,
-                            Matrix& hIh) const = 0;
-  virtual void acceleration(const MechanicLinkValue& parentLink,
-                            MechanicLinkValue& childLink,
-                            const ContinousStateValueVector& states,
-                            PortValueList& portValues,
-                            const Matrix& hIh, Vector& velDot) const = 0;
-
-  /// They implement the mechanic stuff
-  virtual void velocity(const Task&, const ContinousStateValueVector&,
-                        PortValueList&) const;
-  virtual void articulation(const Task&, const ContinousStateValueVector&,
-                            PortValueList&, Matrix& hIh) const;
-  virtual void acceleration(const Task&, const ContinousStateValueVector&,
-                            PortValueList&, const Matrix& hIh,
-                            Vector& velDot) const;
-private:
-  MechanicLink mParentLink;
-  MechanicLink mChildLink;
+  virtual void accept(NodeVisitor& visitor);
+  virtual void accept(ConstNodeVisitor& visitor) const;
 };
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.h	2008-11-05 17:29:18 UTC (rev 667)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.h	2008-11-05 19:28:11 UTC (rev 668)
@@ -24,15 +24,6 @@
 // Interact, something similar we have now for the mechanic context??
 
 // Current inheritence tree:
-// Leaf - Model ...
-//      |
-//      |- MechanicNode -- RigidBody
-//                      |- Interact  -- Mass
-//                                   |- Force
-//                                   |- Joint
-//                                   |- RootJoint
-
-// Desired inheritence tree:
 // Leaf?- Model ...
 //      |
 //      |- MechanicNode?-- RigidBody
@@ -45,10 +36,8 @@
 //                                   |- CartesianJoint -- RevoluteJoint
 //                                                     | ...
 
-
 // TODO:
 // * Remove AbstractNodeContext ...
-// * Make Inheritance for mechanics like that ...
 // * allocate contexts later ...
 
 class DiscreteTask;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.cpp	2008-11-05 17:29:18 UTC (rev 667)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.cpp	2008-11-05 19:28:11 UTC (rev 668)
@@ -7,6 +7,7 @@
 #include "Group.h"
 #include "Input.h"
 #include "Interact.h"
+#include "Joint.h"
 #include "LibraryNode.h"
 #include "LeafNode.h"
 #include "MechanicNode.h"
@@ -84,7 +85,7 @@
 }
 
 void
-NodeVisitor::apply(Interact& node)
+NodeVisitor::apply(Joint& node)
 {
   apply(static_cast<MechanicNode&>(node));
 }
@@ -92,10 +93,16 @@
 void
 NodeVisitor::apply(RootJoint& node)
 {
-  apply(static_cast<Interact&>(node));
+  apply(static_cast<Joint&>(node));
 }
 
 void
+NodeVisitor::apply(Interact& node)
+{
+  apply(static_cast<MechanicNode&>(node));
+}
+
+void
 NodeVisitor::apply(const PortInfo& portInfo)
 {
 }

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.h	2008-11-05 17:29:18 UTC (rev 667)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.h	2008-11-05 19:28:11 UTC (rev 668)
@@ -17,6 +17,7 @@
 class LeafNode;
 class Model;
 class Input;
+class Joint;
 class Output;
 class MechanicNode;
 class RigidBody;
@@ -47,9 +48,11 @@
 
   virtual void apply(RigidBody&);
 
-  virtual void apply(Interact&);
+  virtual void apply(Joint&);
   virtual void apply(RootJoint&);
 
+  virtual void apply(Interact&);
+
   virtual void apply(const PortInfo&);
   virtual void apply(const NumericPortInfo&);
   virtual void apply(const MechanicLinkInfo&);

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteActuator.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteActuator.cpp	2008-11-05 17:29:18 UTC (rev 667)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteActuator.cpp	2008-11-05 19:28:11 UTC (rev 668)
@@ -130,7 +130,7 @@
                                MechanicLinkValue& childLink,
                                const ContinousStateValueVector& states,
                                PortValueList& portValues,
-                               const Matrix&, Vector& velDot) const
+                               const Matrix&, VectorN& velDot) const
 {
   // This is a simple second order system with velocity limits.
   // the joints accelerations, velocities and positions must fit together
@@ -156,16 +156,14 @@
     // and accelerate that proportional to that error ...
     velDot = mVelDotGain*velErr;
   }
-  // FIXME
-  VectorN _velDot = velDot;
 
-  acceleration(parentLink, childLink, _velDot);
+  acceleration(parentLink, childLink, velDot);
 }
 
 void
 RevoluteActuator::derivative(const DiscreteStateValueVector&,
                              const ContinousStateValueVector& states,
-                             const PortValueList&, const Vector& velDot,
+                             const PortValueList&, const VectorN& velDot,
                              ContinousStateValueVector& derivative) const
 {
   derivative[*mPositionStateInfo] = states[*mVelocityStateInfo];

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteActuator.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteActuator.h	2008-11-05 17:29:18 UTC (rev 667)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteActuator.h	2008-11-05 19:28:11 UTC (rev 668)
@@ -52,11 +52,12 @@
                             MechanicLinkValue& childLink,
                             const ContinousStateValueVector& states,
                             PortValueList& portValues,
-                            const Matrix& hIh, Vector& velDot) const;
+                            const Matrix& hIh, VectorN& velDot) const;
 
   virtual void derivative(const DiscreteStateValueVector&,
                           const ContinousStateValueVector&,
-                          const PortValueList& portValues, const Vector& velDot,
+                          const PortValueList& portValues,
+                          const VectorN& velDot,
                           ContinousStateValueVector&) const;
 
   using CartesianJoint<1>::velocity;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.cpp	2008-11-05 17:29:18 UTC (rev 667)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.cpp	2008-11-05 19:28:11 UTC (rev 668)
@@ -93,7 +93,7 @@
                             const MechanicLinkValue& childLink,
                             const ContinousStateValueVector& states,
                             PortValueList& portValues,
-                            Matrix& hIh) const
+                            MatrixFactorsNN& hIh) const
 {
   VectorN jointForce;
   if (mForcePort.empty())
@@ -109,7 +109,7 @@
                             MechanicLinkValue& childLink,
                             const ContinousStateValueVector& states,
                             PortValueList& portValues,
-                            const Matrix& hIh, Vector& velDot) const
+                            const MatrixFactorsNN& hIh, VectorN& velDot) const
 {
   VectorN jointForce;
   if (mForcePort.empty())
@@ -123,7 +123,7 @@
 void
 RevoluteJoint::derivative(const DiscreteStateValueVector&,
                           const ContinousStateValueVector& states,
-                          const PortValueList&, const Vector& velDot,
+                          const PortValueList&, const VectorN& velDot,
                           ContinousStateValueVector& derivative) const
 {
   derivative[*mPositionStateInfo] = states[*mVelocityStateInfo];

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.h	2008-11-05 17:29:18 UTC (rev 667)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.h	2008-11-05 19:28:11 UTC (rev 668)
@@ -47,16 +47,17 @@
                             const MechanicLinkValue& childLink,
                             const ContinousStateValueVector& states,
                             PortValueList& portValues,
-                            Matrix& hIh) const;
+                            MatrixFactorsNN& hIh) const;
   virtual void acceleration(const MechanicLinkValue& parentLink,
                             MechanicLinkValue& childLink,
                             const ContinousStateValueVector& states,
                             PortValueList& portValues,
-                            const Matrix& hIh, Vector& velDot) const;
+                            const MatrixFactorsNN& hIh, VectorN& velDot) const;
 
   virtual void derivative(const DiscreteStateValueVector&,
                           const ContinousStateValueVector&,
-                          const PortValueList& portValues, const Vector& velDot,
+                          const PortValueList& portValues,
+                          const VectorN& velDot,
                           ContinousStateValueVector&) const;
 
   using CartesianJoint<1>::velocity;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.cpp	2008-11-05 17:29:18 UTC (rev 667)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.cpp	2008-11-05 19:28:11 UTC (rev 668)
@@ -5,16 +5,63 @@
 #include "RootJoint.h"
 
 #include "ConstNodeVisitor.h"
+#include "MechanicContext.h"
 #include "NodeVisitor.h"
 
 namespace OpenFDM {
 
-BEGIN_OPENFDM_OBJECT_DEF(RootJoint, Interact)
+class RootJoint::Context : public MechanicContext {
+public:
+  Context(const RootJoint* rootJoint) : mRootJoint(rootJoint) {}
+  virtual ~Context() {}
+  
+  virtual const RootJoint& getNode() const
+  { return *mRootJoint; }
+  
+  virtual bool alloc()
+  { if (!allocStates()) return false; return mRootJoint->alloc(*this); }
+  virtual void initVelocities(const /*Init*/Task& task)
+  {
+    mRootJoint->init(task, mDiscreteState, mContinousState, mPortValueList);
+    mRootJoint->velocity(task, mContinousState, mPortValueList);
+  }
+  
+  virtual void velocities(const Task& task)
+  {
+    mRootJoint->velocity(task, mContinousState, mPortValueList);
+  }
+  virtual void articulation(const Task& task)
+  {
+    mRootJoint->articulation(task, mContinousState, mPortValueList, hIh);
+  }
+  virtual void accelerations(const Task& task)
+  {
+    mRootJoint->acceleration(task, mContinousState, mPortValueList, hIh, velDot);
+  }
+  
+  virtual void derivative(const Task&)
+  {
+    mRootJoint->derivative(mDiscreteState, mContinousState, mPortValueList,
+                       velDot, mContinousStateDerivative);
+  }
+  
+  virtual void update(const DiscreteTask&)
+  { }
+  
+private:
+  // Stores some values persistent accross velocity/articulation/acceleration
+  Matrix hIh;
+  Vector velDot;
+  
+  SharedPtr<const RootJoint> mRootJoint;
+};
+  
+BEGIN_OPENFDM_OBJECT_DEF(RootJoint, Joint)
   DEF_OPENFDM_PROPERTY(Matrix, AngularBaseVelocity, Serialized)
   END_OPENFDM_OBJECT_DEF
 
 RootJoint::RootJoint(const std::string& name) :
-  Interact(name),
+  Joint(name),
   mAngularBaseVelocity(Vector3::zeros())
 {
 }
@@ -23,6 +70,12 @@
 {
 }
 
+MechanicContext*
+RootJoint::newMechanicContext() const
+{
+  return new Context(this);
+}
+
 void
 RootJoint::accept(NodeVisitor& visitor)
 {

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.h	2008-11-05 17:29:18 UTC (rev 667)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.h	2008-11-05 19:28:11 UTC (rev 668)
@@ -6,16 +6,18 @@
 #define OpenFDM_RootJoint_H
 
 #include <string>
-#include "Interact.h"
+#include "Joint.h"
 
 namespace OpenFDM {
 
-class RootJoint : public Interact {
-  OPENFDM_OBJECT(RootJoint, Interact);
+class RootJoint : public Joint {
+  OPENFDM_OBJECT(RootJoint, Joint);
 public:
   RootJoint(const std::string& name);
   virtual ~RootJoint();
 
+  virtual MechanicContext* newMechanicContext() const;
+
   virtual void accept(NodeVisitor& visitor);
   virtual void accept(ConstNodeVisitor& visitor) const;
 
@@ -24,7 +26,21 @@
   void setAngularBaseVelocity(const Vector3& angularBaseVelocity)
   { mAngularBaseVelocity = angularBaseVelocity; }
 
+  virtual void velocity(const Task&, const ContinousStateValueVector&,
+                        PortValueList&) const = 0;
+  virtual void articulation(const Task&, const ContinousStateValueVector&,
+                            PortValueList&, Matrix& hIh) const = 0;
+  virtual void acceleration(const Task&, const ContinousStateValueVector&,
+                            PortValueList&, const Matrix& hIh,
+                            Vector& velDot) const = 0;
+  virtual void derivative(const DiscreteStateValueVector&,
+                          const ContinousStateValueVector&,
+                          const PortValueList& portValues, const Vector&,
+                          ContinousStateValueVector&) const = 0;
+
 private:
+  class Context;
+
   Vector3 mAngularBaseVelocity;
 };
 

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-05 17:29:18 UTC (rev 667)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-05 19:28:11 UTC (rev 668)
@@ -7,10 +7,13 @@
 #include "AbstractSystem.h"
 #include "ConstNodeVisitor.h"
 #include "Group.h"
+#include "Interact.h"
+#include "Joint.h"
 #include "ModelInstance.h"
 #include "MechanicInstance.h"
 #include "NodeInstance.h"
 #include "Object.h"
+#include "RigidBody.h"
 #include "RootJoint.h"
 #include "SystemOutput.h"
 #include "Task.h"
@@ -378,6 +381,8 @@
 
   virtual void apply(const Node& node)
   { Log(Schedule, Error) << __PRETTY_FUNCTION__ << std::endl; }
+  virtual void apply(const MechanicNode& node)
+  { Log(Schedule, Error) << __PRETTY_FUNCTION__ << std::endl; }
   virtual void apply(const LeafNode& leaf)
   { Log(Schedule, Error) << __PRETTY_FUNCTION__ << std::endl; }
   virtual void apply(const LibraryNode& libraryNode)
@@ -421,16 +426,30 @@
     if (node.getNumPorts() == 1)
       _rootJointInstanceList.push_back(mechanicInstance);
     else
-      _mechanicInstanceList.push_back(mechanicInstance);
+      _jointInstanceList.push_back(mechanicInstance);
     allocPortData(mechanicInstance, node);
   }
-  virtual void apply(const MechanicNode& node)
+  virtual void apply(const Interact& node)
   {
     MechanicInstance* mechanicInstance = new MechanicInstance(getNodePath(), mSampleTime, &node);
     _nodeInstanceList.push_back(mechanicInstance);
-    _mechanicInstanceList.push_back(mechanicInstance);
+    _interactInstanceList.push_back(mechanicInstance);
     allocPortData(mechanicInstance, node);
   }
+  virtual void apply(const RigidBody& node)
+  {
+    MechanicInstance* mechanicInstance = new MechanicInstance(getNodePath(), mSampleTime, &node);
+    _nodeInstanceList.push_back(mechanicInstance);
+    _rigidBodyInstanceList.push_back(mechanicInstance);
+    allocPortData(mechanicInstance, node);
+  }
+  virtual void apply(const Joint& node)
+  {
+    MechanicInstance* mechanicInstance = new MechanicInstance(getNodePath(), mSampleTime, &node);
+    _nodeInstanceList.push_back(mechanicInstance);
+    _jointInstanceList.push_back(mechanicInstance);
+    allocPortData(mechanicInstance, node);
+  }
   virtual void apply(const Model& node)
   {
     ModelInstance* modelInstance = new ModelInstance(getNodePath(), mSampleTime, &node);
@@ -564,10 +583,13 @@
   ModelInstanceList _modelInstanceList;
   // The mechanical system list, also for sorting
   MechanicInstanceList _mechanicInstanceList;
+
   // The list of root nodes in the mechanical system. Will be a starting point
   // for sorting the tree of mechanical models downwards
-  typedef MechanicInstanceList RootJointInstanceList;
-  RootJointInstanceList _rootJointInstanceList;
+  MechanicInstanceList _rootJointInstanceList;
+  MechanicInstanceList _interactInstanceList;
+  MechanicInstanceList _jointInstanceList;
+  MechanicInstanceList _rigidBodyInstanceList;
 
   ////////////////////////////////////////////////////////////////////////////
   // Used to map connections in groups ...
@@ -642,32 +664,45 @@
   // method to sort the leafs according to their dependency
   bool sortMechanicList()
   {
-    MechanicInstanceList sortedMechanicInstanceList;
+    // For now RigidBody nodes still do computations
+    // FIXME
+    _jointInstanceList.splice(_jointInstanceList.end(),
+                              _rigidBodyInstanceList,
+                              _rigidBodyInstanceList.begin(),
+                              _rigidBodyInstanceList.end());
+
+    if (_rootJointInstanceList.empty() &&
+        (!_jointInstanceList.empty() || !_interactInstanceList.empty())) {
+      Log(Schedule,Error)
+        << "No root joint in System with mechanic components" << std::endl;
+      return false;
+    }
+
     // Start with all the roots in front of the list ...
     // FIXME: ensure that there is no loop here?
-    sortedMechanicInstanceList.swap(_rootJointInstanceList);
+    _mechanicInstanceList.swap(_rootJointInstanceList);
 
     // Not the best algorithm, but for a first cut ...
-    while (!_mechanicInstanceList.empty()) {
+    while (!_jointInstanceList.empty()) {
       MechanicInstanceList nextLevelList;
 
       MechanicInstanceList::iterator j;
-      for (j = sortedMechanicInstanceList.begin();
-           j != sortedMechanicInstanceList.end(); ++j) {
+      for (j = _mechanicInstanceList.begin();
+           j != _mechanicInstanceList.end(); ++j) {
         MechanicInstanceList::iterator i;
-        for (i = _mechanicInstanceList.begin();
-             i != _mechanicInstanceList.end();) {
+        for (i = _jointInstanceList.begin();
+             i != _jointInstanceList.end();) {
         
           if ((*j)->isConnectedTo(*(*i))) {
             SharedPtr<MechanicInstance> mechanicInstance = *i;
             nextLevelList.push_back(mechanicInstance);
-            i = _mechanicInstanceList.erase(i);
+            i = _jointInstanceList.erase(i);
 
             // Check if this current mechanic node does not reference
             // back into the already sorted models
             MechanicInstanceList::const_iterator k;
-            for (k = sortedMechanicInstanceList.begin();
-                 k != sortedMechanicInstanceList.end(); ++k) {
+            for (k = _mechanicInstanceList.begin();
+                 k != _mechanicInstanceList.end(); ++k) {
               if (*k == *j)
                 continue;
               if (mechanicInstance->isConnectedTo(*(*k))) {
@@ -705,12 +740,16 @@
       
 
       for (j = nextLevelList.begin(); j != nextLevelList.end(); ++j) {
-        sortedMechanicInstanceList.push_back(*j);
+        _mechanicInstanceList.push_back(*j);
       }
     }
+
+    // Interacts are always computed at the end of the list
+    _mechanicInstanceList.splice(_mechanicInstanceList.end(),
+                                      _interactInstanceList,
+                                      _interactInstanceList.begin(),
+                                      _interactInstanceList.end());
     
-    _mechanicInstanceList.swap(sortedMechanicInstanceList);
-
     Log(Schedule,Info) << "MechanicNode Schedule" << std::endl;
     MechanicInstanceList::iterator i = _mechanicInstanceList.begin();
     for (; i != _mechanicInstanceList.end(); ++i) {



From frohlich at mail.berlios.de  Wed Nov  5 20:39:33 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Wed, 5 Nov 2008 20:39:33 +0100
Subject: [OpenFDM-svn] r669 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811051939.mA5JdXDM005043@sheep.berlios.de>

Author: frohlich
Date: 2008-11-05 20:39:33 +0100 (Wed, 05 Nov 2008)
New Revision: 669

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJoint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJoint.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.h
Log:
Less parameters in RootJoint::Context

M    src/OpenFDM/MobileRootJoint.cpp
M    src/OpenFDM/RootJoint.cpp
M    src/OpenFDM/MobileRootJoint.h
M    src/OpenFDM/RootJoint.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJoint.cpp	2008-11-05 19:28:11 UTC (rev 668)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJoint.cpp	2008-11-05 19:39:33 UTC (rev 669)
@@ -61,15 +61,14 @@
 
 void
 MobileRootJoint::articulation(const Task&, const ContinousStateValueVector&,
-                              PortValueList&, Matrix&) const
+                              PortValueList&) const
 {
   /// In this case a noop.
 }
 
 void
 MobileRootJoint::acceleration(const Task&, const ContinousStateValueVector&,
-                              PortValueList& portValues,
-                              const Matrix&, Vector&) const
+                              PortValueList& portValues) const
 {
   // Assumption: body is small compared to the distance to the planets
   // center of mass. That means gravity could be considered equal for the
@@ -92,7 +91,6 @@
 MobileRootJoint::derivative(const DiscreteStateValueVector&,
                             const ContinousStateValueVector& continousState,
                             const PortValueList& portValues,
-                            const Vector& context,
                             ContinousStateValueVector& derivatives) const
 {
   Quaternion orientation = continousState[*mOrientationStateInfo];

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJoint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJoint.h	2008-11-05 19:28:11 UTC (rev 668)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJoint.h	2008-11-05 19:39:33 UTC (rev 669)
@@ -28,13 +28,12 @@
   virtual void velocity(const Task&, const ContinousStateValueVector& states,
                         PortValueList& portValues) const;
   virtual void articulation(const Task&, const ContinousStateValueVector&,
-                            PortValueList& portValues, Matrix&) const;
+                            PortValueList& portValues) const;
   virtual void acceleration(const Task&, const ContinousStateValueVector&,
-                            PortValueList& portValues, const Matrix&,
-                            Vector&) const;
+                            PortValueList& portValues) const;
   virtual void derivative(const DiscreteStateValueVector&,
                           const ContinousStateValueVector&,
-                          const PortValueList& portValues, const Vector&,
+                          const PortValueList& portValues,
                           ContinousStateValueVector&) const;
 private:
   MechanicLink mMechanicLink;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.cpp	2008-11-05 19:28:11 UTC (rev 668)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.cpp	2008-11-05 19:39:33 UTC (rev 669)
@@ -32,27 +32,23 @@
   }
   virtual void articulation(const Task& task)
   {
-    mRootJoint->articulation(task, mContinousState, mPortValueList, hIh);
+    mRootJoint->articulation(task, mContinousState, mPortValueList);
   }
   virtual void accelerations(const Task& task)
   {
-    mRootJoint->acceleration(task, mContinousState, mPortValueList, hIh, velDot);
+    mRootJoint->acceleration(task, mContinousState, mPortValueList);
   }
   
   virtual void derivative(const Task&)
   {
     mRootJoint->derivative(mDiscreteState, mContinousState, mPortValueList,
-                       velDot, mContinousStateDerivative);
+                           mContinousStateDerivative);
   }
   
   virtual void update(const DiscreteTask&)
   { }
   
 private:
-  // Stores some values persistent accross velocity/articulation/acceleration
-  Matrix hIh;
-  Vector velDot;
-  
   SharedPtr<const RootJoint> mRootJoint;
 };
   

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.h	2008-11-05 19:28:11 UTC (rev 668)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.h	2008-11-05 19:39:33 UTC (rev 669)
@@ -29,13 +29,12 @@
   virtual void velocity(const Task&, const ContinousStateValueVector&,
                         PortValueList&) const = 0;
   virtual void articulation(const Task&, const ContinousStateValueVector&,
-                            PortValueList&, Matrix& hIh) const = 0;
+                            PortValueList&) const = 0;
   virtual void acceleration(const Task&, const ContinousStateValueVector&,
-                            PortValueList&, const Matrix& hIh,
-                            Vector& velDot) const = 0;
+                            PortValueList&) const = 0;
   virtual void derivative(const DiscreteStateValueVector&,
                           const ContinousStateValueVector&,
-                          const PortValueList& portValues, const Vector&,
+                          const PortValueList& portValues,
                           ContinousStateValueVector&) const = 0;
 
 private:



From frohlich at mail.berlios.de  Wed Nov  5 20:44:26 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Wed, 5 Nov 2008 20:44:26 +0100
Subject: [OpenFDM-svn] r670 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811051944.mA5JiQJt005610@sheep.berlios.de>

Author: frohlich
Date: 2008-11-05 20:44:26 +0100 (Wed, 05 Nov 2008)
New Revision: 670

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.h
Log:
Remove unused decls.

M    src/OpenFDM/MechanicNode.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.h	2008-11-05 19:39:33 UTC (rev 669)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.h	2008-11-05 19:44:26 UTC (rev 670)
@@ -40,9 +40,6 @@
 // * Remove AbstractNodeContext ...
 // * allocate contexts later ...
 
-class DiscreteTask;
-class PortValueList;
-class Task;
 class MechanicContext;
 
 class MechanicNode : public LeafNode {



From frohlich at mail.berlios.de  Wed Nov  5 22:16:11 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Wed, 5 Nov 2008 22:16:11 +0100
Subject: [OpenFDM-svn] r671 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811052116.mA5LGBPH014746@sheep.berlios.de>

Author: frohlich
Date: 2008-11-05 22:16:11 +0100 (Wed, 05 Nov 2008)
New Revision: 671

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
   branches/OpenFDM-StateSeparation/src/OpenFDM/PrismaticJoint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/PrismaticJoint.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.cpp
Log:
Reimplement PrismaticJoint

M    src/OpenFDM/Makefile.am
M    src/OpenFDM/PrismaticJoint.cpp
M    src/OpenFDM/RevoluteJoint.cpp
M    src/OpenFDM/PrismaticJoint.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-11-05 19:44:26 UTC (rev 670)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-11-05 21:16:11 UTC (rev 671)
@@ -243,6 +243,7 @@
   Joint.cpp \
   Mass.cpp \
   MobileRootJoint.cpp \
+  PrismaticJoint.cpp \
   RevoluteActuator.cpp \
   RevoluteJoint.cpp
 
@@ -270,7 +271,6 @@
 #   MinModel.cpp \
 #   Output.cpp \
 #   Product.cpp \
-#   PrismaticJoint.cpp \
 #   RigidBody.cpp \
 #   Saturation.cpp \
 #   SimpleContact.cpp \

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/PrismaticJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/PrismaticJoint.cpp	2008-11-05 19:44:26 UTC (rev 670)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/PrismaticJoint.cpp	2008-11-05 21:16:11 UTC (rev 671)
@@ -3,167 +3,129 @@
  */
 
 #include "PrismaticJoint.h"
-
 #include "Assert.h"
 #include "LogStream.h"
-#include "Object.h"
 #include "Limits.h"
+#include "Object.h"
 #include "Vector.h"
 #include "Matrix.h"
 #include "Quaternion.h"
 #include "Inertia.h"
-#include "Frame.h"
-#include "RigidBody.h"
-#include "PrismaticJointFrame.h"
+#include "PortValueList.h"
+#include "ContinousStateValueVector.h"
+#include "MechanicContext.h"
 
 namespace OpenFDM {
 
 BEGIN_OPENFDM_OBJECT_DEF(PrismaticJoint, Joint)
+  DEF_OPENFDM_PROPERTY(Vector3, Axis, Serialized)
   END_OPENFDM_OBJECT_DEF
 
-BEGIN_OPENFDM_OBJECT_DEF(PrismaticJointFrame, Frame)
-  END_OPENFDM_OBJECT_DEF
-
-PrismaticJoint::PrismaticJoint(const std::string& name)
-  : Joint(name)
+PrismaticJoint::PrismaticJoint(const std::string& name) :
+  CartesianJoint<1>(name, Vector6(Vector3::zeros(), Vector3(1, 0, 0))),
+  mForcePort(this, "force", Size(1, 1), true),
+  mPositionPort(this, "position", Size(1, 1)),
+  mVelocityPort(this, "velocity", Size(1, 1)),
+  mPositionStateInfo(new Vector1StateInfo),
+  mVelocityStateInfo(new Vector1StateInfo),
+  mAxis(Vector3(1, 0, 0))
 {
-  setNumContinousStates(2);
+  addContinousStateInfo(mPositionStateInfo);
+  addContinousStateInfo(mVelocityStateInfo);
 
-  mPrismaticJointFrame = new PrismaticJointFrame(name);
-
-  setNumInputPorts(1);
-  setInputPortName(0, "jointForce");
-
-  // Since these output ports are just fed by the current state of the
-  // multibody system, we do not have a direct feedthrough model
-  setNumOutputPorts(2);
-  setOutputPort(0, "jointPos", this, &PrismaticJoint::getJointPos);
-  setOutputPort(1, "jointVel", this, &PrismaticJoint::getJointVel);
+  // FIXME
+  setAxis(mAxis);
 }
 
 PrismaticJoint::~PrismaticJoint(void)
 {
 }
 
-bool
-PrismaticJoint::init(void)
+const Vector3&
+PrismaticJoint::getAxis() const
 {
-  /// Check if we have an input port connected to the joint force ...
-  if (getInputPort(0))
-    mJointForcePort = getInputPort(0)->toRealPortHandle();
-  else
-    mJointForcePort = 0;
-
-  recheckTopology();
-  return Joint::init();
+  return mAxis;
 }
 
 void
-PrismaticJoint::recheckTopology(void)
+PrismaticJoint::setAxis(const Vector3& axis)
 {
-  if (!getOutboardBody() || !getInboardBody())
-    return;
-  
-  // check for the inboard frame
-  Frame* inFrame = getInboardBody()->getFrame();
-  if (!inFrame)
-    return;
-  
-  Frame* outFrame = getOutboardBody()->getFrame();
-  if (!outFrame) {
-    getOutboardBody()->setFrame(mPrismaticJointFrame);
-  }
-  outFrame = getOutboardBody()->getFrame();
-  if (!outFrame->isDirectChildFrameOf(inFrame)) {
-    inFrame->addChildFrame(mPrismaticJointFrame);
-  }
-}
-
-void
-PrismaticJoint::setJointAxis(const Vector3& axis)
-{
   real_type nrm = norm(axis);
   if (nrm <= Limits<real_type>::min()) {
     Log(Initialization, Error) << "JointAxis is zero ..." << endl;
     return;
   }
-
-  mPrismaticJointFrame->setJointAxis((1/nrm)*axis);
+  mAxis = (1/nrm)*axis;
+  setJointMatrix(Vector6(Vector3::zeros(), mAxis));
 }
 
-const real_type&
-PrismaticJoint::getJointPos(void) const
-{
-  return mPrismaticJointFrame->getJointPos();
-}
-
 void
-PrismaticJoint::setJointPos(real_type pos)
+PrismaticJoint::init(const Task&, DiscreteStateValueVector&,
+                    ContinousStateValueVector& continousState,
+                    const PortValueList&) const
 {
-  mPrismaticJointFrame->setJointPos(pos);
+  continousState[*mPositionStateInfo] = 0;
+  continousState[*mVelocityStateInfo] = 0;
 }
 
 void
-PrismaticJoint::setJointVel(real_type vel)
+PrismaticJoint::velocity(const MechanicLinkValue& parentLink,
+                        MechanicLinkValue& childLink,
+                        const ContinousStateValueVector& states,
+                        PortValueList& portValues) const
 {
-  mPrismaticJointFrame->setJointVel(vel);
+  VectorN jointPos = states[*mPositionStateInfo];
+  if (!mPositionPort.empty())
+    portValues[mPositionPort] = jointPos;
+  
+  VectorN jointVel = states[*mVelocityStateInfo];
+  if (!mVelocityPort.empty())
+    portValues[mVelocityPort] = jointVel;
+  
+  velocity(parentLink, childLink, mAxis*jointPos, Quaternion::unit(),
+           getJointMatrix()*jointVel);
 }
 
-const real_type&
-PrismaticJoint::getJointVel(void) const
-{
-  return mPrismaticJointFrame->getJointVel();
-}
-
 void
-PrismaticJoint::setOrientation(const Quaternion& orientation)
+PrismaticJoint::articulation(MechanicLinkValue& parentLink,
+                            const MechanicLinkValue& childLink,
+                            const ContinousStateValueVector& states,
+                            PortValueList& portValues,
+                            MatrixFactorsNN& hIh) const
 {
-  mPrismaticJointFrame->setOrientation(orientation);
+  VectorN jointForce;
+  if (mForcePort.empty())
+    jointForce.clear();
+  else
+    jointForce = portValues[mForcePort];
+  
+  articulation(parentLink, childLink, jointForce, hIh);
 }
 
 void
-PrismaticJoint::setPosition(const Vector3& position)
+PrismaticJoint::acceleration(const MechanicLinkValue& parentLink,
+                            MechanicLinkValue& childLink,
+                            const ContinousStateValueVector& states,
+                            PortValueList& portValues,
+                            const MatrixFactorsNN& hIh, VectorN& velDot) const
 {
-  mPrismaticJointFrame->setZeroPosition(position);
+  VectorN jointForce;
+  if (mForcePort.empty())
+    jointForce.clear();
+  else
+    jointForce = portValues[mForcePort];
+  
+  acceleration(parentLink, childLink, jointForce, hIh, velDot);
 }
 
 void
-PrismaticJoint::jointArticulation(SpatialInertia& artI, Vector6& artF,
-                                 const SpatialInertia& outI,
-                                 const Vector6& outF)
+PrismaticJoint::derivative(const DiscreteStateValueVector&,
+                          const ContinousStateValueVector& states,
+                          const PortValueList&, const VectorN& velDot,
+                          ContinousStateValueVector& derivative) const
 {
-  // That projects away tha components where the degrees of freedom
-  // of the joint are.
-  CartesianJointFrame<1>::VectorN tau;
-  if (mJointForcePort.isConnected()) {
-    tau(0) = mJointForcePort.getRealValue();
-  } else
-    tau.clear();
-  mPrismaticJointFrame->jointArticulation(artI, artF, outF, outI, tau);
+  derivative[*mPositionStateInfo] = states[*mVelocityStateInfo];
+  derivative[*mVelocityStateInfo] = velDot;
 }
 
-void
-PrismaticJoint::setState(const StateStream& state)
-{
-  CartesianJointFrame<1>::VectorN v;
-  state.readSubState(v);
-  mPrismaticJointFrame->setJointPos(v(0));
-  state.readSubState(v);
-  mPrismaticJointFrame->setJointVel(v(0));
-}
-
-void
-PrismaticJoint::getState(StateStream& state) const
-{
-  state.writeSubState(mPrismaticJointFrame->getJointPos());
-  state.writeSubState(mPrismaticJointFrame->getJointVel());
-}
-
-void
-PrismaticJoint::getStateDeriv(StateStream& stateDeriv)
-{
-  stateDeriv.writeSubState(mPrismaticJointFrame->getJointVel());
-  stateDeriv.writeSubState(mPrismaticJointFrame->getJointVelDot());
-}
-
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/PrismaticJoint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/PrismaticJoint.h	2008-11-05 19:44:26 UTC (rev 670)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/PrismaticJoint.h	2008-11-05 21:16:11 UTC (rev 671)
@@ -9,71 +9,70 @@
 #include "Object.h"
 #include "Vector.h"
 #include "Matrix.h"
+#include "MatrixStateInfo.h"
 #include "Quaternion.h"
 #include "Inertia.h"
-#include "Frame.h"
-#include "RigidBody.h"
 #include "Joint.h"
+#include "MatrixInputPort.h"
+#include "MatrixOutputPort.h"
+#include "ContinousStateValueVector.h"
+#include "PortValueList.h"
+#include "MechanicContext.h"
+#include "CartesianJoint.h"
 
 namespace OpenFDM {
 
-class PrismaticJointFrame;
-
-class PrismaticJoint : public Joint {
+class PrismaticJoint : public CartesianJoint<1> {
   OPENFDM_OBJECT(PrismaticJoint, Joint);
 public:
   PrismaticJoint(const std::string& name);
   virtual ~PrismaticJoint(void);
 
-  virtual bool init(void);
-
-  virtual void recheckTopology(void);
-
   /** Sets the joint axis where this joint is allowed to rotate around.
    */
-  void setJointAxis(const Vector3& axis);
+  const Vector3& getAxis() const;
+  void setAxis(const Vector3& axis);
 
-  /** Returns the joint position.
-   */
-  const real_type& getJointPos(void) const;
+protected:
 
-  /** Sets the joint position.
-   */
-  void setJointPos(real_type pos);
+  virtual void init(const Task&, DiscreteStateValueVector&,
+                    ContinousStateValueVector& continousState,
+                    const PortValueList&) const;
 
-  /** Returns the joint velocity.
-   */
-  const real_type& getJointVel(void) const;
+  virtual void velocity(const MechanicLinkValue& parentLink,
+                        MechanicLinkValue& childLink,
+                        const ContinousStateValueVector& states,
+                        PortValueList& portValues) const;
+  virtual void articulation(MechanicLinkValue& parentLink,
+                            const MechanicLinkValue& childLink,
+                            const ContinousStateValueVector& states,
+                            PortValueList& portValues,
+                            MatrixFactorsNN& hIh) const;
+  virtual void acceleration(const MechanicLinkValue& parentLink,
+                            MechanicLinkValue& childLink,
+                            const ContinousStateValueVector& states,
+                            PortValueList& portValues,
+                            const MatrixFactorsNN& hIh, VectorN& velDot) const;
 
-  /** Sets the joint velocity.
-   */
-  void setJointVel(real_type vel);
+  virtual void derivative(const DiscreteStateValueVector&,
+                          const ContinousStateValueVector&,
+                          const PortValueList& portValues,
+                          const VectorN& velDot,
+                          ContinousStateValueVector&) const;
 
-  /** Set the orientation of the joint.
-   */
-  void setOrientation(const Quaternion& orientation);
+  using CartesianJoint<1>::velocity;
+  using CartesianJoint<1>::articulation;
+  using CartesianJoint<1>::acceleration;
 
-  /** Sets the zero position of the joint.
-   */
-  void setPosition(const Vector3& position);
-
 private:
-  /** Computes the inboard articulated inertia and force for
-      this articulated body. It is part of the articulated body algorithm.
-   */
-  virtual void jointArticulation(SpatialInertia& artI, Vector6& artF,
-                                 const SpatialInertia& outI,
-                                 const Vector6& outF);
+  MatrixInputPort mForcePort;
+  MatrixOutputPort mPositionPort;
+  MatrixOutputPort mVelocityPort;
 
-  virtual void setState(const StateStream& state);
-  virtual void getState(StateStream& state) const;
-  virtual void getStateDeriv(StateStream& stateDeriv);
+  SharedPtr<Vector1StateInfo> mPositionStateInfo;
+  SharedPtr<Vector1StateInfo> mVelocityStateInfo;
 
-  /// The intput port which might provide some joint internal force
-  RealPortHandle mJointForcePort;
-
-  /// The frame of the mobile root
-  SharedPtr<PrismaticJointFrame> mPrismaticJointFrame;
+  Vector3 mAxis;
 };
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.cpp	2008-11-05 19:44:26 UTC (rev 670)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.cpp	2008-11-05 21:16:11 UTC (rev 671)
@@ -82,10 +82,9 @@
   if (!mVelocityPort.empty())
     portValues[mVelocityPort] = jointVel;
   
-  Vector3 position(0, 0, 0);
-  Quaternion orientation(Quaternion::fromAngleAxis(jointPos(0), mAxis));
-
-  velocity(parentLink, childLink, position, orientation, getJointMatrix()*jointVel);
+  velocity(parentLink, childLink, Vector3(0, 0, 0),
+           Quaternion::fromAngleAxis(jointPos(0), mAxis),
+           getJointMatrix()*jointVel);
 }
 
 void



From frohlich at mail.berlios.de  Thu Nov  6 20:23:10 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Thu, 6 Nov 2008 20:23:10 +0100
Subject: [OpenFDM-svn] r672 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811061923.mA6JNA8U020195@sheep.berlios.de>

Author: frohlich
Date: 2008-11-06 20:23:09 +0100 (Thu, 06 Nov 2008)
New Revision: 672

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/LogStream.h
Log:
Classify error levels.

M    LogStream.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/LogStream.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/LogStream.h	2008-11-05 21:16:11 UTC (rev 671)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/LogStream.h	2008-11-06 19:23:09 UTC (rev 672)
@@ -29,9 +29,21 @@
   };
   
   enum Priority {
+    /// Non recoverable error, either due to an implementation problem or
+    /// due to a user problem probably ignoring previous error return values.
+    /// Simulation results may not be valid.
     Error            = 0,
+    /// Error Conditions that should be avoided, but could be
+    /// worked around in some way.
+    /// Simulation results may not be valid.
     Warning          = Error + 1,
+    /// Error Conditions that are marked with an error return.
+    /// The exact reason is probably explained in this kind of messages.
+    /// These kind of errors do not lead to immediate problems in the
+    /// simulation code. Anyway, when not handled correctly they might lead to
+    /// Error or Warning conditions.
     Info             = Warning + 1,
+    /// Blubber for debugging ...
     Debug            = Info + 1,
     Debug1           = Debug + 1,
     Debug2           = Debug1 + 1,



From frohlich at mail.berlios.de  Thu Nov  6 21:45:12 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Thu, 6 Nov 2008 21:45:12 +0100
Subject: [OpenFDM-svn] r673 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811062045.mA6KjCox026861@sheep.berlios.de>

Author: frohlich
Date: 2008-11-06 21:45:11 +0100 (Thu, 06 Nov 2008)
New Revision: 673

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeInstance.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/HDF5SystemOutput.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/PortValueList.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
Log:
Provide PortValue interfaces directly at the instances.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeInstance.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeInstance.h	2008-11-06 19:23:09 UTC (rev 672)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeInstance.h	2008-11-06 20:45:11 UTC (rev 673)
@@ -39,8 +39,13 @@
   const SampleTime& getSampleTime() const
   { return mSampleTime; }
 
-  const PortValueList& getPortValueList() const
-  { return getNodeContext().getPortValueList(); }
+  /// Access port values by the PortInfo values
+  const PortValue* getPortValue(const PortInfo& portInfo) const
+  { return getNodeContext().getPortValueList().getPortValue(portInfo); }
+  const NumericPortValue* getPortValue(const NumericPortInfo& portInfo) const
+  { return getNodeContext().getPortValueList().getPortValue(portInfo); }
+  const MechanicLinkValue* getPortValue(const MechanicLinkInfo& portInfo) const
+  { return getNodeContext().getPortValueList().getPortValue(portInfo); }
 
   /// Set port value for the given port.
   void setPortValue(const PortInfo& portInfo, PortValue* portValue)

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/HDF5SystemOutput.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/HDF5SystemOutput.h	2008-11-06 19:23:09 UTC (rev 672)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/HDF5SystemOutput.h	2008-11-06 20:45:11 UTC (rev 673)
@@ -392,14 +392,14 @@
       const AbstractNodeInstance* nodeInstance = getNodeInstance(getNodePath());
       if (!nodeInstance)
         return;
-      apply(portInfo, nodeInstance->getPortValueList().getPortValue(portInfo));
+      apply(portInfo, nodeInstance->getPortValue(portInfo));
     }
     virtual void apply(const MechanicLinkInfo& portInfo)
     {
       const AbstractNodeInstance* nodeInstance = getNodeInstance(getNodePath());
       if (!nodeInstance)
         return;
-      apply(portInfo, nodeInstance->getPortValueList().getPortValue(portInfo));
+      apply(portInfo, nodeInstance->getPortValue(portInfo));
     }
     
     virtual void apply(const NumericPortInfo& portInfo,

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/PortValueList.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/PortValueList.h	2008-11-06 19:23:09 UTC (rev 672)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/PortValueList.h	2008-11-06 20:45:11 UTC (rev 673)
@@ -130,6 +130,17 @@
       return 0;
     return portValue->toMechanicLinkValue();
   }
+  /// Save but partially expensive Accessor for numeric ports
+  const PortValue* getPortValue(const PortInfo* portInfo) const
+  {
+    if (!portInfo)
+      return 0;
+    return getPortValue(portInfo->getIndex());
+  }
+  const PortValue* getPortValue(const PortInfo& portInfo) const
+  {
+    return getPortValue(portInfo.getIndex());
+  }
 
 protected:
   PortValueVector mPortValueVector;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-06 19:23:09 UTC (rev 672)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-06 20:45:11 UTC (rev 673)
@@ -317,7 +317,7 @@
 
     virtual bool createPortValue()
     {
-      if (mNodeInstance->getPortValueList().getPortValue(getPortInfo()->getIndex()))
+      if (mNodeInstance->getPortValue(*getPortInfo()))
         return true;
       if (mProxyPortData.lock())
         return true;
@@ -834,7 +834,7 @@
         SharedPtr<const PortInfo> portInfo = node.getPort(k);
         if (portInfo->getOptional())
           continue;
-        if (!(*j)->getPortValueList().getPortValue(k)) {
+        if (!(*j)->getPortValue(*portInfo)) {
           Log(Schedule, Error) << "Mandatory port value for port \""
                                << portInfo->getName() << "\" for model \""
                                << (*j)->getNodeNamePath()



From frohlich at mail.berlios.de  Thu Nov  6 22:41:05 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Thu, 6 Nov 2008 22:41:05 +0100
Subject: [OpenFDM-svn] r674 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811062141.mA6Lf5Nc032168@sheep.berlios.de>

Author: frohlich
Date: 2008-11-06 22:41:04 +0100 (Thu, 06 Nov 2008)
New Revision: 674

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/LibraryModel.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/ModelInstance.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
Log:
Streamline PortValue alloction somehow.

M    src/OpenFDM/ModelInstance.h
M    src/OpenFDM/LibraryModel.h
M    src/OpenFDM/System.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/LibraryModel.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/LibraryModel.h	2008-11-06 20:45:11 UTC (rev 673)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/LibraryModel.h	2008-11-06 21:41:04 UTC (rev 674)
@@ -13,6 +13,9 @@
 
 namespace OpenFDM {
 
+// Group |- LibraryNode
+//       |- 
+
 class LibraryNode;
 
 class LibraryModel : public Object {

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/ModelInstance.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ModelInstance.h	2008-11-06 20:45:11 UTC (rev 673)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ModelInstance.h	2008-11-06 21:41:04 UTC (rev 674)
@@ -21,7 +21,6 @@
   // Return true if this leaf directly depends on one of leafInstance outputs
   bool dependsOn(const ModelInstance& modelInstance) const;
 
-  // FIXME
 // protected:
   /// The node context that belongs to this instance.
   virtual ModelContext& getNodeContext();

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-06 20:45:11 UTC (rev 673)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-06 21:41:04 UTC (rev 674)
@@ -341,15 +341,14 @@
     {
       OpenFDMAssert(!mNodeInstance);
       mNodeInstance = nodeInstance;
-      mPortDataVector.resize(nodeInstance->getNode().getNumPorts());
+      unsigned numPorts = nodeInstance->getNode().getNumPorts();
+      mPortDataVector.resize(numPorts);
+      for (unsigned i = 0; i < numPorts; ++i)
+        mPortDataVector[i] = new PortData(nodeInstance, nodeInstance->getNode().getPort(i));
     }
     
-    PortData* newPortData(const PortInfo* portInfo)
-    {
-      PortData* portData = new PortData(mNodeInstance, portInfo);
-      mPortDataVector[portInfo->getIndex()] = portData;
-      return portData;
-    }
+    PortData* getPortData(const PortInfo& portInfo)
+    { return mPortDataVector[portInfo.getIndex()]; }
     
     bool allocAndConnectProviderPortValues()
     {
@@ -403,7 +402,7 @@
   {
     PortDataList* portDataList = buildNodeContext(leaf);
     OpenFDMAssert(leaf.getPort(0));
-    PortData* portData = portDataList->newPortData(leaf.getPort(0));
+    PortData* portData = portDataList->getPortData(*leaf.getPort(0));
     _groupPortDataMap[leaf.getExternalPortIndex()] = portData;
   }
 
@@ -412,9 +411,6 @@
     PortDataList* portDataList;
     portDataList = getCurrentNodePortDataList();
     portDataList->setNodeInstance(nodeInstance);
-
-    for (unsigned i = 0; i < leaf.getNumPorts(); ++i)
-      portDataList->newPortData(leaf.getPort(i));
   }
 
   virtual void apply(const RootJoint& node)
@@ -462,12 +458,6 @@
   {
     // Prepare a new leaf map for the child group
     PortDataMap parentPortDataMap(group.getNumChildren());
-    for (unsigned i = 0; i < group.getNumChildren(); ++i) {
-      PortDataList* portDataList;
-      portDataList = new PortDataList;
-      parentPortDataMap[i] = portDataList;
-      _portDataListList.push_back(portDataList);
-    }
     parentPortDataMap.swap(_portDataMap);
 
     // Get PortDataList indexed by group port index
@@ -478,11 +468,6 @@
 
     // Now walk the children
     for (unsigned i = 0; i < group.getNumChildren(); ++i) {
-      // Push the right per node port information struct
-      SharedPtr<PortDataList> parentNodePortDataList;
-      parentNodePortDataList.swap(mCurrentNodePortDataList);
-      mCurrentNodePortDataList = _portDataMap[i];
-
       // push the sample time
       SampleTime sampleTime = mSampleTime;
 
@@ -504,14 +489,22 @@
         }
       }
 
+      // Push the right per node port information struct
+      SharedPtr<PortDataList> parentNodePortDataList;
+      parentNodePortDataList.swap(mCurrentNodePortDataList);
+
+      mCurrentNodePortDataList = new PortDataList;
+      _portDataMap[i] = mCurrentNodePortDataList;
+      _portDataListList.push_back(mCurrentNodePortDataList);
+
       // now traverse the child ...
       node->accept(*this);
 
-      // restore old group sample time
-      mSampleTime = sampleTime;
-
       // Pop the per node port information struct
       parentNodePortDataList.swap(mCurrentNodePortDataList);
+
+      // restore old group sample time
+      mSampleTime = sampleTime;
     }
 
     // Apply the group internal connections to the instances
@@ -564,7 +557,7 @@
       }
 
       // Allocate a new port data struct in the parent.
-      PortData* parentPortData = portDataList->newPortData(group.getPort(i));
+      PortData* parentPortData = portDataList->getPortData(*group.getPort(i));
       parentPortData->setProxyPortData(portData);
       portData->setProxyPortData(parentPortData);
     }



From frohlich at mail.berlios.de  Fri Nov  7 10:47:34 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Fri, 7 Nov 2008 10:47:34 +0100
Subject: [OpenFDM-svn] r675 -
	branches/OpenFDM-StateSeparation/src/OpenFDM/LinAlg
Message-ID: <200811070947.mA79lYFx025998@sheep.berlios.de>

Author: frohlich
Date: 2008-11-07 10:47:34 +0100 (Fri, 07 Nov 2008)
New Revision: 675

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/LinAlg/Expressions.h
Log:
dead band and saturation for matrices.

M    Expressions.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/LinAlg/Expressions.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/LinAlg/Expressions.h	2008-11-06 21:41:04 UTC (rev 674)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/LinAlg/Expressions.h	2008-11-07 09:47:34 UTC (rev 675)
@@ -748,6 +748,102 @@
   return ret;
 }
 
+template<typename Impl1, size_type m1, size_type n1,
+         typename Impl2, size_type m2, size_type n2>
+OpenFDM_FORCE_INLINE
+Matrix<typename Impl1::value_type,m1,n1>
+saturate(const MatrixRValue<Impl1,m1,n1>& A1,
+         const MatrixRValue<Impl2,m2,n2>& A2)
+{
+  const Impl1& A1i = A1.asImpl();
+  const Impl2& A2i = A2.asImpl();
+
+  size_type rows = A1i.rows();
+  size_type cols = A1i.cols();
+  SizeCheck<m1,m2>::Equal(rows, A2i.rows());
+  SizeCheck<n1,n2>::Equal(cols, A2i.cols());
+
+  Matrix<typename Impl1::value_type,m1,n1> ret(rows, cols);
+  size_type i, j;
+  for (j = 0; j < cols; ++j)
+    for (i = 0; i < rows; ++i)
+      ret(i, j) = ::OpenFDM::saturate(A1i(i, j), A2i(i, j));
+
+  return ret;
+}
+
+template<typename Impl1, size_type m1, size_type n1,
+         typename Impl2, size_type m2, size_type n2>
+OpenFDM_FORCE_INLINE
+Matrix<typename Impl1::value_type,m1,n1>
+smoothSaturate(const MatrixRValue<Impl1,m1,n1>& A1,
+               const MatrixRValue<Impl2,m2,n2>& A2)
+{
+  const Impl1& A1i = A1.asImpl();
+  const Impl2& A2i = A2.asImpl();
+
+  size_type rows = A1i.rows();
+  size_type cols = A1i.cols();
+  SizeCheck<m1,m2>::Equal(rows, A2i.rows());
+  SizeCheck<n1,n2>::Equal(cols, A2i.cols());
+
+  Matrix<typename Impl1::value_type,m1,n1> ret(rows, cols);
+  size_type i, j;
+  for (j = 0; j < cols; ++j)
+    for (i = 0; i < rows; ++i)
+      ret(i, j) = ::OpenFDM::smoothSaturate(A1i(i, j), A2i(i, j));
+
+  return ret;
+}
+
+template<typename Impl1, size_type m1, size_type n1,
+         typename Impl2, size_type m2, size_type n2>
+OpenFDM_FORCE_INLINE
+Matrix<typename Impl1::value_type,m1,n1>
+deadBand(const MatrixRValue<Impl1,m1,n1>& A1,
+         const MatrixRValue<Impl2,m2,n2>& A2)
+{
+  const Impl1& A1i = A1.asImpl();
+  const Impl2& A2i = A2.asImpl();
+
+  size_type rows = A1i.rows();
+  size_type cols = A1i.cols();
+  SizeCheck<m1,m2>::Equal(rows, A2i.rows());
+  SizeCheck<n1,n2>::Equal(cols, A2i.cols());
+
+  Matrix<typename Impl1::value_type,m1,n1> ret(rows, cols);
+  size_type i, j;
+  for (j = 0; j < cols; ++j)
+    for (i = 0; i < rows; ++i)
+      ret(i, j) = ::OpenFDM::deadBand(A1i(i, j), A2i(i, j));
+
+  return ret;
+}
+
+template<typename Impl1, size_type m1, size_type n1,
+         typename Impl2, size_type m2, size_type n2>
+OpenFDM_FORCE_INLINE
+Matrix<typename Impl1::value_type,m1,n1>
+smoothDeadBand(const MatrixRValue<Impl1,m1,n1>& A1,
+         const MatrixRValue<Impl2,m2,n2>& A2)
+{
+  const Impl1& A1i = A1.asImpl();
+  const Impl2& A2i = A2.asImpl();
+
+  size_type rows = A1i.rows();
+  size_type cols = A1i.cols();
+  SizeCheck<m1,m2>::Equal(rows, A2i.rows());
+  SizeCheck<n1,n2>::Equal(cols, A2i.cols());
+
+  Matrix<typename Impl1::value_type,m1,n1> ret(rows, cols);
+  size_type i, j;
+  for (j = 0; j < cols; ++j)
+    for (i = 0; i < rows; ++i)
+      ret(i, j) = ::OpenFDM::smoothDeadBand(A1i(i, j), A2i(i, j));
+
+  return ret;
+}
+
 #endif
 
 } // namespace LinAlg



From frohlich at mail.berlios.de  Fri Nov  7 10:59:50 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Fri, 7 Nov 2008 10:59:50 +0100
Subject: [OpenFDM-svn] r676 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811070959.mA79xogs026677@sheep.berlios.de>

Author: frohlich
Date: 2008-11-07 10:59:50 +0100 (Fri, 07 Nov 2008)
New Revision: 676

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h
Log:
Store parent and child link information in the context.

M    CartesianJoint.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h	2008-11-07 09:47:34 UTC (rev 675)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h	2008-11-07 09:59:50 UTC (rev 676)
@@ -156,65 +156,53 @@
                           const PortValueList& portValues, const VectorN&,
                           ContinousStateValueVector&) const = 0;
 
-  void velocity(const Task&,
-                const ContinousStateValueVector& continousState,
-                PortValueList& portValues) const
-  {
-    velocity(portValues[mParentLink], portValues[mChildLink],
-             continousState, portValues);
-  }
-
-  void articulation(const Task&,
-                    const ContinousStateValueVector& continousState,
-                    PortValueList& portValues, MatrixFactorsNN& hIh) const
-  {
-    articulation(portValues[mParentLink], portValues[mChildLink],
-                 continousState, portValues, hIh);
-  }
-
-  void acceleration(const Task&,
-                    const ContinousStateValueVector& continousState,
-                    PortValueList& portValues, const MatrixFactorsNN& hIh,
-                    VectorN& velDot) const
-  {
-    acceleration(portValues[mParentLink], portValues[mChildLink],
-                 continousState, portValues, hIh, velDot);
-  }
-  
 private:
   class Context : public MechanicContext {
   public:
-    Context(const CartesianJoint* cartesianJoint) : mCartesianJoint(cartesianJoint) {}
+    Context(const CartesianJoint* cartesianJoint) :
+      mCartesianJoint(cartesianJoint)
+    { }
     virtual ~Context() {}
     
     virtual const CartesianJoint& getNode() const
     { return *mCartesianJoint; }
     
     virtual bool alloc()
-    { if (!allocStates()) return false; return mCartesianJoint->alloc(*this); }
+    {
+      if (!allocStates())
+        return false;
+      mParentLink = &mPortValueList[mCartesianJoint->mParentLink];
+      mChildLink = &mPortValueList[mCartesianJoint->mChildLink];
+      return mCartesianJoint->alloc(*this);
+    }
     virtual void initVelocities(const /*Init*/Task& task)
     {
       mCartesianJoint->init(task, mDiscreteState, mContinousState, mPortValueList);
-      mCartesianJoint->velocity(task, mContinousState, mPortValueList);
+      mCartesianJoint->velocity(*mParentLink, *mChildLink,
+                                mContinousState, mPortValueList);
     }
     
     virtual void velocities(const Task& task)
     {
-      mCartesianJoint->velocity(task, mContinousState, mPortValueList);
+      mCartesianJoint->velocity(*mParentLink, *mChildLink,
+                                mContinousState, mPortValueList);
     }
     virtual void articulation(const Task& task)
     {
-      mCartesianJoint->articulation(task, mContinousState, mPortValueList, hIh);
+      mCartesianJoint->articulation(*mParentLink, *mChildLink,
+                                    mContinousState, mPortValueList, hIh);
     }
     virtual void accelerations(const Task& task)
     {
-      mCartesianJoint->acceleration(task, mContinousState, mPortValueList, hIh, velDot);
+      mCartesianJoint->acceleration(*mParentLink, *mChildLink, mContinousState,
+                                    mPortValueList, hIh, velDot);
     }
     
     virtual void derivative(const Task&)
     {
-      mCartesianJoint->derivative(mDiscreteState, mContinousState, mPortValueList,
-                         velDot, mContinousStateDerivative);
+      mCartesianJoint->derivative(mDiscreteState, mContinousState,
+                                  mPortValueList, velDot,
+                                  mContinousStateDerivative);
     }
     
     virtual void update(const DiscreteTask&)
@@ -224,6 +212,9 @@
     // Stores some values persistent accross velocity/articulation/acceleration
     MatrixFactorsNN hIh;
     VectorN velDot;
+
+    SharedPtr<MechanicLinkValue> mParentLink;
+    SharedPtr<MechanicLinkValue> mChildLink;
     
     SharedPtr<const CartesianJoint> mCartesianJoint;
   };



From frohlich at mail.berlios.de  Fri Nov  7 16:29:30 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Fri, 7 Nov 2008 16:29:30 +0100
Subject: [OpenFDM-svn] r677 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811071529.mA7FTUfS018078@sheep.berlios.de>

Author: frohlich
Date: 2008-11-07 16:29:29 +0100 (Fri, 07 Nov 2008)
New Revision: 677

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
Log:
Use dopri5 as default.

M    src/OpenFDM/System.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-07 09:59:50 UTC (rev 676)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-07 15:29:29 UTC (rev 677)
@@ -19,7 +19,7 @@
 #include "Task.h"
 
 #include "Function.h"
-#include "ExplicitEuler.h"
+#include "DoPri5.h"
 
 namespace OpenFDM {
 
@@ -90,7 +90,7 @@
     mContinousSystemFunction = new ContinousSystemFunction;
     mContinousSystemFunction->mContinousTask = mContinousTask;
 
-    mODESolver = new ExplicitEuler;
+    mODESolver = new DoPri5;
     mODESolver->setFunction(mContinousSystemFunction);
   }
 



From frohlich at mail.berlios.de  Sat Nov  8 13:32:56 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 8 Nov 2008 13:32:56 +0100
Subject: [OpenFDM-svn] r678 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811081232.mA8CWu8q024746@sheep.berlios.de>

Author: frohlich
Date: 2008-11-08 13:32:55 +0100 (Sat, 08 Nov 2008)
New Revision: 678

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
Log:
Change the way port values are distributed and connected.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-07 15:29:29 UTC (rev 677)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-08 12:32:55 UTC (rev 678)
@@ -238,20 +238,69 @@
     mBasicSampleTime(SampleTime::getContinous())
   { }
 
+  struct PortData;
+
+  struct PortConnectSet : public Referenced {
+    bool setPortValue(PortValue* portValue)
+    {
+      while (!mParentPortData.empty()) {
+        SharedPtr<PortData> portData = mParentPortData.back().lock();
+        mParentPortData.pop_back();
+        if (!portData->setPortValue(portValue))
+          return false;
+      }
+      return true;
+    }
+    std::vector<WeakPtr<PortData> > mParentPortData;
+  };
+
   struct PortData : public WeakReferenced {
   public:
     PortData(AbstractNodeInstance* nodeInstance, const PortInfo* portInfo) :
       mNodeInstance(nodeInstance),
+      mPortValueCreator(true),
       mPortInfo(portInfo)
-    { }
-    virtual ~PortData()
-    { }
+    {
+      getOrCreatePortConnectSet();
+    }
 
+    void setPortConnectSet(PortConnectSet* portSet)
+    {
+      OpenFDMAssert(portSet);
+      if (portSet == mPortConnectSet)
+        return;
+      if (!mPortConnectSet) {
+        mPortConnectSet = portSet;
+        mPortConnectSet->mParentPortData.push_back(this);
+        return;
+      }
+      // Merge the port sets together ...
+      while (!mPortConnectSet->mParentPortData.empty()) {
+        SharedPtr<PortData> portData = mPortConnectSet->mParentPortData.back().lock();
+        mPortConnectSet->mParentPortData.pop_back();
+        if (portData == this)
+          continue;
+        portData->mPortConnectSet = portSet;
+        portSet->mParentPortData.push_back(portData);
+      }
+      mPortConnectSet = portSet;
+      mPortConnectSet->mParentPortData.push_back(this);
+    }
+
+    PortConnectSet* getOrCreatePortConnectSet()
+    {
+      if (mPortConnectSet)
+        return mPortConnectSet;
+      setPortConnectSet(new PortConnectSet);
+      return mPortConnectSet;
+    }
+
     bool addPortData(PortData* portData)
     {
       if (getPortInfo()->getMaxConnects() <= mConnectedPorts.size())
         return false;
       mConnectedPorts.push_back(portData);
+      setPortConnectSet(portData->getOrCreatePortConnectSet());
       return true;
     }
 
@@ -262,20 +311,21 @@
       if (!portData->addPortData(this))
         return false;
       mConnectedPorts.push_back(portData);
+      setPortConnectSet(portData->getOrCreatePortConnectSet());
       return true;
     }
 
     const SharedPtr<const PortInfo>& getPortInfo() const
     { return mPortInfo; }
 
-    bool setLocalPortValue(PortValue* portValue)
+    bool setPortValue(PortValue* portValue)
     {
       if (!getPortInfo())
         return false;
       if (!mNodeInstance)
         return false;
       Log(Schedule, Debug3)
-        << "setLocalPortValue for port \"" << getPortInfo()->getName()
+        << "setPortValue for port \"" << getPortInfo()->getName()
         << "\" is at: " << portValue << endl;
       // FIXME: move the set port value and accept port value into one call
       if (!getPortInfo()->acceptPortValue(portValue))
@@ -284,54 +334,32 @@
       return true;
     }
 
-    bool setConnectedPortValues(PortValue* portValue)
+    void setProxyPortData(PortData* proxyPortData)
     {
-      Log(Schedule, Debug3)
-        << "setConnectedPortValues for port \"" << getPortInfo()->getName()
-        << "\" is at: " << portValue << endl;
-      for (unsigned i = 0; i < mConnectedPorts.size(); ++i) {
-        SharedPtr<PortData> portData = mConnectedPorts[i].lock();
-        if (!portData)
-          return false;
-        if (!portData->setProxyPortValue(portValue))
-          return false;
-      }
-      return setLocalPortValue(portValue);
+      mPortValueCreator = false;
+      setPortConnectSet(proxyPortData->getOrCreatePortConnectSet());
     }
 
-    bool setProxyPortValue(PortValue* portValue)
+    bool createPortValue()
     {
-      Log(Schedule, Debug3)
-        << "setProxyPortValues for port \"" << getPortInfo()->getName()
-        << "\" is at: " << portValue << endl;
-      SharedPtr<PortData> portData = mProxyPortData.lock();
-      if (portData) {
-        if (!portData->setConnectedPortValues(portValue))
-          return false;
-      }
-      return setLocalPortValue(portValue);
-    }
-
-    void setProxyPortData(PortData* proxyPortData)
-    { mProxyPortData = proxyPortData; }
-
-    virtual bool createPortValue()
-    {
+      if (!mPortValueCreator)
+        return true;
       if (mNodeInstance->getPortValue(*getPortInfo()))
         return true;
-      if (mProxyPortData.lock())
-        return true;
       SharedPtr<PortValue> portValue = getPortInfo()->newValue();
       if (!portValue)
         return true; // FIXME
-      return setConnectedPortValues(portValue);
+      if (!mPortConnectSet->setPortValue(portValue))
+        return false;
+      return true;
     }
 
   private:
+    bool mPortValueCreator;
     SharedPtr<AbstractNodeInstance> mNodeInstance;
     SharedPtr<const PortInfo> mPortInfo;
     std::vector<WeakPtr<PortData> > mConnectedPorts;
-    WeakPtr<PortData> mProxyPortData;
+    SharedPtr<PortConnectSet> mPortConnectSet;
   };
 
   // Return true if this leaf directly depends on one of leafInstance outputs



From frohlich at mail.berlios.de  Sat Nov  8 13:40:59 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 8 Nov 2008 13:40:59 +0100
Subject: [OpenFDM-svn] r679 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811081240.mA8CexhR025346@sheep.berlios.de>

Author: frohlich
Date: 2008-11-08 13:40:59 +0100 (Sat, 08 Nov 2008)
New Revision: 679

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/RigidBody.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/RigidBody.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
Log:
make use of the different port allocation stuff.
RigidBody does no longer compute anything.

M    src/OpenFDM/RigidBody.h
M    src/OpenFDM/RigidBody.cpp
M    src/OpenFDM/System.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RigidBody.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RigidBody.cpp	2008-11-08 12:32:55 UTC (rev 678)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RigidBody.cpp	2008-11-08 12:40:59 UTC (rev 679)
@@ -24,22 +24,14 @@
   virtual void initVelocities(const /*Init*/Task& task)
   {
     mRigidBody->init(task, mDiscreteState, mContinousState, mPortValueList);
-    mRigidBody->velocity(task, mContinousState, mPortValueList);
   }
 
   virtual void velocities(const Task& task)
-  {
-    mRigidBody->velocity(task, mContinousState, mPortValueList);
-  }
+  { }
   virtual void articulation(const Task& task)
-  {
-    mRigidBody->articulation(task, mContinousState, mPortValueList);
-  }
+  { }
   virtual void accelerations(const Task& task)
-  {
-    mRigidBody->acceleration(task, mContinousState, mPortValueList);
-  }
-
+  { }
   virtual void derivative(const Task&)
   { }
   virtual void update(const DiscreteTask&)
@@ -102,34 +94,4 @@
   }
 }
 
-void
-RigidBody::velocity(const Task&, const ContinousStateValueVector&,
-                    PortValueList& portValues) const
-{
-  unsigned numLinkValues = mMechanicLinks.size();
-  const MechanicLinkValue& parentLink = portValues[mMechanicLinks.front()];
-  for (unsigned i = 1; i < numLinkValues; ++i)
-    portValues[mMechanicLinks[i]].setPosAndVel(parentLink);
-}
-
-void
-RigidBody::articulation(const Task&, const ContinousStateValueVector&,
-                        PortValueList& portValues) const
-{
-  unsigned numLinkValues = mMechanicLinks.size();
-  MechanicLinkValue& parentLink = portValues[mMechanicLinks.front()];
-  for (unsigned i = 1; i < numLinkValues; ++i)
-    parentLink.applyArticulation(portValues[mMechanicLinks[i]]);
-}
-
-void
-RigidBody::acceleration(const Task&, const ContinousStateValueVector&,
-                        PortValueList& portValues) const
-{
-  unsigned numLinkValues = mMechanicLinks.size();
-  const MechanicLinkValue& parentLink = portValues[mMechanicLinks.front()];
-  for (unsigned i = 1; i < numLinkValues; ++i)
-    portValues[mMechanicLinks[i]].setAccel(parentLink);
-}
-
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RigidBody.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RigidBody.h	2008-11-08 12:32:55 UTC (rev 678)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RigidBody.h	2008-11-08 12:40:59 UTC (rev 679)
@@ -24,20 +24,6 @@
   PortId addLink(const std::string& name);
   void removeLink(const PortId& portId);
 
-  /// Simple node distributing the positions, velocities and accelerations
-  /// from the parent link to the child links. Forces and inertias are summed
-  /// over the children and written into the parent link.
-  ///
-  /// Idea: may be use the same link value for all links and use a
-  /// contributeForce/contributeInertia method to add inertia to a
-  /// parent link???
-
-  void velocity(const Task&, const ContinousStateValueVector& states,
-                PortValueList& portValues) const;
-  void articulation(const Task&, const ContinousStateValueVector&,
-                    PortValueList& portValues) const;
-  void acceleration(const Task&, const ContinousStateValueVector&,
-                    PortValueList& portValues) const;
 private:
   class Context;
 

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-08 12:32:55 UTC (rev 678)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-08 12:40:59 UTC (rev 679)
@@ -334,6 +334,11 @@
       return true;
     }
 
+    void disablePortValueCreation()
+    {
+      mPortValueCreator = false;
+    }
+
     void setProxyPortData(PortData* proxyPortData)
     {
       mPortValueCreator = false;
@@ -464,8 +469,19 @@
   {
     MechanicInstance* mechanicInstance = new MechanicInstance(getNodePath(), mSampleTime, &node);
     _nodeInstanceList.push_back(mechanicInstance);
-    _rigidBodyInstanceList.push_back(mechanicInstance);
     allocPortData(mechanicInstance, node);
+    // Make all rigid mechanic body links use the same link value
+    PortData* portData = 0;
+    for (unsigned i = 0; i < node.getNumPorts(); ++i) {
+      if (!node.getPort(i)->toMechanicLinkInfo())
+        continue;
+      if (portData) {
+        mCurrentNodePortDataList->mPortDataVector[i]->setProxyPortData(portData);
+      } else {
+        portData = mCurrentNodePortDataList->mPortDataVector[i];
+        portData->disablePortValueCreation();
+      }
+    }
   }
   virtual void apply(const Joint& node)
   {
@@ -610,7 +626,6 @@
   MechanicInstanceList _rootJointInstanceList;
   MechanicInstanceList _interactInstanceList;
   MechanicInstanceList _jointInstanceList;
-  MechanicInstanceList _rigidBodyInstanceList;
 
   ////////////////////////////////////////////////////////////////////////////
   // Used to map connections in groups ...
@@ -685,13 +700,6 @@
   // method to sort the leafs according to their dependency
   bool sortMechanicList()
   {
-    // For now RigidBody nodes still do computations
-    // FIXME
-    _jointInstanceList.splice(_jointInstanceList.end(),
-                              _rigidBodyInstanceList,
-                              _rigidBodyInstanceList.begin(),
-                              _rigidBodyInstanceList.end());
-
     if (_rootJointInstanceList.empty() &&
         (!_jointInstanceList.empty() || !_interactInstanceList.empty())) {
       Log(Schedule,Error)



From frohlich at mail.berlios.de  Sat Nov  8 18:47:19 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 8 Nov 2008 18:47:19 +0100
Subject: [OpenFDM-svn] r680 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811081747.mA8HlJPj001409@sheep.berlios.de>

Author: frohlich
Date: 2008-11-08 18:47:18 +0100 (Sat, 08 Nov 2008)
New Revision: 680

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/PortInfo.h
Log:
Add accelerationOutput property to output ports.

M    PortInfo.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/PortInfo.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/PortInfo.h	2008-11-08 12:40:59 UTC (rev 679)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/PortInfo.h	2008-11-08 17:47:18 UTC (rev 680)
@@ -155,13 +155,15 @@
   { return 0; }
 
 private:
+  // FIXME Derive??
   bool mDirectInput;
 };
 
 class OutputPortInfo : public NumericPortInfo {
 public:
   OutputPortInfo(Node* node, const std::string& name, const Size& size) :
-    NumericPortInfo(node, name, size)
+    NumericPortInfo(node, name, size),
+    mAccelerationOutput(false)
   { }
   virtual ~OutputPortInfo()
   { }
@@ -175,9 +177,18 @@
   virtual bool canConnect(const PortInfo& portInfo) const
   { return portInfo.toInputPortInfo(); }
 
+  bool getAccelerationOutput() const
+  { return mAccelerationOutput; }
+  void setAccelerationOutput(bool accelerationOutput)
+  { mAccelerationOutput = accelerationOutput; }
+
 protected:
   virtual NumericPortValue* newValueImplementation() const
   { return new NumericPortValue(mSize); }
+
+private:
+  // FIXME Derive??
+  bool mAccelerationOutput;
 };
 
 class MechanicLinkInfo : public PortInfo {



From frohlich at mail.berlios.de  Sat Nov  8 22:34:33 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 8 Nov 2008 22:34:33 +0100
Subject: [OpenFDM-svn] r681 - in
	branches/OpenFDM-StateSeparation/src/OpenFDM: . LinAlg
Message-ID: <200811082134.mA8LYXPr026740@sheep.berlios.de>

Author: frohlich
Date: 2008-11-08 22:34:33 +0100 (Sat, 08 Nov 2008)
New Revision: 681

Added:
   branches/OpenFDM-StateSeparation/src/OpenFDM/UniversalJoint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/UniversalJoint.h
Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/LinAlg/Algorithm.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
   branches/OpenFDM-StateSeparation/src/OpenFDM/PrismaticJoint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteActuator.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.cpp
Log:
First cut of an universal joint.

M    OpenFDM/CartesianJoint.h
M    OpenFDM/Makefile.am
M    OpenFDM/PrismaticJoint.cpp
M    OpenFDM/RevoluteActuator.cpp
M    OpenFDM/RevoluteJoint.cpp
M    OpenFDM/LinAlg/Algorithm.h
A    OpenFDM/UniversalJoint.h
A    OpenFDM/UniversalJoint.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h	2008-11-08 17:47:18 UTC (rev 680)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h	2008-11-08 21:34:33 UTC (rev 681)
@@ -30,11 +30,10 @@
   { return new Context(this); }
 
 protected:
-  CartesianJoint(const std::string& name, const Matrix6N& jointMatrix) :
+  CartesianJoint(const std::string& name) :
     Joint(name),
     mParentLink(newMechanicLink("link0")),
-    mChildLink(newMechanicLink("link1")),
-    mJointMatrix(jointMatrix)
+    mChildLink(newMechanicLink("link1"))
   { }
   virtual ~CartesianJoint(void)
   { }

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/LinAlg/Algorithm.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/LinAlg/Algorithm.h	2008-11-08 17:47:18 UTC (rev 680)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/LinAlg/Algorithm.h	2008-11-08 21:34:33 UTC (rev 681)
@@ -574,6 +574,35 @@
   return ret;
 }
 
+// return any normalized vector perpendicular to v
+// template<typename Impl1, typename Impl2>
+// OpenFDM_FORCE_INLINE
+// Vector<typename Impl1::value_type,3>
+// cross(const MatrixRValue<Impl1,3,1>& u, const MatrixRValue<Impl2,3,1>& v)
+template<typename T>
+OpenFDM_FORCE_INLINE
+Vector3<T>
+perpendicular(const Vector3<T>& v)
+{
+  T absv1 = fabs(v(0));
+  T absv2 = fabs(v(1));
+  T absv3 = fabs(v(2));
+
+  if (absv2 < absv1 && absv3 < absv1) {
+    T quot = v(1)/v(0);
+    return (1/sqrt(1+quot*quot))*Vector3<T>(quot, -1, 0);
+  } else if (absv3 < absv2) {
+    T quot = v(2)/v(1);
+    return (1/sqrt(1+quot*quot))*Vector3<T>(0, quot, -1);
+  } else if (Limits<T>::min() < absv3) {
+    T quot = v(0)/v(2);
+    return (1/sqrt(1+quot*quot))*Vector3<T>(-1, 0, quot);
+  } else {
+    // the all zero case ...
+    return Vector3<T>(0, 0, 0);
+  }
+}
+
 template<typename T, size_type dim1>
 OpenFDM_FORCE_INLINE
 void

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-11-08 17:47:18 UTC (rev 680)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-11-08 21:34:33 UTC (rev 681)
@@ -225,6 +225,7 @@
   TransferFunction.h \
   Turbulence.h \
   UnaryFunctionModel.h \
+  UniversalJoint.h \
   Vehicle.h \
   WheelContact.h \
   Wind.h
@@ -245,7 +246,8 @@
   MobileRootJoint.cpp \
   PrismaticJoint.cpp \
   RevoluteActuator.cpp \
-  RevoluteJoint.cpp
+  RevoluteJoint.cpp \
+  UniversalJoint.cpp
 
 
 #   AeroForce.cpp \

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/PrismaticJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/PrismaticJoint.cpp	2008-11-08 17:47:18 UTC (rev 680)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/PrismaticJoint.cpp	2008-11-08 21:34:33 UTC (rev 681)
@@ -22,7 +22,7 @@
   END_OPENFDM_OBJECT_DEF
 
 PrismaticJoint::PrismaticJoint(const std::string& name) :
-  CartesianJoint<1>(name, Vector6(Vector3::zeros(), Vector3(1, 0, 0))),
+  CartesianJoint<1>(name),
   mForcePort(this, "force", Size(1, 1), true),
   mPositionPort(this, "position", Size(1, 1)),
   mVelocityPort(this, "velocity", Size(1, 1)),

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteActuator.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteActuator.cpp	2008-11-08 17:47:18 UTC (rev 680)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteActuator.cpp	2008-11-08 21:34:33 UTC (rev 681)
@@ -22,7 +22,7 @@
   END_OPENFDM_OBJECT_DEF
 
 RevoluteActuator::RevoluteActuator(const std::string& name) :
-  CartesianJoint<1>(name, Vector6(Vector3(1, 0, 0), Vector3::zeros())),
+  CartesianJoint<1>(name),
   mInputPort(this, "input", Size(1, 1), true),
   mPositionPort(this, "position", Size(1, 1)),
   mVelocityPort(this, "velocity", Size(1, 1)),

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.cpp	2008-11-08 17:47:18 UTC (rev 680)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.cpp	2008-11-08 21:34:33 UTC (rev 681)
@@ -22,7 +22,7 @@
   END_OPENFDM_OBJECT_DEF
 
 RevoluteJoint::RevoluteJoint(const std::string& name) :
-  CartesianJoint<1>(name, Vector6(Vector3(1, 0, 0), Vector3::zeros())),
+  CartesianJoint<1>(name),
   mForcePort(this, "force", Size(1, 1), true),
   mPositionPort(this, "position", Size(1, 1)),
   mVelocityPort(this, "velocity", Size(1, 1)),

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/UniversalJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/UniversalJoint.cpp	2008-11-08 17:47:18 UTC (rev 680)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/UniversalJoint.cpp	2008-11-08 21:34:33 UTC (rev 681)
@@ -0,0 +1,154 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
+ *
+ */
+
+#include "UniversalJoint.h"
+#include "Assert.h"
+#include "LogStream.h"
+#include "Limits.h"
+#include "Object.h"
+#include "Vector.h"
+#include "Matrix.h"
+#include "Quaternion.h"
+#include "Inertia.h"
+#include "PortValueList.h"
+#include "ContinousStateValueVector.h"
+#include "MechanicContext.h"
+
+namespace OpenFDM {
+
+BEGIN_OPENFDM_OBJECT_DEF(UniversalJoint, Joint)
+  DEF_OPENFDM_PROPERTY(Vector3, Axis, Serialized)
+  END_OPENFDM_OBJECT_DEF
+
+UniversalJoint::UniversalJoint(const std::string& name) :
+  CartesianJoint<2>(name),
+  mForcePort(this, "force", Size(2, 1), true),
+  mOrientationPort(this, "orientation", Size(4, 1)),
+  mVelocityPort(this, "velocity", Size(2, 1)),
+  mPositionStateInfo(new Vector3StateInfo),
+  mVelocityStateInfo(new Vector2StateInfo),
+  mAxis(Vector3(1, 0, 0))
+{
+  addContinousStateInfo(mPositionStateInfo);
+  addContinousStateInfo(mVelocityStateInfo);
+
+  // FIXME
+  setAxis(mAxis);
+}
+
+UniversalJoint::~UniversalJoint(void)
+{
+}
+
+const Vector3&
+UniversalJoint::getAxis() const
+{
+  return mAxis;
+}
+
+void
+UniversalJoint::setAxis(const Vector3& axis)
+{
+  real_type nrm = norm(axis);
+  if (nrm <= Limits<real_type>::min()) {
+    Log(Initialization, Error) << "JointAxis is zero ..." << endl;
+    return;
+  }
+  mAxis = (1/nrm)*axis;
+
+  mOrientation = Quaternion::fromRotateTo(Vector3(0, 0, 1), mAxis);
+  
+  Vector3 axis1 = perpendicular(mAxis);
+  Vector3 axis2 = cross(mAxis, axis1);
+  Matrix6N jointMatrix;
+  jointMatrix(Range(0, 6), Range(0)) = Vector6(axis1, Vector3::zeros());
+  jointMatrix(Range(0, 6), Range(1)) = Vector6(axis2, Vector3::zeros());
+  setJointMatrix(jointMatrix);
+}
+
+void
+UniversalJoint::init(const Task&, DiscreteStateValueVector&,
+                    ContinousStateValueVector& continousState,
+                    const PortValueList&) const
+{
+  continousState[*mPositionStateInfo] = Vector3(1, 0, 0);
+  continousState[*mVelocityStateInfo] = Vector2(0, 0);
+}
+
+void
+UniversalJoint::velocity(const MechanicLinkValue& parentLink,
+                        MechanicLinkValue& childLink,
+                        const ContinousStateValueVector& states,
+                        PortValueList& portValues) const
+{
+  Vector3 jointPos = states[*mPositionStateInfo];
+  Quaternion orientation(jointPos(0), jointPos(1), 0, jointPos(2));
+  orientation *= mOrientation;
+
+  if (!mOrientationPort.empty())
+    portValues[mOrientationPort] = orientation;
+  
+  VectorN jointVel = states[*mVelocityStateInfo];
+  if (!mVelocityPort.empty())
+    portValues[mVelocityPort] = jointVel;
+  
+  velocity(parentLink, childLink, Vector3(0, 0, 0),
+           orientation, getJointMatrix()*jointVel);
+}
+
+void
+UniversalJoint::articulation(MechanicLinkValue& parentLink,
+                            const MechanicLinkValue& childLink,
+                            const ContinousStateValueVector& states,
+                            PortValueList& portValues,
+                            MatrixFactorsNN& hIh) const
+{
+  VectorN jointForce;
+  if (mForcePort.empty())
+    jointForce.clear();
+  else
+    jointForce = portValues[mForcePort];
+  
+  articulation(parentLink, childLink, jointForce, hIh);
+}
+
+void
+UniversalJoint::acceleration(const MechanicLinkValue& parentLink,
+                            MechanicLinkValue& childLink,
+                            const ContinousStateValueVector& states,
+                            PortValueList& portValues,
+                            const MatrixFactorsNN& hIh, VectorN& velDot) const
+{
+  VectorN jointForce;
+  if (mForcePort.empty())
+    jointForce.clear();
+  else
+    jointForce = portValues[mForcePort];
+  
+  acceleration(parentLink, childLink, jointForce, hIh, velDot);
+}
+
+void
+UniversalJoint::derivative(const DiscreteStateValueVector&,
+                          const ContinousStateValueVector& states,
+                          const PortValueList&, const VectorN& velDot,
+                          ContinousStateValueVector& derivative) const
+{
+  Vector3 jointPos = states[*mPositionStateInfo];
+  Quaternion q = Quaternion(jointPos(0), jointPos(1), 0, jointPos(2));
+  q *= mOrientation;
+
+  // Compute the derivative term originating from the angular velocity.
+  // Correction term to keep the quaternion normalized.
+  // That is if |q| < 1 add a little radial component outward,
+  // if |q| > 1 add a little radial component inward
+  Vector3 angVel = getJointMatrix()(Range(0, 2), Range(0, 1))
+    *states[*mVelocityStateInfo];
+  Vector4 qderiv = LinAlg::derivative(q, angVel) + 1e1*(normalize(q) - q);
+
+  derivative[*mPositionStateInfo] = Vector3(qderiv(0), qderiv(1), qderiv(3));
+  derivative[*mVelocityStateInfo] = velDot;
+}
+
+} // namespace OpenFDM

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/UniversalJoint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/UniversalJoint.h	2008-11-08 17:47:18 UTC (rev 680)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/UniversalJoint.h	2008-11-08 21:34:33 UTC (rev 681)
@@ -0,0 +1,81 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_UniversalJoint_H
+#define OpenFDM_UniversalJoint_H
+
+#include "Assert.h"
+#include "Object.h"
+#include "Vector.h"
+#include "Matrix.h"
+#include "MatrixStateInfo.h"
+#include "Quaternion.h"
+#include "Inertia.h"
+#include "Joint.h"
+#include "MatrixInputPort.h"
+#include "MatrixOutputPort.h"
+#include "ContinousStateValueVector.h"
+#include "PortValueList.h"
+#include "MechanicContext.h"
+#include "CartesianJoint.h"
+
+namespace OpenFDM {
+
+class UniversalJoint : public CartesianJoint<2> {
+  OPENFDM_OBJECT(UniversalJoint, Joint);
+public:
+  UniversalJoint(const std::string& name);
+  virtual ~UniversalJoint(void);
+
+  /** Sets the joint axis where this joint is allowed to rotate around.
+   */
+  const Vector3& getAxis() const;
+  void setAxis(const Vector3& axis);
+
+protected:
+
+  virtual void init(const Task&, DiscreteStateValueVector&,
+                    ContinousStateValueVector& continousState,
+                    const PortValueList&) const;
+
+  virtual void velocity(const MechanicLinkValue& parentLink,
+                        MechanicLinkValue& childLink,
+                        const ContinousStateValueVector& states,
+                        PortValueList& portValues) const;
+  virtual void articulation(MechanicLinkValue& parentLink,
+                            const MechanicLinkValue& childLink,
+                            const ContinousStateValueVector& states,
+                            PortValueList& portValues,
+                            MatrixFactorsNN& hIh) const;
+  virtual void acceleration(const MechanicLinkValue& parentLink,
+                            MechanicLinkValue& childLink,
+                            const ContinousStateValueVector& states,
+                            PortValueList& portValues,
+                            const MatrixFactorsNN& hIh, VectorN& velDot) const;
+
+  virtual void derivative(const DiscreteStateValueVector&,
+                          const ContinousStateValueVector&,
+                          const PortValueList& portValues,
+                          const VectorN& velDot,
+                          ContinousStateValueVector&) const;
+
+  using CartesianJoint<2>::velocity;
+  using CartesianJoint<2>::articulation;
+  using CartesianJoint<2>::acceleration;
+
+private:
+  MatrixInputPort mForcePort;
+  MatrixOutputPort mOrientationPort;
+  MatrixOutputPort mVelocityPort;
+
+  SharedPtr<Vector3StateInfo> mPositionStateInfo;
+  SharedPtr<Vector2StateInfo> mVelocityStateInfo;
+
+  Vector3 mAxis;
+  Quaternion mOrientation;
+};
+
+} // namespace OpenFDM
+
+#endif



From frohlich at mail.berlios.de  Sat Nov  8 22:35:20 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 8 Nov 2008 22:35:20 +0100
Subject: [OpenFDM-svn] r682 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200811082135.mA8LZK4a026833@sheep.berlios.de>

Author: frohlich
Date: 2008-11-08 22:35:20 +0100 (Sat, 08 Nov 2008)
New Revision: 682

Added:
   branches/OpenFDM-StateSeparation/src/test/foucault.cpp
Modified:
   branches/OpenFDM-StateSeparation/src/test/Makefile.am
Log:
Hmm, sketch of ates for the universal joint.

A    src/test/foucault.cpp
M    src/test/Makefile.am


Modified: branches/OpenFDM-StateSeparation/src/test/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/Makefile.am	2008-11-08 21:34:33 UTC (rev 681)
+++ branches/OpenFDM-StateSeparation/src/test/Makefile.am	2008-11-08 21:35:20 UTC (rev 682)
@@ -21,6 +21,9 @@
 mechanic_SOURCES = mechanic.cpp
 mechanic_LDADD = ../OpenFDM/libOpenFDM.la
 
+# foucault_SOURCES = foucault.cpp
+# foucault_LDADD = ../OpenFDM/libOpenFDM.la
+
 structure_SOURCES = structure.cpp
 structure_LDADD = ../OpenFDM/libOpenFDM.la
 

Added: branches/OpenFDM-StateSeparation/src/test/foucault.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/foucault.cpp	2008-11-08 21:34:33 UTC (rev 681)
+++ branches/OpenFDM-StateSeparation/src/test/foucault.cpp	2008-11-08 21:35:20 UTC (rev 682)
@@ -0,0 +1,36 @@
+#include <OpenFDM/Group.h>
+#include <OpenFDM/Mass.h>
+#include <OpenFDM/FixedRootJoint.h>
+#include <OpenFDM/UniversalJoint.h>
+#include <OpenFDM/RigidBody.h>
+#include <OpenFDM/System.h>
+#include <OpenFDM/SystemOutput.h>
+
+using namespace OpenFDM;
+
+int main()
+{
+  // Model of the paris pendulum or foucault pendulum to test coriolis effects.
+
+  SharedPtr<Group> group = new Group("Foucault");
+  Group::NodeId root = group->addChild(new FixedRootJoint("Root"));
+  Group::NodeId universal = group->addChild(new UniversalJoint("Universal"));
+  Group::NodeId rigidBody = group->addChild(new RigidBody("Rigid Body"));
+  InertiaMatrix inertia(1, 0, 0, 1, 0, 1);
+  Group::NodeId mass = group->addChild(new Mass("Mass", 1, inertia));
+
+  group->connect(root, 0, universal, 0);
+  group->connect(universal, 1, rigidBody, 0);
+  group->connect(rigidBody, 1, mass, 0);
+
+  SharedPtr<System> system = new System("System", group);
+
+  system->attach(SystemOutput::newDefaultSystemOutput("foucault.h5"));
+
+  if (!system->init())
+    return 1;
+
+  system->simulate(24*60*60);
+
+  return 0;
+}



From frohlich at mail.berlios.de  Sun Nov  9 09:18:15 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 9 Nov 2008 09:18:15 +0100
Subject: [OpenFDM-svn] r683 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811090818.mA98IFR9009844@sheep.berlios.de>

Author: frohlich
Date: 2008-11-09 09:18:14 +0100 (Sun, 09 Nov 2008)
New Revision: 683

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJoint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJoint.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
   branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.h
Log:
Sketch of a fixed root implementation.

M    OpenFDM/FixedRootJoint.h
M    OpenFDM/Makefile.am
M    OpenFDM/RootJoint.h
M    OpenFDM/FixedRootJoint.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJoint.cpp	2008-11-08 21:35:20 UTC (rev 682)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJoint.cpp	2008-11-09 08:18:14 UTC (rev 683)
@@ -5,6 +5,7 @@
 #include "FixedRootJoint.h"
 
 #include "Assert.h"
+#include "LeafContext.h"
 #include "LogStream.h"
 #include "Object.h"
 #include "Vector.h"
@@ -12,140 +13,64 @@
 #include "Quaternion.h"
 #include "Inertia.h"
 #include "Gravity.h"
-#include "Frame.h"
-#include "RigidBody.h"
-#include "ModelVisitor.h"
-#include "RootFrame.h"
-#include "FixedRootJointFrame.h"
+#include "MechanicContext.h"
 
 namespace OpenFDM {
 
-FixedRootJoint::FixedRootJoint(const std::string& name)
-  : Joint(name),
-    mFrame(new FixedRootJointFrame(name))
-{
-}
+BEGIN_OPENFDM_OBJECT_DEF(FixedRootJoint, RootJoint)
+  END_OPENFDM_OBJECT_DEF
 
-FixedRootJoint::~FixedRootJoint(void)
+FixedRootJoint::FixedRootJoint(const std::string& name) :
+  RootJoint(name),
+  mMechanicLink(newMechanicLink("link"))
 {
 }
 
-void
-FixedRootJoint::accept(ModelVisitor& visitor)
+FixedRootJoint::~FixedRootJoint()
 {
-  visitor.handleNodePathAndApply(*this);
 }
 
-bool
-FixedRootJoint::init(void)
-{
-  mGravity = mEnvironment->getGravity();
-  if (!mGravity) {
-    Log(Model,Error) << "Can not get gravity model!" << endl;
-    return false;
-  }
-  const Frame* rootFrame = mEnvironment->getRootFrame();
-  if (!rootFrame) {
-    Log(Model,Error) << "Can not get rootFrame model!" << endl;
-    return false;
-  }
-  recheckTopology();
-
-  return Joint::init();
-}
-
 void
-FixedRootJoint::recheckTopology(void)
+FixedRootJoint::init(const Task&, DiscreteStateValueVector&,
+                      ContinousStateValueVector& continousState,
+                      const PortValueList& portValues) const
 {
-  // Hmm, works for the first cut, but rethink what happens with strange
-  // attach reattach sequences ...
-  RigidBody* rigidBody = getOutboardBody();
-  if (!rigidBody)
-    return;
-  // check if already done
-  if (mFrame != rigidBody->getFrame())
-    rigidBody->setFrame(mFrame);
-
-  // Check if we are attached to some rigid body ...
-  rigidBody = getInboardBody();
-  if (rigidBody) {
-    Frame* frame = rigidBody->getFrame();
-    if (frame && !frame->isDirectParentFrameOf(mFrame))
-      frame->addChildFrame(mFrame);
-  } else {
-    if (mEnvironment) {
-      Frame* rootFrame = mEnvironment->getRootFrame();
-      if (rootFrame && !rootFrame->isDirectParentFrameOf(mFrame))
-        rootFrame->addChildFrame(mFrame);
-    }
-  }
 }
 
-const Vector3&
-FixedRootJoint::getRefPosition(void) const
-{
-  return mFrame->getRefPosition();
-}
-
 void
-FixedRootJoint::setRefPosition(const Vector3& p)
+FixedRootJoint::velocity(const Task&,
+                          const ContinousStateValueVector& continousState,
+                          PortValueList& portValues) const
 {
-  mFrame->setRefPosition(p);
-}
+  Vector3 position(0, 0, 0);
+  Quaternion orientation = Quaternion::unit();
+  Vector6 velocity = Vector6::zeros();
 
-const Quaternion&
-FixedRootJoint::getRefOrientation(void) const
-{
-  return mFrame->getRefOrientation();
+  portValues[mMechanicLink].setPosAndVel(getAngularBaseVelocity(),
+                                         position, orientation, velocity);
 }
 
 void
-FixedRootJoint::setRefOrientation(const Quaternion& o)
+FixedRootJoint::articulation(const Task&, const ContinousStateValueVector&,
+                              PortValueList&) const
 {
-  mFrame->setRefOrientation(o);
+  /// In this case a noop.
 }
 
-Geodetic
-FixedRootJoint::getGeodPosition(void) const
-{
-  if (!mEnvironment)
-    return Geodetic();
-  return mEnvironment->getPlanet()->toGeod(getRefPosition());
-}
-
 void
-FixedRootJoint::setGeodPosition(const Geodetic& geod)
+FixedRootJoint::acceleration(const Task&, const ContinousStateValueVector&,
+                              PortValueList& portValues) const
 {
-  if (!mEnvironment)
-    return;
-  setRefPosition(mEnvironment->getPlanet()->toCart(geod));
-}
+  // Assumption: body is small compared to the distance to the planets
+  // center of mass. That means gravity could be considered equal for the
+  // whole vehicle.
+  // See Featherstone, Orin: Equations and Algorithms
 
-Quaternion
-FixedRootJoint::getGeodOrientation(void) const
-{
-  if (!mEnvironment)
-    return Quaternion::unit();
-  Quaternion hlOr = mEnvironment->getPlanet()->getGeodHLOrientation(getRefPosition());
-  return inverse(hlOr)*getRefOrientation();
-}
+  // FIXME
+  Vector6 grav = Vector6(Vector3::zeros(), portValues[mMechanicLink].getFrame().rotFromRef(Vector3(0, 0, 9.81)));
 
-void
-FixedRootJoint::jointArticulation(SpatialInertia& artI, Vector6& artF,
-                             const SpatialInertia& outI,
-                             const Vector6& outF)
-{
-  artI.clear();
-  artF.clear();
-
-  Log(ArtBody, Debug) << "FixedRootJoint::computeRelVelDot():\n" << outI << endl;
-  mFrame->jointArticulation(outF, outI, mGravity);
+  Vector6 spatialAcceleration = grav;
+  portValues[mMechanicLink].getFrame().setSpAccel(spatialAcceleration);
 }
 
-void
-FixedRootJoint::setEnvironment(Environment* environment)
-{
-  mEnvironment = environment;
-}
-
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJoint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJoint.h	2008-11-08 21:35:20 UTC (rev 682)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJoint.h	2008-11-09 08:18:14 UTC (rev 683)
@@ -9,71 +9,30 @@
 #include "Object.h"
 #include "Vector.h"
 #include "Matrix.h"
+#include "MatrixStateInfo.h"
 #include "Quaternion.h"
 #include "Inertia.h"
-#include "Frame.h"
-#include "RigidBody.h"
-#include "Planet.h"
-#include "Joint.h"
-#include "Environment.h"
+#include "RootJoint.h"
 
 namespace OpenFDM {
 
-class ModelVisitor;
-class FixedRootJointFrame;
-
-class FixedRootJoint
-  : public Joint {
+class FixedRootJoint : public RootJoint {
+  OPENFDM_OBJECT(FixedRootJoint, RootJoint);
 public:
   FixedRootJoint(const std::string& name);
-  virtual ~FixedRootJoint(void);
+  virtual ~FixedRootJoint();
 
-  /// Double dispatch helper for the multibody system visitor
-  virtual void accept(ModelVisitor& visitor);
-  /// Double dispatch helper for the multibody system visitor
-//   virtual void accept(ConstModelVisitor& visitor) const;
-
-  virtual bool init(void);
-
-  virtual void recheckTopology(void);
-
-  /// Get the reference position.
-  const Vector3& getRefPosition(void) const;
-  /// Set the reference position.
-  void setRefPosition(const Vector3& p);
-
-  /// Get the reference orientation.
-  const Quaternion& getRefOrientation(void) const;
-  /// Set the reference orientation.
-  void setRefOrientation(const Quaternion& o);
-
-  /// Get the geodetic position.
-  Geodetic getGeodPosition(void) const;
-  /// Set the geodetic position.
-  void setGeodPosition(const Geodetic& geod);
-  /// Get orientation wrt the geodetic hl frame.
-  Quaternion getGeodOrientation(void) const;
-
-  /** Plugin function for the articulated body algorithm.
-   */
-  virtual void jointArticulation(SpatialInertia& artI, Vector6& artF,
-                                 const SpatialInertia& outI,
-                                 const Vector6& outF);
-
-
-protected:
-  virtual void setEnvironment(Environment* environment);
-
+  virtual void init(const Task&, DiscreteStateValueVector&,
+                    ContinousStateValueVector&,
+                    const PortValueList&) const;
+  virtual void velocity(const Task&, const ContinousStateValueVector& states,
+                        PortValueList& portValues) const;
+  virtual void articulation(const Task&, const ContinousStateValueVector&,
+                            PortValueList& portValues) const;
+  virtual void acceleration(const Task&, const ContinousStateValueVector&,
+                            PortValueList& portValues) const;
 private:
-  /// The commonly used gravity model from the environment class
-  /// It is initialized at the init() call
-  SharedPtr<const Gravity> mGravity;
-
-  /// The frame of the mobile root
-  SharedPtr<FixedRootJointFrame> mFrame;
-
-  /// The environment pointer
-  SharedPtr<Environment> mEnvironment;
+  MechanicLink mMechanicLink;
 };
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-11-08 21:35:20 UTC (rev 682)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-11-09 08:18:14 UTC (rev 683)
@@ -242,6 +242,7 @@
 
 OpenFDMMechanicSOURCES = \
   Joint.cpp \
+  FixedRootJoint.cpp \
   Mass.cpp \
   MobileRootJoint.cpp \
   PrismaticJoint.cpp \
@@ -263,7 +264,6 @@
 #   DefaultPlanet.cpp \
 #   DiscBrake.cpp \
 #   ExternalForceModel.cpp \
-#   FixedRootJoint.cpp \
 #   Force.cpp \
 #   Gravity.cpp \
 #   Ground.cpp \

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.h	2008-11-08 21:35:20 UTC (rev 682)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.h	2008-11-09 08:18:14 UTC (rev 683)
@@ -35,8 +35,8 @@
   virtual void derivative(const DiscreteStateValueVector&,
                           const ContinousStateValueVector&,
                           const PortValueList& portValues,
-                          ContinousStateValueVector&) const = 0;
-
+                          ContinousStateValueVector&) const
+  {}
 private:
   class Context;
 



From frohlich at mail.berlios.de  Sun Nov  9 09:27:35 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 9 Nov 2008 09:27:35 +0100
Subject: [OpenFDM-svn] r684 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811090827.mA98RZt9011813@sheep.berlios.de>

Author: frohlich
Date: 2008-11-09 09:27:34 +0100 (Sun, 09 Nov 2008)
New Revision: 684

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/MatrixInputPort.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/RealInputPort.h
Log:
Remove const qualifier on non const methods.

M    OpenFDM/MatrixInputPort.h
M    OpenFDM/RealInputPort.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MatrixInputPort.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MatrixInputPort.h	2008-11-09 08:18:14 UTC (rev 683)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MatrixInputPort.h	2008-11-09 08:27:34 UTC (rev 684)
@@ -34,7 +34,7 @@
   { OpenFDMAssert(mPort); return mPort->getIndex(); }
   bool getDirectInput() const
   { OpenFDMAssert(mPort); return mPort->getDirectInput(); }
-  void setDirectInput(bool directInput) const
+  void setDirectInput(bool directInput)
   { OpenFDMAssert(mPort); mPort->setDirectInput(directInput); }
 private:
   SharedPtr<InputPortInfo> mPort;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RealInputPort.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RealInputPort.h	2008-11-09 08:18:14 UTC (rev 683)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RealInputPort.h	2008-11-09 08:27:34 UTC (rev 684)
@@ -34,7 +34,7 @@
   { OpenFDMAssert(mPort); return mPort->getIndex(); }
   bool getDirectInput() const
   { OpenFDMAssert(mPort); return mPort->getDirectInput(); }
-  void setDirectInput(bool directInput) const
+  void setDirectInput(bool directInput)
   { OpenFDMAssert(mPort); mPort->setDirectInput(directInput); }
 private:
   SharedPtr<InputPortInfo> mPort;



From frohlich at mail.berlios.de  Sun Nov  9 09:44:04 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 9 Nov 2008 09:44:04 +0100
Subject: [OpenFDM-svn] r685 - in branches/OpenFDM-StateSeparation/src:
	OpenFDM test
Message-ID: <200811090844.mA98i4nk012523@sheep.berlios.de>

Author: frohlich
Date: 2008-11-09 09:44:04 +0100 (Sun, 09 Nov 2008)
New Revision: 685

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/PrismaticJoint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/PrismaticJoint.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/UniversalJoint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/UniversalJoint.h
   branches/OpenFDM-StateSeparation/src/test/mechanic.cpp
Log:
Make joint input forces optional.

M    OpenFDM/PrismaticJoint.cpp
M    OpenFDM/RevoluteJoint.cpp
M    OpenFDM/UniversalJoint.h
M    OpenFDM/PrismaticJoint.h
M    OpenFDM/RevoluteJoint.h
M    OpenFDM/UniversalJoint.cpp
M    test/mechanic.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/PrismaticJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/PrismaticJoint.cpp	2008-11-09 08:27:34 UTC (rev 684)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/PrismaticJoint.cpp	2008-11-09 08:44:04 UTC (rev 685)
@@ -23,7 +23,6 @@
 
 PrismaticJoint::PrismaticJoint(const std::string& name) :
   CartesianJoint<1>(name),
-  mForcePort(this, "force", Size(1, 1), true),
   mPositionPort(this, "position", Size(1, 1)),
   mVelocityPort(this, "velocity", Size(1, 1)),
   mPositionStateInfo(new Vector1StateInfo),
@@ -60,6 +59,23 @@
 }
 
 void
+PrismaticJoint::setEnableExternalForce(bool enable)
+{
+  if (enable == getEnableExternalForce())
+    return;
+  if (enable)
+    mForcePort = MatrixInputPort(this, "force", Size(1, 1), true);
+  else
+    mForcePort.clear();
+}
+
+bool
+PrismaticJoint::getEnableExternalForce() const
+{
+  return !mForcePort.empty();
+}
+
+void
 PrismaticJoint::init(const Task&, DiscreteStateValueVector&,
                     ContinousStateValueVector& continousState,
                     const PortValueList&) const

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/PrismaticJoint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/PrismaticJoint.h	2008-11-09 08:27:34 UTC (rev 684)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/PrismaticJoint.h	2008-11-09 08:44:04 UTC (rev 685)
@@ -33,6 +33,9 @@
   const Vector3& getAxis() const;
   void setAxis(const Vector3& axis);
 
+  void setEnableExternalForce(bool enable);
+  bool getEnableExternalForce() const;
+
 protected:
 
   virtual void init(const Task&, DiscreteStateValueVector&,

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.cpp	2008-11-09 08:27:34 UTC (rev 684)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.cpp	2008-11-09 08:44:04 UTC (rev 685)
@@ -23,7 +23,6 @@
 
 RevoluteJoint::RevoluteJoint(const std::string& name) :
   CartesianJoint<1>(name),
-  mForcePort(this, "force", Size(1, 1), true),
   mPositionPort(this, "position", Size(1, 1)),
   mVelocityPort(this, "velocity", Size(1, 1)),
   mPositionStateInfo(new Vector1StateInfo),
@@ -60,6 +59,23 @@
 }
 
 void
+RevoluteJoint::setEnableExternalForce(bool enable)
+{
+  if (enable == getEnableExternalForce())
+    return;
+  if (enable)
+    mForcePort = MatrixInputPort(this, "force", Size(1, 1), true);
+  else
+    mForcePort.clear();
+}
+
+bool
+RevoluteJoint::getEnableExternalForce() const
+{
+  return !mForcePort.empty();
+}
+
+void
 RevoluteJoint::init(const Task&, DiscreteStateValueVector&,
                     ContinousStateValueVector& continousState,
                     const PortValueList&) const

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.h	2008-11-09 08:27:34 UTC (rev 684)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.h	2008-11-09 08:44:04 UTC (rev 685)
@@ -33,6 +33,9 @@
   const Vector3& getAxis() const;
   void setAxis(const Vector3& axis);
 
+  void setEnableExternalForce(bool enable);
+  bool getEnableExternalForce() const;
+
 protected:
 
   virtual void init(const Task&, DiscreteStateValueVector&,

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/UniversalJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/UniversalJoint.cpp	2008-11-09 08:27:34 UTC (rev 684)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/UniversalJoint.cpp	2008-11-09 08:44:04 UTC (rev 685)
@@ -23,7 +23,6 @@
 
 UniversalJoint::UniversalJoint(const std::string& name) :
   CartesianJoint<2>(name),
-  mForcePort(this, "force", Size(2, 1), true),
   mOrientationPort(this, "orientation", Size(4, 1)),
   mVelocityPort(this, "velocity", Size(2, 1)),
   mPositionStateInfo(new Vector3StateInfo),
@@ -68,6 +67,23 @@
 }
 
 void
+UniversalJoint::setEnableExternalForce(bool enable)
+{
+  if (enable == getEnableExternalForce())
+    return;
+  if (enable)
+    mForcePort = MatrixInputPort(this, "force", Size(2, 1), true);
+  else
+    mForcePort.clear();
+}
+
+bool
+UniversalJoint::getEnableExternalForce() const
+{
+  return !mForcePort.empty();
+}
+
+void
 UniversalJoint::init(const Task&, DiscreteStateValueVector&,
                     ContinousStateValueVector& continousState,
                     const PortValueList&) const

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/UniversalJoint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/UniversalJoint.h	2008-11-09 08:27:34 UTC (rev 684)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/UniversalJoint.h	2008-11-09 08:44:04 UTC (rev 685)
@@ -33,6 +33,9 @@
   const Vector3& getAxis() const;
   void setAxis(const Vector3& axis);
 
+  void setEnableExternalForce(bool enable);
+  bool getEnableExternalForce() const;
+
 protected:
 
   virtual void init(const Task&, DiscreteStateValueVector&,

Modified: branches/OpenFDM-StateSeparation/src/test/mechanic.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/mechanic.cpp	2008-11-09 08:27:34 UTC (rev 684)
+++ branches/OpenFDM-StateSeparation/src/test/mechanic.cpp	2008-11-09 08:44:04 UTC (rev 685)
@@ -37,10 +37,13 @@
   RigidBody *body = new RigidBody("Rigid Body");
   body->addLink("link2");
   Group::NodeId rigidBody = group->addChild(body);
-  Group::NodeId mass = group->addChild(new Mass("Mass", 1, InertiaMatrix(1, 0, 0, 1, 0, 1)));
-  Group::NodeId revolute = group->addChild(new RevoluteJoint("Revolute Joint"));
+  InertiaMatrix inertia(1, 0, 0, 1, 0, 1);
+  Group::NodeId mass = group->addChild(new Mass("Mass", 1, inertia));
+  RevoluteJoint* revoluteJoint = new RevoluteJoint("Revolute Joint");
+  revoluteJoint->setEnableExternalForce(true);
+  Group::NodeId revolute = group->addChild(revoluteJoint);
   Group::NodeId rigidBody2 = group->addChild(new RigidBody("Rigid Body 2"));
-  Group::NodeId mass2 = group->addChild(new Mass("Mass 2", 1, InertiaMatrix(1, 0, 0, 1, 0, 1)));
+  Group::NodeId mass2 = group->addChild(new Mass("Mass 2", 1, inertia));
 
   group->connect(rootJoint, "link", rigidBody, "link0");
   group->connect(rigidBody, "link1", mass, "link");
@@ -49,7 +52,7 @@
   group->connect(rigidBody2, "link1", mass2, "link");
 
   Group::NodeId jointForce = group->addChild(new ConstModel("Joint Force", 1));
-//   Group::NodeId jointForce = group->addChild(new ConstModel("Joint Force", 0));
+
   group->connect(jointForce, "output", revolute, "force");
 
   return group.release();



From frohlich at mail.berlios.de  Sun Nov  9 10:16:33 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 9 Nov 2008 10:16:33 +0100
Subject: [OpenFDM-svn] r686 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811090916.mA99GXA0014613@sheep.berlios.de>

Author: frohlich
Date: 2008-11-09 10:16:33 +0100 (Sun, 09 Nov 2008)
New Revision: 686

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/UniversalJoint.cpp
Log:
Fix off by one error.

M    UniversalJoint.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/UniversalJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/UniversalJoint.cpp	2008-11-09 08:44:04 UTC (rev 685)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/UniversalJoint.cpp	2008-11-09 09:16:33 UTC (rev 686)
@@ -61,8 +61,8 @@
   Vector3 axis1 = perpendicular(mAxis);
   Vector3 axis2 = cross(mAxis, axis1);
   Matrix6N jointMatrix;
-  jointMatrix(Range(0, 6), Range(0)) = Vector6(axis1, Vector3::zeros());
-  jointMatrix(Range(0, 6), Range(1)) = Vector6(axis2, Vector3::zeros());
+  jointMatrix(Range(0, 5), Range(0)) = Vector6(axis1, Vector3::zeros());
+  jointMatrix(Range(0, 5), Range(1)) = Vector6(axis2, Vector3::zeros());
   setJointMatrix(jointMatrix);
 }
 



From frohlich at mail.berlios.de  Sun Nov  9 10:25:05 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 9 Nov 2008 10:25:05 +0100
Subject: [OpenFDM-svn] r687 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200811090925.mA99P5sc015064@sheep.berlios.de>

Author: frohlich
Date: 2008-11-09 10:25:05 +0100 (Sun, 09 Nov 2008)
New Revision: 687

Modified:
   branches/OpenFDM-StateSeparation/src/test/Makefile.am
   branches/OpenFDM-StateSeparation/src/test/foucault.cpp
Log:
Small updates for the pendulum example. Does not work yet ...

M    src/test/foucault.cpp
M    src/test/Makefile.am


Modified: branches/OpenFDM-StateSeparation/src/test/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/Makefile.am	2008-11-09 09:16:33 UTC (rev 686)
+++ branches/OpenFDM-StateSeparation/src/test/Makefile.am	2008-11-09 09:25:05 UTC (rev 687)
@@ -2,7 +2,7 @@
 
 # define some util programs
 # bin_PROGRAMS = tiretestrig
-bin_PROGRAMS = structure mechanic
+bin_PROGRAMS = structure mechanic foucault
 
 # define some unit tests
 #check_PROGRAMS = quattest unitstest structure simulationtime constintegral harmonic limit
@@ -21,8 +21,8 @@
 mechanic_SOURCES = mechanic.cpp
 mechanic_LDADD = ../OpenFDM/libOpenFDM.la
 
-# foucault_SOURCES = foucault.cpp
-# foucault_LDADD = ../OpenFDM/libOpenFDM.la
+foucault_SOURCES = foucault.cpp
+foucault_LDADD = ../OpenFDM/libOpenFDM.la
 
 structure_SOURCES = structure.cpp
 structure_LDADD = ../OpenFDM/libOpenFDM.la

Modified: branches/OpenFDM-StateSeparation/src/test/foucault.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/foucault.cpp	2008-11-09 09:16:33 UTC (rev 686)
+++ branches/OpenFDM-StateSeparation/src/test/foucault.cpp	2008-11-09 09:25:05 UTC (rev 687)
@@ -12,12 +12,16 @@
 {
   // Model of the paris pendulum or foucault pendulum to test coriolis effects.
 
+  // FIXME, need usable positioning algorithm first ...
   SharedPtr<Group> group = new Group("Foucault");
   Group::NodeId root = group->addChild(new FixedRootJoint("Root"));
-  Group::NodeId universal = group->addChild(new UniversalJoint("Universal"));
+  UniversalJoint* universalJoint = new UniversalJoint("Universal");
+  universalJoint->setAxis(Vector3(0, 0, 1));
+  Group::NodeId universal = group->addChild(universalJoint);
   Group::NodeId rigidBody = group->addChild(new RigidBody("Rigid Body"));
-  InertiaMatrix inertia(1, 0, 0, 1, 0, 1);
-  Group::NodeId mass = group->addChild(new Mass("Mass", 1, inertia));
+  Mass* massModel = new Mass("Mass", 1, InertiaMatrix(1, 0, 0, 1, 0, 1));
+  massModel->setPosition(Vector3(1, 1, 1));
+  Group::NodeId mass = group->addChild(massModel);
 
   group->connect(root, 0, universal, 0);
   group->connect(universal, 1, rigidBody, 0);
@@ -30,7 +34,8 @@
   if (!system->init())
     return 1;
 
-  system->simulate(24*60*60);
+//   system->simulate(24*60*60);
+  system->simulate(60);
 
   return 0;
 }



From frohlich at mail.berlios.de  Sun Nov  9 11:19:50 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 9 Nov 2008 11:19:50 +0100
Subject: [OpenFDM-svn] r688 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811091019.mA9AJoU7018685@sheep.berlios.de>

Author: frohlich
Date: 2008-11-09 11:19:49 +0100 (Sun, 09 Nov 2008)
New Revision: 688

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
Log:
Rename some utility classes to start with an '_'

M    src/OpenFDM/System.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-09 09:25:05 UTC (rev 687)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-09 10:19:49 UTC (rev 688)
@@ -94,7 +94,7 @@
     mODESolver->setFunction(mContinousSystemFunction);
   }
 
-  void appendModelInstance(ModelInstance* modelInstance)
+  void appendModelInstance(OpenFDM::ModelInstance* modelInstance)
   {
     ModelContext* modelContext = &modelInstance->getNodeContext();
     SampleTime sampleTime = modelInstance->getSampleTime();
@@ -238,25 +238,25 @@
     mBasicSampleTime(SampleTime::getContinous())
   { }
 
-  struct PortData;
+  struct _PortData;
 
   struct PortConnectSet : public Referenced {
     bool setPortValue(PortValue* portValue)
     {
       while (!mParentPortData.empty()) {
-        SharedPtr<PortData> portData = mParentPortData.back().lock();
+        SharedPtr<_PortData> portData = mParentPortData.back().lock();
         mParentPortData.pop_back();
         if (!portData->setPortValue(portValue))
           return false;
       }
       return true;
     }
-    std::vector<WeakPtr<PortData> > mParentPortData;
+    std::vector<WeakPtr<_PortData> > mParentPortData;
   };
 
-  struct PortData : public WeakReferenced {
+  struct _PortData : public WeakReferenced {
   public:
-    PortData(AbstractNodeInstance* nodeInstance, const PortInfo* portInfo) :
+    _PortData(AbstractNodeInstance* nodeInstance, const PortInfo* portInfo) :
       mNodeInstance(nodeInstance),
       mPortValueCreator(true),
       mPortInfo(portInfo)
@@ -276,7 +276,7 @@
       }
       // Merge the port sets together ...
       while (!mPortConnectSet->mParentPortData.empty()) {
-        SharedPtr<PortData> portData = mPortConnectSet->mParentPortData.back().lock();
+        SharedPtr<_PortData> portData = mPortConnectSet->mParentPortData.back().lock();
         mPortConnectSet->mParentPortData.pop_back();
         if (portData == this)
           continue;
@@ -295,7 +295,7 @@
       return mPortConnectSet;
     }
 
-    bool addPortData(PortData* portData)
+    bool addPortData(_PortData* portData)
     {
       if (getPortInfo()->getMaxConnects() <= mConnectedPorts.size())
         return false;
@@ -304,7 +304,7 @@
       return true;
     }
 
-    bool connect(PortData* portData)
+    bool connect(_PortData* portData)
     {
       if (getPortInfo()->getMaxConnects() <= mConnectedPorts.size())
         return false;
@@ -339,7 +339,7 @@
       mPortValueCreator = false;
     }
 
-    void setProxyPortData(PortData* proxyPortData)
+    void setProxyPortData(_PortData* proxyPortData)
     {
       mPortValueCreator = false;
       setPortConnectSet(proxyPortData->getOrCreatePortConnectSet());
@@ -363,12 +363,12 @@
     bool mPortValueCreator;
     SharedPtr<AbstractNodeInstance> mNodeInstance;
     SharedPtr<const PortInfo> mPortInfo;
-    std::vector<WeakPtr<PortData> > mConnectedPorts;
+    std::vector<WeakPtr<_PortData> > mConnectedPorts;
     SharedPtr<PortConnectSet> mPortConnectSet;
   };
 
   // Return true if this leaf directly depends on one of leafInstance outputs
-  class PortDataList : public Referenced {
+  class _PortDataList : public Referenced {
   public:
     void setNodeInstance(AbstractNodeInstance* nodeInstance)
     {
@@ -377,10 +377,10 @@
       unsigned numPorts = nodeInstance->getNode().getNumPorts();
       mPortDataVector.resize(numPorts);
       for (unsigned i = 0; i < numPorts; ++i)
-        mPortDataVector[i] = new PortData(nodeInstance, nodeInstance->getNode().getPort(i));
+        mPortDataVector[i] = new _PortData(nodeInstance, nodeInstance->getNode().getPort(i));
     }
     
-    PortData* getPortData(const PortInfo& portInfo)
+    _PortData* getPortData(const PortInfo& portInfo)
     { return mPortDataVector[portInfo.getIndex()]; }
     
     bool allocAndConnectProviderPortValues()
@@ -403,7 +403,7 @@
     }
 
     /// The vector of per port connect information
-    typedef std::vector<SharedPtr<PortData> > PortDataVector;
+    typedef std::vector<SharedPtr<_PortData> > PortDataVector;
     PortDataVector mPortDataVector;
     
     /// The AbstractNodeInstance having some way to reference the
@@ -420,12 +420,12 @@
   virtual void apply(const LibraryNode& libraryNode)
   { Log(Schedule, Error) << __PRETTY_FUNCTION__ << std::endl; }
 
-  PortDataList* buildNodeContext(const Node& node)
+  _PortDataList* buildNodeContext(const Node& node)
   {
-    NodeInstance* nodeInstance;
-    nodeInstance = new NodeInstance(getNodePath(), mSampleTime, &node);
+    OpenFDM::NodeInstance* nodeInstance;
+    nodeInstance = new OpenFDM::NodeInstance(getNodePath(), mSampleTime, &node);
     _nodeInstanceList.push_back(nodeInstance);
-    PortDataList* portDataList;
+    _PortDataList* portDataList;
     portDataList = getCurrentNodePortDataList();
     portDataList->setNodeInstance(nodeInstance);
     return portDataList;
@@ -433,15 +433,15 @@
 
   virtual void apply(const GroupInterfaceNode& leaf)
   {
-    PortDataList* portDataList = buildNodeContext(leaf);
+    _PortDataList* portDataList = buildNodeContext(leaf);
     OpenFDMAssert(leaf.getPort(0));
-    PortData* portData = portDataList->getPortData(*leaf.getPort(0));
+    _PortData* portData = portDataList->getPortData(*leaf.getPort(0));
     _groupPortDataMap[leaf.getExternalPortIndex()] = portData;
   }
 
   void allocPortData(AbstractNodeInstance* nodeInstance, const LeafNode& leaf)
   {
-    PortDataList* portDataList;
+    _PortDataList* portDataList;
     portDataList = getCurrentNodePortDataList();
     portDataList->setNodeInstance(nodeInstance);
   }
@@ -471,7 +471,7 @@
     _nodeInstanceList.push_back(mechanicInstance);
     allocPortData(mechanicInstance, node);
     // Make all rigid mechanic body links use the same link value
-    PortData* portData = 0;
+    _PortData* portData = 0;
     for (unsigned i = 0; i < node.getNumPorts(); ++i) {
       if (!node.getPort(i)->toMechanicLinkInfo())
         continue;
@@ -492,7 +492,7 @@
   }
   virtual void apply(const Model& node)
   {
-    ModelInstance* modelInstance = new ModelInstance(getNodePath(), mSampleTime, &node);
+    OpenFDM::ModelInstance* modelInstance = new OpenFDM::ModelInstance(getNodePath(), mSampleTime, &node);
     _nodeInstanceList.push_back(modelInstance);
     _modelInstanceList.push_back(modelInstance);
     allocPortData(modelInstance, node);
@@ -501,11 +501,11 @@
   virtual void apply(const Group& group)
   {
     // Prepare a new leaf map for the child group
-    PortDataMap parentPortDataMap(group.getNumChildren());
+    _PortDataMap parentPortDataMap(group.getNumChildren());
     parentPortDataMap.swap(_portDataMap);
 
     // Get PortDataList indexed by group port index
-    ExternalGroupPortDataMap parentGroupPortDataMap(group.getNumPorts());
+    _ExternalGroupPortDataMap parentGroupPortDataMap(group.getNumPorts());
     parentGroupPortDataMap.swap(_groupPortDataMap);
 
     // End pushing external connection data
@@ -534,10 +534,10 @@
       }
 
       // Push the right per node port information struct
-      SharedPtr<PortDataList> parentNodePortDataList;
+      SharedPtr<_PortDataList> parentNodePortDataList;
       parentNodePortDataList.swap(mCurrentNodePortDataList);
 
-      mCurrentNodePortDataList = new PortDataList;
+      mCurrentNodePortDataList = new _PortDataList;
       _portDataMap[i] = mCurrentNodePortDataList;
       _portDataListList.push_back(mCurrentNodePortDataList);
 
@@ -588,12 +588,12 @@
           " appeared to be compatible before." << std::endl;
     }
 
-    SharedPtr<PortDataList> portDataList = buildNodeContext(group);
+    SharedPtr<_PortDataList> portDataList = buildNodeContext(group);
 
     // add group connect routings
     // merge child list into the global list of instances
     for (unsigned i = 0; i < group.getNumPorts(); ++i) {
-      PortData* portData = _groupPortDataMap[i];
+      _PortData* portData = _groupPortDataMap[i];
       if (!portData) {
         Log(Schedule, Error) << "Internal Error: Cannot find internal port "
           "data for group external port!" << std::endl;
@@ -601,7 +601,7 @@
       }
 
       // Allocate a new port data struct in the parent.
-      PortData* parentPortData = portDataList->getPortData(*group.getPort(i));
+      _PortData* parentPortData = portDataList->getPortData(*group.getPort(i));
       parentPortData->setProxyPortData(portData);
       portData->setProxyPortData(parentPortData);
     }
@@ -629,18 +629,18 @@
 
   ////////////////////////////////////////////////////////////////////////////
   // Used to map connections in groups ...
-  typedef std::vector<SharedPtr<PortDataList> > PortDataMap;
-  PortDataMap _portDataMap;
+  typedef std::vector<SharedPtr<_PortDataList> > _PortDataMap;
+  _PortDataMap _portDataMap;
   // Holds the PortDataList pointer indexed by parent groups port index
-  typedef std::vector<SharedPtr<PortData> > ExternalGroupPortDataMap;
-  ExternalGroupPortDataMap _groupPortDataMap;
+  typedef std::vector<SharedPtr<_PortData> > _ExternalGroupPortDataMap;
+  _ExternalGroupPortDataMap _groupPortDataMap;
   // Just to hold references to all port data lists we have in the
   // simulation system. They are just needed during traversal for connect
   // information and to distribute port value pointers. If this list is not
   // built up the PortData values are deleted befor the PortValues are
   // distributed.
-  typedef std::list<SharedPtr<PortDataList> > PortDataListList;
-  PortDataListList _portDataListList;
+  typedef std::list<SharedPtr<_PortDataList> > _PortDataListList;
+  _PortDataListList _portDataListList;
 
   // Current nodes sample time
   SampleTime mSampleTime;
@@ -794,7 +794,7 @@
   {
     ModelInstanceList sortedModelInstanceList;
     while (!_modelInstanceList.empty()) {
-      SharedPtr<ModelInstance> modelInstance = _modelInstanceList.front();
+      SharedPtr<OpenFDM::ModelInstance> modelInstance = _modelInstanceList.front();
       _modelInstanceList.pop_front();
 
       if (modelInstance->dependsOn(*modelInstance)) {
@@ -850,7 +850,7 @@
   allocPortValues()
   {
     // alloc port values
-    PortDataListList::const_iterator i;
+    _PortDataListList::const_iterator i;
     for (i = _portDataListList.begin(); i != _portDataListList.end(); ++i) {
       if (!(*i)->allocAndConnectProviderPortValues())
         return false;
@@ -906,16 +906,16 @@
     return true;
   }
 
-  PortDataList* getCurrentNodePortDataList()
+  _PortDataList* getCurrentNodePortDataList()
   {
     if (!mCurrentNodePortDataList)
       // will happen for the toplevel group node ..
-      mCurrentNodePortDataList = new PortDataList;
+      mCurrentNodePortDataList = new _PortDataList;
     return mCurrentNodePortDataList;
   }
 
 private:
-  SharedPtr<PortDataList> mCurrentNodePortDataList;
+  SharedPtr<_PortDataList> mCurrentNodePortDataList;
 };
 
 BEGIN_OPENFDM_OBJECT_DEF(System, Object)



From frohlich at mail.berlios.de  Sun Nov  9 11:22:40 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 9 Nov 2008 11:22:40 +0100
Subject: [OpenFDM-svn] r689 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811091022.mA9AMeeH018913@sheep.berlios.de>

Author: frohlich
Date: 2008-11-09 11:22:40 +0100 (Sun, 09 Nov 2008)
New Revision: 689

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
Log:
Again leading underscores.

M    src/OpenFDM/System.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-09 10:19:49 UTC (rev 688)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-09 10:22:40 UTC (rev 689)
@@ -240,7 +240,7 @@
 
   struct _PortData;
 
-  struct PortConnectSet : public Referenced {
+  struct _PortConnectSet : public Referenced {
     bool setPortValue(PortValue* portValue)
     {
       while (!mParentPortData.empty()) {
@@ -264,7 +264,7 @@
       getOrCreatePortConnectSet();
     }
 
-    void setPortConnectSet(PortConnectSet* portSet)
+    void setPortConnectSet(_PortConnectSet* portSet)
     {
       OpenFDMAssert(portSet);
       if (portSet == mPortConnectSet)
@@ -287,11 +287,11 @@
       mPortConnectSet->mParentPortData.push_back(this);
     }
 
-    PortConnectSet* getOrCreatePortConnectSet()
+    _PortConnectSet* getOrCreatePortConnectSet()
     {
       if (mPortConnectSet)
         return mPortConnectSet;
-      setPortConnectSet(new PortConnectSet);
+      setPortConnectSet(new _PortConnectSet);
       return mPortConnectSet;
     }
 
@@ -364,7 +364,7 @@
     SharedPtr<AbstractNodeInstance> mNodeInstance;
     SharedPtr<const PortInfo> mPortInfo;
     std::vector<WeakPtr<_PortData> > mConnectedPorts;
-    SharedPtr<PortConnectSet> mPortConnectSet;
+    SharedPtr<_PortConnectSet> mPortConnectSet;
   };
 
   // Return true if this leaf directly depends on one of leafInstance outputs



From frohlich at mail.berlios.de  Sun Nov  9 11:49:44 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 9 Nov 2008 11:49:44 +0100
Subject: [OpenFDM-svn] r690 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811091049.mA9AniTK020510@sheep.berlios.de>

Author: frohlich
Date: 2008-11-09 11:49:44 +0100 (Sun, 09 Nov 2008)
New Revision: 690

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
Log:
More namespace qualifier.

M    src/OpenFDM/System.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-09 10:22:40 UTC (rev 689)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-09 10:49:44 UTC (rev 690)
@@ -450,7 +450,7 @@
   {
     // Need to stor the root nodes to build up the spanning tree for the
     // mechanical system here.
-    MechanicInstance* mechanicInstance = new MechanicInstance(getNodePath(), mSampleTime, &node);
+    OpenFDM::MechanicInstance* mechanicInstance = new MechanicInstance(getNodePath(), mSampleTime, &node);
     _nodeInstanceList.push_back(mechanicInstance);
     if (node.getNumPorts() == 1)
       _rootJointInstanceList.push_back(mechanicInstance);
@@ -460,14 +460,14 @@
   }
   virtual void apply(const Interact& node)
   {
-    MechanicInstance* mechanicInstance = new MechanicInstance(getNodePath(), mSampleTime, &node);
+    OpenFDM::MechanicInstance* mechanicInstance = new MechanicInstance(getNodePath(), mSampleTime, &node);
     _nodeInstanceList.push_back(mechanicInstance);
     _interactInstanceList.push_back(mechanicInstance);
     allocPortData(mechanicInstance, node);
   }
   virtual void apply(const RigidBody& node)
   {
-    MechanicInstance* mechanicInstance = new MechanicInstance(getNodePath(), mSampleTime, &node);
+    OpenFDM::MechanicInstance* mechanicInstance = new MechanicInstance(getNodePath(), mSampleTime, &node);
     _nodeInstanceList.push_back(mechanicInstance);
     allocPortData(mechanicInstance, node);
     // Make all rigid mechanic body links use the same link value
@@ -613,19 +613,19 @@
 
   ////////////////////////////////////////////////////////////////////////////
   // The final list of Nodes we have in the simulation system
-  NodeInstanceList _nodeInstanceList;
+  OpenFDM::NodeInstanceList _nodeInstanceList;
 
 
   // The Models list, worthwhile for sorting
-  ModelInstanceList _modelInstanceList;
+  OpenFDM::ModelInstanceList _modelInstanceList;
   // The mechanical system list, also for sorting
-  MechanicInstanceList _mechanicInstanceList;
+  OpenFDM::MechanicInstanceList _mechanicInstanceList;
 
   // The list of root nodes in the mechanical system. Will be a starting point
   // for sorting the tree of mechanical models downwards
-  MechanicInstanceList _rootJointInstanceList;
-  MechanicInstanceList _interactInstanceList;
-  MechanicInstanceList _jointInstanceList;
+  OpenFDM::MechanicInstanceList _rootJointInstanceList;
+  OpenFDM::MechanicInstanceList _interactInstanceList;
+  OpenFDM::MechanicInstanceList _jointInstanceList;
 
   ////////////////////////////////////////////////////////////////////////////
   // Used to map connections in groups ...
@@ -682,12 +682,12 @@
     SharedPtr<DiscreteSystem> discreteSystem;
     discreteSystem = new DiscreteSystem(basicSampleTime, 1);
 
-    ModelInstanceList::const_iterator i;
+    OpenFDM::ModelInstanceList::const_iterator i;
     for (i = _modelInstanceList.begin(); i != _modelInstanceList.end(); ++i) {
       discreteSystem->appendModelInstance(*i);
     }
 
-    MechanicInstanceList::const_iterator j;
+    OpenFDM::MechanicInstanceList::const_iterator j;
     for (j = _mechanicInstanceList.begin();
          j != _mechanicInstanceList.end(); ++j) {
       discreteSystem->appendMechanicInstance(*j);
@@ -713,23 +713,23 @@
 
     // Not the best algorithm, but for a first cut ...
     while (!_jointInstanceList.empty()) {
-      MechanicInstanceList nextLevelList;
+      OpenFDM::MechanicInstanceList nextLevelList;
 
-      MechanicInstanceList::iterator j;
+      OpenFDM::MechanicInstanceList::iterator j;
       for (j = _mechanicInstanceList.begin();
            j != _mechanicInstanceList.end(); ++j) {
-        MechanicInstanceList::iterator i;
+        OpenFDM::MechanicInstanceList::iterator i;
         for (i = _jointInstanceList.begin();
              i != _jointInstanceList.end();) {
         
           if ((*j)->isConnectedTo(*(*i))) {
-            SharedPtr<MechanicInstance> mechanicInstance = *i;
+            SharedPtr<OpenFDM::MechanicInstance> mechanicInstance = *i;
             nextLevelList.push_back(mechanicInstance);
             i = _jointInstanceList.erase(i);
 
             // Check if this current mechanic node does not reference
             // back into the already sorted models
-            MechanicInstanceList::const_iterator k;
+            OpenFDM::MechanicInstanceList::const_iterator k;
             for (k = _mechanicInstanceList.begin();
                  k != _mechanicInstanceList.end(); ++k) {
               if (*k == *j)
@@ -754,7 +754,7 @@
       // if we have a connection in between them, there must be a
       // closed kinematic loop.
       for (j = nextLevelList.begin(); j != nextLevelList.end(); ++j) {
-        MechanicInstanceList::iterator i = j;
+        OpenFDM::MechanicInstanceList::iterator i = j;
         for (++i; i != nextLevelList.end(); ++i) {
           if ((*j)->isConnectedTo(*(*i))) {
             Log(Schedule,Error)
@@ -780,7 +780,7 @@
                                       _interactInstanceList.end());
     
     Log(Schedule,Info) << "MechanicNode Schedule" << std::endl;
-    MechanicInstanceList::iterator i = _mechanicInstanceList.begin();
+    OpenFDM::MechanicInstanceList::iterator i = _mechanicInstanceList.begin();
     for (; i != _mechanicInstanceList.end(); ++i) {
       Log(Schedule,Info)
         << "  MechanicNode \"" << (*i)->getNodeNamePath() << "\"" << std::endl;
@@ -792,7 +792,7 @@
   // method to sort the leafs according to their dependency
   bool sortModelList()
   {
-    ModelInstanceList sortedModelInstanceList;
+    OpenFDM::ModelInstanceList sortedModelInstanceList;
     while (!_modelInstanceList.empty()) {
       SharedPtr<OpenFDM::ModelInstance> modelInstance = _modelInstanceList.front();
       _modelInstanceList.pop_front();
@@ -804,7 +804,7 @@
         return false;
       }
 
-      ModelInstanceList::iterator i;
+      OpenFDM::ModelInstanceList::iterator i;
       for (i = sortedModelInstanceList.begin();
            i != sortedModelInstanceList.end();
            ++i) {
@@ -856,7 +856,7 @@
         return false;
     }
     // check port values and report unconnected mandatory values.
-    NodeInstanceList::const_iterator j;
+    OpenFDM::NodeInstanceList::const_iterator j;
     for (j = _nodeInstanceList.begin(); j != _nodeInstanceList.end(); ++j) {
       const Node& node = (*j)->getNode();
       for (unsigned k = 0; k < node.getNumPorts(); ++k) {
@@ -877,7 +877,7 @@
 
   bool allocModels()
   {
-    ModelInstanceList::const_iterator i;
+    OpenFDM::ModelInstanceList::const_iterator i;
     for (i = _modelInstanceList.begin(); i != _modelInstanceList.end(); ++i) {
       if (!(*i)->getNodeContext().alloc()) {
         Log(Schedule, Error) << "Could not alloc for model \""
@@ -886,7 +886,7 @@
       }
     }
 
-    MechanicInstanceList::const_iterator j;
+    OpenFDM::MechanicInstanceList::const_iterator j;
     for (j = _rootJointInstanceList.begin();
          j != _rootJointInstanceList.end(); ++j) {
       if (!(*j)->getNodeContext().alloc()) {
@@ -966,7 +966,7 @@
 
   // Have something to run in our hands.
   // Not get the information required to reflect the system to the user.
-  NodeInstanceList::iterator i;
+  OpenFDM::NodeInstanceList::iterator i;
   for (i = nodeInstanceCollector._nodeInstanceList.begin();
        i != nodeInstanceCollector._nodeInstanceList.end(); ++i) {
     mNodeInstanceMap[(*i)->getNodePath()] = *i;



From frohlich at mail.berlios.de  Sun Nov  9 11:56:32 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 9 Nov 2008 11:56:32 +0100
Subject: [OpenFDM-svn] r691 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811091056.mA9AuW3u021003@sheep.berlios.de>

Author: frohlich
Date: 2008-11-09 11:56:31 +0100 (Sun, 09 Nov 2008)
New Revision: 691

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
Log:
More namespace qualifiers.

M    src/OpenFDM/System.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-09 10:49:44 UTC (rev 690)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-09 10:56:31 UTC (rev 691)
@@ -450,7 +450,7 @@
   {
     // Need to stor the root nodes to build up the spanning tree for the
     // mechanical system here.
-    OpenFDM::MechanicInstance* mechanicInstance = new MechanicInstance(getNodePath(), mSampleTime, &node);
+    OpenFDM::MechanicInstance* mechanicInstance = new OpenFDM::MechanicInstance(getNodePath(), mSampleTime, &node);
     _nodeInstanceList.push_back(mechanicInstance);
     if (node.getNumPorts() == 1)
       _rootJointInstanceList.push_back(mechanicInstance);
@@ -460,14 +460,14 @@
   }
   virtual void apply(const Interact& node)
   {
-    OpenFDM::MechanicInstance* mechanicInstance = new MechanicInstance(getNodePath(), mSampleTime, &node);
+    OpenFDM::MechanicInstance* mechanicInstance = new OpenFDM::MechanicInstance(getNodePath(), mSampleTime, &node);
     _nodeInstanceList.push_back(mechanicInstance);
     _interactInstanceList.push_back(mechanicInstance);
     allocPortData(mechanicInstance, node);
   }
   virtual void apply(const RigidBody& node)
   {
-    OpenFDM::MechanicInstance* mechanicInstance = new MechanicInstance(getNodePath(), mSampleTime, &node);
+    OpenFDM::MechanicInstance* mechanicInstance = new OpenFDM::MechanicInstance(getNodePath(), mSampleTime, &node);
     _nodeInstanceList.push_back(mechanicInstance);
     allocPortData(mechanicInstance, node);
     // Make all rigid mechanic body links use the same link value
@@ -485,7 +485,7 @@
   }
   virtual void apply(const Joint& node)
   {
-    MechanicInstance* mechanicInstance = new MechanicInstance(getNodePath(), mSampleTime, &node);
+    OpenFDM::MechanicInstance* mechanicInstance = new OpenFDM::MechanicInstance(getNodePath(), mSampleTime, &node);
     _nodeInstanceList.push_back(mechanicInstance);
     _jointInstanceList.push_back(mechanicInstance);
     allocPortData(mechanicInstance, node);



From frohlich at mail.berlios.de  Sun Nov  9 13:18:29 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 9 Nov 2008 13:18:29 +0100
Subject: [OpenFDM-svn] r692 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811091218.mA9CITt0017812@sheep.berlios.de>

Author: frohlich
Date: 2008-11-09 13:18:28 +0100 (Sun, 09 Nov 2008)
New Revision: 692

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/PortInfo.h
Log:
Add a FIXME ... :-/

M    PortInfo.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/PortInfo.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/PortInfo.h	2008-11-09 10:56:31 UTC (rev 691)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/PortInfo.h	2008-11-09 12:18:28 UTC (rev 692)
@@ -193,7 +193,8 @@
 
 class MechanicLinkInfo : public PortInfo {
 public:
-  MechanicLinkInfo(Node* node, const std::string& name) :
+  // FIXME: mechanic links are special. Just allow them in MechanicNodes ...
+  MechanicLinkInfo(/*Mechanic*/Node* node, const std::string& name) :
     PortInfo(node, name)
   { }
   virtual ~MechanicLinkInfo()



From frohlich at mail.berlios.de  Sun Nov  9 15:43:41 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 9 Nov 2008 15:43:41 +0100
Subject: [OpenFDM-svn] r693 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811091443.mA9EhfTB031387@sheep.berlios.de>

Author: frohlich
Date: 2008-11-09 15:43:40 +0100 (Sun, 09 Nov 2008)
New Revision: 693

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
Log:
Use CollectorVisitor internal data structures for port distribution.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-09 12:18:28 UTC (rev 692)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-09 14:43:40 UTC (rev 693)
@@ -238,33 +238,35 @@
     mBasicSampleTime(SampleTime::getContinous())
   { }
 
-  struct _PortData;
+  struct Instance;
+  struct PortData;
 
-  struct _PortConnectSet : public Referenced {
+  struct PortConnectSet : public Referenced {
     bool setPortValue(PortValue* portValue)
     {
       while (!mParentPortData.empty()) {
-        SharedPtr<_PortData> portData = mParentPortData.back().lock();
+        SharedPtr<PortData> portData = mParentPortData.back().lock();
         mParentPortData.pop_back();
         if (!portData->setPortValue(portValue))
           return false;
       }
       return true;
     }
-    std::vector<WeakPtr<_PortData> > mParentPortData;
+    std::vector<WeakPtr<PortData> > mParentPortData;
   };
 
-  struct _PortData : public WeakReferenced {
+  struct PortData : public WeakReferenced {
   public:
-    _PortData(AbstractNodeInstance* nodeInstance, const PortInfo* portInfo) :
-      mNodeInstance(nodeInstance),
-      mPortValueCreator(true),
-      mPortInfo(portInfo)
+    PortData(Instance* instance, const PortInfo* portInfo,
+             bool valueCreator = true) :
+      mInstance(instance),
+      mPortInfo(portInfo),
+      mPortValueCreator(valueCreator)
     {
       getOrCreatePortConnectSet();
     }
 
-    void setPortConnectSet(_PortConnectSet* portSet)
+    void setPortConnectSet(PortConnectSet* portSet)
     {
       OpenFDMAssert(portSet);
       if (portSet == mPortConnectSet)
@@ -276,7 +278,7 @@
       }
       // Merge the port sets together ...
       while (!mPortConnectSet->mParentPortData.empty()) {
-        SharedPtr<_PortData> portData = mPortConnectSet->mParentPortData.back().lock();
+        SharedPtr<PortData> portData = mPortConnectSet->mParentPortData.back().lock();
         mPortConnectSet->mParentPortData.pop_back();
         if (portData == this)
           continue;
@@ -287,15 +289,15 @@
       mPortConnectSet->mParentPortData.push_back(this);
     }
 
-    _PortConnectSet* getOrCreatePortConnectSet()
+    PortConnectSet* getOrCreatePortConnectSet()
     {
       if (mPortConnectSet)
         return mPortConnectSet;
-      setPortConnectSet(new _PortConnectSet);
+      setPortConnectSet(new PortConnectSet);
       return mPortConnectSet;
     }
 
-    bool addPortData(_PortData* portData)
+    bool addPortData(PortData* portData)
     {
       if (getPortInfo()->getMaxConnects() <= mConnectedPorts.size())
         return false;
@@ -304,7 +306,7 @@
       return true;
     }
 
-    bool connect(_PortData* portData)
+    bool connect(PortData* portData)
     {
       if (getPortInfo()->getMaxConnects() <= mConnectedPorts.size())
         return false;
@@ -322,7 +324,7 @@
     {
       if (!getPortInfo())
         return false;
-      if (!mNodeInstance)
+      if (!mInstance)
         return false;
       Log(Schedule, Debug3)
         << "setPortValue for port \"" << getPortInfo()->getName()
@@ -330,7 +332,7 @@
       // FIXME: move the set port value and accept port value into one call
       if (!getPortInfo()->acceptPortValue(portValue))
         return false;
-      mNodeInstance->setPortValue(*getPortInfo(), portValue);
+      mInstance->setPortValue(*getPortInfo(), portValue);
       return true;
     }
 
@@ -339,7 +341,7 @@
       mPortValueCreator = false;
     }
 
-    void setProxyPortData(_PortData* proxyPortData)
+    void setProxyPortData(PortData* proxyPortData)
     {
       mPortValueCreator = false;
       setPortConnectSet(proxyPortData->getOrCreatePortConnectSet());
@@ -349,7 +351,8 @@
     {
       if (!mPortValueCreator)
         return true;
-      if (mNodeInstance->getPortValue(*getPortInfo()))
+      // FIXME
+      if (mInstance->getPortValue(*getPortInfo()))
         return true;
       SharedPtr<PortValue> portValue = getPortInfo()->newValue();
       if (!portValue)
@@ -360,40 +363,57 @@
     }
 
   private:
+    SharedPtr<Instance> mInstance;
+    SharedPtr<const PortInfo> mPortInfo;
+    std::vector<WeakPtr<PortData> > mConnectedPorts;
+    SharedPtr<PortConnectSet> mPortConnectSet;
     bool mPortValueCreator;
-    SharedPtr<AbstractNodeInstance> mNodeInstance;
-    SharedPtr<const PortInfo> mPortInfo;
-    std::vector<WeakPtr<_PortData> > mConnectedPorts;
-    SharedPtr<_PortConnectSet> mPortConnectSet;
   };
 
-  // Return true if this leaf directly depends on one of leafInstance outputs
-  class _PortDataList : public Referenced {
-  public:
-    void setNodeInstance(AbstractNodeInstance* nodeInstance)
+  struct Instance : public WeakReferenced {
+    Instance(const Node& node, const NodePath& nodePath,
+             const SampleTime& sampleTime) :
+      mNodePath(nodePath),
+      mSampleTime(sampleTime)
     {
-      OpenFDMAssert(!mNodeInstance);
-      mNodeInstance = nodeInstance;
-      unsigned numPorts = nodeInstance->getNode().getNumPorts();
-      mPortDataVector.resize(numPorts);
+      unsigned numPorts = node.getNumPorts();
+      mPortDataVector.reserve(numPorts);
       for (unsigned i = 0; i < numPorts; ++i)
-        mPortDataVector[i] = new _PortData(nodeInstance, nodeInstance->getNode().getPort(i));
+        mPortDataVector.push_back(new PortData(this, node.getPort(i)));
     }
-    
-    _PortData* getPortData(const PortInfo& portInfo)
-    { return mPortDataVector[portInfo.getIndex()]; }
-    
-    bool allocAndConnectProviderPortValues()
+    virtual ~Instance()
+    { }
+    virtual const Node* getNode() = 0;
+
+    PortData* getPortData(unsigned i)
     {
+      // Internal used function, just cry if this does not hold
+      OpenFDMAssert(i < mPortDataVector.size());
+      return mPortDataVector[i];
+    }
+
+    void setPortValue(const PortInfo& portInfo, PortValue* portValue)
+    {
+      mAbstractNodeInstance->setPortValue(portInfo, portValue);
+    }
+    const PortValue* getPortValue(const PortInfo& portInfo)
+    {
+      return mAbstractNodeInstance->getPortValue(portInfo);
+    }
+
+    bool allocPortValues()
+    {
       for (unsigned i = 0; i < mPortDataVector.size(); ++i) {
         Log(Schedule, Debug3) << "Try to to allocate port value \""
-                               << mPortDataVector[i]->getPortInfo()->getName()
-                               << "\" of \"" << mNodeInstance->getNodeNamePath()
-                               << "\"" << endl;
+                              << mPortDataVector[i]->getPortInfo()->getName()
+                              << "\" of \""
+                              << mAbstractNodeInstance->getNodeNamePath()
+                              << "\"" << endl;
         if (!mPortDataVector[i]->createPortValue()) {
           Log(Schedule, Error) << "Failed to allocate port value \""
                                << mPortDataVector[i]->getPortInfo()->getName()
-                               << "\" of \"" << mNodeInstance->getNodeNamePath()
+                               << "\" of \""
+                               << mAbstractNodeInstance->getNodeNamePath()
                                << "\".\nAborting!" << endl;
 
           return false;
@@ -402,15 +422,78 @@
       return true;
     }
 
-    /// The vector of per port connect information
-    typedef std::vector<SharedPtr<_PortData> > PortDataVector;
+    const NodePath mNodePath;
+    const SampleTime mSampleTime;
+
+    typedef std::vector<SharedPtr<PortData> > PortDataVector;
     PortDataVector mPortDataVector;
-    
-    /// The AbstractNodeInstance having some way to reference the
-    /// PortValues to the current connect information.
-    SharedPtr<AbstractNodeInstance> mNodeInstance;
+
+    /// FIXME, just in this intermediate step
+    SharedPtr<AbstractNodeInstance> mAbstractNodeInstance;
   };
 
+  struct NodeInstance : public Instance {
+    NodeInstance(const Node& node, const NodePath& nodePath,
+                  const SampleTime& sampleTime) :
+      Instance(node, nodePath, sampleTime),
+      mNode(&node)
+    { }
+    virtual const Node* getNode() { return mNode; }
+    SharedPtr<const Node> mNode;
+  };
+  struct ModelInstance : public Instance {
+    ModelInstance(const Model& model, const NodePath& nodePath,
+                  const SampleTime& sampleTime) :
+      Instance(model, nodePath, sampleTime),
+      mModel(&model)
+    { }
+    virtual const Model* getNode() { return mModel; }
+    SharedPtr<const Model> mModel;
+  };
+  struct MechanicInstance : public Instance {
+    MechanicInstance(const MechanicNode& mechanicNode, const NodePath& nodePath,
+                     const SampleTime& sampleTime) :
+      Instance(mechanicNode, nodePath, sampleTime)
+    { }
+    virtual const MechanicNode* getNode() = 0;
+  };
+  // FIXME may be root joints are joints with only one link???
+  struct RootJointInstance : public MechanicInstance {
+    RootJointInstance(const RootJoint& rootJoint, const NodePath& nodePath,
+                      const SampleTime& sampleTime) :
+      MechanicInstance(rootJoint, nodePath, sampleTime),
+      mRootJoint(&rootJoint)
+    { }
+    virtual const RootJoint* getNode() { return mRootJoint; }
+    SharedPtr<const RootJoint> mRootJoint;
+  };
+  struct JointInstance : public MechanicInstance {
+    JointInstance(const Joint& joint, const NodePath& nodePath,
+                  const SampleTime& sampleTime) :
+      MechanicInstance(joint, nodePath, sampleTime),
+      mJoint(&joint)
+    { }
+    virtual const Joint* getNode() { return mJoint; }
+    SharedPtr<const Joint> mJoint;
+  };
+  struct InteractInstance : public MechanicInstance {
+    InteractInstance(const Interact& interact, const NodePath& nodePath,
+                     const SampleTime& sampleTime) :
+      MechanicInstance(interact, nodePath, sampleTime),
+      mInteract(&interact)
+    { }
+    virtual const Interact* getNode() { return mInteract; }
+    SharedPtr<const Interact> mInteract;
+  };
+
+  void addInstance(Instance* instance)
+  {
+    // Add the instance to the per System instance map
+    mInstanceMap[getNodePath()] = instance;
+    // Add the instance to the current groups instance list
+    mInstanceVector.push_back(instance);
+  }
+
   virtual void apply(const Node& node)
   { Log(Schedule, Error) << __PRETTY_FUNCTION__ << std::endl; }
   virtual void apply(const MechanicNode& node)
@@ -420,93 +503,122 @@
   virtual void apply(const LibraryNode& libraryNode)
   { Log(Schedule, Error) << __PRETTY_FUNCTION__ << std::endl; }
 
-  _PortDataList* buildNodeContext(const Node& node)
+  virtual void apply(const GroupInterfaceNode& node)
   {
+    SharedPtr<NodeInstance> instance;
+    instance = new NodeInstance(node, getNodePath(), mSampleTime);
+    addInstance(instance);
+
     OpenFDM::NodeInstance* nodeInstance;
     nodeInstance = new OpenFDM::NodeInstance(getNodePath(), mSampleTime, &node);
     _nodeInstanceList.push_back(nodeInstance);
-    _PortDataList* portDataList;
-    portDataList = getCurrentNodePortDataList();
-    portDataList->setNodeInstance(nodeInstance);
-    return portDataList;
-  }
+    instance->mAbstractNodeInstance = nodeInstance;
 
-  virtual void apply(const GroupInterfaceNode& leaf)
-  {
-    _PortDataList* portDataList = buildNodeContext(leaf);
-    OpenFDMAssert(leaf.getPort(0));
-    _PortData* portData = portDataList->getPortData(*leaf.getPort(0));
-    _groupPortDataMap[leaf.getExternalPortIndex()] = portData;
+    OpenFDMAssert(node.getPort(0));
+    PortData* portData = instance->getPortData(0);
+    OpenFDMAssert(portData);
+    portData->disablePortValueCreation();
+    mGroupInterfacePortDataMap[node.getExternalPortIndex()] = portData;
   }
 
-  void allocPortData(AbstractNodeInstance* nodeInstance, const LeafNode& leaf)
-  {
-    _PortDataList* portDataList;
-    portDataList = getCurrentNodePortDataList();
-    portDataList->setNodeInstance(nodeInstance);
-  }
-
   virtual void apply(const RootJoint& node)
   {
-    // Need to stor the root nodes to build up the spanning tree for the
+    // Need to store the root nodes to build up the spanning tree for the
     // mechanical system here.
+    SharedPtr<RootJointInstance> instance;
+    instance = new RootJointInstance(node, getNodePath(), mSampleTime);
+    addInstance(instance);
+    mRootJointInstanceList.push_back(instance);
+
     OpenFDM::MechanicInstance* mechanicInstance = new OpenFDM::MechanicInstance(getNodePath(), mSampleTime, &node);
     _nodeInstanceList.push_back(mechanicInstance);
+    instance->mAbstractNodeInstance = mechanicInstance;
     if (node.getNumPorts() == 1)
       _rootJointInstanceList.push_back(mechanicInstance);
     else
       _jointInstanceList.push_back(mechanicInstance);
-    allocPortData(mechanicInstance, node);
   }
   virtual void apply(const Interact& node)
   {
+    SharedPtr<InteractInstance> instance;
+    instance = new InteractInstance(node, getNodePath(), mSampleTime);
+    addInstance(instance);
+    mInteractInstanceList.push_back(instance);
+
     OpenFDM::MechanicInstance* mechanicInstance = new OpenFDM::MechanicInstance(getNodePath(), mSampleTime, &node);
     _nodeInstanceList.push_back(mechanicInstance);
+    instance->mAbstractNodeInstance = mechanicInstance;
     _interactInstanceList.push_back(mechanicInstance);
-    allocPortData(mechanicInstance, node);
   }
   virtual void apply(const RigidBody& node)
   {
+    SharedPtr<NodeInstance> instance;
+    instance = new NodeInstance(node, getNodePath(), mSampleTime);
+    addInstance(instance);
+
     OpenFDM::MechanicInstance* mechanicInstance = new OpenFDM::MechanicInstance(getNodePath(), mSampleTime, &node);
     _nodeInstanceList.push_back(mechanicInstance);
-    allocPortData(mechanicInstance, node);
+    instance->mAbstractNodeInstance = mechanicInstance;
     // Make all rigid mechanic body links use the same link value
-    _PortData* portData = 0;
+    // FIXME, allocate them in this way!
+    PortData* portData = 0;
     for (unsigned i = 0; i < node.getNumPorts(); ++i) {
       if (!node.getPort(i)->toMechanicLinkInfo())
         continue;
       if (portData) {
-        mCurrentNodePortDataList->mPortDataVector[i]->setProxyPortData(portData);
+        instance->getPortData(i)->setProxyPortData(portData);
+        instance->getPortData(i)->disablePortValueCreation();
       } else {
-        portData = mCurrentNodePortDataList->mPortDataVector[i];
+        portData = instance->getPortData(i);
         portData->disablePortValueCreation();
       }
     }
   }
   virtual void apply(const Joint& node)
   {
+    SharedPtr<JointInstance> instance;
+    instance = new JointInstance(node, getNodePath(), mSampleTime);
+    addInstance(instance);
+    mJointInstanceList.push_back(instance);
+
     OpenFDM::MechanicInstance* mechanicInstance = new OpenFDM::MechanicInstance(getNodePath(), mSampleTime, &node);
     _nodeInstanceList.push_back(mechanicInstance);
+    instance->mAbstractNodeInstance = mechanicInstance;
     _jointInstanceList.push_back(mechanicInstance);
-    allocPortData(mechanicInstance, node);
   }
   virtual void apply(const Model& node)
   {
+    SharedPtr<ModelInstance> instance;
+    instance = new ModelInstance(node, getNodePath(), mSampleTime);
+    addInstance(instance);
+    mModelInstanceList.push_back(instance);
+
     OpenFDM::ModelInstance* modelInstance = new OpenFDM::ModelInstance(getNodePath(), mSampleTime, &node);
     _nodeInstanceList.push_back(modelInstance);
+    instance->mAbstractNodeInstance = modelInstance;
     _modelInstanceList.push_back(modelInstance);
-    allocPortData(modelInstance, node);
   }
 
   virtual void apply(const Group& group)
   {
-    // Prepare a new leaf map for the child group
-    _PortDataMap parentPortDataMap(group.getNumChildren());
-    parentPortDataMap.swap(_portDataMap);
+    SharedPtr<NodeInstance> instance;
+    instance = new NodeInstance(group, getNodePath(), mSampleTime);
+    addInstance(instance);
 
+    OpenFDM::NodeInstance* nodeInstance;
+    nodeInstance = new OpenFDM::NodeInstance(getNodePath(), mSampleTime, &group);
+    _nodeInstanceList.push_back(nodeInstance);
+    instance->mAbstractNodeInstance = nodeInstance;
+
+    // The vector of instances for this group.
+    InstanceVector parentInstanceVector;
+    parentInstanceVector.swap(mInstanceVector);
+    mInstanceVector.reserve(group.getNumChildren());
+
     // Get PortDataList indexed by group port index
-    _ExternalGroupPortDataMap parentGroupPortDataMap(group.getNumPorts());
-    parentGroupPortDataMap.swap(_groupPortDataMap);
+    GroupInterfacePortDataMap parentGroupInterfacePortDataMap;
+    mGroupInterfacePortDataMap.swap(parentGroupInterfacePortDataMap);
+    mGroupInterfacePortDataMap.resize(group.getNumPorts());
 
     // End pushing external connection data
 
@@ -533,20 +645,9 @@
         }
       }
 
-      // Push the right per node port information struct
-      SharedPtr<_PortDataList> parentNodePortDataList;
-      parentNodePortDataList.swap(mCurrentNodePortDataList);
-
-      mCurrentNodePortDataList = new _PortDataList;
-      _portDataMap[i] = mCurrentNodePortDataList;
-      _portDataListList.push_back(mCurrentNodePortDataList);
-
       // now traverse the child ...
       node->accept(*this);
 
-      // Pop the per node port information struct
-      parentNodePortDataList.swap(mCurrentNodePortDataList);
-
       // restore old group sample time
       mSampleTime = sampleTime;
     }
@@ -582,18 +683,17 @@
 
       unsigned portInfoIndex0 = portInfo0->getIndex();
       unsigned portInfoIndex1 = portInfo1->getIndex();
-      if (!_portDataMap[nodeIndex1]->mPortDataVector[portInfoIndex1]->
-          connect(_portDataMap[nodeIndex0]->mPortDataVector[portInfoIndex0]))
+      if (!mInstanceVector[nodeIndex1]->getPortData(portInfoIndex1)->
+          connect(mInstanceVector[nodeIndex0]->getPortData(portInfoIndex0)))
         Log(Schedule, Error) << "Internal Error: Cannot connect ports that"
           " appeared to be compatible before." << std::endl;
     }
 
-    SharedPtr<_PortDataList> portDataList = buildNodeContext(group);
-
     // add group connect routings
     // merge child list into the global list of instances
+    OpenFDMAssert(mGroupInterfacePortDataMap.size() == group.getNumPorts());
     for (unsigned i = 0; i < group.getNumPorts(); ++i) {
-      _PortData* portData = _groupPortDataMap[i];
+      PortData* portData = mGroupInterfacePortDataMap[i];
       if (!portData) {
         Log(Schedule, Error) << "Internal Error: Cannot find internal port "
           "data for group external port!" << std::endl;
@@ -601,46 +701,62 @@
       }
 
       // Allocate a new port data struct in the parent.
-      _PortData* parentPortData = portDataList->getPortData(*group.getPort(i));
+      PortData* parentPortData = instance->getPortData(i);
       parentPortData->setProxyPortData(portData);
       portData->setProxyPortData(parentPortData);
+      parentPortData->disablePortValueCreation();
+      portData->disablePortValueCreation();
     }
 
+    // We must have gained exactly this amount of instances while traversing
+    // this group, so make sure it is like that ...
+    OpenFDMAssert(mInstanceVector.size() == group.getNumChildren());
+
     // Pop the per group port connect info
-    parentGroupPortDataMap.swap(_groupPortDataMap);
-    parentPortDataMap.swap(_portDataMap);
+    parentGroupInterfacePortDataMap.swap(mGroupInterfacePortDataMap);
+    parentInstanceVector.swap(mInstanceVector);
   }
 
   ////////////////////////////////////////////////////////////////////////////
+  // All instances in the system indexed by node path.
+  typedef std::map<NodePath, SharedPtr<Instance> > InstanceMap;
+  InstanceMap mInstanceMap;
+
+  ////////////////////////////////////////////////////////////////////////////
   // The final list of Nodes we have in the simulation system
-  OpenFDM::NodeInstanceList _nodeInstanceList;
+  OpenFDM::NodeInstanceList _nodeInstanceList; // mInstanceMap
 
 
+  typedef std::list<SharedPtr<ModelInstance> > ModelInstanceList;
+  typedef std::list<SharedPtr<MechanicInstance> > MechanicInstanceList;
+  typedef std::list<SharedPtr<InteractInstance> > InteractInstanceList;
+  typedef std::list<SharedPtr<JointInstance> > JointInstanceList;
+  typedef std::list<SharedPtr<RootJointInstance> > RootJointInstanceList;
+
   // The Models list, worthwhile for sorting
-  OpenFDM::ModelInstanceList _modelInstanceList;
+  OpenFDM::ModelInstanceList _modelInstanceList; // mModelInstanceList
+  ModelInstanceList mModelInstanceList;
   // The mechanical system list, also for sorting
-  OpenFDM::MechanicInstanceList _mechanicInstanceList;
+  OpenFDM::MechanicInstanceList _mechanicInstanceList; // mMechanicInstanceList
+  MechanicInstanceList mMechanicInstanceList;
 
   // The list of root nodes in the mechanical system. Will be a starting point
   // for sorting the tree of mechanical models downwards
-  OpenFDM::MechanicInstanceList _rootJointInstanceList;
-  OpenFDM::MechanicInstanceList _interactInstanceList;
-  OpenFDM::MechanicInstanceList _jointInstanceList;
+  OpenFDM::MechanicInstanceList _rootJointInstanceList; //mRootJointInstanceList
+  OpenFDM::MechanicInstanceList _interactInstanceList; // mInteractInstanceList
+  OpenFDM::MechanicInstanceList _jointInstanceList; // mJointInstanceList
 
+  RootJointInstanceList mRootJointInstanceList;
+  JointInstanceList mJointInstanceList;
+  InteractInstanceList mInteractInstanceList;
+
   ////////////////////////////////////////////////////////////////////////////
   // Used to map connections in groups ...
-  typedef std::vector<SharedPtr<_PortDataList> > _PortDataMap;
-  _PortDataMap _portDataMap;
+  typedef std::vector<SharedPtr<Instance> > InstanceVector;
+  InstanceVector mInstanceVector;
   // Holds the PortDataList pointer indexed by parent groups port index
-  typedef std::vector<SharedPtr<_PortData> > _ExternalGroupPortDataMap;
-  _ExternalGroupPortDataMap _groupPortDataMap;
-  // Just to hold references to all port data lists we have in the
-  // simulation system. They are just needed during traversal for connect
-  // information and to distribute port value pointers. If this list is not
-  // built up the PortData values are deleted befor the PortValues are
-  // distributed.
-  typedef std::list<SharedPtr<_PortDataList> > _PortDataListList;
-  _PortDataListList _portDataListList;
+  typedef std::vector<SharedPtr<PortData> > GroupInterfacePortDataMap;
+  GroupInterfacePortDataMap mGroupInterfacePortDataMap;
 
   // Current nodes sample time
   SampleTime mSampleTime;
@@ -850,11 +966,12 @@
   allocPortValues()
   {
     // alloc port values
-    _PortDataListList::const_iterator i;
-    for (i = _portDataListList.begin(); i != _portDataListList.end(); ++i) {
-      if (!(*i)->allocAndConnectProviderPortValues())
-        return false;
+    InstanceMap::const_iterator i;
+    for (i = mInstanceMap.begin(); i != mInstanceMap.end(); ++i) {
+      if (!i->second->allocPortValues())
+          return false;
     }
+    
     // check port values and report unconnected mandatory values.
     OpenFDM::NodeInstanceList::const_iterator j;
     for (j = _nodeInstanceList.begin(); j != _nodeInstanceList.end(); ++j) {
@@ -905,17 +1022,6 @@
     }
     return true;
   }
-
-  _PortDataList* getCurrentNodePortDataList()
-  {
-    if (!mCurrentNodePortDataList)
-      // will happen for the toplevel group node ..
-      mCurrentNodePortDataList = new _PortDataList;
-    return mCurrentNodePortDataList;
-  }
-
-private:
-  SharedPtr<_PortDataList> mCurrentNodePortDataList;
 };
 
 BEGIN_OPENFDM_OBJECT_DEF(System, Object)



From frohlich at mail.berlios.de  Sun Nov  9 16:08:37 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 9 Nov 2008 16:08:37 +0100
Subject: [OpenFDM-svn] r694 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811091508.mA9F8beb001783@sheep.berlios.de>

Author: frohlich
Date: 2008-11-09 16:08:36 +0100 (Sun, 09 Nov 2008)
New Revision: 694

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
Log:
Constify const method.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-09 14:43:40 UTC (rev 693)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-09 15:08:36 UTC (rev 694)
@@ -383,7 +383,7 @@
     }
     virtual ~Instance()
     { }
-    virtual const Node* getNode() = 0;
+    virtual const Node* getNode() const = 0;
 
     PortData* getPortData(unsigned i)
     {
@@ -438,7 +438,7 @@
       Instance(node, nodePath, sampleTime),
       mNode(&node)
     { }
-    virtual const Node* getNode() { return mNode; }
+    virtual const Node* getNode() const { return mNode; }
     SharedPtr<const Node> mNode;
   };
   struct ModelInstance : public Instance {
@@ -447,7 +447,7 @@
       Instance(model, nodePath, sampleTime),
       mModel(&model)
     { }
-    virtual const Model* getNode() { return mModel; }
+    virtual const Model* getNode() const { return mModel; }
     SharedPtr<const Model> mModel;
   };
   struct MechanicInstance : public Instance {
@@ -455,7 +455,7 @@
                      const SampleTime& sampleTime) :
       Instance(mechanicNode, nodePath, sampleTime)
     { }
-    virtual const MechanicNode* getNode() = 0;
+    virtual const MechanicNode* getNode() const = 0;
   };
   // FIXME may be root joints are joints with only one link???
   struct RootJointInstance : public MechanicInstance {
@@ -464,7 +464,7 @@
       MechanicInstance(rootJoint, nodePath, sampleTime),
       mRootJoint(&rootJoint)
     { }
-    virtual const RootJoint* getNode() { return mRootJoint; }
+    virtual const RootJoint* getNode() const { return mRootJoint; }
     SharedPtr<const RootJoint> mRootJoint;
   };
   struct JointInstance : public MechanicInstance {
@@ -473,7 +473,7 @@
       MechanicInstance(joint, nodePath, sampleTime),
       mJoint(&joint)
     { }
-    virtual const Joint* getNode() { return mJoint; }
+    virtual const Joint* getNode() const { return mJoint; }
     SharedPtr<const Joint> mJoint;
   };
   struct InteractInstance : public MechanicInstance {
@@ -482,7 +482,7 @@
       MechanicInstance(interact, nodePath, sampleTime),
       mInteract(&interact)
     { }
-    virtual const Interact* getNode() { return mInteract; }
+    virtual const Interact* getNode() const { return mInteract; }
     SharedPtr<const Interact> mInteract;
   };
 



From frohlich at mail.berlios.de  Sun Nov  9 17:20:10 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 9 Nov 2008 17:20:10 +0100
Subject: [OpenFDM-svn] r695 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811091620.mA9GKA48005842@sheep.berlios.de>

Author: frohlich
Date: 2008-11-09 17:20:10 +0100 (Sun, 09 Nov 2008)
New Revision: 695

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Node.h
Log:
Add helper to make strings from NodePaths.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Node.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Node.h	2008-11-09 15:08:36 UTC (rev 694)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Node.h	2008-11-09 16:20:10 UTC (rev 695)
@@ -65,6 +65,21 @@
   /// Hmm, here or in the leaf stuff:
   virtual AbstractNodeContext* newNodeContext() const = 0;
 
+  static std::string toNodePathName(const NodePath& nodePath)
+  {
+    if (nodePath.empty())
+      return std::string();
+    std::string path = nodePath.front()->getName();
+    NodePath::const_iterator i = nodePath.begin();
+    if (i != nodePath.end()) {
+      for (++i; i != nodePath.end(); ++i) {
+        path += '/';
+        path += (*i)->getName();
+      }
+    }
+    return path;
+  }
+
 protected:
 
   friend class Group;



From frohlich at mail.berlios.de  Sun Nov  9 17:20:37 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 9 Nov 2008 17:20:37 +0100
Subject: [OpenFDM-svn] r696 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811091620.mA9GKbvG006037@sheep.berlios.de>

Author: frohlich
Date: 2008-11-09 17:20:37 +0100 (Sun, 09 Nov 2008)
New Revision: 696

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeInstance.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeInstance.h
Log:
Make use of the NodePath string helper.

M    AbstractNodeInstance.h
M    AbstractNodeInstance.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeInstance.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeInstance.cpp	2008-11-09 16:20:10 UTC (rev 695)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeInstance.cpp	2008-11-09 16:20:37 UTC (rev 696)
@@ -23,20 +23,4 @@
 {
 }
 
-std::string
-AbstractNodeInstance::getNodeNamePath() const
-{
-  if (mNodePath.empty())
-    return std::string();
-  std::string path = mNodePath.front()->getName();
-  NodePath::const_iterator i = mNodePath.begin();
-  if (i != mNodePath.end()) {
-    for (++i; i != mNodePath.end(); ++i) {
-      path += '/';
-      path += (*i)->getName();
-    }
-  }
-  return path;
-}
-
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeInstance.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeInstance.h	2008-11-09 16:20:10 UTC (rev 695)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeInstance.h	2008-11-09 16:20:37 UTC (rev 696)
@@ -33,7 +33,8 @@
   const NodePath& getNodePath() const
   { return mNodePath; }
   /// String representation of the node path.
-  std::string getNodeNamePath() const;
+  std::string getNodeNamePath() const
+  { return Node::toNodePathName(mNodePath); }
 
   /// Get the sample time this node will run on
   const SampleTime& getSampleTime() const



From frohlich at mail.berlios.de  Sun Nov  9 17:53:16 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 9 Nov 2008 17:53:16 +0100
Subject: [OpenFDM-svn] r697 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811091653.mA9GrGTU008230@sheep.berlios.de>

Author: frohlich
Date: 2008-11-09 17:53:15 +0100 (Sun, 09 Nov 2008)
New Revision: 697

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicContext.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicContext.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicInstance.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicInstance.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/ModelContext.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/ModelContext.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/ModelInstance.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/ModelInstance.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
Log:
Move model sorting into the instance collector.

M    src/OpenFDM/ModelInstance.h
M    src/OpenFDM/ModelContext.cpp
M    src/OpenFDM/MechanicInstance.h
M    src/OpenFDM/MechanicInstance.cpp
M    src/OpenFDM/ModelInstance.cpp
M    src/OpenFDM/MechanicContext.h
M    src/OpenFDM/MechanicContext.cpp
M    src/OpenFDM/System.cpp
M    src/OpenFDM/ModelContext.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicContext.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicContext.cpp	2008-11-09 16:20:37 UTC (rev 696)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicContext.cpp	2008-11-09 16:53:15 UTC (rev 697)
@@ -10,30 +10,4 @@
 {
 }
 
-bool
-MechanicContext::isConnectedTo(const MechanicContext& mechanicContext) const
-{
-  unsigned numPorts = getNode().getNumPorts();
-  for (unsigned i = 0; i < numPorts; ++i) {
-    SharedPtr<const PortInfo> portInfo = getNode().getPort(i);
-    OpenFDMAssert(portInfo);
-    const PortValue* portValue = getPortValueList().getPortValue(i);
-    if (!portValue)
-      continue;
-    unsigned otherNumPorts = mechanicContext.getNode().getNumPorts();
-    for (unsigned j = 0; j < otherNumPorts; ++j) {
-      if (!mechanicContext.getNode().getPort(j)->toMechanicLinkInfo())
-        continue;
-      
-      const PortValue* otherPortValue;
-      otherPortValue = mechanicContext.getPortValueList().getPortValue(j);
-      if (portValue != otherPortValue)
-        continue;
-      
-      return true;
-    }
-  }
-  return false;
-}
-
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicContext.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicContext.h	2008-11-09 16:20:37 UTC (rev 696)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicContext.h	2008-11-09 16:53:15 UTC (rev 697)
@@ -33,8 +33,6 @@
   virtual void derivative(const Task&) = 0;
   virtual void update(const DiscreteTask& discreteTask) = 0;
 
-  virtual bool isConnectedTo(const MechanicContext& mechanicContext) const;
-
 private:
   MechanicContext(const MechanicContext&);
   MechanicContext& operator=(const MechanicContext&);

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicInstance.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicInstance.cpp	2008-11-09 16:20:37 UTC (rev 696)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicInstance.cpp	2008-11-09 16:53:15 UTC (rev 697)
@@ -18,12 +18,6 @@
 {
 }
 
-bool
-MechanicInstance::isConnectedTo(const MechanicInstance& mechanicInstance) const
-{
-  return mMechanicContext->isConnectedTo(*mechanicInstance.mMechanicContext);
-}
-
 MechanicContext&
 MechanicInstance::getNodeContext()
 {

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicInstance.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicInstance.h	2008-11-09 16:20:37 UTC (rev 696)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicInstance.h	2008-11-09 16:53:15 UTC (rev 697)
@@ -18,8 +18,6 @@
                    const MechanicNode* mechanicNode);
   virtual ~MechanicInstance();
 
-  bool isConnectedTo(const MechanicInstance& mechanicInstance) const;
-
 // protected:
   virtual MechanicContext& getNodeContext();
   virtual const MechanicContext& getNodeContext() const;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/ModelContext.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ModelContext.cpp	2008-11-09 16:20:37 UTC (rev 696)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ModelContext.cpp	2008-11-09 16:53:15 UTC (rev 697)
@@ -23,33 +23,4 @@
   return *mModel;
 }
 
-bool ModelContext::dependsOn(const ModelContext& modelContext) const
-{
-  unsigned numPorts = mModel->getNumPorts();
-  for (unsigned i = 0; i < numPorts; ++i) {
-    const InputPortInfo* inputPortInfo;
-    inputPortInfo = mModel->getPort(i)->toInputPortInfo();
-    if (!inputPortInfo)
-      continue;
-    if (!inputPortInfo->getDirectInput())
-      continue;
-    const PortValue* portValue = getPortValueList().getPortValue(i);
-    if (!portValue)
-      continue;
-    unsigned otherNumPorts = modelContext.mModel->getNumPorts();
-    for (unsigned j = 0; j < otherNumPorts; ++j) {
-      if (!modelContext.mModel->getPort(j)->toOutputPortInfo())
-        continue;
-      
-      const PortValue* otherPortValue;
-      otherPortValue = modelContext.getPortValueList().getPortValue(j);
-      if (portValue != otherPortValue)
-        continue;
-      
-      return true;
-    }
-  }
-  return false;
-}
-
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/ModelContext.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ModelContext.h	2008-11-09 16:20:37 UTC (rev 696)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ModelContext.h	2008-11-09 16:53:15 UTC (rev 697)
@@ -41,9 +41,6 @@
   { mModel->derivative(mDiscreteState, mContinousState, mPortValueList,
                        mContinousStateDerivative); }
 
-  // Return true if this model directly depends on one of models outputs
-  bool dependsOn(const ModelContext& modelContext) const;
-
 private:
   ModelContext();
   ModelContext(const ModelContext&);

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/ModelInstance.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ModelInstance.cpp	2008-11-09 16:20:37 UTC (rev 696)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ModelInstance.cpp	2008-11-09 16:53:15 UTC (rev 697)
@@ -17,12 +17,6 @@
 {
 }
 
-bool
-ModelInstance::dependsOn(const ModelInstance& modelInstance) const
-{
-  return mModelContext->dependsOn(*modelInstance.mModelContext);
-}
-
 ModelContext&
 ModelInstance::getNodeContext()
 {

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/ModelInstance.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ModelInstance.h	2008-11-09 16:20:37 UTC (rev 696)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ModelInstance.h	2008-11-09 16:53:15 UTC (rev 697)
@@ -18,9 +18,6 @@
                 const Model* model);
   virtual ~ModelInstance();
 
-  // Return true if this leaf directly depends on one of leafInstance outputs
-  bool dependsOn(const ModelInstance& modelInstance) const;
-
 // protected:
   /// The node context that belongs to this instance.
   virtual ModelContext& getNodeContext();

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-09 16:20:37 UTC (rev 696)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-09 16:53:15 UTC (rev 697)
@@ -306,6 +306,11 @@
       return true;
     }
 
+    bool isConnected(const PortData& portData) const
+    {
+      return mPortConnectSet && mPortConnectSet == portData.mPortConnectSet;
+    }
+
     bool connect(PortData* portData)
     {
       if (getPortInfo()->getMaxConnects() <= mConnectedPorts.size())
@@ -401,6 +406,41 @@
       return mAbstractNodeInstance->getPortValue(portInfo);
     }
 
+    bool dependsOn(const Instance& instance, bool acceleration = false) const
+    {
+      unsigned numPorts = getNode()->getNumPorts();
+      for (unsigned i = 0; i < numPorts; ++i) {
+        const InputPortInfo* inputPortInfo;
+        inputPortInfo = getNode()->getPort(i)->toInputPortInfo();
+        if (!inputPortInfo)
+          continue;
+        if (!inputPortInfo->getDirectInput())
+          continue;
+        OpenFDMAssert(i < mPortDataVector.size());
+
+        unsigned otherNumPorts = instance.getNode()->getNumPorts();
+        for (unsigned j = 0; j < otherNumPorts; ++j) {
+          const OutputPortInfo* outputPortInfo;
+          outputPortInfo = instance.getNode()->getPort(j)->toOutputPortInfo();
+          if (!outputPortInfo)
+            continue;
+          if (!acceleration && outputPortInfo->getAccelerationOutput())
+            continue;
+
+          OpenFDMAssert(j < instance.mPortDataVector.size());
+          OpenFDMAssert(instance.mPortDataVector[j]);
+          if (!mPortDataVector[i]->isConnected(*instance.mPortDataVector[j]))
+            continue;
+          
+          return true;
+        }
+      }
+      return false;
+    }
+
+    std::string getNodeNamePath() const
+    { return Node::toNodePathName(mNodePath); }
+
     bool allocPortValues()
     {
       for (unsigned i = 0; i < mPortDataVector.size(); ++i) {
@@ -448,6 +488,8 @@
       mModel(&model)
     { }
     virtual const Model* getNode() const { return mModel; }
+
+  private:
     SharedPtr<const Model> mModel;
   };
   struct MechanicInstance : public Instance {
@@ -456,6 +498,31 @@
       Instance(mechanicNode, nodePath, sampleTime)
     { }
     virtual const MechanicNode* getNode() const = 0;
+
+    bool isLinkedTo(const MechanicInstance& instance) const
+    {
+      unsigned numPorts = getNode()->getNumPorts();
+      for (unsigned i = 0; i < numPorts; ++i) {
+        if (!getNode()->getPort(i)->toMechanicLinkInfo())
+          continue;
+        OpenFDMAssert(i < mPortDataVector.size());
+
+        const Node* otherNode = instance.getNode();
+        unsigned otherNumPorts = otherNode->getNumPorts();
+        for (unsigned j = 0; j < otherNumPorts; ++j) {
+          if (!otherNode->getPort(j)->toMechanicLinkInfo())
+            continue;
+
+          OpenFDMAssert(j < instance.mPortDataVector.size());
+          OpenFDMAssert(instance.mPortDataVector[j]);
+          if (!mPortDataVector[i]->isConnected(*instance.mPortDataVector[j]))
+            continue;
+          
+          return true;
+        }
+      }
+      return false;
+    }
   };
   // FIXME may be root joints are joints with only one link???
   struct RootJointInstance : public MechanicInstance {
@@ -465,6 +532,7 @@
       mRootJoint(&rootJoint)
     { }
     virtual const RootJoint* getNode() const { return mRootJoint; }
+  private:
     SharedPtr<const RootJoint> mRootJoint;
   };
   struct JointInstance : public MechanicInstance {
@@ -474,6 +542,7 @@
       mJoint(&joint)
     { }
     virtual const Joint* getNode() const { return mJoint; }
+  private:
     SharedPtr<const Joint> mJoint;
   };
   struct InteractInstance : public MechanicInstance {
@@ -483,6 +552,7 @@
       mInteract(&interact)
     { }
     virtual const Interact* getNode() const { return mInteract; }
+  private:
     SharedPtr<const Interact> mInteract;
   };
 
@@ -533,10 +603,6 @@
     OpenFDM::MechanicInstance* mechanicInstance = new OpenFDM::MechanicInstance(getNodePath(), mSampleTime, &node);
     _nodeInstanceList.push_back(mechanicInstance);
     instance->mAbstractNodeInstance = mechanicInstance;
-    if (node.getNumPorts() == 1)
-      _rootJointInstanceList.push_back(mechanicInstance);
-    else
-      _jointInstanceList.push_back(mechanicInstance);
   }
   virtual void apply(const Interact& node)
   {
@@ -548,7 +614,6 @@
     OpenFDM::MechanicInstance* mechanicInstance = new OpenFDM::MechanicInstance(getNodePath(), mSampleTime, &node);
     _nodeInstanceList.push_back(mechanicInstance);
     instance->mAbstractNodeInstance = mechanicInstance;
-    _interactInstanceList.push_back(mechanicInstance);
   }
   virtual void apply(const RigidBody& node)
   {
@@ -584,7 +649,6 @@
     OpenFDM::MechanicInstance* mechanicInstance = new OpenFDM::MechanicInstance(getNodePath(), mSampleTime, &node);
     _nodeInstanceList.push_back(mechanicInstance);
     instance->mAbstractNodeInstance = mechanicInstance;
-    _jointInstanceList.push_back(mechanicInstance);
   }
   virtual void apply(const Model& node)
   {
@@ -596,7 +660,6 @@
     OpenFDM::ModelInstance* modelInstance = new OpenFDM::ModelInstance(getNodePath(), mSampleTime, &node);
     _nodeInstanceList.push_back(modelInstance);
     instance->mAbstractNodeInstance = modelInstance;
-    _modelInstanceList.push_back(modelInstance);
   }
 
   virtual void apply(const Group& group)
@@ -742,14 +805,10 @@
 
   // The list of root nodes in the mechanical system. Will be a starting point
   // for sorting the tree of mechanical models downwards
-  OpenFDM::MechanicInstanceList _rootJointInstanceList; //mRootJointInstanceList
-  OpenFDM::MechanicInstanceList _interactInstanceList; // mInteractInstanceList
-  OpenFDM::MechanicInstanceList _jointInstanceList; // mJointInstanceList
+  MechanicInstanceList mRootJointInstanceList;
+  MechanicInstanceList mJointInstanceList;
+  MechanicInstanceList mInteractInstanceList;
 
-  RootJointInstanceList mRootJointInstanceList;
-  JointInstanceList mJointInstanceList;
-  InteractInstanceList mInteractInstanceList;
-
   ////////////////////////////////////////////////////////////////////////////
   // Used to map connections in groups ...
   typedef std::vector<SharedPtr<Instance> > InstanceVector;
@@ -816,8 +875,8 @@
   // method to sort the leafs according to their dependency
   bool sortMechanicList()
   {
-    if (_rootJointInstanceList.empty() &&
-        (!_jointInstanceList.empty() || !_interactInstanceList.empty())) {
+    if (mRootJointInstanceList.empty() &&
+        (!mJointInstanceList.empty() || !mInteractInstanceList.empty())) {
       Log(Schedule,Error)
         << "No root joint in System with mechanic components" << std::endl;
       return false;
@@ -825,32 +884,32 @@
 
     // Start with all the roots in front of the list ...
     // FIXME: ensure that there is no loop here?
-    _mechanicInstanceList.swap(_rootJointInstanceList);
+    mMechanicInstanceList.swap(mRootJointInstanceList);
 
     // Not the best algorithm, but for a first cut ...
-    while (!_jointInstanceList.empty()) {
-      OpenFDM::MechanicInstanceList nextLevelList;
+    while (!mJointInstanceList.empty()) {
+      MechanicInstanceList nextLevelList;
 
-      OpenFDM::MechanicInstanceList::iterator j;
-      for (j = _mechanicInstanceList.begin();
-           j != _mechanicInstanceList.end(); ++j) {
-        OpenFDM::MechanicInstanceList::iterator i;
-        for (i = _jointInstanceList.begin();
-             i != _jointInstanceList.end();) {
+      MechanicInstanceList::iterator j;
+      for (j = mMechanicInstanceList.begin();
+           j != mMechanicInstanceList.end(); ++j) {
+        MechanicInstanceList::iterator i;
+        for (i = mJointInstanceList.begin();
+             i != mJointInstanceList.end();) {
         
-          if ((*j)->isConnectedTo(*(*i))) {
-            SharedPtr<OpenFDM::MechanicInstance> mechanicInstance = *i;
+          if ((*j)->isLinkedTo(*(*i))) {
+            SharedPtr<MechanicInstance> mechanicInstance = *i;
             nextLevelList.push_back(mechanicInstance);
-            i = _jointInstanceList.erase(i);
+            i = mJointInstanceList.erase(i);
 
             // Check if this current mechanic node does not reference
             // back into the already sorted models
-            OpenFDM::MechanicInstanceList::const_iterator k;
-            for (k = _mechanicInstanceList.begin();
-                 k != _mechanicInstanceList.end(); ++k) {
+            MechanicInstanceList::const_iterator k;
+            for (k = mMechanicInstanceList.begin();
+                 k != mMechanicInstanceList.end(); ++k) {
               if (*k == *j)
                 continue;
-              if (mechanicInstance->isConnectedTo(*(*k))) {
+              if (mechanicInstance->isLinkedTo(*(*k))) {
                 Log(Schedule,Error)
                   << "Detected closed kinematic loop: MechanicNode \""
                   << mechanicInstance->getNodeNamePath()
@@ -870,9 +929,9 @@
       // if we have a connection in between them, there must be a
       // closed kinematic loop.
       for (j = nextLevelList.begin(); j != nextLevelList.end(); ++j) {
-        OpenFDM::MechanicInstanceList::iterator i = j;
+        MechanicInstanceList::iterator i = j;
         for (++i; i != nextLevelList.end(); ++i) {
-          if ((*j)->isConnectedTo(*(*i))) {
+          if ((*j)->isLinkedTo(*(*i))) {
             Log(Schedule,Error)
               << "Detected closed kinematic loop: MechanicNode \""
               << (*j)->getNodeNamePath()
@@ -885,42 +944,51 @@
       
 
       for (j = nextLevelList.begin(); j != nextLevelList.end(); ++j) {
-        _mechanicInstanceList.push_back(*j);
+        mMechanicInstanceList.push_back(*j);
       }
     }
 
     // Interacts are always computed at the end of the list
-    _mechanicInstanceList.splice(_mechanicInstanceList.end(),
-                                      _interactInstanceList,
-                                      _interactInstanceList.begin(),
-                                      _interactInstanceList.end());
+    mMechanicInstanceList.splice(mMechanicInstanceList.end(),
+                                 mInteractInstanceList,
+                                 mInteractInstanceList.begin(),
+                                 mInteractInstanceList.end());
     
     Log(Schedule,Info) << "MechanicNode Schedule" << std::endl;
-    OpenFDM::MechanicInstanceList::iterator i = _mechanicInstanceList.begin();
-    for (; i != _mechanicInstanceList.end(); ++i) {
+    MechanicInstanceList::iterator i = mMechanicInstanceList.begin();
+    for (; i != mMechanicInstanceList.end(); ++i) {
       Log(Schedule,Info)
         << "  MechanicNode \"" << (*i)->getNodeNamePath() << "\"" << std::endl;
     }
 
+    // FIXME: just for now
+    _mechanicInstanceList.clear();
+    MechanicInstanceList::iterator j;
+    for (j = mMechanicInstanceList.begin(); j != mMechanicInstanceList.end(); ++j) {
+      OpenFDMAssert(dynamic_cast<OpenFDM::MechanicInstance*>((*j)->mAbstractNodeInstance.get()));
+      _mechanicInstanceList.push_back(dynamic_cast<OpenFDM::MechanicInstance*>((*j)->mAbstractNodeInstance.get()));
+    }
+
     return true;
   }
 
   // method to sort the leafs according to their dependency
   bool sortModelList()
   {
-    OpenFDM::ModelInstanceList sortedModelInstanceList;
-    while (!_modelInstanceList.empty()) {
-      SharedPtr<OpenFDM::ModelInstance> modelInstance = _modelInstanceList.front();
-      _modelInstanceList.pop_front();
+    ModelInstanceList sortedModelInstanceList;
+    while (!mModelInstanceList.empty()) {
+      SharedPtr<ModelInstance> modelInstance = mModelInstanceList.front();
+      mModelInstanceList.pop_front();
 
       if (modelInstance->dependsOn(*modelInstance)) {
         Log(Schedule, Error)
           << "Self referencing direct dependency for Model \""
-          << modelInstance->getNodeNamePath() << "\" detected!" << std::endl;
+          << modelInstance->getNodeNamePath()
+          << "\" detected!" << std::endl;
         return false;
       }
 
-      OpenFDM::ModelInstanceList::iterator i;
+      ModelInstanceList::iterator i;
       for (i = sortedModelInstanceList.begin();
            i != sortedModelInstanceList.end();
            ++i) {
@@ -930,9 +998,10 @@
         // Something already sorted in depends on modelInstance,
         // so schedule that new thing just before.
         Log(Schedule, Info)
-          << "Inserting Model \"" << modelInstance->getNodeNamePath()
-          << "\" before Model \"" << (*i)->getNodeNamePath()
-          << "\"" << std::endl;
+          << "Inserting Model \""
+          << modelInstance->getNodeNamePath()
+          << "\" before Model \""
+          << (*i)->getNodeNamePath() << "\"" << std::endl;
         i = sortedModelInstanceList.insert(i, modelInstance);
         break;
       }
@@ -940,7 +1009,8 @@
         // nothing found so far that depends on model instance.
         // So put it at the end.
         Log(Schedule, Info)
-          << "Appending Model \"" << modelInstance->getNodeNamePath()
+          << "Appending Model \""
+          << modelInstance->getNodeNamePath()
           << "\"" << std::endl;
 
         sortedModelInstanceList.push_back(modelInstance);
@@ -952,13 +1022,30 @@
             continue;
           Log(Schedule,Error)
             << "Detected cyclic loop: Model \""
-            << modelInstance->getNodeNamePath() << "\" depends on Model \""
+            << modelInstance->getNodeNamePath()
+            << "\" depends on Model \""
             << (*i)->getNodeNamePath() << "\"" << std::endl;
           return false;
         }
       }
     }
-    _modelInstanceList.swap(sortedModelInstanceList);
+    mModelInstanceList.swap(sortedModelInstanceList);
+
+    Log(Schedule,Info) << "Model Schedule" << std::endl;
+    ModelInstanceList::iterator i = mModelInstanceList.begin();
+    for (; i != mModelInstanceList.end(); ++i) {
+      Log(Schedule,Info)
+        << "  Model \"" << (*i)->getNodeNamePath() << "\"" << std::endl;
+    }
+
+    // FIXME: just for now
+    _modelInstanceList.clear();
+    ModelInstanceList::iterator j;
+    for (j = mModelInstanceList.begin(); j != mModelInstanceList.end(); ++j) {
+      OpenFDMAssert(dynamic_cast<OpenFDM::ModelInstance*>((*j)->mAbstractNodeInstance.get()));
+      _modelInstanceList.push_back(dynamic_cast<OpenFDM::ModelInstance*>((*j)->mAbstractNodeInstance.get()));
+    }
+
     return true;
   }
 
@@ -1004,14 +1091,6 @@
     }
 
     OpenFDM::MechanicInstanceList::const_iterator j;
-    for (j = _rootJointInstanceList.begin();
-         j != _rootJointInstanceList.end(); ++j) {
-      if (!(*j)->getNodeContext().alloc()) {
-        Log(Schedule, Error) << "Could not alloc for MechanicNode \""
-                             << (*j)->getNodeNamePath() << "\"" << endl;
-        return false;
-      }
-    }
     for (j = _mechanicInstanceList.begin();
          j != _mechanicInstanceList.end(); ++j) {
       if (!(*j)->getNodeContext().alloc()) {



From frohlich at mail.berlios.de  Sun Nov  9 18:07:09 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 9 Nov 2008 18:07:09 +0100
Subject: [OpenFDM-svn] r698 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811091707.mA9H79Pw010090@sheep.berlios.de>

Author: frohlich
Date: 2008-11-09 18:07:09 +0100 (Sun, 09 Nov 2008)
New Revision: 698

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
Log:
Now that the model sorting no longer depends on allocated port values, move that past sorting.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-09 16:53:15 UTC (rev 697)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-09 17:07:09 UTC (rev 698)
@@ -829,16 +829,16 @@
   // to simulate the system.
   AbstractSystem* buildSystem()
   {
-    // Allocates and distributes the PortValues, is required for the sort
-    // steps below
-    if (!allocPortValues())
-      return 0;
     // The MechanicNode instances are sorted to match the direct input property
     if (!sortMechanicList())
       return 0;
     // The model instances are sorted to match the direct input property
     if (!sortModelList())
       return 0;
+    // Allocates and distributes the PortValues, is required for the sort
+    // steps below
+    if (!allocPortValues())
+      return 0;
     // Now that they are sorted, allocate the port sizes and with that
     // knowledge the state values.
     if (!allocModels())



From frohlich at mail.berlios.de  Sun Nov  9 18:14:07 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 9 Nov 2008 18:14:07 +0100
Subject: [OpenFDM-svn] r699 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811091714.mA9HE7fM010597@sheep.berlios.de>

Author: frohlich
Date: 2008-11-09 18:14:06 +0100 (Sun, 09 Nov 2008)
New Revision: 699

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
Log:
NodeInstanceCollector::_nodeInstanceList is retired.

M    src/OpenFDM/System.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-09 17:07:09 UTC (rev 698)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-09 17:14:06 UTC (rev 699)
@@ -581,7 +581,6 @@
 
     OpenFDM::NodeInstance* nodeInstance;
     nodeInstance = new OpenFDM::NodeInstance(getNodePath(), mSampleTime, &node);
-    _nodeInstanceList.push_back(nodeInstance);
     instance->mAbstractNodeInstance = nodeInstance;
 
     OpenFDMAssert(node.getPort(0));
@@ -601,7 +600,6 @@
     mRootJointInstanceList.push_back(instance);
 
     OpenFDM::MechanicInstance* mechanicInstance = new OpenFDM::MechanicInstance(getNodePath(), mSampleTime, &node);
-    _nodeInstanceList.push_back(mechanicInstance);
     instance->mAbstractNodeInstance = mechanicInstance;
   }
   virtual void apply(const Interact& node)
@@ -612,7 +610,6 @@
     mInteractInstanceList.push_back(instance);
 
     OpenFDM::MechanicInstance* mechanicInstance = new OpenFDM::MechanicInstance(getNodePath(), mSampleTime, &node);
-    _nodeInstanceList.push_back(mechanicInstance);
     instance->mAbstractNodeInstance = mechanicInstance;
   }
   virtual void apply(const RigidBody& node)
@@ -622,7 +619,6 @@
     addInstance(instance);
 
     OpenFDM::MechanicInstance* mechanicInstance = new OpenFDM::MechanicInstance(getNodePath(), mSampleTime, &node);
-    _nodeInstanceList.push_back(mechanicInstance);
     instance->mAbstractNodeInstance = mechanicInstance;
     // Make all rigid mechanic body links use the same link value
     // FIXME, allocate them in this way!
@@ -647,7 +643,6 @@
     mJointInstanceList.push_back(instance);
 
     OpenFDM::MechanicInstance* mechanicInstance = new OpenFDM::MechanicInstance(getNodePath(), mSampleTime, &node);
-    _nodeInstanceList.push_back(mechanicInstance);
     instance->mAbstractNodeInstance = mechanicInstance;
   }
   virtual void apply(const Model& node)
@@ -658,7 +653,6 @@
     mModelInstanceList.push_back(instance);
 
     OpenFDM::ModelInstance* modelInstance = new OpenFDM::ModelInstance(getNodePath(), mSampleTime, &node);
-    _nodeInstanceList.push_back(modelInstance);
     instance->mAbstractNodeInstance = modelInstance;
   }
 
@@ -670,7 +664,6 @@
 
     OpenFDM::NodeInstance* nodeInstance;
     nodeInstance = new OpenFDM::NodeInstance(getNodePath(), mSampleTime, &group);
-    _nodeInstanceList.push_back(nodeInstance);
     instance->mAbstractNodeInstance = nodeInstance;
 
     // The vector of instances for this group.
@@ -785,11 +778,6 @@
   typedef std::map<NodePath, SharedPtr<Instance> > InstanceMap;
   InstanceMap mInstanceMap;
 
-  ////////////////////////////////////////////////////////////////////////////
-  // The final list of Nodes we have in the simulation system
-  OpenFDM::NodeInstanceList _nodeInstanceList; // mInstanceMap
-
-
   typedef std::list<SharedPtr<ModelInstance> > ModelInstanceList;
   typedef std::list<SharedPtr<MechanicInstance> > MechanicInstanceList;
   typedef std::list<SharedPtr<InteractInstance> > InteractInstanceList;
@@ -1060,17 +1048,16 @@
     }
     
     // check port values and report unconnected mandatory values.
-    OpenFDM::NodeInstanceList::const_iterator j;
-    for (j = _nodeInstanceList.begin(); j != _nodeInstanceList.end(); ++j) {
-      const Node& node = (*j)->getNode();
-      for (unsigned k = 0; k < node.getNumPorts(); ++k) {
-        SharedPtr<const PortInfo> portInfo = node.getPort(k);
+    for (i = mInstanceMap.begin(); i != mInstanceMap.end(); ++i) {
+      const Node* node = i->second->getNode();
+      for (unsigned k = 0; k < node->getNumPorts(); ++k) {
+        SharedPtr<const PortInfo> portInfo = node->getPort(k);
         if (portInfo->getOptional())
           continue;
-        if (!(*j)->getPortValue(*portInfo)) {
+        if (!i->second->getPortValue(*portInfo)) {
           Log(Schedule, Error) << "Mandatory port value for port \""
                                << portInfo->getName() << "\" for model \""
-                               << (*j)->getNodeNamePath()
+                               << i->second->getNodeNamePath()
                                << "\" is not connected!" << endl;
           return false;
         }
@@ -1151,11 +1138,11 @@
 
   // Have something to run in our hands.
   // Not get the information required to reflect the system to the user.
-  OpenFDM::NodeInstanceList::iterator i;
-  for (i = nodeInstanceCollector._nodeInstanceList.begin();
-       i != nodeInstanceCollector._nodeInstanceList.end(); ++i) {
-    mNodeInstanceMap[(*i)->getNodePath()] = *i;
-    mNodeInstanceList.push_back(*i);
+  NodeInstanceCollector::InstanceMap::const_iterator i;
+  for (i = nodeInstanceCollector.mInstanceMap.begin();
+       i != nodeInstanceCollector.mInstanceMap.end(); ++i) {
+    mNodeInstanceMap[i->first] = i->second->mAbstractNodeInstance;
+    mNodeInstanceList.push_back(i->second->mAbstractNodeInstance);
   }
 
   SystemOutputList::const_iterator j;



From frohlich at mail.berlios.de  Sun Nov  9 18:21:40 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 9 Nov 2008 18:21:40 +0100
Subject: [OpenFDM-svn] r700 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811091721.mA9HLeaE011073@sheep.berlios.de>

Author: frohlich
Date: 2008-11-09 18:21:40 +0100 (Sun, 09 Nov 2008)
New Revision: 700

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
Log:
Downgrade two info messages to debug.

M    src/OpenFDM/System.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-09 17:14:06 UTC (rev 699)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-09 17:21:40 UTC (rev 700)
@@ -985,7 +985,7 @@
 
         // Something already sorted in depends on modelInstance,
         // so schedule that new thing just before.
-        Log(Schedule, Info)
+        Log(Schedule, Debug)
           << "Inserting Model \""
           << modelInstance->getNodeNamePath()
           << "\" before Model \""
@@ -996,7 +996,7 @@
       if (i == sortedModelInstanceList.end()) {
         // nothing found so far that depends on model instance.
         // So put it at the end.
-        Log(Schedule, Info)
+        Log(Schedule, Debug)
           << "Appending Model \""
           << modelInstance->getNodeNamePath()
           << "\"" << std::endl;



From frohlich at mail.berlios.de  Sun Nov  9 18:30:30 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 9 Nov 2008 18:30:30 +0100
Subject: [OpenFDM-svn] r701 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811091730.mA9HUUZU012154@sheep.berlios.de>

Author: frohlich
Date: 2008-11-09 18:30:29 +0100 (Sun, 09 Nov 2008)
New Revision: 701

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
Log:
Delay allocation even further.

M    src/OpenFDM/System.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-09 17:21:40 UTC (rev 700)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-09 17:30:29 UTC (rev 701)
@@ -949,14 +949,6 @@
         << "  MechanicNode \"" << (*i)->getNodeNamePath() << "\"" << std::endl;
     }
 
-    // FIXME: just for now
-    _mechanicInstanceList.clear();
-    MechanicInstanceList::iterator j;
-    for (j = mMechanicInstanceList.begin(); j != mMechanicInstanceList.end(); ++j) {
-      OpenFDMAssert(dynamic_cast<OpenFDM::MechanicInstance*>((*j)->mAbstractNodeInstance.get()));
-      _mechanicInstanceList.push_back(dynamic_cast<OpenFDM::MechanicInstance*>((*j)->mAbstractNodeInstance.get()));
-    }
-
     return true;
   }
 
@@ -1026,14 +1018,6 @@
         << "  Model \"" << (*i)->getNodeNamePath() << "\"" << std::endl;
     }
 
-    // FIXME: just for now
-    _modelInstanceList.clear();
-    ModelInstanceList::iterator j;
-    for (j = mModelInstanceList.begin(); j != mModelInstanceList.end(); ++j) {
-      OpenFDMAssert(dynamic_cast<OpenFDM::ModelInstance*>((*j)->mAbstractNodeInstance.get()));
-      _modelInstanceList.push_back(dynamic_cast<OpenFDM::ModelInstance*>((*j)->mAbstractNodeInstance.get()));
-    }
-
     return true;
   }
 
@@ -1068,19 +1052,28 @@
 
   bool allocModels()
   {
-    OpenFDM::ModelInstanceList::const_iterator i;
-    for (i = _modelInstanceList.begin(); i != _modelInstanceList.end(); ++i) {
-      if (!(*i)->getNodeContext().alloc()) {
+    // FIXME: just for now
+    ModelInstanceList::iterator i;
+    for (i = mModelInstanceList.begin(); i != mModelInstanceList.end(); ++i) {
+      OpenFDM::ModelInstance* instance = 
+       dynamic_cast<OpenFDM::ModelInstance*>((*i)->mAbstractNodeInstance.get());
+      OpenFDMAssert(instance);
+      _modelInstanceList.push_back(instance);
+      if (!instance->getNodeContext().alloc()) {
         Log(Schedule, Error) << "Could not alloc for model \""
                              << (*i)->getNodeNamePath() << "\"" << endl;
         return false;
       }
     }
 
-    OpenFDM::MechanicInstanceList::const_iterator j;
-    for (j = _mechanicInstanceList.begin();
-         j != _mechanicInstanceList.end(); ++j) {
-      if (!(*j)->getNodeContext().alloc()) {
+    MechanicInstanceList::iterator j;
+    for (j = mMechanicInstanceList.begin();
+         j != mMechanicInstanceList.end(); ++j) {
+      OpenFDM::MechanicInstance* instance = 
+       dynamic_cast<OpenFDM::MechanicInstance*>((*j)->mAbstractNodeInstance.get());
+      OpenFDMAssert(instance);
+      _mechanicInstanceList.push_back(instance);
+      if (!instance->getNodeContext().alloc()) {
         Log(Schedule, Error) << "Could not alloc for MechanicNode \""
                              << (*j)->getNodeNamePath() << "\"" << endl;
         return false;



From frohlich at mail.berlios.de  Sun Nov  9 18:35:03 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 9 Nov 2008 18:35:03 +0100
Subject: [OpenFDM-svn] r702 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811091735.mA9HZ3tS017819@sheep.berlios.de>

Author: frohlich
Date: 2008-11-09 18:35:02 +0100 (Sun, 09 Nov 2008)
New Revision: 702

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
Log:
More privacy 

M    src/OpenFDM/System.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-09 17:30:29 UTC (rev 701)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-09 17:35:02 UTC (rev 702)
@@ -479,6 +479,7 @@
       mNode(&node)
     { }
     virtual const Node* getNode() const { return mNode; }
+  private:
     SharedPtr<const Node> mNode;
   };
   struct ModelInstance : public Instance {
@@ -488,7 +489,6 @@
       mModel(&model)
     { }
     virtual const Model* getNode() const { return mModel; }
-
   private:
     SharedPtr<const Model> mModel;
   };



From frohlich at mail.berlios.de  Sun Nov  9 18:49:03 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 9 Nov 2008 18:49:03 +0100
Subject: [OpenFDM-svn] r703 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811091749.mA9Hn33S032097@sheep.berlios.de>

Author: frohlich
Date: 2008-11-09 18:49:02 +0100 (Sun, 09 Nov 2008)
New Revision: 703

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
Log:
Ok, The RootJointinstance was a bad idea :)

M    src/OpenFDM/System.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-09 17:35:02 UTC (rev 702)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-09 17:49:02 UTC (rev 703)
@@ -524,17 +524,6 @@
       return false;
     }
   };
-  // FIXME may be root joints are joints with only one link???
-  struct RootJointInstance : public MechanicInstance {
-    RootJointInstance(const RootJoint& rootJoint, const NodePath& nodePath,
-                      const SampleTime& sampleTime) :
-      MechanicInstance(rootJoint, nodePath, sampleTime),
-      mRootJoint(&rootJoint)
-    { }
-    virtual const RootJoint* getNode() const { return mRootJoint; }
-  private:
-    SharedPtr<const RootJoint> mRootJoint;
-  };
   struct JointInstance : public MechanicInstance {
     JointInstance(const Joint& joint, const NodePath& nodePath,
                   const SampleTime& sampleTime) :
@@ -594,8 +583,8 @@
   {
     // Need to store the root nodes to build up the spanning tree for the
     // mechanical system here.
-    SharedPtr<RootJointInstance> instance;
-    instance = new RootJointInstance(node, getNodePath(), mSampleTime);
+    SharedPtr<JointInstance> instance;
+    instance = new JointInstance(node, getNodePath(), mSampleTime);
     addInstance(instance);
     mRootJointInstanceList.push_back(instance);
 
@@ -782,7 +771,6 @@
   typedef std::list<SharedPtr<MechanicInstance> > MechanicInstanceList;
   typedef std::list<SharedPtr<InteractInstance> > InteractInstanceList;
   typedef std::list<SharedPtr<JointInstance> > JointInstanceList;
-  typedef std::list<SharedPtr<RootJointInstance> > RootJointInstanceList;
 
   // The Models list, worthwhile for sorting
   OpenFDM::ModelInstanceList _modelInstanceList; // mModelInstanceList



From frohlich at mail.berlios.de  Sun Nov  9 21:52:40 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 9 Nov 2008 21:52:40 +0100
Subject: [OpenFDM-svn] r704 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811092052.mA9KqeWw020153@sheep.berlios.de>

Author: frohlich
Date: 2008-11-09 21:52:40 +0100 (Sun, 09 Nov 2008)
New Revision: 704

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicInstance.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicInstance.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/ModelInstance.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/ModelInstance.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
Log:
Reorder allocation methods.

M    src/OpenFDM/ModelInstance.h
M    src/OpenFDM/MechanicInstance.h
M    src/OpenFDM/MechanicInstance.cpp
M    src/OpenFDM/ModelInstance.cpp
M    src/OpenFDM/System.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicInstance.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicInstance.cpp	2008-11-09 17:49:02 UTC (rev 703)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicInstance.cpp	2008-11-09 20:52:40 UTC (rev 704)
@@ -8,9 +8,10 @@
 
 MechanicInstance::MechanicInstance(const NodePath& nodePath,
                                    const SampleTime& sampleTime,
-                                   const MechanicNode* mechanicNode) :
+                                   const MechanicNode* mechanicNode,
+                                   MechanicContext* mechanicContext) :
   AbstractNodeInstance(nodePath, sampleTime),
-  mMechanicContext(mechanicNode->newMechanicContext())
+  mMechanicContext(mechanicContext)
 {
 }
 

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicInstance.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicInstance.h	2008-11-09 17:49:02 UTC (rev 703)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicInstance.h	2008-11-09 20:52:40 UTC (rev 704)
@@ -15,10 +15,11 @@
 class MechanicInstance : public AbstractNodeInstance {
 public:
   MechanicInstance(const NodePath& nodePath, const SampleTime& sampleTime,
-                   const MechanicNode* mechanicNode);
+                   const MechanicNode* mechanicNode,
+                   MechanicContext* mechanicContext);
   virtual ~MechanicInstance();
 
-// protected:
+protected:
   virtual MechanicContext& getNodeContext();
   virtual const MechanicContext& getNodeContext() const;
 

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/ModelInstance.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ModelInstance.cpp	2008-11-09 17:49:02 UTC (rev 703)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ModelInstance.cpp	2008-11-09 20:52:40 UTC (rev 704)
@@ -7,9 +7,11 @@
 namespace OpenFDM {
 
 ModelInstance::ModelInstance(const NodePath& nodePath,
-                             const SampleTime& sampleTime, const Model* model) :
+                             const SampleTime& sampleTime,
+                             const Model* model,
+                             ModelContext* modelContext) :
   AbstractNodeInstance(nodePath, sampleTime),
-  mModelContext(model->newModelContext())
+  mModelContext(modelContext)
 {
 }
 

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/ModelInstance.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ModelInstance.h	2008-11-09 17:49:02 UTC (rev 703)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ModelInstance.h	2008-11-09 20:52:40 UTC (rev 704)
@@ -15,10 +15,10 @@
 class ModelInstance : public AbstractNodeInstance {
 public:
   ModelInstance(const NodePath& nodePath, const SampleTime& sampleTime,
-                const Model* model);
+                const Model* model, ModelContext* modelContext);
   virtual ~ModelInstance();
 
-// protected:
+protected:
   /// The node context that belongs to this instance.
   virtual ModelContext& getNodeContext();
   virtual const ModelContext& getNodeContext() const;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-09 17:49:02 UTC (rev 703)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-09 20:52:40 UTC (rev 704)
@@ -94,11 +94,9 @@
     mODESolver->setFunction(mContinousSystemFunction);
   }
 
-  void appendModelInstance(OpenFDM::ModelInstance* modelInstance)
+  void appendModelContext(const SampleTime& sampleTime,
+                          ModelContext* modelContext)
   {
-    ModelContext* modelContext = &modelInstance->getNodeContext();
-    SampleTime sampleTime = modelInstance->getSampleTime();
-
     // The init task contains them all
     mInitTask->mModelContextList[0].push_back(modelContext);
     
@@ -119,12 +117,8 @@
     }
   }
 
-  void appendMechanicInstance(MechanicInstance* mechanicInstance)
+  void appendMechanicContext(MechanicContext* mechanicContext)
   {
-    MechanicContext* mechanicContext = &mechanicInstance->getNodeContext();
-    // FIXME???
-//     SampleTime sampleTime = modelInstance->getSampleTime();
-
     // The init task contains them all
     mInitTask->mMechanicContextList.push_back(mechanicContext);
     
@@ -400,10 +394,11 @@
     void setPortValue(const PortInfo& portInfo, PortValue* portValue)
     {
       mAbstractNodeInstance->setPortValue(portInfo, portValue);
+      mPortValueList.setPortValue(portInfo.getIndex(), portValue);
     }
     const PortValue* getPortValue(const PortInfo& portInfo)
     {
-      return mAbstractNodeInstance->getPortValue(portInfo);
+      return mPortValueList.getPortValue(portInfo);
     }
 
     bool dependsOn(const Instance& instance, bool acceleration = false) const
@@ -446,14 +441,12 @@
       for (unsigned i = 0; i < mPortDataVector.size(); ++i) {
         Log(Schedule, Debug3) << "Try to to allocate port value \""
                               << mPortDataVector[i]->getPortInfo()->getName()
-                              << "\" of \""
-                              << mAbstractNodeInstance->getNodeNamePath()
+                              << "\" of \"" << getNodeNamePath()
                               << "\"" << endl;
         if (!mPortDataVector[i]->createPortValue()) {
           Log(Schedule, Error) << "Failed to allocate port value \""
                                << mPortDataVector[i]->getPortInfo()->getName()
-                               << "\" of \""
-                               << mAbstractNodeInstance->getNodeNamePath()
+                               << "\" of \"" << getNodeNamePath()
                                << "\".\nAborting!" << endl;
 
           return false;
@@ -468,6 +461,8 @@
     typedef std::vector<SharedPtr<PortData> > PortDataVector;
     PortDataVector mPortDataVector;
 
+    PortValueList mPortValueList;
+    
     /// FIXME, just in this intermediate step
     SharedPtr<AbstractNodeInstance> mAbstractNodeInstance;
   };
@@ -489,6 +484,9 @@
       mModel(&model)
     { }
     virtual const Model* getNode() const { return mModel; }
+
+    SharedPtr<ModelContext> mModelContext;
+
   private:
     SharedPtr<const Model> mModel;
   };
@@ -499,6 +497,8 @@
     { }
     virtual const MechanicNode* getNode() const = 0;
 
+    SharedPtr<MechanicContext> mMechanicContext;
+
     bool isLinkedTo(const MechanicInstance& instance) const
     {
       unsigned numPorts = getNode()->getNumPorts();
@@ -587,9 +587,6 @@
     instance = new JointInstance(node, getNodePath(), mSampleTime);
     addInstance(instance);
     mRootJointInstanceList.push_back(instance);
-
-    OpenFDM::MechanicInstance* mechanicInstance = new OpenFDM::MechanicInstance(getNodePath(), mSampleTime, &node);
-    instance->mAbstractNodeInstance = mechanicInstance;
   }
   virtual void apply(const Interact& node)
   {
@@ -597,9 +594,6 @@
     instance = new InteractInstance(node, getNodePath(), mSampleTime);
     addInstance(instance);
     mInteractInstanceList.push_back(instance);
-
-    OpenFDM::MechanicInstance* mechanicInstance = new OpenFDM::MechanicInstance(getNodePath(), mSampleTime, &node);
-    instance->mAbstractNodeInstance = mechanicInstance;
   }
   virtual void apply(const RigidBody& node)
   {
@@ -607,8 +601,9 @@
     instance = new NodeInstance(node, getNodePath(), mSampleTime);
     addInstance(instance);
 
-    OpenFDM::MechanicInstance* mechanicInstance = new OpenFDM::MechanicInstance(getNodePath(), mSampleTime, &node);
-    instance->mAbstractNodeInstance = mechanicInstance;
+    OpenFDM::NodeInstance* nodeInstance
+      = new OpenFDM::NodeInstance(getNodePath(), mSampleTime, &node);
+    instance->mAbstractNodeInstance = nodeInstance;
     // Make all rigid mechanic body links use the same link value
     // FIXME, allocate them in this way!
     PortData* portData = 0;
@@ -630,9 +625,6 @@
     instance = new JointInstance(node, getNodePath(), mSampleTime);
     addInstance(instance);
     mJointInstanceList.push_back(instance);
-
-    OpenFDM::MechanicInstance* mechanicInstance = new OpenFDM::MechanicInstance(getNodePath(), mSampleTime, &node);
-    instance->mAbstractNodeInstance = mechanicInstance;
   }
   virtual void apply(const Model& node)
   {
@@ -640,9 +632,6 @@
     instance = new ModelInstance(node, getNodePath(), mSampleTime);
     addInstance(instance);
     mModelInstanceList.push_back(instance);
-
-    OpenFDM::ModelInstance* modelInstance = new OpenFDM::ModelInstance(getNodePath(), mSampleTime, &node);
-    instance->mAbstractNodeInstance = modelInstance;
   }
 
   virtual void apply(const Group& group)
@@ -773,10 +762,8 @@
   typedef std::list<SharedPtr<JointInstance> > JointInstanceList;
 
   // The Models list, worthwhile for sorting
-  OpenFDM::ModelInstanceList _modelInstanceList; // mModelInstanceList
   ModelInstanceList mModelInstanceList;
   // The mechanical system list, also for sorting
-  OpenFDM::MechanicInstanceList _mechanicInstanceList; // mMechanicInstanceList
   MechanicInstanceList mMechanicInstanceList;
 
   // The list of root nodes in the mechanical system. Will be a starting point
@@ -833,15 +820,16 @@
     SharedPtr<DiscreteSystem> discreteSystem;
     discreteSystem = new DiscreteSystem(basicSampleTime, 1);
 
-    OpenFDM::ModelInstanceList::const_iterator i;
-    for (i = _modelInstanceList.begin(); i != _modelInstanceList.end(); ++i) {
-      discreteSystem->appendModelInstance(*i);
+    ModelInstanceList::const_iterator i;
+    for (i = mModelInstanceList.begin(); i != mModelInstanceList.end(); ++i) {
+      discreteSystem->appendModelContext((*i)->mSampleTime,
+                                         (*i)->mModelContext);
     }
 
-    OpenFDM::MechanicInstanceList::const_iterator j;
-    for (j = _mechanicInstanceList.begin();
-         j != _mechanicInstanceList.end(); ++j) {
-      discreteSystem->appendMechanicInstance(*j);
+    MechanicInstanceList::const_iterator j;
+    for (j = mMechanicInstanceList.begin();
+         j != mMechanicInstanceList.end(); ++j) {
+      discreteSystem->appendMechanicContext((*j)->mMechanicContext);
     }
 
     return discreteSystem.release();
@@ -1012,6 +1000,32 @@
   bool
   allocPortValues()
   {
+    {
+    ModelInstanceList::const_iterator i;
+    for (i = mModelInstanceList.begin(); i != mModelInstanceList.end(); ++i) {
+      ModelContext* context = (*i)->getNode()->newModelContext();
+      OpenFDM::ModelInstance* modelInstance;
+      modelInstance = new OpenFDM::ModelInstance((*i)->mNodePath,
+                                                 (*i)->mSampleTime,
+                                                 (*i)->getNode(), context);
+      (*i)->mAbstractNodeInstance = modelInstance;
+      (*i)->mModelContext = context;
+    }
+
+    MechanicInstanceList::const_iterator j;
+    for (j = mMechanicInstanceList.begin();
+         j != mMechanicInstanceList.end(); ++j) {
+      MechanicContext* context = (*j)->getNode()->newMechanicContext();
+      OpenFDM::MechanicInstance* mechanicInstance;
+      mechanicInstance = new OpenFDM::MechanicInstance((*j)->mNodePath,
+                                                       (*j)->mSampleTime,
+                                                       (*j)->getNode(),
+                                                       context);
+      (*j)->mAbstractNodeInstance = mechanicInstance;
+      (*j)->mMechanicContext = context;
+    }
+    }
+
     // alloc port values
     InstanceMap::const_iterator i;
     for (i = mInstanceMap.begin(); i != mInstanceMap.end(); ++i) {
@@ -1040,28 +1054,19 @@
 
   bool allocModels()
   {
-    // FIXME: just for now
-    ModelInstanceList::iterator i;
+    ModelInstanceList::const_iterator i;
     for (i = mModelInstanceList.begin(); i != mModelInstanceList.end(); ++i) {
-      OpenFDM::ModelInstance* instance = 
-       dynamic_cast<OpenFDM::ModelInstance*>((*i)->mAbstractNodeInstance.get());
-      OpenFDMAssert(instance);
-      _modelInstanceList.push_back(instance);
-      if (!instance->getNodeContext().alloc()) {
+      if (!(*i)->mModelContext->alloc()) {
         Log(Schedule, Error) << "Could not alloc for model \""
                              << (*i)->getNodeNamePath() << "\"" << endl;
         return false;
       }
     }
 
-    MechanicInstanceList::iterator j;
+    MechanicInstanceList::const_iterator j;
     for (j = mMechanicInstanceList.begin();
          j != mMechanicInstanceList.end(); ++j) {
-      OpenFDM::MechanicInstance* instance = 
-       dynamic_cast<OpenFDM::MechanicInstance*>((*j)->mAbstractNodeInstance.get());
-      OpenFDMAssert(instance);
-      _mechanicInstanceList.push_back(instance);
-      if (!instance->getNodeContext().alloc()) {
+      if (!(*j)->mMechanicContext->alloc()) {
         Log(Schedule, Error) << "Could not alloc for MechanicNode \""
                              << (*j)->getNodeNamePath() << "\"" << endl;
         return false;



From frohlich at mail.berlios.de  Sun Nov  9 21:54:48 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 9 Nov 2008 21:54:48 +0100
Subject: [OpenFDM-svn] r705 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811092054.mA9KsmJt020506@sheep.berlios.de>

Author: frohlich
Date: 2008-11-09 21:54:48 +0100 (Sun, 09 Nov 2008)
New Revision: 705

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/System.h
Log:
Remove unused method.

M    src/OpenFDM/System.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/System.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/System.h	2008-11-09 20:52:40 UTC (rev 704)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/System.h	2008-11-09 20:54:48 UTC (rev 705)
@@ -48,10 +48,6 @@
   /// Return the current simulation time, convenience function
   real_type getTime(void) const;
 
-  /// Get the whole NodeInstance list
-  const ConstNodeInstanceList& getNodeInstanceList() const
-  { return mNodeInstanceList; }
-
   /// Get node instances by their path within the system
   const AbstractNodeInstance* getNodeInstance(const NodePath& nodePath) const;
   AbstractNodeInstance* getNodeInstance(const NodePath& nodePath);



From frohlich at mail.berlios.de  Sun Nov  9 22:03:51 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 9 Nov 2008 22:03:51 +0100
Subject: [OpenFDM-svn] r706 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811092103.mA9L3pnl021055@sheep.berlios.de>

Author: frohlich
Date: 2008-11-09 22:03:50 +0100 (Sun, 09 Nov 2008)
New Revision: 706

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeInstance.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/System.h
Log:
Some more unused stuff removal.

M    src/OpenFDM/System.h
M    src/OpenFDM/System.cpp
M    src/OpenFDM/AbstractNodeInstance.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeInstance.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeInstance.h	2008-11-09 20:54:48 UTC (rev 705)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeInstance.h	2008-11-09 21:03:50 UTC (rev 706)
@@ -26,7 +26,7 @@
   virtual ~AbstractNodeInstance();
 
   /// The actual Node this AbstractNodeInstance stems from
-  const Node& getNode() const
+  virtual const Node& getNode() const
   { return getNodeContext().getNode(); }
 
   /// The node path leading to this instance.
@@ -41,15 +41,15 @@
   { return mSampleTime; }
 
   /// Access port values by the PortInfo values
-  const PortValue* getPortValue(const PortInfo& portInfo) const
+  virtual const PortValue* getPortValue(const PortInfo& portInfo) const
   { return getNodeContext().getPortValueList().getPortValue(portInfo); }
-  const NumericPortValue* getPortValue(const NumericPortInfo& portInfo) const
+  virtual const NumericPortValue* getPortValue(const NumericPortInfo& portInfo) const
   { return getNodeContext().getPortValueList().getPortValue(portInfo); }
-  const MechanicLinkValue* getPortValue(const MechanicLinkInfo& portInfo) const
+  virtual const MechanicLinkValue* getPortValue(const MechanicLinkInfo& portInfo) const
   { return getNodeContext().getPortValueList().getPortValue(portInfo); }
 
   /// Set port value for the given port.
-  void setPortValue(const PortInfo& portInfo, PortValue* portValue)
+  virtual void setPortValue(const PortInfo& portInfo, PortValue* portValue)
   { getNodeContext().setPortValue(portInfo, portValue); }
 
 protected:
@@ -67,10 +67,6 @@
   const NodePath mNodePath;
 };
 
-typedef std::list<SharedPtr<AbstractNodeInstance> > NodeInstanceList;
-typedef std::list<SharedPtr<const AbstractNodeInstance> > ConstNodeInstanceList;
-typedef std::map<NodePath, SharedPtr<AbstractNodeInstance> > NodeInstanceMap;
-
 } // namespace OpenFDM
 
 #endif

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-09 20:54:48 UTC (rev 705)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-09 21:03:50 UTC (rev 706)
@@ -1128,7 +1128,6 @@
   for (i = nodeInstanceCollector.mInstanceMap.begin();
        i != nodeInstanceCollector.mInstanceMap.end(); ++i) {
     mNodeInstanceMap[i->first] = i->second->mAbstractNodeInstance;
-    mNodeInstanceList.push_back(i->second->mAbstractNodeInstance);
   }
 
   SystemOutputList::const_iterator j;
@@ -1145,7 +1144,6 @@
 System::clear()
 {
   mAbstractSystem = 0;
-  mNodeInstanceList.clear();
   mNodeInstanceMap.clear();
 
   SystemOutputList::const_iterator i;
@@ -1196,15 +1194,6 @@
   return i->second;
 }
 
-AbstractNodeInstance*
-System::getNodeInstance(const NodePath& nodePath)
-{
-  NodeInstanceMap::const_iterator i = mNodeInstanceMap.find(nodePath);
-  if (i == mNodeInstanceMap.end())
-    return 0;
-  return i->second;
-}
-
 void
 System::attach(SystemOutput* systemOutput)
 {

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/System.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/System.h	2008-11-09 20:54:48 UTC (rev 705)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/System.h	2008-11-09 21:03:50 UTC (rev 706)
@@ -50,7 +50,6 @@
 
   /// Get node instances by their path within the system
   const AbstractNodeInstance* getNodeInstance(const NodePath& nodePath) const;
-  AbstractNodeInstance* getNodeInstance(const NodePath& nodePath);
 
   void attach(SystemOutput* systemOutput);
   void detach(SystemOutput* systemOutput);
@@ -62,7 +61,8 @@
   SampleTime mSampleTime;
 
   SharedPtr<AbstractSystem> mAbstractSystem;
-  ConstNodeInstanceList mNodeInstanceList;
+
+  typedef std::map<NodePath, SharedPtr<AbstractNodeInstance> > NodeInstanceMap;
   NodeInstanceMap mNodeInstanceMap;
 
   typedef std::list<SharedPtr<SystemOutput> > SystemOutputList;



From frohlich at mail.berlios.de  Mon Nov 10 17:59:17 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Mon, 10 Nov 2008 17:59:17 +0100
Subject: [OpenFDM-svn] r707 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811101659.mAAGxHxq012667@sheep.berlios.de>

Author: frohlich
Date: 2008-11-10 17:59:16 +0100 (Mon, 10 Nov 2008)
New Revision: 707

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
Log:
Avoid cyclic loop in reference counts.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-09 21:03:50 UTC (rev 706)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-10 16:59:16 UTC (rev 707)
@@ -323,7 +323,8 @@
     {
       if (!getPortInfo())
         return false;
-      if (!mInstance)
+      SharedPtr<Instance> instance = mInstance.lock();
+      if (!instance)
         return false;
       Log(Schedule, Debug3)
         << "setPortValue for port \"" << getPortInfo()->getName()
@@ -331,7 +332,7 @@
       // FIXME: move the set port value and accept port value into one call
       if (!getPortInfo()->acceptPortValue(portValue))
         return false;
-      mInstance->setPortValue(*getPortInfo(), portValue);
+      instance->setPortValue(*getPortInfo(), portValue);
       return true;
     }
 
@@ -350,8 +351,11 @@
     {
       if (!mPortValueCreator)
         return true;
+      SharedPtr<Instance> instance = mInstance.lock();
+      if (!instance)
+        return false;
       // FIXME
-      if (mInstance->getPortValue(*getPortInfo()))
+      if (instance->getPortValue(*getPortInfo()))
         return true;
       SharedPtr<PortValue> portValue = getPortInfo()->newValue();
       if (!portValue)
@@ -362,7 +366,7 @@
     }
 
   private:
-    SharedPtr<Instance> mInstance;
+    WeakPtr<Instance> mInstance;
     SharedPtr<const PortInfo> mPortInfo;
     std::vector<WeakPtr<PortData> > mConnectedPorts;
     SharedPtr<PortConnectSet> mPortConnectSet;



From frohlich at mail.berlios.de  Mon Nov 10 18:24:46 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Mon, 10 Nov 2008 18:24:46 +0100
Subject: [OpenFDM-svn] r708 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811101724.mAAHOkSr016377@sheep.berlios.de>

Author: frohlich
Date: 2008-11-10 18:24:46 +0100 (Mon, 10 Nov 2008)
New Revision: 708

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
Log:
Downgrade some Errors to Warnings according to the documented semantics.

M    src/OpenFDM/System.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-10 16:59:16 UTC (rev 707)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-10 17:24:46 UTC (rev 708)
@@ -448,7 +448,7 @@
                               << "\" of \"" << getNodeNamePath()
                               << "\"" << endl;
         if (!mPortDataVector[i]->createPortValue()) {
-          Log(Schedule, Error) << "Failed to allocate port value \""
+          Log(Schedule, Warning) << "Failed to allocate port value \""
                                << mPortDataVector[i]->getPortInfo()->getName()
                                << "\" of \"" << getNodeNamePath()
                                << "\".\nAborting!" << endl;
@@ -845,7 +845,7 @@
   {
     if (mRootJointInstanceList.empty() &&
         (!mJointInstanceList.empty() || !mInteractInstanceList.empty())) {
-      Log(Schedule,Error)
+      Log(Schedule,Warning)
         << "No root joint in System with mechanic components" << std::endl;
       return false;
     }
@@ -878,7 +878,7 @@
               if (*k == *j)
                 continue;
               if (mechanicInstance->isLinkedTo(*(*k))) {
-                Log(Schedule,Error)
+                Log(Schedule,Warning)
                   << "Detected closed kinematic loop: MechanicNode \""
                   << mechanicInstance->getNodeNamePath()
                   << "\" is linked to MechanicNode \""
@@ -900,7 +900,7 @@
         MechanicInstanceList::iterator i = j;
         for (++i; i != nextLevelList.end(); ++i) {
           if ((*j)->isLinkedTo(*(*i))) {
-            Log(Schedule,Error)
+            Log(Schedule,Warning)
               << "Detected closed kinematic loop: MechanicNode \""
               << (*j)->getNodeNamePath()
               << "\" is linked to MechanicNode \""
@@ -941,7 +941,7 @@
       mModelInstanceList.pop_front();
 
       if (modelInstance->dependsOn(*modelInstance)) {
-        Log(Schedule, Error)
+        Log(Schedule, Warning)
           << "Self referencing direct dependency for Model \""
           << modelInstance->getNodeNamePath()
           << "\" detected!" << std::endl;
@@ -980,7 +980,7 @@
         for (; i != sortedModelInstanceList.end(); ++i) {
           if (!modelInstance->dependsOn(*(*i)))
             continue;
-          Log(Schedule,Error)
+          Log(Schedule,Warning)
             << "Detected cyclic loop: Model \""
             << modelInstance->getNodeNamePath()
             << "\" depends on Model \""
@@ -1045,7 +1045,7 @@
         if (portInfo->getOptional())
           continue;
         if (!i->second->getPortValue(*portInfo)) {
-          Log(Schedule, Error) << "Mandatory port value for port \""
+          Log(Schedule, Warning) << "Mandatory port value for port \""
                                << portInfo->getName() << "\" for model \""
                                << i->second->getNodeNamePath()
                                << "\" is not connected!" << endl;
@@ -1061,7 +1061,7 @@
     ModelInstanceList::const_iterator i;
     for (i = mModelInstanceList.begin(); i != mModelInstanceList.end(); ++i) {
       if (!(*i)->mModelContext->alloc()) {
-        Log(Schedule, Error) << "Could not alloc for model \""
+        Log(Schedule, Warning) << "Could not alloc for model \""
                              << (*i)->getNodeNamePath() << "\"" << endl;
         return false;
       }
@@ -1071,7 +1071,7 @@
     for (j = mMechanicInstanceList.begin();
          j != mMechanicInstanceList.end(); ++j) {
       if (!(*j)->mMechanicContext->alloc()) {
-        Log(Schedule, Error) << "Could not alloc for MechanicNode \""
+        Log(Schedule, Warning) << "Could not alloc for MechanicNode \""
                              << (*j)->getNodeNamePath() << "\"" << endl;
         return false;
       }



From frohlich at mail.berlios.de  Mon Nov 10 18:58:55 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Mon, 10 Nov 2008 18:58:55 +0100
Subject: [OpenFDM-svn] r709 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811101758.mAAHwtNl019400@sheep.berlios.de>

Author: frohlich
Date: 2008-11-10 18:58:54 +0100 (Mon, 10 Nov 2008)
New Revision: 709

Removed:
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicInstance.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicInstance.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/ModelInstance.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/ModelInstance.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/NodeContext.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/NodeContext.h
Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeInstance.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeInstance.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Group.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
   branches/OpenFDM-StateSeparation/src/OpenFDM/NodeInstance.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/NodeInstance.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
Log:
Remove MechanicInstance and ModelInstance.

D    src/OpenFDM/ModelInstance.h
M    src/OpenFDM/Group.h
D    src/OpenFDM/MechanicInstance.h
M    src/OpenFDM/Makefile.am
D    src/OpenFDM/NodeContext.cpp
M    src/OpenFDM/AbstractNodeInstance.cpp
D    src/OpenFDM/NodeContext.h
D    src/OpenFDM/MechanicInstance.cpp
D    src/OpenFDM/ModelInstance.cpp
M    src/OpenFDM/System.cpp
M    src/OpenFDM/AbstractNodeInstance.h
M    src/OpenFDM/NodeInstance.cpp
M    src/OpenFDM/NodeInstance.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeInstance.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeInstance.cpp	2008-11-10 17:24:46 UTC (rev 708)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeInstance.cpp	2008-11-10 17:58:54 UTC (rev 709)
@@ -11,12 +11,9 @@
 
 namespace OpenFDM {
 
-AbstractNodeInstance::AbstractNodeInstance(const NodePath& nodePath,
-                                           const SampleTime& sampleTime) :
-  mNodePath(nodePath),
+AbstractNodeInstance::AbstractNodeInstance(const SampleTime& sampleTime) :
   mSampleTime(sampleTime)
 {
-  OpenFDMAssert(!nodePath.empty());
 }
 
 AbstractNodeInstance::~AbstractNodeInstance()

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeInstance.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeInstance.h	2008-11-10 17:24:46 UTC (rev 708)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeInstance.h	2008-11-10 17:58:54 UTC (rev 709)
@@ -22,49 +22,68 @@
 /// This class is meant to show up in the user interface of this simulation.
 class AbstractNodeInstance : public WeakReferenced {
 public:
-  AbstractNodeInstance(const NodePath& nodePath, const SampleTime& sampleTime);
+  AbstractNodeInstance(const SampleTime& sampleTime);
   virtual ~AbstractNodeInstance();
 
   /// The actual Node this AbstractNodeInstance stems from
-  virtual const Node& getNode() const
-  { return getNodeContext().getNode(); }
+  virtual const Node& getNode() const = 0;
 
-  /// The node path leading to this instance.
-  const NodePath& getNodePath() const
-  { return mNodePath; }
-  /// String representation of the node path.
-  std::string getNodeNamePath() const
-  { return Node::toNodePathName(mNodePath); }
-
   /// Get the sample time this node will run on
   const SampleTime& getSampleTime() const
   { return mSampleTime; }
 
   /// Access port values by the PortInfo values
-  virtual const PortValue* getPortValue(const PortInfo& portInfo) const
-  { return getNodeContext().getPortValueList().getPortValue(portInfo); }
-  virtual const NumericPortValue* getPortValue(const NumericPortInfo& portInfo) const
-  { return getNodeContext().getPortValueList().getPortValue(portInfo); }
-  virtual const MechanicLinkValue* getPortValue(const MechanicLinkInfo& portInfo) const
-  { return getNodeContext().getPortValueList().getPortValue(portInfo); }
+  virtual const PortValue*
+  getPortValue(const PortInfo& portInfo) const = 0;
+  virtual const NumericPortValue*
+  getPortValue(const NumericPortInfo& portInfo) const = 0;
+  virtual const MechanicLinkValue*
+  getPortValue(const MechanicLinkInfo& portInfo) const = 0;
 
   /// Set port value for the given port.
-  virtual void setPortValue(const PortInfo& portInfo, PortValue* portValue)
-  { getNodeContext().setPortValue(portInfo, portValue); }
+  // FIXME, must vanish ...
+  virtual void setPortValue(const PortInfo& portInfo, PortValue* portValue) = 0;
 
-protected:
-  /// The node context that belongs to this instance.
-  virtual AbstractNodeContext& getNodeContext() = 0;
-  virtual const AbstractNodeContext& getNodeContext() const = 0;
-
 private:
   AbstractNodeInstance(const AbstractNodeInstance&);
   AbstractNodeInstance& operator=(const AbstractNodeInstance&);
 
   /// The sample times this node will run on
   const SampleTime mSampleTime;
+};
 
-  const NodePath mNodePath;
+class LeafInstance : public AbstractNodeInstance {
+public:
+  LeafInstance(const SampleTime& sampleTime, AbstractNodeContext* context) :
+    AbstractNodeInstance(sampleTime),
+    mNodeContext(context)
+  { }
+  virtual ~LeafInstance() {}
+
+  /// The actual Node this AbstractLeafInstance stems from
+  virtual const Node& getNode() const
+  { return mNodeContext->getNode(); }
+
+  /// Access port values by the PortInfo values
+  virtual const PortValue*
+  getPortValue(const PortInfo& portInfo) const
+  { return mNodeContext->getPortValueList().getPortValue(portInfo); }
+  virtual const NumericPortValue*
+  getPortValue(const NumericPortInfo& portInfo) const
+  { return mNodeContext->getPortValueList().getPortValue(portInfo); }
+  virtual const MechanicLinkValue*
+  getPortValue(const MechanicLinkInfo& portInfo) const
+  { return mNodeContext->getPortValueList().getPortValue(portInfo); }
+
+  /// Set port value for the given port.
+  virtual void setPortValue(const PortInfo& portInfo, PortValue* portValue)
+  { mNodeContext->setPortValue(portInfo, portValue); }
+
+private:
+  LeafInstance(const LeafInstance&);
+  LeafInstance& operator=(const LeafInstance&);
+
+  SharedPtr<AbstractNodeContext> mNodeContext;
 };
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Group.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Group.h	2008-11-10 17:24:46 UTC (rev 708)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Group.h	2008-11-10 17:58:54 UTC (rev 709)
@@ -10,7 +10,6 @@
 #include <sstream>
 #include "ConstNodeVisitor.h"
 #include "Node.h"
-#include "NodeContext.h"
 #include "NodeVisitor.h"
 #include "Object.h"
 #include "PortId.h"
@@ -32,7 +31,7 @@
   }
 
   virtual AbstractNodeContext* newNodeContext() const
-  { return new NodeContext(this); }
+  { return 0; }
 
   unsigned getExternalPortIndex() const
   { return mExternalPortInfo->getIndex(); }
@@ -130,7 +129,7 @@
   void traverse(ConstNodeVisitor& visitor) const;
 
   virtual AbstractNodeContext* newNodeContext() const
-  { return new NodeContext(this); }
+  { return 0; }
 
   NodeId addChild(const SharedPtr<Node>& node);
   unsigned getNumChildren() const;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-11-10 17:24:46 UTC (rev 708)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-11-10 17:58:54 UTC (rev 709)
@@ -60,18 +60,15 @@
   MatrixStateInfo.h \
   MidpointRule.h \
   MechanicContext.h \
-  MechanicInstance.h \
   MechanicLink.h \
   MechanicLinkValue.h \
   MechanicNode.h \
   Model.h \
   ModelContext.h \
-  ModelInstance.h \
   Mutex.h \
   MPFRFloat.h \
   Newton.h \
   Node.h \
-  NodeContext.h \
   NodeInstance.h \
   NodeVisitor.h \
   NumericPortValue.h \
@@ -141,15 +138,12 @@
   LibraryNode.cpp \
   Logger.cpp \
   MechanicContext.cpp \
-  MechanicInstance.cpp \
   MechanicLinkValue.cpp \
   MechanicNode.cpp \
   MidpointRule.cpp \
   Model.cpp \
   ModelContext.cpp \
-  ModelInstance.cpp \
   Node.cpp \
-  NodeContext.cpp \
   NodeInstance.cpp \
   NodeVisitor.cpp \
   NumericPortValue.cpp \

Deleted: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicInstance.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicInstance.cpp	2008-11-10 17:24:46 UTC (rev 708)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicInstance.cpp	2008-11-10 17:58:54 UTC (rev 709)
@@ -1,34 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
- *
- */
-
-#include "MechanicInstance.h"
-
-namespace OpenFDM {
-
-MechanicInstance::MechanicInstance(const NodePath& nodePath,
-                                   const SampleTime& sampleTime,
-                                   const MechanicNode* mechanicNode,
-                                   MechanicContext* mechanicContext) :
-  AbstractNodeInstance(nodePath, sampleTime),
-  mMechanicContext(mechanicContext)
-{
-}
-
-MechanicInstance::~MechanicInstance()
-{
-}
-
-MechanicContext&
-MechanicInstance::getNodeContext()
-{
-  return *mMechanicContext;
-}
-
-const MechanicContext&
-MechanicInstance::getNodeContext() const
-{
-  return *mMechanicContext;
-}
-
-} // namespace OpenFDM

Deleted: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicInstance.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicInstance.h	2008-11-10 17:24:46 UTC (rev 708)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicInstance.h	2008-11-10 17:58:54 UTC (rev 709)
@@ -1,34 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
- *
- */
-
-#ifndef OpenFDM_MechanicInstance_H
-#define OpenFDM_MechanicInstance_H
-
-#include <list>
-#include "AbstractNodeInstance.h"
-#include "MechanicContext.h"
-#include "SharedPtr.h"
-
-namespace OpenFDM {
-
-class MechanicInstance : public AbstractNodeInstance {
-public:
-  MechanicInstance(const NodePath& nodePath, const SampleTime& sampleTime,
-                   const MechanicNode* mechanicNode,
-                   MechanicContext* mechanicContext);
-  virtual ~MechanicInstance();
-
-protected:
-  virtual MechanicContext& getNodeContext();
-  virtual const MechanicContext& getNodeContext() const;
-
-private:
-  SharedPtr<MechanicContext> mMechanicContext;
-};
-
-typedef std::list<SharedPtr<MechanicInstance> > MechanicInstanceList;
-
-} // namespace OpenFDM
-
-#endif

Deleted: branches/OpenFDM-StateSeparation/src/OpenFDM/ModelInstance.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ModelInstance.cpp	2008-11-10 17:24:46 UTC (rev 708)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ModelInstance.cpp	2008-11-10 17:58:54 UTC (rev 709)
@@ -1,34 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
- *
- */
-
-#include "ModelInstance.h"
-
-namespace OpenFDM {
-
-ModelInstance::ModelInstance(const NodePath& nodePath,
-                             const SampleTime& sampleTime,
-                             const Model* model,
-                             ModelContext* modelContext) :
-  AbstractNodeInstance(nodePath, sampleTime),
-  mModelContext(modelContext)
-{
-}
-
-ModelInstance::~ModelInstance()
-{
-}
-
-ModelContext&
-ModelInstance::getNodeContext()
-{
-  return *mModelContext;
-}
-
-const ModelContext&
-ModelInstance::getNodeContext() const
-{
-  return *mModelContext;
-}
-
-} // namespace OpenFDM

Deleted: branches/OpenFDM-StateSeparation/src/OpenFDM/ModelInstance.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ModelInstance.h	2008-11-10 17:24:46 UTC (rev 708)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ModelInstance.h	2008-11-10 17:58:54 UTC (rev 709)
@@ -1,34 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
- *
- */
-
-#ifndef OpenFDM_ModelInstance_H
-#define OpenFDM_ModelInstance_H
-
-#include <list>
-#include "AbstractNodeInstance.h"
-#include "ModelContext.h"
-#include "SharedPtr.h"
-
-namespace OpenFDM {
-
-class ModelInstance : public AbstractNodeInstance {
-public:
-  ModelInstance(const NodePath& nodePath, const SampleTime& sampleTime,
-                const Model* model, ModelContext* modelContext);
-  virtual ~ModelInstance();
-
-protected:
-  /// The node context that belongs to this instance.
-  virtual ModelContext& getNodeContext();
-  virtual const ModelContext& getNodeContext() const;
-
-private:
-  SharedPtr<ModelContext> mModelContext;
-};
-
-typedef std::list<SharedPtr<ModelInstance> > ModelInstanceList;
-
-} // namespace OpenFDM
-
-#endif

Deleted: branches/OpenFDM-StateSeparation/src/OpenFDM/NodeContext.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/NodeContext.cpp	2008-11-10 17:24:46 UTC (rev 708)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/NodeContext.cpp	2008-11-10 17:58:54 UTC (rev 709)
@@ -1,26 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
- *
- */
-
-#include "Assert.h"
-#include "NodeContext.h"
-
-namespace OpenFDM {
-
-NodeContext::NodeContext(const Node* node) :
-  mNode(node)
-{
-  OpenFDMAssert(mNode);
-}
-
-NodeContext::~NodeContext()
-{
-}
-
-const Node&
-NodeContext::getNode() const
-{
-  return *mNode;
-}
-
-} // namespace OpenFDM

Deleted: branches/OpenFDM-StateSeparation/src/OpenFDM/NodeContext.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/NodeContext.h	2008-11-10 17:24:46 UTC (rev 708)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/NodeContext.h	2008-11-10 17:58:54 UTC (rev 709)
@@ -1,34 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
- *
- */
-
-#ifndef OpenFDM_NodeContext_H
-#define OpenFDM_NodeContext_H
-
-#include "SharedPtr.h"
-#include "AbstractNodeContext.h"
-
-namespace OpenFDM {
-
-/// This one will not show up in any execution list, but will be used
-/// to fill NodeContext's for Node's that have nothing to execute,
-/// should be reflected to the user of the simulation system. Group's
-/// inputs ad outputs and their input and output models are such examples.
-class NodeContext : public AbstractNodeContext {
-public:
-  NodeContext(const Node* node);
-  virtual ~NodeContext();
-
-  virtual const Node& getNode() const;
-
-private:
-  NodeContext();
-  NodeContext(const NodeContext&);
-  NodeContext& operator=(const NodeContext&);
-
-  SharedPtr<const Node> mNode;
-};
-
-} // namespace OpenFDM
-
-#endif

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/NodeInstance.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/NodeInstance.cpp	2008-11-10 17:24:46 UTC (rev 708)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/NodeInstance.cpp	2008-11-10 17:58:54 UTC (rev 709)
@@ -6,10 +6,9 @@
 
 namespace OpenFDM {
 
-NodeInstance::NodeInstance(const NodePath& nodePath,
-                           const SampleTime& sampleTime, const Node* node) :
-  AbstractNodeInstance(nodePath, sampleTime),
-  mNodeContext(node->newNodeContext())
+NodeInstance::NodeInstance(const SampleTime& sampleTime, const Node* node) :
+  AbstractNodeInstance(sampleTime),
+  mNode(node)
 {
 }
 
@@ -17,16 +16,4 @@
 {
 }
 
-AbstractNodeContext&
-NodeInstance::getNodeContext()
-{
-  return *mNodeContext;
-}
-
-const AbstractNodeContext&
-NodeInstance::getNodeContext() const
-{
-  return *mNodeContext;
-}
-
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/NodeInstance.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/NodeInstance.h	2008-11-10 17:24:46 UTC (rev 708)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/NodeInstance.h	2008-11-10 17:58:54 UTC (rev 709)
@@ -6,23 +6,33 @@
 #define OpenFDM_NodeInstance_H
 
 #include "AbstractNodeInstance.h"
-#include "NodeContext.h"
 
 namespace OpenFDM {
 
 class NodeInstance : public AbstractNodeInstance {
 public:
-  NodeInstance(const NodePath& nodePath, const SampleTime& sampleTime,
+  NodeInstance(const SampleTime& sampleTime,
                const Node* node);
   virtual ~NodeInstance();
 
-protected:
-  /// The node context that belongs to this instance.
-  virtual AbstractNodeContext& getNodeContext();
-  virtual const AbstractNodeContext& getNodeContext() const;
+  virtual const Node& getNode() const
+  { return *mNode; }
 
+  virtual const PortValue* getPortValue(const PortInfo& portInfo) const
+  { return mPortValueList.getPortValue(portInfo); }
+  virtual const NumericPortValue* getPortValue(const NumericPortInfo& portInfo) const
+  { return mPortValueList.getPortValue(portInfo); }
+  virtual const MechanicLinkValue* getPortValue(const MechanicLinkInfo& portInfo) const
+  { return mPortValueList.getPortValue(portInfo); }
+
+  /// Set port value for the given port.
+  virtual void setPortValue(const PortInfo& portInfo, PortValue* portValue)
+  { mPortValueList.setPortValue(portInfo.getIndex(), portValue); }
+
 private:
-  SharedPtr<AbstractNodeContext> mNodeContext;
+  SharedPtr<const Node> mNode;
+
+  PortValueList mPortValueList;
 };
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-10 17:24:46 UTC (rev 708)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-10 17:58:54 UTC (rev 709)
@@ -9,8 +9,6 @@
 #include "Group.h"
 #include "Interact.h"
 #include "Joint.h"
-#include "ModelInstance.h"
-#include "MechanicInstance.h"
 #include "NodeInstance.h"
 #include "Object.h"
 #include "RigidBody.h"
@@ -573,7 +571,7 @@
     addInstance(instance);
 
     OpenFDM::NodeInstance* nodeInstance;
-    nodeInstance = new OpenFDM::NodeInstance(getNodePath(), mSampleTime, &node);
+    nodeInstance = new OpenFDM::NodeInstance(mSampleTime, &node);
     instance->mAbstractNodeInstance = nodeInstance;
 
     OpenFDMAssert(node.getPort(0));
@@ -606,7 +604,7 @@
     addInstance(instance);
 
     OpenFDM::NodeInstance* nodeInstance
-      = new OpenFDM::NodeInstance(getNodePath(), mSampleTime, &node);
+      = new OpenFDM::NodeInstance(mSampleTime, &node);
     instance->mAbstractNodeInstance = nodeInstance;
     // Make all rigid mechanic body links use the same link value
     // FIXME, allocate them in this way!
@@ -645,7 +643,7 @@
     addInstance(instance);
 
     OpenFDM::NodeInstance* nodeInstance;
-    nodeInstance = new OpenFDM::NodeInstance(getNodePath(), mSampleTime, &group);
+    nodeInstance = new OpenFDM::NodeInstance(mSampleTime, &group);
     instance->mAbstractNodeInstance = nodeInstance;
 
     // The vector of instances for this group.
@@ -1008,10 +1006,8 @@
     ModelInstanceList::const_iterator i;
     for (i = mModelInstanceList.begin(); i != mModelInstanceList.end(); ++i) {
       ModelContext* context = (*i)->getNode()->newModelContext();
-      OpenFDM::ModelInstance* modelInstance;
-      modelInstance = new OpenFDM::ModelInstance((*i)->mNodePath,
-                                                 (*i)->mSampleTime,
-                                                 (*i)->getNode(), context);
+      OpenFDM::LeafInstance* modelInstance;
+      modelInstance = new OpenFDM::LeafInstance((*i)->mSampleTime, context);
       (*i)->mAbstractNodeInstance = modelInstance;
       (*i)->mModelContext = context;
     }
@@ -1020,11 +1016,8 @@
     for (j = mMechanicInstanceList.begin();
          j != mMechanicInstanceList.end(); ++j) {
       MechanicContext* context = (*j)->getNode()->newMechanicContext();
-      OpenFDM::MechanicInstance* mechanicInstance;
-      mechanicInstance = new OpenFDM::MechanicInstance((*j)->mNodePath,
-                                                       (*j)->mSampleTime,
-                                                       (*j)->getNode(),
-                                                       context);
+      OpenFDM::LeafInstance* mechanicInstance;
+      mechanicInstance = new OpenFDM::LeafInstance((*j)->mSampleTime, context);
       (*j)->mAbstractNodeInstance = mechanicInstance;
       (*j)->mMechanicContext = context;
     }



From frohlich at mail.berlios.de  Mon Nov 10 19:11:14 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Mon, 10 Nov 2008 19:11:14 +0100
Subject: [OpenFDM-svn] r710 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811101811.mAAIBEgt003086@sheep.berlios.de>

Author: frohlich
Date: 2008-11-10 19:11:13 +0100 (Mon, 10 Nov 2008)
New Revision: 710

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
Log:
Fix typo.

M    src/OpenFDM/System.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-10 17:58:54 UTC (rev 709)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-10 18:11:13 UTC (rev 710)
@@ -1120,7 +1120,7 @@
     return false;
 
   // Have something to run in our hands.
-  // Not get the information required to reflect the system to the user.
+  // Now get the information required to reflect the system to the user.
   NodeInstanceCollector::InstanceMap::const_iterator i;
   for (i = nodeInstanceCollector.mInstanceMap.begin();
        i != nodeInstanceCollector.mInstanceMap.end(); ++i) {



From frohlich at mail.berlios.de  Mon Nov 10 19:12:27 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Mon, 10 Nov 2008 19:12:27 +0100
Subject: [OpenFDM-svn] r711 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811101812.mAAICR1a005289@sheep.berlios.de>

Author: frohlich
Date: 2008-11-10 19:12:26 +0100 (Mon, 10 Nov 2008)
New Revision: 711

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/System.h
Log:
Fix an other typo

M    src/OpenFDM/System.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/System.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/System.h	2008-11-10 18:11:13 UTC (rev 710)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/System.h	2008-11-10 18:12:26 UTC (rev 711)
@@ -39,7 +39,7 @@
   bool init(const real_type& t0 = real_type(0));
   void clear();
 
-  /// Simulate the system until the time tEnd
+  /// Simulate the system until the time t
   bool simulate(const real_type& t);
 
   /// Bring the system in an equilibrum state near the current state ...



From frohlich at mail.berlios.de  Mon Nov 10 19:28:45 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Mon, 10 Nov 2008 19:28:45 +0100
Subject: [OpenFDM-svn] r712 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200811101828.mAAISju8002933@sheep.berlios.de>

Author: frohlich
Date: 2008-11-10 19:28:45 +0100 (Mon, 10 Nov 2008)
New Revision: 712

Modified:
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Echo something usefull when testing was successful.

M    src/test/structure.cpp


Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-11-10 18:12:26 UTC (rev 711)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-11-10 18:28:45 UTC (rev 712)
@@ -210,6 +210,8 @@
 
   system->simulate(10);
 
+  std::cout << "PASSED" << std::endl;
+
   return 0;
 }
 



From frohlich at mail.berlios.de  Tue Nov 11 18:32:24 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Tue, 11 Nov 2008 18:32:24 +0100
Subject: [OpenFDM-svn] r713 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811111732.mABHWOG0020881@sheep.berlios.de>

Author: frohlich
Date: 2008-11-11 18:32:23 +0100 (Tue, 11 Nov 2008)
New Revision: 713

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
Log:
Next bunch of refactoring for the system bootstrap.

M    src/OpenFDM/System.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-10 18:28:45 UTC (rev 712)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-11 17:32:23 UTC (rev 713)
@@ -385,6 +385,7 @@
     virtual ~Instance()
     { }
     virtual const Node* getNode() const = 0;
+    virtual AbstractNodeInstance* getAbstractNodeInstance() = 0;
 
     PortData* getPortData(unsigned i)
     {
@@ -395,7 +396,7 @@
 
     void setPortValue(const PortInfo& portInfo, PortValue* portValue)
     {
-      mAbstractNodeInstance->setPortValue(portInfo, portValue);
+      getAbstractNodeInstance()->setPortValue(portInfo, portValue);
       mPortValueList.setPortValue(portInfo.getIndex(), portValue);
     }
     const PortValue* getPortValue(const PortInfo& portInfo)
@@ -464,9 +465,6 @@
     PortDataVector mPortDataVector;
 
     PortValueList mPortValueList;
-    
-    /// FIXME, just in this intermediate step
-    SharedPtr<AbstractNodeInstance> mAbstractNodeInstance;
   };
 
   struct NodeInstance : public Instance {
@@ -476,6 +474,10 @@
       mNode(&node)
     { }
     virtual const Node* getNode() const { return mNode; }
+    virtual AbstractNodeInstance* getAbstractNodeInstance()
+    { return mAbstractNodeInstance; }
+    /// FIXME, just in this intermediate step
+    SharedPtr<AbstractNodeInstance> mAbstractNodeInstance;
   private:
     SharedPtr<const Node> mNode;
   };
@@ -486,7 +488,14 @@
       mModel(&model)
     { }
     virtual const Model* getNode() const { return mModel; }
+    virtual AbstractNodeInstance* getAbstractNodeInstance()
+    { return mAbstractNodeInstance; }
+    /// FIXME, just in this intermediate step
+    SharedPtr<AbstractNodeInstance> mAbstractNodeInstance;
 
+    ModelContext* getModelContext()
+    { return mModelContext; }
+
     SharedPtr<ModelContext> mModelContext;
 
   private:
@@ -498,7 +507,14 @@
       Instance(mechanicNode, nodePath, sampleTime)
     { }
     virtual const MechanicNode* getNode() const = 0;
+    virtual AbstractNodeInstance* getAbstractNodeInstance()
+    { return mAbstractNodeInstance; }
+    /// FIXME, just in this intermediate step
+    SharedPtr<AbstractNodeInstance> mAbstractNodeInstance;
 
+    MechanicContext* getMechanicContext()
+    { return mMechanicContext; }
+
     SharedPtr<MechanicContext> mMechanicContext;
 
     bool isLinkedTo(const MechanicInstance& instance) const
@@ -569,11 +585,8 @@
     SharedPtr<NodeInstance> instance;
     instance = new NodeInstance(node, getNodePath(), mSampleTime);
     addInstance(instance);
+    mNodeInstanceList.push_back(instance);
 
-    OpenFDM::NodeInstance* nodeInstance;
-    nodeInstance = new OpenFDM::NodeInstance(mSampleTime, &node);
-    instance->mAbstractNodeInstance = nodeInstance;
-
     OpenFDMAssert(node.getPort(0));
     PortData* portData = instance->getPortData(0);
     OpenFDMAssert(portData);
@@ -602,10 +615,8 @@
     SharedPtr<NodeInstance> instance;
     instance = new NodeInstance(node, getNodePath(), mSampleTime);
     addInstance(instance);
+    mNodeInstanceList.push_back(instance);
 
-    OpenFDM::NodeInstance* nodeInstance
-      = new OpenFDM::NodeInstance(mSampleTime, &node);
-    instance->mAbstractNodeInstance = nodeInstance;
     // Make all rigid mechanic body links use the same link value
     // FIXME, allocate them in this way!
     PortData* portData = 0;
@@ -641,11 +652,8 @@
     SharedPtr<NodeInstance> instance;
     instance = new NodeInstance(group, getNodePath(), mSampleTime);
     addInstance(instance);
+    mNodeInstanceList.push_back(instance);
 
-    OpenFDM::NodeInstance* nodeInstance;
-    nodeInstance = new OpenFDM::NodeInstance(mSampleTime, &group);
-    instance->mAbstractNodeInstance = nodeInstance;
-
     // The vector of instances for this group.
     InstanceVector parentInstanceVector;
     parentInstanceVector.swap(mInstanceVector);
@@ -758,11 +766,12 @@
   typedef std::map<NodePath, SharedPtr<Instance> > InstanceMap;
   InstanceMap mInstanceMap;
 
+  typedef std::list<SharedPtr<NodeInstance> > NodeInstanceList;
   typedef std::list<SharedPtr<ModelInstance> > ModelInstanceList;
   typedef std::list<SharedPtr<MechanicInstance> > MechanicInstanceList;
-  typedef std::list<SharedPtr<InteractInstance> > InteractInstanceList;
-  typedef std::list<SharedPtr<JointInstance> > JointInstanceList;
 
+  // The list of Nodes that do not need a context for itself.
+  NodeInstanceList mNodeInstanceList;
   // The Models list, worthwhile for sorting
   ModelInstanceList mModelInstanceList;
   // The mechanical system list, also for sorting
@@ -1021,7 +1030,15 @@
       (*j)->mAbstractNodeInstance = mechanicInstance;
       (*j)->mMechanicContext = context;
     }
+
+    NodeInstanceList::const_iterator k;
+    for (k = mNodeInstanceList.begin(); k != mNodeInstanceList.end(); ++k) {
+      OpenFDM::NodeInstance* nodeInstance;
+      nodeInstance = new OpenFDM::NodeInstance((*k)->mSampleTime,
+                                               (*k)->getNode());
+      (*k)->mAbstractNodeInstance = nodeInstance;
     }
+    }
 
     // alloc port values
     InstanceMap::const_iterator i;
@@ -1124,7 +1141,7 @@
   NodeInstanceCollector::InstanceMap::const_iterator i;
   for (i = nodeInstanceCollector.mInstanceMap.begin();
        i != nodeInstanceCollector.mInstanceMap.end(); ++i) {
-    mNodeInstanceMap[i->first] = i->second->mAbstractNodeInstance;
+    mNodeInstanceMap[i->first] = i->second->getAbstractNodeInstance();
   }
 
   SystemOutputList::const_iterator j;



From frohlich at mail.berlios.de  Tue Nov 11 19:00:51 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Tue, 11 Nov 2008 19:00:51 +0100
Subject: [OpenFDM-svn] r714 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811111800.mABI0pDJ024149@sheep.berlios.de>

Author: frohlich
Date: 2008-11-11 19:00:50 +0100 (Tue, 11 Nov 2008)
New Revision: 714

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/PortValueList.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
Log:
Comming closer to a propper bootstrap sequence.

M    src/OpenFDM/PortValueList.h
M    src/OpenFDM/System.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/PortValueList.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/PortValueList.h	2008-11-11 17:32:23 UTC (rev 713)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/PortValueList.h	2008-11-11 18:00:50 UTC (rev 714)
@@ -101,6 +101,12 @@
       return 0;
     return mPortValueVector[idx];
   }
+  PortValue* getPortValue(unsigned idx)
+  {
+    if (mPortValueVector.size() <= idx)
+      return 0;
+    return mPortValueVector[idx];
+  }
 
   /// Save but partially expensive Accessor for numeric ports
   const NumericPortValue* getPortValue(const NumericPortInfo* portInfo) const

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-11 17:32:23 UTC (rev 713)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-11 18:00:50 UTC (rev 714)
@@ -385,7 +385,7 @@
     virtual ~Instance()
     { }
     virtual const Node* getNode() const = 0;
-    virtual AbstractNodeInstance* getAbstractNodeInstance() = 0;
+    virtual AbstractNodeInstance* newNodeInstance() = 0;
 
     PortData* getPortData(unsigned i)
     {
@@ -396,7 +396,6 @@
 
     void setPortValue(const PortInfo& portInfo, PortValue* portValue)
     {
-      getAbstractNodeInstance()->setPortValue(portInfo, portValue);
       mPortValueList.setPortValue(portInfo.getIndex(), portValue);
     }
     const PortValue* getPortValue(const PortInfo& portInfo)
@@ -474,10 +473,16 @@
       mNode(&node)
     { }
     virtual const Node* getNode() const { return mNode; }
-    virtual AbstractNodeInstance* getAbstractNodeInstance()
-    { return mAbstractNodeInstance; }
-    /// FIXME, just in this intermediate step
-    SharedPtr<AbstractNodeInstance> mAbstractNodeInstance;
+    virtual AbstractNodeInstance* newNodeInstance()
+    {
+      OpenFDM::NodeInstance* nodeInstance;
+      nodeInstance = new OpenFDM::NodeInstance(mSampleTime, getNode());
+      OpenFDMAssert(mNode->getNumPorts() == mPortDataVector.size());
+      for (unsigned i = 0; i < mNode->getNumPorts(); ++i)
+        nodeInstance->setPortValue(*mNode->getPort(i),
+                                   mPortValueList.getPortValue(i));
+      return nodeInstance;
+    }
   private:
     SharedPtr<const Node> mNode;
   };
@@ -488,11 +493,21 @@
       mModel(&model)
     { }
     virtual const Model* getNode() const { return mModel; }
-    virtual AbstractNodeInstance* getAbstractNodeInstance()
-    { return mAbstractNodeInstance; }
-    /// FIXME, just in this intermediate step
-    SharedPtr<AbstractNodeInstance> mAbstractNodeInstance;
 
+    bool createModelContext()
+    {
+      OpenFDMAssert(!mModelContext);
+      mModelContext = mModel->newModelContext();
+      OpenFDMAssert(mModel->getNumPorts() == mPortDataVector.size());
+      for (unsigned i = 0; i < mModel->getNumPorts(); ++i)
+        mModelContext->setPortValue(*mModel->getPort(i), mPortValueList.getPortValue(i));
+    }
+
+    virtual AbstractNodeInstance* newNodeInstance()
+    {
+      return new OpenFDM::LeafInstance(mSampleTime, mModelContext);
+    }
+
     ModelContext* getModelContext()
     { return mModelContext; }
 
@@ -507,11 +522,21 @@
       Instance(mechanicNode, nodePath, sampleTime)
     { }
     virtual const MechanicNode* getNode() const = 0;
-    virtual AbstractNodeInstance* getAbstractNodeInstance()
-    { return mAbstractNodeInstance; }
-    /// FIXME, just in this intermediate step
-    SharedPtr<AbstractNodeInstance> mAbstractNodeInstance;
 
+    bool createMechanicContext()
+    {
+      OpenFDMAssert(!mMechanicContext);
+      mMechanicContext = getNode()->newMechanicContext();
+      OpenFDMAssert(getNode()->getNumPorts() == mPortDataVector.size());
+      for (unsigned i = 0; i < getNode()->getNumPorts(); ++i)
+        mMechanicContext->setPortValue(*getNode()->getPort(i), mPortValueList.getPortValue(i));
+    }
+
+    virtual AbstractNodeInstance* newNodeInstance()
+    {
+      return new OpenFDM::LeafInstance(mSampleTime, mMechanicContext);
+    }
+
     MechanicContext* getMechanicContext()
     { return mMechanicContext; }
 
@@ -1011,41 +1036,25 @@
   bool
   allocPortValues()
   {
+    // alloc port values
+    InstanceMap::const_iterator i;
+    for (i = mInstanceMap.begin(); i != mInstanceMap.end(); ++i) {
+      if (!i->second->allocPortValues())
+          return false;
+    }
+
     {
     ModelInstanceList::const_iterator i;
     for (i = mModelInstanceList.begin(); i != mModelInstanceList.end(); ++i) {
-      ModelContext* context = (*i)->getNode()->newModelContext();
-      OpenFDM::LeafInstance* modelInstance;
-      modelInstance = new OpenFDM::LeafInstance((*i)->mSampleTime, context);
-      (*i)->mAbstractNodeInstance = modelInstance;
-      (*i)->mModelContext = context;
+      (*i)->createModelContext();
     }
 
     MechanicInstanceList::const_iterator j;
     for (j = mMechanicInstanceList.begin();
          j != mMechanicInstanceList.end(); ++j) {
-      MechanicContext* context = (*j)->getNode()->newMechanicContext();
-      OpenFDM::LeafInstance* mechanicInstance;
-      mechanicInstance = new OpenFDM::LeafInstance((*j)->mSampleTime, context);
-      (*j)->mAbstractNodeInstance = mechanicInstance;
-      (*j)->mMechanicContext = context;
+      (*j)->createMechanicContext();
     }
-
-    NodeInstanceList::const_iterator k;
-    for (k = mNodeInstanceList.begin(); k != mNodeInstanceList.end(); ++k) {
-      OpenFDM::NodeInstance* nodeInstance;
-      nodeInstance = new OpenFDM::NodeInstance((*k)->mSampleTime,
-                                               (*k)->getNode());
-      (*k)->mAbstractNodeInstance = nodeInstance;
     }
-    }
-
-    // alloc port values
-    InstanceMap::const_iterator i;
-    for (i = mInstanceMap.begin(); i != mInstanceMap.end(); ++i) {
-      if (!i->second->allocPortValues())
-          return false;
-    }
     
     // check port values and report unconnected mandatory values.
     for (i = mInstanceMap.begin(); i != mInstanceMap.end(); ++i) {
@@ -1141,7 +1150,7 @@
   NodeInstanceCollector::InstanceMap::const_iterator i;
   for (i = nodeInstanceCollector.mInstanceMap.begin();
        i != nodeInstanceCollector.mInstanceMap.end(); ++i) {
-    mNodeInstanceMap[i->first] = i->second->getAbstractNodeInstance();
+    mNodeInstanceMap[i->first] = i->second->newNodeInstance();
   }
 
   SystemOutputList::const_iterator j;



From frohlich at mail.berlios.de  Tue Nov 11 19:22:47 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Tue, 11 Nov 2008 19:22:47 +0100
Subject: [OpenFDM-svn] r715 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811111822.mABIMlK1020519@sheep.berlios.de>

Author: frohlich
Date: 2008-11-11 19:22:46 +0100 (Tue, 11 Nov 2008)
New Revision: 715

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
Log:
Now we ended up with a correct bootstrap order.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-11 18:00:50 UTC (rev 714)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-11 18:22:46 UTC (rev 715)
@@ -22,6 +22,26 @@
 namespace OpenFDM {
 
 
+/// System bootstrap:
+///
+/// The first step is to collect all the structural and leaf nodes in
+/// the whole system. For each instance we have a data struct that
+/// references such a model.
+/// During that traversal, the port connections are assigned and connected
+/// port values get a single data structure assigned, that is used to
+/// distribute port values to the model nodes.
+/// Models and mechanic nodes are sorted according to their direct input
+/// dependencies and parent child relationship for mechanic nodes.
+/// Then the port values itself are allocated.
+/// Models are checkd for unset port values.
+/// Past that, the contexts are allocated. This allocation is delegated to the
+/// leaf model nodes so that they can alloacte contexts dependent of the port
+/// values that are actually attached to the model.
+/// Once this is done, the models are distributed to the actual execution lists
+/// and AbstractNodeInstance's are allocated to reflect the ready to run
+/// System to the user.
+///
+///
 /// Evaluation orders:
 ///
 /// Initialization:
@@ -498,9 +518,21 @@
     {
       OpenFDMAssert(!mModelContext);
       mModelContext = mModel->newModelContext();
+      if (!mModelContext) {
+        Log(Schedule, Warning) << "Could not create context for model \""
+                               << getNodeNamePath() << "\"" << endl;
+        return false;
+      }
       OpenFDMAssert(mModel->getNumPorts() == mPortDataVector.size());
       for (unsigned i = 0; i < mModel->getNumPorts(); ++i)
-        mModelContext->setPortValue(*mModel->getPort(i), mPortValueList.getPortValue(i));
+        mModelContext->setPortValue(*mModel->getPort(i),
+                                    mPortValueList.getPortValue(i));
+      if (!mModelContext->alloc()) {
+        Log(Schedule, Warning) << "Could not alloc for model \""
+                               << getNodeNamePath() << "\"" << endl;
+        return false;
+      }
+      return true;
     }
 
     virtual AbstractNodeInstance* newNodeInstance()
@@ -527,9 +559,23 @@
     {
       OpenFDMAssert(!mMechanicContext);
       mMechanicContext = getNode()->newMechanicContext();
+      if (!mMechanicContext) {
+        Log(Schedule, Warning) << "Could not create context for mechanic "
+                               << "node \"" << getNodeNamePath()
+                               << "\"" << endl;
+        return false;
+      }
       OpenFDMAssert(getNode()->getNumPorts() == mPortDataVector.size());
       for (unsigned i = 0; i < getNode()->getNumPorts(); ++i)
-        mMechanicContext->setPortValue(*getNode()->getPort(i), mPortValueList.getPortValue(i));
+        mMechanicContext->setPortValue(*getNode()->getPort(i),
+                                       mPortValueList.getPortValue(i));
+      if (!mMechanicContext->alloc()) {
+        Log(Schedule, Warning) << "Could not alloc for mechanic "
+                               << "node \"" << getNodeNamePath()
+                               << "\"" << endl;
+        return false;
+      }
+      return true;
     }
 
     virtual AbstractNodeInstance* newNodeInstance()
@@ -834,14 +880,10 @@
     // The model instances are sorted to match the direct input property
     if (!sortModelList())
       return 0;
-    // Allocates and distributes the PortValues, is required for the sort
-    // steps below
-    if (!allocPortValues())
+    // Allocates and distributes the PortValues, check for unassigned ports
+    // and allocate contexts.
+    if (!createContexts())
       return 0;
-    // Now that they are sorted, allocate the port sizes and with that
-    // knowledge the state values.
-    if (!allocModels())
-      return 0;
 
     real_type basicSampleTime = 0.01; // FIXME in this case just continous
     if (mBasicSampleTime.isDiscrete())
@@ -1034,7 +1076,7 @@
   }
 
   bool
-  allocPortValues()
+  createContexts()
   {
     // alloc port values
     InstanceMap::const_iterator i;
@@ -1043,19 +1085,6 @@
           return false;
     }
 
-    {
-    ModelInstanceList::const_iterator i;
-    for (i = mModelInstanceList.begin(); i != mModelInstanceList.end(); ++i) {
-      (*i)->createModelContext();
-    }
-
-    MechanicInstanceList::const_iterator j;
-    for (j = mMechanicInstanceList.begin();
-         j != mMechanicInstanceList.end(); ++j) {
-      (*j)->createMechanicContext();
-    }
-    }
-    
     // check port values and report unconnected mandatory values.
     for (i = mInstanceMap.begin(); i != mInstanceMap.end(); ++i) {
       const Node* node = i->second->getNode();
@@ -1072,29 +1101,23 @@
         }
       }
     }
-    return true;
-  }
 
-  bool allocModels()
-  {
-    ModelInstanceList::const_iterator i;
-    for (i = mModelInstanceList.begin(); i != mModelInstanceList.end(); ++i) {
-      if (!(*i)->mModelContext->alloc()) {
-        Log(Schedule, Warning) << "Could not alloc for model \""
-                             << (*i)->getNodeNamePath() << "\"" << endl;
+    // Create the contexts
+    // This happens past the port values are assigned, this way models can
+    // create different kind of contexts based on the type of port values.
+    ModelInstanceList::const_iterator j;
+    for (j = mModelInstanceList.begin(); j != mModelInstanceList.end(); ++j) {
+      if (!(*j)->createModelContext())
         return false;
-      }
     }
 
-    MechanicInstanceList::const_iterator j;
-    for (j = mMechanicInstanceList.begin();
-         j != mMechanicInstanceList.end(); ++j) {
-      if (!(*j)->mMechanicContext->alloc()) {
-        Log(Schedule, Warning) << "Could not alloc for MechanicNode \""
-                             << (*j)->getNodeNamePath() << "\"" << endl;
+    MechanicInstanceList::const_iterator k;
+    for (k = mMechanicInstanceList.begin();
+         k != mMechanicInstanceList.end(); ++k) {
+      if (!(*k)->createMechanicContext())
         return false;
-      }
     }
+
     return true;
   }
 };



From frohlich at mail.berlios.de  Tue Nov 11 19:49:05 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Tue, 11 Nov 2008 19:49:05 +0100
Subject: [OpenFDM-svn] r716 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811111849.mABIn5I7018919@sheep.berlios.de>

Author: frohlich
Date: 2008-11-11 19:49:04 +0100 (Tue, 11 Nov 2008)
New Revision: 716

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Group.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/LibraryNode.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Model.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Model.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Node.h
Log:
Remove Node::newNodeContext and derived.

M    src/OpenFDM/Group.h
M    src/OpenFDM/Model.h
M    src/OpenFDM/LibraryNode.h
M    src/OpenFDM/MechanicNode.cpp
M    src/OpenFDM/Model.cpp
M    src/OpenFDM/Node.h
M    src/OpenFDM/MechanicNode.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Group.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Group.h	2008-11-11 18:22:46 UTC (rev 715)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Group.h	2008-11-11 18:49:04 UTC (rev 716)
@@ -30,9 +30,6 @@
     visitor.handleNodePathAndApply(this);
   }
 
-  virtual AbstractNodeContext* newNodeContext() const
-  { return 0; }
-
   unsigned getExternalPortIndex() const
   { return mExternalPortInfo->getIndex(); }
 protected:
@@ -128,9 +125,6 @@
   void traverse(NodeVisitor& visitor);
   void traverse(ConstNodeVisitor& visitor) const;
 
-  virtual AbstractNodeContext* newNodeContext() const
-  { return 0; }
-
   NodeId addChild(const SharedPtr<Node>& node);
   unsigned getNumChildren() const;
   SharedPtr<Node> getChild(unsigned i);

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/LibraryNode.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/LibraryNode.h	2008-11-11 18:22:46 UTC (rev 715)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/LibraryNode.h	2008-11-11 18:49:04 UTC (rev 716)
@@ -21,9 +21,6 @@
   virtual void accept(NodeVisitor& visitor);
   virtual void accept(ConstNodeVisitor& visitor) const;
 
-  virtual AbstractNodeContext* newNodeContext() const
-  { OpenFDMAssert(false); return 0; }
-
   // FIXME: Hmm, how do we map ports??
   // May be the Node just gets virtuals for ports???
   // May be changing ports means informing the parent about that???

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.cpp	2008-11-11 18:22:46 UTC (rev 715)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.cpp	2008-11-11 18:49:04 UTC (rev 716)
@@ -34,10 +34,4 @@
   visitor.handleNodePathAndApply(this);
 }
 
-AbstractNodeContext*
-MechanicNode::newNodeContext() const
-{
-  return newMechanicContext();
-}
-
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.h	2008-11-11 18:22:46 UTC (rev 715)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.h	2008-11-11 18:49:04 UTC (rev 716)
@@ -51,7 +51,6 @@
   virtual void accept(NodeVisitor& visitor);
   virtual void accept(ConstNodeVisitor& visitor) const;
 
-  virtual AbstractNodeContext* newNodeContext() const;
   virtual MechanicContext* newMechanicContext() const = 0;
 
 protected:

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Model.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Model.cpp	2008-11-11 18:22:46 UTC (rev 715)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Model.cpp	2008-11-11 18:49:04 UTC (rev 716)
@@ -35,12 +35,6 @@
   visitor.handleNodePathAndApply(this);
 }
 
-AbstractNodeContext*
-Model::newNodeContext() const
-{
-  return newModelContext();
-}
-
 ModelContext*
 Model::newModelContext() const
 {

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Model.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Model.h	2008-11-11 18:22:46 UTC (rev 715)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Model.h	2008-11-11 18:49:04 UTC (rev 716)
@@ -35,7 +35,6 @@
   virtual void accept(NodeVisitor& visitor);
   virtual void accept(ConstNodeVisitor& visitor) const;
 
-  virtual AbstractNodeContext* newNodeContext() const;
   virtual ModelContext* newModelContext() const;
 
   // FIXME: May be we want to collapse all state values in one

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Node.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Node.h	2008-11-11 18:22:46 UTC (rev 715)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Node.h	2008-11-11 18:49:04 UTC (rev 716)
@@ -62,9 +62,6 @@
   /// Return all node paths this Node is currently attached to.
   NodePathList getNodePathList() const;
 
-  /// Hmm, here or in the leaf stuff:
-  virtual AbstractNodeContext* newNodeContext() const = 0;
-
   static std::string toNodePathName(const NodePath& nodePath)
   {
     if (nodePath.empty())



From frohlich at mail.berlios.de  Tue Nov 11 20:09:35 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Tue, 11 Nov 2008 20:09:35 +0100
Subject: [OpenFDM-svn] r717 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811111909.mABJ9ZOp021361@sheep.berlios.de>

Author: frohlich
Date: 2008-11-11 20:09:34 +0100 (Tue, 11 Nov 2008)
New Revision: 717

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Model.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Model.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
Log:
Move PortValue assignment and context alloc into the context allocation method.

M    src/OpenFDM/Model.h
M    src/OpenFDM/System.cpp
M    src/OpenFDM/Model.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Model.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Model.cpp	2008-11-11 18:49:04 UTC (rev 716)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Model.cpp	2008-11-11 19:09:34 UTC (rev 717)
@@ -36,9 +36,25 @@
 }
 
 ModelContext*
-Model::newModelContext() const
+Model::newModelContext(PortValueList& portValueList) const
 {
-  return new ModelContext(this);
+  SharedPtr<ModelContext> context = new ModelContext(this);
+  for (unsigned i = 0; i < getNumPorts(); ++i) {
+    PortValue* portValue = portValueList.getPortValue(i);
+    if (!portValue) {
+      Log(Model, Error) << "No port value given for model \"" << getName()
+                        << "\" and port \"" << getPort(i)->getName()
+                        << "\"" << endl;
+      return false;
+    }
+    context->setPortValue(*getPort(i), portValue);
+  }
+  if (!context->alloc()) {
+    Log(Model, Warning) << "Could not alloc for model \""
+                        << getName() << "\"" << endl;
+    return false;
+  }
+  return context.release();
 }
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Model.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Model.h	2008-11-11 18:49:04 UTC (rev 716)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Model.h	2008-11-11 19:09:34 UTC (rev 717)
@@ -35,7 +35,7 @@
   virtual void accept(NodeVisitor& visitor);
   virtual void accept(ConstNodeVisitor& visitor) const;
 
-  virtual ModelContext* newModelContext() const;
+  virtual ModelContext* newModelContext(PortValueList& portValueList) const;
 
   // FIXME: May be we want to collapse all state values in one
   // argument? May be it is sufficient to have a const and non const version??

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-11 18:49:04 UTC (rev 716)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-11 19:09:34 UTC (rev 717)
@@ -517,21 +517,12 @@
     bool createModelContext()
     {
       OpenFDMAssert(!mModelContext);
-      mModelContext = mModel->newModelContext();
+      mModelContext = mModel->newModelContext(mPortValueList);
       if (!mModelContext) {
         Log(Schedule, Warning) << "Could not create context for model \""
                                << getNodeNamePath() << "\"" << endl;
         return false;
       }
-      OpenFDMAssert(mModel->getNumPorts() == mPortDataVector.size());
-      for (unsigned i = 0; i < mModel->getNumPorts(); ++i)
-        mModelContext->setPortValue(*mModel->getPort(i),
-                                    mPortValueList.getPortValue(i));
-      if (!mModelContext->alloc()) {
-        Log(Schedule, Warning) << "Could not alloc for model \""
-                               << getNodeNamePath() << "\"" << endl;
-        return false;
-      }
       return true;
     }
 



From frohlich at mail.berlios.de  Tue Nov 11 20:37:05 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Tue, 11 Nov 2008 20:37:05 +0100
Subject: [OpenFDM-svn] r718 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811111937.mABJb510023956@sheep.berlios.de>

Author: frohlich
Date: 2008-11-11 20:37:04 +0100 (Tue, 11 Nov 2008)
New Revision: 718

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Joint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Joint.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/RigidBody.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/RigidBody.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
Log:
Move context creation into the mechanic models.

M    src/OpenFDM/Joint.cpp
M    src/OpenFDM/RigidBody.cpp
M    src/OpenFDM/Interact.cpp
M    src/OpenFDM/System.cpp
M    src/OpenFDM/Interact.h
M    src/OpenFDM/RigidBody.h
M    src/OpenFDM/MechanicNode.h
M    src/OpenFDM/Joint.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.cpp	2008-11-11 19:09:34 UTC (rev 717)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.cpp	2008-11-11 19:37:04 UTC (rev 718)
@@ -86,4 +86,26 @@
   return new Context(this);
 }
 
+MechanicContext*
+Interact::newMechanicContext(PortValueList& portValueList) const
+{
+  SharedPtr<MechanicContext> context = newMechanicContext();
+  for (unsigned i = 0; i < getNumPorts(); ++i) {
+    PortValue* portValue = portValueList.getPortValue(i);
+    if (!portValue) {
+      Log(Model, Error) << "No port value given for model \"" << getName()
+                        << "\" and port \"" << getPort(i)->getName()
+                        << "\"" << endl;
+      return false;
+    }
+    context->setPortValue(*getPort(i), portValue);
+  }
+  if (!context->alloc()) {
+    Log(Model, Warning) << "Could not alloc for model \""
+                        << getName() << "\"" << endl;
+    return false;
+  }
+  return context.release();
+}
+
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.h	2008-11-11 19:09:34 UTC (rev 717)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.h	2008-11-11 19:37:04 UTC (rev 718)
@@ -19,6 +19,7 @@
   virtual void accept(NodeVisitor& visitor);
   virtual void accept(ConstNodeVisitor& visitor) const;
 
+  virtual MechanicContext* newMechanicContext(PortValueList& portValues) const;
   virtual MechanicContext* newMechanicContext() const;
 
   virtual void velocity(const Task&, const ContinousStateValueVector&,

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Joint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Joint.cpp	2008-11-11 19:09:34 UTC (rev 717)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Joint.cpp	2008-11-11 19:37:04 UTC (rev 718)
@@ -43,4 +43,26 @@
   visitor.handleNodePathAndApply(this);
 }
 
+MechanicContext*
+Joint::newMechanicContext(PortValueList& portValueList) const
+{
+  SharedPtr<MechanicContext> context = newMechanicContext();
+  for (unsigned i = 0; i < getNumPorts(); ++i) {
+    PortValue* portValue = portValueList.getPortValue(i);
+    if (!portValue) {
+      Log(Model, Error) << "No port value given for model \"" << getName()
+                        << "\" and port \"" << getPort(i)->getName()
+                        << "\"" << endl;
+      return false;
+    }
+    context->setPortValue(*getPort(i), portValue);
+  }
+  if (!context->alloc()) {
+    Log(Model, Warning) << "Could not alloc for model \""
+                        << getName() << "\"" << endl;
+    return false;
+  }
+  return context.release();
+}
+
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Joint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Joint.h	2008-11-11 19:09:34 UTC (rev 717)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Joint.h	2008-11-11 19:37:04 UTC (rev 718)
@@ -26,6 +26,9 @@
 
   virtual void accept(NodeVisitor& visitor);
   virtual void accept(ConstNodeVisitor& visitor) const;
+
+  virtual MechanicContext* newMechanicContext(PortValueList& portValues) const;
+  virtual MechanicContext* newMechanicContext() const = 0;
 };
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.h	2008-11-11 19:09:34 UTC (rev 717)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.h	2008-11-11 19:37:04 UTC (rev 718)
@@ -51,8 +51,6 @@
   virtual void accept(NodeVisitor& visitor);
   virtual void accept(ConstNodeVisitor& visitor) const;
 
-  virtual MechanicContext* newMechanicContext() const = 0;
-
 protected:
   MechanicLink newMechanicLink(const std::string& name)
   { return MechanicLink(this, name); }

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RigidBody.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RigidBody.cpp	2008-11-11 19:09:34 UTC (rev 717)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RigidBody.cpp	2008-11-11 19:37:04 UTC (rev 718)
@@ -11,36 +11,6 @@
 
 namespace OpenFDM {
 
-class RigidBody::Context : public MechanicContext {
-public:
-  Context(const RigidBody* rigidBody) : mRigidBody(rigidBody) {}
-  virtual ~Context() {}
-
-  virtual const RigidBody& getNode() const
-  { return *mRigidBody; }
-
-  virtual bool alloc()
-  { if (!allocStates()) return false; return mRigidBody->alloc(*this); }
-  virtual void initVelocities(const /*Init*/Task& task)
-  {
-    mRigidBody->init(task, mDiscreteState, mContinousState, mPortValueList);
-  }
-
-  virtual void velocities(const Task& task)
-  { }
-  virtual void articulation(const Task& task)
-  { }
-  virtual void accelerations(const Task& task)
-  { }
-  virtual void derivative(const Task&)
-  { }
-  virtual void update(const DiscreteTask&)
-  { }
-
-private:
-  SharedPtr<const RigidBody> mRigidBody;
-};
-
 BEGIN_OPENFDM_OBJECT_DEF(RigidBody, MechanicNode)
   END_OPENFDM_OBJECT_DEF
 
@@ -67,12 +37,6 @@
   visitor.handleNodePathAndApply(this);
 }
 
-MechanicContext*
-RigidBody::newMechanicContext() const
-{
-  return new Context(this);
-}
-
 PortId
 RigidBody::addLink(const std::string& name)
 {

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RigidBody.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RigidBody.h	2008-11-11 19:09:34 UTC (rev 717)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RigidBody.h	2008-11-11 19:37:04 UTC (rev 718)
@@ -19,14 +19,10 @@
   virtual void accept(NodeVisitor& visitor);
   virtual void accept(ConstNodeVisitor& visitor) const;
 
-  virtual MechanicContext* newMechanicContext() const;
-
   PortId addLink(const std::string& name);
   void removeLink(const PortId& portId);
 
 private:
-  class Context;
-
   typedef std::vector<MechanicLink> MechanicLinkVector;
   MechanicLinkVector mMechanicLinks;
 };

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-11 19:09:34 UTC (rev 717)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-11 19:37:04 UTC (rev 718)
@@ -546,28 +546,7 @@
     { }
     virtual const MechanicNode* getNode() const = 0;
 
-    bool createMechanicContext()
-    {
-      OpenFDMAssert(!mMechanicContext);
-      mMechanicContext = getNode()->newMechanicContext();
-      if (!mMechanicContext) {
-        Log(Schedule, Warning) << "Could not create context for mechanic "
-                               << "node \"" << getNodeNamePath()
-                               << "\"" << endl;
-        return false;
-      }
-      OpenFDMAssert(getNode()->getNumPorts() == mPortDataVector.size());
-      for (unsigned i = 0; i < getNode()->getNumPorts(); ++i)
-        mMechanicContext->setPortValue(*getNode()->getPort(i),
-                                       mPortValueList.getPortValue(i));
-      if (!mMechanicContext->alloc()) {
-        Log(Schedule, Warning) << "Could not alloc for mechanic "
-                               << "node \"" << getNodeNamePath()
-                               << "\"" << endl;
-        return false;
-      }
-      return true;
-    }
+    virtual bool createMechanicContext() = 0;
 
     virtual AbstractNodeInstance* newNodeInstance()
     {
@@ -611,6 +590,18 @@
       mJoint(&joint)
     { }
     virtual const Joint* getNode() const { return mJoint; }
+    virtual bool createMechanicContext()
+    {
+      OpenFDMAssert(!mMechanicContext);
+      mMechanicContext = getNode()->newMechanicContext(mPortValueList);
+      if (!mMechanicContext) {
+        Log(Schedule, Warning) << "Could not create context for mechanic "
+                               << "node \"" << getNodeNamePath()
+                               << "\"" << endl;
+        return false;
+      }
+      return true;
+    }
   private:
     SharedPtr<const Joint> mJoint;
   };
@@ -621,6 +612,18 @@
       mInteract(&interact)
     { }
     virtual const Interact* getNode() const { return mInteract; }
+    virtual bool createMechanicContext()
+    {
+      OpenFDMAssert(!mMechanicContext);
+      mMechanicContext = getNode()->newMechanicContext(mPortValueList);
+      if (!mMechanicContext) {
+        Log(Schedule, Warning) << "Could not create context for mechanic "
+                               << "node \"" << getNodeNamePath()
+                               << "\"" << endl;
+        return false;
+      }
+      return true;
+    }
   private:
     SharedPtr<const Interact> mInteract;
   };



From frohlich at mail.berlios.de  Tue Nov 11 21:00:03 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Tue, 11 Nov 2008 21:00:03 +0100
Subject: [OpenFDM-svn] r719 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811112000.mABK03GV027248@sheep.berlios.de>

Author: frohlich
Date: 2008-11-11 21:00:02 +0100 (Tue, 11 Nov 2008)
New Revision: 719

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Joint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Joint.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.h
Log:
Move context allocation further into the mechanic models.

M    src/OpenFDM/Joint.cpp
M    src/OpenFDM/CartesianJoint.h
M    src/OpenFDM/Interact.cpp
M    src/OpenFDM/RootJoint.h
M    src/OpenFDM/RootJoint.cpp
M    src/OpenFDM/Interact.h
M    src/OpenFDM/Joint.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h	2008-11-11 19:37:04 UTC (rev 718)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h	2008-11-11 20:00:02 UTC (rev 719)
@@ -26,8 +26,26 @@
   typedef LinAlg::Matrix<real_type,n,n> MatrixNN;
   typedef LinAlg::MatrixFactors<real_type,n,n,LinAlg::LUTag> MatrixFactorsNN;
 
-  virtual MechanicContext* newMechanicContext() const
-  { return new Context(this); }
+  virtual MechanicContext* newMechanicContext(PortValueList& portValueList) const
+  {
+    SharedPtr<MechanicContext> context = new Context(this);
+    for (unsigned i = 0; i < getNumPorts(); ++i) {
+      PortValue* portValue = portValueList.getPortValue(i);
+      if (!portValue) {
+        Log(Model, Error) << "No port value given for model \"" << getName()
+                          << "\" and port \"" << getPort(i)->getName()
+                          << "\"" << endl;
+        return false;
+      }
+      context->setPortValue(*getPort(i), portValue);
+    }
+    if (!context->alloc()) {
+      Log(Model, Warning) << "Could not alloc for model \""
+                          << getName() << "\"" << endl;
+      return false;
+    }
+    return context.release();
+  }
 
 protected:
   CartesianJoint(const std::string& name) :

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.cpp	2008-11-11 19:37:04 UTC (rev 718)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.cpp	2008-11-11 20:00:02 UTC (rev 719)
@@ -81,15 +81,9 @@
 }
 
 MechanicContext*
-Interact::newMechanicContext() const
-{
-  return new Context(this);
-}
-
-MechanicContext*
 Interact::newMechanicContext(PortValueList& portValueList) const
 {
-  SharedPtr<MechanicContext> context = newMechanicContext();
+  SharedPtr<MechanicContext> context = new Context(this);
   for (unsigned i = 0; i < getNumPorts(); ++i) {
     PortValue* portValue = portValueList.getPortValue(i);
     if (!portValue) {

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.h	2008-11-11 19:37:04 UTC (rev 718)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.h	2008-11-11 20:00:02 UTC (rev 719)
@@ -20,7 +20,6 @@
   virtual void accept(ConstNodeVisitor& visitor) const;
 
   virtual MechanicContext* newMechanicContext(PortValueList& portValues) const;
-  virtual MechanicContext* newMechanicContext() const;
 
   virtual void velocity(const Task&, const ContinousStateValueVector&,
                         PortValueList&) const

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Joint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Joint.cpp	2008-11-11 19:37:04 UTC (rev 718)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Joint.cpp	2008-11-11 20:00:02 UTC (rev 719)
@@ -43,26 +43,4 @@
   visitor.handleNodePathAndApply(this);
 }
 
-MechanicContext*
-Joint::newMechanicContext(PortValueList& portValueList) const
-{
-  SharedPtr<MechanicContext> context = newMechanicContext();
-  for (unsigned i = 0; i < getNumPorts(); ++i) {
-    PortValue* portValue = portValueList.getPortValue(i);
-    if (!portValue) {
-      Log(Model, Error) << "No port value given for model \"" << getName()
-                        << "\" and port \"" << getPort(i)->getName()
-                        << "\"" << endl;
-      return false;
-    }
-    context->setPortValue(*getPort(i), portValue);
-  }
-  if (!context->alloc()) {
-    Log(Model, Warning) << "Could not alloc for model \""
-                        << getName() << "\"" << endl;
-    return false;
-  }
-  return context.release();
-}
-
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Joint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Joint.h	2008-11-11 19:37:04 UTC (rev 718)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Joint.h	2008-11-11 20:00:02 UTC (rev 719)
@@ -27,8 +27,7 @@
   virtual void accept(NodeVisitor& visitor);
   virtual void accept(ConstNodeVisitor& visitor) const;
 
-  virtual MechanicContext* newMechanicContext(PortValueList& portValues) const;
-  virtual MechanicContext* newMechanicContext() const = 0;
+  virtual MechanicContext* newMechanicContext(PortValueList& portValues) const = 0;
 };
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.cpp	2008-11-11 19:37:04 UTC (rev 718)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.cpp	2008-11-11 20:00:02 UTC (rev 719)
@@ -67,9 +67,25 @@
 }
 
 MechanicContext*
-RootJoint::newMechanicContext() const
+RootJoint::newMechanicContext(PortValueList& portValueList) const
 {
-  return new Context(this);
+  SharedPtr<MechanicContext> context = new Context(this);
+  for (unsigned i = 0; i < getNumPorts(); ++i) {
+    PortValue* portValue = portValueList.getPortValue(i);
+    if (!portValue) {
+      Log(Model, Error) << "No port value given for model \"" << getName()
+                        << "\" and port \"" << getPort(i)->getName()
+                        << "\"" << endl;
+      return false;
+    }
+    context->setPortValue(*getPort(i), portValue);
+  }
+  if (!context->alloc()) {
+    Log(Model, Warning) << "Could not alloc for model \""
+                        << getName() << "\"" << endl;
+    return false;
+  }
+  return context.release();
 }
 
 void

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.h	2008-11-11 19:37:04 UTC (rev 718)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.h	2008-11-11 20:00:02 UTC (rev 719)
@@ -16,7 +16,7 @@
   RootJoint(const std::string& name);
   virtual ~RootJoint();
 
-  virtual MechanicContext* newMechanicContext() const;
+  virtual MechanicContext* newMechanicContext(PortValueList& portValueList) const;
 
   virtual void accept(NodeVisitor& visitor);
   virtual void accept(ConstNodeVisitor& visitor) const;



From frohlich at mail.berlios.de  Tue Nov 11 21:16:29 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Tue, 11 Nov 2008 21:16:29 +0100
Subject: [OpenFDM-svn] r720 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811112016.mABKGTvA030652@sheep.berlios.de>

Author: frohlich
Date: 2008-11-11 21:16:28 +0100 (Tue, 11 Nov 2008)
New Revision: 720

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
Log:
Fix some naming ambiquity.

M    src/OpenFDM/System.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-11 20:00:02 UTC (rev 719)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-11 20:16:28 UTC (rev 720)
@@ -250,7 +250,7 @@
     mBasicSampleTime(SampleTime::getContinous())
   { }
 
-  struct Instance;
+  struct InstanceData;
   struct PortData;
 
   struct PortConnectSet : public Referenced {
@@ -269,9 +269,9 @@
 
   struct PortData : public WeakReferenced {
   public:
-    PortData(Instance* instance, const PortInfo* portInfo,
+    PortData(InstanceData* instanceData, const PortInfo* portInfo,
              bool valueCreator = true) :
-      mInstance(instance),
+      mInstanceData(instanceData),
       mPortInfo(portInfo),
       mPortValueCreator(valueCreator)
     {
@@ -290,7 +290,8 @@
       }
       // Merge the port sets together ...
       while (!mPortConnectSet->mParentPortData.empty()) {
-        SharedPtr<PortData> portData = mPortConnectSet->mParentPortData.back().lock();
+        SharedPtr<PortData> portData;
+        portData = mPortConnectSet->mParentPortData.back().lock();
         mPortConnectSet->mParentPortData.pop_back();
         if (portData == this)
           continue;
@@ -341,8 +342,8 @@
     {
       if (!getPortInfo())
         return false;
-      SharedPtr<Instance> instance = mInstance.lock();
-      if (!instance)
+      SharedPtr<InstanceData> instanceData = mInstanceData.lock();
+      if (!instanceData)
         return false;
       Log(Schedule, Debug3)
         << "setPortValue for port \"" << getPortInfo()->getName()
@@ -350,7 +351,7 @@
       // FIXME: move the set port value and accept port value into one call
       if (!getPortInfo()->acceptPortValue(portValue))
         return false;
-      instance->setPortValue(*getPortInfo(), portValue);
+      instanceData->setPortValue(*getPortInfo(), portValue);
       return true;
     }
 
@@ -369,11 +370,11 @@
     {
       if (!mPortValueCreator)
         return true;
-      SharedPtr<Instance> instance = mInstance.lock();
-      if (!instance)
+      SharedPtr<InstanceData> instanceData = mInstanceData.lock();
+      if (!instanceData)
         return false;
       // FIXME
-      if (instance->getPortValue(*getPortInfo()))
+      if (instanceData->getPortValue(*getPortInfo()))
         return true;
       SharedPtr<PortValue> portValue = getPortInfo()->newValue();
       if (!portValue)
@@ -384,16 +385,16 @@
     }
 
   private:
-    WeakPtr<Instance> mInstance;
+    WeakPtr<InstanceData> mInstanceData;
     SharedPtr<const PortInfo> mPortInfo;
     std::vector<WeakPtr<PortData> > mConnectedPorts;
     SharedPtr<PortConnectSet> mPortConnectSet;
     bool mPortValueCreator;
   };
 
-  struct Instance : public WeakReferenced {
-    Instance(const Node& node, const NodePath& nodePath,
-             const SampleTime& sampleTime) :
+  struct InstanceData : public WeakReferenced {
+    InstanceData(const Node& node, const NodePath& nodePath,
+                 const SampleTime& sampleTime) :
       mNodePath(nodePath),
       mSampleTime(sampleTime)
     {
@@ -402,7 +403,7 @@
       for (unsigned i = 0; i < numPorts; ++i)
         mPortDataVector.push_back(new PortData(this, node.getPort(i)));
     }
-    virtual ~Instance()
+    virtual ~InstanceData()
     { }
     virtual const Node* getNode() const = 0;
     virtual AbstractNodeInstance* newNodeInstance() = 0;
@@ -423,7 +424,8 @@
       return mPortValueList.getPortValue(portInfo);
     }
 
-    bool dependsOn(const Instance& instance, bool acceleration = false) const
+    bool
+    dependsOn(const InstanceData& instance, bool acceleration = false) const
     {
       unsigned numPorts = getNode()->getNumPorts();
       for (unsigned i = 0; i < numPorts; ++i) {
@@ -467,9 +469,9 @@
                               << "\"" << endl;
         if (!mPortDataVector[i]->createPortValue()) {
           Log(Schedule, Warning) << "Failed to allocate port value \""
-                               << mPortDataVector[i]->getPortInfo()->getName()
-                               << "\" of \"" << getNodeNamePath()
-                               << "\".\nAborting!" << endl;
+                                 << mPortDataVector[i]->getPortInfo()->getName()
+                                 << "\" of \"" << getNodeNamePath()
+                                 << "\".\nAborting!" << endl;
 
           return false;
         }
@@ -477,6 +479,10 @@
       return true;
     }
 
+    const SampleTime& getSampleTime() const
+    { return mSampleTime; }
+
+  protected:
     const NodePath mNodePath;
     const SampleTime mSampleTime;
 
@@ -486,17 +492,17 @@
     PortValueList mPortValueList;
   };
 
-  struct NodeInstance : public Instance {
-    NodeInstance(const Node& node, const NodePath& nodePath,
-                  const SampleTime& sampleTime) :
-      Instance(node, nodePath, sampleTime),
+  struct NodeInstanceData : public InstanceData {
+    NodeInstanceData(const Node& node, const NodePath& nodePath,
+                     const SampleTime& sampleTime) :
+      InstanceData(node, nodePath, sampleTime),
       mNode(&node)
     { }
     virtual const Node* getNode() const { return mNode; }
     virtual AbstractNodeInstance* newNodeInstance()
     {
-      OpenFDM::NodeInstance* nodeInstance;
-      nodeInstance = new OpenFDM::NodeInstance(mSampleTime, getNode());
+      NodeInstance* nodeInstance;
+      nodeInstance = new NodeInstance(mSampleTime, getNode());
       OpenFDMAssert(mNode->getNumPorts() == mPortDataVector.size());
       for (unsigned i = 0; i < mNode->getNumPorts(); ++i)
         nodeInstance->setPortValue(*mNode->getPort(i),
@@ -506,10 +512,10 @@
   private:
     SharedPtr<const Node> mNode;
   };
-  struct ModelInstance : public Instance {
-    ModelInstance(const Model& model, const NodePath& nodePath,
-                  const SampleTime& sampleTime) :
-      Instance(model, nodePath, sampleTime),
+  struct ModelInstanceData : public InstanceData {
+    ModelInstanceData(const Model& model, const NodePath& nodePath,
+                      const SampleTime& sampleTime) :
+      InstanceData(model, nodePath, sampleTime),
       mModel(&model)
     { }
     virtual const Model* getNode() const { return mModel; }
@@ -528,21 +534,21 @@
 
     virtual AbstractNodeInstance* newNodeInstance()
     {
-      return new OpenFDM::LeafInstance(mSampleTime, mModelContext);
+      return new LeafInstance(mSampleTime, mModelContext);
     }
 
     ModelContext* getModelContext()
     { return mModelContext; }
 
-    SharedPtr<ModelContext> mModelContext;
-
   private:
     SharedPtr<const Model> mModel;
+    SharedPtr<ModelContext> mModelContext;
   };
-  struct MechanicInstance : public Instance {
-    MechanicInstance(const MechanicNode& mechanicNode, const NodePath& nodePath,
-                     const SampleTime& sampleTime) :
-      Instance(mechanicNode, nodePath, sampleTime)
+  struct MechanicInstanceData : public InstanceData {
+    MechanicInstanceData(const MechanicNode& mechanicNode,
+                         const NodePath& nodePath,
+                         const SampleTime& sampleTime) :
+      InstanceData(mechanicNode, nodePath, sampleTime)
     { }
     virtual const MechanicNode* getNode() const = 0;
 
@@ -550,15 +556,13 @@
 
     virtual AbstractNodeInstance* newNodeInstance()
     {
-      return new OpenFDM::LeafInstance(mSampleTime, mMechanicContext);
+      return new LeafInstance(mSampleTime, mMechanicContext);
     }
 
     MechanicContext* getMechanicContext()
     { return mMechanicContext; }
 
-    SharedPtr<MechanicContext> mMechanicContext;
-
-    bool isLinkedTo(const MechanicInstance& instance) const
+    bool isLinkedTo(const MechanicInstanceData& instance) const
     {
       unsigned numPorts = getNode()->getNumPorts();
       for (unsigned i = 0; i < numPorts; ++i) {
@@ -582,11 +586,13 @@
       }
       return false;
     }
+  protected:
+    SharedPtr<MechanicContext> mMechanicContext;
   };
-  struct JointInstance : public MechanicInstance {
-    JointInstance(const Joint& joint, const NodePath& nodePath,
-                  const SampleTime& sampleTime) :
-      MechanicInstance(joint, nodePath, sampleTime),
+  struct JointInstanceData : public MechanicInstanceData {
+    JointInstanceData(const Joint& joint, const NodePath& nodePath,
+                      const SampleTime& sampleTime) :
+      MechanicInstanceData(joint, nodePath, sampleTime),
       mJoint(&joint)
     { }
     virtual const Joint* getNode() const { return mJoint; }
@@ -605,10 +611,10 @@
   private:
     SharedPtr<const Joint> mJoint;
   };
-  struct InteractInstance : public MechanicInstance {
-    InteractInstance(const Interact& interact, const NodePath& nodePath,
-                     const SampleTime& sampleTime) :
-      MechanicInstance(interact, nodePath, sampleTime),
+  struct InteractInstanceData : public MechanicInstanceData {
+    InteractInstanceData(const Interact& interact, const NodePath& nodePath,
+                         const SampleTime& sampleTime) :
+      MechanicInstanceData(interact, nodePath, sampleTime),
       mInteract(&interact)
     { }
     virtual const Interact* getNode() const { return mInteract; }
@@ -628,12 +634,12 @@
     SharedPtr<const Interact> mInteract;
   };
 
-  void addInstance(Instance* instance)
+  void addInstanceData(InstanceData* instanceData)
   {
     // Add the instance to the per System instance map
-    mInstanceMap[getNodePath()] = instance;
+    mInstanceDataMap[getNodePath()] = instanceData;
     // Add the instance to the current groups instance list
-    mInstanceVector.push_back(instance);
+    mInstanceDataVector.push_back(instanceData);
   }
 
   virtual void apply(const Node& node)
@@ -647,13 +653,13 @@
 
   virtual void apply(const GroupInterfaceNode& node)
   {
-    SharedPtr<NodeInstance> instance;
-    instance = new NodeInstance(node, getNodePath(), mSampleTime);
-    addInstance(instance);
-    mNodeInstanceList.push_back(instance);
+    SharedPtr<NodeInstanceData> instanceData;
+    instanceData = new NodeInstanceData(node, getNodePath(), mSampleTime);
+    addInstanceData(instanceData);
+    mNodeInstanceDataList.push_back(instanceData);
 
     OpenFDMAssert(node.getPort(0));
-    PortData* portData = instance->getPortData(0);
+    PortData* portData = instanceData->getPortData(0);
     OpenFDMAssert(portData);
     portData->disablePortValueCreation();
     mGroupInterfacePortDataMap[node.getExternalPortIndex()] = portData;
@@ -663,24 +669,24 @@
   {
     // Need to store the root nodes to build up the spanning tree for the
     // mechanical system here.
-    SharedPtr<JointInstance> instance;
-    instance = new JointInstance(node, getNodePath(), mSampleTime);
-    addInstance(instance);
-    mRootJointInstanceList.push_back(instance);
+    SharedPtr<JointInstanceData> instanceData;
+    instanceData = new JointInstanceData(node, getNodePath(), mSampleTime);
+    addInstanceData(instanceData);
+    mRootJointInstanceDataList.push_back(instanceData);
   }
   virtual void apply(const Interact& node)
   {
-    SharedPtr<InteractInstance> instance;
-    instance = new InteractInstance(node, getNodePath(), mSampleTime);
-    addInstance(instance);
-    mInteractInstanceList.push_back(instance);
+    SharedPtr<InteractInstanceData> instanceData;
+    instanceData = new InteractInstanceData(node, getNodePath(), mSampleTime);
+    addInstanceData(instanceData);
+    mInteractInstanceDataList.push_back(instanceData);
   }
   virtual void apply(const RigidBody& node)
   {
-    SharedPtr<NodeInstance> instance;
-    instance = new NodeInstance(node, getNodePath(), mSampleTime);
-    addInstance(instance);
-    mNodeInstanceList.push_back(instance);
+    SharedPtr<NodeInstanceData> instanceData;
+    instanceData = new NodeInstanceData(node, getNodePath(), mSampleTime);
+    addInstanceData(instanceData);
+    mNodeInstanceDataList.push_back(instanceData);
 
     // Make all rigid mechanic body links use the same link value
     // FIXME, allocate them in this way!
@@ -689,40 +695,40 @@
       if (!node.getPort(i)->toMechanicLinkInfo())
         continue;
       if (portData) {
-        instance->getPortData(i)->setProxyPortData(portData);
-        instance->getPortData(i)->disablePortValueCreation();
+        instanceData->getPortData(i)->setProxyPortData(portData);
+        instanceData->getPortData(i)->disablePortValueCreation();
       } else {
-        portData = instance->getPortData(i);
+        portData = instanceData->getPortData(i);
         portData->disablePortValueCreation();
       }
     }
   }
   virtual void apply(const Joint& node)
   {
-    SharedPtr<JointInstance> instance;
-    instance = new JointInstance(node, getNodePath(), mSampleTime);
-    addInstance(instance);
-    mJointInstanceList.push_back(instance);
+    SharedPtr<JointInstanceData> instanceData;
+    instanceData = new JointInstanceData(node, getNodePath(), mSampleTime);
+    addInstanceData(instanceData);
+    mJointInstanceDataList.push_back(instanceData);
   }
   virtual void apply(const Model& node)
   {
-    SharedPtr<ModelInstance> instance;
-    instance = new ModelInstance(node, getNodePath(), mSampleTime);
-    addInstance(instance);
-    mModelInstanceList.push_back(instance);
+    SharedPtr<ModelInstanceData> instanceData;
+    instanceData = new ModelInstanceData(node, getNodePath(), mSampleTime);
+    addInstanceData(instanceData);
+    mModelInstanceDataList.push_back(instanceData);
   }
 
   virtual void apply(const Group& group)
   {
-    SharedPtr<NodeInstance> instance;
-    instance = new NodeInstance(group, getNodePath(), mSampleTime);
-    addInstance(instance);
-    mNodeInstanceList.push_back(instance);
+    SharedPtr<NodeInstanceData> instanceData;
+    instanceData = new NodeInstanceData(group, getNodePath(), mSampleTime);
+    addInstanceData(instanceData);
+    mNodeInstanceDataList.push_back(instanceData);
 
     // The vector of instances for this group.
-    InstanceVector parentInstanceVector;
-    parentInstanceVector.swap(mInstanceVector);
-    mInstanceVector.reserve(group.getNumChildren());
+    InstanceDataVector parentInstanceDataVector;
+    parentInstanceDataVector.swap(mInstanceDataVector);
+    mInstanceDataVector.reserve(group.getNumChildren());
 
     // Get PortDataList indexed by group port index
     GroupInterfacePortDataMap parentGroupInterfacePortDataMap;
@@ -780,20 +786,22 @@
       SharedPtr<const PortInfo> portInfo0 = group.getConnectPortInfo0(i);
       if (!portInfo0) {
         Log(Schedule, Error) << "Cannot find provider Port data node "
-                  << group.getChild(nodeIndex0)->getName() << std::endl;
+                             << group.getChild(nodeIndex0)->getName()
+                             << std::endl;
         continue;
       }
       SharedPtr<const PortInfo> portInfo1 = group.getConnectPortInfo1(i);
       if (!portInfo1) {
         Log(Schedule, Error) << "Cannot find acceptor Port data node "
-                  << group.getChild(nodeIndex1)->getName() << std::endl;
+                             << group.getChild(nodeIndex1)->getName()
+                             << std::endl;
         continue;
       }
 
       unsigned portInfoIndex0 = portInfo0->getIndex();
       unsigned portInfoIndex1 = portInfo1->getIndex();
-      if (!mInstanceVector[nodeIndex1]->getPortData(portInfoIndex1)->
-          connect(mInstanceVector[nodeIndex0]->getPortData(portInfoIndex0)))
+      if (!mInstanceDataVector[nodeIndex1]->getPortData(portInfoIndex1)->
+          connect(mInstanceDataVector[nodeIndex0]->getPortData(portInfoIndex0)))
         Log(Schedule, Error) << "Internal Error: Cannot connect ports that"
           " appeared to be compatible before." << std::endl;
     }
@@ -810,7 +818,7 @@
       }
 
       // Allocate a new port data struct in the parent.
-      PortData* parentPortData = instance->getPortData(i);
+      PortData* parentPortData = instanceData->getPortData(i);
       parentPortData->setProxyPortData(portData);
       portData->setProxyPortData(parentPortData);
       parentPortData->disablePortValueCreation();
@@ -819,39 +827,39 @@
 
     // We must have gained exactly this amount of instances while traversing
     // this group, so make sure it is like that ...
-    OpenFDMAssert(mInstanceVector.size() == group.getNumChildren());
+    OpenFDMAssert(mInstanceDataVector.size() == group.getNumChildren());
 
     // Pop the per group port connect info
     parentGroupInterfacePortDataMap.swap(mGroupInterfacePortDataMap);
-    parentInstanceVector.swap(mInstanceVector);
+    parentInstanceDataVector.swap(mInstanceDataVector);
   }
 
   ////////////////////////////////////////////////////////////////////////////
   // All instances in the system indexed by node path.
-  typedef std::map<NodePath, SharedPtr<Instance> > InstanceMap;
-  InstanceMap mInstanceMap;
+  typedef std::map<NodePath, SharedPtr<InstanceData> > InstanceDataMap;
+  InstanceDataMap mInstanceDataMap;
 
-  typedef std::list<SharedPtr<NodeInstance> > NodeInstanceList;
-  typedef std::list<SharedPtr<ModelInstance> > ModelInstanceList;
-  typedef std::list<SharedPtr<MechanicInstance> > MechanicInstanceList;
+  typedef std::list<SharedPtr<NodeInstanceData> > NodeInstanceDataList;
+  typedef std::list<SharedPtr<ModelInstanceData> > ModelInstanceDataList;
+  typedef std::list<SharedPtr<MechanicInstanceData> > MechanicInstanceDataList;
 
   // The list of Nodes that do not need a context for itself.
-  NodeInstanceList mNodeInstanceList;
+  NodeInstanceDataList mNodeInstanceDataList;
   // The Models list, worthwhile for sorting
-  ModelInstanceList mModelInstanceList;
+  ModelInstanceDataList mModelInstanceDataList;
   // The mechanical system list, also for sorting
-  MechanicInstanceList mMechanicInstanceList;
+  MechanicInstanceDataList mMechanicInstanceDataList;
 
   // The list of root nodes in the mechanical system. Will be a starting point
   // for sorting the tree of mechanical models downwards
-  MechanicInstanceList mRootJointInstanceList;
-  MechanicInstanceList mJointInstanceList;
-  MechanicInstanceList mInteractInstanceList;
+  MechanicInstanceDataList mRootJointInstanceDataList;
+  MechanicInstanceDataList mJointInstanceDataList;
+  MechanicInstanceDataList mInteractInstanceDataList;
 
   ////////////////////////////////////////////////////////////////////////////
   // Used to map connections in groups ...
-  typedef std::vector<SharedPtr<Instance> > InstanceVector;
-  InstanceVector mInstanceVector;
+  typedef std::vector<SharedPtr<InstanceData> > InstanceDataVector;
+  InstanceDataVector mInstanceDataVector;
   // Holds the PortDataList pointer indexed by parent groups port index
   typedef std::vector<SharedPtr<PortData> > GroupInterfacePortDataMap;
   GroupInterfacePortDataMap mGroupInterfacePortDataMap;
@@ -892,16 +900,17 @@
     SharedPtr<DiscreteSystem> discreteSystem;
     discreteSystem = new DiscreteSystem(basicSampleTime, 1);
 
-    ModelInstanceList::const_iterator i;
-    for (i = mModelInstanceList.begin(); i != mModelInstanceList.end(); ++i) {
-      discreteSystem->appendModelContext((*i)->mSampleTime,
-                                         (*i)->mModelContext);
+    ModelInstanceDataList::const_iterator i;
+    for (i = mModelInstanceDataList.begin();
+         i != mModelInstanceDataList.end(); ++i) {
+      discreteSystem->appendModelContext((*i)->getSampleTime(),
+                                         (*i)->getModelContext());
     }
 
-    MechanicInstanceList::const_iterator j;
-    for (j = mMechanicInstanceList.begin();
-         j != mMechanicInstanceList.end(); ++j) {
-      discreteSystem->appendMechanicContext((*j)->mMechanicContext);
+    MechanicInstanceDataList::const_iterator j;
+    for (j = mMechanicInstanceDataList.begin();
+         j != mMechanicInstanceDataList.end(); ++j) {
+      discreteSystem->appendMechanicContext((*j)->getMechanicContext());
     }
 
     return discreteSystem.release();
@@ -911,8 +920,9 @@
   // method to sort the leafs according to their dependency
   bool sortMechanicList()
   {
-    if (mRootJointInstanceList.empty() &&
-        (!mJointInstanceList.empty() || !mInteractInstanceList.empty())) {
+    if (mRootJointInstanceDataList.empty() &&
+        (!mJointInstanceDataList.empty() ||
+         !mInteractInstanceDataList.empty())) {
       Log(Schedule,Warning)
         << "No root joint in System with mechanic components" << std::endl;
       return false;
@@ -920,35 +930,35 @@
 
     // Start with all the roots in front of the list ...
     // FIXME: ensure that there is no loop here?
-    mMechanicInstanceList.swap(mRootJointInstanceList);
+    mMechanicInstanceDataList.swap(mRootJointInstanceDataList);
 
     // Not the best algorithm, but for a first cut ...
-    while (!mJointInstanceList.empty()) {
-      MechanicInstanceList nextLevelList;
+    while (!mJointInstanceDataList.empty()) {
+      MechanicInstanceDataList nextLevelList;
 
-      MechanicInstanceList::iterator j;
-      for (j = mMechanicInstanceList.begin();
-           j != mMechanicInstanceList.end(); ++j) {
-        MechanicInstanceList::iterator i;
-        for (i = mJointInstanceList.begin();
-             i != mJointInstanceList.end();) {
+      MechanicInstanceDataList::iterator j;
+      for (j = mMechanicInstanceDataList.begin();
+           j != mMechanicInstanceDataList.end(); ++j) {
+        MechanicInstanceDataList::iterator i;
+        for (i = mJointInstanceDataList.begin();
+             i != mJointInstanceDataList.end();) {
         
           if ((*j)->isLinkedTo(*(*i))) {
-            SharedPtr<MechanicInstance> mechanicInstance = *i;
-            nextLevelList.push_back(mechanicInstance);
-            i = mJointInstanceList.erase(i);
+            SharedPtr<MechanicInstanceData> mechanicInstanceData = *i;
+            nextLevelList.push_back(mechanicInstanceData);
+            i = mJointInstanceDataList.erase(i);
 
             // Check if this current mechanic node does not reference
             // back into the already sorted models
-            MechanicInstanceList::const_iterator k;
-            for (k = mMechanicInstanceList.begin();
-                 k != mMechanicInstanceList.end(); ++k) {
+            MechanicInstanceDataList::const_iterator k;
+            for (k = mMechanicInstanceDataList.begin();
+                 k != mMechanicInstanceDataList.end(); ++k) {
               if (*k == *j)
                 continue;
-              if (mechanicInstance->isLinkedTo(*(*k))) {
+              if (mechanicInstanceData->isLinkedTo(*(*k))) {
                 Log(Schedule,Warning)
                   << "Detected closed kinematic loop: MechanicNode \""
-                  << mechanicInstance->getNodeNamePath()
+                  << mechanicInstanceData->getNodeNamePath()
                   << "\" is linked to MechanicNode \""
                   << (*k)->getNodeNamePath() << "\"" << std::endl;
                 return false;
@@ -965,7 +975,7 @@
       // if we have a connection in between them, there must be a
       // closed kinematic loop.
       for (j = nextLevelList.begin(); j != nextLevelList.end(); ++j) {
-        MechanicInstanceList::iterator i = j;
+        MechanicInstanceDataList::iterator i = j;
         for (++i; i != nextLevelList.end(); ++i) {
           if ((*j)->isLinkedTo(*(*i))) {
             Log(Schedule,Warning)
@@ -980,19 +990,19 @@
       
 
       for (j = nextLevelList.begin(); j != nextLevelList.end(); ++j) {
-        mMechanicInstanceList.push_back(*j);
+        mMechanicInstanceDataList.push_back(*j);
       }
     }
 
     // Interacts are always computed at the end of the list
-    mMechanicInstanceList.splice(mMechanicInstanceList.end(),
-                                 mInteractInstanceList,
-                                 mInteractInstanceList.begin(),
-                                 mInteractInstanceList.end());
+    mMechanicInstanceDataList.splice(mMechanicInstanceDataList.end(),
+                                     mInteractInstanceDataList,
+                                     mInteractInstanceDataList.begin(),
+                                     mInteractInstanceDataList.end());
     
     Log(Schedule,Info) << "MechanicNode Schedule" << std::endl;
-    MechanicInstanceList::iterator i = mMechanicInstanceList.begin();
-    for (; i != mMechanicInstanceList.end(); ++i) {
+    MechanicInstanceDataList::iterator i = mMechanicInstanceDataList.begin();
+    for (; i != mMechanicInstanceDataList.end(); ++i) {
       Log(Schedule,Info)
         << "  MechanicNode \"" << (*i)->getNodeNamePath() << "\"" << std::endl;
     }
@@ -1003,65 +1013,66 @@
   // method to sort the leafs according to their dependency
   bool sortModelList()
   {
-    ModelInstanceList sortedModelInstanceList;
-    while (!mModelInstanceList.empty()) {
-      SharedPtr<ModelInstance> modelInstance = mModelInstanceList.front();
-      mModelInstanceList.pop_front();
+    ModelInstanceDataList sortedModelInstanceDataList;
+    while (!mModelInstanceDataList.empty()) {
+      SharedPtr<ModelInstanceData> modelInstanceData;
+      modelInstanceData = mModelInstanceDataList.front();
+      mModelInstanceDataList.pop_front();
 
-      if (modelInstance->dependsOn(*modelInstance)) {
+      if (modelInstanceData->dependsOn(*modelInstanceData)) {
         Log(Schedule, Warning)
           << "Self referencing direct dependency for Model \""
-          << modelInstance->getNodeNamePath()
+          << modelInstanceData->getNodeNamePath()
           << "\" detected!" << std::endl;
         return false;
       }
 
-      ModelInstanceList::iterator i;
-      for (i = sortedModelInstanceList.begin();
-           i != sortedModelInstanceList.end();
+      ModelInstanceDataList::iterator i;
+      for (i = sortedModelInstanceDataList.begin();
+           i != sortedModelInstanceDataList.end();
            ++i) {
-        if (!(*i)->dependsOn(*modelInstance))
+        if (!(*i)->dependsOn(*modelInstanceData))
           continue;
 
-        // Something already sorted in depends on modelInstance,
+        // Something already sorted in depends on modelInstanceData,
         // so schedule that new thing just before.
         Log(Schedule, Debug)
           << "Inserting Model \""
-          << modelInstance->getNodeNamePath()
+          << modelInstanceData->getNodeNamePath()
           << "\" before Model \""
           << (*i)->getNodeNamePath() << "\"" << std::endl;
-        i = sortedModelInstanceList.insert(i, modelInstance);
+        i = sortedModelInstanceDataList.insert(i, modelInstanceData);
         break;
       }
-      if (i == sortedModelInstanceList.end()) {
+      if (i == sortedModelInstanceDataList.end()) {
         // nothing found so far that depends on model instance.
         // So put it at the end.
         Log(Schedule, Debug)
           << "Appending Model \""
-          << modelInstance->getNodeNamePath()
+          << modelInstanceData->getNodeNamePath()
           << "\"" << std::endl;
 
-        sortedModelInstanceList.push_back(modelInstance);
+        sortedModelInstanceDataList.push_back(modelInstanceData);
       } else {
-        // If it cannot be put at the end, check if modelInstance depends
+        // If it cannot be put at the end, check if modelInstanceData depends
         // on any model that is already scheduled behind to detect cyclic loops.
-        for (; i != sortedModelInstanceList.end(); ++i) {
-          if (!modelInstance->dependsOn(*(*i)))
+        for (; i != sortedModelInstanceDataList.end(); ++i) {
+          if (!modelInstanceData->dependsOn(*(*i)))
             continue;
           Log(Schedule,Warning)
             << "Detected cyclic loop: Model \""
-            << modelInstance->getNodeNamePath()
+            << modelInstanceData->getNodeNamePath()
             << "\" depends on Model \""
             << (*i)->getNodeNamePath() << "\"" << std::endl;
           return false;
         }
       }
     }
-    mModelInstanceList.swap(sortedModelInstanceList);
+    mModelInstanceDataList.swap(sortedModelInstanceDataList);
 
     Log(Schedule,Info) << "Model Schedule" << std::endl;
-    ModelInstanceList::iterator i = mModelInstanceList.begin();
-    for (; i != mModelInstanceList.end(); ++i) {
+    ModelInstanceDataList::iterator i = mModelInstanceDataList.begin();
+    for (; i != mModelInstanceDataList.end(); ++i) {
       Log(Schedule,Info)
         << "  Model \"" << (*i)->getNodeNamePath() << "\"" << std::endl;
     }
@@ -1073,14 +1084,14 @@
   createContexts()
   {
     // alloc port values
-    InstanceMap::const_iterator i;
-    for (i = mInstanceMap.begin(); i != mInstanceMap.end(); ++i) {
+    InstanceDataMap::const_iterator i;
+    for (i = mInstanceDataMap.begin(); i != mInstanceDataMap.end(); ++i) {
       if (!i->second->allocPortValues())
-          return false;
+        return false;
     }
 
     // check port values and report unconnected mandatory values.
-    for (i = mInstanceMap.begin(); i != mInstanceMap.end(); ++i) {
+    for (i = mInstanceDataMap.begin(); i != mInstanceDataMap.end(); ++i) {
       const Node* node = i->second->getNode();
       for (unsigned k = 0; k < node->getNumPorts(); ++k) {
         SharedPtr<const PortInfo> portInfo = node->getPort(k);
@@ -1088,9 +1099,9 @@
           continue;
         if (!i->second->getPortValue(*portInfo)) {
           Log(Schedule, Warning) << "Mandatory port value for port \""
-                               << portInfo->getName() << "\" for model \""
-                               << i->second->getNodeNamePath()
-                               << "\" is not connected!" << endl;
+                                 << portInfo->getName() << "\" for model \""
+                                 << i->second->getNodeNamePath()
+                                 << "\" is not connected!" << endl;
           return false;
         }
       }
@@ -1099,15 +1110,16 @@
     // Create the contexts
     // This happens past the port values are assigned, this way models can
     // create different kind of contexts based on the type of port values.
-    ModelInstanceList::const_iterator j;
-    for (j = mModelInstanceList.begin(); j != mModelInstanceList.end(); ++j) {
+    ModelInstanceDataList::const_iterator j;
+    for (j = mModelInstanceDataList.begin();
+         j != mModelInstanceDataList.end(); ++j) {
       if (!(*j)->createModelContext())
         return false;
     }
 
-    MechanicInstanceList::const_iterator k;
-    for (k = mMechanicInstanceList.begin();
-         k != mMechanicInstanceList.end(); ++k) {
+    MechanicInstanceDataList::const_iterator k;
+    for (k = mMechanicInstanceDataList.begin();
+         k != mMechanicInstanceDataList.end(); ++k) {
       if (!(*k)->createMechanicContext())
         return false;
     }
@@ -1164,9 +1176,9 @@
 
   // Have something to run in our hands.
   // Now get the information required to reflect the system to the user.
-  NodeInstanceCollector::InstanceMap::const_iterator i;
-  for (i = nodeInstanceCollector.mInstanceMap.begin();
-       i != nodeInstanceCollector.mInstanceMap.end(); ++i) {
+  NodeInstanceCollector::InstanceDataMap::const_iterator i;
+  for (i = nodeInstanceCollector.mInstanceDataMap.begin();
+       i != nodeInstanceCollector.mInstanceDataMap.end(); ++i) {
     mNodeInstanceMap[i->first] = i->second->newNodeInstance();
   }
 



From frohlich at mail.berlios.de  Tue Nov 11 21:21:12 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Tue, 11 Nov 2008 21:21:12 +0100
Subject: [OpenFDM-svn] r721 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811112021.mABKLCSi031240@sheep.berlios.de>

Author: frohlich
Date: 2008-11-11 21:21:11 +0100 (Tue, 11 Nov 2008)
New Revision: 721

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Node.h
Log:
Remove unused fwd decl.

M    Node.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Node.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Node.h	2008-11-11 20:16:28 UTC (rev 720)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Node.h	2008-11-11 20:21:11 UTC (rev 721)
@@ -15,7 +15,6 @@
 
 namespace OpenFDM {
 
-class AbstractNodeContext;
 class Group;
 class Node;
 class NodeVisitor;



From frohlich at mail.berlios.de  Tue Nov 11 21:42:26 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Tue, 11 Nov 2008 21:42:26 +0100
Subject: [OpenFDM-svn] r722 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811112042.mABKgQU6000469@sheep.berlios.de>

Author: frohlich
Date: 2008-11-11 21:42:26 +0100 (Tue, 11 Nov 2008)
New Revision: 722

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Joint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicContext.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Model.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Model.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/ModelContext.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/ModelContext.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.cpp
Log:
Remove the alloc virtual function.
Make ModelContext a virtual base.

M    src/OpenFDM/Joint.cpp
M    src/OpenFDM/CartesianJoint.h
M    src/OpenFDM/ModelContext.cpp
M    src/OpenFDM/Model.h
M    src/OpenFDM/Interact.cpp
M    src/OpenFDM/RootJoint.cpp
M    src/OpenFDM/Model.cpp
M    src/OpenFDM/ModelContext.h
M    src/OpenFDM/MechanicContext.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h	2008-11-11 20:21:11 UTC (rev 721)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h	2008-11-11 20:42:26 UTC (rev 722)
@@ -28,7 +28,7 @@
 
   virtual MechanicContext* newMechanicContext(PortValueList& portValueList) const
   {
-    SharedPtr<MechanicContext> context = new Context(this);
+    SharedPtr<Context> context = new Context(this);
     for (unsigned i = 0; i < getNumPorts(); ++i) {
       PortValue* portValue = portValueList.getPortValue(i);
       if (!portValue) {
@@ -184,7 +184,7 @@
     virtual const CartesianJoint& getNode() const
     { return *mCartesianJoint; }
     
-    virtual bool alloc()
+    bool alloc()
     {
       if (!allocStates())
         return false;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.cpp	2008-11-11 20:21:11 UTC (rev 721)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.cpp	2008-11-11 20:42:26 UTC (rev 722)
@@ -83,7 +83,7 @@
 MechanicContext*
 Interact::newMechanicContext(PortValueList& portValueList) const
 {
-  SharedPtr<MechanicContext> context = new Context(this);
+  SharedPtr<Context> context = new Context(this);
   for (unsigned i = 0; i < getNumPorts(); ++i) {
     PortValue* portValue = portValueList.getPortValue(i);
     if (!portValue) {

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Joint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Joint.cpp	2008-11-11 20:21:11 UTC (rev 721)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Joint.cpp	2008-11-11 20:42:26 UTC (rev 722)
@@ -14,7 +14,6 @@
 #include "Interact.h"
 #include "LogStream.h"
 #include "PortValueList.h"
-#include "MechanicContext.h"
 #include "NodeVisitor.h"
 
 namespace OpenFDM {

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicContext.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicContext.h	2008-11-11 20:21:11 UTC (rev 721)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicContext.h	2008-11-11 20:42:26 UTC (rev 722)
@@ -25,7 +25,6 @@
 
   virtual const MechanicNode& getNode() const = 0;
 
-  virtual bool alloc() = 0;
   virtual void initVelocities(const /*Init*/Task& task) = 0;
   virtual void velocities(const Task& task) = 0;
   virtual void articulation(const Task& task) = 0;
@@ -42,13 +41,6 @@
 public:
   typedef std::list<SharedPtr<MechanicContext> > list_type;
 
-  bool alloc() const
-  {
-    for (list_type::const_iterator i = begin(); i != end(); ++i)
-      if (!(*i)->alloc())
-        return false;
-    return true;
-  }
   void initVelocities(const /*Init*/Task& task) const
   {
     for (list_type::const_iterator i = begin(); i != end(); ++i)

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Model.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Model.cpp	2008-11-11 20:21:11 UTC (rev 721)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Model.cpp	2008-11-11 20:42:26 UTC (rev 722)
@@ -11,6 +11,52 @@
 
 namespace OpenFDM {
 
+class Model::Context : public ModelContext {
+public:
+  Context(const Model* model) :
+    mModel(model)
+  {
+  }
+  virtual ~Context()
+  { }
+
+  virtual const Model& getNode() const
+  { return *mModel; }
+
+  bool alloc()
+  {
+    if (!allocStates())
+      return false;
+    return mModel->alloc(*this);
+  }
+  virtual void initOutput(const /*Init*/Task& task)
+  {
+    mModel->init(task, mDiscreteState, mContinousState, mPortValueList);
+    mModel->output(task, mDiscreteState, mContinousState, mPortValueList);
+  }
+  virtual void output(const Task& task)
+  {
+    mModel->output(task, mDiscreteState, mContinousState, mPortValueList);
+  }
+  virtual void update(const DiscreteTask& discreteTask)
+  {
+    mModel->update(discreteTask, mDiscreteState, mContinousState, mPortValueList);
+  }
+
+  virtual void derivative(const Task&)
+  {
+    mModel->derivative(mDiscreteState, mContinousState, mPortValueList,
+                       mContinousStateDerivative);
+  }
+
+private:
+  Context();
+  Context(const Context&);
+  Context& operator=(const Context&);
+
+  SharedPtr<const Model> mModel;
+};
+
 BEGIN_OPENFDM_OBJECT_DEF(Model, LeafNode)
   END_OPENFDM_OBJECT_DEF
 
@@ -38,7 +84,7 @@
 ModelContext*
 Model::newModelContext(PortValueList& portValueList) const
 {
-  SharedPtr<ModelContext> context = new ModelContext(this);
+  SharedPtr<Context> context = new Context(this);
   for (unsigned i = 0; i < getNumPorts(); ++i) {
     PortValue* portValue = portValueList.getPortValue(i);
     if (!portValue) {

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Model.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Model.h	2008-11-11 20:21:11 UTC (rev 721)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Model.h	2008-11-11 20:42:26 UTC (rev 722)
@@ -66,6 +66,9 @@
   RealInputPort
   newRealInputPort(const std::string& name, bool directInput)
   { return RealInputPort(this, name, directInput); }
+
+private:
+  class Context;
 };
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/ModelContext.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ModelContext.cpp	2008-11-11 20:21:11 UTC (rev 721)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ModelContext.cpp	2008-11-11 20:42:26 UTC (rev 722)
@@ -7,20 +7,8 @@
 
 namespace OpenFDM {
 
-ModelContext::ModelContext(const Model* model) :
-  mModel(model)
-{
-  OpenFDMAssert(mModel);
-}
-
 ModelContext::~ModelContext()
 {
 }
 
-const Model&
-ModelContext::getNode() const
-{
-  return *mModel;
-}
-
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/ModelContext.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ModelContext.h	2008-11-11 20:21:11 UTC (rev 721)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ModelContext.h	2008-11-11 20:42:26 UTC (rev 722)
@@ -20,46 +20,25 @@
 //// This one is used to execute the simulation system
 class ModelContext : public LeafContext {
 public:
-  ModelContext(const Model* model);
+  ModelContext() {}
   virtual ~ModelContext();
 
-  virtual const Model& getNode() const;
+  virtual const Model& getNode() const = 0;
 
-  bool alloc()
-  { if (!allocStates()) return false; return mModel->alloc(*this); }
-  void initOutput(const /*Init*/Task& task)
-  {
-    mModel->init(task, mDiscreteState, mContinousState, mPortValueList);
-    mModel->output(task, mDiscreteState, mContinousState, mPortValueList);
-  }
-  void output(const Task& task)
-  { mModel->output(task, mDiscreteState, mContinousState, mPortValueList); }
-  void update(const DiscreteTask& discreteTask)
-  { mModel->update(discreteTask, mDiscreteState, mContinousState, mPortValueList); }
+  virtual void initOutput(const /*Init*/Task& task) = 0;
+  virtual void output(const Task& task) = 0;
+  virtual void update(const DiscreteTask& discreteTask) = 0;
+  virtual void derivative(const Task&) = 0;
 
-  void derivative(const Task&)
-  { mModel->derivative(mDiscreteState, mContinousState, mPortValueList,
-                       mContinousStateDerivative); }
-
 private:
-  ModelContext();
   ModelContext(const ModelContext&);
   ModelContext& operator=(const ModelContext&);
-
-  SharedPtr<const Model> mModel;
 };
 
 class ModelContextList : public std::list<SharedPtr<ModelContext> > {
 public:
   typedef std::list<SharedPtr<ModelContext> > list_type;
 
-  bool alloc() const
-  {
-    for (list_type::const_iterator i = begin(); i != end(); ++i)
-      if (!(*i)->alloc())
-        return false;
-    return true;
-  }
   void initOutput(const /*Init*/Task& task) const
   {
     for (list_type::const_iterator i = begin(); i != end(); ++i)

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.cpp	2008-11-11 20:21:11 UTC (rev 721)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.cpp	2008-11-11 20:42:26 UTC (rev 722)
@@ -18,7 +18,7 @@
   virtual const RootJoint& getNode() const
   { return *mRootJoint; }
   
-  virtual bool alloc()
+  bool alloc()
   { if (!allocStates()) return false; return mRootJoint->alloc(*this); }
   virtual void initVelocities(const /*Init*/Task& task)
   {
@@ -69,7 +69,7 @@
 MechanicContext*
 RootJoint::newMechanicContext(PortValueList& portValueList) const
 {
-  SharedPtr<MechanicContext> context = new Context(this);
+  SharedPtr<Context> context = new Context(this);
   for (unsigned i = 0; i < getNumPorts(); ++i) {
     PortValue* portValue = portValueList.getPortValue(i);
     if (!portValue) {



From frohlich at mail.berlios.de  Tue Nov 11 22:46:29 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Tue, 11 Nov 2008 22:46:29 +0100
Subject: [OpenFDM-svn] r723 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811112146.mABLkTuv006803@sheep.berlios.de>

Author: frohlich
Date: 2008-11-11 22:46:27 +0100 (Tue, 11 Nov 2008)
New Revision: 723

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/LogStream.h
Log:
Make the NDEBUG cut at DEBUG messages

M    LogStream.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/LogStream.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/LogStream.h	2008-11-11 20:42:26 UTC (rev 722)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/LogStream.h	2008-11-11 21:46:27 UTC (rev 723)
@@ -60,7 +60,7 @@
 #if defined(NDEBUG) || defined(_NDEBUG)
     // In the NDEBUG case, give the compilers optimizer a chance to
     // completely remove the code.
-    if (Info <= priority)
+    if (Debug <= priority)
       return false;
 #endif
     return Instance()->getEnabled(category, priority);



From frohlich at mail.berlios.de  Wed Nov 12 06:55:54 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Wed, 12 Nov 2008 06:55:54 +0100
Subject: [OpenFDM-svn] r724 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811120555.mAC5tsH3001472@sheep.berlios.de>

Author: frohlich
Date: 2008-11-12 06:55:49 +0100 (Wed, 12 Nov 2008)
New Revision: 724

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Joint.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/PortValueList.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
Log:
Joints get now their topological link information.

M    src/OpenFDM/CartesianJoint.h
M    src/OpenFDM/PortValueList.h
M    src/OpenFDM/RootJoint.h
M    src/OpenFDM/System.cpp
M    src/OpenFDM/RootJoint.cpp
M    src/OpenFDM/Joint.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h	2008-11-11 21:46:27 UTC (rev 723)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h	2008-11-12 05:55:49 UTC (rev 724)
@@ -26,23 +26,46 @@
   typedef LinAlg::Matrix<real_type,n,n> MatrixNN;
   typedef LinAlg::MatrixFactors<real_type,n,n,LinAlg::LUTag> MatrixFactorsNN;
 
-  virtual MechanicContext* newMechanicContext(PortValueList& portValueList) const
+  virtual MechanicContext*
+  newMechanicContext(const MechanicLinkInfo* parentLink,
+                     const MechanicLinkInfo* childLink,
+                     PortValueList& portValueList) const
   {
-    SharedPtr<Context> context = new Context(this);
+    if (!parentLink) {
+      Log(Model, Error) << "Parent link is not set while creating context "
+                        << "for model \"" << getName() << "\"" << endl;
+      return 0;
+    }
+    MechanicLinkValue* parentLinkValue;
+    parentLinkValue = portValueList.getPortValue(*parentLink);
+    if (!parentLinkValue)
+      return 0;
+    if (!childLink) {
+      Log(Model, Error) << "Child link is not set while creating context "
+                        << "for model \"" << getName() << "\"" << endl;
+      return 0;
+    }
+    MechanicLinkValue* childLinkValue;
+    childLinkValue = portValueList.getPortValue(*childLink);
+    if (!childLinkValue)
+      return 0;
+
+    SharedPtr<Context> context;
+    context = new Context(this, parentLinkValue, childLinkValue);
     for (unsigned i = 0; i < getNumPorts(); ++i) {
       PortValue* portValue = portValueList.getPortValue(i);
       if (!portValue) {
         Log(Model, Error) << "No port value given for model \"" << getName()
                           << "\" and port \"" << getPort(i)->getName()
                           << "\"" << endl;
-        return false;
+        return 0;
       }
       context->setPortValue(*getPort(i), portValue);
     }
     if (!context->alloc()) {
       Log(Model, Warning) << "Could not alloc for model \""
                           << getName() << "\"" << endl;
-      return false;
+      return 0;
     }
     return context.release();
   }
@@ -176,8 +199,11 @@
 private:
   class Context : public MechanicContext {
   public:
-    Context(const CartesianJoint* cartesianJoint) :
-      mCartesianJoint(cartesianJoint)
+    Context(const CartesianJoint* cartesianJoint, MechanicLinkValue* parentLink,
+            MechanicLinkValue* childLink) :
+      mCartesianJoint(cartesianJoint),
+      mParentLink(parentLink),
+      mChildLink(childLink)
     { }
     virtual ~Context() {}
     
@@ -188,8 +214,6 @@
     {
       if (!allocStates())
         return false;
-      mParentLink = &mPortValueList[mCartesianJoint->mParentLink];
-      mChildLink = &mPortValueList[mCartesianJoint->mChildLink];
       return mCartesianJoint->alloc(*this);
     }
     virtual void initVelocities(const /*Init*/Task& task)

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Joint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Joint.h	2008-11-11 21:46:27 UTC (rev 723)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Joint.h	2008-11-12 05:55:49 UTC (rev 724)
@@ -27,7 +27,10 @@
   virtual void accept(NodeVisitor& visitor);
   virtual void accept(ConstNodeVisitor& visitor) const;
 
-  virtual MechanicContext* newMechanicContext(PortValueList& portValues) const = 0;
+  virtual MechanicContext*
+  newMechanicContext(const MechanicLinkInfo* parentLink,
+                     const MechanicLinkInfo* childLink,
+                     PortValueList& portValues) const = 0;
 };
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/PortValueList.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/PortValueList.h	2008-11-11 21:46:27 UTC (rev 723)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/PortValueList.h	2008-11-12 05:55:49 UTC (rev 724)
@@ -136,6 +136,13 @@
       return 0;
     return portValue->toMechanicLinkValue();
   }
+  MechanicLinkValue* getPortValue(const MechanicLinkInfo& portInfo)
+  {
+    PortValue* portValue = getPortValue(portInfo.getIndex());
+    if (!portValue)
+      return 0;
+    return portValue->toMechanicLinkValue();
+  }
   /// Save but partially expensive Accessor for numeric ports
   const PortValue* getPortValue(const PortInfo* portInfo) const
   {

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.cpp	2008-11-11 21:46:27 UTC (rev 723)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.cpp	2008-11-12 05:55:49 UTC (rev 724)
@@ -67,7 +67,9 @@
 }
 
 MechanicContext*
-RootJoint::newMechanicContext(PortValueList& portValueList) const
+RootJoint::newMechanicContext(const MechanicLinkInfo* parentLink,
+                              const MechanicLinkInfo* childLink,
+                              PortValueList& portValueList) const
 {
   SharedPtr<Context> context = new Context(this);
   for (unsigned i = 0; i < getNumPorts(); ++i) {

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.h	2008-11-11 21:46:27 UTC (rev 723)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.h	2008-11-12 05:55:49 UTC (rev 724)
@@ -16,7 +16,10 @@
   RootJoint(const std::string& name);
   virtual ~RootJoint();
 
-  virtual MechanicContext* newMechanicContext(PortValueList& portValueList) const;
+  virtual MechanicContext*
+  newMechanicContext(const MechanicLinkInfo* parentLink,
+                     const MechanicLinkInfo* childLink,
+                     PortValueList& portValueList) const;
 
   virtual void accept(NodeVisitor& visitor);
   virtual void accept(ConstNodeVisitor& visitor) const;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-11 21:46:27 UTC (rev 723)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-12 05:55:49 UTC (rev 724)
@@ -599,7 +599,8 @@
     virtual bool createMechanicContext()
     {
       OpenFDMAssert(!mMechanicContext);
-      mMechanicContext = getNode()->newMechanicContext(mPortValueList);
+      mMechanicContext = getNode()->newMechanicContext(mParentLink, mChildLink,
+                                                       mPortValueList);
       if (!mMechanicContext) {
         Log(Schedule, Warning) << "Could not create context for mechanic "
                                << "node \"" << getNodeNamePath()
@@ -608,6 +609,56 @@
       }
       return true;
     }
+
+    bool isLinkedToAndSetChild(JointInstanceData& instance)
+    {
+      unsigned numPorts = getNode()->getNumPorts();
+      for (unsigned i = 0; i < numPorts; ++i) {
+        const MechanicLinkInfo* linkInfo;
+        linkInfo = getNode()->getPort(i)->toMechanicLinkInfo();
+        if (!linkInfo)
+          continue;
+        OpenFDMAssert(i < mPortDataVector.size());
+
+        const Node* otherNode = instance.getNode();
+        unsigned otherNumPorts = otherNode->getNumPorts();
+        for (unsigned j = 0; j < otherNumPorts; ++j) {
+          const MechanicLinkInfo* otherLinkInfo;
+          otherLinkInfo = otherNode->getPort(j)->toMechanicLinkInfo();
+          if (!otherLinkInfo)
+            continue;
+
+          OpenFDMAssert(j < instance.mPortDataVector.size());
+          OpenFDMAssert(instance.mPortDataVector[j]);
+          if (!mPortDataVector[i]->isConnected(*instance.mPortDataVector[j]))
+            continue;
+
+          mChildLink = linkInfo;
+          instance.mParentLink = otherLinkInfo;
+          return true;
+        }
+      }
+      return false;
+    }
+
+    // FIXME: do real checks in this case, connected and so forth ...
+    bool makeRemainigLinksChildLinks()
+    {
+      unsigned numPorts = getNode()->getNumPorts();
+      for (unsigned i = 0; i < numPorts; ++i) {
+        const MechanicLinkInfo* linkInfo;
+        linkInfo = getNode()->getPort(i)->toMechanicLinkInfo();
+        if (!linkInfo)
+          continue;
+        if (linkInfo == mParentLink)
+          continue;
+        mChildLink = linkInfo;
+      }
+      return true;
+    }
+
+    SharedPtr<const MechanicLinkInfo> mParentLink;
+    SharedPtr<const MechanicLinkInfo> mChildLink;
   private:
     SharedPtr<const Joint> mJoint;
   };
@@ -842,6 +893,7 @@
   typedef std::list<SharedPtr<NodeInstanceData> > NodeInstanceDataList;
   typedef std::list<SharedPtr<ModelInstanceData> > ModelInstanceDataList;
   typedef std::list<SharedPtr<MechanicInstanceData> > MechanicInstanceDataList;
+  typedef std::list<SharedPtr<JointInstanceData> > JointInstanceDataList;
 
   // The list of Nodes that do not need a context for itself.
   NodeInstanceDataList mNodeInstanceDataList;
@@ -852,8 +904,8 @@
 
   // The list of root nodes in the mechanical system. Will be a starting point
   // for sorting the tree of mechanical models downwards
-  MechanicInstanceDataList mRootJointInstanceDataList;
-  MechanicInstanceDataList mJointInstanceDataList;
+  JointInstanceDataList mRootJointInstanceDataList;
+  JointInstanceDataList mJointInstanceDataList;
   MechanicInstanceDataList mInteractInstanceDataList;
 
   ////////////////////////////////////////////////////////////////////////////
@@ -929,30 +981,34 @@
     }
 
     // Start with all the roots in front of the list ...
-    // FIXME: ensure that there is no loop here?
-    mMechanicInstanceDataList.swap(mRootJointInstanceDataList);
+    // FIXME: ensure that we have no root joints with two mechanic links.
+    // They must then appear in the joint list. When we know that, we are sure
+    // that there is no mechanic link loop in the root joints - they
+    // have only one link ...
+    JointInstanceDataList sortedJoints;
+    sortedJoints.swap(mRootJointInstanceDataList);
 
     // Not the best algorithm, but for a first cut ...
     while (!mJointInstanceDataList.empty()) {
-      MechanicInstanceDataList nextLevelList;
+      JointInstanceDataList nextLevelList;
 
-      MechanicInstanceDataList::iterator j;
-      for (j = mMechanicInstanceDataList.begin();
-           j != mMechanicInstanceDataList.end(); ++j) {
-        MechanicInstanceDataList::iterator i;
+      JointInstanceDataList::iterator j;
+      for (j = sortedJoints.begin();
+           j != sortedJoints.end(); ++j) {
+        JointInstanceDataList::iterator i;
         for (i = mJointInstanceDataList.begin();
              i != mJointInstanceDataList.end();) {
         
-          if ((*j)->isLinkedTo(*(*i))) {
-            SharedPtr<MechanicInstanceData> mechanicInstanceData = *i;
+          if ((*j)->isLinkedToAndSetChild(*(*i))) {
+            SharedPtr<JointInstanceData> mechanicInstanceData = *i;
             nextLevelList.push_back(mechanicInstanceData);
             i = mJointInstanceDataList.erase(i);
 
             // Check if this current mechanic node does not reference
             // back into the already sorted models
-            MechanicInstanceDataList::const_iterator k;
-            for (k = mMechanicInstanceDataList.begin();
-                 k != mMechanicInstanceDataList.end(); ++k) {
+            JointInstanceDataList::const_iterator k;
+            for (k = sortedJoints.begin();
+                 k != sortedJoints.end(); ++k) {
               if (*k == *j)
                 continue;
               if (mechanicInstanceData->isLinkedTo(*(*k))) {
@@ -975,7 +1031,7 @@
       // if we have a connection in between them, there must be a
       // closed kinematic loop.
       for (j = nextLevelList.begin(); j != nextLevelList.end(); ++j) {
-        MechanicInstanceDataList::iterator i = j;
+        JointInstanceDataList::iterator i = j;
         for (++i; i != nextLevelList.end(); ++i) {
           if ((*j)->isLinkedTo(*(*i))) {
             Log(Schedule,Warning)
@@ -990,11 +1046,15 @@
       
 
       for (j = nextLevelList.begin(); j != nextLevelList.end(); ++j) {
-        mMechanicInstanceDataList.push_back(*j);
+        // FIXME
+        (*j)->makeRemainigLinksChildLinks();
+        sortedJoints.push_back(*j);
       }
     }
 
-    // Interacts are always computed at the end of the list
+    // First the sorted joints ...
+    mMechanicInstanceDataList.assign(sortedJoints.begin(), sortedJoints.end());
+    // ... then Interacts at the end of the list
     mMechanicInstanceDataList.splice(mMechanicInstanceDataList.end(),
                                      mInteractInstanceDataList,
                                      mInteractInstanceDataList.begin(),



From frohlich at mail.berlios.de  Wed Nov 12 22:41:57 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Wed, 12 Nov 2008 22:41:57 +0100
Subject: [OpenFDM-svn] r725 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811122141.mACLfvSK018562@sheep.berlios.de>

Author: frohlich
Date: 2008-11-12 22:41:55 +0100 (Wed, 12 Nov 2008)
New Revision: 725

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJoint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJoint.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Mass.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Mass.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicContext.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJoint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJoint.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/PrismaticJoint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/PrismaticJoint.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteActuator.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteActuator.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/UniversalJoint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/UniversalJoint.h
Log:
Include position support for joints.

M    src/OpenFDM/MobileRootJoint.cpp
M    src/OpenFDM/RevoluteJoint.cpp
M    src/OpenFDM/CartesianJoint.h
M    src/OpenFDM/Mass.h
M    src/OpenFDM/Interact.cpp
M    src/OpenFDM/FixedRootJoint.h
M    src/OpenFDM/UniversalJoint.h
M    src/OpenFDM/RootJoint.h
M    src/OpenFDM/Mass.cpp
M    src/OpenFDM/PrismaticJoint.h
M    src/OpenFDM/FixedRootJoint.cpp
M    src/OpenFDM/RevoluteActuator.h
M    src/OpenFDM/RevoluteJoint.h
M    src/OpenFDM/RootJoint.cpp
M    src/OpenFDM/PrismaticJoint.cpp
M    src/OpenFDM/UniversalJoint.cpp
M    src/OpenFDM/Interact.h
M    src/OpenFDM/RevoluteActuator.cpp
M    src/OpenFDM/MechanicContext.h
M    src/OpenFDM/MobileRootJoint.h
M    src/OpenFDM/MechanicLinkValue.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h	2008-11-12 05:55:49 UTC (rev 724)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h	2008-11-12 21:41:55 UTC (rev 725)
@@ -176,6 +176,8 @@
     childLink.setAccel(parentLink, mJointMatrix*velDot);
   }
 
+  virtual void initDesignPosition(const MechanicLinkValue& parentLink,
+                                  MechanicLinkValue& childLink) const = 0;
   virtual void velocity(const MechanicLinkValue& parentLink,
                         MechanicLinkValue& childLink,
                         const ContinousStateValueVector& states,
@@ -210,6 +212,11 @@
     virtual const CartesianJoint& getNode() const
     { return *mCartesianJoint; }
     
+    virtual void initDesignPosition()
+    {
+      mCartesianJoint->initDesignPosition(*mParentLink, *mChildLink);
+    }
+
     bool alloc()
     {
       if (!allocStates())

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJoint.cpp	2008-11-12 05:55:49 UTC (rev 724)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJoint.cpp	2008-11-12 21:41:55 UTC (rev 725)
@@ -38,6 +38,12 @@
 }
 
 void
+FixedRootJoint::initDesignPosition(PortValueList& portValues) const
+{
+  portValues[mMechanicLink].setDesignPosition(Vector3::zeros());
+}
+
+void
 FixedRootJoint::velocity(const Task&,
                           const ContinousStateValueVector& continousState,
                           PortValueList& portValues) const

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJoint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJoint.h	2008-11-12 05:55:49 UTC (rev 724)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJoint.h	2008-11-12 21:41:55 UTC (rev 725)
@@ -25,6 +25,7 @@
   virtual void init(const Task&, DiscreteStateValueVector&,
                     ContinousStateValueVector&,
                     const PortValueList&) const;
+  virtual void initDesignPosition(PortValueList&) const;
   virtual void velocity(const Task&, const ContinousStateValueVector& states,
                         PortValueList& portValues) const;
   virtual void articulation(const Task&, const ContinousStateValueVector&,

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.cpp	2008-11-12 05:55:49 UTC (rev 724)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.cpp	2008-11-12 21:41:55 UTC (rev 725)
@@ -18,6 +18,11 @@
   virtual const Interact& getNode() const
   { return *mInteract; }
 
+  virtual void initDesignPosition()
+  {
+    mInteract->initDesignPosition(mPortValueList);
+  }
+
   virtual bool alloc()
   { if (!allocStates()) return false; return mInteract->alloc(*this); }
   virtual void initVelocities(const /*Init*/Task& task)

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.h	2008-11-12 05:55:49 UTC (rev 724)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.h	2008-11-12 21:41:55 UTC (rev 725)
@@ -21,6 +21,7 @@
 
   virtual MechanicContext* newMechanicContext(PortValueList& portValues) const;
 
+  virtual void initDesignPosition(PortValueList&) const = 0;
   virtual void velocity(const Task&, const ContinousStateValueVector&,
                         PortValueList&) const
   { }

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Mass.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Mass.cpp	2008-11-12 05:55:49 UTC (rev 724)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Mass.cpp	2008-11-12 21:41:55 UTC (rev 725)
@@ -21,10 +21,8 @@
   mMechanicLink(newMechanicLink("link")),
   mMass(mass),
   mInertia(inertia),
-  mPosition(position),
-  mSpatialInertia(0)
+  mPosition(position)
 {
-  setInertia(mMass, mInertia, mPosition);
 }
 
 Mass::~Mass(void)
@@ -32,25 +30,32 @@
 }
 
 void
+Mass::initDesignPosition(PortValueList&) const
+{
+}
+
+void
 Mass::articulation(const Task&, const ContinousStateValueVector&,
                    PortValueList& portValues, Matrix&) const
 {
   // FIXME: Hardcoding that gravity happens in the roots??
-  // Vectro3 position = portValues[mMechanicLink].mPosition;
   Vector3 gravity = Vector3::zeros();
   Vector6 force = Vector6(Vector3::zeros(), gravity);
 
+  Vector3 position = mPosition - portValues[mMechanicLink].getDesignPosition();
+  SpatialInertia I = inertiaFrom(position, SpatialInertia(mInertia, mMass));
+
   // FIXME: do we really need that in the mass
   // I did search for a while until I found that missing term here ...
   Vector6 iv = portValues[mMechanicLink].getFrame().getSpVel();
-  Vector6 Jiv = mSpatialInertia*iv;
+  Vector6 Jiv = I*iv;
   force += Vector6(cross(iv.getAngular(), Jiv.getAngular()) +
                    cross(iv.getLinear(), Jiv.getLinear()),
                    cross(iv.getAngular(), Jiv.getLinear()));
 
 
-  portValues[mMechanicLink].applyInertia(mSpatialInertia);
-  portValues[mMechanicLink].applyForce(force);
+  portValues[mMechanicLink].applyInertia(I);
+  portValues[mMechanicLink].applyForce(forceFrom(position, force));
 }
 
 const InertiaMatrix&
@@ -62,7 +67,7 @@
 void
 Mass::setInertia(const InertiaMatrix& inertia)
 {
-  setInertia(mMass, inertia, mPosition);
+  mInertia = inertia;
 }
 
 const real_type&
@@ -74,7 +79,7 @@
 void
 Mass::setMass(const real_type& mass)
 {
-  setInertia(mass, mInertia, mPosition);
+  mMass = mass;
 }
 
 const Vector3&
@@ -86,17 +91,7 @@
 void
 Mass::setPosition(const Vector3& position)
 {
-  setInertia(mMass, mInertia, position);
-}
-
-void
-Mass::setInertia(const real_type& mass, const InertiaMatrix& inertia,
-                 const Vector3& position)
-{
-  mMass = mass;
-  mInertia = inertia;
   mPosition = position;
-  mSpatialInertia = inertiaFrom(mPosition, SpatialInertia(mInertia, mMass));
 }
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Mass.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Mass.h	2008-11-12 05:55:49 UTC (rev 724)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Mass.h	2008-11-12 21:41:55 UTC (rev 725)
@@ -18,6 +18,7 @@
        const Vector3& position = Vector3::zeros());
   virtual ~Mass(void);
 
+  virtual void initDesignPosition(PortValueList&) const;
   virtual void articulation(const Task&, const ContinousStateValueVector&,
                             PortValueList&, Matrix&) const;
 
@@ -42,15 +43,6 @@
   const Vector3& getPosition(void) const;
   void setPosition(const Vector3& position);
 
-  /** Set the local spatial inertia.
-      @param mass mass in kg.
-      @param inertia inertia matrix in kg*m^2.
-      Sets the spatial inertia of the current rigid body to a simple
-      point mass of the mass and inertia given in the argument.
-   */
-  void setInertia(const real_type& mass, const InertiaMatrix& inertia,
-                  const Vector3& position);
-
 private:
   MechanicLink mMechanicLink;
 
@@ -58,9 +50,6 @@
   real_type mMass;
   InertiaMatrix mInertia;
   Vector3 mPosition;
-
-  /// The resulting local spatial inertia matrix
-  SpatialInertia mSpatialInertia;
 };
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicContext.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicContext.h	2008-11-12 05:55:49 UTC (rev 724)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicContext.h	2008-11-12 21:41:55 UTC (rev 725)
@@ -25,6 +25,7 @@
 
   virtual const MechanicNode& getNode() const = 0;
 
+  virtual void initDesignPosition() = 0;
   virtual void initVelocities(const /*Init*/Task& task) = 0;
   virtual void velocities(const Task& task) = 0;
   virtual void articulation(const Task& task) = 0;
@@ -41,10 +42,18 @@
 public:
   typedef std::list<SharedPtr<MechanicContext> > list_type;
 
+  void initDesignPosition() const
+  {
+    for (list_type::const_iterator i = begin(); i != end(); ++i)
+      (*i)->initDesignPosition();
+  }
+
   void initVelocities(const /*Init*/Task& task) const
   {
-    for (list_type::const_iterator i = begin(); i != end(); ++i)
+    for (list_type::const_iterator i = begin(); i != end(); ++i) {
+      (*i)->initDesignPosition();
       (*i)->initVelocities(task);
+    }
   }
   void velocities(const Task& task) const
   {

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.h	2008-11-12 05:55:49 UTC (rev 724)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.h	2008-11-12 21:41:55 UTC (rev 725)
@@ -76,6 +76,11 @@
     applyInertia(linkValue.mArticulatedInertia);
   }
 
+  const Vector3& getDesignPosition() const
+  { return mDesignPosition; }
+  void setDesignPosition(const Vector3& designPosition)
+  { mDesignPosition = designPosition; }
+
 protected:
   // May be build a class hierarchy that accounts for different inputs
   // and outputs a rigid body can have.
@@ -83,6 +88,8 @@
   Frame mFrame;
   Vector6 mArticulatedForce;
   SpatialInertia mArticulatedInertia;
+
+  Vector3 mDesignPosition;
 };
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJoint.cpp	2008-11-12 05:55:49 UTC (rev 724)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJoint.cpp	2008-11-12 21:41:55 UTC (rev 725)
@@ -47,6 +47,12 @@
 }
 
 void
+MobileRootJoint::initDesignPosition(PortValueList& portValues) const
+{
+  portValues[mMechanicLink].setDesignPosition(Vector3::zeros());
+}
+
+void
 MobileRootJoint::velocity(const Task&,
                           const ContinousStateValueVector& continousState,
                           PortValueList& portValues) const

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJoint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJoint.h	2008-11-12 05:55:49 UTC (rev 724)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJoint.h	2008-11-12 21:41:55 UTC (rev 725)
@@ -25,6 +25,7 @@
   virtual void init(const Task&, DiscreteStateValueVector&,
                     ContinousStateValueVector&,
                     const PortValueList&) const;
+  virtual void initDesignPosition(PortValueList&) const;
   virtual void velocity(const Task&, const ContinousStateValueVector& states,
                         PortValueList& portValues) const;
   virtual void articulation(const Task&, const ContinousStateValueVector&,

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/PrismaticJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/PrismaticJoint.cpp	2008-11-12 05:55:49 UTC (rev 724)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/PrismaticJoint.cpp	2008-11-12 21:41:55 UTC (rev 725)
@@ -19,6 +19,7 @@
 
 BEGIN_OPENFDM_OBJECT_DEF(PrismaticJoint, Joint)
   DEF_OPENFDM_PROPERTY(Vector3, Axis, Serialized)
+  DEF_OPENFDM_PROPERTY(Vector3, Position, Serialized)
   END_OPENFDM_OBJECT_DEF
 
 PrismaticJoint::PrismaticJoint(const std::string& name) :
@@ -27,7 +28,8 @@
   mVelocityPort(this, "velocity", Size(1, 1)),
   mPositionStateInfo(new Vector1StateInfo),
   mVelocityStateInfo(new Vector1StateInfo),
-  mAxis(Vector3(1, 0, 0))
+  mAxis(Vector3(1, 0, 0)),
+  mPosition(Vector3(0, 0, 0))
 {
   addContinousStateInfo(mPositionStateInfo);
   addContinousStateInfo(mVelocityStateInfo);
@@ -58,7 +60,19 @@
   setJointMatrix(Vector6(Vector3::zeros(), mAxis));
 }
 
+const Vector3&
+PrismaticJoint::getPosition() const
+{
+  return mPosition;
+}
+
 void
+PrismaticJoint::setPosition(const Vector3& position)
+{
+  mPosition = position;
+}
+
+void
 PrismaticJoint::setEnableExternalForce(bool enable)
 {
   if (enable == getEnableExternalForce())
@@ -76,6 +90,13 @@
 }
 
 void
+PrismaticJoint::initDesignPosition(const MechanicLinkValue& parentLink,
+                                   MechanicLinkValue& childLink) const
+{
+  childLink.setDesignPosition(mPosition);
+}
+
+void
 PrismaticJoint::init(const Task&, DiscreteStateValueVector&,
                     ContinousStateValueVector& continousState,
                     const PortValueList&) const
@@ -98,7 +119,8 @@
   if (!mVelocityPort.empty())
     portValues[mVelocityPort] = jointVel;
   
-  velocity(parentLink, childLink, mAxis*jointPos, Quaternion::unit(),
+  Vector3 position = mAxis*jointPos + mPosition - parentLink.getDesignPosition();
+  velocity(parentLink, childLink, position, Quaternion::unit(),
            getJointMatrix()*jointVel);
 }
 

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/PrismaticJoint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/PrismaticJoint.h	2008-11-12 05:55:49 UTC (rev 724)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/PrismaticJoint.h	2008-11-12 21:41:55 UTC (rev 725)
@@ -33,11 +33,16 @@
   const Vector3& getAxis() const;
   void setAxis(const Vector3& axis);
 
+  const Vector3& getPosition() const;
+  void setPosition(const Vector3& position);
+
   void setEnableExternalForce(bool enable);
   bool getEnableExternalForce() const;
 
 protected:
 
+  virtual void initDesignPosition(const MechanicLinkValue& parentLink,
+                                  MechanicLinkValue& childLink) const;
   virtual void init(const Task&, DiscreteStateValueVector&,
                     ContinousStateValueVector& continousState,
                     const PortValueList&) const;
@@ -76,6 +81,7 @@
   SharedPtr<Vector1StateInfo> mVelocityStateInfo;
 
   Vector3 mAxis;
+  Vector3 mPosition;
 };
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteActuator.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteActuator.cpp	2008-11-12 05:55:49 UTC (rev 724)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteActuator.cpp	2008-11-12 21:41:55 UTC (rev 725)
@@ -19,6 +19,11 @@
 
 BEGIN_OPENFDM_OBJECT_DEF(RevoluteActuator, Joint)
   DEF_OPENFDM_PROPERTY(Vector3, Axis, Serialized)
+  DEF_OPENFDM_PROPERTY(Vector3, Position, Serialized)
+  DEF_OPENFDM_PROPERTY(Bool, VelocityControl, Serialized)
+  DEF_OPENFDM_PROPERTY(Real, MaxVel, Serialized)
+  DEF_OPENFDM_PROPERTY(Real, VelGain, Serialized)
+  DEF_OPENFDM_PROPERTY(Real, VelDotGain, Serialized)
   END_OPENFDM_OBJECT_DEF
 
 RevoluteActuator::RevoluteActuator(const std::string& name) :
@@ -28,7 +33,12 @@
   mVelocityPort(this, "velocity", Size(1, 1)),
   mPositionStateInfo(new Vector1StateInfo),
   mVelocityStateInfo(new Vector1StateInfo),
-  mAxis(Vector3(1, 0, 0))
+  mAxis(Vector3(1, 0, 0)),
+  mPosition(Vector3(0, 0, 0)),
+  mVelocityControl(false),
+  mVelGain(1),
+  mVelDotGain(1),
+  mMaxVel(1)
 {
   addContinousStateInfo(mPositionStateInfo);
   addContinousStateInfo(mVelocityStateInfo);
@@ -59,7 +69,26 @@
   setJointMatrix(Vector6(mAxis, Vector3::zeros()));
 }
 
+const Vector3&
+RevoluteActuator::getPosition() const
+{
+  return mPosition;
+}
+
 void
+RevoluteActuator::setPosition(const Vector3& position)
+{
+  mPosition = position;
+}
+
+void
+RevoluteActuator::initDesignPosition(const MechanicLinkValue& parentLink,
+                                     MechanicLinkValue& childLink) const
+{
+  childLink.setDesignPosition(mPosition);
+}
+
+void
 RevoluteActuator::init(const Task&, DiscreteStateValueVector&,
                        ContinousStateValueVector& continousState,
                        const PortValueList&) const
@@ -82,9 +111,8 @@
   if (!mVelocityPort.empty())
     portValues[mVelocityPort] = jointVel;
   
-  Vector3 position(0, 0, 0);
+  Vector3 position = mPosition - parentLink.getDesignPosition();
   Quaternion orientation(Quaternion::fromAngleAxis(jointPos(0), mAxis));
-
   velocity(parentLink, childLink, position, orientation, getJointMatrix()*jointVel);
 }
 
@@ -101,7 +129,7 @@
   // the joints accelerations, velocities and positions must fit together
   // otherwise the articulated body dynamics get fooled ...
 
-  if (mPositionControl) {
+  if (!mVelocityControl) {
     // The desired position input
     VectorN desiredPos = portValues[mInputPort];
     // Compute the error ...
@@ -136,7 +164,7 @@
   // the joints accelerations, velocities and positions must fit together
   // otherwise the articulated body dynamics get fooled ...
 
-  if (mPositionControl) {
+  if (!mVelocityControl) {
     // The desired position input
     VectorN desiredPos = portValues[mInputPort];
     // Compute the error ...

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteActuator.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteActuator.h	2008-11-12 05:55:49 UTC (rev 724)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteActuator.h	2008-11-12 21:41:55 UTC (rev 725)
@@ -33,8 +33,33 @@
   const Vector3& getAxis() const;
   void setAxis(const Vector3& axis);
 
+  const Vector3& getPosition() const;
+  void setPosition(const Vector3& position);
+
+  const bool& getVelocityControl(void) const
+  { return mVelocityControl; }
+  void setVelocityControl(const bool& velocityControl)
+  { mVelocityControl = velocityControl; }
+
+  const real_type& getMaxVel(void) const
+  { return mMaxVel; }
+  void setMaxVel(const real_type& maxVel)
+  { mMaxVel = maxVel; }
+
+  const real_type& getVelGain(void) const
+  { return mVelGain; }
+  void setVelGain(const real_type& velGain)
+  { mVelGain = velGain; }
+
+  const real_type& getVelDotGain(void) const
+  { return mVelDotGain; }
+  void setVelDotGain(const real_type& velDotGain)
+  { mVelDotGain = velDotGain; }
+
 protected:
 
+  virtual void initDesignPosition(const MechanicLinkValue& parentLink,
+                                  MechanicLinkValue& childLink) const;
   virtual void init(const Task&, DiscreteStateValueVector&,
                     ContinousStateValueVector& continousState,
                     const PortValueList&) const;
@@ -73,7 +98,8 @@
   SharedPtr<Vector1StateInfo> mVelocityStateInfo;
 
   Vector3 mAxis;
-  bool mPositionControl;
+  Vector3 mPosition;
+  bool mVelocityControl;
   real_type mVelGain;
   real_type mVelDotGain;
   real_type mMaxVel;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.cpp	2008-11-12 05:55:49 UTC (rev 724)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.cpp	2008-11-12 21:41:55 UTC (rev 725)
@@ -19,6 +19,7 @@
 
 BEGIN_OPENFDM_OBJECT_DEF(RevoluteJoint, Joint)
   DEF_OPENFDM_PROPERTY(Vector3, Axis, Serialized)
+  DEF_OPENFDM_PROPERTY(Vector3, Position, Serialized)
   END_OPENFDM_OBJECT_DEF
 
 RevoluteJoint::RevoluteJoint(const std::string& name) :
@@ -27,7 +28,8 @@
   mVelocityPort(this, "velocity", Size(1, 1)),
   mPositionStateInfo(new Vector1StateInfo),
   mVelocityStateInfo(new Vector1StateInfo),
-  mAxis(Vector3(1, 0, 0))
+  mAxis(Vector3(1, 0, 0)),
+  mPosition(Vector3(0, 0, 0))
 {
   addContinousStateInfo(mPositionStateInfo);
   addContinousStateInfo(mVelocityStateInfo);
@@ -58,7 +60,19 @@
   setJointMatrix(Vector6(mAxis, Vector3::zeros()));
 }
 
+const Vector3&
+RevoluteJoint::getPosition() const
+{
+  return mPosition;
+}
+
 void
+RevoluteJoint::setPosition(const Vector3& position)
+{
+  mPosition = position;
+}
+
+void
 RevoluteJoint::setEnableExternalForce(bool enable)
 {
   if (enable == getEnableExternalForce())
@@ -76,6 +90,13 @@
 }
 
 void
+RevoluteJoint::initDesignPosition(const MechanicLinkValue& parentLink,
+                                  MechanicLinkValue& childLink) const
+{
+  childLink.setDesignPosition(mPosition);
+}
+
+void
 RevoluteJoint::init(const Task&, DiscreteStateValueVector&,
                     ContinousStateValueVector& continousState,
                     const PortValueList&) const
@@ -97,8 +118,10 @@
   VectorN jointVel = states[*mVelocityStateInfo];
   if (!mVelocityPort.empty())
     portValues[mVelocityPort] = jointVel;
-  
-  velocity(parentLink, childLink, Vector3(0, 0, 0),
+
+  // FIXME: move that somewhere into the context??
+  Vector3 position = mPosition - parentLink.getDesignPosition();
+  velocity(parentLink, childLink, position,
            Quaternion::fromAngleAxis(jointPos(0), mAxis),
            getJointMatrix()*jointVel);
 }

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.h	2008-11-12 05:55:49 UTC (rev 724)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.h	2008-11-12 21:41:55 UTC (rev 725)
@@ -33,11 +33,16 @@
   const Vector3& getAxis() const;
   void setAxis(const Vector3& axis);
 
+  const Vector3& getPosition() const;
+  void setPosition(const Vector3& position);
+
   void setEnableExternalForce(bool enable);
   bool getEnableExternalForce() const;
 
 protected:
 
+  virtual void initDesignPosition(const MechanicLinkValue& parentLink,
+                                  MechanicLinkValue& childLink) const;
   virtual void init(const Task&, DiscreteStateValueVector&,
                     ContinousStateValueVector& continousState,
                     const PortValueList&) const;
@@ -76,6 +81,7 @@
   SharedPtr<Vector1StateInfo> mVelocityStateInfo;
 
   Vector3 mAxis;
+  Vector3 mPosition;
 };
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.cpp	2008-11-12 05:55:49 UTC (rev 724)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.cpp	2008-11-12 21:41:55 UTC (rev 725)
@@ -18,6 +18,11 @@
   virtual const RootJoint& getNode() const
   { return *mRootJoint; }
   
+  virtual void initDesignPosition()
+  {
+    mRootJoint->initDesignPosition(mPortValueList);
+  }
+
   bool alloc()
   { if (!allocStates()) return false; return mRootJoint->alloc(*this); }
   virtual void initVelocities(const /*Init*/Task& task)

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.h	2008-11-12 05:55:49 UTC (rev 724)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.h	2008-11-12 21:41:55 UTC (rev 725)
@@ -29,6 +29,8 @@
   void setAngularBaseVelocity(const Vector3& angularBaseVelocity)
   { mAngularBaseVelocity = angularBaseVelocity; }
 
+  virtual void initDesignPosition(PortValueList&) const = 0;
+
   virtual void velocity(const Task&, const ContinousStateValueVector&,
                         PortValueList&) const = 0;
   virtual void articulation(const Task&, const ContinousStateValueVector&,

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/UniversalJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/UniversalJoint.cpp	2008-11-12 05:55:49 UTC (rev 724)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/UniversalJoint.cpp	2008-11-12 21:41:55 UTC (rev 725)
@@ -19,6 +19,7 @@
 
 BEGIN_OPENFDM_OBJECT_DEF(UniversalJoint, Joint)
   DEF_OPENFDM_PROPERTY(Vector3, Axis, Serialized)
+  DEF_OPENFDM_PROPERTY(Vector3, Position, Serialized)
   END_OPENFDM_OBJECT_DEF
 
 UniversalJoint::UniversalJoint(const std::string& name) :
@@ -27,7 +28,8 @@
   mVelocityPort(this, "velocity", Size(2, 1)),
   mPositionStateInfo(new Vector3StateInfo),
   mVelocityStateInfo(new Vector2StateInfo),
-  mAxis(Vector3(1, 0, 0))
+  mAxis(Vector3(1, 0, 0)),
+  mPosition(0, 0, 0)
 {
   addContinousStateInfo(mPositionStateInfo);
   addContinousStateInfo(mVelocityStateInfo);
@@ -66,7 +68,19 @@
   setJointMatrix(jointMatrix);
 }
 
+const Vector3&
+UniversalJoint::getPosition() const
+{
+  return mPosition;
+}
+
 void
+UniversalJoint::setPosition(const Vector3& position)
+{
+  mPosition = position;
+}
+
+void
 UniversalJoint::setEnableExternalForce(bool enable)
 {
   if (enable == getEnableExternalForce())
@@ -84,6 +98,13 @@
 }
 
 void
+UniversalJoint::initDesignPosition(const MechanicLinkValue& parentLink,
+                                  MechanicLinkValue& childLink) const
+{
+  childLink.setDesignPosition(mPosition);
+}
+
+void
 UniversalJoint::init(const Task&, DiscreteStateValueVector&,
                     ContinousStateValueVector& continousState,
                     const PortValueList&) const
@@ -109,7 +130,8 @@
   if (!mVelocityPort.empty())
     portValues[mVelocityPort] = jointVel;
   
-  velocity(parentLink, childLink, Vector3(0, 0, 0),
+  Vector3 position = mPosition - parentLink.getDesignPosition();
+  velocity(parentLink, childLink, position,
            orientation, getJointMatrix()*jointVel);
 }
 

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/UniversalJoint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/UniversalJoint.h	2008-11-12 05:55:49 UTC (rev 724)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/UniversalJoint.h	2008-11-12 21:41:55 UTC (rev 725)
@@ -33,11 +33,16 @@
   const Vector3& getAxis() const;
   void setAxis(const Vector3& axis);
 
+  const Vector3& getPosition() const;
+  void setPosition(const Vector3& position);
+
   void setEnableExternalForce(bool enable);
   bool getEnableExternalForce() const;
 
 protected:
 
+  virtual void initDesignPosition(const MechanicLinkValue& parentLink,
+                                  MechanicLinkValue& childLink) const;
   virtual void init(const Task&, DiscreteStateValueVector&,
                     ContinousStateValueVector& continousState,
                     const PortValueList&) const;
@@ -76,6 +81,7 @@
   SharedPtr<Vector2StateInfo> mVelocityStateInfo;
 
   Vector3 mAxis;
+  Vector3 mPosition;
   Quaternion mOrientation;
 };
 



From frohlich at mail.berlios.de  Thu Nov 13 06:46:48 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Thu, 13 Nov 2008 06:46:48 +0100
Subject: [OpenFDM-svn] r726 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811130546.mAD5kmx0016599@sheep.berlios.de>

Author: frohlich
Date: 2008-11-13 06:46:45 +0100 (Thu, 13 Nov 2008)
New Revision: 726

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJoint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJoint.h
Log:
A FixedRootJoint must have a position.

M    FixedRootJoint.h
M    FixedRootJoint.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJoint.cpp	2008-11-12 21:41:55 UTC (rev 725)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJoint.cpp	2008-11-13 05:46:45 UTC (rev 726)
@@ -18,11 +18,15 @@
 namespace OpenFDM {
 
 BEGIN_OPENFDM_OBJECT_DEF(FixedRootJoint, RootJoint)
+  DEF_OPENFDM_PROPERTY(Vector3, Position, Serialized)
+  DEF_OPENFDM_PROPERTY(Quaternion, Orientation, Serialized)
   END_OPENFDM_OBJECT_DEF
 
 FixedRootJoint::FixedRootJoint(const std::string& name) :
   RootJoint(name),
-  mMechanicLink(newMechanicLink("link"))
+  mMechanicLink(newMechanicLink("link")),
+  mPosition(0, 0, 0),
+  mOrientation(Quaternion::unit())
 {
 }
 
@@ -30,7 +34,31 @@
 {
 }
 
+const Vector3&
+FixedRootJoint::getPosition() const
+{
+  return mPosition;
+}
+
 void
+FixedRootJoint::setPosition(const Vector3& position)
+{
+  mPosition = position;
+}
+
+const Quaternion&
+FixedRootJoint::getOrientation() const
+{
+  return mOrientation;
+}
+
+void
+FixedRootJoint::setOrientation(const Quaternion& orientation)
+{
+  mOrientation = orientation;
+}
+
+void
 FixedRootJoint::init(const Task&, DiscreteStateValueVector&,
                       ContinousStateValueVector& continousState,
                       const PortValueList& portValues) const
@@ -48,12 +76,8 @@
                           const ContinousStateValueVector& continousState,
                           PortValueList& portValues) const
 {
-  Vector3 position(0, 0, 0);
-  Quaternion orientation = Quaternion::unit();
-  Vector6 velocity = Vector6::zeros();
-
-  portValues[mMechanicLink].setPosAndVel(getAngularBaseVelocity(),
-                                         position, orientation, velocity);
+  portValues[mMechanicLink].setPosAndVel(getAngularBaseVelocity(), mPosition,
+                                         mOrientation, Vector6::zeros());
 }
 
 void

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJoint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJoint.h	2008-11-12 21:41:55 UTC (rev 725)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJoint.h	2008-11-13 05:46:45 UTC (rev 726)
@@ -22,6 +22,14 @@
   FixedRootJoint(const std::string& name);
   virtual ~FixedRootJoint();
 
+  /// The position is global coordinates
+  const Vector3& getPosition() const;
+  void setPosition(const Vector3& position);
+
+  /// The orientation is global coordinates
+  const Quaternion& getOrientation() const;
+  void setOrientation(const Quaternion& orientation);
+
   virtual void init(const Task&, DiscreteStateValueVector&,
                     ContinousStateValueVector&,
                     const PortValueList&) const;
@@ -34,6 +42,9 @@
                             PortValueList& portValues) const;
 private:
   MechanicLink mMechanicLink;
+
+  Vector3 mPosition;
+  Quaternion mOrientation;
 };
 
 } // namespace OpenFDM



From frohlich at mail.berlios.de  Thu Nov 13 07:03:04 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Thu, 13 Nov 2008 07:03:04 +0100
Subject: [OpenFDM-svn] r727 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811130603.mAD63407003035@sheep.berlios.de>

Author: frohlich
Date: 2008-11-13 07:03:00 +0100 (Thu, 13 Nov 2008)
New Revision: 727

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/HDF5SystemOutput.h
Log:
Hmm, improove(?!) hdf5 output a bit.

M    HDF5SystemOutput.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/HDF5SystemOutput.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/HDF5SystemOutput.h	2008-11-13 05:46:45 UTC (rev 726)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/HDF5SystemOutput.h	2008-11-13 06:03:00 UTC (rev 727)
@@ -195,24 +195,40 @@
 class HDFMatrixStream : public HDF5Object {
 public:
   HDFMatrixStream(const HDF5Object& parent, const std::string& name,
-                  const Size& size)
+                  const Size& size) :
+    _timeIndex(0)
   {
     hsize_t _chunklen(100);
     herr_t status;
     hsize_t rank = 3;
+    _dims[0] = 1;
     if (size(0) == 1) {
-      rank = 2;
-      if (size(1) == 1)
+      if (size(1) == 1) {
         rank = 1;
+        _dims[1] = 0;
+        _dims[2] = 0;
+      } else {
+        rank = 2;
+        _dims[1] = size(1);
+        _dims[2] = 0;
+      }
+    } else {
+      if (size(1) == 1) {
+        rank = 2;
+        _dims[1] = size(0);
+        _dims[2] = 0;
+      } else {
+        rank = 3;
+        _dims[1] = size(1);
+        _dims[2] = size(0);
+      }
     }
-    _dims[0] = 1;
-    _dims[1] = size(1);
-    _dims[2] = size(0);
     hsize_t maxdims[3] = { H5S_UNLIMITED, _dims[1], _dims[2] };
     _dataspace = HDF5Object(H5Screate_simple(rank, _dims, maxdims), true);
     if (!_dataspace.valid())
       return;
 
+    _timeIndex = 0;
     _dims[0] = 0;
 
     hsize_t chunk_dims[3] = { _chunklen, _dims[1], _dims[2] };
@@ -262,6 +278,7 @@
 
 private:
   hsize_t _dims[3];
+  unsigned _timeIndex;
   HDF5Object _dataspace;
 };
 



From frohlich at mail.berlios.de  Thu Nov 13 07:14:54 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Thu, 13 Nov 2008 07:14:54 +0100
Subject: [OpenFDM-svn] r728 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200811130614.mAD6EsMp014292@sheep.berlios.de>

Author: frohlich
Date: 2008-11-13 07:14:53 +0100 (Thu, 13 Nov 2008)
New Revision: 728

Modified:
   branches/OpenFDM-StateSeparation/src/test/foucault.cpp
Log:
Hmm, looks like the universal joint needs some debugging

M    foucault.cpp


Modified: branches/OpenFDM-StateSeparation/src/test/foucault.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/foucault.cpp	2008-11-13 06:03:00 UTC (rev 727)
+++ branches/OpenFDM-StateSeparation/src/test/foucault.cpp	2008-11-13 06:14:53 UTC (rev 728)
@@ -2,9 +2,11 @@
 #include <OpenFDM/Mass.h>
 #include <OpenFDM/FixedRootJoint.h>
 #include <OpenFDM/UniversalJoint.h>
+// #include <OpenFDM/RevoluteJoint.h>
 #include <OpenFDM/RigidBody.h>
 #include <OpenFDM/System.h>
 #include <OpenFDM/SystemOutput.h>
+// #include <OpenFDM/Planet.h>
 
 using namespace OpenFDM;
 
@@ -12,15 +14,23 @@
 {
   // Model of the paris pendulum or foucault pendulum to test coriolis effects.
 
-  // FIXME, need usable positioning algorithm first ...
+  // Position of the pendulum
+//   Geocentric geocentric()
+  // Test the direction of the velocity vector projected to the ground plane
+
+  // FIXME, need usable environment stuff like gravity first ...
   SharedPtr<Group> group = new Group("Foucault");
-  Group::NodeId root = group->addChild(new FixedRootJoint("Root"));
+  FixedRootJoint* fixedRoot = new FixedRootJoint("Root");
+  fixedRoot->setPosition(Vector3(0, 0, -10));
+  Group::NodeId root = group->addChild(fixedRoot);
   UniversalJoint* universalJoint = new UniversalJoint("Universal");
   universalJoint->setAxis(Vector3(0, 0, 1));
+//   RevoluteJoint* universalJoint = new RevoluteJoint("Revolute");
+//   universalJoint->setAxis(Vector3(0, 1, 0));
   Group::NodeId universal = group->addChild(universalJoint);
   Group::NodeId rigidBody = group->addChild(new RigidBody("Rigid Body"));
   Mass* massModel = new Mass("Mass", 1, InertiaMatrix(1, 0, 0, 1, 0, 1));
-  massModel->setPosition(Vector3(1, 1, 1));
+  massModel->setPosition(Vector3(1, 0, 0));
   Group::NodeId mass = group->addChild(massModel);
 
   group->connect(root, 0, universal, 0);



From frohlich at mail.berlios.de  Sun Nov 16 08:36:45 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 16 Nov 2008 08:36:45 +0100
Subject: [OpenFDM-svn] r729 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811160736.mAG7ajom004784@sheep.berlios.de>

Author: frohlich
Date: 2008-11-16 08:36:45 +0100 (Sun, 16 Nov 2008)
New Revision: 729

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
Log:
Try to implement propper model sorting in face of mechanic models.

M    src/OpenFDM/System.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-13 06:14:53 UTC (rev 728)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-16 07:36:45 UTC (rev 729)
@@ -113,15 +113,15 @@
   }
 
   void appendModelContext(const SampleTime& sampleTime,
-                          ModelContext* modelContext)
+                          ModelContext* modelContext, unsigned listIndex)
   {
     // The init task contains them all
-    mInitTask->mModelContextList[0].push_back(modelContext);
+    mInitTask->mModelContextList[listIndex].push_back(modelContext);
     
     // for now continous tasks take also all of them
     mContinousTask->appendStateValuesFromLeafContext(*modelContext);
     if (sampleTime.isContinous())
-      mContinousTask->mModelContextList[0].push_back(modelContext);
+      mContinousTask->mModelContextList[listIndex].push_back(modelContext);
 
     // Discrete tasks need special treatment
     if (sampleTime.isDiscrete()) {
@@ -129,6 +129,7 @@
       for (unsigned i = 0; i < mDiscreteTaskList.size(); ++i) {
         if (!equal(mDiscreteTaskList[i]->getStepsize(), realSampleTime))
           continue;
+        // FIXME: is this true??? No model index here??
         mDiscreteTaskList[i]->mModelContextList.push_back(modelContext);
         break;
       }
@@ -899,6 +900,8 @@
   NodeInstanceDataList mNodeInstanceDataList;
   // The Models list, worthwhile for sorting
   ModelInstanceDataList mModelInstanceDataList;
+  ModelInstanceDataList mVelocityModelInstanceDataList;
+  ModelInstanceDataList mAccelerationModelInstanceDataList;
   // The mechanical system list, also for sorting
   MechanicInstanceDataList mMechanicInstanceDataList;
 
@@ -928,7 +931,7 @@
   // to simulate the system.
   AbstractSystem* buildSystem()
   {
-    // The MechanicNode instances are sorted to match the direct input property
+    // Build the spanning tree for the mechanic system
     if (!sortMechanicList())
       return 0;
     // The model instances are sorted to match the direct input property
@@ -956,9 +959,21 @@
     for (i = mModelInstanceDataList.begin();
          i != mModelInstanceDataList.end(); ++i) {
       discreteSystem->appendModelContext((*i)->getSampleTime(),
-                                         (*i)->getModelContext());
+                                         (*i)->getModelContext(), 0);
     }
 
+    for (i = mVelocityModelInstanceDataList.begin();
+         i != mVelocityModelInstanceDataList.end(); ++i) {
+      discreteSystem->appendModelContext((*i)->getSampleTime(),
+                                         (*i)->getModelContext(), 1);
+    }
+
+    for (i = mAccelerationModelInstanceDataList.begin();
+         i != mAccelerationModelInstanceDataList.end(); ++i) {
+      discreteSystem->appendModelContext((*i)->getSampleTime(),
+                                         (*i)->getModelContext(), 2);
+    }
+
     MechanicInstanceDataList::const_iterator j;
     for (j = mMechanicInstanceDataList.begin();
          j != mMechanicInstanceDataList.end(); ++j) {
@@ -1070,14 +1085,126 @@
     return true;
   }
 
-  // method to sort the leafs according to their dependency
+  bool isDirectVelocityDependent(ModelInstanceData& modelInstanceData)
+  {
+    MechanicInstanceDataList::iterator i = mMechanicInstanceDataList.begin();
+    for (; i != mMechanicInstanceDataList.end(); ++i) {
+      if (modelInstanceData.dependsOn(*(*i), false))
+        return true;
+      if (modelInstanceData.dependsOn(*(*i), true))
+        return true;
+    }
+    return false;
+  }
+
+  bool isDirectForceModel(ModelInstanceData& modelInstanceData)
+  {
+    MechanicInstanceDataList::iterator i = mMechanicInstanceDataList.begin();
+    for (; i != mMechanicInstanceDataList.end(); ++i) {
+      if ((*i)->dependsOn(modelInstanceData))
+        return true;
+    }
+    return false;
+  }
+
+  void
+  getVelocityDependentModels(ModelInstanceDataList& velocityDependentModels)
+  {
+    // find all models that are dependent on the mechanic systems velocities
+    ModelInstanceDataList::iterator i = mModelInstanceDataList.begin();
+    while (i != mModelInstanceDataList.end()) {
+      if (isDirectVelocityDependent(*(*i))) {
+        velocityDependentModels.push_back(*i);
+        i = mModelInstanceDataList.erase(i);
+      } else {
+        ++i;
+      }
+    }
+
+    for (i = velocityDependentModels.begin();
+         i != velocityDependentModels.end(); ++i) {
+
+      ModelInstanceDataList::iterator j = mModelInstanceDataList.begin();
+      while (j != mModelInstanceDataList.end()) {
+        if ((*j)->dependsOn(*(*i))) {
+          velocityDependentModels.push_back(*j);
+          j = mModelInstanceDataList.erase(j);
+        } else {
+          ++j;
+        }
+      }
+    }
+  }
+
+  void splitForceModels(ModelInstanceDataList& velocityDependentModels,
+                        ModelInstanceDataList& forceModelList)
+  {
+    ModelInstanceDataList::iterator i = velocityDependentModels.begin();
+    while (i != velocityDependentModels.end()) {
+      if (isDirectForceModel(*(*i))) {
+        forceModelList.push_back(*i);
+        i = velocityDependentModels.erase(i);
+      } else {
+        ++i;
+      }
+    }
+
+    for (i = forceModelList.begin();
+         i != forceModelList.end(); ++i) {
+
+      ModelInstanceDataList::iterator j = velocityDependentModels.begin();
+      while (j != velocityDependentModels.end()) {
+        if ((*i)->dependsOn(*(*j))) {
+          forceModelList.push_back(*j);
+          j = velocityDependentModels.erase(j);
+        } else {
+          ++j;
+        }
+      }
+    }
+  }
+
   bool sortModelList()
   {
+    // How to sort:
+    //  * First split out all velocity dependent models.
+    //  * build up a usual sorted list of models
+    //  * Go from the back of this list and push all models in the acceleration
+    //    list when it is not needed for the forces (?? does not work ??)
+    //    (hmm, alternatively build the force list by walking back the velocity
+    //     list and pulling out all chains that depend on force.
+    //     The old velocity list is than the acceleration one??)
+    //  * Check the resulting velocity list for dependency on acceleration
+    
+    // get the list of models that depend on the mechnic systems velocity or
+    // acceleration
+    getVelocityDependentModels(mAccelerationModelInstanceDataList);
+
+    // Seperate out those models that are really required for forces
+    splitForceModels(mAccelerationModelInstanceDataList,
+                     mVelocityModelInstanceDataList);
+
+    // Sort that lists according to the usual rules
+    if (!sortModelList(mModelInstanceDataList))
+      return false;
+
+    if (!sortModelList(mVelocityModelInstanceDataList))
+      return false;
+
+    if (!sortModelList(mAccelerationModelInstanceDataList))
+      return false;
+
+    return true;
+  }
+
+  // method to sort the leafs according to their dependency
+  bool sortModelList(ModelInstanceDataList& modelInstanceDataList)
+  {
     ModelInstanceDataList sortedModelInstanceDataList;
-    while (!mModelInstanceDataList.empty()) {
+    while (!modelInstanceDataList.empty()) {
       SharedPtr<ModelInstanceData> modelInstanceData;
-      modelInstanceData = mModelInstanceDataList.front();
-      mModelInstanceDataList.pop_front();
+      modelInstanceData = modelInstanceDataList.front();
+      modelInstanceDataList.pop_front();
 
       if (modelInstanceData->dependsOn(*modelInstanceData)) {
         Log(Schedule, Warning)
@@ -1128,11 +1255,11 @@
         }
       }
     }
-    mModelInstanceDataList.swap(sortedModelInstanceDataList);
+    modelInstanceDataList.swap(sortedModelInstanceDataList);
 
     Log(Schedule,Info) << "Model Schedule" << std::endl;
-    ModelInstanceDataList::iterator i = mModelInstanceDataList.begin();
-    for (; i != mModelInstanceDataList.end(); ++i) {
+    ModelInstanceDataList::iterator i = modelInstanceDataList.begin();
+    for (; i != modelInstanceDataList.end(); ++i) {
       Log(Schedule,Info)
         << "  Model \"" << (*i)->getNodeNamePath() << "\"" << std::endl;
     }



From frohlich at mail.berlios.de  Sun Nov 16 09:25:34 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 16 Nov 2008 09:25:34 +0100
Subject: [OpenFDM-svn] r730 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811160825.mAG8PYj4006832@sheep.berlios.de>

Author: frohlich
Date: 2008-11-16 09:25:33 +0100 (Sun, 16 Nov 2008)
New Revision: 730

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/HDF5SystemOutput.h
Log:
The output function is virtual.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/HDF5SystemOutput.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/HDF5SystemOutput.h	2008-11-16 07:36:45 UTC (rev 729)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/HDF5SystemOutput.h	2008-11-16 08:25:33 UTC (rev 730)
@@ -292,7 +292,7 @@
   virtual ~HDF5SystemOutput()
   { }
 
-  void output(const real_type& t)
+  virtual void output(const real_type& t)
   {
     mTimeStream.append(t);
     DumperList::iterator i;



From frohlich at mail.berlios.de  Sun Nov 16 15:13:45 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 16 Nov 2008 15:13:45 +0100
Subject: [OpenFDM-svn] r731 - in branches/OpenFDM-StateSeparation/src:
	OpenFDM test
Message-ID: <200811161413.mAGEDj5c005388@sheep.berlios.de>

Author: frohlich
Date: 2008-11-16 15:13:43 +0100 (Sun, 16 Nov 2008)
New Revision: 731

Added:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.cpp
Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Group.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
   branches/OpenFDM-StateSeparation/src/OpenFDM/MatrixOutputPort.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/PortInfo.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/RealOutputPort.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.h
   branches/OpenFDM-StateSeparation/src/test/foucault.cpp
Log:
Implement a sensor.

M    src/test/foucault.cpp
A    src/OpenFDM/Sensor.cpp
M    src/OpenFDM/RealOutputPort.h
M    src/OpenFDM/MatrixOutputPort.h
M    src/OpenFDM/Group.h
M    src/OpenFDM/Makefile.am
M    src/OpenFDM/Sensor.h
M    src/OpenFDM/Interact.h
M    src/OpenFDM/PortInfo.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Group.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Group.h	2008-11-16 08:25:33 UTC (rev 730)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Group.h	2008-11-16 14:13:43 UTC (rev 731)
@@ -61,7 +61,7 @@
 public:
   GroupInput(const std::string& name) :
     GroupInterfaceNode(name),
-    mGroupInternalPort(new OutputPortInfo(this, "output", Size(0, 0)))
+    mGroupInternalPort(new OutputPortInfo(this, "output", Size(0, 0), false))
   { }
 protected:
   virtual bool addParent(Node* parent)
@@ -86,7 +86,7 @@
   {
     if (!GroupInterfaceNode::addParent(parent))
       return false;
-    setExternalPortInfo(new OutputPortInfo(parent, "output", Size(0, 0)));
+    setExternalPortInfo(new OutputPortInfo(parent, "output", Size(0, 0), false));
     return true;
   }
 private:

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.h	2008-11-16 08:25:33 UTC (rev 730)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.h	2008-11-16 14:13:43 UTC (rev 731)
@@ -28,7 +28,6 @@
   virtual void articulation(const Task&, const ContinousStateValueVector&,
                             PortValueList&, Matrix&) const
   { }
-  // hmm, may be this should be output???
   virtual void acceleration(const Task&, const ContinousStateValueVector&,
                             PortValueList&, const Matrix&, Vector&) const
   { }

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-11-16 08:25:33 UTC (rev 730)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-11-16 14:13:43 UTC (rev 731)
@@ -242,6 +242,7 @@
   PrismaticJoint.cpp \
   RevoluteActuator.cpp \
   RevoluteJoint.cpp \
+  Sensor.cpp \
   UniversalJoint.cpp
 
 

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MatrixOutputPort.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MatrixOutputPort.h	2008-11-16 08:25:33 UTC (rev 730)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MatrixOutputPort.h	2008-11-16 14:13:43 UTC (rev 731)
@@ -12,9 +12,12 @@
 
 class MatrixOutputPort {
 public:
-  MatrixOutputPort(Node* node, const std::string& name, const Size& size) :
-    mPort(new OutputPortInfo(node, name, size))
+  MatrixOutputPort()
   { }
+  MatrixOutputPort(Node* node, const std::string& name, const Size& size,
+                   bool accelerationPort = false) :
+    mPort(new OutputPortInfo(node, name, size, accelerationPort))
+  { }
   NumericPortValue* getPortValue(const PortValueVector& portValueVector) const
   {
     PortValue* portValue = mPort->getPortValue(portValueVector);
@@ -28,6 +31,10 @@
   { if (!mPort) return; mPort->clear(); mPort = 0; }
   unsigned getPortIndex() const
   { return mPort->getIndex(); }
+  bool getAccelerationOutput() const
+  { OpenFDMAssert(mPort); return mPort->getAccelerationOutput(); }
+  void setAccelerationOutput(bool accelerationOutput)
+  { OpenFDMAssert(mPort); mPort->setAccelerationOutput(accelerationOutput); }
 private:
   SharedPtr<OutputPortInfo> mPort;
 };

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/PortInfo.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/PortInfo.h	2008-11-16 08:25:33 UTC (rev 730)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/PortInfo.h	2008-11-16 14:13:43 UTC (rev 731)
@@ -161,9 +161,10 @@
 
 class OutputPortInfo : public NumericPortInfo {
 public:
-  OutputPortInfo(Node* node, const std::string& name, const Size& size) :
+  OutputPortInfo(Node* node, const std::string& name, const Size& size,
+                 bool accelerationOutput) :
     NumericPortInfo(node, name, size),
-    mAccelerationOutput(false)
+    mAccelerationOutput(accelerationOutput)
   { }
   virtual ~OutputPortInfo()
   { }

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RealOutputPort.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RealOutputPort.h	2008-11-16 08:25:33 UTC (rev 730)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RealOutputPort.h	2008-11-16 14:13:43 UTC (rev 731)
@@ -13,9 +13,12 @@
 
 class RealOutputPort {
 public:
-  RealOutputPort(Node* node, const std::string& name) :
-    mPort(new OutputPortInfo(node, name, Size(1, 1)))
+  RealOutputPort()
   { }
+  RealOutputPort(Node* node, const std::string& name,
+                 bool accelerationPort = false) :
+    mPort(new OutputPortInfo(node, name, Size(1, 1), accelerationPort))
+  { }
   NumericPortValue* getPortValue(const PortValueVector& portValueVector) const
   {
     PortValue* portValue = mPort->getPortValue(portValueVector);
@@ -29,6 +32,10 @@
   { if (!mPort) return; mPort->clear(); mPort = 0; }
   unsigned getPortIndex() const
   { return mPort->getIndex(); }
+  bool getAccelerationOutput() const
+  { OpenFDMAssert(mPort); return mPort->getAccelerationOutput(); }
+  void setAccelerationOutput(bool accelerationOutput)
+  { OpenFDMAssert(mPort); mPort->setAccelerationOutput(accelerationOutput); }
 private:
   SharedPtr<OutputPortInfo> mPort;
 };

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.cpp	2008-11-16 08:25:33 UTC (rev 730)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.cpp	2008-11-16 14:13:43 UTC (rev 731)
@@ -0,0 +1,176 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
+ *
+ */
+
+#include "Sensor.h"
+
+#include "MechanicLinkValue.h"
+#include "NumericPortValue.h"
+#include "PortValueList.h"
+
+namespace OpenFDM {
+
+Sensor::Sensor(const std::string& name) :
+  Interact(name),
+  mMechanicLink(newMechanicLink("link")),
+  mPosition(0, 0, 0)
+{
+}
+
+Sensor::~Sensor(void)
+{
+}
+
+void
+Sensor::initDesignPosition(PortValueList& portValues) const
+{
+}
+
+void
+Sensor::velocity(const Task&, const ContinousStateValueVector&,
+                 PortValueList& portValues) const
+{
+  const Frame& frame = portValues[mMechanicLink].getFrame();
+
+  // FIXME, for now relative position
+  Vector3 position = mPosition - portValues[mMechanicLink].getDesignPosition();
+  Vector3 refPosition = frame.posToRef(position);
+
+  if (getEnablePosition())
+    portValues[mPositionPort] = refPosition;
+
+  if (getEnableOrientation())
+    portValues[mOrientationPort] = frame.getRefOrientation();
+
+  
+  Vector6 refVelocity = motionTo(refPosition, frame.getRefOrientation(),
+                                 Vector6::zeros());
+  if (getEnableAngularVelocity())
+    portValues[mAngularVelocityPort] = refVelocity.getAngular();
+
+  if (getEnableLinearVelocity())
+    portValues[mLinearVelocityPort] = refVelocity.getLinear();
+}
+
+void
+Sensor::acceleration(const Task&, const ContinousStateValueVector&,
+                     PortValueList& portValues, const Matrix&, Vector&) const
+{
+  const Frame& frame = portValues[mMechanicLink].getFrame();
+
+  // FIXME, for now relative position
+  Vector3 position = mPosition - portValues[mMechanicLink].getDesignPosition();
+
+  if (getEnableCentrifugalAcceleration()) {
+    Vector6 spatialVel = motionTo(position, frame.getSpVel());
+    Vector6 spatialAccel = motionTo(position, frame.getSpAccel());
+    Vector3 centrifugalAccel = spatialAccel.getLinear();
+    centrifugalAccel += cross(spatialVel.getAngular(), spatialVel.getLinear());
+
+    portValues[mCentrifugalAccelerationPort] = centrifugalAccel;
+  }
+
+//   if (getEnableLoadAcceleration())
+//     portValues[mLoadAccelerationPort] = centrifugalAccel + gravity;
+}
+
+void
+Sensor::setPosition(const Vector3& position)
+{
+  mPosition = position;
+}
+
+const Vector3&
+Sensor::getPosition() const
+{
+  return mPosition;
+}
+
+void
+Sensor::setEnablePosition(bool enable)
+{
+  if (enable == getEnablePosition())
+    return;
+  if (enable)
+    mPositionPort = MatrixOutputPort(this, "position", Size(3, 1));
+  else
+    mPositionPort.clear();
+}
+
+bool
+Sensor::getEnablePosition() const
+{
+  return !mPositionPort.empty();
+}
+
+void
+Sensor::setEnableOrientation(bool enable)
+{
+  if (enable == getEnableOrientation())
+    return;
+  if (enable)
+    mOrientationPort = MatrixOutputPort(this, "orientation", Size(4, 1));
+  else
+    mOrientationPort.clear();
+}
+
+bool
+Sensor::getEnableOrientation() const
+{
+  return !mOrientationPort.empty();
+}
+
+void
+Sensor::setEnableLinearVelocity(bool enable)
+{
+  if (enable == getEnableLinearVelocity())
+    return;
+  if (enable)
+    mLinearVelocityPort = MatrixOutputPort(this, "linearVelocity", Size(3, 1));
+  else
+    mLinearVelocityPort.clear();
+}
+
+bool
+Sensor::getEnableLinearVelocity() const
+{
+  return !mLinearVelocityPort.empty();
+}
+
+void
+Sensor::setEnableAngularVelocity(bool enable)
+{
+  if (enable == getEnableAngularVelocity())
+    return;
+  if (enable)
+    mAngularVelocityPort
+      = MatrixOutputPort(this, "angularVelocity", Size(3, 1));
+  else
+    mAngularVelocityPort.clear();
+}
+
+bool
+Sensor::getEnableAngularVelocity() const
+{
+  return !mAngularVelocityPort.empty();
+}
+
+void
+Sensor::setEnableCentrifugalAcceleration(bool enable)
+{
+  if (enable == getEnableCentrifugalAcceleration())
+    return;
+  if (enable)
+    mCentrifugalAccelerationPort
+      = MatrixOutputPort(this, "centrifugalAcceleration", Size(3, 1), true);
+  else
+    mCentrifugalAccelerationPort.clear();
+}
+
+bool
+Sensor::getEnableCentrifugalAcceleration() const
+{
+  return !mCentrifugalAccelerationPort.empty();
+}
+
+} // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.h	2008-11-16 08:25:33 UTC (rev 730)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.h	2008-11-16 14:13:43 UTC (rev 731)
@@ -5,87 +5,66 @@
 #ifndef OpenFDM_Sensor_H
 #define OpenFDM_Sensor_H
 
-#include "Assert.h"
-#include "Object.h"
-#include "Vector.h"
-#include "Gravity.h"
-#include "Frame.h"
-#include "RigidBody.h"
-#include "Environment.h"
 #include "Interact.h"
+#include "MatrixOutputPort.h"
+#include "MechanicLink.h"
+#include "Vector.h"
 
 namespace OpenFDM {
 
-class Sensor
-  : public Interact {
+class Sensor : public Interact {
 public:
-  Sensor(const std::string& name) :
-    Interact(name, 1)
-  {
-    setNumOutputPorts(2);
-    setOutputPort(0, "nlfz", this, &Sensor::getNlfz);
-    setOutputPort(1, "az", this, &Sensor::getAz);
-  }
-  virtual ~Sensor(void)
-  { }
+  Sensor(const std::string& name);
+  virtual ~Sensor(void);
 
-  virtual bool init(void)
-  {
-    mNextNlfz = 0;
-    mNextAz = 0;
-    return Interact::init();
-  }
+  virtual void initDesignPosition(PortValueList&) const;
+  virtual void velocity(const Task&, const ContinousStateValueVector&,
+                        PortValueList&) const;
+  virtual void acceleration(const Task&, const ContinousStateValueVector&,
+                            PortValueList&, const Matrix&, Vector&) const;
 
-  virtual void output(const TaskInfo& taskInfo)
-  {
-    mNlfz = mNextNlfz;
-    mAz = mNextAz;
-  }
+  /// Set the position of the sensor in design coordinates
+  void setPosition(const Vector3& position);
+  /// Get the position of the sensor in design coordinates
+  const Vector3& getPosition() const;
 
-  virtual void update(const TaskInfo& taskInfo)
-  {
-    if (!nonZeroIntersection(taskInfo.getSampleTimeSet(), getSampleTimeSet()))
-        return;
+  /// Set availabilty of the position output port
+  void setEnablePosition(bool enable);
+  /// Get availabilty of the position output port
+  bool getEnablePosition() const;
 
-    mNextNlfz = 0;
-    mNextAz = 0;
-    RigidBody* rigidBody = getParentRigidBody(0);
-    if (!rigidBody)
-      return;
-    Frame* frame = rigidBody->getFrame();
-    if (!frame)
-      return;
-    const Gravity* grav = mEnvironment->getGravity();
-    if (!grav)
-      return;
-    Vector3 accel = frame->getClassicAccel().getLinear();
-    // That is the acceleration like sensed by a gyro
-    mNextAz = accel(2);
+  /// Set availabilty of the orientation output port
+  void setEnableOrientation(bool enable);
+  /// Get availabilty of the orientation output port
+  bool getEnableOrientation() const;
 
-    // Now compute the acceleration like sensed by anything sensing the
-    // gravitational stuff too
-    accel -= frame->rotFromRef(grav->gravityAccel(frame->getRefPosition()));
-    mNextNlfz = accel(2)/9.81;
-  }
+  /// Set availabilty of the linear velocity output port
+  void setEnableLinearVelocity(bool enable);
+  /// Get availabilty of the linear velocity output port
+  bool getEnableLinearVelocity() const;
 
-  const real_type& getNlfz(void) const
-  { return mNlfz; }
-  const real_type& getAz(void) const
-  { return mAz; }
+  /// Set availabilty of the angular velocity output port
+  void setEnableAngularVelocity(bool enable);
+  /// Get availabilty of the angular velocity output port
+  bool getEnableAngularVelocity() const;
 
-  virtual void interactWith(RigidBody*)
-  {}
+  /// Set availabilty of the linear acceleration output port
+  void setEnableCentrifugalAcceleration(bool enable);
+  /// Get availabilty of the linear acceleration output port
+  bool getEnableCentrifugalAcceleration() const;
 
-protected:
-  virtual void setEnvironment(Environment* environment)
-  { mEnvironment = environment; }
-
 private:
-  SharedPtr<Environment> mEnvironment;
-  real_type mNlfz;
-  real_type mNextNlfz;
-  real_type mAz;
-  real_type mNextAz;
+  MechanicLink mMechanicLink;
+
+  Vector3 mPosition;
+
+  MatrixOutputPort mPositionPort;
+  MatrixOutputPort mOrientationPort;
+
+  MatrixOutputPort mLinearVelocityPort;
+  MatrixOutputPort mAngularVelocityPort;
+
+  MatrixOutputPort mCentrifugalAccelerationPort;
 };
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/test/foucault.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/foucault.cpp	2008-11-16 08:25:33 UTC (rev 730)
+++ branches/OpenFDM-StateSeparation/src/test/foucault.cpp	2008-11-16 14:13:43 UTC (rev 731)
@@ -4,6 +4,7 @@
 #include <OpenFDM/UniversalJoint.h>
 // #include <OpenFDM/RevoluteJoint.h>
 #include <OpenFDM/RigidBody.h>
+#include <OpenFDM/Sensor.h>
 #include <OpenFDM/System.h>
 #include <OpenFDM/SystemOutput.h>
 // #include <OpenFDM/Planet.h>
@@ -28,14 +29,27 @@
 //   RevoluteJoint* universalJoint = new RevoluteJoint("Revolute");
 //   universalJoint->setAxis(Vector3(0, 1, 0));
   Group::NodeId universal = group->addChild(universalJoint);
-  Group::NodeId rigidBody = group->addChild(new RigidBody("Rigid Body"));
+
+  RigidBody* rigidBodyNode = new RigidBody("Rigid Body");
+  rigidBodyNode->addLink("sensorLink");
+  Group::NodeId rigidBody = group->addChild(rigidBodyNode);
   Mass* massModel = new Mass("Mass", 1, InertiaMatrix(1, 0, 0, 1, 0, 1));
   massModel->setPosition(Vector3(1, 0, 0));
   Group::NodeId mass = group->addChild(massModel);
 
+  Sensor* sensorModel = new Sensor("Sensor");
+  sensorModel->setPosition(massModel->getPosition());
+  sensorModel->setEnablePosition(true);
+  sensorModel->setEnableOrientation(true);
+  sensorModel->setEnableLinearVelocity(true);
+  sensorModel->setEnableAngularVelocity(true);
+  sensorModel->setEnableCentrifugalAcceleration(true);
+  Group::NodeId sensor = group->addChild(sensorModel);
+
   group->connect(root, 0, universal, 0);
   group->connect(universal, 1, rigidBody, 0);
   group->connect(rigidBody, 1, mass, 0);
+  group->connect(rigidBody, "sensorLink", sensor, "link");
 
   SharedPtr<System> system = new System("System", group);
 



From frohlich at mail.berlios.de  Sun Nov 16 15:26:41 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 16 Nov 2008 15:26:41 +0100
Subject: [OpenFDM-svn] r732 - in branches/OpenFDM-StateSeparation/src:
	OpenFDM test
Message-ID: <200811161426.mAGEQfju008810@sheep.berlios.de>

Author: frohlich
Date: 2008-11-16 15:26:40 +0100 (Sun, 16 Nov 2008)
New Revision: 732

Added:
   branches/OpenFDM-StateSeparation/src/OpenFDM/RotationalJoint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/RotationalJoint.h
Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
   branches/OpenFDM-StateSeparation/src/test/foucault.cpp
Log:
Use a completely free joint for rotation for the pendulum.

M    src/test/foucault.cpp
A    src/OpenFDM/RotationalJoint.h
M    src/OpenFDM/Makefile.am
A    src/OpenFDM/RotationalJoint.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-11-16 14:13:43 UTC (rev 731)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-11-16 14:26:40 UTC (rev 732)
@@ -206,6 +206,7 @@
   PrismaticJoint.h \
   RevoluteActuator.h \
   RevoluteJoint.h \
+  RotationalJoint.h \
   Saturation.h \
   Sensor.h \
   SimpleContact.h \
@@ -242,6 +243,7 @@
   PrismaticJoint.cpp \
   RevoluteActuator.cpp \
   RevoluteJoint.cpp \
+  RotationalJoint.cpp \
   Sensor.cpp \
   UniversalJoint.cpp
 

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/RotationalJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RotationalJoint.cpp	2008-11-16 14:13:43 UTC (rev 731)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RotationalJoint.cpp	2008-11-16 14:26:40 UTC (rev 732)
@@ -0,0 +1,163 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
+ *
+ */
+
+#include "RotationalJoint.h"
+#include "Assert.h"
+#include "LogStream.h"
+#include "Limits.h"
+#include "Object.h"
+#include "Vector.h"
+#include "Matrix.h"
+#include "Quaternion.h"
+#include "Inertia.h"
+#include "PortValueList.h"
+#include "ContinousStateValueVector.h"
+#include "MechanicContext.h"
+
+namespace OpenFDM {
+
+BEGIN_OPENFDM_OBJECT_DEF(RotationalJoint, Joint)
+  DEF_OPENFDM_PROPERTY(Vector3, Position, Serialized)
+  END_OPENFDM_OBJECT_DEF
+
+RotationalJoint::RotationalJoint(const std::string& name) :
+  CartesianJoint<3>(name),
+  mOrientationPort(this, "orientation", Size(4, 1)),
+  mVelocityPort(this, "velocity", Size(3, 1)),
+  mPositionStateInfo(new Vector4StateInfo),
+  mVelocityStateInfo(new Vector3StateInfo),
+  mPosition(0, 0, 0)
+{
+  addContinousStateInfo(mPositionStateInfo);
+  addContinousStateInfo(mVelocityStateInfo);
+
+  Matrix6N jointMatrix;
+  for (unsigned i = 0; i < 3; ++i)
+    for (unsigned j = 0; j < 6; ++j)
+      jointMatrix(j, i) = real_type(i == j);
+  setJointMatrix(jointMatrix);
+}
+
+RotationalJoint::~RotationalJoint(void)
+{
+}
+
+const Vector3&
+RotationalJoint::getPosition() const
+{
+  return mPosition;
+}
+
+void
+RotationalJoint::setPosition(const Vector3& position)
+{
+  mPosition = position;
+}
+
+void
+RotationalJoint::setEnableExternalForce(bool enable)
+{
+  if (enable == getEnableExternalForce())
+    return;
+  if (enable)
+    mForcePort = MatrixInputPort(this, "force", Size(3, 1), true);
+  else
+    mForcePort.clear();
+}
+
+bool
+RotationalJoint::getEnableExternalForce() const
+{
+  return !mForcePort.empty();
+}
+
+void
+RotationalJoint::initDesignPosition(const MechanicLinkValue& parentLink,
+                                  MechanicLinkValue& childLink) const
+{
+  childLink.setDesignPosition(mPosition);
+}
+
+void
+RotationalJoint::init(const Task&, DiscreteStateValueVector&,
+                    ContinousStateValueVector& continousState,
+                    const PortValueList&) const
+{
+  continousState[*mPositionStateInfo] = Quaternion::unit();
+  continousState[*mVelocityStateInfo] = Vector3::zeros();
+}
+
+void
+RotationalJoint::velocity(const MechanicLinkValue& parentLink,
+                        MechanicLinkValue& childLink,
+                        const ContinousStateValueVector& states,
+                        PortValueList& portValues) const
+{
+  Quaternion orientation = states[*mPositionStateInfo];
+  if (!mOrientationPort.empty())
+    portValues[mOrientationPort] = orientation;
+  
+  VectorN jointVel = states[*mVelocityStateInfo];
+  if (!mVelocityPort.empty())
+    portValues[mVelocityPort] = jointVel;
+  
+  Vector3 position = mPosition - parentLink.getDesignPosition();
+  velocity(parentLink, childLink, position,
+           orientation, getJointMatrix()*jointVel);
+}
+
+void
+RotationalJoint::articulation(MechanicLinkValue& parentLink,
+                            const MechanicLinkValue& childLink,
+                            const ContinousStateValueVector& states,
+                            PortValueList& portValues,
+                            MatrixFactorsNN& hIh) const
+{
+  VectorN jointForce;
+  if (mForcePort.empty())
+    jointForce.clear();
+  else
+    jointForce = portValues[mForcePort];
+  
+  articulation(parentLink, childLink, jointForce, hIh);
+}
+
+void
+RotationalJoint::acceleration(const MechanicLinkValue& parentLink,
+                            MechanicLinkValue& childLink,
+                            const ContinousStateValueVector& states,
+                            PortValueList& portValues,
+                            const MatrixFactorsNN& hIh, VectorN& velDot) const
+{
+  VectorN jointForce;
+  if (mForcePort.empty())
+    jointForce.clear();
+  else
+    jointForce = portValues[mForcePort];
+  
+  acceleration(parentLink, childLink, jointForce, hIh, velDot);
+}
+
+void
+RotationalJoint::derivative(const DiscreteStateValueVector&,
+                          const ContinousStateValueVector& states,
+                          const PortValueList&, const VectorN& velDot,
+                          ContinousStateValueVector& derivative) const
+{
+  Quaternion orientation = states[*mPositionStateInfo];
+  Quaternion q = orientation;
+
+  // Compute the derivative term originating from the angular velocity.
+  // Correction term to keep the quaternion normalized.
+  // That is if |q| < 1 add a little radial component outward,
+  // if |q| > 1 add a little radial component inward
+  Vector3 angVel = getJointMatrix()(Range(0, 2), Range(0, 2))
+    *states[*mVelocityStateInfo];
+  Vector4 qderiv = LinAlg::derivative(q, angVel) + 1e1*(normalize(q) - q);
+
+  derivative[*mPositionStateInfo] = qderiv;
+  derivative[*mVelocityStateInfo] = velDot;
+}
+
+} // namespace OpenFDM

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/RotationalJoint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RotationalJoint.h	2008-11-16 14:13:43 UTC (rev 731)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RotationalJoint.h	2008-11-16 14:26:40 UTC (rev 732)
@@ -0,0 +1,85 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_RotationalJoint_H
+#define OpenFDM_RotationalJoint_H
+
+#include "Assert.h"
+#include "Object.h"
+#include "Vector.h"
+#include "Matrix.h"
+#include "MatrixStateInfo.h"
+#include "Quaternion.h"
+#include "Inertia.h"
+#include "Joint.h"
+#include "MatrixInputPort.h"
+#include "MatrixOutputPort.h"
+#include "ContinousStateValueVector.h"
+#include "PortValueList.h"
+#include "MechanicContext.h"
+#include "CartesianJoint.h"
+
+namespace OpenFDM {
+
+class RotationalJoint : public CartesianJoint<3> {
+  OPENFDM_OBJECT(RotationalJoint, Joint);
+public:
+  RotationalJoint(const std::string& name);
+  virtual ~RotationalJoint(void);
+
+  /** Sets the joint axis where this joint is allowed to rotate around.
+   */
+  const Vector3& getPosition() const;
+  void setPosition(const Vector3& position);
+
+  void setEnableExternalForce(bool enable);
+  bool getEnableExternalForce() const;
+
+protected:
+
+  virtual void initDesignPosition(const MechanicLinkValue& parentLink,
+                                  MechanicLinkValue& childLink) const;
+  virtual void init(const Task&, DiscreteStateValueVector&,
+                    ContinousStateValueVector& continousState,
+                    const PortValueList&) const;
+
+  virtual void velocity(const MechanicLinkValue& parentLink,
+                        MechanicLinkValue& childLink,
+                        const ContinousStateValueVector& states,
+                        PortValueList& portValues) const;
+  virtual void articulation(MechanicLinkValue& parentLink,
+                            const MechanicLinkValue& childLink,
+                            const ContinousStateValueVector& states,
+                            PortValueList& portValues,
+                            MatrixFactorsNN& hIh) const;
+  virtual void acceleration(const MechanicLinkValue& parentLink,
+                            MechanicLinkValue& childLink,
+                            const ContinousStateValueVector& states,
+                            PortValueList& portValues,
+                            const MatrixFactorsNN& hIh, VectorN& velDot) const;
+
+  virtual void derivative(const DiscreteStateValueVector&,
+                          const ContinousStateValueVector&,
+                          const PortValueList& portValues,
+                          const VectorN& velDot,
+                          ContinousStateValueVector&) const;
+
+  using CartesianJoint<3>::velocity;
+  using CartesianJoint<3>::articulation;
+  using CartesianJoint<3>::acceleration;
+
+private:
+  MatrixInputPort mForcePort;
+  MatrixOutputPort mOrientationPort;
+  MatrixOutputPort mVelocityPort;
+
+  SharedPtr<Vector4StateInfo> mPositionStateInfo;
+  SharedPtr<Vector3StateInfo> mVelocityStateInfo;
+
+  Vector3 mPosition;
+};
+
+} // namespace OpenFDM
+
+#endif

Modified: branches/OpenFDM-StateSeparation/src/test/foucault.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/foucault.cpp	2008-11-16 14:13:43 UTC (rev 731)
+++ branches/OpenFDM-StateSeparation/src/test/foucault.cpp	2008-11-16 14:26:40 UTC (rev 732)
@@ -1,8 +1,7 @@
 #include <OpenFDM/Group.h>
 #include <OpenFDM/Mass.h>
 #include <OpenFDM/FixedRootJoint.h>
-#include <OpenFDM/UniversalJoint.h>
-// #include <OpenFDM/RevoluteJoint.h>
+#include <OpenFDM/RotationalJoint.h>
 #include <OpenFDM/RigidBody.h>
 #include <OpenFDM/Sensor.h>
 #include <OpenFDM/System.h>
@@ -24,11 +23,8 @@
   FixedRootJoint* fixedRoot = new FixedRootJoint("Root");
   fixedRoot->setPosition(Vector3(0, 0, -10));
   Group::NodeId root = group->addChild(fixedRoot);
-  UniversalJoint* universalJoint = new UniversalJoint("Universal");
-  universalJoint->setAxis(Vector3(0, 0, 1));
-//   RevoluteJoint* universalJoint = new RevoluteJoint("Revolute");
-//   universalJoint->setAxis(Vector3(0, 1, 0));
-  Group::NodeId universal = group->addChild(universalJoint);
+  RotationalJoint* rotationalJoint = new RotationalJoint("Rotational");
+  Group::NodeId rotational = group->addChild(rotationalJoint);
 
   RigidBody* rigidBodyNode = new RigidBody("Rigid Body");
   rigidBodyNode->addLink("sensorLink");
@@ -46,8 +42,8 @@
   sensorModel->setEnableCentrifugalAcceleration(true);
   Group::NodeId sensor = group->addChild(sensorModel);
 
-  group->connect(root, 0, universal, 0);
-  group->connect(universal, 1, rigidBody, 0);
+  group->connect(root, 0, rotational, 0);
+  group->connect(rotational, 1, rigidBody, 0);
   group->connect(rigidBody, 1, mass, 0);
   group->connect(rigidBody, "sensorLink", sensor, "link");
 



From frohlich at mail.berlios.de  Sun Nov 16 19:22:41 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 16 Nov 2008 19:22:41 +0100
Subject: [OpenFDM-svn] r733 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811161822.mAGIMfo3002682@sheep.berlios.de>

Author: frohlich
Date: 2008-11-16 19:22:41 +0100 (Sun, 16 Nov 2008)
New Revision: 733

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Frame.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.cpp
Log:
Make the sensor's velocity values work.

M    Frame.h
M    Sensor.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Frame.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Frame.h	2008-11-16 14:26:40 UTC (rev 732)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Frame.h	2008-11-16 18:22:41 UTC (rev 733)
@@ -414,6 +414,11 @@
   Vector6 getRelVel(const Frame& frame) const
   { return motionFromRef(frame.motionToRef(frame.getRefVel())) - getRefVel(); }
 
+  // FIXME, docunment, and improove
+  Vector6 getRefVelAt(const Vector3& p) const
+  { return motionFrom(posToRef(p), getRefOrientation(), motionTo(p, getRefVel())); }
+
+
 private:
   // The offset of this frames origin wrt the parent frame measured in
   // the parent frames coordinates.

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.cpp	2008-11-16 14:26:40 UTC (rev 732)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.cpp	2008-11-16 18:22:41 UTC (rev 733)
@@ -42,9 +42,7 @@
   if (getEnableOrientation())
     portValues[mOrientationPort] = frame.getRefOrientation();
 
-  
-  Vector6 refVelocity = motionTo(refPosition, frame.getRefOrientation(),
-                                 Vector6::zeros());
+  Vector6 refVelocity = frame.getRefVelAt(position);
   if (getEnableAngularVelocity())
     portValues[mAngularVelocityPort] = refVelocity.getAngular();
 



From frohlich at mail.berlios.de  Sun Nov 16 19:36:41 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 16 Nov 2008 19:36:41 +0100
Subject: [OpenFDM-svn] r734 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200811161836.mAGIaf6u000605@sheep.berlios.de>

Author: frohlich
Date: 2008-11-16 19:36:41 +0100 (Sun, 16 Nov 2008)
New Revision: 734

Modified:
   branches/OpenFDM-StateSeparation/src/test/foucault.cpp
Log:
Place stuff more near the origin.

M    foucault.cpp


Modified: branches/OpenFDM-StateSeparation/src/test/foucault.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/foucault.cpp	2008-11-16 18:22:41 UTC (rev 733)
+++ branches/OpenFDM-StateSeparation/src/test/foucault.cpp	2008-11-16 18:36:41 UTC (rev 734)
@@ -21,7 +21,7 @@
   // FIXME, need usable environment stuff like gravity first ...
   SharedPtr<Group> group = new Group("Foucault");
   FixedRootJoint* fixedRoot = new FixedRootJoint("Root");
-  fixedRoot->setPosition(Vector3(0, 0, -10));
+  fixedRoot->setPosition(Vector3(0, 0, -1));
   Group::NodeId root = group->addChild(fixedRoot);
   RotationalJoint* rotationalJoint = new RotationalJoint("Rotational");
   Group::NodeId rotational = group->addChild(rotationalJoint);
@@ -37,6 +37,7 @@
   sensorModel->setPosition(massModel->getPosition());
   sensorModel->setEnablePosition(true);
   sensorModel->setEnableOrientation(true);
+  sensorModel->setEnableEulerAngles(true);
   sensorModel->setEnableLinearVelocity(true);
   sensorModel->setEnableAngularVelocity(true);
   sensorModel->setEnableCentrifugalAcceleration(true);



From frohlich at mail.berlios.de  Sun Nov 16 19:37:13 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 16 Nov 2008 19:37:13 +0100
Subject: [OpenFDM-svn] r735 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811161837.mAGIbDhc000858@sheep.berlios.de>

Author: frohlich
Date: 2008-11-16 19:37:13 +0100 (Sun, 16 Nov 2008)
New Revision: 735

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.h
Log:
Add Euler angles to the sensors.

M    Sensor.h
M    Sensor.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.cpp	2008-11-16 18:36:41 UTC (rev 734)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.cpp	2008-11-16 18:37:13 UTC (rev 735)
@@ -42,6 +42,9 @@
   if (getEnableOrientation())
     portValues[mOrientationPort] = frame.getRefOrientation();
 
+  if (getEnableEulerAngles())
+    portValues[mEulerAnglesPort] = frame.getRefOrientation().getEuler();
+
   Vector6 refVelocity = frame.getRefVelAt(position);
   if (getEnableAngularVelocity())
     portValues[mAngularVelocityPort] = refVelocity.getAngular();
@@ -119,6 +122,23 @@
 }
 
 void
+Sensor::setEnableEulerAngles(bool enable)
+{
+  if (enable == getEnableEulerAngles())
+    return;
+  if (enable)
+    mEulerAnglesPort = MatrixOutputPort(this, "eulerAngles", Size(3, 1));
+  else
+    mEulerAnglesPort.clear();
+}
+
+bool
+Sensor::getEnableEulerAngles() const
+{
+  return !mEulerAnglesPort.empty();
+}
+
+void
 Sensor::setEnableLinearVelocity(bool enable)
 {
   if (enable == getEnableLinearVelocity())

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.h	2008-11-16 18:36:41 UTC (rev 734)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.h	2008-11-16 18:37:13 UTC (rev 735)
@@ -38,6 +38,11 @@
   /// Get availabilty of the orientation output port
   bool getEnableOrientation() const;
 
+  /// Set availabilty of the euler angles output port
+  void setEnableEulerAngles(bool enable);
+  /// Get availabilty of the euler angles output port
+  bool getEnableEulerAngles() const;
+
   /// Set availabilty of the linear velocity output port
   void setEnableLinearVelocity(bool enable);
   /// Get availabilty of the linear velocity output port
@@ -60,6 +65,7 @@
 
   MatrixOutputPort mPositionPort;
   MatrixOutputPort mOrientationPort;
+  MatrixOutputPort mEulerAnglesPort;
 
   MatrixOutputPort mLinearVelocityPort;
   MatrixOutputPort mAngularVelocityPort;



From frohlich at mail.berlios.de  Sun Nov 16 20:38:38 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 16 Nov 2008 20:38:38 +0100
Subject: [OpenFDM-svn] r736 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811161938.mAGJccaX013927@sheep.berlios.de>

Author: frohlich
Date: 2008-11-16 20:38:38 +0100 (Sun, 16 Nov 2008)
New Revision: 736

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Mass.cpp
Log:
Hmm, need to take the vectors from the same frame.

M    Mass.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Mass.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Mass.cpp	2008-11-16 18:37:13 UTC (rev 735)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Mass.cpp	2008-11-16 19:38:38 UTC (rev 736)
@@ -38,11 +38,12 @@
 Mass::articulation(const Task&, const ContinousStateValueVector&,
                    PortValueList& portValues, Matrix&) const
 {
+  Vector3 position = mPosition - portValues[mMechanicLink].getDesignPosition();
+
   // FIXME: Hardcoding that gravity happens in the roots??
   Vector3 gravity = Vector3::zeros();
-  Vector6 force = Vector6(Vector3::zeros(), gravity);
 
-  Vector3 position = mPosition - portValues[mMechanicLink].getDesignPosition();
+  Vector6 force = forceFrom(position, Vector6(Vector3::zeros(), gravity));
   SpatialInertia I = inertiaFrom(position, SpatialInertia(mInertia, mMass));
 
   // FIXME: do we really need that in the mass
@@ -55,7 +56,7 @@
 
 
   portValues[mMechanicLink].applyInertia(I);
-  portValues[mMechanicLink].applyForce(forceFrom(position, force));
+  portValues[mMechanicLink].applyForce(force);
 }
 
 const InertiaMatrix&



From frohlich at mail.berlios.de  Mon Nov 17 07:24:42 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Mon, 17 Nov 2008 07:24:42 +0100
Subject: [OpenFDM-svn] r737 - in branches/OpenFDM-StateSeparation/src:
	OpenFDM test
Message-ID: <200811170624.mAH6Og8h004690@sheep.berlios.de>

Author: frohlich
Date: 2008-11-17 07:24:40 +0100 (Mon, 17 Nov 2008)
New Revision: 737

Added:
   branches/OpenFDM-StateSeparation/src/OpenFDM/GroupInput.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/GroupInput.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/GroupInterfaceNode.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/GroupInterfaceNode.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/GroupMechanicLink.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/GroupMechanicLink.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/GroupOutput.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/GroupOutput.h
Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/ConstNodeVisitor.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Group.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
   branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Move group special nodes into their own files.

M    src/test/structure.cpp
M    src/OpenFDM/Group.h
A    src/OpenFDM/GroupMechanicLink.cpp
A    src/OpenFDM/GroupMechanicLink.h
M    src/OpenFDM/Makefile.am
A    src/OpenFDM/GroupInput.h
A    src/OpenFDM/GroupOutput.h
A    src/OpenFDM/GroupInput.cpp
A    src/OpenFDM/GroupOutput.cpp
A    src/OpenFDM/GroupInterfaceNode.h
M    src/OpenFDM/NodeVisitor.cpp
A    src/OpenFDM/GroupInterfaceNode.cpp
M    src/OpenFDM/System.cpp
M    src/OpenFDM/ConstNodeVisitor.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/ConstNodeVisitor.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ConstNodeVisitor.cpp	2008-11-16 19:38:38 UTC (rev 736)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ConstNodeVisitor.cpp	2008-11-17 06:24:40 UTC (rev 737)
@@ -5,6 +5,7 @@
 #include "ConstNodeVisitor.h"
 
 #include "Group.h"
+#include "GroupInterfaceNode.h"
 #include "Interact.h"
 #include "LibraryNode.h"
 #include "LeafNode.h"

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Group.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Group.h	2008-11-16 19:38:38 UTC (rev 736)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Group.h	2008-11-17 06:24:40 UTC (rev 737)
@@ -8,109 +8,13 @@
 #include <string>
 #include <vector>
 #include <sstream>
-#include "ConstNodeVisitor.h"
 #include "Node.h"
-#include "NodeVisitor.h"
-#include "Object.h"
 #include "PortId.h"
 #include "PortInfo.h"
 #include "SharedPtr.h"
 
 namespace OpenFDM {
 
-class GroupInterfaceNode : public Node {
-public:
-  GroupInterfaceNode(const std::string& name) : Node(name) {}
-  virtual void accept(NodeVisitor& visitor)
-  {
-    visitor.handleNodePathAndApply(this);
-  }
-  virtual void accept(ConstNodeVisitor& visitor) const
-  {
-    visitor.handleNodePathAndApply(this);
-  }
-
-  unsigned getExternalPortIndex() const
-  { return mExternalPortInfo->getIndex(); }
-protected:
-  virtual bool addParent(Node* parent)
-  {
-    if (getNumParents()) {
-      Log(Model,Warning) << "Group Interface Nodes cannot have more than "
-        "one parent!" << std::endl;
-      return false;
-    }
-    
-    return Node::addParent(parent);
-  }
-  virtual void removeParent(Node* parent)
-  {
-    Node::removeParent(parent);
-  }
-
-  void setExternalPortInfo(PortInfo* portInfo)
-  {
-    mExternalPortInfo = portInfo;
-  }
-
-private:
-  SharedPtr<PortInfo> mExternalPortInfo;
-};
-
-class GroupInput : public GroupInterfaceNode {
-public:
-  GroupInput(const std::string& name) :
-    GroupInterfaceNode(name),
-    mGroupInternalPort(new OutputPortInfo(this, "output", Size(0, 0), false))
-  { }
-protected:
-  virtual bool addParent(Node* parent)
-  {
-    if (!GroupInterfaceNode::addParent(parent))
-      return false;
-    setExternalPortInfo(new InputPortInfo(parent, "input", Size(0, 0), false));
-    return true;
-  }
-private:
-  SharedPtr<OutputPortInfo> mGroupInternalPort;
-};
-
-class GroupOutput : public GroupInterfaceNode {
-public:
-  GroupOutput(const std::string& name) :
-    GroupInterfaceNode(name),
-    mGroupInternalPort(new InputPortInfo(this, "input", Size(0, 0), false))
-  { }
-protected:
-  virtual bool addParent(Node* parent)
-  {
-    if (!GroupInterfaceNode::addParent(parent))
-      return false;
-    setExternalPortInfo(new OutputPortInfo(parent, "output", Size(0, 0), false));
-    return true;
-  }
-private:
-  SharedPtr<InputPortInfo> mGroupInternalPort;
-};
-
-class GroupMechanicLink : public GroupInterfaceNode {
-public:
-  GroupMechanicLink(const std::string& name) :
-    GroupInterfaceNode(name),
-    mGroupInternalPort(new MechanicLinkInfo(this, "link"))
-  { }
-protected:
-  virtual bool addParent(Node* parent)
-  {
-    if (!GroupInterfaceNode::addParent(parent))
-      return false;
-    setExternalPortInfo(new MechanicLinkInfo(parent, "link"));
-    return true;
-  }
-private:
-  SharedPtr<MechanicLinkInfo> mGroupInternalPort;
-};
-
 class Group : public Node {
   OPENFDM_OBJECT(Group, Node);
 public:

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/GroupInput.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/GroupInput.cpp	2008-11-16 19:38:38 UTC (rev 736)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/GroupInput.cpp	2008-11-17 06:24:40 UTC (rev 737)
@@ -0,0 +1,31 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
+ *
+ */
+
+#include "GroupInput.h"
+
+namespace OpenFDM {
+
+BEGIN_OPENFDM_OBJECT_DEF(GroupInput, GroupInterfaceNode)
+  END_OPENFDM_OBJECT_DEF
+
+GroupInput::GroupInput(const std::string& name) :
+  GroupInterfaceNode(name),
+  mGroupInternalPort(new OutputPortInfo(this, "output", Size(0, 0), false))
+{
+}
+
+GroupInput::~GroupInput()
+{
+}
+
+bool
+GroupInput::addParent(Node* parent)
+{
+  if (!GroupInterfaceNode::addParent(parent))
+    return false;
+  setExternalPortInfo(new InputPortInfo(parent, "input", Size(0, 0), false));
+  return true;
+}
+
+} // namespace OpenFDM

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/GroupInput.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/GroupInput.h	2008-11-16 19:38:38 UTC (rev 736)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/GroupInput.h	2008-11-17 06:24:40 UTC (rev 737)
@@ -0,0 +1,30 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_GroupInput_H
+#define OpenFDM_GroupInput_H
+
+#include <string>
+#include "GroupInterfaceNode.h"
+#include "PortInfo.h"
+#include "SharedPtr.h"
+
+namespace OpenFDM {
+
+class GroupInput : public GroupInterfaceNode {
+  OPENFDM_OBJECT(GroupInput, GroupInterfaceNode);
+public:
+  GroupInput(const std::string& name);
+  virtual ~GroupInput();
+
+protected:
+  virtual bool addParent(Node* parent);
+
+private:
+  SharedPtr<OutputPortInfo> mGroupInternalPort;
+};
+
+} // namespace OpenFDM
+
+#endif

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/GroupInterfaceNode.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/GroupInterfaceNode.cpp	2008-11-16 19:38:38 UTC (rev 736)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/GroupInterfaceNode.cpp	2008-11-17 06:24:40 UTC (rev 737)
@@ -0,0 +1,66 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
+ *
+ */
+
+#include "GroupInterfaceNode.h"
+
+#include "ConstNodeVisitor.h"
+#include "NodeVisitor.h"
+
+namespace OpenFDM {
+
+BEGIN_OPENFDM_OBJECT_DEF(GroupInterfaceNode, Node)
+  END_OPENFDM_OBJECT_DEF
+
+GroupInterfaceNode::GroupInterfaceNode(const std::string& name) :
+  Node(name)
+{
+}
+
+GroupInterfaceNode::~GroupInterfaceNode()
+{
+}
+
+void
+GroupInterfaceNode::accept(NodeVisitor& visitor)
+{
+  visitor.handleNodePathAndApply(this);
+}
+
+void
+GroupInterfaceNode::accept(ConstNodeVisitor& visitor) const
+{
+  visitor.handleNodePathAndApply(this);
+}
+
+unsigned
+GroupInterfaceNode::getExternalPortIndex() const
+{
+  return mExternalPortInfo->getIndex();
+}
+
+bool
+GroupInterfaceNode::addParent(Node* parent)
+{
+  if (getNumParents()) {
+    Log(Model,Warning) << "Group Interface Nodes cannot have more than "
+      "one parent!" << std::endl;
+    return false;
+  }
+  
+  return Node::addParent(parent);
+}
+
+void
+GroupInterfaceNode::removeParent(Node* parent)
+{
+  Node::removeParent(parent);
+}
+
+void
+GroupInterfaceNode::setExternalPortInfo(PortInfo* portInfo)
+{
+  mExternalPortInfo = portInfo;
+}
+
+} // namespace OpenFDM

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/GroupInterfaceNode.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/GroupInterfaceNode.h	2008-11-16 19:38:38 UTC (rev 736)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/GroupInterfaceNode.h	2008-11-17 06:24:40 UTC (rev 737)
@@ -0,0 +1,44 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_GroupInterfaceNode_H
+#define OpenFDM_GroupInterfaceNode_H
+
+#include <string>
+#include <vector>
+#include <sstream>
+#include "ConstNodeVisitor.h"
+#include "Node.h"
+#include "NodeVisitor.h"
+#include "Object.h"
+#include "PortId.h"
+#include "PortInfo.h"
+#include "SharedPtr.h"
+
+namespace OpenFDM {
+
+class GroupInterfaceNode : public Node {
+  OPENFDM_OBJECT(GroupInterfaceNode, Node);
+public:
+  GroupInterfaceNode(const std::string& name);
+  virtual ~GroupInterfaceNode();
+
+  virtual void accept(NodeVisitor& visitor);
+  virtual void accept(ConstNodeVisitor& visitor) const;
+
+  unsigned getExternalPortIndex() const;
+
+protected:
+  virtual bool addParent(Node* parent);
+  virtual void removeParent(Node* parent);
+
+  void setExternalPortInfo(PortInfo* portInfo);
+
+private:
+  SharedPtr<PortInfo> mExternalPortInfo;
+};
+
+} // namespace OpenFDM
+
+#endif

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/GroupMechanicLink.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/GroupMechanicLink.cpp	2008-11-16 19:38:38 UTC (rev 736)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/GroupMechanicLink.cpp	2008-11-17 06:24:40 UTC (rev 737)
@@ -0,0 +1,31 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
+ *
+ */
+
+#include "GroupMechanicLink.h"
+
+namespace OpenFDM {
+
+BEGIN_OPENFDM_OBJECT_DEF(GroupMechanicLink, GroupInterfaceNode)
+  END_OPENFDM_OBJECT_DEF
+
+GroupMechanicLink::GroupMechanicLink(const std::string& name) :
+  GroupInterfaceNode(name),
+  mGroupInternalPort(new MechanicLinkInfo(this, "link"))
+{
+}
+
+GroupMechanicLink::~GroupMechanicLink()
+{
+}
+
+bool
+GroupMechanicLink::addParent(Node* parent)
+{
+  if (!GroupInterfaceNode::addParent(parent))
+    return false;
+  setExternalPortInfo(new MechanicLinkInfo(parent, "link"));
+  return true;
+}
+
+} // namespace OpenFDM

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/GroupMechanicLink.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/GroupMechanicLink.h	2008-11-16 19:38:38 UTC (rev 736)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/GroupMechanicLink.h	2008-11-17 06:24:40 UTC (rev 737)
@@ -0,0 +1,30 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_GroupMechanicLink_H
+#define OpenFDM_GroupMechanicLink_H
+
+#include <string>
+#include "GroupInterfaceNode.h"
+#include "PortInfo.h"
+#include "SharedPtr.h"
+
+namespace OpenFDM {
+
+class GroupMechanicLink : public GroupInterfaceNode {
+  OPENFDM_OBJECT(GroupMechanicLink, GroupInterfaceNode);
+public:
+  GroupMechanicLink(const std::string& name);
+  virtual ~GroupMechanicLink();
+
+protected:
+  virtual bool addParent(Node* parent);
+
+private:
+  SharedPtr<MechanicLinkInfo> mGroupInternalPort;
+};
+
+} // namespace OpenFDM
+
+#endif

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/GroupOutput.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/GroupOutput.cpp	2008-11-16 19:38:38 UTC (rev 736)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/GroupOutput.cpp	2008-11-17 06:24:40 UTC (rev 737)
@@ -0,0 +1,31 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
+ *
+ */
+
+#include "GroupOutput.h"
+
+namespace OpenFDM {
+
+BEGIN_OPENFDM_OBJECT_DEF(GroupOutput, GroupInterfaceNode)
+  END_OPENFDM_OBJECT_DEF
+
+GroupOutput::GroupOutput(const std::string& name) :
+  GroupInterfaceNode(name),
+  mGroupInternalPort(new InputPortInfo(this, "input", Size(0, 0), false))
+{
+}
+
+GroupOutput::~GroupOutput()
+{
+}
+
+bool
+GroupOutput::addParent(Node* parent)
+{
+  if (!GroupInterfaceNode::addParent(parent))
+    return false;
+  setExternalPortInfo(new OutputPortInfo(parent, "output", Size(0, 0), false));
+  return true;
+}
+
+} // namespace OpenFDM

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/GroupOutput.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/GroupOutput.h	2008-11-16 19:38:38 UTC (rev 736)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/GroupOutput.h	2008-11-17 06:24:40 UTC (rev 737)
@@ -0,0 +1,30 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_GroupOutput_H
+#define OpenFDM_GroupOutput_H
+
+#include <string>
+#include "GroupInterfaceNode.h"
+#include "PortInfo.h"
+#include "SharedPtr.h"
+
+namespace OpenFDM {
+
+class GroupOutput : public GroupInterfaceNode {
+  OPENFDM_OBJECT(GroupOutput, GroupInterfaceNode);
+public:
+  GroupOutput(const std::string& name);
+  virtual ~GroupOutput();
+
+protected:
+  virtual bool addParent(Node* parent);
+
+private:
+  SharedPtr<InputPortInfo> mGroupInternalPort;
+};
+
+} // namespace OpenFDM
+
+#endif

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-11-16 19:38:38 UTC (rev 736)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-11-17 06:24:40 UTC (rev 737)
@@ -34,6 +34,10 @@
   Frame.h \
   Function.h \
   Group.h \
+  GroupInterfaceNode.h \
+  GroupInput.h \
+  GroupMechanicLink.h \
+  GroupOutput.h \
   HDF5SystemOutput.h \
   ImplicitEuler.h \
   Inertia.h \
@@ -132,6 +136,10 @@
   Frame.cpp \
   Function.cpp \
   Group.cpp \
+  GroupInterfaceNode.cpp \
+  GroupInput.cpp \
+  GroupMechanicLink.cpp \
+  GroupOutput.cpp \
   Interact.cpp \
   LeafNode.cpp \
   LibraryModel.cpp \

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.cpp	2008-11-16 19:38:38 UTC (rev 736)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.cpp	2008-11-17 06:24:40 UTC (rev 737)
@@ -5,6 +5,7 @@
 #include "NodeVisitor.h"
 
 #include "Group.h"
+#include "GroupInterfaceNode.h"
 #include "Input.h"
 #include "Interact.h"
 #include "Joint.h"

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-16 19:38:38 UTC (rev 736)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-17 06:24:40 UTC (rev 737)
@@ -7,6 +7,7 @@
 #include "AbstractSystem.h"
 #include "ConstNodeVisitor.h"
 #include "Group.h"
+#include "GroupInterfaceNode.h"
 #include "Interact.h"
 #include "Joint.h"
 #include "NodeInstance.h"

Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-11-16 19:38:38 UTC (rev 736)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-11-17 06:24:40 UTC (rev 737)
@@ -4,6 +4,8 @@
 #include <OpenFDM/Delay.h>
 #include <OpenFDM/Output.h>
 #include <OpenFDM/Group.h>
+#include <OpenFDM/GroupInput.h>
+#include <OpenFDM/GroupOutput.h>
 #include <OpenFDM/LibraryNode.h>
 #include <OpenFDM/LibraryModel.h>
 #include <OpenFDM/System.h>



From frohlich at mail.berlios.de  Mon Nov 17 07:29:34 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Mon, 17 Nov 2008 07:29:34 +0100
Subject: [OpenFDM-svn] r738 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811170629.mAH6TYBK017314@sheep.berlios.de>

Author: frohlich
Date: 2008-11-17 07:29:33 +0100 (Mon, 17 Nov 2008)
New Revision: 738

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.h
Log:
Add reflection macros to the sensor.

M    src/OpenFDM/Sensor.cpp
M    src/OpenFDM/Sensor.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.cpp	2008-11-17 06:24:40 UTC (rev 737)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.cpp	2008-11-17 06:29:33 UTC (rev 738)
@@ -10,6 +10,16 @@
 
 namespace OpenFDM {
 
+BEGIN_OPENFDM_OBJECT_DEF(Sensor, Interact)
+  DEF_OPENFDM_PROPERTY(Vector3, Position, Serialized)
+  DEF_OPENFDM_PROPERTY(Bool, EnablePosition, Serialized)
+  DEF_OPENFDM_PROPERTY(Bool, EnableOrientation, Serialized)
+  DEF_OPENFDM_PROPERTY(Bool, EnableEulerAngles, Serialized)
+  DEF_OPENFDM_PROPERTY(Bool, EnableLinearVelocity, Serialized)
+  DEF_OPENFDM_PROPERTY(Bool, EnableAngularVelocity, Serialized)
+  DEF_OPENFDM_PROPERTY(Bool, EnableCentrifugalAcceleration, Serialized)
+  END_OPENFDM_OBJECT_DEF
+
 Sensor::Sensor(const std::string& name) :
   Interact(name),
   mMechanicLink(newMechanicLink("link")),

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.h	2008-11-17 06:24:40 UTC (rev 737)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.h	2008-11-17 06:29:33 UTC (rev 738)
@@ -13,6 +13,7 @@
 namespace OpenFDM {
 
 class Sensor : public Interact {
+  OPENFDM_OBJECT(Sensor, Interact);
 public:
   Sensor(const std::string& name);
   virtual ~Sensor(void);



From frohlich at mail.berlios.de  Mon Nov 17 19:42:28 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Mon, 17 Nov 2008 19:42:28 +0100
Subject: [OpenFDM-svn] r739 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811171842.mAHIgS4A022580@sheep.berlios.de>

Author: frohlich
Date: 2008-11-17 19:42:28 +0100 (Mon, 17 Nov 2008)
New Revision: 739

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Task.h
Log:
Initialize uninitialized variable.

M    Task.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Task.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Task.h	2008-11-17 06:29:33 UTC (rev 738)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Task.h	2008-11-17 18:42:28 UTC (rev 739)
@@ -13,6 +13,7 @@
 
 class Task : public Referenced {
 public:
+  Task() : mTime(0) {}
   virtual ~Task() {}
 
   const real_type& getTime() const



From frohlich at mail.berlios.de  Mon Nov 17 19:42:58 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Mon, 17 Nov 2008 19:42:58 +0100
Subject: [OpenFDM-svn] r740 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811171842.mAHIgwsp022657@sheep.berlios.de>

Author: frohlich
Date: 2008-11-17 19:42:58 +0100 (Mon, 17 Nov 2008)
New Revision: 740

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/RotationalJoint.cpp
Log:
Avoid multiplication with a identity matrix.

M    RotationalJoint.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RotationalJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RotationalJoint.cpp	2008-11-17 18:42:28 UTC (rev 739)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RotationalJoint.cpp	2008-11-17 18:42:58 UTC (rev 740)
@@ -152,8 +152,7 @@
   // Correction term to keep the quaternion normalized.
   // That is if |q| < 1 add a little radial component outward,
   // if |q| > 1 add a little radial component inward
-  Vector3 angVel = getJointMatrix()(Range(0, 2), Range(0, 2))
-    *states[*mVelocityStateInfo];
+  Vector3 angVel = states[*mVelocityStateInfo];
   Vector4 qderiv = LinAlg::derivative(q, angVel) + 1e1*(normalize(q) - q);
 
   derivative[*mPositionStateInfo] = qderiv;



From frohlich at mail.berlios.de  Mon Nov 17 20:19:25 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Mon, 17 Nov 2008 20:19:25 +0100
Subject: [OpenFDM-svn] r741 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811171919.mAHJJPx3026117@sheep.berlios.de>

Author: frohlich
Date: 2008-11-17 20:19:24 +0100 (Mon, 17 Nov 2008)
New Revision: 741

Added:
   branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractModel.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractModel.h
Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/ConstNodeVisitor.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/ConstNodeVisitor.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
   branches/OpenFDM-StateSeparation/src/OpenFDM/Model.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Model.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
Log:
Introduce an AbstractModel class providing only the Context factory.

M    src/OpenFDM/Model.h
M    src/OpenFDM/Makefile.am
A    src/OpenFDM/AbstractModel.h
M    src/OpenFDM/NodeVisitor.h
A    src/OpenFDM/AbstractModel.cpp
M    src/OpenFDM/ConstNodeVisitor.h
M    src/OpenFDM/NodeVisitor.cpp
M    src/OpenFDM/System.cpp
M    src/OpenFDM/Model.cpp
M    src/OpenFDM/ConstNodeVisitor.cpp


Added: branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractModel.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractModel.cpp	2008-11-17 18:42:58 UTC (rev 740)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractModel.cpp	2008-11-17 19:19:24 UTC (rev 741)
@@ -0,0 +1,36 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
+ *
+ */
+
+#include "AbstractModel.h"
+
+#include "ConstNodeVisitor.h"
+#include "NodeVisitor.h"
+
+namespace OpenFDM {
+
+BEGIN_OPENFDM_OBJECT_DEF(AbstractModel, LeafNode)
+  END_OPENFDM_OBJECT_DEF
+
+AbstractModel::AbstractModel(const std::string& name) :
+  LeafNode(name)
+{
+}
+
+AbstractModel::~AbstractModel()
+{
+}
+
+void
+AbstractModel::accept(NodeVisitor& visitor)
+{
+  visitor.handleNodePathAndApply(this);
+}
+
+void
+AbstractModel::accept(ConstNodeVisitor& visitor) const
+{
+  visitor.handleNodePathAndApply(this);
+}
+
+} // namespace OpenFDM

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractModel.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractModel.h	2008-11-17 18:42:58 UTC (rev 740)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractModel.h	2008-11-17 19:19:24 UTC (rev 741)
@@ -0,0 +1,32 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_AbstractModel_H
+#define OpenFDM_AbstractModel_H
+
+#include <string>
+
+#include "OpenFDMConfig.h"
+#include "LeafNode.h"
+
+namespace OpenFDM {
+
+class ModelContext;
+class PortValueList;
+
+class AbstractModel : public LeafNode {
+  OPENFDM_OBJECT(AbstractModel, LeafNode);
+public:
+  AbstractModel(const std::string& name);
+  virtual ~AbstractModel();
+
+  virtual void accept(NodeVisitor& visitor);
+  virtual void accept(ConstNodeVisitor& visitor) const;
+
+  virtual ModelContext* newModelContext(PortValueList&) const = 0;
+};
+
+} // namespace OpenFDM
+
+#endif

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/ConstNodeVisitor.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ConstNodeVisitor.cpp	2008-11-17 18:42:58 UTC (rev 740)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ConstNodeVisitor.cpp	2008-11-17 19:19:24 UTC (rev 741)
@@ -10,7 +10,7 @@
 #include "LibraryNode.h"
 #include "LeafNode.h"
 #include "MechanicNode.h"
-#include "Model.h"
+#include "AbstractModel.h"
 #include "Input.h"
 #include "Joint.h"
 #include "Output.h"
@@ -56,7 +56,7 @@
 }
 
 void
-ConstNodeVisitor::apply(const Model& node)
+ConstNodeVisitor::apply(const AbstractModel& node)
 {
   apply(static_cast<const LeafNode&>(node));
 }
@@ -64,13 +64,13 @@
 void
 ConstNodeVisitor::apply(const Input& node)
 {
-  apply(static_cast<const Model&>(node));
+  apply(static_cast<const AbstractModel&>(node));
 }
 
 void
 ConstNodeVisitor::apply(const Output& node)
 {
-  apply(static_cast<const Model&>(node));
+  apply(static_cast<const AbstractModel&>(node));
 }
 
 void

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/ConstNodeVisitor.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ConstNodeVisitor.h	2008-11-17 18:42:58 UTC (rev 740)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ConstNodeVisitor.h	2008-11-17 19:19:24 UTC (rev 741)
@@ -15,7 +15,7 @@
 class GroupInterfaceNode;
 class LibraryNode;
 class LeafNode;
-class Model;
+class AbstractModel;
 class Input;
 class Joint;
 class Output;
@@ -40,7 +40,7 @@
   virtual void apply(const LibraryNode&);
 
   virtual void apply(const LeafNode&);
-  virtual void apply(const Model&);
+  virtual void apply(const AbstractModel&);
   virtual void apply(const Input&);
   virtual void apply(const Output&);
 

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-11-17 18:42:58 UTC (rev 740)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-11-17 19:19:24 UTC (rev 741)
@@ -12,6 +12,7 @@
 endif
 
 OpenFDMCoreHEADERS = \
+  AbstractModel.h \
   AbstractNodeContext.h \
   AbstractNodeInstance.h \
   AbstractSystem.h \
@@ -124,6 +125,7 @@
   XMLDumpModelVisitor.h
 
 OpenFDMCoreSOURCES = \
+  AbstractModel.cpp \
   AbstractNodeContext.cpp \
   AbstractNodeInstance.cpp \
   Assert.cpp \

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Model.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Model.cpp	2008-11-17 18:42:58 UTC (rev 740)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Model.cpp	2008-11-17 19:19:24 UTC (rev 741)
@@ -57,11 +57,11 @@
   SharedPtr<const Model> mModel;
 };
 
-BEGIN_OPENFDM_OBJECT_DEF(Model, LeafNode)
+BEGIN_OPENFDM_OBJECT_DEF(Model, AbstractModel)
   END_OPENFDM_OBJECT_DEF
 
 Model::Model(const std::string& name) :
-  LeafNode(name)
+  AbstractModel(name)
 {
 }
 
@@ -69,18 +69,6 @@
 {
 }
 
-void
-Model::accept(NodeVisitor& visitor)
-{
-  visitor.handleNodePathAndApply(this);
-}
-
-void
-Model::accept(ConstNodeVisitor& visitor) const
-{
-  visitor.handleNodePathAndApply(this);
-}
-
 ModelContext*
 Model::newModelContext(PortValueList& portValueList) const
 {

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Model.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Model.h	2008-11-17 18:42:58 UTC (rev 740)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Model.h	2008-11-17 19:19:24 UTC (rev 741)
@@ -9,7 +9,7 @@
 
 #include "OpenFDMConfig.h"
 #include "Assert.h"
-#include "LeafNode.h"
+#include "AbstractModel.h"
 #include "MatrixInputPort.h"
 #include "MatrixOutputPort.h"
 #include "RealInputPort.h"
@@ -26,15 +26,12 @@
 class Task;
 class ModelContext;
 
-class Model : public LeafNode {
-  OPENFDM_OBJECT(Model, LeafNode);
+class Model : public AbstractModel {
+  OPENFDM_OBJECT(Model, AbstractModel);
 public:
   Model(const std::string& name);
   virtual ~Model();
 
-  virtual void accept(NodeVisitor& visitor);
-  virtual void accept(ConstNodeVisitor& visitor) const;
-
   virtual ModelContext* newModelContext(PortValueList& portValueList) const;
 
   // FIXME: May be we want to collapse all state values in one

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.cpp	2008-11-17 18:42:58 UTC (rev 740)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.cpp	2008-11-17 19:19:24 UTC (rev 741)
@@ -12,7 +12,7 @@
 #include "LibraryNode.h"
 #include "LeafNode.h"
 #include "MechanicNode.h"
-#include "Model.h"
+#include "AbstractModel.h"
 #include "Output.h"
 #include "RigidBody.h"
 #include "RootJoint.h"
@@ -56,7 +56,7 @@
 }
 
 void
-NodeVisitor::apply(Model& node)
+NodeVisitor::apply(AbstractModel& node)
 {
   apply(static_cast<LeafNode&>(node));
 }
@@ -64,13 +64,13 @@
 void
 NodeVisitor::apply(Input& node)
 {
-  apply(static_cast<Model&>(node));
+  apply(static_cast<AbstractModel&>(node));
 }
 
 void
 NodeVisitor::apply(Output& node)
 {
-  apply(static_cast<Model&>(node));
+  apply(static_cast<AbstractModel&>(node));
 }
 
 void

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.h	2008-11-17 18:42:58 UTC (rev 740)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.h	2008-11-17 19:19:24 UTC (rev 741)
@@ -15,7 +15,7 @@
 class GroupInterfaceNode;
 class LibraryNode;
 class LeafNode;
-class Model;
+class AbstractModel;
 class Input;
 class Joint;
 class Output;
@@ -40,7 +40,7 @@
   virtual void apply(LibraryNode&);
 
   virtual void apply(LeafNode&);
-  virtual void apply(Model&);
+  virtual void apply(AbstractModel&);
   virtual void apply(Input&);
   virtual void apply(Output&);
 

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-17 18:42:58 UTC (rev 740)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-17 19:19:24 UTC (rev 741)
@@ -515,12 +515,12 @@
     SharedPtr<const Node> mNode;
   };
   struct ModelInstanceData : public InstanceData {
-    ModelInstanceData(const Model& model, const NodePath& nodePath,
+    ModelInstanceData(const AbstractModel& model, const NodePath& nodePath,
                       const SampleTime& sampleTime) :
       InstanceData(model, nodePath, sampleTime),
       mModel(&model)
     { }
-    virtual const Model* getNode() const { return mModel; }
+    virtual const AbstractModel* getNode() const { return mModel; }
 
     bool createModelContext()
     {
@@ -543,7 +543,7 @@
     { return mModelContext; }
 
   private:
-    SharedPtr<const Model> mModel;
+    SharedPtr<const AbstractModel> mModel;
     SharedPtr<ModelContext> mModelContext;
   };
   struct MechanicInstanceData : public InstanceData {
@@ -763,7 +763,7 @@
     addInstanceData(instanceData);
     mJointInstanceDataList.push_back(instanceData);
   }
-  virtual void apply(const Model& node)
+  virtual void apply(const AbstractModel& node)
   {
     SharedPtr<ModelInstanceData> instanceData;
     instanceData = new ModelInstanceData(node, getNodePath(), mSampleTime);



From frohlich at mail.berlios.de  Mon Nov 17 20:24:20 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Mon, 17 Nov 2008 20:24:20 +0100
Subject: [OpenFDM-svn] r742 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811171924.mAHJOKFl028228@sheep.berlios.de>

Author: frohlich
Date: 2008-11-17 20:24:20 +0100 (Mon, 17 Nov 2008)
New Revision: 742

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/ModelContext.h
Log:
Also reference AbstractModel from the Context.

M    ModelContext.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/ModelContext.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ModelContext.h	2008-11-17 19:19:24 UTC (rev 741)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ModelContext.h	2008-11-17 19:24:20 UTC (rev 742)
@@ -8,7 +8,7 @@
 #include <list>
 #include "SharedPtr.h"
 #include "LeafContext.h"
-#include "Model.h"
+#include "AbstractModel.h"
 
 namespace OpenFDM {
 
@@ -23,7 +23,7 @@
   ModelContext() {}
   virtual ~ModelContext();
 
-  virtual const Model& getNode() const = 0;
+  virtual const AbstractModel& getNode() const = 0;
 
   virtual void initOutput(const /*Init*/Task& task) = 0;
   virtual void output(const Task& task) = 0;



From frohlich at mail.berlios.de  Mon Nov 17 22:22:24 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Mon, 17 Nov 2008 22:22:24 +0100
Subject: [OpenFDM-svn] r743 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811172122.mAHLMOaA001390@sheep.berlios.de>

Author: frohlich
Date: 2008-11-17 22:22:22 +0100 (Mon, 17 Nov 2008)
New Revision: 743

Added:
   branches/OpenFDM-StateSeparation/src/OpenFDM/UnaryModel.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/UnaryModel.h
Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Bias.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Bias.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/DeadBand.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/DeadBand.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Gain.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Gain.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
   branches/OpenFDM-StateSeparation/src/OpenFDM/PortValueList.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Saturation.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Saturation.h
Log:
Reactivate some direct feedthrough models.

M    src/OpenFDM/Saturation.h
M    src/OpenFDM/Gain.cpp
M    src/OpenFDM/DeadBand.cpp
M    src/OpenFDM/Makefile.am
M    src/OpenFDM/DeadBand.h
M    src/OpenFDM/Bias.h
A    src/OpenFDM/UnaryModel.cpp
M    src/OpenFDM/PortValueList.h
M    src/OpenFDM/Bias.cpp
M    src/OpenFDM/Gain.h
M    src/OpenFDM/Saturation.cpp
A    src/OpenFDM/UnaryModel.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Bias.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Bias.cpp	2008-11-17 19:24:20 UTC (rev 742)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Bias.cpp	2008-11-17 21:22:22 UTC (rev 743)
@@ -14,55 +14,39 @@
 
 namespace OpenFDM {
 
-BEGIN_OPENFDM_OBJECT_DEF(Bias, Model)
+BEGIN_OPENFDM_OBJECT_DEF(Bias, UnaryModel)
   DEF_OPENFDM_PROPERTY(Matrix, Bias, Serialized)
   END_OPENFDM_OBJECT_DEF
 
-Bias::Bias(const std::string& name) : Model(name)
+Bias::Bias(const std::string& name) :
+  UnaryModel(name),
+  mBias(Matrix::zeros(1, 1))
 {
-  setDirectFeedThrough(true);
-  
-  setNumInputPorts(1);
-  setInputPortName(0, "input");
-  
-  addOutputPort("output", this, &Bias::getOutput);
 }
 
 Bias::~Bias(void)
 {
 }
   
-bool
-Bias::init(void)
+ModelContext*
+Bias::newModelContext(PortValueList& portValueList) const
 {
-  // Invalidate outputs
-  mOutput.resize(0, 0);
+  return UnaryModel::newModelContext(this, portValueList);
+}
 
-  mInputPort = getInputPort(0)->toMatrixPortHandle();
-  if (!mInputPort.isConnected()) {
-    Log(Model, Error) << "Initialization of Bias model \"" << getName()
-                      << "\" failed: Input port \"" << getInputPortName(0)
-                      << "\" is not connected!" << endl;
+bool
+Bias::alloc(LeafContext& context) const
+{
+  // FIXME: check that the mBias matches the size of the ports.
+  if (!UnaryModel::alloc(context))
     return false;
-  }
-
-  // Size compatibility check
-  if (size(mInputPort.getMatrixValue()) != size(mBias)) {
-    Log(Model, Error) << "Input port of \"" << getName() << "\", does not "
-                      << "match the size of the bias property" << endl;
-    return false;
-  }
-  mOutput.resize(mInputPort.getMatrixValue());
-
-  return Model::init();
+  return true;
 }
 
 void
-Bias::output(const TaskInfo&)
+Bias::output(const Matrix& inputValue, Matrix& outputValue) const
 {
-  OpenFDMAssert(mInputPort.isConnected());
-  mOutput = mInputPort.getMatrixValue();
-  mOutput += mBias;
+  outputValue = mBias + inputValue;
 }
 
 const Matrix&
@@ -77,10 +61,4 @@
   mBias = bias;
 }
 
-const Matrix&
-Bias::getOutput(void) const
-{
-  return mOutput;
-}
-
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Bias.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Bias.h	2008-11-17 19:24:20 UTC (rev 742)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Bias.h	2008-11-17 21:22:22 UTC (rev 743)
@@ -6,33 +6,27 @@
 #define OpenFDM_Bias_H
 
 #include <string>
-#include <vector>
 
-#include "Assert.h"
-#include "Object.h"
-#include "Vector.h"
-#include "Model.h"
+#include "UnaryModel.h"
 
 namespace OpenFDM {
 
-class Bias : public Model {
-  OPENFDM_OBJECT(Bias, Model);
+class Bias : public UnaryModel {
+  OPENFDM_OBJECT(Bias, UnaryModel);
 public:
   Bias(const std::string& name);
   virtual ~Bias(void);
-  
-  virtual bool init(void);
-  virtual void output(const TaskInfo&);
 
+  ModelContext* newModelContext(PortValueList&) const;
+
+  bool alloc(LeafContext& context) const;
+  void output(const Matrix& inputValue, Matrix& outputValue) const;
+
   const Matrix& getBias(void) const;
   void setBias(const Matrix& bias);
 
-  const Matrix& getOutput(void) const;
-
 private:
   Matrix mBias;
-  Matrix mOutput;
-  MatrixPortHandle mInputPort;
 };
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/DeadBand.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/DeadBand.cpp	2008-11-17 19:24:20 UTC (rev 742)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/DeadBand.cpp	2008-11-17 21:22:22 UTC (rev 743)
@@ -4,61 +4,36 @@
 
 #include "DeadBand.h"
 
-#include <string>
-#include <vector>
+#include "Matrix.h"
 
-#include "Assert.h"
-#include "Object.h"
-#include "Vector.h"
-#include "Model.h"
-
 namespace OpenFDM {
 
-BEGIN_OPENFDM_OBJECT_DEF(DeadBand, Model)
+BEGIN_OPENFDM_OBJECT_DEF(DeadBand, UnaryModel)
   DEF_OPENFDM_PROPERTY(Real, Width, Serialized)
   END_OPENFDM_OBJECT_DEF
 
-DeadBand::DeadBand(const std::string& name) : Model(name)
+DeadBand::DeadBand(const std::string& name, const real_type& width) :
+  UnaryModel(name),
+  mWidth(width)
 {
-  setDirectFeedThrough(true);
-  
-  setNumInputPorts(1);
-  setInputPortName(0, "input");
-  
-  setNumOutputPorts(1);
-  setOutputPort(0, "output", this, &DeadBand::getOutput);
 }
 
 DeadBand::~DeadBand(void)
 {
 }
   
-bool
-DeadBand::init(void)
+ModelContext*
+DeadBand::newModelContext(PortValueList& portValueList) const
 {
-  mInputPort = getInputPort(0)->toRealPortHandle();
-  if (!mInputPort.isConnected()) {
-    Log(Model, Error) << "Initialization of DeadBand model \"" << getName()
-                      << "\" failed: Input port \"" << getInputPortName(0)
-                      << "\" is not connected!" << endl;
-    return false;
-  }
-
-  return Model::init();
+  return UnaryModel::newModelContext(this, portValueList);
 }
 
 void
-DeadBand::output(const TaskInfo&)
+DeadBand::output(const Matrix& inputValue, Matrix& outputValue) const
 {
-  OpenFDMAssert(mInputPort.isConnected());
-  
-  mOutput = mInputPort.getRealValue();
-  if (mOutput < -mWidth)
-    mOutput += mWidth;
-  else if (mWidth < mOutput)
-    mOutput -= mWidth;
-  else
-    mOutput = 0;
+  for (unsigned i = 0; i < rows(inputValue); ++i)
+    for (unsigned j = 0; j < cols(inputValue); ++j)
+      outputValue(i, j) = deadBand(inputValue(i, j), mWidth);
 }
 
 const real_type&
@@ -73,10 +48,4 @@
   mWidth = width;
 }
 
-const real_type&
-DeadBand::getOutput(void) const
-{
-  return mOutput;
-}
-
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/DeadBand.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/DeadBand.h	2008-11-17 19:24:20 UTC (rev 742)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/DeadBand.h	2008-11-17 21:22:22 UTC (rev 743)
@@ -6,32 +6,26 @@
 #define OpenFDM_DeadBand_H
 
 #include <string>
-#include <vector>
 
-#include "Assert.h"
-#include "Object.h"
-#include "Model.h"
+#include "UnaryModel.h"
 
 namespace OpenFDM {
 
-class DeadBand : public Model {
-  OPENFDM_OBJECT(DeadBand, Model);
+class DeadBand : public UnaryModel {
+  OPENFDM_OBJECT(DeadBand, UnaryModel);
 public:
-  DeadBand(const std::string& name);
+  DeadBand(const std::string& name, const real_type& width = real_type(0));
   virtual ~DeadBand(void);
-  
-  virtual bool init(void);
-  virtual void output(const TaskInfo&);
 
+  ModelContext* newModelContext(PortValueList&) const;
+
+  void output(const Matrix& inputValue, Matrix& outputValue) const;
+
   const real_type& getWidth(void) const;
   void setWidth(const real_type& width);
 
-  const real_type& getOutput(void) const;
-
 private:
   real_type mWidth;
-  real_type mOutput;
-  RealPortHandle mInputPort;
 };
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Gain.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Gain.cpp	2008-11-17 19:24:20 UTC (rev 742)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Gain.cpp	2008-11-17 21:22:22 UTC (rev 743)
@@ -5,24 +5,16 @@
 #include "Gain.h"
 
 #include <string>
-#include <vector>
-
-#include "Assert.h"
-#include "Object.h"
-#include "LeafContext.h"
-#include "Model.h"
 #include "Vector.h"
 
 namespace OpenFDM {
 
-BEGIN_OPENFDM_OBJECT_DEF(Gain, Model)
+BEGIN_OPENFDM_OBJECT_DEF(Gain, UnaryModel)
   DEF_OPENFDM_PROPERTY(Real, Gain, Serialized)
   END_OPENFDM_OBJECT_DEF
 
 Gain::Gain(const std::string& name, const real_type& gain) :
-  Model(name),
-  mInputPort(newMatrixInputPort("input", true)),
-  mOutputPort(newMatrixOutputPort("output")),
+  UnaryModel(name),
   mGain(gain)
 {
 }
@@ -31,27 +23,16 @@
 {
 }
 
-bool
-Gain::alloc(LeafContext& leafContext) const
+ModelContext*
+Gain::newModelContext(PortValueList& portValueList) const
 {
-  Size sz = size(leafContext.mPortValueList[mInputPort]);
-  Log(Initialization, Debug)
-    << "Size for Gain is detemined by the input port with size: "
-    << trans(sz) << std::endl;
-  if (!leafContext.mPortValueList.setOrCheckPortSize(mOutputPort, sz)) {
-    Log(Initialization, Error)
-      << "Size for output port does not match!" << std::endl;
-    return false;
-  }
-  return true;
+  return UnaryModel::newModelContext(this, portValueList);
 }
 
 void
-Gain::output(const Task&,const DiscreteStateValueVector&,
-             const ContinousStateValueVector&,
-             PortValueList& portValues) const
+Gain::output(const Matrix& inputValue, Matrix& outputValue) const
 {
-  portValues[mOutputPort] = mGain*portValues[mInputPort];
+  outputValue = mGain*inputValue;
 }
 
 const real_type&

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Gain.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Gain.h	2008-11-17 19:24:20 UTC (rev 742)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Gain.h	2008-11-17 21:22:22 UTC (rev 743)
@@ -7,27 +7,25 @@
 
 #include <string>
 
-#include "Model.h"
+#include "UnaryModel.h"
+#include "ModelContext.h"
 
 namespace OpenFDM {
 
-class Gain : public Model {
-  OPENFDM_OBJECT(Gain, Model);
+class Gain : public UnaryModel {
+  OPENFDM_OBJECT(Gain, UnaryModel);
 public:
   Gain(const std::string& name, const real_type& gain = real_type(1));
   virtual ~Gain(void);
 
-  virtual bool alloc(LeafContext& leafContext) const;
-  virtual void output(const Task&,const DiscreteStateValueVector&,
-                      const ContinousStateValueVector&,
-                      PortValueList& portValues) const;
+  ModelContext* newModelContext(PortValueList&) const;
 
+  void output(const Matrix& inputValue, Matrix& outputValue) const;
+
   const real_type& getGain(void) const;
   void setGain(const real_type& gain);
 
 private:
-  MatrixInputPort mInputPort;
-  MatrixOutputPort mOutputPort;
   real_type mGain;
 };
 

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-11-17 19:24:20 UTC (rev 742)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-11-17 21:22:22 UTC (rev 743)
@@ -230,19 +230,23 @@
   TransferFunction.h \
   Turbulence.h \
   UnaryFunctionModel.h \
+  UnaryModel.h \
   UniversalJoint.h \
   Vehicle.h \
   WheelContact.h \
   Wind.h
 
 OpenFDMModelsSOURCES = \
+  Bias.cpp \
   ConstModel.cpp \
+  DeadBand.cpp \
   Delay.cpp \
   DiscreteIntegrator.cpp \
   Gain.cpp \
   Input.cpp \
   Integrator.cpp \
   Output.cpp \
+  Saturation.cpp \
   SimulationTime.cpp
 
 OpenFDMMechanicSOURCES = \
@@ -255,17 +259,15 @@
   RevoluteJoint.cpp \
   RotationalJoint.cpp \
   Sensor.cpp \
+  UnaryModel.cpp \
   UniversalJoint.cpp
 
-
 #   AeroForce.cpp \
 #   AirSpring.cpp \
 #   Atmosphere.cpp \
 #   AtmosphereSTD1976.cpp \
-#   Bias.cpp \
 #   BinaryFunctionModel.cpp \
 #   Contact.cpp \
-#   DeadBand.cpp \
 #   DefaultGravity.cpp \
 #   DefaultGround.cpp \
 #   DefaultPlanet.cpp \
@@ -281,7 +283,6 @@
 #   Output.cpp \
 #   Product.cpp \
 #   RigidBody.cpp \
-#   Saturation.cpp \
 #   SimpleContact.cpp \
 #   SimpleGear.cpp \
 #   Summer.cpp \

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/PortValueList.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/PortValueList.h	2008-11-17 19:24:20 UTC (rev 742)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/PortValueList.h	2008-11-17 21:22:22 UTC (rev 743)
@@ -83,6 +83,20 @@
     else
       return false;
   }
+  bool setOrCheckPortSize(const OutputPortInfo* portInfo, const Size& sz)
+  {
+    if (!portInfo)
+      return false;
+    Size oldSize = size(getPortValue(portInfo)->getValue());
+    // If the size is still 0x0, just set to the desired size
+    if (oldSize(0) == 0 || oldSize(1) == 0) {
+      getPortValue(portInfo)->getValue().resize(sz(0), sz(1));
+      return true;
+    } else if (oldSize == sz)
+      return true;
+    else
+      return false;
+  }
   bool setOrCheckPortSize(const MatrixInputPort& port, const Size& sz)
   {
     Size oldSize = size(port.getPortValue(mPortValueVector)->getValue());
@@ -95,6 +109,20 @@
     else
       return false;
   }
+  bool setOrCheckPortSize(const InputPortInfo* portInfo, const Size& sz)
+  {
+    if (!portInfo)
+      return false;
+    Size oldSize = size(getPortValue(portInfo)->getValue());
+    // If the size is still 0x0, just set to the desired size
+    if (oldSize(0) == 0 || oldSize(1) == 0) {
+      getPortValue(portInfo)->getValue().resize(sz(0), sz(1));
+      return true;
+    } else if (oldSize == sz)
+      return true;
+    else
+      return false;
+  }
   const PortValue* getPortValue(unsigned idx) const
   {
     if (mPortValueVector.size() <= idx)
@@ -109,6 +137,19 @@
   }
 
   /// Save but partially expensive Accessor for numeric ports
+  NumericPortValue* getPortValue(const NumericPortInfo* portInfo)
+  {
+    if (!portInfo)
+      return 0;
+    return getPortValue(*portInfo);
+  }
+  NumericPortValue* getPortValue(const NumericPortInfo& portInfo)
+  {
+    PortValue* portValue = getPortValue(portInfo.getIndex());
+    if (!portValue)
+      return 0;
+    return portValue->toNumericPortValue();
+  }
   const NumericPortValue* getPortValue(const NumericPortInfo* portInfo) const
   {
     if (!portInfo)

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Saturation.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Saturation.cpp	2008-11-17 19:24:20 UTC (rev 742)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Saturation.cpp	2008-11-17 21:22:22 UTC (rev 743)
@@ -4,70 +4,38 @@
 
 #include "Saturation.h"
 
-#include <string>
-#include <vector>
-
-#include "Assert.h"
-#include "Object.h"
-#include "Vector.h"
 #include "Matrix.h"
-#include "Model.h"
 
 namespace OpenFDM {
 
-BEGIN_OPENFDM_OBJECT_DEF(Saturation, Model)
+BEGIN_OPENFDM_OBJECT_DEF(Saturation, UnaryModel)
   DEF_OPENFDM_PROPERTY(Matrix, MinSaturation, Serialized)
   DEF_OPENFDM_PROPERTY(Matrix, MaxSaturation, Serialized)
   END_OPENFDM_OBJECT_DEF
 
-Saturation::Saturation(const std::string& name) : Model(name)
+Saturation::Saturation(const std::string& name) :
+  UnaryModel(name)
 {
-  setDirectFeedThrough(true);
-  
-  setNumInputPorts(1);
-  setInputPortName(0, "input");
-  
-  setNumOutputPorts(1);
-  setOutputPort(0, "output", this, &Saturation::getOutput);
 }
 
 Saturation::~Saturation(void)
 {
 }
   
-bool
-Saturation::init(void)
+ModelContext*
+Saturation::newModelContext(PortValueList& portValueList) const
 {
-  mInputPort = getInputPort(0)->toMatrixPortHandle();
-  if (!mInputPort.isConnected()) {
-    Log(Model, Error) << "Initialization of Saturation model \""
-                      << getName()
-                      << "\" failed: Input port \"" << getInputPortName(0)
-                      << "\" is not connected!" << endl;
-    return false;
-  }
-
-  Matrix inputMatrix = mInputPort.getMatrixValue();
-  if (0 < rows(mMaxSaturation) && 0 < cols(mMaxSaturation) &&
-      size(mMaxSaturation) != size(inputMatrix))
-    mOutput.resize(0, 0);
-  if (0 < rows(mMinSaturation) && 0 < cols(mMinSaturation) &&
-      size(mMinSaturation) != size(inputMatrix))
-    mOutput.resize(0, 0);
-  
-  mOutput.resize(inputMatrix);
-
-  return Model::init();
+  return UnaryModel::newModelContext(this, portValueList);
 }
 
 void
-Saturation::output(const TaskInfo&)
+Saturation::output(const Matrix& inputValue, Matrix& outputValue) const
 {
-  mOutput = mInputPort.getMatrixValue();
+  outputValue = inputValue;
   if (0 < rows(mMaxSaturation) && 0 < cols(mMaxSaturation))
-    mOutput = LinAlg::min(mOutput, mMaxSaturation);
+    outputValue = LinAlg::min(outputValue, mMaxSaturation);
   if (0 < rows(mMinSaturation) && 0 < cols(mMinSaturation))
-    mOutput = LinAlg::max(mOutput, mMinSaturation);
+    outputValue = LinAlg::max(outputValue, mMinSaturation);
 }
 
 const Matrix&
@@ -94,10 +62,4 @@
   mMaxSaturation = maxSaturation;
 }
 
-const Matrix&
-Saturation::getOutput(void) const
-{
-  return mOutput;
-}
-
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Saturation.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Saturation.h	2008-11-17 19:24:20 UTC (rev 742)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Saturation.h	2008-11-17 21:22:22 UTC (rev 743)
@@ -6,38 +6,30 @@
 #define OpenFDM_Saturation_H
 
 #include <string>
-#include <vector>
 
-#include "Assert.h"
-#include "Object.h"
-#include "Vector.h"
 #include "Matrix.h"
-#include "Model.h"
+#include "UnaryModel.h"
 
 namespace OpenFDM {
 
-class Saturation : public Model {
-  OPENFDM_OBJECT(Saturation, Model);
+class Saturation : public UnaryModel {
+  OPENFDM_OBJECT(Saturation, UnaryModel);
 public:
   Saturation(const std::string& name);
   virtual ~Saturation(void);
   
-  virtual bool init(void);
-  virtual void output(const TaskInfo&);
+  ModelContext* newModelContext(PortValueList&) const;
 
+  void output(const Matrix& inputValue, Matrix& outputValue) const;
+
   const Matrix& getMinSaturation(void) const;
   void setMinSaturation(const Matrix& minSaturation);
   const Matrix& getMaxSaturation(void) const;
   void setMaxSaturation(const Matrix& maxSaturation);
 
-  const Matrix& getOutput(void) const;
-
 private:
   Matrix mMaxSaturation;
   Matrix mMinSaturation;
-  Matrix mOutput;
-
-  MatrixPortHandle mInputPort;
 };
 
 } // namespace OpenFDM

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/UnaryModel.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/UnaryModel.cpp	2008-11-17 19:24:20 UTC (rev 742)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/UnaryModel.cpp	2008-11-17 21:22:22 UTC (rev 743)
@@ -0,0 +1,41 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
+ *
+ */
+
+#include "UnaryModel.h"
+
+#include "LogStream.h"
+
+namespace OpenFDM {
+
+BEGIN_OPENFDM_OBJECT_DEF(UnaryModel, AbstractModel)
+  END_OPENFDM_OBJECT_DEF
+
+UnaryModel::UnaryModel(const std::string& name) :
+  AbstractModel(name),
+  mInputPort(new InputPortInfo(this, "input", Size(0, 0), true)),
+  mOutputPort(new OutputPortInfo(this, "output", Size(0, 0), false))
+{
+}
+
+UnaryModel::~UnaryModel()
+{
+}
+
+bool
+UnaryModel::alloc(LeafContext& leafContext) const
+{
+  Size sz;
+  sz = size(leafContext.mPortValueList.getPortValue(mInputPort)->getValue());
+  Log(Initialization, Debug)
+    << "Size for Gain is detemined by the input port with size: "
+    << trans(sz) << std::endl;
+  if (!leafContext.mPortValueList.setOrCheckPortSize(mOutputPort, sz)) {
+    Log(Initialization, Error)
+      << "Size for output port does not match!" << std::endl;
+    return false;
+  }
+  return true;
+}
+
+} // namespace OpenFDM

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/UnaryModel.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/UnaryModel.h	2008-11-17 19:24:20 UTC (rev 742)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/UnaryModel.h	2008-11-17 21:22:22 UTC (rev 743)
@@ -0,0 +1,95 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_UnaryModel_H
+#define OpenFDM_UnaryModel_H
+
+#include <string>
+
+#include "AbstractModel.h"
+#include "ModelContext.h"
+
+namespace OpenFDM {
+
+class UnaryModel : public AbstractModel {
+  OPENFDM_OBJECT(UnaryModel, AbstractModel);
+public:
+  UnaryModel(const std::string& name);
+  virtual ~UnaryModel();
+
+  virtual bool alloc(LeafContext& leafContext) const;
+
+protected:
+  template<typename UM>
+  ModelContext* newModelContext(UM* um, PortValueList& portValueList) const
+  {
+    SharedPtr<Context<UM> > context;
+    context = new Context<UM>(um, portValueList.getPortValue(mInputPort),
+                              portValueList.getPortValue(mOutputPort));
+    for (unsigned i = 0; i < getNumPorts(); ++i) {
+      PortValue* portValue = portValueList.getPortValue(i);
+      if (!portValue) {
+        Log(Model, Error) << "No port value given for model \"" << getName()
+                          << "\" and port \"" << getPort(i)->getName()
+                          << "\"" << endl;
+        return false;
+      }
+      context->setPortValue(*getPort(i), portValue);
+    }
+    if (!context->alloc()) {
+      Log(Model, Warning) << "Could not alloc for model \""
+                          << getName() << "\"" << endl;
+      return false;
+    }
+    return context.release();
+  }
+
+  template<typename UM>
+  class Context : public ModelContext {
+  public:
+    Context(const UM* unaryModel, const NumericPortValue* inputValue,
+            NumericPortValue* outputValue) :
+      mUnaryModel(unaryModel),
+      mInputValue(inputValue),
+      mOutputValue(outputValue)
+    { }
+    virtual ~Context()
+    { }
+    
+    virtual const UM& getNode() const
+    { return *mUnaryModel; }
+    
+    bool alloc()
+    {
+      if (!allocStates())
+        return false;
+      return mUnaryModel->alloc(*this);
+    }
+    virtual void initOutput(const /*Init*/Task&)
+    { mUnaryModel->output(mInputValue->getValue(), mOutputValue->getValue()); }
+    virtual void output(const Task&)
+    { mUnaryModel->output(mInputValue->getValue(), mOutputValue->getValue()); }
+    virtual void update(const DiscreteTask&)
+    { }
+    virtual void derivative(const Task&)
+    { }
+    
+  private:
+    Context();
+    Context(const Context&);
+    Context& operator=(const Context&);
+    
+    SharedPtr<const UM> mUnaryModel;
+    SharedPtr<const NumericPortValue> mInputValue;
+    SharedPtr<NumericPortValue> mOutputValue;
+  };
+
+private:
+  SharedPtr<InputPortInfo> mInputPort;
+  SharedPtr<OutputPortInfo> mOutputPort;
+};
+
+} // namespace OpenFDM
+
+#endif



From frohlich at mail.berlios.de  Tue Nov 18 17:42:23 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Tue, 18 Nov 2008 17:42:23 +0100
Subject: [OpenFDM-svn] r744 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811181642.mAIGgNbX028556@sheep.berlios.de>

Author: frohlich
Date: 2008-11-18 17:42:21 +0100 (Tue, 18 Nov 2008)
New Revision: 744

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeContext.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeContext.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeInstance.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/DiscreteIntegrator.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Integrator.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/LeafContext.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/LeafNode.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Model.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/UnaryModel.cpp
Log:
Move alloc and init methods upwards.
More interfaces in the PortValues.

M    src/OpenFDM/LeafNode.h
M    src/OpenFDM/CartesianJoint.h
M    src/OpenFDM/Model.h
M    src/OpenFDM/Interact.cpp
M    src/OpenFDM/RootJoint.cpp
M    src/OpenFDM/Interact.h
M    src/OpenFDM/AbstractNodeContext.cpp
M    src/OpenFDM/UnaryModel.cpp
M    src/OpenFDM/Integrator.cpp
M    src/OpenFDM/LeafContext.h
M    src/OpenFDM/RootJoint.h
M    src/OpenFDM/DiscreteIntegrator.cpp
M    src/OpenFDM/AbstractNodeInstance.h
M    src/OpenFDM/Delay.cpp
M    src/OpenFDM/AbstractNodeContext.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeContext.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeContext.cpp	2008-11-17 21:22:22 UTC (rev 743)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeContext.cpp	2008-11-18 16:42:21 UTC (rev 744)
@@ -17,11 +17,24 @@
 const PortValue*
 AbstractNodeContext::getPortValue(const PortInfo& portInfo) const
 {
-  return mPortValueList.getPortValue(portInfo.getIndex());
+  return mPortValueList.getPortValue(portInfo);
 }
 
+const NumericPortValue*
+AbstractNodeContext::getPortValue(const NumericPortInfo& portInfo) const
+{
+  return mPortValueList.getPortValue(portInfo);
+}
+
+const MechanicLinkValue*
+AbstractNodeContext::getPortValue(const MechanicLinkInfo& portInfo) const
+{
+  return mPortValueList.getPortValue(portInfo);
+}
+
 void
-AbstractNodeContext::setPortValue(const PortInfo& portInfo, PortValue* portValue)
+AbstractNodeContext::setPortValue(const PortInfo& portInfo,
+                                  PortValue* portValue)
 {
   mPortValueList.setPortValue(portInfo.getIndex(), portValue);
 }

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeContext.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeContext.h	2008-11-17 21:22:22 UTC (rev 743)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeContext.h	2008-11-18 16:42:21 UTC (rev 744)
@@ -19,17 +19,14 @@
   virtual const Node& getNode() const = 0;
 
   /// Port value accessors for System external usage.
-  virtual const PortValue* getPortValue(const PortInfo& portInfo) const;
+  virtual const PortValue* getPortValue(const PortInfo&) const;
+  virtual const NumericPortValue* getPortValue(const NumericPortInfo&) const;
+  virtual const MechanicLinkValue* getPortValue(const MechanicLinkInfo&) const;
 
   /// Set port value for the given port.
-  virtual void setPortValue(const PortInfo& portInfo, PortValue* portValue);
+  virtual void setPortValue(const PortInfo&, PortValue*);
 
-  /// might vanish???
-  PortValueList& getPortValueList()
-  { return mPortValueList; }
-  const PortValueList& getPortValueList() const
-  { return mPortValueList; }
-
+protected:
   // PortValues
   PortValueList mPortValueList;
 };

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeInstance.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeInstance.h	2008-11-17 21:22:22 UTC (rev 743)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeInstance.h	2008-11-18 16:42:21 UTC (rev 744)
@@ -67,13 +67,13 @@
   /// Access port values by the PortInfo values
   virtual const PortValue*
   getPortValue(const PortInfo& portInfo) const
-  { return mNodeContext->getPortValueList().getPortValue(portInfo); }
+  { return mNodeContext->getPortValue(portInfo); }
   virtual const NumericPortValue*
   getPortValue(const NumericPortInfo& portInfo) const
-  { return mNodeContext->getPortValueList().getPortValue(portInfo); }
+  { return mNodeContext->getPortValue(portInfo); }
   virtual const MechanicLinkValue*
   getPortValue(const MechanicLinkInfo& portInfo) const
-  { return mNodeContext->getPortValueList().getPortValue(portInfo); }
+  { return mNodeContext->getPortValue(portInfo); }
 
   /// Set port value for the given port.
   virtual void setPortValue(const PortInfo& portInfo, PortValue* portValue)

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h	2008-11-17 21:22:22 UTC (rev 743)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h	2008-11-18 16:42:21 UTC (rev 744)
@@ -176,6 +176,9 @@
     childLink.setAccel(parentLink, mJointMatrix*velDot);
   }
 
+  virtual void init(const Task&,DiscreteStateValueVector&,
+                    ContinousStateValueVector&, const PortValueList&) const
+  { }
   virtual void initDesignPosition(const MechanicLinkValue& parentLink,
                                   MechanicLinkValue& childLink) const = 0;
   virtual void velocity(const MechanicLinkValue& parentLink,
@@ -219,9 +222,7 @@
 
     bool alloc()
     {
-      if (!allocStates())
-        return false;
-      return mCartesianJoint->alloc(*this);
+      return allocStates();
     }
     virtual void initVelocities(const /*Init*/Task& task)
     {

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.cpp	2008-11-17 21:22:22 UTC (rev 743)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.cpp	2008-11-18 16:42:21 UTC (rev 744)
@@ -41,12 +41,12 @@
   Log(Initialization, Debug)
     << "Size for Delay is detemined by the static initial value "
     << "with size: " << trans(sz) << std::endl;
-  if (!context.mPortValueList.setOrCheckPortSize(mInputPort, sz)) {
+  if (!context.getPortValueList().setOrCheckPortSize(mInputPort, sz)) {
     Log(Initialization, Error)
       << "Size for input port does not match!" << std::endl;
     return false;
   }
-  if (!context.mPortValueList.setOrCheckPortSize(mOutputPort, sz)) {
+  if (!context.getPortValueList().setOrCheckPortSize(mOutputPort, sz)) {
     Log(Initialization, Error)
       << "Size for output port does not match!" << std::endl;
     return false;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/DiscreteIntegrator.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/DiscreteIntegrator.cpp	2008-11-17 21:22:22 UTC (rev 743)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/DiscreteIntegrator.cpp	2008-11-18 16:42:21 UTC (rev 744)
@@ -34,7 +34,7 @@
 {
   Size sz;
   if (getEnableInitialValuePort()) {
-    sz = size(leafContext.mPortValueList[mInitialValuePort]);
+    sz = size(leafContext.getPortValueList()[mInitialValuePort]);
     Log(Initialization, Debug)
       << "Size for Integrator is detemined by the initial input "
       << "port with size: " << trans(sz) << std::endl;
@@ -44,12 +44,12 @@
       << "Size for Integrator is detemined by the static initial value "
       << "with size: " << trans(sz) << std::endl;
   }
-  if (!leafContext.mPortValueList.setOrCheckPortSize(mInputPort, sz)) {
+  if (!leafContext.getPortValueList().setOrCheckPortSize(mInputPort, sz)) {
     Log(Initialization, Error)
       << "Size for input port does not match!" << std::endl;
     return false;
   }
-  if (!leafContext.mPortValueList.setOrCheckPortSize(mOutputPort, sz)) {
+  if (!leafContext.getPortValueList().setOrCheckPortSize(mOutputPort, sz)) {
     Log(Initialization, Error)
       << "Size for input port does not match!" << std::endl;
     return false;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Integrator.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Integrator.cpp	2008-11-17 21:22:22 UTC (rev 743)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Integrator.cpp	2008-11-18 16:42:21 UTC (rev 744)
@@ -33,7 +33,7 @@
 {
   Size sz;
   if (getEnableInitialValuePort()) {
-    sz = size(leafContext.mPortValueList[mInitialValuePort]);
+    sz = size(leafContext.getPortValueList()[mInitialValuePort]);
     Log(Initialization, Debug)
       << "Size for Integrator is detemined by the initial input "
       << "port with size: " << trans(sz) << std::endl;
@@ -43,12 +43,12 @@
       << "Size for Integrator is detemined by the static initial value "
       << "with size: " << trans(sz) << std::endl;
   }
-  if (!leafContext.mPortValueList.setOrCheckPortSize(mInputPort, sz)) {
+  if (!leafContext.getPortValueList().setOrCheckPortSize(mInputPort, sz)) {
     Log(Initialization, Error)
       << "Size for input port does not match!" << std::endl;
     return false;
   }
-  if (!leafContext.mPortValueList.setOrCheckPortSize(mOutputPort, sz)) {
+  if (!leafContext.getPortValueList().setOrCheckPortSize(mOutputPort, sz)) {
     Log(Initialization, Error)
       << "Size for input port does not match!" << std::endl;
     return false;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.cpp	2008-11-17 21:22:22 UTC (rev 743)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.cpp	2008-11-18 16:42:21 UTC (rev 744)
@@ -18,13 +18,14 @@
   virtual const Interact& getNode() const
   { return *mInteract; }
 
+  virtual bool alloc()
+  { return allocStates(); }
+
   virtual void initDesignPosition()
   {
     mInteract->initDesignPosition(mPortValueList);
   }
 
-  virtual bool alloc()
-  { if (!allocStates()) return false; return mInteract->alloc(*this); }
   virtual void initVelocities(const /*Init*/Task& task)
   {
     mInteract->init(task, mDiscreteState, mContinousState, mPortValueList);

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.h	2008-11-17 21:22:22 UTC (rev 743)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.h	2008-11-18 16:42:21 UTC (rev 744)
@@ -21,6 +21,9 @@
 
   virtual MechanicContext* newMechanicContext(PortValueList& portValues) const;
 
+  virtual void init(const Task&,DiscreteStateValueVector&,
+                    ContinousStateValueVector&, const PortValueList&) const
+  { }
   virtual void initDesignPosition(PortValueList&) const = 0;
   virtual void velocity(const Task&, const ContinousStateValueVector&,
                         PortValueList&) const

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/LeafContext.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/LeafContext.h	2008-11-17 21:22:22 UTC (rev 743)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/LeafContext.h	2008-11-18 16:42:21 UTC (rev 744)
@@ -42,15 +42,19 @@
     }
     return true;
   }
+
+  /// might vanish???
+  PortValueList& getPortValueList()
+  { return mPortValueList; }
+  const PortValueList& getPortValueList() const
+  { return mPortValueList; }
+
 // protected:
   // Continous States
   ContinousStateValueVector mContinousState;
   ContinousStateValueVector mContinousStateDerivative;
   // Discrete States
   DiscreteStateValueVector mDiscreteState;
-
-  // functors to the operations to do??
-
 };
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/LeafNode.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/LeafNode.h	2008-11-17 21:22:22 UTC (rev 743)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/LeafNode.h	2008-11-18 16:42:21 UTC (rev 744)
@@ -27,17 +27,6 @@
   virtual void accept(NodeVisitor& visitor);
   virtual void accept(ConstNodeVisitor& visitor) const;
 
-  // Is done once before a model starts to live
-  // Should have connect information here, can setup memory allocations and
-  // sizes. Then the PortValueList does not need to have resizable stuff.
-  // The same goes for the states.
-  virtual bool alloc(LeafContext&) const // = 0;
-  { return true; }
-
-  virtual void init(const Task&,DiscreteStateValueVector&,
-                    ContinousStateValueVector&, const PortValueList&) const
-  { }
-
   unsigned getNumContinousStateValues() const
   { return mContinousStateInfoVector.size(); }
   const ContinousStateInfo* getContinousStateInfo(unsigned index) const

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Model.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Model.h	2008-11-17 21:22:22 UTC (rev 743)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Model.h	2008-11-18 16:42:21 UTC (rev 744)
@@ -38,6 +38,12 @@
   // argument? May be it is sufficient to have a const and non const version??
   // FIXME???
   // const TaskInfo& taskInfo
+  virtual bool alloc(LeafContext&) const // = 0;
+  { return true; }
+
+  virtual void init(const Task&,DiscreteStateValueVector&,
+                    ContinousStateValueVector&, const PortValueList&) const
+  { }
   virtual void update(const DiscreteTask&, DiscreteStateValueVector&,
                       const ContinousStateValueVector&,
                       const PortValueList&) const { }

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.cpp	2008-11-17 21:22:22 UTC (rev 743)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.cpp	2008-11-18 16:42:21 UTC (rev 744)
@@ -18,13 +18,14 @@
   virtual const RootJoint& getNode() const
   { return *mRootJoint; }
   
+  bool alloc()
+  { return allocStates(); }
+
   virtual void initDesignPosition()
   {
     mRootJoint->initDesignPosition(mPortValueList);
   }
 
-  bool alloc()
-  { if (!allocStates()) return false; return mRootJoint->alloc(*this); }
   virtual void initVelocities(const /*Init*/Task& task)
   {
     mRootJoint->init(task, mDiscreteState, mContinousState, mPortValueList);

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.h	2008-11-17 21:22:22 UTC (rev 743)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.h	2008-11-18 16:42:21 UTC (rev 744)
@@ -29,6 +29,9 @@
   void setAngularBaseVelocity(const Vector3& angularBaseVelocity)
   { mAngularBaseVelocity = angularBaseVelocity; }
 
+  virtual void init(const Task&,DiscreteStateValueVector&,
+                    ContinousStateValueVector&, const PortValueList&) const
+  { }
   virtual void initDesignPosition(PortValueList&) const = 0;
 
   virtual void velocity(const Task&, const ContinousStateValueVector&,

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/UnaryModel.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/UnaryModel.cpp	2008-11-17 21:22:22 UTC (rev 743)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/UnaryModel.cpp	2008-11-18 16:42:21 UTC (rev 744)
@@ -26,11 +26,11 @@
 UnaryModel::alloc(LeafContext& leafContext) const
 {
   Size sz;
-  sz = size(leafContext.mPortValueList.getPortValue(mInputPort)->getValue());
+  sz = size(leafContext.getPortValue(*mInputPort)->getValue());
   Log(Initialization, Debug)
     << "Size for Gain is detemined by the input port with size: "
     << trans(sz) << std::endl;
-  if (!leafContext.mPortValueList.setOrCheckPortSize(mOutputPort, sz)) {
+  if (!leafContext.getPortValueList().setOrCheckPortSize(mOutputPort, sz)) {
     Log(Initialization, Error)
       << "Size for output port does not match!" << std::endl;
     return false;



From frohlich at mail.berlios.de  Tue Nov 18 17:56:44 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Tue, 18 Nov 2008 17:56:44 +0100
Subject: [OpenFDM-svn] r745 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811181656.mAIGuiG0029927@sheep.berlios.de>

Author: frohlich
Date: 2008-11-18 17:56:44 +0100 (Tue, 18 Nov 2008)
New Revision: 745

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeInstance.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/NodeInstance.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/NodeInstance.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
Log:
Remove some PortValue setters. Resolve some FIXMES.

M    src/OpenFDM/System.cpp
M    src/OpenFDM/AbstractNodeInstance.h
M    src/OpenFDM/NodeInstance.cpp
M    src/OpenFDM/NodeInstance.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeInstance.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeInstance.h	2008-11-18 16:42:21 UTC (rev 744)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeInstance.h	2008-11-18 16:56:44 UTC (rev 745)
@@ -40,10 +40,6 @@
   virtual const MechanicLinkValue*
   getPortValue(const MechanicLinkInfo& portInfo) const = 0;
 
-  /// Set port value for the given port.
-  // FIXME, must vanish ...
-  virtual void setPortValue(const PortInfo& portInfo, PortValue* portValue) = 0;
-
 private:
   AbstractNodeInstance(const AbstractNodeInstance&);
   AbstractNodeInstance& operator=(const AbstractNodeInstance&);
@@ -75,10 +71,6 @@
   getPortValue(const MechanicLinkInfo& portInfo) const
   { return mNodeContext->getPortValue(portInfo); }
 
-  /// Set port value for the given port.
-  virtual void setPortValue(const PortInfo& portInfo, PortValue* portValue)
-  { mNodeContext->setPortValue(portInfo, portValue); }
-
 private:
   LeafInstance(const LeafInstance&);
   LeafInstance& operator=(const LeafInstance&);

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/NodeInstance.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/NodeInstance.cpp	2008-11-18 16:42:21 UTC (rev 744)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/NodeInstance.cpp	2008-11-18 16:56:44 UTC (rev 745)
@@ -4,16 +4,46 @@
 
 #include "NodeInstance.h"
 
+#include "Assert.h"
+
 namespace OpenFDM {
 
-NodeInstance::NodeInstance(const SampleTime& sampleTime, const Node* node) :
+NodeInstance::NodeInstance(const SampleTime& sampleTime, const Node* node,
+                           const PortValueList& portValueList) :
   AbstractNodeInstance(sampleTime),
-  mNode(node)
+  mNode(node),
+  mPortValueList(portValueList)
 {
+  for (unsigned i = 0; i < mNode->getNumPorts(); ++i)
+    OpenFDMAssert(mPortValueList.getPortValue(mNode->getPort(i)));
 }
 
 NodeInstance::~NodeInstance()
 {
 }
 
+const Node&
+NodeInstance::getNode() const
+{
+  return *mNode;
+}
+
+const PortValue*
+NodeInstance::getPortValue(const PortInfo& portInfo) const
+{
+  return mPortValueList.getPortValue(portInfo);
+}
+
+const NumericPortValue*
+NodeInstance::getPortValue(const NumericPortInfo& portInfo) const
+{
+  return mPortValueList.getPortValue(portInfo);
+}
+
+const MechanicLinkValue*
+NodeInstance::getPortValue(const MechanicLinkInfo& portInfo) const
+{
+  return mPortValueList.getPortValue(portInfo);
+}
+
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/NodeInstance.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/NodeInstance.h	2008-11-18 16:42:21 UTC (rev 744)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/NodeInstance.h	2008-11-18 16:56:44 UTC (rev 745)
@@ -11,24 +11,15 @@
 
 class NodeInstance : public AbstractNodeInstance {
 public:
-  NodeInstance(const SampleTime& sampleTime,
-               const Node* node);
+  NodeInstance(const SampleTime&, const Node*, const PortValueList&);
   virtual ~NodeInstance();
 
-  virtual const Node& getNode() const
-  { return *mNode; }
+  virtual const Node& getNode() const;
 
-  virtual const PortValue* getPortValue(const PortInfo& portInfo) const
-  { return mPortValueList.getPortValue(portInfo); }
-  virtual const NumericPortValue* getPortValue(const NumericPortInfo& portInfo) const
-  { return mPortValueList.getPortValue(portInfo); }
-  virtual const MechanicLinkValue* getPortValue(const MechanicLinkInfo& portInfo) const
-  { return mPortValueList.getPortValue(portInfo); }
+  virtual const PortValue* getPortValue(const PortInfo&) const;
+  virtual const NumericPortValue* getPortValue(const NumericPortInfo&) const;
+  virtual const MechanicLinkValue* getPortValue(const MechanicLinkInfo&) const;
 
-  /// Set port value for the given port.
-  virtual void setPortValue(const PortInfo& portInfo, PortValue* portValue)
-  { mPortValueList.setPortValue(portInfo.getIndex(), portValue); }
-
 private:
   SharedPtr<const Node> mNode;
 

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-18 16:42:21 UTC (rev 744)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-18 16:56:44 UTC (rev 745)
@@ -502,15 +502,7 @@
     { }
     virtual const Node* getNode() const { return mNode; }
     virtual AbstractNodeInstance* newNodeInstance()
-    {
-      NodeInstance* nodeInstance;
-      nodeInstance = new NodeInstance(mSampleTime, getNode());
-      OpenFDMAssert(mNode->getNumPorts() == mPortDataVector.size());
-      for (unsigned i = 0; i < mNode->getNumPorts(); ++i)
-        nodeInstance->setPortValue(*mNode->getPort(i),
-                                   mPortValueList.getPortValue(i));
-      return nodeInstance;
-    }
+    { return new NodeInstance(mSampleTime, getNode(), mPortValueList); }
   private:
     SharedPtr<const Node> mNode;
   };
@@ -535,9 +527,7 @@
     }
 
     virtual AbstractNodeInstance* newNodeInstance()
-    {
-      return new LeafInstance(mSampleTime, mModelContext);
-    }
+    { return new LeafInstance(mSampleTime, mModelContext); }
 
     ModelContext* getModelContext()
     { return mModelContext; }
@@ -557,9 +547,7 @@
     virtual bool createMechanicContext() = 0;
 
     virtual AbstractNodeInstance* newNodeInstance()
-    {
-      return new LeafInstance(mSampleTime, mMechanicContext);
-    }
+    { return new LeafInstance(mSampleTime, mMechanicContext); }
 
     MechanicContext* getMechanicContext()
     { return mMechanicContext; }



From frohlich at mail.berlios.de  Tue Nov 18 18:23:10 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Tue, 18 Nov 2008 18:23:10 +0100
Subject: [OpenFDM-svn] r746 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811181723.mAIHNAs5032562@sheep.berlios.de>

Author: frohlich
Date: 2008-11-18 18:23:10 +0100 (Tue, 18 Nov 2008)
New Revision: 746

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/LeafNode.h
Log:
Move fwd decls to where they belong.

M    src/OpenFDM/LeafNode.h
M    src/OpenFDM/Interact.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.h	2008-11-18 16:56:44 UTC (rev 745)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.h	2008-11-18 17:23:10 UTC (rev 746)
@@ -10,6 +10,13 @@
 
 namespace OpenFDM {
 
+class ConstNodeVisitor;
+class ContinousStateValueVector;
+class DiscreteStateValueVector;
+class NodeVisitor;
+class PortValueList;
+class Task;
+
 class Interact : public MechanicNode {
   OPENFDM_OBJECT(Interact, MechanicNode);
 public:

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/LeafNode.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/LeafNode.h	2008-11-18 16:56:44 UTC (rev 745)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/LeafNode.h	2008-11-18 17:23:10 UTC (rev 746)
@@ -12,12 +12,8 @@
 
 namespace OpenFDM {
 
-class LeafContext;
+class ConstNodeVisitor;
 class NodeVisitor;
-class ContinousStateValueVector;
-class DiscreteStateValueVector;
-class PortValueList;
-class Task;
 
 class LeafNode : public Node {
   OPENFDM_OBJECT(LeafNode, Node);



From frohlich at mail.berlios.de  Tue Nov 18 18:31:44 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Tue, 18 Nov 2008 18:31:44 +0100
Subject: [OpenFDM-svn] r747 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811181731.mAIHViPo002381@sheep.berlios.de>

Author: frohlich
Date: 2008-11-18 18:31:42 +0100 (Tue, 18 Nov 2008)
New Revision: 747

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
Log:
Remove some already done files from the TODO list.

M    Makefile.am


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-11-18 17:23:10 UTC (rev 746)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-11-18 17:31:42 UTC (rev 747)
@@ -280,9 +280,7 @@
 #   LinearSpringDamper.cpp \
 #   MaxModel.cpp \
 #   MinModel.cpp \
-#   Output.cpp \
 #   Product.cpp \
-#   RigidBody.cpp \
 #   SimpleContact.cpp \
 #   SimpleGear.cpp \
 #   Summer.cpp \



From frohlich at mail.berlios.de  Tue Nov 18 18:46:34 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Tue, 18 Nov 2008 18:46:34 +0100
Subject: [OpenFDM-svn] r748 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811181746.mAIHkYsT018477@sheep.berlios.de>

Author: frohlich
Date: 2008-11-18 18:46:33 +0100 (Tue, 18 Nov 2008)
New Revision: 748

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Bias.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Bias.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/PortValueList.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/UnaryModel.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/UnaryModel.h
Log:
More alloc removal.

M    src/OpenFDM/Bias.h
M    src/OpenFDM/UnaryModel.cpp
M    src/OpenFDM/PortValueList.h
M    src/OpenFDM/Bias.cpp
M    src/OpenFDM/UnaryModel.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Bias.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Bias.cpp	2008-11-18 17:31:42 UTC (rev 747)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Bias.cpp	2008-11-18 17:46:33 UTC (rev 748)
@@ -34,15 +34,6 @@
   return UnaryModel::newModelContext(this, portValueList);
 }
 
-bool
-Bias::alloc(LeafContext& context) const
-{
-  // FIXME: check that the mBias matches the size of the ports.
-  if (!UnaryModel::alloc(context))
-    return false;
-  return true;
-}
-
 void
 Bias::output(const Matrix& inputValue, Matrix& outputValue) const
 {

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Bias.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Bias.h	2008-11-18 17:31:42 UTC (rev 747)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Bias.h	2008-11-18 17:46:33 UTC (rev 748)
@@ -19,7 +19,6 @@
 
   ModelContext* newModelContext(PortValueList&) const;
 
-  bool alloc(LeafContext& context) const;
   void output(const Matrix& inputValue, Matrix& outputValue) const;
 
   const Matrix& getBias(void) const;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/PortValueList.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/PortValueList.h	2008-11-18 17:31:42 UTC (rev 747)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/PortValueList.h	2008-11-18 17:46:33 UTC (rev 748)
@@ -71,20 +71,8 @@
       mPortValueVector.resize(idx+1);
     mPortValueVector[idx] = portValue;
   }
-  bool setOrCheckPortSize(const MatrixOutputPort& port, const Size& sz)
+  bool setOrCheckPortSize(const NumericPortInfo* portInfo, const Size& sz)
   {
-    Size oldSize = size(port.getPortValue(mPortValueVector)->getValue());
-    // If the size is still 0x0, just set to the desired size
-    if (oldSize(0) == 0 || oldSize(1) == 0) {
-      port.getPortValue(mPortValueVector)->getValue().resize(sz(0), sz(1));
-      return true;
-    } else if (oldSize == sz)
-      return true;
-    else
-      return false;
-  }
-  bool setOrCheckPortSize(const OutputPortInfo* portInfo, const Size& sz)
-  {
     if (!portInfo)
       return false;
     Size oldSize = size(getPortValue(portInfo)->getValue());
@@ -97,7 +85,7 @@
     else
       return false;
   }
-  bool setOrCheckPortSize(const MatrixInputPort& port, const Size& sz)
+  bool setOrCheckPortSize(const MatrixOutputPort& port, const Size& sz)
   {
     Size oldSize = size(port.getPortValue(mPortValueVector)->getValue());
     // If the size is still 0x0, just set to the desired size
@@ -109,14 +97,12 @@
     else
       return false;
   }
-  bool setOrCheckPortSize(const InputPortInfo* portInfo, const Size& sz)
+  bool setOrCheckPortSize(const MatrixInputPort& port, const Size& sz)
   {
-    if (!portInfo)
-      return false;
-    Size oldSize = size(getPortValue(portInfo)->getValue());
+    Size oldSize = size(port.getPortValue(mPortValueVector)->getValue());
     // If the size is still 0x0, just set to the desired size
     if (oldSize(0) == 0 || oldSize(1) == 0) {
-      getPortValue(portInfo)->getValue().resize(sz(0), sz(1));
+      port.getPortValue(mPortValueVector)->getValue().resize(sz(0), sz(1));
       return true;
     } else if (oldSize == sz)
       return true;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/UnaryModel.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/UnaryModel.cpp	2008-11-18 17:31:42 UTC (rev 747)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/UnaryModel.cpp	2008-11-18 17:46:33 UTC (rev 748)
@@ -22,20 +22,4 @@
 {
 }
 
-bool
-UnaryModel::alloc(LeafContext& leafContext) const
-{
-  Size sz;
-  sz = size(leafContext.getPortValue(*mInputPort)->getValue());
-  Log(Initialization, Debug)
-    << "Size for Gain is detemined by the input port with size: "
-    << trans(sz) << std::endl;
-  if (!leafContext.getPortValueList().setOrCheckPortSize(mOutputPort, sz)) {
-    Log(Initialization, Error)
-      << "Size for output port does not match!" << std::endl;
-    return false;
-  }
-  return true;
-}
-
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/UnaryModel.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/UnaryModel.h	2008-11-18 17:31:42 UTC (rev 747)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/UnaryModel.h	2008-11-18 17:46:33 UTC (rev 748)
@@ -18,12 +18,23 @@
   UnaryModel(const std::string& name);
   virtual ~UnaryModel();
 
-  virtual bool alloc(LeafContext& leafContext) const;
-
 protected:
   template<typename UM>
   ModelContext* newModelContext(UM* um, PortValueList& portValueList) const
   {
+    Size sz;
+    sz = size(portValueList.getPortValue(mInputPort)->getValue());
+    Log(Initialization, Debug)
+      << "Size for Model \"" << getName()
+      << "\" is detemined by the input port with size: "
+      << trans(sz) << std::endl;
+    if (!portValueList.setOrCheckPortSize(mOutputPort, sz)) {
+      Log(Initialization, Error)
+        << "Size for output port from Model \"" << getName()
+        << "\" does not match!" << std::endl;
+      return 0;
+    }
+
     SharedPtr<Context<UM> > context;
     context = new Context<UM>(um, portValueList.getPortValue(mInputPort),
                               portValueList.getPortValue(mOutputPort));
@@ -37,7 +48,7 @@
       }
       context->setPortValue(*getPort(i), portValue);
     }
-    if (!context->alloc()) {
+    if (!context->allocStates()) {
       Log(Model, Warning) << "Could not alloc for model \""
                           << getName() << "\"" << endl;
       return false;
@@ -60,12 +71,6 @@
     virtual const UM& getNode() const
     { return *mUnaryModel; }
     
-    bool alloc()
-    {
-      if (!allocStates())
-        return false;
-      return mUnaryModel->alloc(*this);
-    }
     virtual void initOutput(const /*Init*/Task&)
     { mUnaryModel->output(mInputValue->getValue(), mOutputValue->getValue()); }
     virtual void output(const Task&)



From frohlich at mail.berlios.de  Tue Nov 18 18:51:31 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Tue, 18 Nov 2008 18:51:31 +0100
Subject: [OpenFDM-svn] r749 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811181751.mAIHpVtZ025810@sheep.berlios.de>

Author: frohlich
Date: 2008-11-18 18:51:30 +0100 (Tue, 18 Nov 2008)
New Revision: 749

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/UnaryModel.h
Log:
Fix some return values.

M    UnaryModel.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/UnaryModel.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/UnaryModel.h	2008-11-18 17:46:33 UTC (rev 748)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/UnaryModel.h	2008-11-18 17:51:30 UTC (rev 749)
@@ -22,14 +22,13 @@
   template<typename UM>
   ModelContext* newModelContext(UM* um, PortValueList& portValueList) const
   {
-    Size sz;
-    sz = size(portValueList.getPortValue(mInputPort)->getValue());
+    Size sz = size(portValueList.getPortValue(mInputPort)->getValue());
     Log(Initialization, Debug)
       << "Size for Model \"" << getName()
       << "\" is detemined by the input port with size: "
       << trans(sz) << std::endl;
     if (!portValueList.setOrCheckPortSize(mOutputPort, sz)) {
-      Log(Initialization, Error)
+      Log(Initialization, Warning)
         << "Size for output port from Model \"" << getName()
         << "\" does not match!" << std::endl;
       return 0;
@@ -44,14 +43,14 @@
         Log(Model, Error) << "No port value given for model \"" << getName()
                           << "\" and port \"" << getPort(i)->getName()
                           << "\"" << endl;
-        return false;
+        return 0;
       }
       context->setPortValue(*getPort(i), portValue);
     }
     if (!context->allocStates()) {
       Log(Model, Warning) << "Could not alloc for model \""
                           << getName() << "\"" << endl;
-      return false;
+      return 0;
     }
     return context.release();
   }



From frohlich at mail.berlios.de  Tue Nov 18 20:02:08 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Tue, 18 Nov 2008 20:02:08 +0100
Subject: [OpenFDM-svn] r750 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811181902.mAIJ28Rw003537@sheep.berlios.de>

Author: frohlich
Date: 2008-11-18 20:02:05 +0100 (Tue, 18 Nov 2008)
New Revision: 750

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeContext.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeContext.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeInstance.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeInstance.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/DiscreteIntegrator.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/DiscreteIntegrator.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJoint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Integrator.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Integrator.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJoint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Model.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Output.cpp
Log:
Context and port value cleanup.

M    src/OpenFDM/DiscreteIntegrator.h
M    src/OpenFDM/MobileRootJoint.cpp
M    src/OpenFDM/Integrator.h
M    src/OpenFDM/Model.h
M    src/OpenFDM/AbstractNodeInstance.cpp
M    src/OpenFDM/Output.cpp
M    src/OpenFDM/AbstractNodeContext.cpp
M    src/OpenFDM/Delay.h
M    src/OpenFDM/Integrator.cpp
M    src/OpenFDM/FixedRootJoint.cpp
M    src/OpenFDM/DiscreteIntegrator.cpp
M    src/OpenFDM/AbstractNodeInstance.h
M    src/OpenFDM/Delay.cpp
M    src/OpenFDM/AbstractNodeContext.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeContext.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeContext.cpp	2008-11-18 17:51:30 UTC (rev 749)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeContext.cpp	2008-11-18 19:02:05 UTC (rev 750)
@@ -20,18 +20,6 @@
   return mPortValueList.getPortValue(portInfo);
 }
 
-const NumericPortValue*
-AbstractNodeContext::getPortValue(const NumericPortInfo& portInfo) const
-{
-  return mPortValueList.getPortValue(portInfo);
-}
-
-const MechanicLinkValue*
-AbstractNodeContext::getPortValue(const MechanicLinkInfo& portInfo) const
-{
-  return mPortValueList.getPortValue(portInfo);
-}
-
 void
 AbstractNodeContext::setPortValue(const PortInfo& portInfo,
                                   PortValue* portValue)

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeContext.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeContext.h	2008-11-18 17:51:30 UTC (rev 749)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeContext.h	2008-11-18 19:02:05 UTC (rev 750)
@@ -20,14 +20,11 @@
 
   /// Port value accessors for System external usage.
   virtual const PortValue* getPortValue(const PortInfo&) const;
-  virtual const NumericPortValue* getPortValue(const NumericPortInfo&) const;
-  virtual const MechanicLinkValue* getPortValue(const MechanicLinkInfo&) const;
 
   /// Set port value for the given port.
   virtual void setPortValue(const PortInfo&, PortValue*);
 
 protected:
-  // PortValues
   PortValueList mPortValueList;
 };
 

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeInstance.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeInstance.cpp	2008-11-18 17:51:30 UTC (rev 749)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeInstance.cpp	2008-11-18 19:02:05 UTC (rev 750)
@@ -20,4 +20,24 @@
 {
 }
 
+const NumericPortValue*
+AbstractNodeInstance::getPortValue(const NumericPortInfo& portInfo) const
+{
+  const PortValue* portValue;
+  portValue = getPortValue(static_cast<const PortInfo&>(portInfo));
+  if (!portValue)
+    return 0;
+  return portValue->toNumericPortValue();
+}
+
+const MechanicLinkValue*
+AbstractNodeInstance::getPortValue(const MechanicLinkInfo& portInfo) const
+{
+  const PortValue* portValue;
+  portValue = getPortValue(static_cast<const PortInfo&>(portInfo));
+  if (!portValue)
+    return 0;
+  return portValue->toMechanicLinkValue();
+}
+
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeInstance.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeInstance.h	2008-11-18 17:51:30 UTC (rev 749)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeInstance.h	2008-11-18 19:02:05 UTC (rev 750)
@@ -33,12 +33,9 @@
   { return mSampleTime; }
 
   /// Access port values by the PortInfo values
-  virtual const PortValue*
-  getPortValue(const PortInfo& portInfo) const = 0;
-  virtual const NumericPortValue*
-  getPortValue(const NumericPortInfo& portInfo) const = 0;
-  virtual const MechanicLinkValue*
-  getPortValue(const MechanicLinkInfo& portInfo) const = 0;
+  virtual const PortValue* getPortValue(const PortInfo&) const = 0;
+  const NumericPortValue* getPortValue(const NumericPortInfo&) const;
+  const MechanicLinkValue* getPortValue(const MechanicLinkInfo&) const;
 
 private:
   AbstractNodeInstance(const AbstractNodeInstance&);
@@ -61,15 +58,8 @@
   { return mNodeContext->getNode(); }
 
   /// Access port values by the PortInfo values
-  virtual const PortValue*
-  getPortValue(const PortInfo& portInfo) const
+  virtual const PortValue* getPortValue(const PortInfo& portInfo) const
   { return mNodeContext->getPortValue(portInfo); }
-  virtual const NumericPortValue*
-  getPortValue(const NumericPortInfo& portInfo) const
-  { return mNodeContext->getPortValue(portInfo); }
-  virtual const MechanicLinkValue*
-  getPortValue(const MechanicLinkInfo& portInfo) const
-  { return mNodeContext->getPortValue(portInfo); }
 
 private:
   LeafInstance(const LeafInstance&);

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.cpp	2008-11-18 17:51:30 UTC (rev 749)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.cpp	2008-11-18 19:02:05 UTC (rev 750)
@@ -9,8 +9,8 @@
 
 #include "Assert.h"
 #include "Object.h"
-#include "LeafContext.h"
 #include "Model.h"
+#include "ModelContext.h"
 #include "Vector.h"
 
 namespace OpenFDM {
@@ -35,7 +35,7 @@
 }
 
 bool
-Delay::alloc(LeafContext& context) const
+Delay::alloc(ModelContext& context) const
 {
   Size sz = size(mInitialValue);
   Log(Initialization, Debug)

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.h	2008-11-18 17:51:30 UTC (rev 749)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.h	2008-11-18 19:02:05 UTC (rev 750)
@@ -18,7 +18,7 @@
   Delay(const std::string& name);
   virtual ~Delay();
 
-  virtual bool alloc(LeafContext& leafContext) const;
+  virtual bool alloc(ModelContext&) const;
   virtual void init(const Task&,DiscreteStateValueVector& discreteState,
                     ContinousStateValueVector&, const PortValueList&) const;
   virtual void output(const Task&,const DiscreteStateValueVector& discreteState,

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/DiscreteIntegrator.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/DiscreteIntegrator.cpp	2008-11-18 17:51:30 UTC (rev 749)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/DiscreteIntegrator.cpp	2008-11-18 19:02:05 UTC (rev 750)
@@ -4,8 +4,8 @@
 
 #include "DiscreteIntegrator.h"
 #include "Assert.h"
-#include "LeafContext.h"
 #include "Task.h"
+#include "ModelContext.h"
 
 namespace OpenFDM {
 
@@ -30,7 +30,7 @@
 }
 
 bool
-DiscreteIntegrator::alloc(LeafContext& leafContext) const
+DiscreteIntegrator::alloc(ModelContext& leafContext) const
 {
   Size sz;
   if (getEnableInitialValuePort()) {

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/DiscreteIntegrator.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/DiscreteIntegrator.h	2008-11-18 17:51:30 UTC (rev 749)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/DiscreteIntegrator.h	2008-11-18 19:02:05 UTC (rev 750)
@@ -17,7 +17,7 @@
   DiscreteIntegrator(const std::string& name);
   virtual ~DiscreteIntegrator(void);
 
-  virtual bool alloc(LeafContext& leafContext) const;
+  virtual bool alloc(ModelContext&) const;
   virtual void init(const Task&,DiscreteStateValueVector& discreteState,
                     ContinousStateValueVector&, const PortValueList&) const;
   virtual void output(const Task&,const DiscreteStateValueVector& discreteState,

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJoint.cpp	2008-11-18 17:51:30 UTC (rev 749)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJoint.cpp	2008-11-18 19:02:05 UTC (rev 750)
@@ -5,7 +5,6 @@
 #include "FixedRootJoint.h"
 
 #include "Assert.h"
-#include "LeafContext.h"
 #include "LogStream.h"
 #include "Object.h"
 #include "Vector.h"

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Integrator.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Integrator.cpp	2008-11-18 17:51:30 UTC (rev 749)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Integrator.cpp	2008-11-18 19:02:05 UTC (rev 750)
@@ -5,7 +5,7 @@
 #include "Integrator.h"
 
 #include "Assert.h"
-#include "LeafContext.h"
+#include "ModelContext.h"
 
 namespace OpenFDM {
 
@@ -29,7 +29,7 @@
 }
 
 bool
-Integrator::alloc(LeafContext& leafContext) const
+Integrator::alloc(ModelContext& leafContext) const
 {
   Size sz;
   if (getEnableInitialValuePort()) {

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Integrator.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Integrator.h	2008-11-18 17:51:30 UTC (rev 749)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Integrator.h	2008-11-18 19:02:05 UTC (rev 750)
@@ -17,7 +17,7 @@
   Integrator(const std::string& name);
   virtual ~Integrator(void);
 
-  virtual bool alloc(LeafContext& leafContext) const;
+  virtual bool alloc(ModelContext&) const;
   virtual void init(const Task&, DiscreteStateValueVector& discreteState,
                     ContinousStateValueVector& continousState,
                     const PortValueList& portValueList) const;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJoint.cpp	2008-11-18 17:51:30 UTC (rev 749)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJoint.cpp	2008-11-18 19:02:05 UTC (rev 750)
@@ -5,7 +5,6 @@
 #include "MobileRootJoint.h"
 
 #include "Assert.h"
-#include "LeafContext.h"
 #include "LogStream.h"
 #include "Object.h"
 #include "Vector.h"

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Model.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Model.h	2008-11-18 17:51:30 UTC (rev 749)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Model.h	2008-11-18 19:02:05 UTC (rev 750)
@@ -38,7 +38,7 @@
   // argument? May be it is sufficient to have a const and non const version??
   // FIXME???
   // const TaskInfo& taskInfo
-  virtual bool alloc(LeafContext&) const // = 0;
+  virtual bool alloc(ModelContext&) const // = 0;
   { return true; }
 
   virtual void init(const Task&,DiscreteStateValueVector&,

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Output.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Output.cpp	2008-11-18 17:51:30 UTC (rev 749)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Output.cpp	2008-11-18 19:02:05 UTC (rev 750)
@@ -3,9 +3,10 @@
  */
 
 #include "Output.h"
+
 #include "ConstNodeVisitor.h"
-#include "LeafContext.h"
 #include "NodeVisitor.h"
+#include "PortValueList.h"
 
 namespace OpenFDM {
 



From frohlich at mail.berlios.de  Tue Nov 18 20:06:17 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Tue, 18 Nov 2008 20:06:17 +0100
Subject: [OpenFDM-svn] r751 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811181906.mAIJ6HrA003978@sheep.berlios.de>

Author: frohlich
Date: 2008-11-18 20:06:16 +0100 (Tue, 18 Nov 2008)
New Revision: 751

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.cpp
Log:
More alloc removal.

M    RootJoint.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.cpp	2008-11-18 19:02:05 UTC (rev 750)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.cpp	2008-11-18 19:06:16 UTC (rev 751)
@@ -18,9 +18,6 @@
   virtual const RootJoint& getNode() const
   { return *mRootJoint; }
   
-  bool alloc()
-  { return allocStates(); }
-
   virtual void initDesignPosition()
   {
     mRootJoint->initDesignPosition(mPortValueList);
@@ -88,7 +85,7 @@
     }
     context->setPortValue(*getPort(i), portValue);
   }
-  if (!context->alloc()) {
+  if (!context->allocStates()) {
     Log(Model, Warning) << "Could not alloc for model \""
                         << getName() << "\"" << endl;
     return false;



From frohlich at mail.berlios.de  Tue Nov 18 20:10:19 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Tue, 18 Nov 2008 20:10:19 +0100
Subject: [OpenFDM-svn] r752 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811181910.mAIJAJ90004652@sheep.berlios.de>

Author: frohlich
Date: 2008-11-18 20:10:19 +0100 (Tue, 18 Nov 2008)
New Revision: 752

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/LeafContext.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/ModelContext.h
Log:
Move port value list accessor into the model context.

M    src/OpenFDM/LeafContext.h
M    src/OpenFDM/ModelContext.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/LeafContext.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/LeafContext.h	2008-11-18 19:06:16 UTC (rev 751)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/LeafContext.h	2008-11-18 19:10:19 UTC (rev 752)
@@ -43,12 +43,6 @@
     return true;
   }
 
-  /// might vanish???
-  PortValueList& getPortValueList()
-  { return mPortValueList; }
-  const PortValueList& getPortValueList() const
-  { return mPortValueList; }
-
 // protected:
   // Continous States
   ContinousStateValueVector mContinousState;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/ModelContext.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ModelContext.h	2008-11-18 19:06:16 UTC (rev 751)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ModelContext.h	2008-11-18 19:10:19 UTC (rev 752)
@@ -30,6 +30,10 @@
   virtual void update(const DiscreteTask& discreteTask) = 0;
   virtual void derivative(const Task&) = 0;
 
+  /// might vanish???
+  PortValueList& getPortValueList()
+  { return mPortValueList; }
+
 private:
   ModelContext(const ModelContext&);
   ModelContext& operator=(const ModelContext&);



From frohlich at mail.berlios.de  Tue Nov 18 20:34:47 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Tue, 18 Nov 2008 20:34:47 +0100
Subject: [OpenFDM-svn] r753 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811181934.mAIJYlPo007364@sheep.berlios.de>

Author: frohlich
Date: 2008-11-18 20:34:46 +0100 (Tue, 18 Nov 2008)
New Revision: 753

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Task.h
Log:
Avoid a const_cast

M    Task.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Task.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Task.h	2008-11-18 19:10:19 UTC (rev 752)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Task.h	2008-11-18 19:34:46 UTC (rev 753)
@@ -173,8 +173,8 @@
   {
     unsigned numContStates = leafContext.getNode().getNumContinousStateValues();
     for (unsigned k = 0; k < numContStates; ++k) {
-      ContinousStateInfo* continousStateInfo;
-      continousStateInfo = const_cast<ContinousStateInfo*>(leafContext.getNode().getContinousStateInfo(k));
+      const ContinousStateInfo* continousStateInfo;
+      continousStateInfo = leafContext.getNode().getContinousStateInfo(k);
       mStateValues.push_back(leafContext.mContinousState.getValue(*continousStateInfo));
       mDerivativeValues.push_back(leafContext.mContinousStateDerivative.getValue(*continousStateInfo));
     }



From frohlich at mail.berlios.de  Tue Nov 18 20:50:04 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Tue, 18 Nov 2008 20:50:04 +0100
Subject: [OpenFDM-svn] r754 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811181950.mAIJo4rW009211@sheep.berlios.de>

Author: frohlich
Date: 2008-11-18 20:50:03 +0100 (Tue, 18 Nov 2008)
New Revision: 754

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/DiscreteIntegrator.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/LeafContext.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Task.h
Log:
Move state value handling behind interface functions.

M    src/OpenFDM/Task.h
M    src/OpenFDM/LeafContext.h
M    src/OpenFDM/DiscreteIntegrator.cpp
M    src/OpenFDM/Delay.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.cpp	2008-11-18 19:34:46 UTC (rev 753)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.cpp	2008-11-18 19:50:03 UTC (rev 754)
@@ -51,7 +51,6 @@
       << "Size for output port does not match!" << std::endl;
     return false;
   }
-  context.mDiscreteState.setValue(*mMatrixStateInfo, context);
   return true;
 }
 

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/DiscreteIntegrator.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/DiscreteIntegrator.cpp	2008-11-18 19:34:46 UTC (rev 753)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/DiscreteIntegrator.cpp	2008-11-18 19:50:03 UTC (rev 754)
@@ -54,7 +54,6 @@
       << "Size for input port does not match!" << std::endl;
     return false;
   }
-  leafContext.mDiscreteState.setValue(*mMatrixStateInfo, leafContext);
   return true;
 }
 

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/LeafContext.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/LeafContext.h	2008-11-18 19:34:46 UTC (rev 753)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/LeafContext.h	2008-11-18 19:50:03 UTC (rev 754)
@@ -43,7 +43,12 @@
     return true;
   }
 
-// protected:
+  virtual ContinousStateValue* getStateValue(const ContinousStateInfo& info)
+  { return mContinousState.getValue(info); }
+  virtual ContinousStateValue* getStateDerivative(const ContinousStateInfo& info)
+  { return mContinousStateDerivative.getValue(info); }
+  
+protected:
   // Continous States
   ContinousStateValueVector mContinousState;
   ContinousStateValueVector mContinousStateDerivative;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Task.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Task.h	2008-11-18 19:34:46 UTC (rev 753)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Task.h	2008-11-18 19:50:03 UTC (rev 754)
@@ -173,10 +173,10 @@
   {
     unsigned numContStates = leafContext.getNode().getNumContinousStateValues();
     for (unsigned k = 0; k < numContStates; ++k) {
-      const ContinousStateInfo* continousStateInfo;
-      continousStateInfo = leafContext.getNode().getContinousStateInfo(k);
-      mStateValues.push_back(leafContext.mContinousState.getValue(*continousStateInfo));
-      mDerivativeValues.push_back(leafContext.mContinousStateDerivative.getValue(*continousStateInfo));
+      const ContinousStateInfo* stateInfo;
+      stateInfo = leafContext.getNode().getContinousStateInfo(k);
+      mStateValues.push_back(leafContext.getStateValue(*stateInfo));
+      mDerivativeValues.push_back(leafContext.getStateDerivative(*stateInfo));
     }
   }
 



From frohlich at mail.berlios.de  Wed Nov 19 18:52:34 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Wed, 19 Nov 2008 18:52:34 +0100
Subject: [OpenFDM-svn] r755 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811191752.mAJHqYtU026151@sheep.berlios.de>

Author: frohlich
Date: 2008-11-19 18:52:32 +0100 (Wed, 19 Nov 2008)
New Revision: 755

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Bias.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Bias.h
Log:
Make Bias model nicer

M    Bias.cpp
M    Bias.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Bias.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Bias.cpp	2008-11-18 19:50:03 UTC (rev 754)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Bias.cpp	2008-11-19 17:52:32 UTC (rev 755)
@@ -18,10 +18,10 @@
   DEF_OPENFDM_PROPERTY(Matrix, Bias, Serialized)
   END_OPENFDM_OBJECT_DEF
 
-Bias::Bias(const std::string& name) :
-  UnaryModel(name),
-  mBias(Matrix::zeros(1, 1))
+Bias::Bias(const std::string& name, const real_type& bias) :
+  UnaryModel(name)
 {
+  setBias(bias);
 }
 
 Bias::~Bias(void)
@@ -52,4 +52,11 @@
   mBias = bias;
 }
 
+void
+Bias::setBias(const real_type& bias)
+{
+  mBias.resize(1, 1);
+  mBias(0, 0) = bias;
+}
+
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Bias.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Bias.h	2008-11-18 19:50:03 UTC (rev 754)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Bias.h	2008-11-19 17:52:32 UTC (rev 755)
@@ -14,15 +14,15 @@
 class Bias : public UnaryModel {
   OPENFDM_OBJECT(Bias, UnaryModel);
 public:
-  Bias(const std::string& name);
+  Bias(const std::string& name, const real_type& bias = real_type(0));
   virtual ~Bias(void);
 
   ModelContext* newModelContext(PortValueList&) const;
-
   void output(const Matrix& inputValue, Matrix& outputValue) const;
 
   const Matrix& getBias(void) const;
   void setBias(const Matrix& bias);
+  void setBias(const real_type& bias);
 
 private:
   Matrix mBias;



From frohlich at mail.berlios.de  Wed Nov 19 18:53:23 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Wed, 19 Nov 2008 18:53:23 +0100
Subject: [OpenFDM-svn] r756 - in branches/OpenFDM-StateSeparation/src:
	JSBSim OpenFDM
Message-ID: <200811191753.mAJHrNH2027393@sheep.berlios.de>

Author: frohlich
Date: 2008-11-19 18:53:21 +0100 (Wed, 19 Nov 2008)
New Revision: 756

Added:
   branches/OpenFDM-StateSeparation/src/OpenFDM/UnitConversion.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/UnitConversion.h
Modified:
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
   branches/OpenFDM-StateSeparation/src/OpenFDM/UnaryFunctionModel.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/UnaryFunctionModel.h
Log:
Again have UnitConversion

M    src/JSBSim/JSBSimReaderBase.cpp
M    src/JSBSim/JSBSimReader.cpp
M    src/OpenFDM/UnaryFunctionModel.h
M    src/OpenFDM/Makefile.am
A    src/OpenFDM/UnitConversion.h
M    src/OpenFDM/UnaryFunctionModel.cpp
A    src/OpenFDM/UnitConversion.cpp


Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp	2008-11-19 17:52:32 UTC (rev 755)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp	2008-11-19 17:53:21 UTC (rev 756)
@@ -657,10 +657,10 @@
           addOutputModel(port, "Gear " + numStr + " Steering Output",
                          "gear/gear[" + numStr + "]/steering-norm");
 
-          UnitConversionModel* unitConv
-            = new UnitConversionModel(name + " Degree Conversion",
-                                      UnitConversionModel::UnitToSi,
-                                      Unit::degree());
+          UnitConversion* unitConv
+            = new UnitConversion(name + " Degree Conversion",
+                                 UnitConversion::UnitToBaseUnit,
+                                 Unit::degree());
           addFCSModel(unitConv);
           Connection::connect(gain->getOutputPort(0),
                               unitConv->getInputPort(0));

Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.cpp	2008-11-19 17:52:32 UTC (rev 755)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.cpp	2008-11-19 17:53:21 UTC (rev 756)
@@ -757,8 +757,8 @@
     std::cerr << "Could not add inverter model \"" << name << "\"" << std::endl;
     return 0;
   }
-  UnitConversionModel* unitConv
-    = new UnitConversionModel(name, UnitConversionModel::SiToUnit, u);
+  UnitConversion* unitConv
+    = new UnitConversion(name, UnitConversion::BaseUnitToUnit, u);
   modelGroup->addModel(unitConv, true);
   if (Port::Success != Connection::connect(in, unitConv->getInputPort(0)))
     return 0;
@@ -773,8 +773,8 @@
     std::cerr << "Could not add inverter model \"" << name << "\"" << std::endl;
     return 0;
   }
-  UnitConversionModel* unitConv
-    = new UnitConversionModel(name, UnitConversionModel::UnitToSi, u);
+  UnitConversion* unitConv
+    = new UnitConversion(name, UnitConversion::UnitToBaseUnit, u);
   modelGroup->addModel(unitConv, true);
   if (Port::Success != Connection::connect(in, unitConv->getInputPort(0)))
     return 0;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-11-19 17:52:32 UTC (rev 755)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-11-19 17:53:21 UTC (rev 756)
@@ -231,6 +231,7 @@
   Turbulence.h \
   UnaryFunctionModel.h \
   UnaryModel.h \
+  UnitConversion.h \
   UniversalJoint.h \
   Vehicle.h \
   WheelContact.h \
@@ -260,6 +261,7 @@
   RotationalJoint.cpp \
   Sensor.cpp \
   UnaryModel.cpp \
+  UnitConversion.cpp \
   UniversalJoint.cpp
 
 #   AeroForce.cpp \

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/UnaryFunctionModel.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/UnaryFunctionModel.cpp	2008-11-19 17:52:32 UTC (rev 755)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/UnaryFunctionModel.cpp	2008-11-19 17:53:21 UTC (rev 756)
@@ -244,83 +244,4 @@
   return mType;
 }
 
-BEGIN_OPENFDM_OBJECT_DEF(UnitConversionModel, Model)
-  END_OPENFDM_OBJECT_DEF
-
-UnitConversionModel::UnitConversionModel(const std::string& name,
-                                         Type type, const Unit& unit) :
-  Model(name),
-  mType(type),
-  mUnit(unit)
-{
-  setDirectFeedThrough(true);
-
-  setNumInputPorts(1);
-  setInputPortName(0, "input");
-  
-  setNumOutputPorts(1);
-  setOutputPort(0, "output", this, &UnitConversionModel::getFunctionValue);
-}
-
-UnitConversionModel::~UnitConversionModel(void)
-{
-}
-
-bool
-UnitConversionModel::init(void)
-{
-  mInputPort = getInputPort(0)->toRealPortHandle();
-  if (!mInputPort.isConnected()) {
-    Log(Model, Error) << "Initialization of UnitConversion model \""
-                      << getName()
-                      << "\" failed: Input port \"" << getInputPortName(0)
-                      << "\" is not connected!" << endl;
-    return false;
-  }
-
-  return Model::init();
-}
-
-void
-UnitConversionModel::output(const TaskInfo&)
-{
-  OpenFDMAssert(mInputPort.isConnected());
-  real_type value = mInputPort.getRealValue();
-  if (mType == UnitToSi) {
-    mValue = mUnit.convertFrom(value);
-  } else {
-    mValue = mUnit.convertTo(value);
-  }
-}
-
-const real_type&
-UnitConversionModel::getFunctionValue(void) const
-{
-  return mValue;
-}
-
-void
-UnitConversionModel::setType(UnitConversionModel::Type type)
-{
-  mType = type;
-}
-
-UnitConversionModel::Type
-UnitConversionModel::getType(void) const
-{
-  return mType;
-}
-
-void
-UnitConversionModel::setUnit(const Unit& unit)
-{
-  mUnit = unit;
-}
-
-const Unit&
-UnitConversionModel::getUnit(void) const
-{
-  return mUnit;
-}
-
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/UnaryFunctionModel.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/UnaryFunctionModel.h	2008-11-19 17:52:32 UTC (rev 755)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/UnaryFunctionModel.h	2008-11-19 17:53:21 UTC (rev 756)
@@ -8,7 +8,6 @@
 #include <string>
 
 #include "Types.h"
-#include "Unit.h"
 #include "Model.h"
 
 namespace OpenFDM {
@@ -54,35 +53,6 @@
   real_type mFunctionValue;
 };
 
-class UnitConversionModel : public Model {
-  OPENFDM_OBJECT(UnitConversionModel, Model);
-public:
-  enum Type {
-    UnitToSi,
-    SiToUnit
-  };
-
-  UnitConversionModel(const std::string& name, Type type, const Unit& unit);
-  virtual ~UnitConversionModel(void);
-
-  virtual bool init(void);
-  virtual void output(const TaskInfo&);
-
-  const real_type& getFunctionValue(void) const;
-
-  void setType(Type type);
-  Type getType(void) const;
-
-  void setUnit(const Unit& unit);
-  const Unit& getUnit(void) const;
-
-private:
-  Type mType;
-  Unit mUnit;
-  real_type mValue;
-  RealPortHandle mInputPort;
-};
-
 } // namespace OpenFDM
 
 #endif

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/UnitConversion.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/UnitConversion.cpp	2008-11-19 17:52:32 UTC (rev 755)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/UnitConversion.cpp	2008-11-19 17:53:21 UTC (rev 756)
@@ -0,0 +1,64 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
+ *
+ */
+
+#include "UnitConversion.h"
+
+namespace OpenFDM {
+
+BEGIN_OPENFDM_OBJECT_DEF(UnitConversion, UnaryModel)
+  END_OPENFDM_OBJECT_DEF
+
+UnitConversion::UnitConversion(const std::string& name, const Type& type,
+                               const Unit& unit) :
+  UnaryModel(name),
+  mType(type),
+  mUnit(unit)
+{
+}
+
+UnitConversion::~UnitConversion(void)
+{
+}
+
+ModelContext*
+UnitConversion::newModelContext(PortValueList& portValueList) const
+{
+  return UnaryModel::newModelContext(this, portValueList);
+}
+
+void
+UnitConversion::output(const Matrix& inputValue, Matrix& outputValue) const
+{
+  if (mType == UnitToBaseUnit) {
+    outputValue = mUnit.convertFrom(inputValue);
+  } else {
+    outputValue = mUnit.convertTo(inputValue);
+  }
+}
+
+void
+UnitConversion::setType(const UnitConversion::Type& type)
+{
+  mType = type;
+}
+
+const UnitConversion::Type&
+UnitConversion::getType(void) const
+{
+  return mType;
+}
+
+void
+UnitConversion::setUnit(const Unit& unit)
+{
+  mUnit = unit;
+}
+
+const Unit&
+UnitConversion::getUnit(void) const
+{
+  return mUnit;
+}
+
+} // namespace OpenFDM

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/UnitConversion.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/UnitConversion.h	2008-11-19 17:52:32 UTC (rev 755)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/UnitConversion.h	2008-11-19 17:53:21 UTC (rev 756)
@@ -0,0 +1,42 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_UnitConversion_H
+#define OpenFDM_UnitConversion_H
+
+#include <string>
+
+#include "Unit.h"
+#include "UnaryModel.h"
+
+namespace OpenFDM {
+
+class UnitConversion : public UnaryModel {
+  OPENFDM_OBJECT(UnitConversion, UnaryModel);
+public:
+  enum Type {
+    UnitToBaseUnit,
+    BaseUnitToUnit
+  };
+
+  UnitConversion(const std::string& name, const Type& type, const Unit& unit);
+  virtual ~UnitConversion(void);
+
+  ModelContext* newModelContext(PortValueList&) const;
+  void output(const Matrix& inputValue, Matrix& outputValue) const;
+
+  void setType(const Type& type);
+  const Type& getType(void) const;
+
+  void setUnit(const Unit& unit);
+  const Unit& getUnit(void) const;
+
+private:
+  Type mType;
+  Unit mUnit;
+};
+
+} // namespace OpenFDM
+
+#endif



From frohlich at mail.berlios.de  Wed Nov 19 19:01:57 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Wed, 19 Nov 2008 19:01:57 +0100
Subject: [OpenFDM-svn] r757 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811191801.mAJI1vjJ004177@sheep.berlios.de>

Author: frohlich
Date: 2008-11-19 19:01:54 +0100 (Wed, 19 Nov 2008)
New Revision: 757

Removed:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Vehicle.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Vehicle.h
Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
   branches/OpenFDM-StateSeparation/src/OpenFDM/ReaderWriter.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/ReaderWriter.h
Log:
Cleanup source files to convert to the current base implementation.

D    src/OpenFDM/Vehicle.h
M    src/OpenFDM/Makefile.am
M    src/OpenFDM/ReaderWriter.cpp
D    src/OpenFDM/Vehicle.cpp
M    src/OpenFDM/ReaderWriter.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-11-19 17:53:21 UTC (rev 756)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-11-19 18:01:54 UTC (rev 757)
@@ -178,7 +178,16 @@
 #   ReaderWriter.cpp \
 #
 
+#   Atmosphere.cpp \
+#   AtmosphereSTD1976.cpp \
+#   DefaultGravity.cpp \
+#   DefaultGround.cpp \
+#   DefaultPlanet.cpp \
+#   Gravity.cpp \
+#   Ground.cpp
 
+
+
 OpenFDMModelsHEADERS = \
   AeroForce.h \
   AirSpring.h \
@@ -233,7 +242,6 @@
   UnaryModel.h \
   UnitConversion.h \
   UniversalJoint.h \
-  Vehicle.h \
   WheelContact.h \
   Wind.h
 
@@ -250,6 +258,19 @@
   Saturation.cpp \
   SimulationTime.cpp
 
+#   AirSpring.cpp \
+#   BinaryFunctionModel.cpp \
+#   DiscBrake.cpp \
+#   LinearSpringDamper.cpp \
+#   MaxModel.cpp \
+#   MinModel.cpp \
+#   Product.cpp \
+#   Summer.cpp \
+#   Table.cpp \
+#   TimeDerivative.cpp \
+#   TransferFunction.cpp \
+#   UnaryFunctionModel.cpp
+
 OpenFDMMechanicSOURCES = \
   Joint.cpp \
   FixedRootJoint.cpp \
@@ -265,35 +286,16 @@
   UniversalJoint.cpp
 
 #   AeroForce.cpp \
-#   AirSpring.cpp \
-#   Atmosphere.cpp \
-#   AtmosphereSTD1976.cpp \
-#   BinaryFunctionModel.cpp \
 #   Contact.cpp \
-#   DefaultGravity.cpp \
-#   DefaultGround.cpp \
-#   DefaultPlanet.cpp \
-#   DiscBrake.cpp \
 #   ExternalForceModel.cpp \
 #   Force.cpp \
-#   Gravity.cpp \
-#   Ground.cpp \
 #   Launchbar.cpp \
-#   LinearSpringDamper.cpp \
-#   MaxModel.cpp \
-#   MinModel.cpp \
-#   Product.cpp \
 #   SimpleContact.cpp \
 #   SimpleGear.cpp \
-#   Summer.cpp \
-#   Table.cpp \
 #   Tailhook.cpp \
 #   Tank.cpp \
-#   TimeDerivative.cpp \
-#   TransferFunction.cpp \
-#   UnaryFunctionModel.cpp \
-#   Vehicle.cpp \
 #   WheelContact.cpp
 
+
 nobase_OpenFDMinclude_HEADERS = $(OpenFDMCoreHEADERS) $(OpenFDMModelsHEADERS)
 libOpenFDM_la_SOURCES = $(OpenFDMCoreSOURCES) $(OpenFDMModelsSOURCES) $(OpenFDMMechanicSOURCES)

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/ReaderWriter.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ReaderWriter.cpp	2008-11-19 17:53:21 UTC (rev 756)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ReaderWriter.cpp	2008-11-19 18:01:54 UTC (rev 757)
@@ -3,8 +3,6 @@
  */
 
 #include "ReaderWriter.h"
-#include "Vehicle.h"
-#include "Force.h"
 
 namespace OpenFDM {
 

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/ReaderWriter.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ReaderWriter.h	2008-11-19 17:53:21 UTC (rev 756)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ReaderWriter.h	2008-11-19 18:01:54 UTC (rev 757)
@@ -46,8 +46,8 @@
 
   /** Returns a pointer to the vehicle.
    */
-  Vehicle* getVehicle(void)
-  { return mVehicle; }
+//   Vehicle* getVehicle(void)
+//   { return mVehicle; }
   
 protected:
   /** Slot where a ReaderWriter implementation should reset it's state.
@@ -63,9 +63,9 @@
    */
   bool error(const std::string& message);
 
-  /** The Vehicle handle.
-   */
-  SharedPtr<Vehicle> mVehicle;
+//   /** The Vehicle handle.
+//    */
+//   SharedPtr<Vehicle> mVehicle;
 
 private:
   /** A list of errors during import.

Deleted: branches/OpenFDM-StateSeparation/src/OpenFDM/Vehicle.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Vehicle.cpp	2008-11-19 17:53:21 UTC (rev 756)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Vehicle.cpp	2008-11-19 18:01:54 UTC (rev 757)
@@ -1,177 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
- *
- */
-
-#include "Vehicle.h"
-
-#include "Assert.h"
-#include "Object.h"
-#include "Vector.h"
-#include "Quaternion.h"
-#include "Force.h"
-#include "RigidBody.h"
-#include "MobileRootJoint.h"
-#include "Planet.h"
-#include "Wind.h"
-#include "ExplicitEuler.h"
-#include "ExplicitAdams.h"
-#include "ImplicitEuler.h"
-#include "MidpointRule.h"
-#include "DoPri5.h"
-#include "ModelGroup.h"
-#include "System.h"
-
-namespace OpenFDM {
-
-Vehicle::Vehicle(void)
-{
-  mSystem = new System("Top Vehicle System");
-
-//   mSystem->setTimestepper(new ExplicitEuler);
-//   mSystem->setTimestepper(new ExplicitAdams);
-  mSystem->setTimestepper(new DoPri5);
-//   mSystem->setTimestepper(new ImplicitEuler);
-//   mSystem->setTimestepper(new MidpointRule);
-
-  mModelGroup = new ModelGroup("Flight Control System");
-  mSystem->addModel(mModelGroup);
-
-  mMultiBodySystem = new ModelGroup("Multi Body System");
-  mSystem->addModel(mMultiBodySystem);
-
-  mTopBody = new RigidBody("Topmost rigid body");
-  mMultiBodySystem->addModel(mTopBody);
-
-  mMobileRootJoint = new MobileRootJoint("Mobile vehicle base");
-  mMultiBodySystem->addModel(mMobileRootJoint);
-  mTopBody->setInboardJoint(mMobileRootJoint);
-}
-
-Vehicle::~Vehicle(void)
-{
-}
-
-bool
-Vehicle::init(void)
-{
-  return mSystem->init();
-}
-
-void
-Vehicle::output(void)
-{
-}
-
-void
-Vehicle::update(real_type dt)
-{
-  mSystem->simulate(mSystem->getTime() + dt);
-}
-
-bool
-Vehicle::trim(void)
-{
-  return mSystem->trim();
-}
-
-void
-Vehicle::setPlanet(Planet* p)
-{
-  mSystem->getEnvironment()->setPlanet(p);
-}
-
-void
-Vehicle::setGround(Ground* p)
-{
-  mSystem->getEnvironment()->setGround(p);
-}
-
-void
-Vehicle::setAtmosphere(Atmosphere* p)
-{
-  mSystem->getEnvironment()->setAtmosphere(p);
-}
-
-void
-Vehicle::setWind(Wind* w)
-{
-  mSystem->getEnvironment()->setWind(w);
-}
-
-Vector3
-Vehicle::getCartPosition(void) const
-{
-  return mTopBody->getFrame()->getRefPosition();/*FIXME*/
-}
-
-void
-Vehicle::setCartPosition(const Vector3& pos)
-{
-  mMobileRootJoint->setRefPosition(pos);/*FIXME*/
-}
-
-Geodetic
-Vehicle::getGeodPosition(void) const
-{
-  return getPlanet()->toGeod(getCartPosition());
-}
-
-void
-Vehicle::setGeodPosition(const Geodetic& geod)
-{
-  setCartPosition(getPlanet()->toCart(geod));
-}
-
-Geocentric
-Vehicle::getGeocPosition(void) const
-{
-  return getPlanet()->toGeoc(getCartPosition());
-}
-
-void
-Vehicle::setGeocPosition(const Geocentric& geoc)
-{
-  setCartPosition(getPlanet()->toCart(geoc));
-}
-
-Quaternion
-Vehicle::getCartOrientation(void) const
-{
-  return mTopBody->getFrame()->getRefOrientation();/*FIXME*/
-}
-
-void
-Vehicle::setCartOrientation(const Quaternion& o)
-{
-  mMobileRootJoint->setRefOrientation(o);/*FIXME*/
-}
-
-Quaternion
-Vehicle::getGeocOrientation(void) const
-{
-  Quaternion hlOr = getPlanet()->getGeocHLOrientation(getCartPosition());
-  return inverse(hlOr)*getCartOrientation();
-}
-
-void
-Vehicle::setGeocOrientation(const Quaternion& o)
-{
-  Quaternion hlOr = getPlanet()->getGeocHLOrientation(getCartPosition());
-  setCartOrientation(hlOr*o);
-}
-
-Quaternion
-Vehicle::getGeodOrientation(void) const
-{
-  Quaternion hlOr = getPlanet()->getGeodHLOrientation(getCartPosition()); 
-  return inverse(hlOr)*getCartOrientation();
-}
-
-void
-Vehicle::setGeodOrientation(const Quaternion& o)
-{
-  Quaternion hlOr = getPlanet()->getGeodHLOrientation(getCartPosition()); 
-  setCartOrientation(hlOr*o);
-}
-
-} // namespace OpenFDM

Deleted: branches/OpenFDM-StateSeparation/src/OpenFDM/Vehicle.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Vehicle.h	2008-11-19 17:53:21 UTC (rev 756)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Vehicle.h	2008-11-19 18:01:54 UTC (rev 757)
@@ -1,136 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
- *
- */
-
-#ifndef OpenFDM_Vehicle_H
-#define OpenFDM_Vehicle_H
-
-#include "Assert.h"
-#include "Object.h"
-#include "Vector.h"
-#include "Quaternion.h"
-#include "Force.h"
-#include "Frame.h"
-#include "MobileRootJoint.h"
-#include "RootFrame.h"
-#include "Planet.h"
-#include "ODESolver.h"
-#include "Environment.h"
-#include "ModelGroup.h"
-#include "System.h"
-
-namespace OpenFDM {
-
-class JSBReader;
-class System;
-
-/// FIXME: Derive that from System or something like that
-class Vehicle :
-    public Object {
-public:
-  Vehicle(void);
-  virtual ~Vehicle(void);
-
-  bool init(void);
-  void output(void); /// FIXME??
-  void update(real_type dt);
-
-  bool trim(void);
-
-  /** Set planet callback.
-   */
-  void setPlanet(Planet* p);
-
-  /** Get planet callback.
-   */
-  const Planet* getPlanet(void) const
-  { return mSystem->getEnvironment()->getPlanet(); }
-
-  /** Set ground callback.
-   */
-  void setGround(Ground* g);
-
-  /** Get ground callback.
-   */
-  const Ground* getGround(void) const
-  { return mSystem->getEnvironment()->getGround(); }
-
-  /** Set atmosphere callback.
-   */
-  void setAtmosphere(Atmosphere* g);
-
-  /** Get atmosphere callback.
-      FIXME ?? only callback??
-   */
-  const Atmosphere* getAtmosphere(void) const
-  { return mSystem->getEnvironment()->getAtmosphere(); }
-
-  /** Set wind callback.
-   */
-  void setWind(Wind* p);
-
-  /** Get wind callback.
-   */
-  const Wind* getWind(void) const
-  { return mSystem->getEnvironment()->getWind(); }
-
-  /** Get the vehicle base node.
-   */
-  const MobileRootJoint* getMobileRootJoint(void) const
-  { return mMobileRootJoint; }
-  MobileRootJoint* getMobileRootJoint(void)
-  { return mMobileRootJoint; }
-
-  const ModelGroup* getModelGroup(void) const
-  { return mModelGroup; }
-  ModelGroup* getModelGroup(void)
-  { return mModelGroup; }
-
-  Vector3 getCartPosition(void) const;
-  void setCartPosition(const Vector3& pos);
-  Geodetic getGeodPosition(void) const;
-  void setGeodPosition(const Geodetic& geod);
-  Geocentric getGeocPosition(void) const;
-  void setGeocPosition(const Geocentric& geoc);
-
-  Quaternion getCartOrientation(void) const;
-  void setCartOrientation(const Quaternion& o);
-  Quaternion getGeocOrientation(void) const;
-  void setGeocOrientation(const Quaternion& o);
-  Quaternion getGeodOrientation(void) const;
-  void setGeodOrientation(const Quaternion& o);
-
-  // FIXME
-  Vector6 getVelocity(void) const
-  { return mTopBody->getFrame()->getRelVel(); }
-  real_type getRadius(void) const
-  { return 15; }
-  real_type getTime(void) const
-  { return mSystem->getTime(); }
-  // FIXME:
-  const RigidBody* getTopBody(void) const
-  { return mTopBody; }
-  RigidBody* getTopBody(void)
-  { return mTopBody; }
-
-  const System* getSystem(void) const
-  { return mSystem; }
-  System* getSystem(void)
-  { return mSystem; }
-
-  ModelGroup* getMultiBodySystem(void)
-  { return mMultiBodySystem; }
-
-private:
-  SharedPtr<RigidBody> mTopBody;
-  SharedPtr<MobileRootJoint> mMobileRootJoint;
-  SharedPtr<ModelGroup> mMultiBodySystem;
-
-  SharedPtr<ModelGroup> mModelGroup;
-
-  SharedPtr<System> mSystem;
-};
-
-} // namespace OpenFDM
-
-#endif



From frohlich at mail.berlios.de  Wed Nov 19 19:57:17 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Wed, 19 Nov 2008 19:57:17 +0100
Subject: [OpenFDM-svn] r758 - in branches/OpenFDM-StateSeparation/src:
	JSBSim OpenFDM test
Message-ID: <200811191857.mAJIvHSM000343@sheep.berlios.de>

Author: frohlich
Date: 2008-11-19 19:57:16 +0100 (Wed, 19 Nov 2008)
New Revision: 758

Added:
   branches/OpenFDM-StateSeparation/src/OpenFDM/BinaryFunction.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/BinaryFunction.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/UnaryFunction.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/UnaryFunction.h
Removed:
   branches/OpenFDM-StateSeparation/src/OpenFDM/BinaryFunctionModel.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/BinaryFunctionModel.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/UnaryFunctionModel.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/UnaryFunctionModel.h
Modified:
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Integrator.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
   branches/OpenFDM-StateSeparation/src/test/harmonic.cpp
   branches/OpenFDM-StateSeparation/src/test/tiretestrig.cpp
Log:
More model rebuild work.

M    src/test/harmonic.cpp
M    src/test/tiretestrig.cpp
M    src/JSBSim/JSBSimReaderBase.cpp
M    src/JSBSim/JSBSimReader.cpp
D    src/OpenFDM/UnaryFunctionModel.h
A    src/OpenFDM/BinaryFunction.h
M    src/OpenFDM/Makefile.am
D    src/OpenFDM/UnaryFunctionModel.cpp
D    src/OpenFDM/BinaryFunctionModel.h
A    src/OpenFDM/UnaryFunction.h
D    src/OpenFDM/BinaryFunctionModel.cpp
M    src/OpenFDM/Integrator.cpp
A    src/OpenFDM/UnaryFunction.cpp
A    src/OpenFDM/BinaryFunction.cpp


Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp	2008-11-19 18:01:54 UTC (rev 757)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp	2008-11-19 18:57:16 UTC (rev 758)
@@ -40,7 +40,7 @@
 #include <OpenFDM/Table.h>
 #include <OpenFDM/Tailhook.h>
 #include <OpenFDM/TimeDerivative.h>
-#include <OpenFDM/UnaryFunctionModel.h>
+#include <OpenFDM/UnaryFunction.h>
 #include <OpenFDM/Unit.h>
 #include <OpenFDM/Vehicle.h>
 #include <OpenFDM/WheelContact.h>
@@ -632,8 +632,8 @@
 
         real_type maxSteer = realData((*it)->getElement("max_steer"), 0);
         if (maxSteer != 0) {
-          UnaryFunctionModel* scale
-            = new UnaryFunctionModel(name + " Scale", UnaryFunctionModel::Abs);
+          UnaryFunction* scale
+            = new UnaryFunction(name + " Scale", UnaryFunction::Abs);
           addFCSModel(scale);
           // FIXME: FCS might later define something for that gain ...
           // "fcs/steer-pos-deg[" + numStr + "]";
@@ -730,8 +730,8 @@
           sj->setPosition(parentPos);
           sj->setOrientation(Quaternion::unit());
           
-          UnaryFunctionModel* scale
-            = new UnaryFunctionModel(name + " Scale", UnaryFunctionModel::Abs);
+          UnaryFunction* scale
+            = new UnaryFunction(name + " Scale", UnaryFunction::Abs);
           addFCSModel(scale);
           if (!connectJSBExpression("fcs/steer-cmd-norm",
                                     scale->getInputPort(0)))

Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.cpp	2008-11-19 18:01:54 UTC (rev 757)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.cpp	2008-11-19 18:57:16 UTC (rev 758)
@@ -39,7 +39,7 @@
 #include <OpenFDM/Summer.h>
 #include <OpenFDM/Table.h>
 #include <OpenFDM/TimeDerivative.h>
-#include <OpenFDM/UnaryFunctionModel.h>
+#include <OpenFDM/UnaryFunction.h>
 #include <OpenFDM/Unit.h>
 #include <OpenFDM/Vehicle.h>
 #include <OpenFDM/WheelContact.h>
@@ -711,8 +711,8 @@
     std::cerr << "Could not add inverter model \"" << name << "\"" << std::endl;
     return 0;
   }
-  UnaryFunctionModel *unary
-    = new UnaryFunctionModel(name + " Inverter", UnaryFunctionModel::Minus);
+  UnaryFunction *unary
+    = new UnaryFunction(name + " Inverter", UnaryFunction::Minus);
   modelGroup->addModel(unary, true);
   if (Port::Success != Connection::connect(in, unary->getInputPort(0)))
     return 0;
@@ -727,8 +727,8 @@
     std::cerr << "Could not add inverter model \"" << name << "\"" << std::endl;
     return 0;
   }
-  UnaryFunctionModel *unary
-    = new UnaryFunctionModel(name + " Abs", UnaryFunctionModel::Abs);
+  UnaryFunction *unary
+    = new UnaryFunction(name + " Abs", UnaryFunction::Abs);
   modelGroup->addModel(unary, true);
   if (Port::Success != Connection::connect(in, unary->getInputPort(0)))
     return 0;

Copied: branches/OpenFDM-StateSeparation/src/OpenFDM/BinaryFunction.cpp (from rev 754, branches/OpenFDM-StateSeparation/src/OpenFDM/BinaryFunctionModel.cpp)
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/BinaryFunctionModel.cpp	2008-11-18 19:50:03 UTC (rev 754)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/BinaryFunction.cpp	2008-11-19 18:57:16 UTC (rev 758)
@@ -0,0 +1,88 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
+ *
+ */
+
+#include "BinaryFunction.h"
+
+#include "ModelContext.h"
+#include "PortValueList.h"
+
+namespace OpenFDM {
+
+BEGIN_OPENFDM_OBJECT_DEF(BinaryFunction, Model)
+  END_OPENFDM_OBJECT_DEF
+
+BinaryFunction::BinaryFunction(const std::string& name, Type type) :
+  Model(name),
+  mInput0Port(newMatrixInputPort("input0", true)),
+  mInput1Port(newMatrixInputPort("input1", true)),
+  mOutputPort(newMatrixOutputPort("output"))
+{
+}
+
+BinaryFunction::~BinaryFunction(void)
+{
+}
+
+bool
+BinaryFunction::alloc(ModelContext& context) const
+{
+  Size sz = size(context.getPortValueList()[mInput0Port]);
+  Log(Initialization, Debug)
+    << "Size for BinaryFunction is detemined by input0 "
+    << "port with size: " << trans(sz) << std::endl;
+  if (!context.getPortValueList().setOrCheckPortSize(mInput1Port, sz)) {
+    Log(Initialization, Error)
+      << "Size for input1 port does not match!" << std::endl;
+    return false;
+  }
+  if (!context.getPortValueList().setOrCheckPortSize(mOutputPort, sz)) {
+    Log(Initialization, Error)
+      << "Size for output port does not match!" << std::endl;
+    return false;
+  }
+  return true;
+}
+
+void
+BinaryFunction::output(const Task&,const DiscreteStateValueVector&,
+                       const ContinousStateValueVector&,
+                       PortValueList& portValues) const
+{
+  Size sz = size(portValues[mOutputPort]);
+  for (unsigned j = 0; j < sz(1); ++j) {
+    for (unsigned i = 0; i < sz(0); ++i) {
+      switch (mType) {
+      case Atan2:
+        portValues[mOutputPort](i, j) =
+          atan2(portValues[mInput0Port](i, j), portValues[mInput1Port](i, j));
+        break;
+      case Pow:
+        portValues[mOutputPort](i, j) =
+          pow(portValues[mInput0Port](i, j), portValues[mInput1Port](i, j));
+        break;
+      case Div:
+        portValues[mOutputPort](i, j) =
+          portValues[mInput0Port](i, j) / portValues[mInput1Port](i, j);
+        break;
+      default:
+        OpenFDMAssert(false);
+        break;
+      }
+    }
+  }
+}
+
+void
+BinaryFunction::setType(const BinaryFunction::Type& type)
+{
+  mType = type;
+}
+
+const BinaryFunction::Type&
+BinaryFunction::getType(void) const
+{
+  return mType;
+}
+
+} // namespace OpenFDM

Copied: branches/OpenFDM-StateSeparation/src/OpenFDM/BinaryFunction.h (from rev 754, branches/OpenFDM-StateSeparation/src/OpenFDM/BinaryFunctionModel.h)
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/BinaryFunctionModel.h	2008-11-18 19:50:03 UTC (rev 754)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/BinaryFunction.h	2008-11-19 18:57:16 UTC (rev 758)
@@ -0,0 +1,44 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_BinaryFunction_H
+#define OpenFDM_BinaryFunction_H
+
+#include <string>
+#include "Model.h"
+
+namespace OpenFDM {
+
+/// Class representing a model with exactly two inputs.
+class BinaryFunction : public Model {
+  OPENFDM_OBJECT(BinaryFunction, Model);
+public:
+  enum Type {
+    Atan2,
+    Pow,
+    Div
+  };
+
+  BinaryFunction(const std::string& name, Type type);
+  virtual ~BinaryFunction(void);
+
+  virtual bool alloc(ModelContext&) const;
+  virtual void output(const Task&, const DiscreteStateValueVector&,
+                      const ContinousStateValueVector&,
+                      PortValueList& portValues) const;
+
+  void setType(const Type& type);
+  const Type& getType(void) const;
+
+private:
+  MatrixInputPort mInput0Port;
+  MatrixInputPort mInput1Port;
+  MatrixOutputPort mOutputPort;
+  
+  Type mType;
+};
+
+} // namespace OpenFDM
+
+#endif

Deleted: branches/OpenFDM-StateSeparation/src/OpenFDM/BinaryFunctionModel.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/BinaryFunctionModel.cpp	2008-11-19 18:01:54 UTC (rev 757)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/BinaryFunctionModel.cpp	2008-11-19 18:57:16 UTC (rev 758)
@@ -1,137 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
- *
- */
-
-#include "BinaryFunctionModel.h"
-
-#include <string>
-#include "Types.h"
-
-namespace OpenFDM {
-
-class BinaryFunctionModelImpl :
-    public Referenced {
-public:
-  virtual ~BinaryFunctionModelImpl(void) {}
-  void setRealPortHandle(unsigned idx, const RealPortHandle& realPortHandle)
-  { mRealPortHandle[idx] = realPortHandle; }
-  virtual real_type getValue(void) = 0;
-protected:
-  RealPortHandle mRealPortHandle[2];
-};
-
-class Atan2BinaryFunctionModelImpl :
-    public BinaryFunctionModelImpl {
-private:
-  virtual real_type getValue(void)
-  { return atan2(mRealPortHandle[0].getRealValue(), mRealPortHandle[1].getRealValue()); }
-};
-
-class PowBinaryFunctionModelImpl :
-    public BinaryFunctionModelImpl {
-private:
-  virtual real_type getValue(void)
-  { return pow(mRealPortHandle[0].getRealValue(), mRealPortHandle[1].getRealValue()); }
-};
-
-class DivBinaryFunctionModelImpl :
-    public BinaryFunctionModelImpl {
-private:
-  virtual real_type getValue(void)
-  { return mRealPortHandle[0].getRealValue() / mRealPortHandle[1].getRealValue(); }
-};
-
-
-BEGIN_OPENFDM_OBJECT_DEF(BinaryFunctionModel, Model)
-  END_OPENFDM_OBJECT_DEF
-
-BinaryFunctionModel::BinaryFunctionModel(const std::string& name, Type type) :
-  Model(name)
-{
-  setType(type);
-
-  setDirectFeedThrough(true);
-
-  setNumInputPorts(2);
-  setInputPortName(0, "input 0");
-  setInputPortName(1, "input 1");
-  
-  setNumOutputPorts(1);
-  setOutputPort(0, "output", this, &BinaryFunctionModel::getFunctionValue);
-}
-
-BinaryFunctionModel::~BinaryFunctionModel(void)
-{
-}
-
-bool
-BinaryFunctionModel::init(void)
-{
-  if (!mImpl) {
-    Log(Model, Error) << "Initialization of BinaryFunctionModel model \""
-                      << getName() << "\" failed: No funcion given!" << endl;
-    return false;
-  }
-
-  RealPortHandle portHandle = getInputPort(0)->toRealPortHandle();
-  if (!portHandle.isConnected()) {
-    Log(Model, Error) << "Initialization of BinaryFunctionModel model \""
-                      << getName()
-                      << "\" failed: Input port \"" << getInputPortName(0)
-                      << "\" is not connected!" << endl;
-    return false;
-  }
-  mImpl->setRealPortHandle(0, portHandle);
-
-  portHandle = getInputPort(1)->toRealPortHandle();
-  if (!portHandle.isConnected()) {
-    Log(Model, Error) << "Initialization of BinaryFunctionModel model \""
-                      << getName()
-                      << "\" failed: Input port \"" << getInputPortName(1)
-                      << "\" is not connected!" << endl;
-    return false;
-  }
-  mImpl->setRealPortHandle(1, portHandle);
-
-  return Model::init();
-}
-
-void
-BinaryFunctionModel::output(const TaskInfo&)
-{
-  // Evaluate the expression.
-  mFunctionValue = mImpl->getValue();
-}
-
-const real_type&
-BinaryFunctionModel::getFunctionValue(void) const
-{
-  return mFunctionValue;
-}
-
-void
-BinaryFunctionModel::setType(BinaryFunctionModel::Type type)
-{
-  mType = type;
-  switch (type) {
-  case Atan2:
-    mImpl = new Atan2BinaryFunctionModelImpl;
-    break;
-  case Pow:
-    mImpl = new PowBinaryFunctionModelImpl;
-    break;
-  case Div:
-    mImpl = new DivBinaryFunctionModelImpl;
-    break;
-  default:
-    break;
-  }
-}
-
-BinaryFunctionModel::Type
-BinaryFunctionModel::getType(void) const
-{
-  return mType;
-}
-
-} // namespace OpenFDM

Deleted: branches/OpenFDM-StateSeparation/src/OpenFDM/BinaryFunctionModel.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/BinaryFunctionModel.h	2008-11-19 18:01:54 UTC (rev 757)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/BinaryFunctionModel.h	2008-11-19 18:57:16 UTC (rev 758)
@@ -1,46 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
- *
- */
-
-#ifndef OpenFDM_BinaryFunctionModel_H
-#define OpenFDM_BinaryFunctionModel_H
-
-#include <string>
-
-#include "Types.h"
-#include "Model.h"
-
-namespace OpenFDM {
-
-class BinaryFunctionModelImpl;
-
-/// Class representing a model with exactly two inputs.
-class BinaryFunctionModel : public Model {
-  OPENFDM_OBJECT(BinaryFunctionModel, Model);
-public:
-  enum Type {
-    Atan2,
-    Pow,
-    Div
-  };
-
-  BinaryFunctionModel(const std::string& name, Type type);
-  virtual ~BinaryFunctionModel(void);
-
-  virtual bool init(void);
-  virtual void output(const TaskInfo&);
-
-  const real_type& getFunctionValue(void) const;
-
-  void setType(Type type);
-  Type getType(void) const;
-
-private:
-  SharedPtr<BinaryFunctionModelImpl> mImpl;
-  Type mType;
-  real_type mFunctionValue;
-};
-
-} // namespace OpenFDM
-
-#endif

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Integrator.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Integrator.cpp	2008-11-19 18:01:54 UTC (rev 757)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Integrator.cpp	2008-11-19 18:57:16 UTC (rev 758)
@@ -29,11 +29,11 @@
 }
 
 bool
-Integrator::alloc(ModelContext& leafContext) const
+Integrator::alloc(ModelContext& context) const
 {
   Size sz;
   if (getEnableInitialValuePort()) {
-    sz = size(leafContext.getPortValueList()[mInitialValuePort]);
+    sz = size(context.getPortValueList()[mInitialValuePort]);
     Log(Initialization, Debug)
       << "Size for Integrator is detemined by the initial input "
       << "port with size: " << trans(sz) << std::endl;
@@ -43,22 +43,22 @@
       << "Size for Integrator is detemined by the static initial value "
       << "with size: " << trans(sz) << std::endl;
   }
-  if (!leafContext.getPortValueList().setOrCheckPortSize(mInputPort, sz)) {
+  if (!context.getPortValueList().setOrCheckPortSize(mInputPort, sz)) {
     Log(Initialization, Error)
       << "Size for input port does not match!" << std::endl;
     return false;
   }
-  if (!leafContext.getPortValueList().setOrCheckPortSize(mOutputPort, sz)) {
+  if (!context.getPortValueList().setOrCheckPortSize(mOutputPort, sz)) {
     Log(Initialization, Error)
       << "Size for input port does not match!" << std::endl;
     return false;
   }
-  leafContext.setContinousStateSize(*mMatrixStateInfo, sz);
+  context.setContinousStateSize(*mMatrixStateInfo, sz);
   return true;
 }
 
 void
-Integrator::init(const Task&, DiscreteStateValueVector& discreteState,
+Integrator::init(const Task&, DiscreteStateValueVector&,
                  ContinousStateValueVector& continousState,
                  const PortValueList& portValues) const
 {

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-11-19 18:01:54 UTC (rev 757)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-11-19 18:57:16 UTC (rev 758)
@@ -194,7 +194,7 @@
   Atmosphere.h \
   AtmosphereSTD1976.h \
   Bias.h \
-  BinaryFunctionModel.h \
+  BinaryFunction.h \
   CartesianJoint.h \
   ConstModel.h \
   Contact.h \
@@ -238,7 +238,7 @@
   TimeDerivative.h \
   TransferFunction.h \
   Turbulence.h \
-  UnaryFunctionModel.h \
+  UnaryFunction.h \
   UnaryModel.h \
   UnitConversion.h \
   UniversalJoint.h \
@@ -247,6 +247,7 @@
 
 OpenFDMModelsSOURCES = \
   Bias.cpp \
+  BinaryFunction.cpp \
   ConstModel.cpp \
   DeadBand.cpp \
   Delay.cpp \
@@ -256,10 +257,12 @@
   Integrator.cpp \
   Output.cpp \
   Saturation.cpp \
-  SimulationTime.cpp
+  SimulationTime.cpp \
+  UnaryFunction.cpp \
+  UnaryModel.cpp \
+  UnitConversion.cpp
 
 #   AirSpring.cpp \
-#   BinaryFunctionModel.cpp \
 #   DiscBrake.cpp \
 #   LinearSpringDamper.cpp \
 #   MaxModel.cpp \
@@ -269,7 +272,7 @@
 #   Table.cpp \
 #   TimeDerivative.cpp \
 #   TransferFunction.cpp \
-#   UnaryFunctionModel.cpp
+#
 
 OpenFDMMechanicSOURCES = \
   Joint.cpp \
@@ -281,8 +284,6 @@
   RevoluteJoint.cpp \
   RotationalJoint.cpp \
   Sensor.cpp \
-  UnaryModel.cpp \
-  UnitConversion.cpp \
   UniversalJoint.cpp
 
 #   AeroForce.cpp \

Copied: branches/OpenFDM-StateSeparation/src/OpenFDM/UnaryFunction.cpp (from rev 756, branches/OpenFDM-StateSeparation/src/OpenFDM/UnaryFunctionModel.cpp)
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/UnaryFunctionModel.cpp	2008-11-19 17:53:21 UTC (rev 756)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/UnaryFunction.cpp	2008-11-19 18:57:16 UTC (rev 758)
@@ -0,0 +1,104 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
+ *
+ */
+
+#include "UnaryFunction.h"
+
+#include <string>
+
+namespace OpenFDM {
+
+BEGIN_OPENFDM_OBJECT_DEF(UnaryFunction, UnaryModel)
+  END_OPENFDM_OBJECT_DEF
+
+UnaryFunction::UnaryFunction(const std::string& name, const Type& type) :
+  UnaryModel(name),
+  mType(type)
+{
+}
+
+UnaryFunction::~UnaryFunction(void)
+{
+}
+
+ModelContext*
+UnaryFunction::newModelContext(PortValueList& portValueList) const
+{
+  return UnaryModel::newModelContext(this, portValueList);
+}
+
+void
+UnaryFunction::output(const Matrix& inputValue, Matrix& outputValue) const
+{
+  // FIXME, optimize, move that into a proper context ...
+  // For now make it work
+  Size sz = size(inputValue);
+  for (unsigned j = 0; j < sz(1); ++j) {
+    for (unsigned i = 0; i < sz(0); ++i) {
+      switch (mType) {
+      case Abs:
+        outputValue(i, j) = fabs(inputValue(i, j));
+        break;
+      case Acos:
+        outputValue(i, j) = acos(inputValue(i, j));
+        break;
+      case Asin:
+        outputValue(i, j) = asin(inputValue(i, j));
+        break;
+      case Atan:
+        outputValue(i, j) = atan(inputValue(i, j));
+        break;
+      case Ceil:
+        outputValue(i, j) = ceil(inputValue(i, j));
+        break;
+      case Cos:
+        outputValue(i, j) = cos(inputValue(i, j));
+        break;
+      case Exp:
+        outputValue(i, j) = exp(inputValue(i, j));
+        break;
+      case Floor:
+        outputValue(i, j) = floor(inputValue(i, j));
+        break;
+      case Log:
+        outputValue(i, j) = log(inputValue(i, j));
+        break;
+      case Log10:
+        outputValue(i, j) = log10(inputValue(i, j));
+        break;
+      case Minus:
+        outputValue(i, j) = -inputValue(i, j);
+        break;
+      case Sin:
+        outputValue(i, j) = sin(inputValue(i, j));
+        break;
+      case Sqr:
+        outputValue(i, j) = inputValue(i, j)*inputValue(i, j);
+        break;
+      case Sqrt:
+        outputValue(i, j) = sqrt(inputValue(i, j));
+        break;
+      case Tan:
+        outputValue(i, j) = tan(inputValue(i, j));
+        break;
+      default:
+        outputValue(i, j) = inputValue(i, j);
+        break;
+      }
+    }
+  }
+}
+
+void
+UnaryFunction::setType(const UnaryFunction::Type& type)
+{
+  mType = type;
+}
+
+const UnaryFunction::Type&
+UnaryFunction::getType(void) const
+{
+  return mType;
+}
+
+} // namespace OpenFDM

Copied: branches/OpenFDM-StateSeparation/src/OpenFDM/UnaryFunction.h (from rev 756, branches/OpenFDM-StateSeparation/src/OpenFDM/UnaryFunctionModel.h)
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/UnaryFunctionModel.h	2008-11-19 17:53:21 UTC (rev 756)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/UnaryFunction.h	2008-11-19 18:57:16 UTC (rev 758)
@@ -0,0 +1,50 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_UnaryFunction_H
+#define OpenFDM_UnaryFunction_H
+
+#include <string>
+#include "UnaryModel.h"
+
+namespace OpenFDM {
+
+/// Class representing a model with exactly one input.
+class UnaryFunction : public UnaryModel {
+  OPENFDM_OBJECT(UnaryFunction, UnaryModel);
+public:
+  enum Type {
+    Abs,
+    Acos,
+    Asin,
+    Atan,
+    Ceil,
+    Cos,
+    Exp,
+    Floor,
+    Log,
+    Log10,
+    Minus,
+    Sin,
+    Sqr,
+    Sqrt,
+    Tan
+  };
+
+  UnaryFunction(const std::string& name, const Type& type);
+  virtual ~UnaryFunction(void);
+
+  ModelContext* newModelContext(PortValueList&) const;
+  void output(const Matrix& inputValue, Matrix& outputValue) const;
+
+  void setType(const Type& type);
+  const Type& getType(void) const;
+
+private:
+  Type mType;
+};
+
+} // namespace OpenFDM
+
+#endif

Deleted: branches/OpenFDM-StateSeparation/src/OpenFDM/UnaryFunctionModel.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/UnaryFunctionModel.cpp	2008-11-19 18:01:54 UTC (rev 757)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/UnaryFunctionModel.cpp	2008-11-19 18:57:16 UTC (rev 758)
@@ -1,247 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
- *
- */
-
-#include "UnaryFunctionModel.h"
-
-#include <string>
-
-#include "Types.h"
-
-namespace OpenFDM {
-
-class UnaryFunctionModelImpl :
-    public Referenced {
-public:
-  virtual ~UnaryFunctionModelImpl(void) {}
-  void setRealPortHandle(const RealPortHandle& realPortHandle)
-  { mRealPortHandle = realPortHandle; }
-  virtual real_type getValue(void) = 0;
-protected:
-  RealPortHandle mRealPortHandle;
-};
-
-/// Implementations of various similar functions.
-class AbsUnaryFunctionModelImpl :
-    public UnaryFunctionModelImpl {
-private:
-  virtual real_type getValue(void)
-  { return fabs(mRealPortHandle.getRealValue()); }
-};
-
-class AcosUnaryFunctionModelImpl :
-    public UnaryFunctionModelImpl {
-private:
-  virtual real_type getValue(void)
-  { return acos(mRealPortHandle.getRealValue()); }
-};
-
-class AsinUnaryFunctionModelImpl :
-    public UnaryFunctionModelImpl {
-private:
-  virtual real_type getValue(void)
-  { return asin(mRealPortHandle.getRealValue()); }
-};
-
-class AtanUnaryFunctionModelImpl :
-    public UnaryFunctionModelImpl {
-private:
-  virtual real_type getValue(void)
-  { return atan(mRealPortHandle.getRealValue()); }
-};
-
-class CeilUnaryFunctionModelImpl :
-    public UnaryFunctionModelImpl {
-private:
-  virtual real_type getValue(void)
-  { return ceil(mRealPortHandle.getRealValue()); }
-};
-
-class CosUnaryFunctionModelImpl :
-    public UnaryFunctionModelImpl {
-private:
-  virtual real_type getValue(void)
-  { return cos(mRealPortHandle.getRealValue()); }
-};
-
-class ExpUnaryFunctionModelImpl :
-    public UnaryFunctionModelImpl {
-private:
-  virtual real_type getValue(void)
-  { return exp(mRealPortHandle.getRealValue()); }
-};
-
-class FloorUnaryFunctionModelImpl :
-    public UnaryFunctionModelImpl {
-private:
-  virtual real_type getValue(void)
-  { return floor(mRealPortHandle.getRealValue()); }
-};
-
-class LogUnaryFunctionModelImpl :
-    public UnaryFunctionModelImpl {
-private:
-  virtual real_type getValue(void)
-  { return log(mRealPortHandle.getRealValue()); }
-};
-
-class Log10UnaryFunctionModelImpl :
-    public UnaryFunctionModelImpl {
-private:
-  virtual real_type getValue(void)
-  { return log10(mRealPortHandle.getRealValue()); }
-};
-
-class MinusUnaryFunctionModelImpl :
-    public UnaryFunctionModelImpl {
-private:
-  virtual real_type getValue(void)
-  { return -mRealPortHandle.getRealValue(); }
-};
-
-class SinUnaryFunctionModelImpl :
-    public UnaryFunctionModelImpl {
-private:
-  virtual real_type getValue(void)
-  { return sin(mRealPortHandle.getRealValue()); }
-};
-
-class SqrUnaryFunctionModelImpl :
-    public UnaryFunctionModelImpl {
-private:
-  virtual real_type getValue(void)
-  { real_type v = mRealPortHandle.getRealValue(); return v*v; }
-};
-
-class SqrtUnaryFunctionModelImpl :
-    public UnaryFunctionModelImpl {
-private:
-  virtual real_type getValue(void)
-  { return sqrt(mRealPortHandle.getRealValue()); }
-};
-
-class TanUnaryFunctionModelImpl :
-    public UnaryFunctionModelImpl {
-private:
-  virtual real_type getValue(void)
-  { return tan(mRealPortHandle.getRealValue()); }
-};
-
-BEGIN_OPENFDM_OBJECT_DEF(UnaryFunctionModel, Model)
-  END_OPENFDM_OBJECT_DEF
-
-UnaryFunctionModel::UnaryFunctionModel(const std::string& name, Type type) :
-  Model(name),
-  mType(type)
-{
-  setType(type);
-
-  setDirectFeedThrough(true);
-
-  setNumInputPorts(1);
-  setInputPortName(0, "input");
-  
-  setNumOutputPorts(1);
-  setOutputPort(0, "output", this, &UnaryFunctionModel::getFunctionValue);
-}
-
-UnaryFunctionModel::~UnaryFunctionModel(void)
-{
-}
-
-bool
-UnaryFunctionModel::init(void)
-{
-  if (!mImpl) {
-    Log(Model, Error) << "Initialization of UnaryFunctionModel model \""
-                      << getName() << "\" failed: No funcion given!" << endl;
-    return false;
-  }
-
-  RealPortHandle portHandle = getInputPort(0)->toRealPortHandle();
-  if (!portHandle.isConnected()) {
-    Log(Model, Error) << "Initialization of UnaryFunctionModel model \""
-                      << getName()
-                      << "\" failed: Input port \"" << getInputPortName(0)
-                      << "\" is not connected!" << endl;
-    return false;
-  }
-  mImpl->setRealPortHandle(portHandle);
-  return Model::init();
-}
-
-void
-UnaryFunctionModel::output(const TaskInfo&)
-{
-  // Evaluate the expression.
-  mFunctionValue = mImpl->getValue();
-}
-
-const real_type&
-UnaryFunctionModel::getFunctionValue(void) const
-{
-  return mFunctionValue;
-}
-
-void
-UnaryFunctionModel::setType(UnaryFunctionModel::Type type)
-{
-  mType = type;
-  switch (type) {
-  case Abs:
-    mImpl = new AbsUnaryFunctionModelImpl;
-    break;
-  case Acos:
-    mImpl = new AcosUnaryFunctionModelImpl;
-    break;
-  case Asin:
-    mImpl = new AsinUnaryFunctionModelImpl;
-    break;
-  case Atan:
-    mImpl = new AtanUnaryFunctionModelImpl;
-    break;
-  case Ceil:
-    mImpl = new CeilUnaryFunctionModelImpl;
-    break;
-  case Cos:
-    mImpl = new CosUnaryFunctionModelImpl;
-    break;
-  case Exp:
-    mImpl = new ExpUnaryFunctionModelImpl;
-    break;
-  case Floor:
-    mImpl = new FloorUnaryFunctionModelImpl;
-    break;
-  case Log:
-    mImpl = new LogUnaryFunctionModelImpl;
-    break;
-  case Log10:
-    mImpl = new Log10UnaryFunctionModelImpl;
-    break;
-  case Minus:
-    mImpl = new MinusUnaryFunctionModelImpl;
-    break;
-  case Sin:
-    mImpl = new SinUnaryFunctionModelImpl;
-    break;
-  case Sqr:
-    mImpl = new SqrUnaryFunctionModelImpl;
-    break;
-  case Sqrt:
-    mImpl = new SqrtUnaryFunctionModelImpl;
-    break;
-  case Tan:
-    mImpl = new TanUnaryFunctionModelImpl;
-    break;
-  default:
-    break;
-  }
-}
-
-UnaryFunctionModel::Type
-UnaryFunctionModel::getType(void) const
-{
-  return mType;
-}
-
-} // namespace OpenFDM

Deleted: branches/OpenFDM-StateSeparation/src/OpenFDM/UnaryFunctionModel.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/UnaryFunctionModel.h	2008-11-19 18:01:54 UTC (rev 757)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/UnaryFunctionModel.h	2008-11-19 18:57:16 UTC (rev 758)
@@ -1,58 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
- *
- */
-
-#ifndef OpenFDM_UnaryFunctionModel_H
-#define OpenFDM_UnaryFunctionModel_H
-
-#include <string>
-
-#include "Types.h"
-#include "Model.h"
-
-namespace OpenFDM {
-
-class UnaryFunctionModelImpl;
-
-/// Class representing a model with exactly one input.
-class UnaryFunctionModel : public Model {
-  OPENFDM_OBJECT(UnaryFunctionModel, Model);
-public:
-  enum Type {
-    Abs,
-    Acos,
-    Asin,
-    Atan,
-    Ceil,
-    Cos,
-    Exp,
-    Floor,
-    Log,
-    Log10,
-    Minus,
-    Sin,
-    Sqr,
-    Sqrt,
-    Tan
-  };
-
-  UnaryFunctionModel(const std::string& name, Type type = Abs /*FIXME*/);
-  virtual ~UnaryFunctionModel(void);
-
-  virtual bool init(void);
-  virtual void output(const TaskInfo&);
-
-  const real_type& getFunctionValue(void) const;
-
-  void setType(Type type);
-  Type getType(void) const;
-
-private:
-  SharedPtr<UnaryFunctionModelImpl> mImpl;
-  Type mType;
-  real_type mFunctionValue;
-};
-
-} // namespace OpenFDM
-
-#endif

Modified: branches/OpenFDM-StateSeparation/src/test/harmonic.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/harmonic.cpp	2008-11-19 18:01:54 UTC (rev 757)
+++ branches/OpenFDM-StateSeparation/src/test/harmonic.cpp	2008-11-19 18:57:16 UTC (rev 758)
@@ -11,7 +11,7 @@
 #include <OpenFDM/SimulationTime.h>
 #include <OpenFDM/Summer.h>
 #include <OpenFDM/System.h>
-#include <OpenFDM/UnaryFunctionModel.h>
+#include <OpenFDM/UnaryFunction.h>
 #include "ErrorCollectorCallback.h"
 
 using namespace OpenFDM;
@@ -56,14 +56,14 @@
   Connection::connect(gain->getInputPort(0),
                       simulationTime->getOutputPort(0));
 
-  UnaryFunctionModel* cosFunction
-    = new UnaryFunctionModel("Exact Pos Solution", UnaryFunctionModel::Cos);
+  UnaryFunction* cosFunction
+    = new UnaryFunction("Exact Pos Solution", UnaryFunction::Cos);
   system->addModel(cosFunction);
   Connection::connect(cosFunction->getInputPort(0),
                       gain->getOutputPort(0));
 
-  UnaryFunctionModel* sinFunction
-    = new UnaryFunctionModel("Exact Vel Solution", UnaryFunctionModel::Sin);
+  UnaryFunction* sinFunction
+    = new UnaryFunction("Exact Vel Solution", UnaryFunction::Sin);
   system->addModel(sinFunction);
   Connection::connect(sinFunction->getInputPort(0),
                       gain->getOutputPort(0));

Modified: branches/OpenFDM-StateSeparation/src/test/tiretestrig.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/tiretestrig.cpp	2008-11-19 18:01:54 UTC (rev 757)
+++ branches/OpenFDM-StateSeparation/src/test/tiretestrig.cpp	2008-11-19 18:57:16 UTC (rev 758)
@@ -21,7 +21,7 @@
 #include <OpenFDM/SimulationTime.h>
 #include <OpenFDM/Summer.h>
 #include <OpenFDM/System.h>
-#include <OpenFDM/UnaryFunctionModel.h>
+#include <OpenFDM/UnaryFunction.h>
 #include <OpenFDM/WheelContact.h>
 
 #include "HDF5Writer.h"



From frohlich at mail.berlios.de  Wed Nov 19 20:32:45 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Wed, 19 Nov 2008 20:32:45 +0100
Subject: [OpenFDM-svn] r759 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811191932.mAJJWjUj004791@sheep.berlios.de>

Author: frohlich
Date: 2008-11-19 20:32:45 +0100 (Wed, 19 Nov 2008)
New Revision: 759

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/ImplicitEuler.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/ImplicitEuler.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
Log:
Reactivate some numerical algorithms.

M    src/OpenFDM/ImplicitEuler.cpp
M    src/OpenFDM/Makefile.am
M    src/OpenFDM/ImplicitEuler.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/ImplicitEuler.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ImplicitEuler.cpp	2008-11-19 18:57:16 UTC (rev 758)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ImplicitEuler.cpp	2008-11-19 19:32:45 UTC (rev 759)
@@ -13,10 +13,35 @@
 
 namespace OpenFDM {
 
+class ImplicitEuler::IEFunction : public Function {
+public:
+  IEFunction(ImplicitEuler* i) : ie(i) {}
+  
+  virtual size_type inSize(void) const
+  { return ie->mFunction->inSize(); }
+  virtual size_type outSize(void) const
+  { return ie->mFunction->outSize(); }
+  virtual void eval(real_type t, const invector_type& v, outvector_type& out)
+  {
+    real_type h = ie->mCurrentStepsize;
+    ie->evalFunction(ie->getTime() + h, ie->getState() + v, out);
+    out -= (1/h)*v;
+  }
+  virtual void jac(real_type t, const invector_type& v, jacobian_type& jac)
+  {
+    real_type h = ie->mCurrentStepsize;
+    ie->evalJacobian(ie->getTime() + h, ie->getState() + v, jac);
+    size_type dim = ie->mFunction->inSize();
+    jac -= (1/h)*LinAlg::Eye<real_type,0,0>(dim, dim);
+  }
+private:
+  ImplicitEuler* ie;
+};
+
 ImplicitEuler::ImplicitEuler(void)
 {
   Log(TimeStep, Warning) << "Using mostly hacked implicit Euler method!!!"
-                             << endl;
+                         << endl;
   mJacStepsize = 0;
 }
 
@@ -38,8 +63,7 @@
   Vector fState(mState.size());
   fState.clear();
 
-  SharedPtr<System> system = mSystem.lock();
-  unsigned dim = system->getNumContinousStates();
+  unsigned dim = mFunction->inSize();
 
   real_type h = 0;
   while (!reached(toTEnd)) {

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/ImplicitEuler.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ImplicitEuler.h	2008-11-19 18:57:16 UTC (rev 758)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ImplicitEuler.h	2008-11-19 19:32:45 UTC (rev 759)
@@ -12,8 +12,7 @@
 
 namespace OpenFDM {
 
-class ImplicitEuler
-  : public ODESolver {
+class ImplicitEuler : public ODESolver {
 public:
   ImplicitEuler(void);
   virtual ~ImplicitEuler(void);
@@ -23,33 +22,8 @@
   virtual bool denseOutput(real_type t, Vector& out);
 
 private:
-  class IEFunction
-    : public Function {
-  public:
-    IEFunction(ImplicitEuler* i) : ie(i) {}
+  class IEFunction;
 
-    virtual size_type inSize(void) const
-    { return ie->mSystem.lock()->getNumContinousStates(); }
-    virtual size_type outSize(void) const
-    { return ie->mSystem.lock()->getNumContinousStates(); }
-    virtual void eval(real_type t, const invector_type& v,
-                      outvector_type& out)
-    {
-      real_type h = ie->mCurrentStepsize;
-      ie->evalFunction(ie->getTime() + h, ie->getState() + v, out);
-      out -= (1/h)*v;
-    }
-    virtual void jac(real_type t, const invector_type& v, jacobian_type& jac)
-    {
-      real_type h = ie->mCurrentStepsize;
-      ie->evalJacobian(ie->getTime() + h, ie->getState() + v, jac);
-      size_type dim = ie->mSystem.lock()->getNumContinousStates();
-      jac -= (1/h)*LinAlg::Eye<real_type,0,0>(dim, dim);
-    }
-  private:
-    ImplicitEuler* ie;
-  };
-
   real_type mCurrentStepsize;
   real_type mJacStepsize;
   Matrix mJac;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-11-19 18:57:16 UTC (rev 758)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-11-19 19:32:45 UTC (rev 759)
@@ -142,6 +142,7 @@
   GroupInput.cpp \
   GroupMechanicLink.cpp \
   GroupOutput.cpp \
+  ImplicitEuler.cpp \
   Interact.cpp \
   LeafNode.cpp \
   LibraryModel.cpp \
@@ -153,6 +154,7 @@
   MidpointRule.cpp \
   Model.cpp \
   ModelContext.cpp \
+  Newton.cpp \
   Node.cpp \
   NodeInstance.cpp \
   NodeVisitor.cpp \
@@ -173,11 +175,7 @@
 
 #   Environment.cpp \
 #   EnvironmentObject.cpp \
-#   ImplicitEuler.cpp \
-#   Newton.cpp \
 #   ReaderWriter.cpp \
-#
-
 #   Atmosphere.cpp \
 #   AtmosphereSTD1976.cpp \
 #   DefaultGravity.cpp \
@@ -296,7 +294,7 @@
 #   Tailhook.cpp \
 #   Tank.cpp \
 #   WheelContact.cpp
+#
 
-
 nobase_OpenFDMinclude_HEADERS = $(OpenFDMCoreHEADERS) $(OpenFDMModelsHEADERS)
 libOpenFDM_la_SOURCES = $(OpenFDMCoreSOURCES) $(OpenFDMModelsSOURCES) $(OpenFDMMechanicSOURCES)



From frohlich at mail.berlios.de  Thu Nov 20 18:10:59 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Thu, 20 Nov 2008 18:10:59 +0100
Subject: [OpenFDM-svn] r760 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811201710.mAKHAxtL002378@sheep.berlios.de>

Author: frohlich
Date: 2008-11-20 18:10:59 +0100 (Thu, 20 Nov 2008)
New Revision: 760

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.h
Log:
Todo is already done.

M    MechanicNode.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.h	2008-11-19 19:32:45 UTC (rev 759)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.h	2008-11-20 17:10:59 UTC (rev 760)
@@ -38,7 +38,6 @@
 
 // TODO:
 // * Remove AbstractNodeContext ...
-// * allocate contexts later ...
 
 class MechanicContext;
 



From frohlich at mail.berlios.de  Thu Nov 20 19:06:01 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Thu, 20 Nov 2008 19:06:01 +0100
Subject: [OpenFDM-svn] r761 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811201806.mAKI61Br012693@sheep.berlios.de>

Author: frohlich
Date: 2008-11-20 19:05:58 +0100 (Thu, 20 Nov 2008)
New Revision: 761

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJoint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Mass.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJoint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.h
Log:
Beginnings of the return of the environment.

M    OpenFDM/MobileRootJoint.cpp
M    OpenFDM/CartesianJoint.h
M    OpenFDM/Mass.cpp
M    OpenFDM/RootJoint.cpp
M    OpenFDM/MechanicLinkValue.h
M    OpenFDM/RootJoint.h
M    OpenFDM/FixedRootJoint.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h	2008-11-20 17:10:59 UTC (rev 760)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h	2008-11-20 18:05:58 UTC (rev 761)
@@ -50,6 +50,9 @@
     if (!childLinkValue)
       return 0;
 
+    // Now propagate the root dependent data ...
+    childLinkValue->setEnvironment(parentLinkValue->getEnvironment());
+
     SharedPtr<Context> context;
     context = new Context(this, parentLinkValue, childLinkValue);
     for (unsigned i = 0; i < getNumPorts(); ++i) {

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJoint.cpp	2008-11-20 17:10:59 UTC (rev 760)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJoint.cpp	2008-11-20 18:05:58 UTC (rev 761)
@@ -11,7 +11,7 @@
 #include "Matrix.h"
 #include "Quaternion.h"
 #include "Inertia.h"
-#include "Gravity.h"
+#include "Task.h"
 #include "MechanicContext.h"
 
 namespace OpenFDM {
@@ -71,11 +71,14 @@
 }
 
 void
-FixedRootJoint::velocity(const Task&,
-                          const ContinousStateValueVector& continousState,
-                          PortValueList& portValues) const
+FixedRootJoint::velocity(const Task& task,
+                         const ContinousStateValueVector& continousState,
+                         PortValueList& portValues) const
 {
-  portValues[mMechanicLink].setPosAndVel(getAngularBaseVelocity(), mPosition,
+  const EnvironmentCache* environment;
+  environment = portValues[mMechanicLink].getEnvironment();
+  Vector3 angularBaseVelocity = environment->getAngularVelocity(task.getTime());
+  portValues[mMechanicLink].setPosAndVel(angularBaseVelocity, mPosition,
                                          mOrientation, Vector6::zeros());
 }
 
@@ -87,18 +90,12 @@
 }
 
 void
-FixedRootJoint::acceleration(const Task&, const ContinousStateValueVector&,
+FixedRootJoint::acceleration(const Task& task, const ContinousStateValueVector&,
                               PortValueList& portValues) const
 {
-  // Assumption: body is small compared to the distance to the planets
-  // center of mass. That means gravity could be considered equal for the
-  // whole vehicle.
-  // See Featherstone, Orin: Equations and Algorithms
-
-  // FIXME
-  Vector6 grav = Vector6(Vector3::zeros(), portValues[mMechanicLink].getFrame().rotFromRef(Vector3(0, 0, 9.81)));
-
-  Vector6 spatialAcceleration = grav;
+  const EnvironmentCache* environment;
+  environment = portValues[mMechanicLink].getEnvironment();
+  Vector6 spatialAcceleration = environment->getAcceleration(task.getTime());
   portValues[mMechanicLink].getFrame().setSpAccel(spatialAcceleration);
 }
 

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Mass.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Mass.cpp	2008-11-20 17:10:59 UTC (rev 760)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Mass.cpp	2008-11-20 18:05:58 UTC (rev 761)
@@ -38,12 +38,18 @@
 Mass::articulation(const Task&, const ContinousStateValueVector&,
                    PortValueList& portValues, Matrix&) const
 {
+  const EnvironmentCache* environment;
+  environment = portValues[mMechanicLink].getEnvironment();
+
   Vector3 position = mPosition - portValues[mMechanicLink].getDesignPosition();
 
-  // FIXME: Hardcoding that gravity happens in the roots??
-  Vector3 gravity = Vector3::zeros();
+  Vector3 refPosition = portValues[mMechanicLink].getFrame().posToRef(position);
+  Vector3 gravity = environment->getGravityAcceleration(refPosition);
+  gravity = portValues[mMechanicLink].getFrame().rotFromRef(gravity);
+  // FIXME: Why this -??
+  gravity = -mMass*gravity;
 
-  Vector6 force = forceFrom(position, Vector6(Vector3::zeros(), gravity));
+  Vector6 force = forceFrom(position, gravity);
   SpatialInertia I = inertiaFrom(position, SpatialInertia(mInertia, mMass));
 
   // FIXME: do we really need that in the mass
@@ -54,7 +60,6 @@
                    cross(iv.getLinear(), Jiv.getLinear()),
                    cross(iv.getAngular(), Jiv.getLinear()));
 
-
   portValues[mMechanicLink].applyInertia(I);
   portValues[mMechanicLink].applyForce(force);
 }

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.h	2008-11-20 17:10:59 UTC (rev 760)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.h	2008-11-20 18:05:58 UTC (rev 761)
@@ -11,6 +11,95 @@
 
 namespace OpenFDM {
 
+class EnvironmentCache;
+
+class AbstractInertial : public Referenced {
+public:
+  virtual ~AbstractInertial() {}
+  virtual Vector3 getAngularVelocity(const real_type& t) const
+  { return Vector3::zeros(); }
+  virtual Vector6 getAcceleration(const real_type& t) const
+  { return Vector6::zeros(); }
+};
+
+class AbstractGravity : public Referenced {
+public:
+  virtual ~AbstractGravity() {}
+  virtual Vector3
+  getGravityAcceleration(const EnvironmentCache&, const Vector3&) const
+  { return Vector3(0, 0, 9.81); }
+};
+
+class AbstractWind : public Referenced {
+public:
+  virtual ~AbstractWind() {}
+  virtual Vector6 getWindVelocity(const EnvironmentCache&, const Vector3&) const
+  { return Vector6::zeros(); }
+};
+
+class EnvironmentCache : public Referenced {
+public:
+  EnvironmentCache() :
+    mInertial(new AbstractInertial),
+    mGravity(new AbstractGravity),
+    mWind(new AbstractWind)
+  {
+  }
+  EnvironmentCache(const AbstractInertial* inertial,
+                   const AbstractGravity* gravity,
+                   const AbstractWind* wind) :
+    mInertial(inertial),
+    mGravity(gravity),
+    mWind(wind)
+  {
+  }
+  virtual ~EnvironmentCache() {}
+
+  // The the global coordinate frames angular velocity and acceleration.
+  // Note that the acceleration and velocity must fit together to simulate
+  // something useful.
+  Vector3 getAngularVelocity(const real_type& t) const
+  { return mInertial->getAngularVelocity(t); }
+  Vector6 getAcceleration(const real_type& t) const
+  { return mInertial->getAcceleration(t); }
+
+  // Sets a new RootJoint position, evaluate environmental stuff
+  void setRootJointPosition(const Vector3& position)
+  {
+    mRootJointPosition = position;
+    mGravityAcceleration = getGravityAcceleration(position);
+    mWindVelocity = getWindVelocity(position);
+  }
+  const Vector3& getRootJointPosition() const
+  { return mRootJointPosition; }
+
+  Vector3 getGravityAcceleration(const Vector3& position) const
+  { return mGravity->getGravityAcceleration(*this, position); }
+  const Vector3& getGravityAccelerationAtRoot() const
+  { return mGravityAcceleration; }
+
+  Vector6 getWindVelocity(const Vector3& position) const
+  { return mWind->getWindVelocity(*this, position); }
+  const Vector6& getWindVelocityAtRoot() const
+  { return mWindVelocity; }
+
+private:
+  Vector3 mRootJointPosition;
+
+  SharedPtr<const AbstractInertial> mInertial;
+
+  Vector3 mGravityAcceleration;
+  SharedPtr<const AbstractGravity> mGravity;
+
+  Vector6 mWindVelocity;
+  SharedPtr<const AbstractWind> mWind;
+
+//   SharedPtr<const AbstractPlanet> mPlanet;
+//   SharedPtr<const AbstractAtmosphere> mAtmosphere;
+//   SharedPtr<const AbstractGround> mGround;
+};
+
+
 class MechanicLinkValue : public PortValue {
 public:
   MechanicLinkValue();
@@ -81,6 +170,15 @@
   void setDesignPosition(const Vector3& designPosition)
   { mDesignPosition = designPosition; }
 
+  // This is a per link value because of interacts that can be child of two
+  // different roots.
+  // FIXME, enforce setting that in the contructor
+  const EnvironmentCache* getEnvironment() const
+  { return mEnvironment; }
+
+  void setEnvironment(const EnvironmentCache* environment)
+  { OpenFDMAssert(environment); mEnvironment = environment; }
+
 protected:
   // May be build a class hierarchy that accounts for different inputs
   // and outputs a rigid body can have.
@@ -90,6 +188,8 @@
   SpatialInertia mArticulatedInertia;
 
   Vector3 mDesignPosition;
+
+  SharedPtr<const EnvironmentCache> mEnvironment;
 };
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJoint.cpp	2008-11-20 17:10:59 UTC (rev 760)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJoint.cpp	2008-11-20 18:05:58 UTC (rev 761)
@@ -6,12 +6,11 @@
 
 #include "Assert.h"
 #include "LogStream.h"
-#include "Object.h"
 #include "Vector.h"
 #include "Matrix.h"
 #include "Quaternion.h"
 #include "Inertia.h"
-#include "Gravity.h"
+#include "Task.h"
 #include "MechanicContext.h"
 
 namespace OpenFDM {
@@ -52,15 +51,19 @@
 }
 
 void
-MobileRootJoint::velocity(const Task&,
+MobileRootJoint::velocity(const Task& task,
                           const ContinousStateValueVector& continousState,
                           PortValueList& portValues) const
 {
+  const EnvironmentCache* environment;
+  environment = portValues[mMechanicLink].getEnvironment();
+  Vector3 angularBaseVelocity = environment->getAngularVelocity(task.getTime());
+
   Vector3 position = continousState[*mPositionStateInfo];
   Quaternion orientation = continousState[*mOrientationStateInfo];
   Vector6 velocity = continousState[*mVelocityStateInfo];
 
-  portValues[mMechanicLink].setPosAndVel(getAngularBaseVelocity(),
+  portValues[mMechanicLink].setPosAndVel(angularBaseVelocity,
                                          position, orientation, velocity);
 }
 
@@ -72,23 +75,18 @@
 }
 
 void
-MobileRootJoint::acceleration(const Task&, const ContinousStateValueVector&,
+MobileRootJoint::acceleration(const Task& task,
+                              const ContinousStateValueVector&,
                               PortValueList& portValues) const
 {
-  // Assumption: body is small compared to the distance to the planets
-  // center of mass. That means gravity could be considered equal for the
-  // whole vehicle.
-  // See Featherstone, Orin: Equations and Algorithms
-//   Vector3 ga = gravity->gravityAccel(getRefPosition());
-//     Vector6 grav = Vector6(Vector3::zeros(), rotFromRef(ga));
+  const EnvironmentCache* environment;
+  environment = portValues[mMechanicLink].getEnvironment();
+  Vector6 spatialAcceleration = environment->getAcceleration(task.getTime());
 
-  // FIXME
-  Vector6 grav = Vector6(Vector3::zeros(), portValues[mMechanicLink].getFrame().rotFromRef(Vector3(0, 0, 9.81)));
-
   SpatialInertia inertia = portValues[mMechanicLink].getInertia();
   Vector6 force = portValues[mMechanicLink].getForce();
 
-  Vector6 spatialAcceleration = grav - solve(inertia, force);
+  spatialAcceleration -= solve(inertia, force);
   portValues[mMechanicLink].getFrame().setSpAccel(spatialAcceleration);
 }
 

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.cpp	2008-11-20 17:10:59 UTC (rev 760)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.cpp	2008-11-20 18:05:58 UTC (rev 761)
@@ -56,12 +56,10 @@
 };
   
 BEGIN_OPENFDM_OBJECT_DEF(RootJoint, Joint)
-  DEF_OPENFDM_PROPERTY(Matrix, AngularBaseVelocity, Serialized)
   END_OPENFDM_OBJECT_DEF
 
 RootJoint::RootJoint(const std::string& name) :
-  Joint(name),
-  mAngularBaseVelocity(Vector3::zeros())
+  Joint(name)
 {
 }
 
@@ -83,6 +81,11 @@
                         << "\"" << endl;
       return false;
     }
+
+    if (portValue->toMechanicLinkValue()) {
+      portValue->toMechanicLinkValue()->setEnvironment(new EnvironmentCache);
+    }
+
     context->setPortValue(*getPort(i), portValue);
   }
   if (!context->allocStates()) {

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.h	2008-11-20 17:10:59 UTC (rev 760)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.h	2008-11-20 18:05:58 UTC (rev 761)
@@ -24,11 +24,6 @@
   virtual void accept(NodeVisitor& visitor);
   virtual void accept(ConstNodeVisitor& visitor) const;
 
-  const Vector3& getAngularBaseVelocity() const
-  { return mAngularBaseVelocity; }
-  void setAngularBaseVelocity(const Vector3& angularBaseVelocity)
-  { mAngularBaseVelocity = angularBaseVelocity; }
-
   virtual void init(const Task&,DiscreteStateValueVector&,
                     ContinousStateValueVector&, const PortValueList&) const
   { }
@@ -47,8 +42,6 @@
   {}
 private:
   class Context;
-
-  Vector3 mAngularBaseVelocity;
 };
 
 } // namespace OpenFDM



From frohlich at mail.berlios.de  Thu Nov 20 20:43:30 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Thu, 20 Nov 2008 20:43:30 +0100
Subject: [OpenFDM-svn] r762 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811201943.mAKJhUY0009165@sheep.berlios.de>

Author: frohlich
Date: 2008-11-20 20:43:30 +0100 (Thu, 20 Nov 2008)
New Revision: 762

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/RotationalJoint.cpp
Log:
Remove a useless copy.

M    RotationalJoint.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RotationalJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RotationalJoint.cpp	2008-11-20 18:05:58 UTC (rev 761)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RotationalJoint.cpp	2008-11-20 19:43:30 UTC (rev 762)
@@ -145,13 +145,11 @@
                           const PortValueList&, const VectorN& velDot,
                           ContinousStateValueVector& derivative) const
 {
-  Quaternion orientation = states[*mPositionStateInfo];
-  Quaternion q = orientation;
-
   // Compute the derivative term originating from the angular velocity.
   // Correction term to keep the quaternion normalized.
   // That is if |q| < 1 add a little radial component outward,
   // if |q| > 1 add a little radial component inward
+  Quaternion q = states[*mPositionStateInfo];
   Vector3 angVel = states[*mVelocityStateInfo];
   Vector4 qderiv = LinAlg::derivative(q, angVel) + 1e1*(normalize(q) - q);
 



From frohlich at mail.berlios.de  Fri Nov 21 06:46:24 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Fri, 21 Nov 2008 06:46:24 +0100
Subject: [OpenFDM-svn] r763 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811210546.mAL5kOVb020277@sheep.berlios.de>

Author: frohlich
Date: 2008-11-21 06:46:22 +0100 (Fri, 21 Nov 2008)
New Revision: 763

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Mass.cpp
Log:
Reorder and document

M    Mass.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Mass.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Mass.cpp	2008-11-20 19:43:30 UTC (rev 762)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Mass.cpp	2008-11-21 05:46:22 UTC (rev 763)
@@ -41,27 +41,31 @@
   const EnvironmentCache* environment;
   environment = portValues[mMechanicLink].getEnvironment();
 
+  // The position of the mass point wrt its parent link frame
+  // FIXME precompute that
   Vector3 position = mPosition - portValues[mMechanicLink].getDesignPosition();
 
+  // The gravity force that applies to this mass
   Vector3 refPosition = portValues[mMechanicLink].getFrame().posToRef(position);
   Vector3 gravity = environment->getGravityAcceleration(refPosition);
-  gravity = portValues[mMechanicLink].getFrame().rotFromRef(gravity);
-  // FIXME: Why this -??
-  gravity = -mMass*gravity;
+  gravity = mMass*portValues[mMechanicLink].getFrame().rotFromRef(gravity);
+  // The gravity force at the coordinate system of the parent link
+  Vector6 force = forceFrom(position, gravity);
 
-  Vector6 force = forceFrom(position, gravity);
+  // The inertia at the coordinate system of the parent link
+  // FIXME precompute that
   SpatialInertia I = inertiaFrom(position, SpatialInertia(mInertia, mMass));
 
   // FIXME: do we really need that in the mass
   // I did search for a while until I found that missing term here ...
-  Vector6 iv = portValues[mMechanicLink].getFrame().getSpVel();
-  Vector6 Jiv = I*iv;
-  force += Vector6(cross(iv.getAngular(), Jiv.getAngular()) +
-                   cross(iv.getLinear(), Jiv.getLinear()),
-                   cross(iv.getAngular(), Jiv.getLinear()));
+  Vector6 v = portValues[mMechanicLink].getFrame().getSpVel();
+  Vector6 Iv = I*v;
+  Vector6 vIv = Vector6(cross(v.getAngular(), Iv.getAngular()) +
+                        cross(v.getLinear(), Iv.getLinear()),
+                        cross(v.getAngular(), Iv.getLinear()));
 
   portValues[mMechanicLink].applyInertia(I);
-  portValues[mMechanicLink].applyForce(force);
+  portValues[mMechanicLink].applyForce(Vector6(vIv - force));
 }
 
 const InertiaMatrix&



From frohlich at mail.berlios.de  Fri Nov 21 13:22:30 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Fri, 21 Nov 2008 13:22:30 +0100
Subject: [OpenFDM-svn] r764 - trunk/OpenFDM/src/OpenFDM/LinAlg
Message-ID: <200811211222.mALCMULw006702@sheep.berlios.de>

Author: frohlich
Date: 2008-11-21 13:22:29 +0100 (Fri, 21 Nov 2008)
New Revision: 764

Modified:
   trunk/OpenFDM/src/OpenFDM/LinAlg/Algorithm.h
Log:
Fix long standing problem with the index shift.

M    Algorithm.h


Modified: trunk/OpenFDM/src/OpenFDM/LinAlg/Algorithm.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/LinAlg/Algorithm.h	2008-11-21 05:46:22 UTC (rev 763)
+++ trunk/OpenFDM/src/OpenFDM/LinAlg/Algorithm.h	2008-11-21 12:22:29 UTC (rev 764)
@@ -625,7 +625,7 @@
         v(i) = static_cast<value_type>(0);
       } else {
         v(i) /= Aii;
-        if (1 < i)
+        if (0 < i)
           v(Range(0,i-1)) -= v(i)*A(Range(0,i-1),i);
       }
     }
@@ -652,7 +652,7 @@
           v(i,j) = static_cast<value_type>(0);
         } else {
           v(i,j) /= Aii;
-          if (1 < i)
+          if (0 < i)
             v(Range(0,i-1),j) -= v(i,j)*A(Range(0,i-1),i);
         }
       }
@@ -804,8 +804,8 @@
         // FIXME ...
 //         RangeExpr<Matrix<T,dim1,dim2>,1,0> re1 = A(j, Range(1, n-1));
 //         RangeExpr<Matrix<T,dim1,dim2>,1,0> re2 = A(jp, Range(1, n-1));
-        MatrixPointerExpr<Matrix<T,dim1,dim2>,1,0> re1 = A(j, Range(1, n-1));
-        MatrixPointerExpr<Matrix<T,dim1,dim2>,1,0> re2 = A(jp, Range(1, n-1));
+        MatrixPointerExpr<Matrix<T,dim1,dim2>,1,0> re1 = A(j, Range(0, n-1));
+        MatrixPointerExpr<Matrix<T,dim1,dim2>,1,0> re2 = A(jp, Range(0, n-1));
         swap(re1, re2);
       }
     



From frohlich at mail.berlios.de  Fri Nov 21 13:26:14 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Fri, 21 Nov 2008 13:26:14 +0100
Subject: [OpenFDM-svn] r765 - in branches/OpenFDM-StateSeparation: .
	src/OpenFDM/LinAlg
Message-ID: <200811211226.mALCQEZ6012937@sheep.berlios.de>

Author: frohlich
Date: 2008-11-21 13:26:14 +0100 (Fri, 21 Nov 2008)
New Revision: 765

Modified:
   branches/OpenFDM-StateSeparation/MERGE-REVISION
   branches/OpenFDM-StateSeparation/src/OpenFDM/LinAlg/Algorithm.h
Log:
Merge 631:764 from trunk.

M    src/OpenFDM/LinAlg/Algorithm.h
M    MERGE-REVISION


Modified: branches/OpenFDM-StateSeparation/MERGE-REVISION
===================================================================
--- branches/OpenFDM-StateSeparation/MERGE-REVISION	2008-11-21 12:22:29 UTC (rev 764)
+++ branches/OpenFDM-StateSeparation/MERGE-REVISION	2008-11-21 12:26:14 UTC (rev 765)
@@ -1 +1 @@
-631
+764
\ No newline at end of file

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/LinAlg/Algorithm.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/LinAlg/Algorithm.h	2008-11-21 12:22:29 UTC (rev 764)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/LinAlg/Algorithm.h	2008-11-21 12:26:14 UTC (rev 765)
@@ -654,7 +654,7 @@
         v(i) = static_cast<value_type>(0);
       } else {
         v(i) /= Aii;
-        if (1 < i)
+        if (0 < i)
           v(Range(0,i-1)) -= v(i)*A(Range(0,i-1),i);
       }
     }
@@ -681,7 +681,7 @@
           v(i,j) = static_cast<value_type>(0);
         } else {
           v(i,j) /= Aii;
-          if (1 < i)
+          if (0 < i)
             v(Range(0,i-1),j) -= v(i,j)*A(Range(0,i-1),i);
         }
       }
@@ -833,8 +833,8 @@
         // FIXME ...
 //         RangeExpr<Matrix<T,dim1,dim2>,1,0> re1 = A(j, Range(1, n-1));
 //         RangeExpr<Matrix<T,dim1,dim2>,1,0> re2 = A(jp, Range(1, n-1));
-        MatrixPointerExpr<Matrix<T,dim1,dim2>,1,0> re1 = A(j, Range(1, n-1));
-        MatrixPointerExpr<Matrix<T,dim1,dim2>,1,0> re2 = A(jp, Range(1, n-1));
+        MatrixPointerExpr<Matrix<T,dim1,dim2>,1,0> re1 = A(j, Range(0, n-1));
+        MatrixPointerExpr<Matrix<T,dim1,dim2>,1,0> re2 = A(jp, Range(0, n-1));
         swap(re1, re2);
       }
     



From frohlich at mail.berlios.de  Fri Nov 21 13:27:39 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Fri, 21 Nov 2008 13:27:39 +0100
Subject: [OpenFDM-svn] r766 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811211227.mALCRdWx015455@sheep.berlios.de>

Author: frohlich
Date: 2008-11-21 13:27:39 +0100 (Fri, 21 Nov 2008)
New Revision: 766

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Joint.h
Log:
Some thought on joints.

M    Joint.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Joint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Joint.h	2008-11-21 12:26:14 UTC (rev 765)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Joint.h	2008-11-21 12:27:39 UTC (rev 766)
@@ -18,6 +18,13 @@
 
 namespace OpenFDM {
 
+// May be each joint can be a root joint.
+// A joint with one link is a root joint?
+// The given position is then meant to be in the root coordinate system?
+// That is: if connected to a parent, it is the designPosition wrt root joint
+// If not connected, in the root coordinate system of the simulation?
+// It would be nice if each joint is lockable anyway
+// May be then unify all that joint stuff in a common framework here??
 class Joint : public MechanicNode {
   OPENFDM_OBJECT(Joint, MechanicNode);
 public:



From frohlich at mail.berlios.de  Fri Nov 21 13:31:29 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Fri, 21 Nov 2008 13:31:29 +0100
Subject: [OpenFDM-svn] r767 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200811211231.mALCVTIc025491@sheep.berlios.de>

Author: frohlich
Date: 2008-11-21 13:31:29 +0100 (Fri, 21 Nov 2008)
New Revision: 767

Modified:
   branches/OpenFDM-StateSeparation/src/test/foucault.cpp
Log:
More intuitive naming.

M    foucault.cpp


Modified: branches/OpenFDM-StateSeparation/src/test/foucault.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/foucault.cpp	2008-11-21 12:27:39 UTC (rev 766)
+++ branches/OpenFDM-StateSeparation/src/test/foucault.cpp	2008-11-21 12:31:29 UTC (rev 767)
@@ -20,33 +20,33 @@
 
   // FIXME, need usable environment stuff like gravity first ...
   SharedPtr<Group> group = new Group("Foucault");
-  FixedRootJoint* fixedRoot = new FixedRootJoint("Root");
-  fixedRoot->setPosition(Vector3(0, 0, -1));
-  Group::NodeId root = group->addChild(fixedRoot);
-  RotationalJoint* rotationalJoint = new RotationalJoint("Rotational");
-  Group::NodeId rotational = group->addChild(rotationalJoint);
+  FixedRootJoint* fixedRootJoint = new FixedRootJoint("Root");
+  fixedRootJoint->setPosition(Vector3(0, 0, 1));
+  Group::NodeId fixedRootJointId = group->addChild(fixedRootJoint);
+  RotationalJoint* rotationalJoint1 = new RotationalJoint("Rotational Joint 1");
+  Group::NodeId rotationalJoint1Id = group->addChild(rotationalJoint1);
+  RigidBody* rigidBody1 = new RigidBody("Rigid Body 1");
+  rigidBody1->addLink("sensorLink");
+  Group::NodeId rigidBody1Id = group->addChild(rigidBody1);
 
-  RigidBody* rigidBodyNode = new RigidBody("Rigid Body");
-  rigidBodyNode->addLink("sensorLink");
-  Group::NodeId rigidBody = group->addChild(rigidBodyNode);
-  Mass* massModel = new Mass("Mass", 1, InertiaMatrix(1, 0, 0, 1, 0, 1));
-  massModel->setPosition(Vector3(1, 0, 0));
-  Group::NodeId mass = group->addChild(massModel);
+  Mass* mass = new Mass("Mass", 1, InertiaMatrix(1, 0, 0, 1, 0, 1));
+  mass->setPosition(Vector3(1, 1, 0));
+  Group::NodeId massId = group->addChild(mass);
 
-  Sensor* sensorModel = new Sensor("Sensor");
-  sensorModel->setPosition(massModel->getPosition());
-  sensorModel->setEnablePosition(true);
-  sensorModel->setEnableOrientation(true);
-  sensorModel->setEnableEulerAngles(true);
-  sensorModel->setEnableLinearVelocity(true);
-  sensorModel->setEnableAngularVelocity(true);
-  sensorModel->setEnableCentrifugalAcceleration(true);
-  Group::NodeId sensor = group->addChild(sensorModel);
+  Sensor* sensor = new Sensor("Sensor");
+  sensor->setPosition(mass->getPosition());
+  sensor->setEnablePosition(true);
+  sensor->setEnableOrientation(true);
+  sensor->setEnableEulerAngles(true);
+  sensor->setEnableLinearVelocity(true);
+  sensor->setEnableAngularVelocity(true);
+  sensor->setEnableCentrifugalAcceleration(true);
+  Group::NodeId sensorId = group->addChild(sensor);
 
-  group->connect(root, 0, rotational, 0);
-  group->connect(rotational, 1, rigidBody, 0);
-  group->connect(rigidBody, 1, mass, 0);
-  group->connect(rigidBody, "sensorLink", sensor, "link");
+  group->connect(fixedRootJointId, 0, rotationalJoint1Id, 0);
+  group->connect(rotationalJoint1Id, 1, rigidBody1Id, 0);
+  group->connect(rigidBody1Id, 1, massId, 0);
+  group->connect(rigidBody1Id, "sensorLink", sensorId, "link");
 
   SharedPtr<System> system = new System("System", group);
 



From frohlich at mail.berlios.de  Fri Nov 21 13:48:45 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Fri, 21 Nov 2008 13:48:45 +0100
Subject: [OpenFDM-svn] r768 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811211248.mALCmjuT011956@sheep.berlios.de>

Author: frohlich
Date: 2008-11-21 13:48:44 +0100 (Fri, 21 Nov 2008)
New Revision: 768

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/PrismaticJoint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/PrismaticJoint.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/RotationalJoint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/RotationalJoint.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/UniversalJoint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/UniversalJoint.h
Log:
Fix a problem with AB joints.

M    src/OpenFDM/CartesianJoint.h
M    src/OpenFDM/RotationalJoint.cpp
M    src/OpenFDM/PrismaticJoint.cpp
M    src/OpenFDM/RevoluteJoint.cpp
M    src/OpenFDM/RotationalJoint.h
M    src/OpenFDM/UniversalJoint.h
M    src/OpenFDM/PrismaticJoint.h
M    src/OpenFDM/RevoluteJoint.h
M    src/OpenFDM/UniversalJoint.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h	2008-11-21 12:31:29 UTC (rev 767)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h	2008-11-21 12:48:44 UTC (rev 768)
@@ -100,7 +100,7 @@
   void articulation(MechanicLinkValue& parentLink,
                     const MechanicLinkValue& childLink,
                     const VectorN& jointForce,
-                    MatrixFactorsNN& hIh) const
+                    MatrixFactorsNN& hIh, Vector6& pAlpha) const
   {
     // The formulas conform to Roy Featherstones book eqn (6.37), (6.38)
     
@@ -110,12 +110,11 @@
     
     // Compute the projection to the joint coordinate space
     Matrix6N Ih = I*mJointMatrix;
-    hIh = MatrixNN(trans(mJointMatrix)*Ih);
-    
+    hIh = trans(mJointMatrix)*Ih;
+
     // Note that the momentum of the local mass is already included in the
     // child links force due the the mass model ...
-    Vector6 pAlpha = childLink.getForce() + I*childLink.getFrame().getHdot();
-    Vector6 force = pAlpha;
+    pAlpha = childLink.getForce() + I*childLink.getFrame().getHdot();
     
     if (hIh.singular()) {
       Log(ArtBody,Error) << "Detected singular mass matrix for "
@@ -125,6 +124,7 @@
     }
     
     // Project away the directions handled with this current joint
+    Vector6 force = pAlpha;
     force -= Ih*hIh.solve(trans(mJointMatrix)*pAlpha - jointForce);
     I -= SpatialInertia(Ih*hIh.solve(trans(Ih)));
     
@@ -138,13 +138,13 @@
    */
   void acceleration(const MechanicLinkValue& parentLink,
                     MechanicLinkValue& childLink, const VectorN& jointForce,
-                    const MatrixFactorsNN& hIh, VectorN& velDot) const
+                    const MatrixFactorsNN& hIh, const Vector6& pAlpha,
+                    VectorN& velDot) const
   {
     Vector6 parentSpAccel
       = childLink.getFrame().motionFromParent(parentLink.getFrame().getSpAccel());
     
-    Vector6 f = childLink.getForce();
-    f += childLink.getInertia()*(parentSpAccel + childLink.getFrame().getHdot());
+    Vector6 f = childLink.getInertia()*parentSpAccel + pAlpha;
     velDot = hIh.solve(jointForce - trans(mJointMatrix)*f);
     childLink.setAccel(parentLink, mJointMatrix*velDot);
   }
@@ -192,12 +192,12 @@
                             const MechanicLinkValue& childLink,
                             const ContinousStateValueVector& states,
                             PortValueList& portValues,
-                            MatrixFactorsNN& hIh) const = 0;
+                            MatrixFactorsNN& hIh, Vector6& pAlpha) const = 0;
   virtual void acceleration(const MechanicLinkValue& parentLink,
                             MechanicLinkValue& childLink,
                             const ContinousStateValueVector& states,
                             PortValueList& portValues,
-                            const MatrixFactorsNN& hIh,
+                            const MatrixFactorsNN& hIh, const Vector6& pAlpha,
                             VectorN& velDot) const = 0;
   virtual void derivative(const DiscreteStateValueVector&,
                           const ContinousStateValueVector&,
@@ -241,13 +241,13 @@
     }
     virtual void articulation(const Task& task)
     {
-      mCartesianJoint->articulation(*mParentLink, *mChildLink,
-                                    mContinousState, mPortValueList, hIh);
+      mCartesianJoint->articulation(*mParentLink, *mChildLink, mContinousState,
+                                    mPortValueList, hIh, pAlpha);
     }
     virtual void accelerations(const Task& task)
     {
       mCartesianJoint->acceleration(*mParentLink, *mChildLink, mContinousState,
-                                    mPortValueList, hIh, velDot);
+                                    mPortValueList, hIh, pAlpha, velDot);
     }
     
     virtual void derivative(const Task&)
@@ -263,6 +263,7 @@
   private:
     // Stores some values persistent accross velocity/articulation/acceleration
     MatrixFactorsNN hIh;
+    Vector6 pAlpha;
     VectorN velDot;
 
     SharedPtr<MechanicLinkValue> mParentLink;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/PrismaticJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/PrismaticJoint.cpp	2008-11-21 12:31:29 UTC (rev 767)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/PrismaticJoint.cpp	2008-11-21 12:48:44 UTC (rev 768)
@@ -126,10 +126,10 @@
 
 void
 PrismaticJoint::articulation(MechanicLinkValue& parentLink,
-                            const MechanicLinkValue& childLink,
-                            const ContinousStateValueVector& states,
-                            PortValueList& portValues,
-                            MatrixFactorsNN& hIh) const
+                             const MechanicLinkValue& childLink,
+                             const ContinousStateValueVector& states,
+                             PortValueList& portValues,
+                             MatrixFactorsNN& hIh, Vector6& pAlpha) const
 {
   VectorN jointForce;
   if (mForcePort.empty())
@@ -137,15 +137,16 @@
   else
     jointForce = portValues[mForcePort];
   
-  articulation(parentLink, childLink, jointForce, hIh);
+  articulation(parentLink, childLink, jointForce, hIh, pAlpha);
 }
 
 void
 PrismaticJoint::acceleration(const MechanicLinkValue& parentLink,
-                            MechanicLinkValue& childLink,
-                            const ContinousStateValueVector& states,
-                            PortValueList& portValues,
-                            const MatrixFactorsNN& hIh, VectorN& velDot) const
+                             MechanicLinkValue& childLink,
+                             const ContinousStateValueVector& states,
+                             PortValueList& portValues,
+                             const MatrixFactorsNN& hIh, const Vector6& pAlpha,
+                             VectorN& velDot) const
 {
   VectorN jointForce;
   if (mForcePort.empty())
@@ -153,7 +154,7 @@
   else
     jointForce = portValues[mForcePort];
   
-  acceleration(parentLink, childLink, jointForce, hIh, velDot);
+  acceleration(parentLink, childLink, jointForce, hIh, pAlpha, velDot);
 }
 
 void

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/PrismaticJoint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/PrismaticJoint.h	2008-11-21 12:31:29 UTC (rev 767)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/PrismaticJoint.h	2008-11-21 12:48:44 UTC (rev 768)
@@ -55,12 +55,13 @@
                             const MechanicLinkValue& childLink,
                             const ContinousStateValueVector& states,
                             PortValueList& portValues,
-                            MatrixFactorsNN& hIh) const;
+                            MatrixFactorsNN& hIh, Vector6& pAlpha) const;
   virtual void acceleration(const MechanicLinkValue& parentLink,
                             MechanicLinkValue& childLink,
                             const ContinousStateValueVector& states,
                             PortValueList& portValues,
-                            const MatrixFactorsNN& hIh, VectorN& velDot) const;
+                            const MatrixFactorsNN& hIh, const Vector6& pAlpha,
+                            VectorN& velDot) const;
 
   virtual void derivative(const DiscreteStateValueVector&,
                           const ContinousStateValueVector&,

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.cpp	2008-11-21 12:31:29 UTC (rev 767)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.cpp	2008-11-21 12:48:44 UTC (rev 768)
@@ -131,7 +131,7 @@
                             const MechanicLinkValue& childLink,
                             const ContinousStateValueVector& states,
                             PortValueList& portValues,
-                            MatrixFactorsNN& hIh) const
+                            MatrixFactorsNN& hIh, Vector6& pAlpha) const
 {
   VectorN jointForce;
   if (mForcePort.empty())
@@ -139,7 +139,7 @@
   else
     jointForce = portValues[mForcePort];
   
-  articulation(parentLink, childLink, jointForce, hIh);
+  articulation(parentLink, childLink, jointForce, hIh, pAlpha);
 }
 
 void
@@ -147,7 +147,8 @@
                             MechanicLinkValue& childLink,
                             const ContinousStateValueVector& states,
                             PortValueList& portValues,
-                            const MatrixFactorsNN& hIh, VectorN& velDot) const
+                            const MatrixFactorsNN& hIh, const Vector6& pAlpha,
+                            VectorN& velDot) const
 {
   VectorN jointForce;
   if (mForcePort.empty())
@@ -155,7 +156,7 @@
   else
     jointForce = portValues[mForcePort];
   
-  acceleration(parentLink, childLink, jointForce, hIh, velDot);
+  acceleration(parentLink, childLink, jointForce, hIh, pAlpha, velDot);
 }
 
 void

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.h	2008-11-21 12:31:29 UTC (rev 767)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.h	2008-11-21 12:48:44 UTC (rev 768)
@@ -55,12 +55,13 @@
                             const MechanicLinkValue& childLink,
                             const ContinousStateValueVector& states,
                             PortValueList& portValues,
-                            MatrixFactorsNN& hIh) const;
+                            MatrixFactorsNN& hIh, Vector6& pAlpha) const;
   virtual void acceleration(const MechanicLinkValue& parentLink,
                             MechanicLinkValue& childLink,
                             const ContinousStateValueVector& states,
                             PortValueList& portValues,
-                            const MatrixFactorsNN& hIh, VectorN& velDot) const;
+                            const MatrixFactorsNN& hIh, const Vector6& pAlpha,
+                            VectorN& velDot) const;
 
   virtual void derivative(const DiscreteStateValueVector&,
                           const ContinousStateValueVector&,

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RotationalJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RotationalJoint.cpp	2008-11-21 12:31:29 UTC (rev 767)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RotationalJoint.cpp	2008-11-21 12:48:44 UTC (rev 768)
@@ -109,10 +109,10 @@
 
 void
 RotationalJoint::articulation(MechanicLinkValue& parentLink,
-                            const MechanicLinkValue& childLink,
-                            const ContinousStateValueVector& states,
-                            PortValueList& portValues,
-                            MatrixFactorsNN& hIh) const
+                              const MechanicLinkValue& childLink,
+                              const ContinousStateValueVector& states,
+                              PortValueList& portValues,
+                              MatrixFactorsNN& hIh, Vector6& pAlpha) const
 {
   VectorN jointForce;
   if (mForcePort.empty())
@@ -120,15 +120,16 @@
   else
     jointForce = portValues[mForcePort];
   
-  articulation(parentLink, childLink, jointForce, hIh);
+  articulation(parentLink, childLink, jointForce, hIh, pAlpha);
 }
 
 void
 RotationalJoint::acceleration(const MechanicLinkValue& parentLink,
-                            MechanicLinkValue& childLink,
-                            const ContinousStateValueVector& states,
-                            PortValueList& portValues,
-                            const MatrixFactorsNN& hIh, VectorN& velDot) const
+                              MechanicLinkValue& childLink,
+                              const ContinousStateValueVector& states,
+                              PortValueList& portValues,
+                              const MatrixFactorsNN& hIh, const Vector6& pAlpha,
+                              VectorN& velDot) const
 {
   VectorN jointForce;
   if (mForcePort.empty())
@@ -136,7 +137,7 @@
   else
     jointForce = portValues[mForcePort];
   
-  acceleration(parentLink, childLink, jointForce, hIh, velDot);
+  acceleration(parentLink, childLink, jointForce, hIh, pAlpha, velDot);
 }
 
 void

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RotationalJoint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RotationalJoint.h	2008-11-21 12:31:29 UTC (rev 767)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RotationalJoint.h	2008-11-21 12:48:44 UTC (rev 768)
@@ -52,12 +52,12 @@
                             const MechanicLinkValue& childLink,
                             const ContinousStateValueVector& states,
                             PortValueList& portValues,
-                            MatrixFactorsNN& hIh) const;
+                            MatrixFactorsNN& hIh, Vector6& pAlpha) const;
   virtual void acceleration(const MechanicLinkValue& parentLink,
                             MechanicLinkValue& childLink,
                             const ContinousStateValueVector& states,
                             PortValueList& portValues,
-                            const MatrixFactorsNN& hIh, VectorN& velDot) const;
+                            const MatrixFactorsNN& hIh, const Vector6& pAlpha, VectorN& velDot) const;
 
   virtual void derivative(const DiscreteStateValueVector&,
                           const ContinousStateValueVector&,

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/UniversalJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/UniversalJoint.cpp	2008-11-21 12:31:29 UTC (rev 767)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/UniversalJoint.cpp	2008-11-21 12:48:44 UTC (rev 768)
@@ -137,10 +137,10 @@
 
 void
 UniversalJoint::articulation(MechanicLinkValue& parentLink,
-                            const MechanicLinkValue& childLink,
-                            const ContinousStateValueVector& states,
-                            PortValueList& portValues,
-                            MatrixFactorsNN& hIh) const
+                             const MechanicLinkValue& childLink,
+                             const ContinousStateValueVector& states,
+                             PortValueList& portValues,
+                             MatrixFactorsNN& hIh, Vector6& pAlpha) const
 {
   VectorN jointForce;
   if (mForcePort.empty())
@@ -148,15 +148,16 @@
   else
     jointForce = portValues[mForcePort];
   
-  articulation(parentLink, childLink, jointForce, hIh);
+  articulation(parentLink, childLink, jointForce, hIh, pAlpha);
 }
 
 void
 UniversalJoint::acceleration(const MechanicLinkValue& parentLink,
-                            MechanicLinkValue& childLink,
-                            const ContinousStateValueVector& states,
-                            PortValueList& portValues,
-                            const MatrixFactorsNN& hIh, VectorN& velDot) const
+                             MechanicLinkValue& childLink,
+                             const ContinousStateValueVector& states,
+                             PortValueList& portValues,
+                             const MatrixFactorsNN& hIh, const Vector6& pAlpha,
+                             VectorN& velDot) const
 {
   VectorN jointForce;
   if (mForcePort.empty())
@@ -164,7 +165,7 @@
   else
     jointForce = portValues[mForcePort];
   
-  acceleration(parentLink, childLink, jointForce, hIh, velDot);
+  acceleration(parentLink, childLink, jointForce, hIh, pAlpha, velDot);
 }
 
 void

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/UniversalJoint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/UniversalJoint.h	2008-11-21 12:31:29 UTC (rev 767)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/UniversalJoint.h	2008-11-21 12:48:44 UTC (rev 768)
@@ -55,12 +55,13 @@
                             const MechanicLinkValue& childLink,
                             const ContinousStateValueVector& states,
                             PortValueList& portValues,
-                            MatrixFactorsNN& hIh) const;
+                            MatrixFactorsNN& hIh, Vector6& pAlpha) const;
   virtual void acceleration(const MechanicLinkValue& parentLink,
                             MechanicLinkValue& childLink,
                             const ContinousStateValueVector& states,
                             PortValueList& portValues,
-                            const MatrixFactorsNN& hIh, VectorN& velDot) const;
+                            const MatrixFactorsNN& hIh, const Vector6& pAlpha,
+                            VectorN& velDot) const;
 
   virtual void derivative(const DiscreteStateValueVector&,
                           const ContinousStateValueVector&,



From frohlich at mail.berlios.de  Fri Nov 21 15:19:05 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Fri, 21 Nov 2008 15:19:05 +0100
Subject: [OpenFDM-svn] r769 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811211419.mALEJ55S019048@sheep.berlios.de>

Author: frohlich
Date: 2008-11-21 15:19:05 +0100 (Fri, 21 Nov 2008)
New Revision: 769

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/HDF5SystemOutput.h
Log:
Do not output mechanic links by default.

M    HDF5SystemOutput.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/HDF5SystemOutput.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/HDF5SystemOutput.h	2008-11-21 12:48:44 UTC (rev 768)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/HDF5SystemOutput.h	2008-11-21 14:19:05 UTC (rev 769)
@@ -284,10 +284,11 @@
 
 class HDF5SystemOutput : public SystemOutput {
 public:
-  HDF5SystemOutput(const std::string& filename) :
+  HDF5SystemOutput(const std::string& filename, bool outputMechanics = false) :
     mHDF5File(filename),
     mToplevelGroup(mHDF5File, "System"),
-    mTimeStream(mToplevelGroup, "t", Size(1, 1))
+    mTimeStream(mToplevelGroup, "t", Size(1, 1)),
+    mOutputMechanics(outputMechanics)
   { }
   virtual ~HDF5SystemOutput()
   { }
@@ -305,7 +306,7 @@
     mDumperList.clear();
     if (!system)
       return;
-    Visitor visitor(mToplevelGroup, system);
+    Visitor visitor(mToplevelGroup, system, mOutputMechanics);
     system->getNode()->accept(visitor);
     mDumperList = visitor.mDumperList;
   }
@@ -314,6 +315,7 @@
   HDF5File mHDF5File;
   HDF5Group mToplevelGroup;
   HDFMatrixStream mTimeStream;
+  bool mOutputMechanics;
 
   struct Dumper : public Referenced {
     virtual ~Dumper() {}
@@ -390,9 +392,10 @@
 
   class Visitor : public ConstNodeVisitor {
   public:
-    Visitor(const HDF5Group& group, const System* system) :
+    Visitor(const HDF5Group& group, const System* system, bool outputMechanics) :
       mSystem(system),
-      mCurrentGroup(group)
+      mCurrentGroup(group),
+      mOutputMechanics(outputMechanics)
     { }
     
     SharedPtr<const System> mSystem;
@@ -413,6 +416,8 @@
     }
     virtual void apply(const MechanicLinkInfo& portInfo)
     {
+      if (!mOutputMechanics)
+        return;
       const AbstractNodeInstance* nodeInstance = getNodeInstance(getNodePath());
       if (!nodeInstance)
         return;
@@ -519,6 +524,8 @@
     };
     
     HDF5Group mCurrentGroup;
+
+    bool mOutputMechanics;
     
     UniqueStringSet mCurrentPortValuesUniqueStringSet;
     UniqueStringSet mCurrentGroupUniqueStringSet;



From frohlich at mail.berlios.de  Fri Nov 21 15:19:46 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Fri, 21 Nov 2008 15:19:46 +0100
Subject: [OpenFDM-svn] r770 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811211419.mALEJkFj019117@sheep.berlios.de>

Author: frohlich
Date: 2008-11-21 15:19:45 +0100 (Fri, 21 Nov 2008)
New Revision: 770

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Transform.h
Log:
Fix problems with wrong transforms.

M    MechanicLinkValue.h
M    Transform.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.h	2008-11-21 14:19:05 UTC (rev 769)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.h	2008-11-21 14:19:45 UTC (rev 770)
@@ -18,6 +18,7 @@
   virtual ~AbstractInertial() {}
   virtual Vector3 getAngularVelocity(const real_type& t) const
   { return Vector3::zeros(); }
+//   { return Vector3(0, 0, pi2/(24*60*60)); }
   virtual Vector6 getAcceleration(const real_type& t) const
   { return Vector6::zeros(); }
 };

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Transform.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Transform.h	2008-11-21 14:19:05 UTC (rev 769)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Transform.h	2008-11-21 14:19:45 UTC (rev 770)
@@ -98,7 +98,7 @@
 OpenFDM_FORCE_INLINE Vector6
 angularMotionTo(const Vector3& p, const Rotation& r, const Vector3& v)
 {
-  return Vector6(r.transform(cross(v, p)), Vector3::zeros());
+  return Vector6(r.transform(v), r.transform(cross(v, p)));
 }
 OpenFDM_FORCE_INLINE Vector6
 angularMotionTo(const Rotation& r, const Vector3& v)
@@ -108,7 +108,7 @@
 OpenFDM_FORCE_INLINE Vector6
 angularMotionTo(const Vector3& p, const Vector3& v)
 {
-  return Vector6(cross(v, p), Vector3::zeros());
+  return Vector6(v, cross(v, p));
 }
 
 /** Spatial motion vector transform.



From frohlich at mail.berlios.de  Sun Nov 23 21:28:02 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 23 Nov 2008 21:28:02 +0100
Subject: [OpenFDM-svn] r771 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811232028.mANKS2eV026393@sheep.berlios.de>

Author: frohlich
Date: 2008-11-23 21:28:02 +0100 (Sun, 23 Nov 2008)
New Revision: 771

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.h
Log:
Seperate out environment from its cache.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.h	2008-11-21 14:19:45 UTC (rev 770)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.h	2008-11-23 20:28:02 UTC (rev 771)
@@ -11,7 +11,7 @@
 
 namespace OpenFDM {
 
-class EnvironmentCache;
+class Environment;
 
 class AbstractInertial : public Referenced {
 public:
@@ -27,34 +27,35 @@
 public:
   virtual ~AbstractGravity() {}
   virtual Vector3
-  getGravityAcceleration(const EnvironmentCache&, const Vector3&) const
+  getGravityAcceleration(const Environment&, const Vector3&) const
   { return Vector3(0, 0, 9.81); }
 };
 
 class AbstractWind : public Referenced {
 public:
   virtual ~AbstractWind() {}
-  virtual Vector6 getWindVelocity(const EnvironmentCache&, const Vector3&) const
+  virtual Vector6
+  getWindVelocity(const Environment&, const real_type& t, const Vector3&) const
   { return Vector6::zeros(); }
 };
 
-class EnvironmentCache : public Referenced {
+class Environment : public Referenced {
 public:
-  EnvironmentCache() :
+  Environment() :
     mInertial(new AbstractInertial),
     mGravity(new AbstractGravity),
     mWind(new AbstractWind)
   {
   }
-  EnvironmentCache(const AbstractInertial* inertial,
-                   const AbstractGravity* gravity,
-                   const AbstractWind* wind) :
+  Environment(const AbstractInertial* inertial,
+              const AbstractGravity* gravity,
+              const AbstractWind* wind) :
     mInertial(inertial),
     mGravity(gravity),
     mWind(wind)
   {
   }
-  virtual ~EnvironmentCache() {}
+  virtual ~Environment() {}
 
   // The the global coordinate frames angular velocity and acceleration.
   // Note that the acceleration and velocity must fit together to simulate
@@ -64,40 +65,49 @@
   Vector6 getAcceleration(const real_type& t) const
   { return mInertial->getAcceleration(t); }
 
+  // The gravity acceleration vector in the global coordinate system
+  Vector3 getGravityAcceleration(const Vector3& position) const
+  { return mGravity->getGravityAcceleration(*this, position); }
+
+  // The wind velocity vector in the global coordinate system
+  Vector6 getWindVelocity(const real_type& t, const Vector3& position) const
+  { return mWind->getWindVelocity(*this, t, position); }
+
+private:
+  SharedPtr<const AbstractInertial> mInertial;
+  SharedPtr<const AbstractGravity> mGravity;
+  SharedPtr<const AbstractWind> mWind;
+//   SharedPtr<const AbstractPlanet> mPlanet;
+//   SharedPtr<const AbstractAtmosphere> mAtmosphere;
+//   SharedPtr<const AbstractGround> mGround;
+};
+
+class EnvironmentCache : public Environment {
+public:
+  virtual ~EnvironmentCache() {}
+
   // Sets a new RootJoint position, evaluate environmental stuff
-  void setRootJointPosition(const Vector3& position)
+  void setPosition(const real_type& t, const Vector3& position)
   {
+    mTime = t;
     mRootJointPosition = position;
     mGravityAcceleration = getGravityAcceleration(position);
-    mWindVelocity = getWindVelocity(position);
+    mWindVelocity = getWindVelocity(t, position);
   }
   const Vector3& getRootJointPosition() const
   { return mRootJointPosition; }
 
-  Vector3 getGravityAcceleration(const Vector3& position) const
-  { return mGravity->getGravityAcceleration(*this, position); }
   const Vector3& getGravityAccelerationAtRoot() const
   { return mGravityAcceleration; }
 
-  Vector6 getWindVelocity(const Vector3& position) const
-  { return mWind->getWindVelocity(*this, position); }
   const Vector6& getWindVelocityAtRoot() const
   { return mWindVelocity; }
 
 private:
+  real_type mTime;
   Vector3 mRootJointPosition;
-
-  SharedPtr<const AbstractInertial> mInertial;
-
   Vector3 mGravityAcceleration;
-  SharedPtr<const AbstractGravity> mGravity;
-
   Vector6 mWindVelocity;
-  SharedPtr<const AbstractWind> mWind;
-
-//   SharedPtr<const AbstractPlanet> mPlanet;
-//   SharedPtr<const AbstractAtmosphere> mAtmosphere;
-//   SharedPtr<const AbstractGround> mGround;
 };
 
 



From frohlich at mail.berlios.de  Sun Nov 23 21:28:16 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 23 Nov 2008 21:28:16 +0100
Subject: [OpenFDM-svn] r772 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811232028.mANKSG8o026450@sheep.berlios.de>

Author: frohlich
Date: 2008-11-23 21:28:16 +0100 (Sun, 23 Nov 2008)
New Revision: 772

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/AtmosphereSTD1976.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/AtmosphereSTD1976.h
Log:
Do not use a fixed temperature and pressure.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/AtmosphereSTD1976.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/AtmosphereSTD1976.cpp	2008-11-23 20:28:02 UTC (rev 771)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/AtmosphereSTD1976.cpp	2008-11-23 20:28:16 UTC (rev 772)
@@ -25,7 +25,9 @@
 #define R_HAT           8314.32  // J/kgmol.K (gas const.)
 
 AtmosphereSTD1976::AtmosphereSTD1976(void) :
-  Atmosphere(R_HAT/MOL_WT)
+  Atmosphere(R_HAT/MOL_WT),
+  mSlPressure(101325),
+  mSlTemperature(288.15)
 {
   mTable[0.0] = TableData(288.15, 1.0, -6.5);
   mTable[11.0] = TableData(216.65, 2.233611e-1, 0.0);
@@ -79,21 +81,12 @@
   // density ratio
   sigma = delta/theta;
 
-
-  // Sea level pressure = 101325 N/m2
-  real_type slPressure = 101325;
-  // Sea level temperature = 288.15 K
-  real_type slTemperature = 288.15;
-
-  // Sea leve density of 1.225 kg/m3.
-  real_type slDensity = 1.225;
-
   AtmosphereData data;
 
   // Is aequivalent to one bar.
-  data.pressure = slPressure*delta;
+  data.pressure = mSlPressure*delta;
   // Temperature in kelvin
-  data.temperature = slTemperature*theta;
+  data.temperature = mSlTemperature*theta;
 
   if (fabs(data.temperature) > Limits<real_type>::min())
     data.density = data.pressure / (getGasConstant()*data.temperature);

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/AtmosphereSTD1976.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/AtmosphereSTD1976.h	2008-11-23 20:28:02 UTC (rev 771)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/AtmosphereSTD1976.h	2008-11-23 20:28:16 UTC (rev 772)
@@ -17,12 +17,23 @@
 // http://nssdc.gsfc.nasa.gov/space/model/atmos/atmos_index.html
 // ftp://nssdcftp.gsfc.nasa.gov/models/
 
-class AtmosphereSTD1976
-  : public Atmosphere {
+class AtmosphereSTD1976 : public Atmosphere {
 public:
   AtmosphereSTD1976(void);
   virtual ~AtmosphereSTD1976(void);
 
+  // Sea level pressure, defaults to 101325 N/m2
+  const real_type& getSeaLevelPressure() const
+  { return mSlPressure; }
+  void setSeaLevelPressure(const real_type& pressure)
+  { mSlPressure = pressure; }
+
+  // Sea level temperature, defaults to 288.15 K
+  const real_type& getSeaLevelTemperature() const
+  { return mSlTemperature; }
+  void setSeaLevelTemperature(const real_type& temperature)
+  { mSlTemperature = temperature; }
+
   // Get the atmosphere data for a given height.
   virtual AtmosphereData getData(real_type alt) const;
 private:
@@ -42,6 +53,11 @@
 
   // Should be static, but lacking a good initializer for the map ...
   Table mTable;
+
+  // Sea level pressure
+  real_type mSlPressure;
+  // Sea level temperature
+  real_type mSlTemperature;
 };
 
 } // namespace OpenFDM



From frohlich at mail.berlios.de  Sun Nov 23 21:28:26 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 23 Nov 2008 21:28:26 +0100
Subject: [OpenFDM-svn] r773 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811232028.mANKSQHu026509@sheep.berlios.de>

Author: frohlich
Date: 2008-11-23 21:28:26 +0100 (Sun, 23 Nov 2008)
New Revision: 773

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Environment.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Environment.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
Log:
Move Environment in its implementation file.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Environment.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Environment.cpp	2008-11-23 20:28:16 UTC (rev 772)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Environment.cpp	2008-11-23 20:28:26 UTC (rev 773)
@@ -4,107 +4,17 @@
 
 #include "Environment.h"
 
-#include "Assert.h"
-#include "Object.h"
-#include "EnvironmentObject.h"
-#include "AtmosphereSTD1976.h"
-#include "DefaultGravity.h"
-#include "DefaultGround.h"
-#include "DefaultPlanet.h"
-#include "Turbulence.h"
-#include "Wind.h"
-#include "RootFrame.h"
-
 namespace OpenFDM {
 
-Environment::Environment(void)
+Environment::Environment() :
+  mInertial(new AbstractInertial),
+  mGravity(new AbstractGravity),
+  mWind(new AbstractWind)
 {
-  setAtmosphere(new AtmosphereSTD1976);
-  setGravity(new DefaultGravity);
-  setGround(new DefaultGround);
-  setPlanet(new DefaultPlanet);
-  setWind(new Wind);
-  RootFrame* rootFrame = new RootFrame("Planet centered frame");
-  Vector3 earthRotation(0.0, 0.0, pi2/(60*60*24));
-  rootFrame->setAngularRelVel(earthRotation);
-  setRootFrame(rootFrame);
 }
 
 Environment::~Environment(void)
 {
 }
 
-void
-Environment::setAtmosphere(Atmosphere* atmosphere)
-{
-  detachEnvironmentObject(mAtmosphere);
-  mAtmosphere = atmosphere;
-  attachEnvironmentObject(atmosphere);
-}
-
-void
-Environment::setGravity(Gravity* gravity)
-{
-  detachEnvironmentObject(mGravity);
-  mGravity = gravity;
-  attachEnvironmentObject(gravity);
-}
-
-void
-Environment::setGround(Ground* ground)
-{
-  detachEnvironmentObject(mGround);
-  mGround = ground;
-  attachEnvironmentObject(ground);
-}
-
-void
-Environment::setPlanet(Planet* planet)
-{
-  detachEnvironmentObject(mPlanet);
-  mPlanet = planet;
-  attachEnvironmentObject(planet);
-}
-
-void
-Environment::setTurbulence(Turbulence* turbulence)
-{
-  detachEnvironmentObject(mTurbulence);
-  mTurbulence = turbulence;
-  attachEnvironmentObject(turbulence);
-}
-
-void
-Environment::setWind(Wind* wind)
-{
-  detachEnvironmentObject(mWind);
-  mWind = wind;
-  attachEnvironmentObject(wind);
-}
-
-void
-Environment::setRootFrame(RootFrame* rootFrame)
-{
-  rootFrame->reparentChildren(mRootFrame);
-  mRootFrame = rootFrame;
-}
-
-void
-Environment::attachEnvironmentObject(EnvironmentObject* environmentObject)
-{
-  if (!environmentObject)
-    return;
-
-  environmentObject->attachToEnvironment(this);
-}
-
-void
-Environment::detachEnvironmentObject(EnvironmentObject* environmentObject)
-{
-  if (!environmentObject)
-    return;
-
-  environmentObject->attachToEnvironment(0);
-}
-
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Environment.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Environment.h	2008-11-23 20:28:16 UTC (rev 772)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Environment.h	2008-11-23 20:28:26 UTC (rev 773)
@@ -5,100 +5,69 @@
 #ifndef OpenFDM_Environment_H
 #define OpenFDM_Environment_H
 
-#include "Object.h"
+#include "Matrix.h"
+#include "Referenced.h"
+#include "SharedPtr.h"
+#include "Vector.h"
 
 namespace OpenFDM {
 
-class Atmosphere;
-class Gravity;
-class Ground;
-class Planet;
-class Turbulence;
-class Wind;
-class RootFrame;
+class Environment;
 
-class EnvironmentObject;
+class AbstractInertial : public Referenced {
+public:
+  virtual ~AbstractInertial() {}
+  virtual Vector3 getAngularVelocity(const real_type& t) const
+  { return Vector3::zeros(); }
+//   { return Vector3(0, 0, pi2/(24*60*60)); }
+  virtual Vector6 getAcceleration(const real_type& t) const
+  { return Vector6::zeros(); }
+};
 
-class Environment :
-    public Object {
+class AbstractGravity : public Referenced {
 public:
-  Environment(void);
-  virtual ~Environment(void);
+  virtual ~AbstractGravity() {}
+  virtual Vector3
+  getGravityAcceleration(const Environment&, const Vector3&) const
+  { return Vector3(0, 0, 9.81); }
+};
 
-  /** Set atmosphere model.
-   */
-  void setAtmosphere(Atmosphere* p);
+class AbstractWind : public Referenced {
+public:
+  virtual ~AbstractWind() {}
+  virtual Vector6
+  getWindVelocity(const Environment&, const real_type& t, const Vector3&) const
+  { return Vector6::zeros(); }
+};
 
-  /** Get atmosphere model.
-   */
-  const Atmosphere* getAtmosphere(void) const
-  { return mAtmosphere; }
+class Environment : public Referenced {
+public:
+  Environment();
+  virtual ~Environment();
 
-  /** Set gravity model.
-   */
-  void setGravity(Gravity* g);
+  // The the global coordinate frames angular velocity and acceleration.
+  // Note that the acceleration and velocity must fit together to simulate
+  // something useful.
+  Vector3 getAngularVelocity(const real_type& t) const
+  { return mInertial->getAngularVelocity(t); }
+  Vector6 getAcceleration(const real_type& t) const
+  { return mInertial->getAcceleration(t); }
 
-  /** Get gravity model.
-   */
-  const Gravity* getGravity(void) const
-  { return mGravity; }
+  // The gravity acceleration vector in the global coordinate system
+  Vector3 getGravityAcceleration(const Vector3& position) const
+  { return mGravity->getGravityAcceleration(*this, position); }
 
-  /** Set ground callback.
-   */
-  void setGround(Ground* g);
+  // The wind velocity vector in the global coordinate system
+  Vector6 getWindVelocity(const real_type& t, const Vector3& position) const
+  { return mWind->getWindVelocity(*this, t, position); }
 
-  /** Get ground callback.
-   */
-  const Ground* getGround(void) const
-  { return mGround; }
-
-  /** Set planet callback.
-   */
-  void setPlanet(Planet* p);
-
-  /** Get planet callback.
-   */
-  const Planet* getPlanet(void) const
-  { return mPlanet; }
-
-  /** Set turbulence model.
-   */
-  void setTurbulence(Turbulence* p);
-
-  /** Get turbulence model.
-   */
-  const Turbulence* getTurbulence(void) const
-  { return mTurbulence; }
-
-  /** Set wind callback.
-   */
-  void setWind(Wind* p);
-
-  /** Get wind callback.
-   */
-  const Wind* getWind(void) const
-  { return mWind; }
-
-  /// Set RootFrame
-  void setRootFrame(RootFrame* rootFrame);
-
-  /// Get RootFrame
-  const RootFrame* getRootFrame(void) const
-  { return mRootFrame; }
-  RootFrame* getRootFrame(void)
-  { return mRootFrame; }
-
 private:
-  void attachEnvironmentObject(EnvironmentObject* environmentObject);
-  void detachEnvironmentObject(EnvironmentObject* environmentObject);
-
-  SharedPtr<Atmosphere> mAtmosphere;
-  SharedPtr<Gravity> mGravity;
-  SharedPtr<Ground> mGround;
-  SharedPtr<Planet> mPlanet;
-  SharedPtr<Turbulence> mTurbulence;
-  SharedPtr<Wind> mWind;
-  SharedPtr<RootFrame> mRootFrame;
+  SharedPtr<const AbstractInertial> mInertial;
+  SharedPtr<const AbstractGravity> mGravity;
+  SharedPtr<const AbstractWind> mWind;
+//   SharedPtr<const AbstractPlanet> mPlanet;
+//   SharedPtr<const AbstractAtmosphere> mAtmosphere;
+//   SharedPtr<const AbstractGround> mGround;
 };
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-11-23 20:28:16 UTC (rev 772)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-11-23 20:28:26 UTC (rev 773)
@@ -133,6 +133,7 @@
   ConstNodeVisitor.cpp \
   ContinousStateValue.cpp \
   DoPri5.cpp \
+  Environment.cpp \
   ExplicitAdams.cpp \
   ExplicitEuler.cpp \
   Frame.cpp \
@@ -161,7 +162,6 @@
   NumericPortValue.cpp \
   Object.cpp \
   ODESolver.cpp \
-  Planet.cpp \
   PortInfo.cpp \
   PortValue.cpp \
   RigidBody.cpp \
@@ -173,10 +173,10 @@
   Unit.cpp \
   Variant.cpp
 
-#   Environment.cpp \
 #   EnvironmentObject.cpp \
 #   ReaderWriter.cpp \
 #   Atmosphere.cpp \
+#  Planet.cpp \
 #   AtmosphereSTD1976.cpp \
 #   DefaultGravity.cpp \
 #   DefaultGround.cpp \



From frohlich at mail.berlios.de  Sun Nov 23 21:28:33 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 23 Nov 2008 21:28:33 +0100
Subject: [OpenFDM-svn] r774 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811232028.mANKSXkM026565@sheep.berlios.de>

Author: frohlich
Date: 2008-11-23 21:28:32 +0100 (Sun, 23 Nov 2008)
New Revision: 774

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.h
Log:
Also commit the link value.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.h	2008-11-23 20:28:26 UTC (rev 773)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.h	2008-11-23 20:28:32 UTC (rev 774)
@@ -8,80 +8,10 @@
 #include "Inertia.h"
 #include "PortValue.h"
 #include "Frame.h"
+#include "Environment.h"
 
 namespace OpenFDM {
 
-class Environment;
-
-class AbstractInertial : public Referenced {
-public:
-  virtual ~AbstractInertial() {}
-  virtual Vector3 getAngularVelocity(const real_type& t) const
-  { return Vector3::zeros(); }
-//   { return Vector3(0, 0, pi2/(24*60*60)); }
-  virtual Vector6 getAcceleration(const real_type& t) const
-  { return Vector6::zeros(); }
-};
-
-class AbstractGravity : public Referenced {
-public:
-  virtual ~AbstractGravity() {}
-  virtual Vector3
-  getGravityAcceleration(const Environment&, const Vector3&) const
-  { return Vector3(0, 0, 9.81); }
-};
-
-class AbstractWind : public Referenced {
-public:
-  virtual ~AbstractWind() {}
-  virtual Vector6
-  getWindVelocity(const Environment&, const real_type& t, const Vector3&) const
-  { return Vector6::zeros(); }
-};
-
-class Environment : public Referenced {
-public:
-  Environment() :
-    mInertial(new AbstractInertial),
-    mGravity(new AbstractGravity),
-    mWind(new AbstractWind)
-  {
-  }
-  Environment(const AbstractInertial* inertial,
-              const AbstractGravity* gravity,
-              const AbstractWind* wind) :
-    mInertial(inertial),
-    mGravity(gravity),
-    mWind(wind)
-  {
-  }
-  virtual ~Environment() {}
-
-  // The the global coordinate frames angular velocity and acceleration.
-  // Note that the acceleration and velocity must fit together to simulate
-  // something useful.
-  Vector3 getAngularVelocity(const real_type& t) const
-  { return mInertial->getAngularVelocity(t); }
-  Vector6 getAcceleration(const real_type& t) const
-  { return mInertial->getAcceleration(t); }
-
-  // The gravity acceleration vector in the global coordinate system
-  Vector3 getGravityAcceleration(const Vector3& position) const
-  { return mGravity->getGravityAcceleration(*this, position); }
-
-  // The wind velocity vector in the global coordinate system
-  Vector6 getWindVelocity(const real_type& t, const Vector3& position) const
-  { return mWind->getWindVelocity(*this, t, position); }
-
-private:
-  SharedPtr<const AbstractInertial> mInertial;
-  SharedPtr<const AbstractGravity> mGravity;
-  SharedPtr<const AbstractWind> mWind;
-//   SharedPtr<const AbstractPlanet> mPlanet;
-//   SharedPtr<const AbstractAtmosphere> mAtmosphere;
-//   SharedPtr<const AbstractGround> mGround;
-};
-
 class EnvironmentCache : public Environment {
 public:
   virtual ~EnvironmentCache() {}



From frohlich at mail.berlios.de  Sun Nov 23 21:28:44 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 23 Nov 2008 21:28:44 +0100
Subject: [OpenFDM-svn] r775 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811232028.mANKSi5W026644@sheep.berlios.de>

Author: frohlich
Date: 2008-11-23 21:28:43 +0100 (Sun, 23 Nov 2008)
New Revision: 775

Added:
   branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractGravity.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractGravity.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractInertial.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractInertial.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractWind.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractWind.h
Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Environment.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
Log:
Move the environment components into own implementation files.


Added: branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractGravity.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractGravity.cpp	2008-11-23 20:28:32 UTC (rev 774)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractGravity.cpp	2008-11-23 20:28:43 UTC (rev 775)
@@ -0,0 +1,20 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
+ *
+ */
+
+#include "AbstractGravity.h"
+
+namespace OpenFDM {
+
+AbstractGravity::~AbstractGravity()
+{
+}
+
+Vector3
+AbstractGravity::getGravityAcceleration(const Environment&,
+                                        const Vector3&) const
+{
+  return Vector3(0, 0, 9.81);
+}
+
+} // namespace OpenFDM

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractGravity.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractGravity.h	2008-11-23 20:28:32 UTC (rev 774)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractGravity.h	2008-11-23 20:28:43 UTC (rev 775)
@@ -0,0 +1,24 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_AbstractGravity_H
+#define OpenFDM_AbstractGravity_H
+
+#include "Referenced.h"
+#include "Vector.h"
+
+namespace OpenFDM {
+
+class Environment;
+
+class AbstractGravity : public Referenced {
+public:
+  virtual ~AbstractGravity();
+  virtual Vector3 getGravityAcceleration(const Environment&,
+                                         const Vector3&) const;
+};
+
+} // namespace OpenFDM
+
+#endif

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractInertial.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractInertial.cpp	2008-11-23 20:28:32 UTC (rev 774)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractInertial.cpp	2008-11-23 20:28:43 UTC (rev 775)
@@ -0,0 +1,26 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
+ *
+ */
+
+#include "AbstractInertial.h"
+
+namespace OpenFDM {
+
+AbstractInertial::~AbstractInertial()
+{
+}
+
+Vector3
+AbstractInertial::getAngularVelocity(const real_type& t) const
+{
+  // return Vector3(0, 0, pi2/(24*60*60));
+  return Vector3::zeros();
+}
+
+Vector6
+AbstractInertial::getAcceleration(const real_type& t) const
+{
+  return Vector6::zeros();
+}
+
+} // namespace OpenFDM

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractInertial.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractInertial.h	2008-11-23 20:28:32 UTC (rev 774)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractInertial.h	2008-11-23 20:28:43 UTC (rev 775)
@@ -0,0 +1,22 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_AbstractInertial_H
+#define OpenFDM_AbstractInertial_H
+
+#include "Referenced.h"
+#include "Vector.h"
+
+namespace OpenFDM {
+
+class AbstractInertial : public Referenced {
+public:
+  virtual ~AbstractInertial();
+  virtual Vector3 getAngularVelocity(const real_type& t) const;
+  virtual Vector6 getAcceleration(const real_type& t) const;
+};
+
+} // namespace OpenFDM
+
+#endif

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractWind.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractWind.cpp	2008-11-23 20:28:32 UTC (rev 774)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractWind.cpp	2008-11-23 20:28:43 UTC (rev 775)
@@ -0,0 +1,20 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
+ *
+ */
+
+#include "AbstractWind.h"
+
+namespace OpenFDM {
+
+AbstractWind::~AbstractWind()
+{
+}
+
+Vector6
+AbstractWind::getWindVelocity(const Environment&, const real_type& t,
+                              const Vector3&) const
+{
+  return Vector6::zeros();
+}
+
+} // namespace OpenFDM

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractWind.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractWind.h	2008-11-23 20:28:32 UTC (rev 774)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractWind.h	2008-11-23 20:28:43 UTC (rev 775)
@@ -0,0 +1,24 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_AbstractWind_H
+#define OpenFDM_AbstractWind_H
+
+#include "Referenced.h"
+#include "Vector.h"
+
+namespace OpenFDM {
+
+class Environment;
+
+class AbstractWind : public Referenced {
+public:
+  virtual ~AbstractWind();
+  virtual Vector6 getWindVelocity(const Environment&, const real_type& t,
+                                  const Vector3&) const;
+};
+
+} // namespace OpenFDM
+
+#endif

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Environment.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Environment.h	2008-11-23 20:28:32 UTC (rev 774)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Environment.h	2008-11-23 20:28:43 UTC (rev 775)
@@ -5,6 +5,9 @@
 #ifndef OpenFDM_Environment_H
 #define OpenFDM_Environment_H
 
+#include "AbstractGravity.h"
+#include "AbstractInertial.h"
+#include "AbstractWind.h"
 #include "Matrix.h"
 #include "Referenced.h"
 #include "SharedPtr.h"
@@ -12,34 +15,6 @@
 
 namespace OpenFDM {
 
-class Environment;
-
-class AbstractInertial : public Referenced {
-public:
-  virtual ~AbstractInertial() {}
-  virtual Vector3 getAngularVelocity(const real_type& t) const
-  { return Vector3::zeros(); }
-//   { return Vector3(0, 0, pi2/(24*60*60)); }
-  virtual Vector6 getAcceleration(const real_type& t) const
-  { return Vector6::zeros(); }
-};
-
-class AbstractGravity : public Referenced {
-public:
-  virtual ~AbstractGravity() {}
-  virtual Vector3
-  getGravityAcceleration(const Environment&, const Vector3&) const
-  { return Vector3(0, 0, 9.81); }
-};
-
-class AbstractWind : public Referenced {
-public:
-  virtual ~AbstractWind() {}
-  virtual Vector6
-  getWindVelocity(const Environment&, const real_type& t, const Vector3&) const
-  { return Vector6::zeros(); }
-};
-
 class Environment : public Referenced {
 public:
   Environment();

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-11-23 20:28:32 UTC (rev 774)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-11-23 20:28:43 UTC (rev 775)
@@ -12,10 +12,13 @@
 endif
 
 OpenFDMCoreHEADERS = \
+  AbstractGravity.h \
+  AbstractInertial.h \
   AbstractModel.h \
   AbstractNodeContext.h \
   AbstractNodeInstance.h \
   AbstractSystem.h \
+  AbstractWind.h \
   Assert.h \
   Atomic.h \
   BoolStateInfo.h \
@@ -125,9 +128,12 @@
   XMLDumpModelVisitor.h
 
 OpenFDMCoreSOURCES = \
+  AbstractGravity.cpp \
+  AbstractInertial.cpp \
   AbstractModel.cpp \
   AbstractNodeContext.cpp \
   AbstractNodeInstance.cpp \
+  AbstractWind.cpp \
   Assert.cpp \
   Atomic.cpp \
   ConstNodeVisitor.cpp \



From frohlich at mail.berlios.de  Sun Nov 23 21:28:57 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 23 Nov 2008 21:28:57 +0100
Subject: [OpenFDM-svn] r776 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811232028.mANKSvjv026708@sheep.berlios.de>

Author: frohlich
Date: 2008-11-23 21:28:57 +0100 (Sun, 23 Nov 2008)
New Revision: 776

Added:
   branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractPlanet.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractPlanet.h
Removed:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Planet.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Planet.h
Log:
Move Planet->AbstractPlanet.


Copied: branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractPlanet.cpp (from rev 775, branches/OpenFDM-StateSeparation/src/OpenFDM/Planet.cpp)
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Planet.cpp	2008-11-23 20:28:43 UTC (rev 775)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractPlanet.cpp	2008-11-23 20:28:57 UTC (rev 776)
@@ -0,0 +1,133 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
+ *
+ */
+
+#include "AbstractPlanet.h"
+
+#include <iosfwd>
+
+#include "Types.h"
+#include "Object.h"
+#include "Math.h"
+#include "Vector.h"
+#include "Quaternion.h"
+
+namespace OpenFDM {
+
+AbstractPlanet::AbstractPlanet(void)
+{
+}
+
+AbstractPlanet::~AbstractPlanet(void)
+{
+}
+
+Geocentric
+AbstractPlanet::toGeoc(const Vector3& cart) const
+{
+  real_type lon = (cart(0) == 0 && cart(1) == 0)
+    ? real_type(0) : atan2(cart(1), cart(0));
+  real_type nxy = sqrt(cart(0)*cart(0)+cart(1)*cart(1));
+  real_type lat = (nxy == 0 && cart(2) == 0)
+    ? real_type(0) : atan2(cart(2), nxy);
+  return Geocentric(lat, lon, norm(cart));
+}
+
+Vector3
+AbstractPlanet::toCart(const Geocentric& geoc) const
+{
+  real_type slat = sin(geoc.latitude);
+  real_type clat = cos(geoc.latitude);
+  real_type slon = sin(geoc.longitude);
+  real_type clon = cos(geoc.longitude);
+  return geoc.radius*Vector3( clat*clon, clat*slon, slat );
+}
+
+Geocentric
+AbstractPlanet::toGeoc(const Geodetic& geod) const
+{
+  return toGeoc(toCart(geod));
+}
+
+Geodetic
+AbstractPlanet::toGeod(const Geocentric& geoc) const
+{
+  return toGeod(toCart(geoc));
+}
+
+Quaternion
+AbstractPlanet::getGeodHLOrientation(const Geodetic& pos) const
+{
+  return Quaternion::fromLonLat(pos.longitude, pos.latitude);
+}
+
+Quaternion
+AbstractPlanet::getGeodHLOrientation(const Vector3& pos) const
+{
+  return getGeodHLOrientation(toGeod(pos));
+}
+
+Quaternion
+AbstractPlanet::getGeodHLOrientation(const Geocentric& pos) const
+{
+  return getGeodHLOrientation(toCart(pos));
+}
+
+Quaternion
+AbstractPlanet::getGeocHLOrientation(const Geodetic& pos) const
+{
+  return getGeocHLOrientation(toCart(pos));
+}
+
+Quaternion
+AbstractPlanet::getGeocHLOrientation(const Vector3& pos) const
+{
+  return getGeocHLOrientation(toGeoc(pos));
+}
+
+Quaternion
+AbstractPlanet::getGeocHLOrientation(const Geocentric& pos) const
+{
+  return Quaternion::fromLonLat(pos.longitude, pos.latitude);
+}
+
+Vector3
+AbstractPlanet::getGoecHLRate(const Geocentric& pos, const Vector3& ecVel) const
+{
+  Quaternion hlOrientation = getGeocHLOrientation(pos);
+  Vector3 hlVel = hlOrientation.transform(ecVel);
+  Vector3 hlRate = Vector3(hlVel(1), -hlVel(0), -hlVel(1)*tan(pos.latitude));
+  return hlOrientation.backTransform((1/pos.radius)*hlRate);
+}
+
+Vector3
+AbstractPlanet::getGoecHLRate(const Vector3& pos, const Vector3& ecVel) const
+{
+  return getGoecHLRate(toGeoc(pos), ecVel);
+}
+
+Vector3
+AbstractPlanet::getGoecHLRate(const Geodetic& pos, const Vector3& ecVel) const
+{
+  return getGoecHLRate(toCart(pos), ecVel);
+}
+
+std::ostream&
+operator<<(std::ostream& os, const Geodetic& geod)
+{
+  return os << "[ lon = " << rad2deg*geod.longitude
+            << ", lat = " << rad2deg*geod.latitude
+            << ", alt = " << geod.altitude
+            << " ]";
+}
+
+std::ostream&
+operator<<(std::ostream& os, const Geocentric& geoc)
+{
+  return os << "[ lon = " << rad2deg*geoc.longitude
+            << ", lat = " << rad2deg*geoc.latitude
+            << ", rad = " << geoc.radius
+            << " ]";
+}
+
+} // namespace OpenFDM

Copied: branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractPlanet.h (from rev 775, branches/OpenFDM-StateSeparation/src/OpenFDM/Planet.h)
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Planet.h	2008-11-23 20:28:43 UTC (rev 775)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractPlanet.h	2008-11-23 20:28:57 UTC (rev 776)
@@ -0,0 +1,127 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_Planet_H
+#define OpenFDM_Planet_H
+
+#include <iosfwd>
+
+#include "Types.h"
+#include "Vector.h"
+#include "Quaternion.h"
+#include "Referenced.h"
+
+namespace OpenFDM {
+
+/**
+ * Datatype for the Geodetic position on some ellipsoid.
+ */
+struct Geodetic {
+  Geodetic(real_type lat = 0.0, real_type lon = 0.0, real_type alt = 0.0)
+    : latitude(lat), longitude(lon), altitude(alt)
+  {}
+  real_type latitude;
+  real_type longitude;
+  real_type altitude;
+};
+
+/**
+ * Datatype for a position in speric coordinates.
+ */
+struct Geocentric {
+  Geocentric(real_type lat = 0.0, real_type lon = 0.0, real_type rad = 0.0)
+    : latitude(lat), longitude(lon), radius(rad)
+  {}
+  real_type latitude;
+  real_type longitude;
+  real_type radius;
+};
+
+/**
+ * The Planet class.
+ *
+ * It holds some information about the planet the simulation is running on.
+ */
+class Planet : public Referenced {
+public:
+  /** Default constructor.
+   */
+  Planet(void);
+
+  /** Default destructor.
+   */
+  virtual ~Planet(void);
+
+  /** Transform cartesian coordinates to geodetic coordinates.
+   */
+  virtual Geodetic toGeod(const Vector3& cart) const = 0;
+
+  /** Transform geodetic coordinates to cartesian coordinates.
+   */
+  virtual Vector3 toCart(const Geodetic& geod) const = 0;
+
+  /** Transform cartesian coordinates to geocentric coordinates.
+   */
+  Geocentric toGeoc(const Vector3& cart) const;
+
+  /** Transform geocentric coordinates to cartesian coordinates.
+   */
+  Vector3 toCart(const Geocentric& geoc) const;
+
+  /** Transform geocentric coordinates to geodetic coordinates.
+   */
+  Geocentric toGeoc(const Geodetic& geod) const;
+
+  /** Transform geodetic coordinates to geocentric coordinates.
+   */
+  Geodetic toGeod(const Geocentric& geoc) const;
+
+  /** Orientation of the Geodetic horizontal local frame.
+   */
+  Quaternion getGeodHLOrientation(const Geodetic& pos) const;
+
+  /** Orientation of the Geodetic horizontal local frame.
+   */
+  Quaternion getGeodHLOrientation(const Vector3& pos) const;
+
+  /** Orientation of the Geodetic horizontal local frame.
+   */
+  Quaternion getGeodHLOrientation(const Geocentric& pos) const;
+
+  /** Orientation of the Geocentric horizontal local frame.
+   */
+  Quaternion getGeocHLOrientation(const Geodetic& pos) const;
+
+  /** Orientation of the Geocentric horizontal local frame.
+   */
+  Quaternion getGeocHLOrientation(const Vector3& pos) const;
+
+  /** Orientation of the Geocentric horizontal local frame.
+   */
+  Quaternion getGeocHLOrientation(const Geocentric& pos) const;
+
+  /** Rotation rate of the Geocentric horizontal local frame.
+   */
+  Vector3 getGoecHLRate(const Geocentric& pos, const Vector3& ecVel) const;
+
+  /** Rotation rate of the Geocentric horizontal local frame.
+   */
+  Vector3 getGoecHLRate(const Vector3& pos, const Vector3& ecVel) const;
+
+  /** Rotation rate of the Geocentric horizontal local frame.
+   */
+  Vector3 getGoecHLRate(const Geodetic& pos, const Vector3& ecVel) const;
+};
+
+/** Pretty printing of geodetic coordinates.
+ */
+std::ostream& operator<<(std::ostream& os, const Geodetic& geod);
+
+/** Pretty printing of geocentric coordinates.
+ */
+std::ostream& operator<<(std::ostream& os, const Geocentric& geoc);
+
+} // namespace OpenFDM
+
+#endif

Deleted: branches/OpenFDM-StateSeparation/src/OpenFDM/Planet.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Planet.cpp	2008-11-23 20:28:43 UTC (rev 775)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Planet.cpp	2008-11-23 20:28:57 UTC (rev 776)
@@ -1,133 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
- *
- */
-
-#include "Planet.h"
-
-#include <iosfwd>
-
-#include "Types.h"
-#include "Object.h"
-#include "Math.h"
-#include "Vector.h"
-#include "Quaternion.h"
-
-namespace OpenFDM {
-
-Planet::Planet(void)
-{
-}
-
-Planet::~Planet(void)
-{
-}
-
-Geocentric
-Planet::toGeoc(const Vector3& cart) const
-{
-  real_type lon = (cart(0) == 0 && cart(1) == 0)
-    ? real_type(0) : atan2(cart(1), cart(0));
-  real_type nxy = sqrt(cart(0)*cart(0)+cart(1)*cart(1));
-  real_type lat = (nxy == 0 && cart(2) == 0)
-    ? real_type(0) : atan2(cart(2), nxy);
-  return Geocentric(lat, lon, norm(cart));
-}
-
-Vector3
-Planet::toCart(const Geocentric& geoc) const
-{
-  real_type slat = sin(geoc.latitude);
-  real_type clat = cos(geoc.latitude);
-  real_type slon = sin(geoc.longitude);
-  real_type clon = cos(geoc.longitude);
-  return geoc.radius*Vector3( clat*clon, clat*slon, slat );
-}
-
-Geocentric
-Planet::toGeoc(const Geodetic& geod) const
-{
-  return toGeoc(toCart(geod));
-}
-
-Geodetic
-Planet::toGeod(const Geocentric& geoc) const
-{
-  return toGeod(toCart(geoc));
-}
-
-Quaternion
-Planet::getGeodHLOrientation(const Geodetic& pos) const
-{
-  return Quaternion::fromLonLat(pos.longitude, pos.latitude);
-}
-
-Quaternion
-Planet::getGeodHLOrientation(const Vector3& pos) const
-{
-  return getGeodHLOrientation(toGeod(pos));
-}
-
-Quaternion
-Planet::getGeodHLOrientation(const Geocentric& pos) const
-{
-  return getGeodHLOrientation(toCart(pos));
-}
-
-Quaternion
-Planet::getGeocHLOrientation(const Geodetic& pos) const
-{
-  return getGeocHLOrientation(toCart(pos));
-}
-
-Quaternion
-Planet::getGeocHLOrientation(const Vector3& pos) const
-{
-  return getGeocHLOrientation(toGeoc(pos));
-}
-
-Quaternion
-Planet::getGeocHLOrientation(const Geocentric& pos) const
-{
-  return Quaternion::fromLonLat(pos.longitude, pos.latitude);
-}
-
-Vector3
-Planet::getGoecHLRate(const Geocentric& pos, const Vector3& ecVel) const
-{
-  Quaternion hlOrientation = getGeocHLOrientation(pos);
-  Vector3 hlVel = hlOrientation.transform(ecVel);
-  Vector3 hlRate = Vector3(hlVel(1), -hlVel(0), -hlVel(1)*tan(pos.latitude));
-  return hlOrientation.backTransform((1/pos.radius)*hlRate);
-}
-
-Vector3
-Planet::getGoecHLRate(const Vector3& pos, const Vector3& ecVel) const
-{
-  return getGoecHLRate(toGeoc(pos), ecVel);
-}
-
-Vector3
-Planet::getGoecHLRate(const Geodetic& pos, const Vector3& ecVel) const
-{
-  return getGoecHLRate(toCart(pos), ecVel);
-}
-
-std::ostream&
-operator<<(std::ostream& os, const Geodetic& geod)
-{
-  return os << "[ lon = " << rad2deg*geod.longitude
-            << ", lat = " << rad2deg*geod.latitude
-            << ", alt = " << geod.altitude
-            << " ]";
-}
-
-std::ostream&
-operator<<(std::ostream& os, const Geocentric& geoc)
-{
-  return os << "[ lon = " << rad2deg*geoc.longitude
-            << ", lat = " << rad2deg*geoc.latitude
-            << ", rad = " << geoc.radius
-            << " ]";
-}
-
-} // namespace OpenFDM

Deleted: branches/OpenFDM-StateSeparation/src/OpenFDM/Planet.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Planet.h	2008-11-23 20:28:43 UTC (rev 775)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Planet.h	2008-11-23 20:28:57 UTC (rev 776)
@@ -1,128 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
- *
- */
-
-#ifndef OpenFDM_Planet_H
-#define OpenFDM_Planet_H
-
-#include <iosfwd>
-
-#include "Types.h"
-#include "EnvironmentObject.h"
-#include "Vector.h"
-#include "Quaternion.h"
-
-namespace OpenFDM {
-
-/**
- * Datatype for the Geodetic position on some ellipsoid.
- */
-struct Geodetic {
-  Geodetic(real_type lat = 0.0, real_type lon = 0.0, real_type alt = 0.0)
-    : latitude(lat), longitude(lon), altitude(alt)
-  {}
-  real_type latitude;
-  real_type longitude;
-  real_type altitude;
-};
-
-/**
- * Datatype for a position in speric coordinates.
- */
-struct Geocentric {
-  Geocentric(real_type lat = 0.0, real_type lon = 0.0, real_type rad = 0.0)
-    : latitude(lat), longitude(lon), radius(rad)
-  {}
-  real_type latitude;
-  real_type longitude;
-  real_type radius;
-};
-
-/**
- * The Planet class.
- *
- * It holds some information about the planet the simulation is running on.
- */
-class Planet
-  : public EnvironmentObject {
-public:
-  /** Default constructor.
-   */
-  Planet(void);
-
-  /** Default destructor.
-   */
-  virtual ~Planet(void);
-
-  /** Transform cartesian coordinates to geodetic coordinates.
-   */
-  virtual Geodetic toGeod(const Vector3& cart) const = 0;
-
-  /** Transform geodetic coordinates to cartesian coordinates.
-   */
-  virtual Vector3 toCart(const Geodetic& geod) const = 0;
-
-  /** Transform cartesian coordinates to geocentric coordinates.
-   */
-  Geocentric toGeoc(const Vector3& cart) const;
-
-  /** Transform geocentric coordinates to cartesian coordinates.
-   */
-  Vector3 toCart(const Geocentric& geoc) const;
-
-  /** Transform geocentric coordinates to geodetic coordinates.
-   */
-  Geocentric toGeoc(const Geodetic& geod) const;
-
-  /** Transform geodetic coordinates to geocentric coordinates.
-   */
-  Geodetic toGeod(const Geocentric& geoc) const;
-
-  /** Orientation of the Geodetic horizontal local frame.
-   */
-  Quaternion getGeodHLOrientation(const Geodetic& pos) const;
-
-  /** Orientation of the Geodetic horizontal local frame.
-   */
-  Quaternion getGeodHLOrientation(const Vector3& pos) const;
-
-  /** Orientation of the Geodetic horizontal local frame.
-   */
-  Quaternion getGeodHLOrientation(const Geocentric& pos) const;
-
-  /** Orientation of the Geocentric horizontal local frame.
-   */
-  Quaternion getGeocHLOrientation(const Geodetic& pos) const;
-
-  /** Orientation of the Geocentric horizontal local frame.
-   */
-  Quaternion getGeocHLOrientation(const Vector3& pos) const;
-
-  /** Orientation of the Geocentric horizontal local frame.
-   */
-  Quaternion getGeocHLOrientation(const Geocentric& pos) const;
-
-  /** Rotation rate of the Geocentric horizontal local frame.
-   */
-  Vector3 getGoecHLRate(const Geocentric& pos, const Vector3& ecVel) const;
-
-  /** Rotation rate of the Geocentric horizontal local frame.
-   */
-  Vector3 getGoecHLRate(const Vector3& pos, const Vector3& ecVel) const;
-
-  /** Rotation rate of the Geocentric horizontal local frame.
-   */
-  Vector3 getGoecHLRate(const Geodetic& pos, const Vector3& ecVel) const;
-};
-
-/** Pretty printing of geodetic coordinates.
- */
-std::ostream& operator<<(std::ostream& os, const Geodetic& geod);
-
-/** Pretty printing of geocentric coordinates.
- */
-std::ostream& operator<<(std::ostream& os, const Geocentric& geoc);
-
-} // namespace OpenFDM
-
-#endif



From frohlich at mail.berlios.de  Sun Nov 23 21:29:08 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 23 Nov 2008 21:29:08 +0100
Subject: [OpenFDM-svn] r777 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811232029.mANKT8VS026761@sheep.berlios.de>

Author: frohlich
Date: 2008-11-23 21:29:08 +0100 (Sun, 23 Nov 2008)
New Revision: 777

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractPlanet.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractPlanet.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
Log:
Fixes for the past move.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractPlanet.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractPlanet.cpp	2008-11-23 20:28:57 UTC (rev 776)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractPlanet.cpp	2008-11-23 20:29:08 UTC (rev 777)
@@ -7,7 +7,6 @@
 #include <iosfwd>
 
 #include "Types.h"
-#include "Object.h"
 #include "Math.h"
 #include "Vector.h"
 #include "Quaternion.h"

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractPlanet.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractPlanet.h	2008-11-23 20:28:57 UTC (rev 776)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractPlanet.h	2008-11-23 20:29:08 UTC (rev 777)
@@ -2,8 +2,8 @@
  *
  */
 
-#ifndef OpenFDM_Planet_H
-#define OpenFDM_Planet_H
+#ifndef OpenFDM_AbstractPlanet_H
+#define OpenFDM_AbstractPlanet_H
 
 #include <iosfwd>
 
@@ -43,15 +43,15 @@
  *
  * It holds some information about the planet the simulation is running on.
  */
-class Planet : public Referenced {
+class AbstractPlanet : public Referenced {
 public:
   /** Default constructor.
    */
-  Planet(void);
+  AbstractPlanet(void);
 
   /** Default destructor.
    */
-  virtual ~Planet(void);
+  virtual ~AbstractPlanet(void);
 
   /** Transform cartesian coordinates to geodetic coordinates.
    */

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-11-23 20:28:57 UTC (rev 776)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-11-23 20:29:08 UTC (rev 777)
@@ -17,6 +17,7 @@
   AbstractModel.h \
   AbstractNodeContext.h \
   AbstractNodeInstance.h \
+  AbstractPlanet.h \
   AbstractSystem.h \
   AbstractWind.h \
   Assert.h \
@@ -85,7 +86,6 @@
   OpenFDMConfig.h \
   PhysicalDimension.h \
   Plane.h \
-  Planet.h \
   PortId.h \
   PortInfo.h \
   PortValue.h \
@@ -133,6 +133,7 @@
   AbstractModel.cpp \
   AbstractNodeContext.cpp \
   AbstractNodeInstance.cpp \
+  AbstractPlanet.cpp \
   AbstractWind.cpp \
   Assert.cpp \
   Atomic.cpp \
@@ -182,7 +183,6 @@
 #   EnvironmentObject.cpp \
 #   ReaderWriter.cpp \
 #   Atmosphere.cpp \
-#  Planet.cpp \
 #   AtmosphereSTD1976.cpp \
 #   DefaultGravity.cpp \
 #   DefaultGround.cpp \



From frohlich at mail.berlios.de  Sun Nov 23 21:29:16 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 23 Nov 2008 21:29:16 +0100
Subject: [OpenFDM-svn] r778 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811232029.mANKTGJM026827@sheep.berlios.de>

Author: frohlich
Date: 2008-11-23 21:29:16 +0100 (Sun, 23 Nov 2008)
New Revision: 778

Added:
   branches/OpenFDM-StateSeparation/src/OpenFDM/EllipticPlanet.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/EllipticPlanet.h
Removed:
   branches/OpenFDM-StateSeparation/src/OpenFDM/DefaultPlanet.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/DefaultPlanet.h
Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
Log:
Move DefaultPlanet to EllipticPlanet.


Deleted: branches/OpenFDM-StateSeparation/src/OpenFDM/DefaultPlanet.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/DefaultPlanet.cpp	2008-11-23 20:29:08 UTC (rev 777)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/DefaultPlanet.cpp	2008-11-23 20:29:16 UTC (rev 778)
@@ -1,108 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
- *
- */
-
-#include "DefaultPlanet.h"
-
-#include "Types.h"
-#include "Object.h"
-#include "Unit.h"
-#include "Vector.h"
-#include "Quaternion.h"
-#include "Planet.h"
-
-namespace OpenFDM {
-
-DefaultPlanet::DefaultPlanet(void)
-  : mRotationRate(pi2/(60.0*60.0*24.0))
-{
-  // values taken from simgear
-  setAequatorialRadius(6378137.0);
-  setFlattening(298.257223563);
-
-  // Major semi axis or Aequatorial Radius is called a
-  // Minor semi axis or polar radius is called b.
-  // The the flattening f is defined by f = (a-b)/a.
-  // For our earth these parameters are.
-  //  a = 6378137.0
-  //  b = 6356752.3142
-  //  f = 1/298.257223563
-}
-
-DefaultPlanet::~DefaultPlanet(void)
-{
-}
-
-real_type
-DefaultPlanet::getAequatorialRadius(void) const
-{
-  return a;
-}
-
-void
-DefaultPlanet::setAequatorialRadius(real_type r)
-{
-  a = r;
-  ra2 = 1/(a*a);
-}
-
-void
-DefaultPlanet::setFlattening(real_type flat)
-{
-  real_type squash = 1 - 1/flat;
-  e2 = fabs(1 - squash*squash);
-  e = sqrt(e2);
-  e4 = e2*e2;
-}
-
-Geodetic
-DefaultPlanet::toGeod(const Vector3& cart) const
-{
-  // according to
-  // H. Vermeille,
-  // Direct transformation from geocentric to geodetic ccordinates,
-  // Journal of Geodesy (2002) 76:451-454
-  real_type X = cart(0);
-  real_type Y = cart(1);
-  real_type Z = cart(2);
-  real_type XXpYY = X*X+Y*Y;
-  real_type sqrtXXpYY = sqrt(XXpYY);
-  real_type p = XXpYY*ra2;
-  real_type q = Z*Z*(1-e*e)*ra2;
-  real_type r = 1.0/6.0*(p+q-e4);
-  real_type s = e4*p*q/(4.0*r*r*r);
-  real_type t = pow(1.0+s+sqrt(s*(2.0+s)), real_type(1)/3);
-  real_type u = r*(1.0+t+1.0/t);
-  real_type v = sqrt(u*u+e4*q);
-  real_type w = e2*(u+v-q)/(2.0*v);
-  real_type k = sqrt(u+v+w*w)-w;
-  real_type D = k*sqrtXXpYY/(k+e2);
-  real_type lambda = 2.0*atan2(Y, X+sqrtXXpYY);
-  real_type sqrtDDpZZ = sqrt(D*D+Z*Z);
-  real_type phi = 2.0*atan2(Z, D+sqrtDDpZZ);
-  real_type h = (k+e2-1)*sqrtDDpZZ/k;
-  return Geodetic(phi, lambda, h);
-}
-
-Vector3
-DefaultPlanet::toCart(const Geodetic& geod) const
-{
-  // according to
-  // H. Vermeille,
-  // Direct transformation from geocentric to geodetic ccordinates,
-  // Journal of Geodesy (2002) 76:451-454
-  real_type lambda = geod.longitude;
-  real_type phi = geod.latitude;
-  real_type h = geod.altitude;
-  real_type sphi = sin(phi);
-  real_type n = a/sqrt(1.0-e2*sphi*sphi);
-  real_type cphi = cos(phi);
-  real_type slambda = sin(lambda);
-  real_type clambda = cos(lambda);
-  real_type X = (h+n)*cphi*clambda;
-  real_type Y = (h+n)*cphi*slambda;
-  real_type Z = (h+n-e2*n)*sphi;
-  return Vector3(X, Y, Z);
-}
-
-} // namespace OpenFDM

Deleted: branches/OpenFDM-StateSeparation/src/OpenFDM/DefaultPlanet.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/DefaultPlanet.h	2008-11-23 20:29:08 UTC (rev 777)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/DefaultPlanet.h	2008-11-23 20:29:16 UTC (rev 778)
@@ -1,66 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
- *
- */
-
-#ifndef OpenFDM_DefaultPlanet_H
-#define OpenFDM_DefaultPlanet_H
-
-#include "Types.h"
-#include "Object.h"
-#include "Vector.h"
-#include "Quaternion.h"
-#include "Planet.h"
-
-namespace OpenFDM {
-
-/**
- * The DefaultPlanet class.
- *
- * It holds some information about the planet the simulation is running on.
- */
-class DefaultPlanet
-  : public Planet {
-public:
-  /** Default constructor.
-   */
-  DefaultPlanet(void);
-
-  /** Default destructor.
-   */
-  virtual ~DefaultPlanet(void);
-
-  /** Get aequatorial radius.
-   */
-  real_type getAequatorialRadius(void) const;
-
-  /** Set aequatorial radius.
-   */
-  void setAequatorialRadius(real_type r);
-
-  /** Set planet flattening.
-   */
-  void setFlattening(real_type flat);
-
-  /** Transform cartesian coordinates to geodetic coordinates.
-   */
-  virtual Geodetic toGeod(const Vector3& cart) const;
-
-  /** Transform geodetic coordinates to cartesian coordinates.
-   */
-  virtual Vector3 toCart(const Geodetic& geod) const;
-
-private:
-  /**
-   */
-  real_type a;
-  real_type ra2;
-  real_type e;
-  real_type e2;
-  real_type e4;
-
-  real_type mRotationRate;
-};
-
-} // namespace OpenFDM
-
-#endif

Copied: branches/OpenFDM-StateSeparation/src/OpenFDM/EllipticPlanet.cpp (from rev 777, branches/OpenFDM-StateSeparation/src/OpenFDM/DefaultPlanet.cpp)
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/DefaultPlanet.cpp	2008-11-23 20:29:08 UTC (rev 777)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/EllipticPlanet.cpp	2008-11-23 20:29:16 UTC (rev 778)
@@ -0,0 +1,106 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
+ *
+ */
+
+#include "EllipticPlanet.h"
+
+#include "Types.h"
+#include "Unit.h"
+#include "Vector.h"
+#include "Quaternion.h"
+
+namespace OpenFDM {
+
+EllipticPlanet::EllipticPlanet(void)
+  : mRotationRate(pi2/(60.0*60.0*24.0))
+{
+  // values taken from simgear
+  setAequatorialRadius(6378137.0);
+  setFlattening(298.257223563);
+
+  // Major semi axis or Aequatorial Radius is called a
+  // Minor semi axis or polar radius is called b.
+  // The the flattening f is defined by f = (a-b)/a.
+  // For our earth these parameters are.
+  //  a = 6378137.0
+  //  b = 6356752.3142
+  //  f = 1/298.257223563
+}
+
+EllipticPlanet::~EllipticPlanet(void)
+{
+}
+
+real_type
+EllipticPlanet::getAequatorialRadius(void) const
+{
+  return a;
+}
+
+void
+EllipticPlanet::setAequatorialRadius(real_type r)
+{
+  a = r;
+  ra2 = 1/(a*a);
+}
+
+void
+EllipticPlanet::setFlattening(real_type flat)
+{
+  real_type squash = 1 - 1/flat;
+  e2 = fabs(1 - squash*squash);
+  e = sqrt(e2);
+  e4 = e2*e2;
+}
+
+Geodetic
+EllipticPlanet::toGeod(const Vector3& cart) const
+{
+  // according to
+  // H. Vermeille,
+  // Direct transformation from geocentric to geodetic ccordinates,
+  // Journal of Geodesy (2002) 76:451-454
+  real_type X = cart(0);
+  real_type Y = cart(1);
+  real_type Z = cart(2);
+  real_type XXpYY = X*X+Y*Y;
+  real_type sqrtXXpYY = sqrt(XXpYY);
+  real_type p = XXpYY*ra2;
+  real_type q = Z*Z*(1-e*e)*ra2;
+  real_type r = 1.0/6.0*(p+q-e4);
+  real_type s = e4*p*q/(4.0*r*r*r);
+  real_type t = pow(1.0+s+sqrt(s*(2.0+s)), real_type(1)/3);
+  real_type u = r*(1.0+t+1.0/t);
+  real_type v = sqrt(u*u+e4*q);
+  real_type w = e2*(u+v-q)/(2.0*v);
+  real_type k = sqrt(u+v+w*w)-w;
+  real_type D = k*sqrtXXpYY/(k+e2);
+  real_type lambda = 2.0*atan2(Y, X+sqrtXXpYY);
+  real_type sqrtDDpZZ = sqrt(D*D+Z*Z);
+  real_type phi = 2.0*atan2(Z, D+sqrtDDpZZ);
+  real_type h = (k+e2-1)*sqrtDDpZZ/k;
+  return Geodetic(phi, lambda, h);
+}
+
+Vector3
+EllipticPlanet::toCart(const Geodetic& geod) const
+{
+  // according to
+  // H. Vermeille,
+  // Direct transformation from geocentric to geodetic ccordinates,
+  // Journal of Geodesy (2002) 76:451-454
+  real_type lambda = geod.longitude;
+  real_type phi = geod.latitude;
+  real_type h = geod.altitude;
+  real_type sphi = sin(phi);
+  real_type n = a/sqrt(1.0-e2*sphi*sphi);
+  real_type cphi = cos(phi);
+  real_type slambda = sin(lambda);
+  real_type clambda = cos(lambda);
+  real_type X = (h+n)*cphi*clambda;
+  real_type Y = (h+n)*cphi*slambda;
+  real_type Z = (h+n-e2*n)*sphi;
+  return Vector3(X, Y, Z);
+}
+
+} // namespace OpenFDM

Copied: branches/OpenFDM-StateSeparation/src/OpenFDM/EllipticPlanet.h (from rev 777, branches/OpenFDM-StateSeparation/src/OpenFDM/DefaultPlanet.h)
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/DefaultPlanet.h	2008-11-23 20:29:08 UTC (rev 777)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/EllipticPlanet.h	2008-11-23 20:29:16 UTC (rev 778)
@@ -0,0 +1,64 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_EllipticPlanet_H
+#define OpenFDM_EllipticPlanet_H
+
+#include "Types.h"
+#include "Vector.h"
+#include "Quaternion.h"
+#include "AbstractPlanet.h"
+
+namespace OpenFDM {
+
+/**
+ * The EllipticPlanet class.
+ *
+ * It holds some information about the planet the simulation is running on.
+ */
+class EllipticPlanet : public AbstractPlanet {
+public:
+  /** Elliptic constructor.
+   */
+  EllipticPlanet(void);
+
+  /** Elliptic destructor.
+   */
+  virtual ~EllipticPlanet(void);
+
+  /** Get aequatorial radius.
+   */
+  real_type getAequatorialRadius(void) const;
+
+  /** Set aequatorial radius.
+   */
+  void setAequatorialRadius(real_type r);
+
+  /** Set planet flattening.
+   */
+  void setFlattening(real_type flat);
+
+  /** Transform cartesian coordinates to geodetic coordinates.
+   */
+  virtual Geodetic toGeod(const Vector3& cart) const;
+
+  /** Transform geodetic coordinates to cartesian coordinates.
+   */
+  virtual Vector3 toCart(const Geodetic& geod) const;
+
+private:
+  /**
+   */
+  real_type a;
+  real_type ra2;
+  real_type e;
+  real_type e2;
+  real_type e4;
+
+  real_type mRotationRate;
+};
+
+} // namespace OpenFDM
+
+#endif

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-11-23 20:29:08 UTC (rev 777)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-11-23 20:29:16 UTC (rev 778)
@@ -31,6 +31,7 @@
   CowPtr.h \
   DiscreteStateValueVector.h \
   DoPri5.h \
+  EllipticPlanet.h \
   Environment.h \
   EnvironmentObject.h \
   ExplicitAdams.h \
@@ -140,6 +141,7 @@
   ConstNodeVisitor.cpp \
   ContinousStateValue.cpp \
   DoPri5.cpp \
+  EllipticPlanet.cpp \
   Environment.cpp \
   ExplicitAdams.cpp \
   ExplicitEuler.cpp \
@@ -186,7 +188,6 @@
 #   AtmosphereSTD1976.cpp \
 #   DefaultGravity.cpp \
 #   DefaultGround.cpp \
-#   DefaultPlanet.cpp \
 #   Gravity.cpp \
 #   Ground.cpp
 
@@ -205,7 +206,6 @@
   DeadBand.h \
   DefaultGravity.h \
   DefaultGround.h \
-  DefaultPlanet.h \
   Delay.h \
   DiscBrake.h \
   DiscreteIntegrator.h \



From frohlich at mail.berlios.de  Sun Nov 23 21:29:22 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 23 Nov 2008 21:29:22 +0100
Subject: [OpenFDM-svn] r779 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811232029.mANKTM4l026881@sheep.berlios.de>

Author: frohlich
Date: 2008-11-23 21:29:22 +0100 (Sun, 23 Nov 2008)
New Revision: 779

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/EllipticPlanet.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/EllipticPlanet.h
Log:
Remove rotation rate from the planet.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/EllipticPlanet.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/EllipticPlanet.cpp	2008-11-23 20:29:16 UTC (rev 778)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/EllipticPlanet.cpp	2008-11-23 20:29:22 UTC (rev 779)
@@ -12,7 +12,6 @@
 namespace OpenFDM {
 
 EllipticPlanet::EllipticPlanet(void)
-  : mRotationRate(pi2/(60.0*60.0*24.0))
 {
   // values taken from simgear
   setAequatorialRadius(6378137.0);

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/EllipticPlanet.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/EllipticPlanet.h	2008-11-23 20:29:16 UTC (rev 778)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/EllipticPlanet.h	2008-11-23 20:29:22 UTC (rev 779)
@@ -55,8 +55,6 @@
   real_type e;
   real_type e2;
   real_type e4;
-
-  real_type mRotationRate;
 };
 
 } // namespace OpenFDM



From frohlich at mail.berlios.de  Sun Nov 23 21:29:30 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 23 Nov 2008 21:29:30 +0100
Subject: [OpenFDM-svn] r780 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811232029.mANKTTqW026963@sheep.berlios.de>

Author: frohlich
Date: 2008-11-23 21:29:29 +0100 (Sun, 23 Nov 2008)
New Revision: 780

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractPlanet.h
Log:
Note that this is not an optimal interface for the abstract class.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractPlanet.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractPlanet.h	2008-11-23 20:29:22 UTC (rev 779)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractPlanet.h	2008-11-23 20:29:29 UTC (rev 780)
@@ -38,6 +38,10 @@
   real_type radius;
 };
 
+// FIXME Find out what we need, Move the rest of the elliptic stuff in here
+// into the EllipticPlanet class.
+// We probably only need the altitude computation from the cartesian coordinates
+
 /**
  * The Planet class.
  *



From frohlich at mail.berlios.de  Sun Nov 23 21:29:37 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 23 Nov 2008 21:29:37 +0100
Subject: [OpenFDM-svn] r781 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811232029.mANKTbM0027028@sheep.berlios.de>

Author: frohlich
Date: 2008-11-23 21:29:37 +0100 (Sun, 23 Nov 2008)
New Revision: 781

Added:
   branches/OpenFDM-StateSeparation/src/OpenFDM/FlatPlanet.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/FlatPlanet.h
Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
Log:
Add a flat planet class.


Added: branches/OpenFDM-StateSeparation/src/OpenFDM/FlatPlanet.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/FlatPlanet.cpp	2008-11-23 20:29:29 UTC (rev 780)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/FlatPlanet.cpp	2008-11-23 20:29:37 UTC (rev 781)
@@ -0,0 +1,37 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
+ *
+ */
+
+#include "FlatPlanet.h"
+
+#include "Types.h"
+#include "Unit.h"
+#include "Vector.h"
+
+namespace OpenFDM {
+
+FlatPlanet::FlatPlanet(void)
+{
+}
+
+FlatPlanet::~FlatPlanet(void)
+{
+}
+
+Geodetic
+FlatPlanet::toGeod(const Vector3& cart) const
+{
+  return Geodetic(cart(0)/(111000*rad2deg),
+                  -cart(1)/(111000*rad2deg),
+                  -cart(2));
+}
+
+Vector3
+FlatPlanet::toCart(const Geodetic& geod) const
+{
+  return Vector3(111000*rad2deg*geod.latitude,
+                 -111000*rad2deg*geod.longitude,
+                 -geod.altitude);
+}
+
+} // namespace OpenFDM

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/FlatPlanet.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/FlatPlanet.h	2008-11-23 20:29:29 UTC (rev 780)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/FlatPlanet.h	2008-11-23 20:29:37 UTC (rev 781)
@@ -0,0 +1,40 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_FlatPlanet_H
+#define OpenFDM_FlatPlanet_H
+
+#include "Types.h"
+#include "Vector.h"
+#include "AbstractPlanet.h"
+
+namespace OpenFDM {
+
+/**
+ * The FlatPlanet class.
+ *
+ * Used for simulation where we do not want to move on the whole worlds surface.
+ */
+class FlatPlanet : public AbstractPlanet {
+public:
+  /** Flat constructor.
+   */
+  FlatPlanet(void);
+
+  /** Flat destructor.
+   */
+  virtual ~FlatPlanet(void);
+
+  /** Transform cartesian coordinates to geodetic coordinates.
+   */
+  virtual Geodetic toGeod(const Vector3& cart) const;
+
+  /** Transform geodetic coordinates to cartesian coordinates.
+   */
+  virtual Vector3 toCart(const Geodetic& geod) const;
+};
+
+} // namespace OpenFDM
+
+#endif

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-11-23 20:29:29 UTC (rev 780)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-11-23 20:29:37 UTC (rev 781)
@@ -36,6 +36,7 @@
   EnvironmentObject.h \
   ExplicitAdams.h \
   ExplicitEuler.h \
+  FlatPlanet.h \
   Fraction.h \
   Frame.h \
   Function.h \
@@ -145,6 +146,7 @@
   Environment.cpp \
   ExplicitAdams.cpp \
   ExplicitEuler.cpp \
+  FlatPlanet.cpp \
   Frame.cpp \
   Function.cpp \
   Group.cpp \



From frohlich at mail.berlios.de  Sun Nov 23 21:29:44 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 23 Nov 2008 21:29:44 +0100
Subject: [OpenFDM-svn] r782 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811232029.mANKTiZC027091@sheep.berlios.de>

Author: frohlich
Date: 2008-11-23 21:29:44 +0100 (Sun, 23 Nov 2008)
New Revision: 782

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Environment.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Environment.h
Log:
Use the flat planet by default for the environment.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Environment.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Environment.cpp	2008-11-23 20:29:37 UTC (rev 781)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Environment.cpp	2008-11-23 20:29:44 UTC (rev 782)
@@ -4,12 +4,15 @@
 
 #include "Environment.h"
 
+#include "FlatPlanet.h"
+
 namespace OpenFDM {
 
 Environment::Environment() :
   mInertial(new AbstractInertial),
   mGravity(new AbstractGravity),
-  mWind(new AbstractWind)
+  mWind(new AbstractWind),
+  mPlanet(new FlatPlanet)
 {
 }
 

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Environment.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Environment.h	2008-11-23 20:29:37 UTC (rev 781)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Environment.h	2008-11-23 20:29:44 UTC (rev 782)
@@ -7,6 +7,7 @@
 
 #include "AbstractGravity.h"
 #include "AbstractInertial.h"
+#include "AbstractPlanet.h"
 #include "AbstractWind.h"
 #include "Matrix.h"
 #include "Referenced.h"
@@ -40,7 +41,7 @@
   SharedPtr<const AbstractInertial> mInertial;
   SharedPtr<const AbstractGravity> mGravity;
   SharedPtr<const AbstractWind> mWind;
-//   SharedPtr<const AbstractPlanet> mPlanet;
+  SharedPtr<const AbstractPlanet> mPlanet;
 //   SharedPtr<const AbstractAtmosphere> mAtmosphere;
 //   SharedPtr<const AbstractGround> mGround;
 };



From frohlich at mail.berlios.de  Sun Nov 23 21:41:05 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 23 Nov 2008 21:41:05 +0100
Subject: [OpenFDM-svn] r783 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811232041.mANKf5bK027922@sheep.berlios.de>

Author: frohlich
Date: 2008-11-23 21:41:05 +0100 (Sun, 23 Nov 2008)
New Revision: 783

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/AtmosphereSTD1976.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/AtmosphereSTD1976.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Limits.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
Log:
Various changes in the environmental stuff.

M    src/OpenFDM/AtmosphereSTD1976.h
M    src/OpenFDM/Makefile.am
M    src/OpenFDM/Limits.h
M    src/OpenFDM/AtmosphereSTD1976.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/AtmosphereSTD1976.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/AtmosphereSTD1976.cpp	2008-11-23 20:29:44 UTC (rev 782)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/AtmosphereSTD1976.cpp	2008-11-23 20:41:05 UTC (rev 783)
@@ -8,9 +8,6 @@
 #include "Types.h"
 #include "LogStream.h"
 #include "Math.h"
-#include "Object.h"
-#include "Atmosphere.h"
-#include "Environment.h"
 #include <iostream>
 
 namespace OpenFDM {
@@ -25,7 +22,7 @@
 #define R_HAT           8314.32  // J/kgmol.K (gas const.)
 
 AtmosphereSTD1976::AtmosphereSTD1976(void) :
-  Atmosphere(R_HAT/MOL_WT),
+  AbstractAtmosphere(R_HAT/MOL_WT),
   mSlPressure(101325),
   mSlTemperature(288.15)
 {
@@ -44,8 +41,9 @@
 }
 
 AtmosphereData
-AtmosphereSTD1976::getData(real_type alt) const
+AtmosphereSTD1976::getData(const real_type& altitude) const
 {
+  real_type alt = altitude;
   // We cannot compute data for negative altitudes, just treat them as 0 alt
   if (alt < 0.0)
     alt = 0.0;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/AtmosphereSTD1976.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/AtmosphereSTD1976.h	2008-11-23 20:29:44 UTC (rev 782)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/AtmosphereSTD1976.h	2008-11-23 20:41:05 UTC (rev 783)
@@ -9,7 +9,7 @@
 
 #include "Types.h"
 #include "Object.h"
-#include "Atmosphere.h"
+#include "AbstractAtmosphere.h"
 
 namespace OpenFDM {
 
@@ -17,7 +17,7 @@
 // http://nssdc.gsfc.nasa.gov/space/model/atmos/atmos_index.html
 // ftp://nssdcftp.gsfc.nasa.gov/models/
 
-class AtmosphereSTD1976 : public Atmosphere {
+class AtmosphereSTD1976 : public AbstractAtmosphere {
 public:
   AtmosphereSTD1976(void);
   virtual ~AtmosphereSTD1976(void);
@@ -35,7 +35,7 @@
   { mSlTemperature = temperature; }
 
   // Get the atmosphere data for a given height.
-  virtual AtmosphereData getData(real_type alt) const;
+  virtual AtmosphereData getData(const real_type& alt) const;
 private:
 
   static const real_type mHydrostaticConstant;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Limits.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Limits.h	2008-11-23 20:29:44 UTC (rev 782)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Limits.h	2008-11-23 20:41:05 UTC (rev 783)
@@ -5,6 +5,7 @@
 #ifndef OpenFDM_Limits_H
 #define OpenFDM_Limits_H
 
+#include <algorithm>
 #include <limits>
 
 #include "Types.h"

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-11-23 20:29:44 UTC (rev 782)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-11-23 20:41:05 UTC (rev 783)
@@ -12,6 +12,7 @@
 endif
 
 OpenFDMCoreHEADERS = \
+  AbstractAtmosphere.h \
   AbstractGravity.h \
   AbstractInertial.h \
   AbstractModel.h \
@@ -23,6 +24,7 @@
   Assert.h \
   Atomic.h \
   BoolStateInfo.h \
+  CentralMassGravity.cpp \
   ConstNodeVisitor.h \
   ContinousStateInfo.h \
   ContinousStateInfoVector.h \
@@ -33,7 +35,6 @@
   DoPri5.h \
   EllipticPlanet.h \
   Environment.h \
-  EnvironmentObject.h \
   ExplicitAdams.h \
   ExplicitEuler.h \
   FlatPlanet.h \
@@ -130,7 +131,9 @@
   XMLDumpModelVisitor.h
 
 OpenFDMCoreSOURCES = \
+  AbstractAtmosphere.cpp \
   AbstractGravity.cpp \
+  AbstractGround.cpp \
   AbstractInertial.cpp \
   AbstractModel.cpp \
   AbstractNodeContext.cpp \
@@ -138,6 +141,7 @@
   AbstractPlanet.cpp \
   AbstractWind.cpp \
   Assert.cpp \
+  AtmosphereSTD1976.cpp \
   Atomic.cpp \
   ConstNodeVisitor.cpp \
   ContinousStateValue.cpp \
@@ -184,30 +188,21 @@
   Unit.cpp \
   Variant.cpp
 
-#   EnvironmentObject.cpp \
-#   ReaderWriter.cpp \
-#   Atmosphere.cpp \
-#   AtmosphereSTD1976.cpp \
-#   DefaultGravity.cpp \
-#   DefaultGround.cpp \
-#   Gravity.cpp \
-#   Ground.cpp
+#   ReaderWriter.cpp
 
 
 
 OpenFDMModelsHEADERS = \
   AeroForce.h \
   AirSpring.h \
-  Atmosphere.h \
   AtmosphereSTD1976.h \
   Bias.h \
   BinaryFunction.h \
   CartesianJoint.h \
+  CentralMassGravity.h \
   ConstModel.h \
   Contact.h \
   DeadBand.h \
-  DefaultGravity.h \
-  DefaultGround.h \
   Delay.h \
   DiscBrake.h \
   DiscreteIntegrator.h \
@@ -215,8 +210,6 @@
   FixedRootJoint.h \
   Force.h \
   Gain.h \
-  Gravity.h \
-  Ground.h \
   Input.h \
   Integrator.h \
   Joint.h \



From frohlich at mail.berlios.de  Mon Nov 24 07:08:48 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Mon, 24 Nov 2008 07:08:48 +0100
Subject: [OpenFDM-svn] r784 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811240608.mAO68m18026758@sheep.berlios.de>

Author: frohlich
Date: 2008-11-24 07:08:47 +0100 (Mon, 24 Nov 2008)
New Revision: 784

Added:
   branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractAtmosphere.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractAtmosphere.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractGround.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractGround.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/CentralMassGravity.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/CentralMassGravity.h
Log:
Add some missing files.


Added: branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractAtmosphere.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractAtmosphere.cpp	2008-11-23 20:41:05 UTC (rev 783)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractAtmosphere.cpp	2008-11-24 06:08:47 UTC (rev 784)
@@ -0,0 +1,31 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
+ *
+ */
+
+#include "AbstractAtmosphere.h"
+
+namespace OpenFDM {
+
+AbstractAtmosphere::AbstractAtmosphere(const real_type& gasConstant) :
+  mGasConstant(gasConstant)
+{
+}
+
+AbstractAtmosphere::~AbstractAtmosphere(void)
+{
+}
+
+AtmosphereData
+AbstractAtmosphere::getData(const real_type& alt) const
+{
+  AtmosphereData data;
+  // Sea level pressure = 101325 N/m2
+  data.pressure = 101325;
+  // Sea level temperature = 288.15 K
+  data.temperature = 288.15;
+  // Sea leve density of 1.225 kg/m3.
+  data.density = 1.225;
+  return data;
+}
+
+} // namespace OpenFDM

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractAtmosphere.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractAtmosphere.h	2008-11-23 20:41:05 UTC (rev 783)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractAtmosphere.h	2008-11-24 06:08:47 UTC (rev 784)
@@ -0,0 +1,76 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_AbstractAtmosphere_H
+#define OpenFDM_AbstractAtmosphere_H
+
+#include "Types.h"
+#include "Math.h"
+#include "Referenced.h"
+
+namespace OpenFDM {
+
+struct AtmosphereData {
+  real_type pressure;
+  real_type density;
+  real_type temperature;
+};
+
+class AbstractAtmosphere : public Referenced {
+public:
+  virtual ~AbstractAtmosphere(void);
+
+  /// Returns the gas constant for that current atmosphere gas often refered
+  /// as R. The unit is as usual in the SI system m^2/(s^2 K)
+  real_type getGasConstant(void) const
+  { return mGasConstant; }
+  real_type getR(void) const
+  { return mGasConstant; }
+
+  /// Returns the specific heat ratio
+  real_type getSpecificHeatRatio(real_type temperature) const
+  { return getGamma(temperature); }
+  real_type getGamma(real_type temperature) const
+  {
+    // Taken from SimTurbine, converted to kelvin
+    real_type a = -4.48729540632e-12;
+    real_type b =  4.459750164e-08;
+    real_type c = -1.407342762e-04;
+    real_type d =  1.436914;
+    return ((a*temperature + b)*temperature + c)*temperature + d;
+  }
+  /// Return standard temperature gamma, sufficient for most needs
+  real_type getGamma(void) const
+  { return real_type(1.4); }
+
+  /// Returns the specific heat constant
+  real_type getCp(real_type temperature) const
+  {
+    real_type gamma = getGamma(temperature);
+    return getGasConstant()*gamma/(gamma-1);
+  }
+  /// Returns the specific heat constant for the stdandard temperature
+  real_type getCp(void) const
+  {
+    real_type gamma = getGamma();
+    return getGasConstant()*gamma/(gamma-1);
+  }
+
+  /// Returns the soundspeed for the given temperature
+  real_type getSoundSpeed(real_type temperature) const
+  { return sqrt(getGamma(temperature)*temperature*getGasConstant()); }
+
+  // Get the atmosphere data for a given altitude alt.
+  virtual AtmosphereData getData(const real_type& alt) const;
+
+protected:
+  AbstractAtmosphere(const real_type& gasConstant);
+
+private:
+  real_type mGasConstant;
+};
+
+} // namespace OpenFDM
+
+#endif

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractGround.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractGround.cpp	2008-11-23 20:41:05 UTC (rev 783)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractGround.cpp	2008-11-24 06:08:47 UTC (rev 784)
@@ -0,0 +1,53 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
+ *
+ */
+
+#include "AbstractGround.h"
+
+#include "Types.h"
+#include "Plane.h"
+#include "Environment.h"
+
+namespace OpenFDM {
+
+AbstractGround::AbstractGround(void)
+{
+}
+
+AbstractGround::~AbstractGround(void)
+{
+}
+
+GroundValues
+AbstractGround::getGroundPlane(const Environment& environment,
+                               const real_type& t, const Vector3& refPos) const
+{
+  return GroundValues(environment.getHorizontalLocalPlane(refPos));
+}
+
+bool
+AbstractGround::getCatapultValues(real_type t, const Vector3& refPos,
+                                  CatapultValues& catVal) const
+{
+  return false;
+}
+
+bool
+AbstractGround::caughtWire(const HookPosition& old,
+                           const HookPosition& current) const
+{
+  return false;
+}
+
+bool
+AbstractGround::getWireEnds(real_type t, WireValues& wireVal) const
+{
+  return false;
+}
+
+void
+AbstractGround::releaseWire(void) const
+{
+}
+
+} // namespace OpenFDM

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractGround.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractGround.h	2008-11-23 20:41:05 UTC (rev 783)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractGround.h	2008-11-24 06:08:47 UTC (rev 784)
@@ -0,0 +1,103 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_Ground_H
+#define OpenFDM_Ground_H
+
+#include "Types.h"
+#include "Plane.h"
+#include "Quaternion.h"
+#include "Referenced.h"
+
+namespace OpenFDM {
+
+class Environment;
+
+struct GroundValues {
+  GroundValues(const Plane& p = Plane(), const Vector6& v = Vector6::zeros(),
+               real_type fr = 1) :
+    plane(p), vel(v), friction(fr) {}
+  Plane plane;
+  Vector6 vel;
+  real_type friction;
+};
+
+struct CatapultValues {
+  /// The position of the catapult start in reference coordinates
+  Vector3 position;
+  /// The orientation of the catapult frame
+  Quaternion orientation;
+  /// The spatial velocity of the catapult frame
+  Vector6 velocity;
+  /// The catapult length
+  real_type length;
+};
+
+struct HookPosition {
+  /// The time it is meant for
+  real_type t;
+  /// The hooks base position in reference frames coordinates
+  Vector3 basePosition;
+  /// The hooks direction and length in reference frames coordinates
+  /// That is basePosition + hookVector = hookTip
+  Vector3 hookVector;
+};
+
+struct WireValues {
+  /// The position of the wire midpoint in reference coordinates
+  Vector3 position;
+  /// The orientation of the wire frame
+  Quaternion orientation;
+  /// The spatial velocity of the wire frame
+  Vector6 velocity;
+  /// The wire mounts width, they are assumed to be mounted along the y axis
+  real_type width;
+};
+
+/**
+ * The AbstractGround class.
+ */
+class AbstractGround : public Referenced {
+public:
+  /** Default constructor.
+   */
+  AbstractGround(void);
+
+  /** Default destructor.
+   */
+  virtual ~AbstractGround(void);
+
+  virtual GroundValues
+  getGroundPlane(const Environment&, const real_type& t,
+                 const Vector3& refPos) const;
+
+  /** Returns true if a catapult is within some reasonable range to
+      the reference position. The reference position is usually the
+      position of the launchbar.
+   */
+  virtual bool
+  getCatapultValues(real_type t, const Vector3& refPos,
+                    CatapultValues& catVal) const;
+
+  /** Returns true if we caught a wire while traversing the given rectangle
+      given in reference cordinates.
+   */
+  virtual bool
+  caughtWire(const HookPosition& old, const HookPosition& current) const;
+
+  /** Writes the motions values for the wires we have caught.
+      Returns false if the wires are lost somehow.
+   */
+  virtual bool
+  getWireEnds(real_type t, WireValues& wireVal) const;
+
+  /** Called if the wire values are no longer used.
+   */
+  virtual void
+  releaseWire(void) const;
+};
+
+} // namespace OpenFDM
+
+#endif

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/CentralMassGravity.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/CentralMassGravity.cpp	2008-11-23 20:41:05 UTC (rev 783)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/CentralMassGravity.cpp	2008-11-24 06:08:47 UTC (rev 784)
@@ -0,0 +1,45 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
+ *
+ */
+
+#include "CentralMassGravity.h"
+
+#include "Types.h"
+#include "Object.h"
+#include "Unit.h"
+#include "Vector.h"
+#include "Quaternion.h"
+#include "Gravity.h"
+
+namespace OpenFDM {
+
+CentralMassGravity::CentralMassGravity(void)
+{
+  setPlanetMass(5.9742e24);
+}
+
+CentralMassGravity::~CentralMassGravity(void)
+{
+}
+
+real_type
+CentralMassGravity::getPlanetMass(void) const
+{
+  return mMass;
+}
+
+void
+CentralMassGravity::setPlanetMass(real_type mass)
+{
+  mMass = mass;
+}
+
+Vector3
+CentralMassGravity::getGravityAcceleration(const Environment&,
+                                       const Vector3& cart) const
+{
+  real_type dist = norm(cart);
+  return (-mMass*gravity_constant/(dist*dist*dist))*cart;
+}
+
+} // namespace OpenFDM

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/CentralMassGravity.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/CentralMassGravity.h	2008-11-23 20:41:05 UTC (rev 783)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/CentralMassGravity.h	2008-11-24 06:08:47 UTC (rev 784)
@@ -0,0 +1,48 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_CentralMassGravity_H
+#define OpenFDM_CentralMassGravity_H
+
+#include "Types.h"
+#include "Vector.h"
+#include "AbstractGravity.h"
+
+namespace OpenFDM {
+
+/**
+ * The CentralMassGravity class.
+ *
+ * It holds some information about the gravity the simulation is running on.
+ */
+class CentralMassGravity : public AbstractGravity {
+public:
+  /** CentralMass constructor.
+   */
+  CentralMassGravity(void);
+
+  /** CentralMass destructor.
+   */
+  virtual ~CentralMassGravity(void);
+
+  /** Get planet mass.
+   */
+  real_type getPlanetMass(void) const;
+
+  /** Set planet mass.
+   */
+  void setPlanetMass(real_type mass);
+
+  /** Gravity acceleration at the cartesion position cart.
+   */
+  virtual Vector3 getGravityAcceleration(const Environment&,
+                                         const Vector3&) const;
+
+private:
+  real_type mMass;
+};
+
+} // namespace OpenFDM
+
+#endif



From frohlich at mail.berlios.de  Mon Nov 24 07:09:54 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Mon, 24 Nov 2008 07:09:54 +0100
Subject: [OpenFDM-svn] r785 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811240609.mAO69s59027804@sheep.berlios.de>

Author: frohlich
Date: 2008-11-24 07:09:48 +0100 (Mon, 24 Nov 2008)
New Revision: 785

Removed:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Atmosphere.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Atmosphere.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/DefaultGravity.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/DefaultGravity.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/DefaultGround.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/DefaultGround.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/EnvironmentObject.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/EnvironmentObject.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Gravity.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Gravity.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Ground.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Ground.h
Log:
Remove some obsolete files.


Deleted: branches/OpenFDM-StateSeparation/src/OpenFDM/Atmosphere.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Atmosphere.cpp	2008-11-24 06:08:47 UTC (rev 784)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Atmosphere.cpp	2008-11-24 06:09:48 UTC (rev 785)
@@ -1,18 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
- *
- */
-
-#include "Atmosphere.h"
-
-namespace OpenFDM {
-
-Atmosphere::Atmosphere(real_type gasConstant) :
-  mGasConstant(gasConstant)
-{
-}
-
-Atmosphere::~Atmosphere(void)
-{
-}
-
-} // namespace OpenFDM

Deleted: branches/OpenFDM-StateSeparation/src/OpenFDM/Atmosphere.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Atmosphere.h	2008-11-24 06:08:47 UTC (rev 784)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Atmosphere.h	2008-11-24 06:09:48 UTC (rev 785)
@@ -1,76 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
- *
- */
-
-#ifndef OpenFDM_Atmosphere_H
-#define OpenFDM_Atmosphere_H
-
-#include "Types.h"
-#include "EnvironmentObject.h"
-
-namespace OpenFDM {
-
-struct AtmosphereData {
-  real_type pressure;
-  real_type density;
-  real_type temperature;
-};
-
-class Atmosphere
-  : public EnvironmentObject {
-public:
-  virtual ~Atmosphere(void);
-
-  /// Returns the gas constant for that current atmosphere gas often refered
-  /// as R. The unit is as usual in the SI system m^2/(s^2 K)
-  real_type getGasConstant(void) const
-  { return mGasConstant; }
-  real_type getR(void) const
-  { return mGasConstant; }
-
-  /// Returns the specific heat ratio
-  real_type getSpecificHeatRatio(real_type temperature) const
-  { return getGamma(temperature); }
-  real_type getGamma(real_type temperature) const
-  {
-    // Taken from SimTurbine, converted to kelvin
-    real_type a = -4.48729540632e-12;
-    real_type b =  4.459750164e-08;
-    real_type c = -1.407342762e-04;
-    real_type d =  1.436914;
-    return ((a*temperature + b)*temperature + c)*temperature + d;
-  }
-  /// Return standard temperature gamma, sufficient for most needs
-  real_type getGamma(void) const
-  { return real_type(1.4); }
-
-  /// Returns the specific heat constant
-  real_type getCp(real_type temperature) const
-  {
-    real_type gamma = getGamma(temperature);
-    return getGasConstant()*gamma/(gamma-1);
-  }
-  /// Returns the specific heat constant for the stdandard temperature
-  real_type getCp(void) const
-  {
-    real_type gamma = getGamma();
-    return getGasConstant()*gamma/(gamma-1);
-  }
-
-  /// Returns the soundspeed for the given temperature
-  real_type getSoundSpeed(real_type temperature) const
-  { return sqrt(getGamma(temperature)*temperature*getGasConstant()); }
-
-  // Get the atmosphere data for a given altitude alt.
-  virtual AtmosphereData getData(real_type alt) const = 0;
-
-protected:
-  Atmosphere(real_type gasConstant);
-
-private:
-  real_type mGasConstant;
-};
-
-} // namespace OpenFDM
-
-#endif

Deleted: branches/OpenFDM-StateSeparation/src/OpenFDM/DefaultGravity.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/DefaultGravity.cpp	2008-11-24 06:08:47 UTC (rev 784)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/DefaultGravity.cpp	2008-11-24 06:09:48 UTC (rev 785)
@@ -1,44 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
- *
- */
-
-#include "DefaultGravity.h"
-
-#include "Types.h"
-#include "Object.h"
-#include "Unit.h"
-#include "Vector.h"
-#include "Quaternion.h"
-#include "Gravity.h"
-
-namespace OpenFDM {
-
-DefaultGravity::DefaultGravity(void)
-{
-  setPlanetMass(5.9742e24);
-}
-
-DefaultGravity::~DefaultGravity(void)
-{
-}
-
-real_type
-DefaultGravity::getPlanetMass(void) const
-{
-  return mMass;
-}
-
-void
-DefaultGravity::setPlanetMass(real_type mass)
-{
-  mMass = mass;
-}
-
-Vector3
-DefaultGravity::gravityAccel(const Vector3& cart) const
-{
-  real_type dist = norm(cart);
-  return (-mMass*gravity_constant/(dist*dist*dist))*cart;
-}
-
-} // namespace OpenFDM

Deleted: branches/OpenFDM-StateSeparation/src/OpenFDM/DefaultGravity.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/DefaultGravity.h	2008-11-24 06:08:47 UTC (rev 784)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/DefaultGravity.h	2008-11-24 06:09:48 UTC (rev 785)
@@ -1,48 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
- *
- */
-
-#ifndef OpenFDM_DefaultGravity_H
-#define OpenFDM_DefaultGravity_H
-
-#include "Types.h"
-#include "Vector.h"
-#include "Gravity.h"
-
-namespace OpenFDM {
-
-/**
- * The DefaultGravity class.
- *
- * It holds some information about the gravity the simulation is running on.
- */
-class DefaultGravity
-  : public Gravity {
-public:
-  /** Default constructor.
-   */
-  DefaultGravity(void);
-
-  /** Default destructor.
-   */
-  virtual ~DefaultGravity(void);
-
-  /** Get planet mass.
-   */
-  real_type getPlanetMass(void) const;
-
-  /** Set planet mass.
-   */
-  void setPlanetMass(real_type mass);
-
-  /** Gravity acceleration at the cartesion position cart.
-   */
-  virtual Vector3 gravityAccel(const Vector3& cart) const;
-
-private:
-  real_type mMass;
-};
-
-} // namespace OpenFDM
-
-#endif

Deleted: branches/OpenFDM-StateSeparation/src/OpenFDM/DefaultGround.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/DefaultGround.cpp	2008-11-24 06:08:47 UTC (rev 784)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/DefaultGround.cpp	2008-11-24 06:09:48 UTC (rev 785)
@@ -1,44 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
- *
- */
-
-#include "DefaultGround.h"
-
-#include "Types.h"
-#include "Object.h"
-#include "Plane.h"
-#include "Frame.h"
-#include "Planet.h"
-#include "Environment.h"
-#include "Ground.h"
-
-namespace OpenFDM {
-
-DefaultGround::DefaultGround(void)
-{
-}
-
-DefaultGround::~DefaultGround(void)
-{
-}
-
-GroundValues
-DefaultGround::getGroundPlane(real_type, const Vector3& refPos) const
-{
-  // The default implementation just uses the reference ellipsoid as ground.
-  const Planet* planet = getEnvironment()->getPlanet();
-
-  // Get the unit down vector.
-  Quaternion hlOr = planet->getGeodHLOrientation(refPos);
-  Vector3 unitDown = hlOr.backTransform(Vector3::unit(3));
-  
-  // Get the distance from the planets center.
-  Geodetic geod = planet->toGeod(refPos);
-  geod.altitude = 0;
-  Vector3 groundOff = planet->toCart(geod);
-
-  // Build up and return the aprioriate plane.
-  return GroundValues(Plane(unitDown, groundOff));
-}
-
-} // namespace OpenFDM

Deleted: branches/OpenFDM-StateSeparation/src/OpenFDM/DefaultGround.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/DefaultGround.h	2008-11-24 06:08:47 UTC (rev 784)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/DefaultGround.h	2008-11-24 06:09:48 UTC (rev 785)
@@ -1,37 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
- *
- */
-
-#ifndef OpenFDM_DefaultGround_H
-#define OpenFDM_DefaultGround_H
-
-#include "Types.h"
-#include "Object.h"
-#include "Plane.h"
-#include "Ground.h"
-
-namespace OpenFDM {
-
-class Environment;
-
-/**
- * The DefaultGround class.
- */
-class DefaultGround
-  : public Ground {
-public:
-  /** Default constructor.
-   */
-  DefaultGround();
-
-  /** Default destructor.
-   */
-  virtual ~DefaultGround(void);
-
-  virtual GroundValues
-  getGroundPlane(real_type t, const Vector3& refPos) const;
-};
-
-} // namespace OpenFDM
-
-#endif

Deleted: branches/OpenFDM-StateSeparation/src/OpenFDM/EnvironmentObject.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/EnvironmentObject.cpp	2008-11-24 06:08:47 UTC (rev 784)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/EnvironmentObject.cpp	2008-11-24 06:09:48 UTC (rev 785)
@@ -1,25 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
- *
- */
-
-#include "EnvironmentObject.h"
-#include "Object.h"
-#include "Environment.h"
-
-namespace OpenFDM {
-
-EnvironmentObject::EnvironmentObject(void)
-{
-}
-
-EnvironmentObject::~EnvironmentObject(void)
-{
-}
-
-void
-EnvironmentObject::attachToEnvironment(Environment* environment)
-{
-  mEnvironment = environment;
-}
-
-} // namespace OpenFDM

Deleted: branches/OpenFDM-StateSeparation/src/OpenFDM/EnvironmentObject.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/EnvironmentObject.h	2008-11-24 06:08:47 UTC (rev 784)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/EnvironmentObject.h	2008-11-24 06:09:48 UTC (rev 785)
@@ -1,35 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
- *
- */
-
-#ifndef OpenFDM_EnvironmentObject_H
-#define OpenFDM_EnvironmentObject_H
-
-#include "Object.h"
-#include "WeakPtr.h"
-#include "Environment.h"
-
-namespace OpenFDM {
-
-class EnvironmentObject :
-    public Object {
-public:
-  EnvironmentObject(void);
-  virtual ~EnvironmentObject(void);
-
-  SharedPtr<Environment> getEnvironment(void)
-  { return mEnvironment.lock(); }
-  SharedPtr<const Environment> getEnvironment(void) const
-  { return mEnvironment.lock(); }
-
-private:
-  void attachToEnvironment(Environment* environment);
-
-  WeakPtr<Environment> mEnvironment;
-
-  friend class Environment;
-};
-
-} // namespace OpenFDM
-
-#endif

Deleted: branches/OpenFDM-StateSeparation/src/OpenFDM/Gravity.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Gravity.cpp	2008-11-24 06:08:47 UTC (rev 784)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Gravity.cpp	2008-11-24 06:09:48 UTC (rev 785)
@@ -1,17 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
- *
- */
-
-#include "Gravity.h"
-
-namespace OpenFDM {
-
-Gravity::Gravity(void)
-{
-}
-
-Gravity::~Gravity(void)
-{
-}
-
-} // namespace OpenFDM

Deleted: branches/OpenFDM-StateSeparation/src/OpenFDM/Gravity.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Gravity.h	2008-11-24 06:08:47 UTC (rev 784)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Gravity.h	2008-11-24 06:09:48 UTC (rev 785)
@@ -1,35 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
- *
- */
-
-#ifndef OpenFDM_Gravity_H
-#define OpenFDM_Gravity_H
-
-#include "Types.h"
-#include "EnvironmentObject.h"
-#include "Vector.h"
-
-namespace OpenFDM {
-
-/**
- * The Gravity class.
- */
-class Gravity
-  : public EnvironmentObject {
-public:
-  /** Default constructor.
-   */
-  Gravity(void);
-
-  /** Default destructor.
-   */
-  virtual ~Gravity(void);
-
-  /** Gravity acceleration at the cartesion position cart.
-   */
-  virtual Vector3 gravityAccel(const Vector3& cart) const = 0;
-};
-
-} // namespace OpenFDM
-
-#endif

Deleted: branches/OpenFDM-StateSeparation/src/OpenFDM/Ground.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Ground.cpp	2008-11-24 06:08:47 UTC (rev 784)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Ground.cpp	2008-11-24 06:09:48 UTC (rev 785)
@@ -1,48 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
- *
- */
-
-#include "Ground.h"
-
-#include "Types.h"
-#include "Object.h"
-#include "Plane.h"
-#include "Frame.h"
-#include "Planet.h"
-#include "Environment.h"
-
-namespace OpenFDM {
-
-Ground::Ground(void)
-{
-}
-
-Ground::~Ground(void)
-{
-}
-
-bool
-Ground::getCatapultValues(real_type t, const Vector3& refPos,
-                          CatapultValues& catVal) const
-{
-  return false;
-}
-
-bool
-Ground::caughtWire(const HookPosition& old, const HookPosition& current) const
-{
-  return false;
-}
-
-bool
-Ground::getWireEnds(real_type t, WireValues& wireVal) const
-{
-  return false;
-}
-
-void
-Ground::releaseWire(void) const
-{
-}
-
-} // namespace OpenFDM

Deleted: branches/OpenFDM-StateSeparation/src/OpenFDM/Ground.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Ground.h	2008-11-24 06:08:47 UTC (rev 784)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Ground.h	2008-11-24 06:09:48 UTC (rev 785)
@@ -1,101 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
- *
- */
-
-#ifndef OpenFDM_Ground_H
-#define OpenFDM_Ground_H
-
-#include "Types.h"
-#include "EnvironmentObject.h"
-#include "Plane.h"
-#include "Quaternion.h"
-
-namespace OpenFDM {
-
-struct GroundValues {
-  GroundValues(const Plane& p = Plane(), const Vector6& v = Vector6::zeros(),
-               real_type fr = 1) :
-    plane(p), vel(v), friction(fr) {}
-  Plane plane;
-  Vector6 vel;
-  real_type friction;
-};
-
-struct CatapultValues {
-  /// The position of the catapult start in reference coordinates
-  Vector3 position;
-  /// The orientation of the catapult frame
-  Quaternion orientation;
-  /// The spatial velocity of the catapult frame
-  Vector6 velocity;
-  /// The catapult length
-  real_type length;
-};
-
-struct HookPosition {
-  /// The time it is meant for
-  real_type t;
-  /// The hooks base position in reference frames coordinates
-  Vector3 basePosition;
-  /// The hooks direction and length in reference frames coordinates
-  /// That is basePosition + hookVector = hookTip
-  Vector3 hookVector;
-};
-
-struct WireValues {
-  /// The position of the wire midpoint in reference coordinates
-  Vector3 position;
-  /// The orientation of the wire frame
-  Quaternion orientation;
-  /// The spatial velocity of the wire frame
-  Vector6 velocity;
-  /// The wire mounts width, they are assumed to be mounted along the y axis
-  real_type width;
-};
-
-/**
- * The Ground class.
- */
-class Ground
-  : public EnvironmentObject {
-public:
-  /** Default constructor.
-   */
-  Ground(void);
-
-  /** Default destructor.
-   */
-  virtual ~Ground(void);
-
-  virtual GroundValues
-  getGroundPlane(real_type t, const Vector3& refPos) const = 0;
-
-  /** Returns true if a catapult is within some reasonable range to
-      the reference position. The reference position is usually the
-      position of the launchbar.
-   */
-  virtual bool
-  getCatapultValues(real_type t, const Vector3& refPos,
-                    CatapultValues& catVal) const;
-
-  /** Returns true if we caught a wire while traversing the given rectangle
-      given in reference cordinates.
-   */
-  virtual bool
-  caughtWire(const HookPosition& old, const HookPosition& current) const;
-
-  /** Writes the motions values for the wires we have caught.
-      Returns false if the wires are lost somehow.
-   */
-  virtual bool
-  getWireEnds(real_type t, WireValues& wireVal) const;
-
-  /** Called if the wire values are no longer used.
-   */
-  virtual void
-  releaseWire(void) const;
-};
-
-} // namespace OpenFDM
-
-#endif



From frohlich at mail.berlios.de  Mon Nov 24 07:12:14 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Mon, 24 Nov 2008 07:12:14 +0100
Subject: [OpenFDM-svn] r786 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811240612.mAO6CEWe029561@sheep.berlios.de>

Author: frohlich
Date: 2008-11-24 07:12:10 +0100 (Mon, 24 Nov 2008)
New Revision: 786

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Environment.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Environment.h
Log:
Update to match the other files.
Duh, should now be again up to date past the git-svn problems ...

M    Environment.cpp
M    Environment.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Environment.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Environment.cpp	2008-11-24 06:09:48 UTC (rev 785)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Environment.cpp	2008-11-24 06:12:10 UTC (rev 786)
@@ -5,6 +5,7 @@
 #include "Environment.h"
 
 #include "FlatPlanet.h"
+#include "AtmosphereSTD1976.h"
 
 namespace OpenFDM {
 
@@ -12,7 +13,9 @@
   mInertial(new AbstractInertial),
   mGravity(new AbstractGravity),
   mWind(new AbstractWind),
-  mPlanet(new FlatPlanet)
+  mPlanet(new FlatPlanet),
+  mAtmosphere(new AtmosphereSTD1976),
+  mGround(new AbstractGround)
 {
 }
 

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Environment.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Environment.h	2008-11-24 06:09:48 UTC (rev 785)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Environment.h	2008-11-24 06:12:10 UTC (rev 786)
@@ -5,11 +5,14 @@
 #ifndef OpenFDM_Environment_H
 #define OpenFDM_Environment_H
 
+#include "AbstractAtmosphere.h"
 #include "AbstractGravity.h"
+#include "AbstractGround.h"
 #include "AbstractInertial.h"
 #include "AbstractPlanet.h"
 #include "AbstractWind.h"
 #include "Matrix.h"
+#include "Plane.h"
 #include "Referenced.h"
 #include "SharedPtr.h"
 #include "Vector.h"
@@ -21,6 +24,10 @@
   Environment();
   virtual ~Environment();
 
+  ///////////////////////////////////////////////////////////////////////////
+  // Inertial related
+  // FIXME may be this can be split out???
+
   // The the global coordinate frames angular velocity and acceleration.
   // Note that the acceleration and velocity must fit together to simulate
   // something useful.
@@ -29,21 +36,70 @@
   Vector6 getAcceleration(const real_type& t) const
   { return mInertial->getAcceleration(t); }
 
+  ///////////////////////////////////////////////////////////////////////////
+  // Gravity related
+
   // The gravity acceleration vector in the global coordinate system
   Vector3 getGravityAcceleration(const Vector3& position) const
   { return mGravity->getGravityAcceleration(*this, position); }
 
+  ///////////////////////////////////////////////////////////////////////////
+  // Wind sensing related
+
   // The wind velocity vector in the global coordinate system
   Vector6 getWindVelocity(const real_type& t, const Vector3& position) const
   { return mWind->getWindVelocity(*this, t, position); }
 
+  ///////////////////////////////////////////////////////////////////////////
+  // Planet related
+  // FIXME: find out what we really need here, may be some kind of
+  // abstract horizontal local coordinates?
+  // Is responsible for altitude computations ...
+
+  // From the planet these are so far what we need.
+  // FIXME, invent an abstraction for that, may be optimize???
+protected:
+  Vector3 getHorizontalLocalDown(const Vector3& position) const
+  {
+    Quaternion hlOr = mPlanet->getGeodHLOrientation(position);
+    return hlOr.backTransform(Vector3::unit(3));
+  }
+  Vector3 getHorizontalLocalOffset(const Vector3& position) const
+  {
+    Geodetic geod = mPlanet->toGeod(position);
+    geod.altitude = 0;
+    return mPlanet->toCart(geod);
+  }
+public:
+  Plane getHorizontalLocalPlane(const Vector3& position) const
+  {
+    // Get the unit down vector.
+    Vector3 unitDown = getHorizontalLocalDown(position);
+    // Get the distance from the planets center.
+    Vector3 groundOff = getHorizontalLocalOffset(position);
+    // Then we know the plane ...
+    return Plane(unitDown, groundOff);
+  }
+
+  ///////////////////////////////////////////////////////////////////////////
+  // Atmosphere sensing related
+  AtmosphereData getAtmosphereData(const Vector3& position) const
+  {
+    Geodetic geod = mPlanet->toGeod(position);
+    return mAtmosphere->getData(geod.altitude);
+  }
+
+  ///////////////////////////////////////////////////////////////////////////
+  // Intersection interaction related
+
+
 private:
   SharedPtr<const AbstractInertial> mInertial;
   SharedPtr<const AbstractGravity> mGravity;
   SharedPtr<const AbstractWind> mWind;
   SharedPtr<const AbstractPlanet> mPlanet;
-//   SharedPtr<const AbstractAtmosphere> mAtmosphere;
-//   SharedPtr<const AbstractGround> mGround;
+  SharedPtr<const AbstractAtmosphere> mAtmosphere;
+  SharedPtr<const AbstractGround> mGround;
 };
 
 } // namespace OpenFDM



From frohlich at mail.berlios.de  Mon Nov 24 07:23:00 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Mon, 24 Nov 2008 07:23:00 +0100
Subject: [OpenFDM-svn] r787 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811240623.mAO6N0Gt016096@sheep.berlios.de>

Author: frohlich
Date: 2008-11-24 07:22:59 +0100 (Mon, 24 Nov 2008)
New Revision: 787

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.h
Log:
Add Atmospheric sensing.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.cpp	2008-11-24 06:12:10 UTC (rev 786)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.cpp	2008-11-24 06:22:59 UTC (rev 787)
@@ -18,6 +18,8 @@
   DEF_OPENFDM_PROPERTY(Bool, EnableLinearVelocity, Serialized)
   DEF_OPENFDM_PROPERTY(Bool, EnableAngularVelocity, Serialized)
   DEF_OPENFDM_PROPERTY(Bool, EnableCentrifugalAcceleration, Serialized)
+  DEF_OPENFDM_PROPERTY(Bool, EnableTemperature, Serialized)
+  DEF_OPENFDM_PROPERTY(Bool, EnablePressure, Serialized)
   END_OPENFDM_OBJECT_DEF
 
 Sensor::Sensor(const std::string& name) :
@@ -40,6 +42,8 @@
 Sensor::velocity(const Task&, const ContinousStateValueVector&,
                  PortValueList& portValues) const
 {
+  const Environment* environment;
+  environment = portValues[mMechanicLink].getEnvironment();
   const Frame& frame = portValues[mMechanicLink].getFrame();
 
   // FIXME, for now relative position
@@ -61,6 +65,17 @@
 
   if (getEnableLinearVelocity())
     portValues[mLinearVelocityPort] = refVelocity.getLinear();
+
+  // Atmosphere related sensing
+  bool enableTemperature = getEnableTemperature();
+  bool enablePressure = getEnablePressure();
+  if (enableTemperature || enablePressure) {
+    AtmosphereData data = environment->getAtmosphereData(refPosition);
+    if (enableTemperature)
+      portValues[mTemperaturePort] = data.temperature;
+    if (enablePressure)
+      portValues[mPressurePort] = data.pressure;
+  }
 }
 
 void
@@ -201,4 +216,38 @@
   return !mCentrifugalAccelerationPort.empty();
 }
 
+void
+Sensor::setEnableTemperature(bool enable)
+{
+  if (enable == getEnableTemperature())
+    return;
+  if (enable)
+    mTemperaturePort = RealOutputPort(this, "temperature");
+  else
+    mTemperaturePort.clear();
+}
+
+bool
+Sensor::getEnableTemperature() const
+{
+  return !mTemperaturePort.empty();
+}
+
+void
+Sensor::setEnablePressure(bool enable)
+{
+  if (enable == getEnablePressure())
+    return;
+  if (enable)
+    mPressurePort = RealOutputPort(this, "pressure");
+  else
+    mPressurePort.clear();
+}
+
+bool
+Sensor::getEnablePressure() const
+{
+  return !mPressurePort.empty();
+}
+
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.h	2008-11-24 06:12:10 UTC (rev 786)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.h	2008-11-24 06:22:59 UTC (rev 787)
@@ -8,6 +8,7 @@
 #include "Interact.h"
 #include "MatrixOutputPort.h"
 #include "MechanicLink.h"
+#include "RealOutputPort.h"
 #include "Vector.h"
 
 namespace OpenFDM {
@@ -59,6 +60,17 @@
   /// Get availabilty of the linear acceleration output port
   bool getEnableCentrifugalAcceleration() const;
 
+
+  /// Set availabilty of the temperature output port
+  void setEnableTemperature(bool enable);
+  /// Get availabilty of the temperature output port
+  bool getEnableTemperature() const;
+
+  /// Set availabilty of the pressure output port
+  void setEnablePressure(bool enable);
+  /// Get availabilty of the pressure output port
+  bool getEnablePressure() const;
+
 private:
   MechanicLink mMechanicLink;
 
@@ -72,6 +84,10 @@
   MatrixOutputPort mAngularVelocityPort;
 
   MatrixOutputPort mCentrifugalAccelerationPort;
+
+  RealOutputPort mTemperaturePort;
+  RealOutputPort mPressurePort;
+//   RealOutputPort mDensityPort;
 };
 
 } // namespace OpenFDM



From frohlich at mail.berlios.de  Mon Nov 24 07:24:24 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Mon, 24 Nov 2008 07:24:24 +0100
Subject: [OpenFDM-svn] r788 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811240624.mAO6OOMh017451@sheep.berlios.de>

Author: frohlich
Date: 2008-11-24 07:24:23 +0100 (Mon, 24 Nov 2008)
New Revision: 788

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.cpp
Log:
Conditinally enable velocity computations.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.cpp	2008-11-24 06:22:59 UTC (rev 787)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.cpp	2008-11-24 06:24:23 UTC (rev 788)
@@ -59,13 +59,18 @@
   if (getEnableEulerAngles())
     portValues[mEulerAnglesPort] = frame.getRefOrientation().getEuler();
 
-  Vector6 refVelocity = frame.getRefVelAt(position);
-  if (getEnableAngularVelocity())
-    portValues[mAngularVelocityPort] = refVelocity.getAngular();
+  // Velocity related sensing
+  bool enableAngularVelocity = getEnableAngularVelocity();
+  bool enableLinearVelocity = getEnableLinearVelocity();
+  if (enableAngularVelocity || enableLinearVelocity) {
+    Vector6 refVelocity = frame.getRefVelAt(position);
+    if (enableAngularVelocity)
+      portValues[mAngularVelocityPort] = refVelocity.getAngular();
+    
+    if (enableLinearVelocity)
+      portValues[mLinearVelocityPort] = refVelocity.getLinear();
+  }
 
-  if (getEnableLinearVelocity())
-    portValues[mLinearVelocityPort] = refVelocity.getLinear();
-
   // Atmosphere related sensing
   bool enableTemperature = getEnableTemperature();
   bool enablePressure = getEnablePressure();



From frohlich at mail.berlios.de  Mon Nov 24 18:46:42 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Mon, 24 Nov 2008 18:46:42 +0100
Subject: [OpenFDM-svn] r789 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200811241746.mAOHkgob011297@sheep.berlios.de>

Author: frohlich
Date: 2008-11-24 18:46:39 +0100 (Mon, 24 Nov 2008)
New Revision: 789

Added:
   branches/OpenFDM-StateSeparation/src/test/linalg.cpp
Modified:
   branches/OpenFDM-StateSeparation/src/test/Makefile.am
Log:
Add a matrix solver test.

AM   test/linalg.cpp
M    test/Makefile.am


Modified: branches/OpenFDM-StateSeparation/src/test/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/Makefile.am	2008-11-24 06:24:23 UTC (rev 788)
+++ branches/OpenFDM-StateSeparation/src/test/Makefile.am	2008-11-24 17:46:39 UTC (rev 789)
@@ -6,7 +6,7 @@
 
 # define some unit tests
 #check_PROGRAMS = quattest unitstest structure simulationtime constintegral harmonic limit
-check_PROGRAMS = quattest unitstest simulationtime limit
+check_PROGRAMS = quattest unitstest simulationtime limit linalg
 TESTS          = $(check_PROGRAMS)
 
 # tiretestrig_SOURCES = tiretestrig.cpp
@@ -21,6 +21,9 @@
 mechanic_SOURCES = mechanic.cpp
 mechanic_LDADD = ../OpenFDM/libOpenFDM.la
 
+linalg_SOURCES = linalg.cpp
+linalg_LDADD = ../OpenFDM/libOpenFDM.la
+
 foucault_SOURCES = foucault.cpp
 foucault_LDADD = ../OpenFDM/libOpenFDM.la
 

Added: branches/OpenFDM-StateSeparation/src/test/linalg.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/linalg.cpp	2008-11-24 06:24:23 UTC (rev 788)
+++ branches/OpenFDM-StateSeparation/src/test/linalg.cpp	2008-11-24 17:46:39 UTC (rev 789)
@@ -0,0 +1,123 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
+ *
+ */
+
+#include <cstdlib>
+#include <iostream>
+#include <OpenFDM/Quaternion.h>
+#include <OpenFDM/Matrix.h>
+#include <OpenFDM/Vector.h>
+
+namespace OpenFDM {
+
+/// Return random vector
+Vector
+rVec(unsigned len)
+{
+  Vector v(len);
+  for (unsigned i = 0; i < len; ++i)
+    v(i) = drand48() - real_type(0.5);
+  return v;
+}
+
+/// Return normalized random vector
+Vector
+rnVec(unsigned len)
+{
+  return normalize(rVec(len));
+}
+
+Matrix
+rMatrix(const Size& s)
+{
+  Matrix m(s(0), s(1));
+  for (unsigned i = 0; i < s(0); ++i)
+    for (unsigned j = 0; j < s(1); ++j)
+      m(i, j) = drand48() - real_type(0.5);
+  return m;
+}
+
+template<unsigned n>
+bool
+solvetest(const LinAlg::Matrix<real_type,n,n>& m,
+          const LinAlg::Vector<real_type,n>& v)
+{
+  // compute a decomposition
+  LinAlg::MatrixFactors<real_type,n,n,LinAlg::LUTag> decomp(m);
+
+  // crude condition estimation
+  real_type nrm = 0;
+  real_type rnrm = 0;
+  for (unsigned i = 0; i < rows(v); ++i) {
+    nrm = max(nrm, norm1(m*Vector::unit(i, rows(v))));
+    rnrm = max(rnrm, norm1(decomp.solve(Vector::unit(i, rows(v)))));
+  }
+  real_type cond = nrm*rnrm;
+
+  // determine allowed tolerance from the condition number
+  real_type rtol = sqrt(rows(v))*cond*10*Limits<real_type>::epsilon();
+  real_type atol = sqrt(rows(v))*1e-5*Limits<real_type>::epsilon();
+
+  // Check ...
+  if (!equal(v, decomp.solve(m*v), rtol, atol)) {
+    std::cerr << "Matrix solve test failed\n";
+    std::cerr << "   condition number:       " << cond << "\n";
+    std::cerr << "   norm of the difference: "
+              << norm(v - decomp.solve(m*v)) << std::endl;
+    return false;
+  }
+
+  return true;
+}
+
+template<unsigned n>
+bool
+solvetestFixedSize(void)
+{
+  Size s(n, n);
+  for (unsigned i = 0; i < 100; ++i)
+    if (!solvetest(rMatrix(s), rVec(s(0))))
+      return false;
+  return true;
+}
+
+bool
+solvetestVariableSize(unsigned n)
+{
+  Size s(n, n);
+  for (unsigned i = 0; i < 100; ++i)
+    if (!solvetest(rMatrix(s), rnVec(s(0))))
+      return false;
+  return true;
+}
+
+bool
+solvetest()
+{
+  if (!solvetestFixedSize<1>())
+    return false;
+  if (!solvetestFixedSize<2>())
+    return false;
+  if (!solvetestFixedSize<3>())
+    return false;
+  if (!solvetestFixedSize<4>())
+    return false;
+  if (!solvetestFixedSize<5>())
+    return false;
+  if (!solvetestFixedSize<6>())
+    return false;
+  for (unsigned n = 1; n < 50; ++n)
+    if (!solvetestVariableSize(n))
+      return false;
+  return true;
+}
+
+}
+
+int
+main(int argc, char *argv[])
+{
+  if (!OpenFDM::solvetest())
+    return EXIT_FAILURE;
+  return EXIT_SUCCESS;
+}


Property changes on: branches/OpenFDM-StateSeparation/src/test/linalg.cpp
___________________________________________________________________
Name: svn:executable
   + *



From frohlich at mail.berlios.de  Mon Nov 24 20:04:13 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Mon, 24 Nov 2008 20:04:13 +0100
Subject: [OpenFDM-svn] r790 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811241904.mAOJ4DqI018496@sheep.berlios.de>

Author: frohlich
Date: 2008-11-24 20:04:12 +0100 (Mon, 24 Nov 2008)
New Revision: 790

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/PrismaticJoint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/PrismaticJoint.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteActuator.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteActuator.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/RotationalJoint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/RotationalJoint.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/UniversalJoint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/UniversalJoint.h
Log:
Simplify design position handling.

M    src/OpenFDM/CartesianJoint.h
M    src/OpenFDM/RotationalJoint.cpp
M    src/OpenFDM/PrismaticJoint.cpp
M    src/OpenFDM/RevoluteActuator.cpp
M    src/OpenFDM/RevoluteJoint.cpp
M    src/OpenFDM/RotationalJoint.h
M    src/OpenFDM/UniversalJoint.h
M    src/OpenFDM/PrismaticJoint.h
M    src/OpenFDM/RevoluteActuator.h
M    src/OpenFDM/RevoluteJoint.h
M    src/OpenFDM/UniversalJoint.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h	2008-11-24 17:46:39 UTC (rev 789)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h	2008-11-24 19:04:12 UTC (rev 790)
@@ -26,6 +26,12 @@
   typedef LinAlg::Matrix<real_type,n,n> MatrixNN;
   typedef LinAlg::MatrixFactors<real_type,n,n,LinAlg::LUTag> MatrixFactorsNN;
 
+  // Each Cartesian joint has a position that has some kind of invariance
+  const Vector3& getPosition() const
+  { return mPosition; }
+  void setPosition(const Vector3& position)
+  { mPosition = position; }
+
   virtual MechanicContext*
   newMechanicContext(const MechanicLinkInfo* parentLink,
                      const MechanicLinkInfo* childLink,
@@ -77,7 +83,8 @@
   CartesianJoint(const std::string& name) :
     Joint(name),
     mParentLink(newMechanicLink("link0")),
-    mChildLink(newMechanicLink("link1"))
+    mChildLink(newMechanicLink("link1")),
+    mPosition(0, 0, 0)
   { }
   virtual ~CartesianJoint(void)
   { }
@@ -182,8 +189,6 @@
   virtual void init(const Task&,DiscreteStateValueVector&,
                     ContinousStateValueVector&, const PortValueList&) const
   { }
-  virtual void initDesignPosition(const MechanicLinkValue& parentLink,
-                                  MechanicLinkValue& childLink) const = 0;
   virtual void velocity(const MechanicLinkValue& parentLink,
                         MechanicLinkValue& childLink,
                         const ContinousStateValueVector& states,
@@ -220,7 +225,7 @@
     
     virtual void initDesignPosition()
     {
-      mCartesianJoint->initDesignPosition(*mParentLink, *mChildLink);
+      mChildLink->setDesignPosition(mCartesianJoint->getPosition());
     }
 
     bool alloc()
@@ -276,6 +281,7 @@
   MechanicLink mChildLink;
 
   Matrix6N mJointMatrix;
+  Vector3 mPosition;
 };
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/PrismaticJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/PrismaticJoint.cpp	2008-11-24 17:46:39 UTC (rev 789)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/PrismaticJoint.cpp	2008-11-24 19:04:12 UTC (rev 790)
@@ -28,8 +28,7 @@
   mVelocityPort(this, "velocity", Size(1, 1)),
   mPositionStateInfo(new Vector1StateInfo),
   mVelocityStateInfo(new Vector1StateInfo),
-  mAxis(Vector3(1, 0, 0)),
-  mPosition(Vector3(0, 0, 0))
+  mAxis(Vector3(1, 0, 0))
 {
   addContinousStateInfo(mPositionStateInfo);
   addContinousStateInfo(mVelocityStateInfo);
@@ -63,13 +62,13 @@
 const Vector3&
 PrismaticJoint::getPosition() const
 {
-  return mPosition;
+  return CartesianJoint<1>::getPosition();
 }
 
 void
 PrismaticJoint::setPosition(const Vector3& position)
 {
-  mPosition = position;
+  CartesianJoint<1>::setPosition(position);
 }
 
 void
@@ -90,13 +89,6 @@
 }
 
 void
-PrismaticJoint::initDesignPosition(const MechanicLinkValue& parentLink,
-                                   MechanicLinkValue& childLink) const
-{
-  childLink.setDesignPosition(mPosition);
-}
-
-void
 PrismaticJoint::init(const Task&, DiscreteStateValueVector&,
                     ContinousStateValueVector& continousState,
                     const PortValueList&) const
@@ -119,7 +111,7 @@
   if (!mVelocityPort.empty())
     portValues[mVelocityPort] = jointVel;
   
-  Vector3 position = mAxis*jointPos + mPosition - parentLink.getDesignPosition();
+  Vector3 position = mAxis*jointPos + getPosition() - parentLink.getDesignPosition();
   velocity(parentLink, childLink, position, Quaternion::unit(),
            getJointMatrix()*jointVel);
 }

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/PrismaticJoint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/PrismaticJoint.h	2008-11-24 17:46:39 UTC (rev 789)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/PrismaticJoint.h	2008-11-24 19:04:12 UTC (rev 790)
@@ -41,8 +41,6 @@
 
 protected:
 
-  virtual void initDesignPosition(const MechanicLinkValue& parentLink,
-                                  MechanicLinkValue& childLink) const;
   virtual void init(const Task&, DiscreteStateValueVector&,
                     ContinousStateValueVector& continousState,
                     const PortValueList&) const;
@@ -82,7 +80,6 @@
   SharedPtr<Vector1StateInfo> mVelocityStateInfo;
 
   Vector3 mAxis;
-  Vector3 mPosition;
 };
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteActuator.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteActuator.cpp	2008-11-24 17:46:39 UTC (rev 789)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteActuator.cpp	2008-11-24 19:04:12 UTC (rev 790)
@@ -34,7 +34,6 @@
   mPositionStateInfo(new Vector1StateInfo),
   mVelocityStateInfo(new Vector1StateInfo),
   mAxis(Vector3(1, 0, 0)),
-  mPosition(Vector3(0, 0, 0)),
   mVelocityControl(false),
   mVelGain(1),
   mVelDotGain(1),
@@ -72,23 +71,16 @@
 const Vector3&
 RevoluteActuator::getPosition() const
 {
-  return mPosition;
+  return CartesianJoint<1>::getPosition();
 }
 
 void
 RevoluteActuator::setPosition(const Vector3& position)
 {
-  mPosition = position;
+  CartesianJoint<1>::setPosition(position);
 }
 
 void
-RevoluteActuator::initDesignPosition(const MechanicLinkValue& parentLink,
-                                     MechanicLinkValue& childLink) const
-{
-  childLink.setDesignPosition(mPosition);
-}
-
-void
 RevoluteActuator::init(const Task&, DiscreteStateValueVector&,
                        ContinousStateValueVector& continousState,
                        const PortValueList&) const
@@ -111,7 +103,7 @@
   if (!mVelocityPort.empty())
     portValues[mVelocityPort] = jointVel;
   
-  Vector3 position = mPosition - parentLink.getDesignPosition();
+  Vector3 position = getPosition() - parentLink.getDesignPosition();
   Quaternion orientation(Quaternion::fromAngleAxis(jointPos(0), mAxis));
   velocity(parentLink, childLink, position, orientation, getJointMatrix()*jointVel);
 }

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteActuator.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteActuator.h	2008-11-24 17:46:39 UTC (rev 789)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteActuator.h	2008-11-24 19:04:12 UTC (rev 790)
@@ -58,8 +58,6 @@
 
 protected:
 
-  virtual void initDesignPosition(const MechanicLinkValue& parentLink,
-                                  MechanicLinkValue& childLink) const;
   virtual void init(const Task&, DiscreteStateValueVector&,
                     ContinousStateValueVector& continousState,
                     const PortValueList&) const;
@@ -98,7 +96,6 @@
   SharedPtr<Vector1StateInfo> mVelocityStateInfo;
 
   Vector3 mAxis;
-  Vector3 mPosition;
   bool mVelocityControl;
   real_type mVelGain;
   real_type mVelDotGain;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.cpp	2008-11-24 17:46:39 UTC (rev 789)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.cpp	2008-11-24 19:04:12 UTC (rev 790)
@@ -28,8 +28,7 @@
   mVelocityPort(this, "velocity", Size(1, 1)),
   mPositionStateInfo(new Vector1StateInfo),
   mVelocityStateInfo(new Vector1StateInfo),
-  mAxis(Vector3(1, 0, 0)),
-  mPosition(Vector3(0, 0, 0))
+  mAxis(Vector3(1, 0, 0))
 {
   addContinousStateInfo(mPositionStateInfo);
   addContinousStateInfo(mVelocityStateInfo);
@@ -63,13 +62,13 @@
 const Vector3&
 RevoluteJoint::getPosition() const
 {
-  return mPosition;
+  return CartesianJoint<1>::getPosition();
 }
 
 void
 RevoluteJoint::setPosition(const Vector3& position)
 {
-  mPosition = position;
+  CartesianJoint<1>::setPosition(position);
 }
 
 void
@@ -90,13 +89,6 @@
 }
 
 void
-RevoluteJoint::initDesignPosition(const MechanicLinkValue& parentLink,
-                                  MechanicLinkValue& childLink) const
-{
-  childLink.setDesignPosition(mPosition);
-}
-
-void
 RevoluteJoint::init(const Task&, DiscreteStateValueVector&,
                     ContinousStateValueVector& continousState,
                     const PortValueList&) const
@@ -120,7 +112,7 @@
     portValues[mVelocityPort] = jointVel;
 
   // FIXME: move that somewhere into the context??
-  Vector3 position = mPosition - parentLink.getDesignPosition();
+  Vector3 position = getPosition() - parentLink.getDesignPosition();
   velocity(parentLink, childLink, position,
            Quaternion::fromAngleAxis(jointPos(0), mAxis),
            getJointMatrix()*jointVel);

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.h	2008-11-24 17:46:39 UTC (rev 789)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RevoluteJoint.h	2008-11-24 19:04:12 UTC (rev 790)
@@ -41,8 +41,6 @@
 
 protected:
 
-  virtual void initDesignPosition(const MechanicLinkValue& parentLink,
-                                  MechanicLinkValue& childLink) const;
   virtual void init(const Task&, DiscreteStateValueVector&,
                     ContinousStateValueVector& continousState,
                     const PortValueList&) const;
@@ -82,7 +80,6 @@
   SharedPtr<Vector1StateInfo> mVelocityStateInfo;
 
   Vector3 mAxis;
-  Vector3 mPosition;
 };
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RotationalJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RotationalJoint.cpp	2008-11-24 17:46:39 UTC (rev 789)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RotationalJoint.cpp	2008-11-24 19:04:12 UTC (rev 790)
@@ -26,8 +26,7 @@
   mOrientationPort(this, "orientation", Size(4, 1)),
   mVelocityPort(this, "velocity", Size(3, 1)),
   mPositionStateInfo(new Vector4StateInfo),
-  mVelocityStateInfo(new Vector3StateInfo),
-  mPosition(0, 0, 0)
+  mVelocityStateInfo(new Vector3StateInfo)
 {
   addContinousStateInfo(mPositionStateInfo);
   addContinousStateInfo(mVelocityStateInfo);
@@ -46,13 +45,13 @@
 const Vector3&
 RotationalJoint::getPosition() const
 {
-  return mPosition;
+  return CartesianJoint<3>::getPosition();
 }
 
 void
 RotationalJoint::setPosition(const Vector3& position)
 {
-  mPosition = position;
+  CartesianJoint<3>::setPosition(position);
 }
 
 void
@@ -73,13 +72,6 @@
 }
 
 void
-RotationalJoint::initDesignPosition(const MechanicLinkValue& parentLink,
-                                  MechanicLinkValue& childLink) const
-{
-  childLink.setDesignPosition(mPosition);
-}
-
-void
 RotationalJoint::init(const Task&, DiscreteStateValueVector&,
                     ContinousStateValueVector& continousState,
                     const PortValueList&) const
@@ -102,7 +94,7 @@
   if (!mVelocityPort.empty())
     portValues[mVelocityPort] = jointVel;
   
-  Vector3 position = mPosition - parentLink.getDesignPosition();
+  Vector3 position = getPosition() - parentLink.getDesignPosition();
   velocity(parentLink, childLink, position,
            orientation, getJointMatrix()*jointVel);
 }

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RotationalJoint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RotationalJoint.h	2008-11-24 17:46:39 UTC (rev 789)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RotationalJoint.h	2008-11-24 19:04:12 UTC (rev 790)
@@ -38,8 +38,6 @@
 
 protected:
 
-  virtual void initDesignPosition(const MechanicLinkValue& parentLink,
-                                  MechanicLinkValue& childLink) const;
   virtual void init(const Task&, DiscreteStateValueVector&,
                     ContinousStateValueVector& continousState,
                     const PortValueList&) const;
@@ -76,8 +74,6 @@
 
   SharedPtr<Vector4StateInfo> mPositionStateInfo;
   SharedPtr<Vector3StateInfo> mVelocityStateInfo;
-
-  Vector3 mPosition;
 };
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/UniversalJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/UniversalJoint.cpp	2008-11-24 17:46:39 UTC (rev 789)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/UniversalJoint.cpp	2008-11-24 19:04:12 UTC (rev 790)
@@ -28,8 +28,7 @@
   mVelocityPort(this, "velocity", Size(2, 1)),
   mPositionStateInfo(new Vector3StateInfo),
   mVelocityStateInfo(new Vector2StateInfo),
-  mAxis(Vector3(1, 0, 0)),
-  mPosition(0, 0, 0)
+  mAxis(Vector3(1, 0, 0))
 {
   addContinousStateInfo(mPositionStateInfo);
   addContinousStateInfo(mVelocityStateInfo);
@@ -71,13 +70,13 @@
 const Vector3&
 UniversalJoint::getPosition() const
 {
-  return mPosition;
+  return CartesianJoint<2>::getPosition();
 }
 
 void
 UniversalJoint::setPosition(const Vector3& position)
 {
-  mPosition = position;
+  CartesianJoint<2>::setPosition(position);
 }
 
 void
@@ -98,13 +97,6 @@
 }
 
 void
-UniversalJoint::initDesignPosition(const MechanicLinkValue& parentLink,
-                                  MechanicLinkValue& childLink) const
-{
-  childLink.setDesignPosition(mPosition);
-}
-
-void
 UniversalJoint::init(const Task&, DiscreteStateValueVector&,
                     ContinousStateValueVector& continousState,
                     const PortValueList&) const
@@ -130,7 +122,7 @@
   if (!mVelocityPort.empty())
     portValues[mVelocityPort] = jointVel;
   
-  Vector3 position = mPosition - parentLink.getDesignPosition();
+  Vector3 position = getPosition() - parentLink.getDesignPosition();
   velocity(parentLink, childLink, position,
            orientation, getJointMatrix()*jointVel);
 }

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/UniversalJoint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/UniversalJoint.h	2008-11-24 17:46:39 UTC (rev 789)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/UniversalJoint.h	2008-11-24 19:04:12 UTC (rev 790)
@@ -41,8 +41,6 @@
 
 protected:
 
-  virtual void initDesignPosition(const MechanicLinkValue& parentLink,
-                                  MechanicLinkValue& childLink) const;
   virtual void init(const Task&, DiscreteStateValueVector&,
                     ContinousStateValueVector& continousState,
                     const PortValueList&) const;
@@ -82,7 +80,6 @@
   SharedPtr<Vector2StateInfo> mVelocityStateInfo;
 
   Vector3 mAxis;
-  Vector3 mPosition;
   Quaternion mOrientation;
 };
 



From frohlich at mail.berlios.de  Mon Nov 24 21:33:10 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Mon, 24 Nov 2008 21:33:10 +0100
Subject: [OpenFDM-svn] r791 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811242033.mAOKXAfx027902@sheep.berlios.de>

Author: frohlich
Date: 2008-11-24 21:33:10 +0100 (Mon, 24 Nov 2008)
New Revision: 791

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/HDF5SystemOutput.h
Log:
Reenable mechanic value dumps by default.

M    HDF5SystemOutput.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/HDF5SystemOutput.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/HDF5SystemOutput.h	2008-11-24 19:04:12 UTC (rev 790)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/HDF5SystemOutput.h	2008-11-24 20:33:10 UTC (rev 791)
@@ -284,7 +284,7 @@
 
 class HDF5SystemOutput : public SystemOutput {
 public:
-  HDF5SystemOutput(const std::string& filename, bool outputMechanics = false) :
+  HDF5SystemOutput(const std::string& filename, bool outputMechanics = true) :
     mHDF5File(filename),
     mToplevelGroup(mHDF5File, "System"),
     mTimeStream(mToplevelGroup, "t", Size(1, 1)),



From frohlich at mail.berlios.de  Tue Nov 25 07:32:32 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Tue, 25 Nov 2008 07:32:32 +0100
Subject: [OpenFDM-svn] r793 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811250632.mAP6WWpc002613@sheep.berlios.de>

Author: frohlich
Date: 2008-11-25 07:32:29 +0100 (Tue, 25 Nov 2008)
New Revision: 793

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJoint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Joint.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Mass.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJoint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/System.h
Log:
Make the environment a System variable and propagete
it into the mechanic stuff.

M    src/OpenFDM/MobileRootJoint.cpp
M    src/OpenFDM/CartesianJoint.h
M    src/OpenFDM/Mass.cpp
M    src/OpenFDM/RootJoint.cpp
M    src/OpenFDM/MechanicLinkValue.h
M    src/OpenFDM/System.h
M    src/OpenFDM/RootJoint.h
M    src/OpenFDM/FixedRootJoint.cpp
M    src/OpenFDM/System.cpp
M    src/OpenFDM/Joint.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h	2008-11-24 20:33:50 UTC (rev 792)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h	2008-11-25 06:32:29 UTC (rev 793)
@@ -35,7 +35,8 @@
   { mPosition = position; }
 
   virtual MechanicContext*
-  newMechanicContext(const MechanicLinkInfo* parentLink,
+  newMechanicContext(const Environment* environment,
+                     const MechanicLinkInfo* parentLink,
                      const MechanicLinkInfo* childLink,
                      PortValueList& portValueList) const
   {
@@ -59,7 +60,8 @@
       return 0;
 
     // Now propagate the root dependent data ...
-    childLinkValue->setEnvironment(parentLinkValue->getEnvironment());
+    OpenFDMAssert(environment == parentLinkValue->getEnvironment());
+    childLinkValue->setEnvironment(environment);
 
     SharedPtr<Context> context;
     context = new Context(this, parentLinkValue, childLinkValue);

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJoint.cpp	2008-11-24 20:33:50 UTC (rev 792)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJoint.cpp	2008-11-25 06:32:29 UTC (rev 793)
@@ -75,7 +75,7 @@
                          const ContinousStateValueVector& continousState,
                          PortValueList& portValues) const
 {
-  const EnvironmentCache* environment;
+  const Environment* environment;
   environment = portValues[mMechanicLink].getEnvironment();
   Vector3 angularBaseVelocity = environment->getAngularVelocity(task.getTime());
   portValues[mMechanicLink].setPosAndVel(angularBaseVelocity, mPosition,
@@ -93,7 +93,7 @@
 FixedRootJoint::acceleration(const Task& task, const ContinousStateValueVector&,
                               PortValueList& portValues) const
 {
-  const EnvironmentCache* environment;
+  const Environment* environment;
   environment = portValues[mMechanicLink].getEnvironment();
   Vector6 spatialAcceleration = environment->getAcceleration(task.getTime());
   portValues[mMechanicLink].getFrame().setSpAccel(spatialAcceleration);

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Joint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Joint.h	2008-11-24 20:33:50 UTC (rev 792)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Joint.h	2008-11-25 06:32:29 UTC (rev 793)
@@ -35,7 +35,8 @@
   virtual void accept(ConstNodeVisitor& visitor) const;
 
   virtual MechanicContext*
-  newMechanicContext(const MechanicLinkInfo* parentLink,
+  newMechanicContext(const Environment* environment,
+                     const MechanicLinkInfo* parentLink,
                      const MechanicLinkInfo* childLink,
                      PortValueList& portValues) const = 0;
 };

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Mass.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Mass.cpp	2008-11-24 20:33:50 UTC (rev 792)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Mass.cpp	2008-11-25 06:32:29 UTC (rev 793)
@@ -38,7 +38,7 @@
 Mass::articulation(const Task&, const ContinousStateValueVector&,
                    PortValueList& portValues, Matrix&) const
 {
-  const EnvironmentCache* environment;
+  const Environment* environment;
   environment = portValues[mMechanicLink].getEnvironment();
 
   // The position of the mass point wrt its parent link frame

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.h	2008-11-24 20:33:50 UTC (rev 792)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.h	2008-11-25 06:32:29 UTC (rev 793)
@@ -12,35 +12,6 @@
 
 namespace OpenFDM {
 
-class EnvironmentCache : public Environment {
-public:
-  virtual ~EnvironmentCache() {}
-
-  // Sets a new RootJoint position, evaluate environmental stuff
-  void setPosition(const real_type& t, const Vector3& position)
-  {
-    mTime = t;
-    mRootJointPosition = position;
-    mGravityAcceleration = getGravityAcceleration(position);
-    mWindVelocity = getWindVelocity(t, position);
-  }
-  const Vector3& getRootJointPosition() const
-  { return mRootJointPosition; }
-
-  const Vector3& getGravityAccelerationAtRoot() const
-  { return mGravityAcceleration; }
-
-  const Vector6& getWindVelocityAtRoot() const
-  { return mWindVelocity; }
-
-private:
-  real_type mTime;
-  Vector3 mRootJointPosition;
-  Vector3 mGravityAcceleration;
-  Vector6 mWindVelocity;
-};
-
-
 class MechanicLinkValue : public PortValue {
 public:
   MechanicLinkValue();
@@ -114,10 +85,10 @@
   // This is a per link value because of interacts that can be child of two
   // different roots.
   // FIXME, enforce setting that in the contructor
-  const EnvironmentCache* getEnvironment() const
+  const Environment* getEnvironment() const
   { return mEnvironment; }
 
-  void setEnvironment(const EnvironmentCache* environment)
+  void setEnvironment(const Environment* environment)
   { OpenFDMAssert(environment); mEnvironment = environment; }
 
 protected:
@@ -130,7 +101,7 @@
 
   Vector3 mDesignPosition;
 
-  SharedPtr<const EnvironmentCache> mEnvironment;
+  SharedPtr<const Environment> mEnvironment;
 };
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJoint.cpp	2008-11-24 20:33:50 UTC (rev 792)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJoint.cpp	2008-11-25 06:32:29 UTC (rev 793)
@@ -55,7 +55,7 @@
                           const ContinousStateValueVector& continousState,
                           PortValueList& portValues) const
 {
-  const EnvironmentCache* environment;
+  const Environment* environment;
   environment = portValues[mMechanicLink].getEnvironment();
   Vector3 angularBaseVelocity = environment->getAngularVelocity(task.getTime());
 
@@ -79,7 +79,7 @@
                               const ContinousStateValueVector&,
                               PortValueList& portValues) const
 {
-  const EnvironmentCache* environment;
+  const Environment* environment;
   environment = portValues[mMechanicLink].getEnvironment();
   Vector6 spatialAcceleration = environment->getAcceleration(task.getTime());
 

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.cpp	2008-11-24 20:33:50 UTC (rev 792)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.cpp	2008-11-25 06:32:29 UTC (rev 793)
@@ -68,7 +68,8 @@
 }
 
 MechanicContext*
-RootJoint::newMechanicContext(const MechanicLinkInfo* parentLink,
+RootJoint::newMechanicContext(const Environment* environment,
+                              const MechanicLinkInfo* parentLink,
                               const MechanicLinkInfo* childLink,
                               PortValueList& portValueList) const
 {
@@ -83,7 +84,7 @@
     }
 
     if (portValue->toMechanicLinkValue()) {
-      portValue->toMechanicLinkValue()->setEnvironment(new EnvironmentCache);
+      portValue->toMechanicLinkValue()->setEnvironment(environment);
     }
 
     context->setPortValue(*getPort(i), portValue);

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.h	2008-11-24 20:33:50 UTC (rev 792)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.h	2008-11-25 06:32:29 UTC (rev 793)
@@ -17,7 +17,8 @@
   virtual ~RootJoint();
 
   virtual MechanicContext*
-  newMechanicContext(const MechanicLinkInfo* parentLink,
+  newMechanicContext(const Environment* environment,
+                     const MechanicLinkInfo* parentLink,
                      const MechanicLinkInfo* childLink,
                      PortValueList& portValueList) const;
 

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-24 20:33:50 UTC (rev 792)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-25 06:32:29 UTC (rev 793)
@@ -6,6 +6,7 @@
 
 #include "AbstractSystem.h"
 #include "ConstNodeVisitor.h"
+#include "Environment.h"
 #include "Group.h"
 #include "GroupInterfaceNode.h"
 #include "Interact.h"
@@ -247,9 +248,11 @@
 
 class System::NodeInstanceCollector : public ConstNodeVisitor {
 public:
-  NodeInstanceCollector(const SampleTime& sampleTime) :
+  NodeInstanceCollector(const SampleTime& sampleTime,
+                        Environment* environment) :
     mSampleTime(sampleTime),
-    mBasicSampleTime(SampleTime::getContinous())
+    mBasicSampleTime(SampleTime::getContinous()),
+    mEnvironment(environment)
   { }
 
   struct InstanceData;
@@ -544,7 +547,7 @@
     { }
     virtual const MechanicNode* getNode() const = 0;
 
-    virtual bool createMechanicContext() = 0;
+    virtual bool createMechanicContext(Environment*) = 0;
 
     virtual AbstractNodeInstance* newNodeInstance()
     { return new LeafInstance(mSampleTime, mMechanicContext); }
@@ -586,10 +589,11 @@
       mJoint(&joint)
     { }
     virtual const Joint* getNode() const { return mJoint; }
-    virtual bool createMechanicContext()
+    virtual bool createMechanicContext(Environment* environment)
     {
       OpenFDMAssert(!mMechanicContext);
-      mMechanicContext = getNode()->newMechanicContext(mParentLink, mChildLink,
+      mMechanicContext = getNode()->newMechanicContext(environment, mParentLink,
+                                                       mChildLink,
                                                        mPortValueList);
       if (!mMechanicContext) {
         Log(Schedule, Warning) << "Could not create context for mechanic "
@@ -659,7 +663,7 @@
       mInteract(&interact)
     { }
     virtual const Interact* getNode() const { return mInteract; }
-    virtual bool createMechanicContext()
+    virtual bool createMechanicContext(Environment* environment)
     {
       OpenFDMAssert(!mMechanicContext);
       mMechanicContext = getNode()->newMechanicContext(mPortValueList);
@@ -915,6 +919,9 @@
   // until all models have be traversed.
   SampleTime mBasicSampleTime;
 
+  // The mechanic simulation environment for this system
+  SharedPtr<Environment> mEnvironment;
+
   // Here the miracle occurs.
   // The collected simulation nodes are packed into something that can be used
   // to simulate the system.
@@ -1296,7 +1303,7 @@
     MechanicInstanceDataList::const_iterator k;
     for (k = mMechanicInstanceDataList.begin();
          k != mMechanicInstanceDataList.end(); ++k) {
-      if (!(*k)->createMechanicContext())
+      if (!(*k)->createMechanicContext(mEnvironment))
         return false;
     }
 
@@ -1310,7 +1317,8 @@
 System::System(const std::string& name, Node* node) :
   Object(name),
   mNode(node),
-  mSampleTime(SampleTime::getContinous())
+  mSampleTime(SampleTime::getContinous()),
+  mEnvironment(new Environment)
 {
 }
 
@@ -1336,6 +1344,24 @@
   mSampleTime = sampleTime;
 }
 
+void
+System::setEnvironment(Environment* environment)
+{
+  mEnvironment = environment;
+}
+
+Environment*
+System::getEnvironment()
+{
+  return mEnvironment;
+}
+
+const Environment*
+System::getEnvironment() const
+{
+  return mEnvironment;
+}
+
 bool
 System::init(const real_type& t0)
 {
@@ -1343,7 +1369,7 @@
     return false;
   
   // Build up the lists required to run the model.
-  NodeInstanceCollector nodeInstanceCollector(mSampleTime);
+  NodeInstanceCollector nodeInstanceCollector(mSampleTime, mEnvironment);
   mNode->accept(nodeInstanceCollector);
   
   mAbstractSystem = nodeInstanceCollector.buildSystem();

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/System.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/System.h	2008-11-24 20:33:50 UTC (rev 792)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/System.h	2008-11-25 06:32:29 UTC (rev 793)
@@ -18,6 +18,7 @@
 /// Provides algorithms to simulate and trim the whole system.
 
 class AbstractSystem;
+class Environment;
 class SystemOutput;
 
 class System : public Object {
@@ -36,6 +37,11 @@
   const SampleTime& getSampleTime(void) const { return mSampleTime; }
   bool setSampleTime(const SampleTime& sampleTime);
 
+  /// Access the environment functions bundle.
+  void setEnvironment(Environment* environment);
+  Environment* getEnvironment();
+  const Environment* getEnvironment() const;
+
   bool init(const real_type& t0 = real_type(0));
   void clear();
 
@@ -60,6 +66,8 @@
   SharedPtr<Node> mNode;
   SampleTime mSampleTime;
 
+  SharedPtr<Environment> mEnvironment;
+
   SharedPtr<AbstractSystem> mAbstractSystem;
 
   typedef std::map<NodePath, SharedPtr<AbstractNodeInstance> > NodeInstanceMap;



From frohlich at mail.berlios.de  Tue Nov 25 20:37:07 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Tue, 25 Nov 2008 20:37:07 +0100
Subject: [OpenFDM-svn] r794 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811251937.mAPJb7ER002437@sheep.berlios.de>

Author: frohlich
Date: 2008-11-25 20:37:06 +0100 (Tue, 25 Nov 2008)
New Revision: 794

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/AirSpring.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/AirSpring.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/ConstModel.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Function.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/LinearSpringDamper.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/LinearSpringDamper.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
Log:
Reactivate spring damper models.

M    OpenFDM/Makefile.am
M    OpenFDM/LinearSpringDamper.cpp
M    OpenFDM/AirSpring.h
M    OpenFDM/ConstModel.h
M    OpenFDM/AirSpring.cpp
M    OpenFDM/LinearSpringDamper.h
M    OpenFDM/Function.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/AirSpring.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/AirSpring.cpp	2008-11-25 06:32:29 UTC (rev 793)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/AirSpring.cpp	2008-11-25 19:37:06 UTC (rev 794)
@@ -5,6 +5,7 @@
 #include "AirSpring.h"
 
 #include <string>
+#include "PortValueList.h"
 
 namespace OpenFDM {
 
@@ -20,6 +21,9 @@
 
 AirSpring::AirSpring(const std::string& name) :
   Model(name),
+  mPositionPort(this, "position", true),
+  mVelocityPort(this, "velocity", true),
+  mForcePort(this, "force"),
   mPushPressure(2e5),
   mPullPressure(1e5),
   mArea(0),
@@ -29,47 +33,19 @@
   mMaxDamperConstant(0),
   mGamma(1.4)
 {
-  setDirectFeedThrough(true);
-
-  setNumInputPorts(2);
-  setInputPortName(0, "position");
-  setInputPortName(1, "velocity");
-  
-  setNumOutputPorts(1);
-  setOutputPort(0, "force", this, &AirSpring::getForce);
 }
 
 AirSpring::~AirSpring(void)
 {
 }
 
-bool
-AirSpring::init(void)
-{
-  mPositionPort = getInputPort(0)->toRealPortHandle();
-  if (!mPositionPort.isConnected()) {
-    Log(Model, Error) << "Initialization of AirSpring model \"" << getName()
-                      << "\" failed: Input port \"" << getInputPortName(0)
-                      << "\" is not connected!" << endl;
-    return false;
-  }
-
-  mVelocityPort = getInputPort(1)->toRealPortHandle();
-  if (!mVelocityPort.isConnected()) {
-    Log(Model, Error) << "Initialization of AirSpring model \"" << getName()
-                      << "\" failed: Input port \"" << getInputPortName(1)
-                      << "\" is not connected!" << endl;
-    return false;
-  }
-
-  return Model::init();
-}
-
 void
-AirSpring::output(const TaskInfo& taskInfo)
+AirSpring::output(const Task&, const DiscreteStateValueVector&,
+                  const ContinousStateValueVector&,
+                  PortValueList& portValues) const
 {
-  real_type position = mPositionPort.getRealValue();
-  real_type vel = mVelocityPort.getRealValue();
+  real_type position = portValues[mPositionPort];
+  real_type vel = portValues[mVelocityPort];
 
   real_type maxDisp = mMaxCompression - mMinCompression;
   real_type pullDisp = mMaxCompression - position;
@@ -86,22 +62,17 @@
   real_type pushPressure = mPushPressure/(1-pow(pushDispRatio, mGamma));
   
   // The output force is the pressure difference times the piston area
-  mForce = sign(maxDisp)*mArea*(pullPressure - pushPressure);
+  real_type force = sign(maxDisp)*mArea*(pullPressure - pushPressure);
   // Add a position dependent damping force
   // That sign of the area is just a handy hack to determine
   // the polarity of the output value
-  mForce += sign(mArea)*vel*interpolate(position,
-                                        mMinCompression, mMinDamperConstant,
-                                        mMaxCompression, mMaxDamperConstant);
+  force += sign(mArea)*vel*interpolate(position,
+                                       mMinCompression, mMinDamperConstant,
+                                       mMaxCompression, mMaxDamperConstant);
+  portValues[mForcePort] = force;
 }
 
 const real_type&
-AirSpring::getForce(void) const
-{
-  return mForce;
-}
-
-const real_type&
 AirSpring::getPushPressure(void) const
 {
   return mPushPressure;
@@ -185,14 +156,14 @@
   mMinDamperConstant = minDamperConstant;
 }
 
-real_type
+const real_type&
 AirSpring::getGamma(void) const
 {
   return mGamma;
 }
 
 void
-AirSpring::setGamma(real_type gamma)
+AirSpring::setGamma(const real_type& gamma)
 {
   mGamma = gamma;
 }

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/AirSpring.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/AirSpring.h	2008-11-25 06:32:29 UTC (rev 793)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/AirSpring.h	2008-11-25 19:37:06 UTC (rev 794)
@@ -6,6 +6,8 @@
 #define OpenFDM_AirSpring_H
 
 #include "Model.h"
+#include "RealInputPort.h"
+#include "RealOutputPort.h"
 #include "Vector.h"
 
 namespace OpenFDM {
@@ -17,11 +19,10 @@
   AirSpring(const std::string& name);
   virtual ~AirSpring(void);
 
-  virtual bool init(void);
-  virtual void output(const TaskInfo& taskInfo);
+  virtual void output(const Task&, const DiscreteStateValueVector&,
+                      const ContinousStateValueVector&,
+                      PortValueList& portValues) const;
 
-  const real_type& getForce(void) const;
-
   const real_type& getPushPressure(void) const;
   void setPushPressure(const real_type& pushPressure);
 
@@ -43,10 +44,14 @@
   const real_type& getMinDamperConstant(void) const;
   void setMinDamperConstant(const real_type& minDamperConstant);
 
-  real_type getGamma(void) const;
-  void setGamma(real_type gamma);
+  const real_type& getGamma(void) const;
+  void setGamma(const real_type& gamma);
 
 private:
+  RealInputPort mPositionPort;
+  RealInputPort mVelocityPort;
+  RealOutputPort mForcePort;
+
   real_type mPushPressure;
   real_type mPullPressure;
 
@@ -59,13 +64,6 @@
   real_type mMinDamperConstant;
 
   real_type mGamma;
-
-  real_type mForce;
-
-  /// The intput port which must provide the position
-  RealPortHandle mPositionPort;
-  /// The intput port which must provide the velocity
-  RealPortHandle mVelocityPort;
 };
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/ConstModel.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ConstModel.h	2008-11-25 06:32:29 UTC (rev 793)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ConstModel.h	2008-11-25 19:37:06 UTC (rev 794)
@@ -13,8 +13,8 @@
 class ConstModel : public Model {
   OPENFDM_OBJECT(ConstModel, Model);
 public:
-  ConstModel(const std::string& name, const Matrix& value = Matrix());
-  ConstModel(const std::string& name, const real_type& value);
+  ConstModel(const std::string& name, const Matrix& value);
+  ConstModel(const std::string& name, const real_type& value = real_type(0));
   virtual ~ConstModel(void);
 
   virtual void output(const Task&,const DiscreteStateValueVector&,

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Function.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Function.h	2008-11-25 06:32:29 UTC (rev 793)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Function.h	2008-11-25 19:37:06 UTC (rev 794)
@@ -11,7 +11,7 @@
 
 namespace OpenFDM {
 
-// FIXME: aplit that into two types of functions:
+// FIXME: split that into two types of functions:
 // Functions from R^m->R^n
 // and ODE Functions ...
 

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/LinearSpringDamper.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/LinearSpringDamper.cpp	2008-11-25 06:32:29 UTC (rev 793)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/LinearSpringDamper.cpp	2008-11-25 19:37:06 UTC (rev 794)
@@ -5,6 +5,7 @@
 #include "LinearSpringDamper.h"
 
 #include "Model.h"
+#include "PortValueList.h"
 #include "Vector.h"
 
 namespace OpenFDM {
@@ -17,62 +18,31 @@
 
 LinearSpringDamper::LinearSpringDamper(const std::string& name) :
   Model(name),
+  mPositionPort(this, "position", true),
+  mVelocityPort(this, "velocity", true),
+  mForcePort(this, "force"),
   mSpringReference(0),
   mSpringConstant(0),
   mDamperConstant(0)
 {
-  setDirectFeedThrough(true);
-
-  setNumInputPorts(2);
-  setInputPortName(0, "position");
-  setInputPortName(1, "velocity");
-  
-  setNumOutputPorts(1);
-  setOutputPort(0, "force", this, &LinearSpringDamper::getForce);
 }
 
 LinearSpringDamper::~LinearSpringDamper(void)
 {
 }
 
-bool
-LinearSpringDamper::init(void)
-{
-  mPositionPort = getInputPort(0)->toRealPortHandle();
-  if (!mPositionPort.isConnected()) {
-    Log(Model, Error) << "Initialization of AirSpring model \"" << getName()
-                      << "\" failed: Input port \"" << getInputPortName(0)
-                      << "\" is not connected!" << endl;
-    return false;
-  }
-
-  mVelocityPort = getInputPort(1)->toRealPortHandle();
-  if (!mVelocityPort.isConnected()) {
-    Log(Model, Error) << "Initialization of AirSpring model \"" << getName()
-                      << "\" failed: Input port \"" << getInputPortName(1)
-                      << "\" is not connected!" << endl;
-    return false;
-  }
-
-  return Model::init();
-}
-
 void
-LinearSpringDamper::output(const TaskInfo& taskInfo)
+LinearSpringDamper::output(const Task&, const DiscreteStateValueVector&,
+                           const ContinousStateValueVector&,
+                           PortValueList& portValues) const
 {
-  real_type position = mPositionPort.getRealValue();
-  real_type vel = mVelocityPort.getRealValue();
+  real_type position = portValues[mPositionPort];
+  real_type vel = portValues[mVelocityPort];
   real_type displacement = position - mSpringReference;
-  mForce = mSpringConstant*displacement + vel*mDamperConstant;
+  portValues[mForcePort] = mSpringConstant*displacement + vel*mDamperConstant;
 }
 
 const real_type&
-LinearSpringDamper::getForce(void) const
-{
-  return mForce;
-}
-
-const real_type&
 LinearSpringDamper::getSpringReference(void) const
 {
   return mSpringReference;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/LinearSpringDamper.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/LinearSpringDamper.h	2008-11-25 06:32:29 UTC (rev 793)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/LinearSpringDamper.h	2008-11-25 19:37:06 UTC (rev 794)
@@ -7,8 +7,9 @@
 
 #include <string>
 
-#include "Types.h"
 #include "Model.h"
+#include "RealInputPort.h"
+#include "RealOutputPort.h"
 
 namespace OpenFDM {
 
@@ -19,11 +20,10 @@
   LinearSpringDamper(const std::string& name);
   virtual ~LinearSpringDamper(void);
 
-  virtual bool init(void);
-  virtual void output(const TaskInfo& taskInfo);
+  virtual void output(const Task&, const DiscreteStateValueVector&,
+                      const ContinousStateValueVector&,
+                      PortValueList& portValues) const;
 
-  const real_type& getForce(void) const;
-
   const real_type& getSpringReference(void) const;
   void setSpringReference(const real_type& springReference);
 
@@ -34,16 +34,13 @@
   void setDamperConstant(const real_type& damperConstant);
 
 private:
+  RealInputPort mPositionPort;
+  RealInputPort mVelocityPort;
+  RealOutputPort mForcePort;
+
   real_type mSpringReference;
   real_type mSpringConstant;
   real_type mDamperConstant;
-
-  real_type mForce;
-
-  /// The intput port which must provide the position
-  RealPortHandle mPositionPort;
-  /// The intput port which must provide the velocity
-  RealPortHandle mVelocityPort;
 };
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-11-25 06:32:29 UTC (rev 793)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-11-25 19:37:06 UTC (rev 794)
@@ -245,6 +245,7 @@
   Wind.h
 
 OpenFDMModelsSOURCES = \
+  AirSpring.cpp \
   Bias.cpp \
   BinaryFunction.cpp \
   ConstModel.cpp \
@@ -254,6 +255,7 @@
   Gain.cpp \
   Input.cpp \
   Integrator.cpp \
+  LinearSpringDamper.cpp \
   Output.cpp \
   Saturation.cpp \
   SimulationTime.cpp \
@@ -261,9 +263,7 @@
   UnaryModel.cpp \
   UnitConversion.cpp
 
-#   AirSpring.cpp \
 #   DiscBrake.cpp \
-#   LinearSpringDamper.cpp \
 #   MaxModel.cpp \
 #   MinModel.cpp \
 #   Product.cpp \



From frohlich at mail.berlios.de  Tue Nov 25 20:48:49 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Tue, 25 Nov 2008 20:48:49 +0100
Subject: [OpenFDM-svn] r795 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811251948.mAPJmnwg003651@sheep.berlios.de>

Author: frohlich
Date: 2008-11-25 20:48:48 +0100 (Tue, 25 Nov 2008)
New Revision: 795

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.h
Log:
Enable wind sensing.

M    OpenFDM/Sensor.cpp
M    OpenFDM/Sensor.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.cpp	2008-11-25 19:37:06 UTC (rev 794)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.cpp	2008-11-25 19:48:48 UTC (rev 795)
@@ -7,6 +7,7 @@
 #include "MechanicLinkValue.h"
 #include "NumericPortValue.h"
 #include "PortValueList.h"
+#include "Task.h"
 
 namespace OpenFDM {
 
@@ -18,6 +19,7 @@
   DEF_OPENFDM_PROPERTY(Bool, EnableLinearVelocity, Serialized)
   DEF_OPENFDM_PROPERTY(Bool, EnableAngularVelocity, Serialized)
   DEF_OPENFDM_PROPERTY(Bool, EnableCentrifugalAcceleration, Serialized)
+  DEF_OPENFDM_PROPERTY(Bool, EnableWindVelocity, Serialized)
   DEF_OPENFDM_PROPERTY(Bool, EnableTemperature, Serialized)
   DEF_OPENFDM_PROPERTY(Bool, EnablePressure, Serialized)
   END_OPENFDM_OBJECT_DEF
@@ -39,7 +41,7 @@
 }
 
 void
-Sensor::velocity(const Task&, const ContinousStateValueVector&,
+Sensor::velocity(const Task& task, const ContinousStateValueVector&,
                  PortValueList& portValues) const
 {
   const Environment* environment;
@@ -71,6 +73,12 @@
       portValues[mLinearVelocityPort] = refVelocity.getLinear();
   }
 
+  // Wind sensing
+  if (getEnableWindVelocity()) {
+    Vector6 wind = environment->getWindVelocity(task.getTime(), position);
+    portValues[mWindVelocityPort] = frame.rotFromRef(wind.getLinear());
+  }
+ 
   // Atmosphere related sensing
   bool enableTemperature = getEnableTemperature();
   bool enablePressure = getEnablePressure();
@@ -222,6 +230,23 @@
 }
 
 void
+Sensor::setEnableWindVelocity(bool enable)
+{
+  if (enable == getEnableWindVelocity())
+    return;
+  if (enable)
+    mWindVelocityPort = MatrixOutputPort(this, "windVelocity", Size(3, 1));
+  else
+    mWindVelocityPort.clear();
+}
+
+bool
+Sensor::getEnableWindVelocity() const
+{
+  return !mWindVelocityPort.empty();
+}
+
+void
 Sensor::setEnableTemperature(bool enable)
 {
   if (enable == getEnableTemperature())

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.h	2008-11-25 19:37:06 UTC (rev 794)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.h	2008-11-25 19:48:48 UTC (rev 795)
@@ -61,6 +61,12 @@
   bool getEnableCentrifugalAcceleration() const;
 
 
+  /// Set availabilty of the wind velocity output port
+  void setEnableWindVelocity(bool enable);
+  /// Get availabilty of the wind velocity output port
+  bool getEnableWindVelocity() const;
+
+
   /// Set availabilty of the temperature output port
   void setEnableTemperature(bool enable);
   /// Get availabilty of the temperature output port
@@ -85,6 +91,8 @@
 
   MatrixOutputPort mCentrifugalAccelerationPort;
 
+  MatrixOutputPort mWindVelocityPort;
+
   RealOutputPort mTemperaturePort;
   RealOutputPort mPressurePort;
 //   RealOutputPort mDensityPort;



From frohlich at mail.berlios.de  Tue Nov 25 20:58:27 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Tue, 25 Nov 2008 20:58:27 +0100
Subject: [OpenFDM-svn] r796 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811251958.mAPJwRW8004726@sheep.berlios.de>

Author: frohlich
Date: 2008-11-25 20:58:26 +0100 (Tue, 25 Nov 2008)
New Revision: 796

Removed:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Turbulence.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Wind.h
Log:
Remove obsolete files.

D    OpenFDM/Turbulence.h
D    OpenFDM/Wind.h


Deleted: branches/OpenFDM-StateSeparation/src/OpenFDM/Turbulence.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Turbulence.h	2008-11-25 19:48:48 UTC (rev 795)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Turbulence.h	2008-11-25 19:58:26 UTC (rev 796)
@@ -1,31 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
- *
- */
-
-#ifndef OpenFDM_Turbulence_H
-#define OpenFDM_Turbulence_H
-
-#include "Types.h"
-#include "Object.h"
-#include "Vector.h"
-
-namespace OpenFDM {
-
-/** Turbulence model.
- * Not yet something useful ...
- */
-
-class Turbulence
-  : public EnvironmentObject {
-public:
-  Turbulence(void) {}
-  virtual ~Turbulence(void) {}
-
-//   // Return the Turbulence velocity in the global coordinate frame.
-//   virtual Vector3 getWindVel(const Vector3& pos) const /*= 0;*/
-//   { return Vector3::zeros(); }
-};
-
-} // namespace OpenFDM
-
-#endif

Deleted: branches/OpenFDM-StateSeparation/src/OpenFDM/Wind.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Wind.h	2008-11-25 19:48:48 UTC (rev 795)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Wind.h	2008-11-25 19:58:26 UTC (rev 796)
@@ -1,29 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
- *
- */
-
-#ifndef OpenFDM_Wind_H
-#define OpenFDM_Wind_H
-
-#include "Types.h"
-#include "EnvironmentObject.h"
-#include "Vector.h"
-
-namespace OpenFDM {
-
-class Wind
-  : public EnvironmentObject {
-public:
-  Wind(void) {}
-  virtual ~Wind(void) {}
-
-  // Return the wind velocity in the global coordinate frame.
-  // ????
-  // FIXME: make pure virtual
-  virtual Vector3 getWindVel(const Vector3& pos) const /*= 0;*/
-  { return Vector3::zeros(); }
-};
-
-} // namespace OpenFDM
-
-#endif



From frohlich at mail.berlios.de  Tue Nov 25 21:00:04 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Tue, 25 Nov 2008 21:00:04 +0100
Subject: [OpenFDM-svn] r797 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811252000.mAPK04Yf004962@sheep.berlios.de>

Author: frohlich
Date: 2008-11-25 21:00:02 +0100 (Tue, 25 Nov 2008)
New Revision: 797

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
Log:
Remove build system notes for obsolete files.

M    Makefile.am


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-11-25 19:58:26 UTC (rev 796)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-11-25 20:00:02 UTC (rev 797)
@@ -236,13 +236,11 @@
   Tank.h \
   TimeDerivative.h \
   TransferFunction.h \
-  Turbulence.h \
   UnaryFunction.h \
   UnaryModel.h \
   UnitConversion.h \
   UniversalJoint.h \
-  WheelContact.h \
-  Wind.h
+  WheelContact.h
 
 OpenFDMModelsSOURCES = \
   AirSpring.cpp \



From frohlich at mail.berlios.de  Wed Nov 26 20:32:43 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Wed, 26 Nov 2008 20:32:43 +0100
Subject: [OpenFDM-svn] r798 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811261932.mAQJWhOR021427@sheep.berlios.de>

Author: frohlich
Date: 2008-11-26 20:32:26 +0100 (Wed, 26 Nov 2008)
New Revision: 798

Added:
   branches/OpenFDM-StateSeparation/src/OpenFDM/SimpleDirectModel.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/SimpleDirectModel.h
Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
   branches/OpenFDM-StateSeparation/src/OpenFDM/MaxModel.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/MaxModel.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/MinModel.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/MinModel.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Summer.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Summer.h
Log:
Partly reactivate Summer, MinModel and MaxModel.

M    OpenFDM/MaxModel.h
M    OpenFDM/Summer.h
M    OpenFDM/Makefile.am
M    OpenFDM/MaxModel.cpp
A    OpenFDM/SimpleDirectModel.h
M    OpenFDM/MinModel.h
M    OpenFDM/Summer.cpp
M    OpenFDM/MinModel.cpp
A    OpenFDM/SimpleDirectModel.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-11-25 20:00:02 UTC (rev 797)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-11-26 19:32:26 UTC (rev 798)
@@ -228,6 +228,7 @@
   Saturation.h \
   Sensor.h \
   SimpleContact.h \
+  SimpleDirectModel.h \
   SimpleGear.h \
   SimulationTime.h \
   Summer.h \
@@ -254,18 +255,19 @@
   Input.cpp \
   Integrator.cpp \
   LinearSpringDamper.cpp \
+  MaxModel.cpp \
+  MinModel.cpp \
   Output.cpp \
   Saturation.cpp \
+  SimpleDirectModel.cpp \
   SimulationTime.cpp \
+  Summer.cpp \
   UnaryFunction.cpp \
   UnaryModel.cpp \
   UnitConversion.cpp
 
 #   DiscBrake.cpp \
-#   MaxModel.cpp \
-#   MinModel.cpp \
 #   Product.cpp \
-#   Summer.cpp \
 #   Table.cpp \
 #   TimeDerivative.cpp \
 #   TransferFunction.cpp \

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MaxModel.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MaxModel.cpp	2008-11-25 20:00:02 UTC (rev 797)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MaxModel.cpp	2008-11-26 19:32:26 UTC (rev 798)
@@ -11,79 +11,30 @@
 
 namespace OpenFDM {
 
-BEGIN_OPENFDM_OBJECT_DEF(MaxModel, Model)
+BEGIN_OPENFDM_OBJECT_DEF(MaxModel, SimpleDirectModel)
   DEF_OPENFDM_PROPERTY(Unsigned, NumMaxInputs, Serialized)
   END_OPENFDM_OBJECT_DEF
 
 MaxModel::MaxModel(const std::string& name) :
-  Model(name)
+  SimpleDirectModel(name)
 {
-  setDirectFeedThrough(true);
-
-  setNumInputPorts(2);
-  setInputPortName(0, "Input 0");
-  setInputPortName(1, "Input 1");
-  
-  setNumOutputPorts(1);
-  setOutputPort(0, "output", this, &MaxModel::getMax);
 }
 
 MaxModel::~MaxModel(void)
 {
 }
 
-bool
-MaxModel::init(void)
-{
-  // Make sure it is invalid if sizes do not match.
-  mMax.resize(0, 0);
-
-  mInputPorts.clear();
-  unsigned n = getNumInputPorts();
-  if (n == 0) {
-      Log(Model, Error) << "No input ports for MaxModel \""
-                        << getName() << "\"" << endl;
-      return false;
-  }
-  for (unsigned i = 0; i < n; ++i) {
-    MatrixPortHandle matrixPort = getInputPort(i)->toMatrixPortHandle();
-    if (!matrixPort.isConnected()) {
-      Log(Model, Error) << "Found unconnected input Port for MaxModel \""
-                        << getName() << "\"" << endl;
-      return false;
-    }
-    mInputPorts.push_back(matrixPort);
-
-    Matrix a = matrixPort.getMatrixValue();
-    if (i == 0) {
-      mMax.resize(a);
-    } else {
-      if (size(mMax) != size(a)) {
-        Log(Model, Error) << "Input port sizes for MaxModel \""
-                          << getName() << "\" do not match." << endl;
-        return false;
-      }
-    }
-  }
-
-  return Model::init();
-}
-
 void
-MaxModel::output(const TaskInfo&)
+MaxModel::output(Context& context) const
 {
-  // the input method guarantees that there is at least one input
-  mMax = mInputPorts[0].getMatrixValue();
-  for (unsigned i = 1; i < mInputPorts.size(); ++i)
-    mMax = LinAlg::max(mMax, mInputPorts[i].getMatrixValue());
+  if (!getNumInputPorts())
+    return;
+  context.getOutputValue() = context.getInputValue(0);
+  for (unsigned i = 1; i < getNumInputPorts(); ++i)
+    context.getOutputValue()
+      = LinAlg::max(context.getOutputValue(), context.getInputValue(i));
 }
 
-const Matrix&
-MaxModel::getMax(void) const
-{
-  return mMax;
-}
-
 unsigned
 MaxModel::getNumMaxInputs(void) const
 {
@@ -93,7 +44,7 @@
 void
 MaxModel::setNumMaxInputs(unsigned num)
 {
-  setNumInputPorts(num);
+//   setNumInputPorts(num);
 }
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MaxModel.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MaxModel.h	2008-11-25 20:00:02 UTC (rev 797)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MaxModel.h	2008-11-26 19:32:26 UTC (rev 798)
@@ -7,28 +7,20 @@
 
 #include <string>
 
-#include "Matrix.h"
-#include "Model.h"
+#include "SimpleDirectModel.h"
 
 namespace OpenFDM {
 
-class MaxModel : public Model {
-  OPENFDM_OBJECT(MaxModel, Model);
+class MaxModel : public SimpleDirectModel {
+  OPENFDM_OBJECT(MaxModel, SimpleDirectModel);
 public:
   MaxModel(const std::string& name);
   virtual ~MaxModel(void);
   
-  virtual bool init(void);
-  virtual void output(const TaskInfo&);
+  virtual void output(Context& context) const;
 
-  const Matrix& getMax(void) const;
-
   unsigned getNumMaxInputs(void) const;
   void setNumMaxInputs(unsigned num);
-
-private:
-  Matrix mMax;
-  std::vector<MatrixPortHandle> mInputPorts;
 };
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MinModel.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MinModel.cpp	2008-11-25 20:00:02 UTC (rev 797)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MinModel.cpp	2008-11-26 19:32:26 UTC (rev 798)
@@ -11,80 +11,30 @@
 
 namespace OpenFDM {
 
-BEGIN_OPENFDM_OBJECT_DEF(MinModel, Model)
+BEGIN_OPENFDM_OBJECT_DEF(MinModel, SimpleDirectModel)
   DEF_OPENFDM_PROPERTY(Unsigned, NumMinInputs, Serialized)
   END_OPENFDM_OBJECT_DEF
 
 MinModel::MinModel(const std::string& name) :
-  Model(name)
+  SimpleDirectModel(name)
 {
-  setDirectFeedThrough(true);
-
-  setNumInputPorts(2);
-  setInputPortName(0, "Input 0");
-  setInputPortName(1, "Input 1");
-  
-  setNumOutputPorts(1);
-  setOutputPort(0, "output", this, &MinModel::getMin);
 }
 
 MinModel::~MinModel(void)
 {
 }
 
-bool
-MinModel::init(void)
-{
-  // Make sure it is invalid if sizes do not match.
-  mMin.resize(0, 0);
-
-  mInputPorts2.clear();
-
-  unsigned n = getNumInputPorts();
-  if (n == 0) {
-      Log(Model, Error) << "No input ports for MinModel \""
-                        << getName() << "\"" << endl;
-      return false;
-  }
-  for (unsigned i = 0; i < n; ++i) {
-    MatrixPortHandle matrixPort = getInputPort(i)->toMatrixPortHandle();
-    if (!matrixPort.isConnected()) {
-      Log(Model, Error) << "Found unconnected input Port for MinModel \""
-                        << getName() << "\"" << endl;
-      return false;
-    }
-    mInputPorts2.push_back(matrixPort);
-
-    Matrix a = matrixPort.getMatrixValue();
-    if (i == 0) {
-      mMin.resize(a);
-    } else {
-      if (size(mMin) != size(a)) {
-        Log(Model, Error) << "Input port sizes for MinModel \""
-                          << getName() << "\" do not match." << endl;
-        return false;
-      }
-    }
-  }
-
-  return Model::init();
-}
-
 void
-MinModel::output(const TaskInfo&)
+MinModel::output(Context& context) const
 {
-  // the input method guarantees that there is at least one input
-  mMin = mInputPorts2[0].getMatrixValue();
-  for (unsigned i = 1; i < mInputPorts2.size(); ++i)
-    mMin = LinAlg::min(mMin, mInputPorts2[i].getMatrixValue());
+  if (!getNumInputPorts())
+    return;
+  context.getOutputValue() = context.getInputValue(0);
+  for (unsigned i = 1; i < getNumInputPorts(); ++i)
+    context.getOutputValue()
+      = LinAlg::min(context.getOutputValue(), context.getInputValue(i));
 }
 
-const Matrix&
-MinModel::getMin(void) const
-{
-  return mMin;
-}
-
 unsigned
 MinModel::getNumMinInputs(void) const
 {
@@ -94,7 +44,7 @@
 void
 MinModel::setNumMinInputs(unsigned num)
 {
-  setNumInputPorts(num);
+//   setNumInputPorts(num);
 }
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MinModel.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MinModel.h	2008-11-25 20:00:02 UTC (rev 797)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MinModel.h	2008-11-26 19:32:26 UTC (rev 798)
@@ -7,28 +7,20 @@
 
 #include <string>
 
-#include "Matrix.h"
-#include "Model.h"
+#include "SimpleDirectModel.h"
 
 namespace OpenFDM {
 
-class MinModel : public Model {
-  OPENFDM_OBJECT(MinModel, Model);
+class MinModel : public SimpleDirectModel {
+  OPENFDM_OBJECT(MinModel, SimpleDirectModel);
 public:
   MinModel(const std::string& name);
   virtual ~MinModel(void);
-  
-  virtual bool init(void);
-  virtual void output(const TaskInfo&);
 
-  const Matrix& getMin(void) const;
-
+  virtual void output(Context& context) const;
+  
   unsigned getNumMinInputs(void) const;
   void setNumMinInputs(unsigned num);
-
-private:
-  Matrix mMin;
-  std::vector<MatrixPortHandle> mInputPorts2;
 };
 
 } // namespace OpenFDM

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/SimpleDirectModel.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/SimpleDirectModel.cpp	2008-11-25 20:00:02 UTC (rev 797)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/SimpleDirectModel.cpp	2008-11-26 19:32:26 UTC (rev 798)
@@ -0,0 +1,146 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
+ *
+ */
+
+#include "SimpleDirectModel.h"
+
+#include "Matrix.h"
+#include "AbstractModel.h"
+#include "ModelContext.h"
+
+namespace OpenFDM {
+
+SimpleDirectModel::Context::Context(const SimpleDirectModel* model,
+                                    const InputValueVector& inputValues,
+                                    NumericPortValue* outputValue) :
+  mModel(model),
+  mInputValues(inputValues),
+  mOutputValue(outputValue)
+{
+}
+
+SimpleDirectModel::Context::~Context()
+{
+}
+    
+const SimpleDirectModel&
+SimpleDirectModel::Context::getNode() const
+{
+  return *mModel;
+}
+    
+void
+SimpleDirectModel::Context::initOutput(const /*Init*/Task&)
+{
+  mModel->output(*this);
+}
+
+void
+SimpleDirectModel::Context::output(const Task&)
+{
+  mModel->output(*this);
+}
+
+void
+SimpleDirectModel::Context::update(const DiscreteTask&)
+{
+}
+
+void
+SimpleDirectModel::Context::derivative(const Task&)
+{
+}
+
+BEGIN_OPENFDM_OBJECT_DEF(SimpleDirectModel, AbstractModel)
+  END_OPENFDM_OBJECT_DEF
+
+SimpleDirectModel::SimpleDirectModel(const std::string& name) :
+  AbstractModel(name),
+  mOutputPort(new OutputPortInfo(this, "output", Size(0, 0), false))
+{
+}
+
+SimpleDirectModel::~SimpleDirectModel()
+{
+}
+
+ModelContext*
+SimpleDirectModel::newModelContext(PortValueList& portValueList) const
+{
+  if (mInputPorts.empty()) {
+    Log(Initialization, Info)
+      << "No input ports in models with multiple inputs!" << std::endl;
+    return 0;
+  }
+  
+  NumericPortValue* outputPortValue = portValueList.getPortValue(mOutputPort);
+  if (!outputPortValue) {
+    Log(Initialization, Warning)
+      << "Output port value not connected for model \"" << getName()
+      << "\"!" << std::endl;
+    return 0;
+  }
+  InputValueVector inputValues;
+  
+  /// FIXME, hmm, this can be made generically on the port infos directly??
+  // May be some 'Simple pointwise model' type that just allows equal
+  // numeric ports in size and type??
+  
+  // Look into all ports and get the best size match.
+  Size sz = size(outputPortValue->getValue());
+  for (unsigned i = 0; i < mInputPorts.size(); ++i) {
+    NumericPortValue* npv = portValueList.getPortValue(mInputPorts[i]);
+    inputValues.push_back(npv);
+    Size sz2 = size(npv->getValue());
+    // If the ports size is undefined, use the size variabe here.
+    for (unsigned j = 0; j < 2; ++j) {
+      if (sz(j) == 0) {
+        sz(j) = sz2(j);
+      } else {
+        if (sz(j) != sz2(j)) {
+          Log(Initialization, Info)
+            << "Port size " << j << " does not match for model \""
+            << getName() << "\"!" << std::endl;
+          return 0;
+        }
+      }
+    }
+  }
+  
+  // Ok, success in checking output and input ports, set them all.
+  if (!portValueList.setOrCheckPortSize(mOutputPort, sz)) {
+    Log(Initialization, Info) << "Port sizes do not match!" << std::endl;
+    return 0;
+  }
+  for (unsigned i = 0; i < mInputPorts.size(); ++i) {
+    if (!portValueList.setOrCheckPortSize(mInputPorts[i], sz)) {
+      Log(Initialization, Info) << "Port sizes do not match!" << std::endl;
+      return 0;
+    }
+  }
+  
+  SharedPtr<Context> context;
+  context = new Context(this, inputValues, outputPortValue);
+  /// FIXME, this is for legacy lport value stuff ...
+  for (unsigned i = 0; i < getNumPorts(); ++i) {
+    PortValue* portValue = portValueList.getPortValue(i);
+    if (!portValue) {
+      Log(Model, Error) << "No port value given for model \"" << getName()
+                        << "\" and port \"" << getPort(i)->getName()
+                        << "\"" << endl;
+      return 0;
+    }
+    context->setPortValue(*getPort(i), portValue);
+  }
+  
+  /// FIXME, should not need to do that either ...
+  if (!context->allocStates()) {
+    Log(Model, Warning) << "Could not alloc for model \""
+                        << getName() << "\"" << endl;
+    return 0;
+  }
+  
+  return context.release();
+}
+
+} // namespace OpenFDM

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/SimpleDirectModel.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/SimpleDirectModel.h	2008-11-25 20:00:02 UTC (rev 797)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/SimpleDirectModel.h	2008-11-26 19:32:26 UTC (rev 798)
@@ -0,0 +1,84 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_SimpleDirectModel_H
+#define OpenFDM_SimpleDirectModel_H
+
+#include <string>
+
+#include "Matrix.h"
+#include "AbstractModel.h"
+#include "ModelContext.h"
+
+namespace OpenFDM {
+
+class SimpleDirectModel : public AbstractModel {
+  OPENFDM_OBJECT(SimpleDirectModel, AbstractModel);
+public:
+  SimpleDirectModel(const std::string& name);
+  virtual ~SimpleDirectModel();
+
+  unsigned getNumInputPorts() const
+  { return mInputPorts.size(); }
+
+  class Context;
+  virtual ModelContext* newModelContext(PortValueList& portValueList) const;
+  virtual void output(Context& context) const = 0;
+
+  typedef std::vector<SharedPtr<const NumericPortValue> > InputValueVector;
+  class Context : public ModelContext {
+  public:
+    Context(const SimpleDirectModel* model, const InputValueVector& inputValues,
+            NumericPortValue* outputValue);
+    virtual ~Context();
+    
+    virtual const SimpleDirectModel& getNode() const;
+    
+    virtual void initOutput(const /*Init*/Task&);
+    virtual void output(const Task&);
+    virtual void update(const DiscreteTask&);
+    virtual void derivative(const Task&);
+    
+    const Matrix& getInputValue(unsigned i)
+    {
+      OpenFDMAssert(i < mInputValues.size());
+      return mInputValues[i]->getValue();
+    }
+    Matrix& getOutputValue()
+    { return mOutputValue->getValue(); }
+
+  private:
+    SharedPtr<const SimpleDirectModel> mModel;
+    InputValueVector mInputValues;
+    SharedPtr<NumericPortValue> mOutputValue;
+  };
+
+// protected:
+  PortId addInputPort(const std::string& name)
+  {
+    mInputPorts.push_back(new InputPortInfo(this, name, Size(0, 0), true));
+    return PortId(mInputPorts.back());
+  }
+  void removeInputPort(const PortId& portId)
+  {
+    InputPortVector::iterator i = mInputPorts.begin();
+    while (i != mInputPorts.end()) {
+      if (portId != PortId(*i)) {
+        ++i;
+        continue;
+      }
+      (*i)->clear();
+      i = mInputPorts.erase(i);
+    }
+  }
+
+private:
+  typedef std::vector<SharedPtr<InputPortInfo> > InputPortVector;
+  InputPortVector mInputPorts;
+  SharedPtr<OutputPortInfo> mOutputPort;
+};
+
+} // namespace OpenFDM
+
+#endif

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Summer.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Summer.cpp	2008-11-25 20:00:02 UTC (rev 797)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Summer.cpp	2008-11-26 19:32:26 UTC (rev 798)
@@ -11,124 +11,64 @@
 
 namespace OpenFDM {
 
-BEGIN_OPENFDM_OBJECT_DEF(Summer, Model)
-  DEF_OPENFDM_PROPERTY(Unsigned, NumSummands, Serialized)
+BEGIN_OPENFDM_OBJECT_DEF(Summer, SimpleDirectModel)
+//   DEF_OPENFDM_PROPERTY(Unsigned, NumSummands, Serialized)
   END_OPENFDM_OBJECT_DEF
 
 Summer::Summer(const std::string& name) :
-  Model(name)
+  SimpleDirectModel(name)
 {
-  setDirectFeedThrough(true);
-
-  setNumInputPorts(2);
-  setInputPortName(0, "+");
-  setInputPortName(1, "+");
-  
-  setNumOutputPorts(1);
-  setOutputPort(0, "output", this, &Summer::getSum);
 }
 
 Summer::~Summer(void)
 {
 }
 
-bool
-Summer::init(void)
-{
-  // Make sure it is invalid if sizes do not match.
-  mSum.resize(0, 0);
-
-  mPositiveSummandPorts.clear();
-  mNegativeSummandPorts.clear();
-  for (unsigned i = 0; i < getNumInputPorts(); ++i) {
-    MatrixPortHandle matrixPort = getInputPort(i)->toMatrixPortHandle();
-    if (!matrixPort.isConnected()) {
-      Log(Model, Error) << "Found unconnected input Port for Summer \""
-                        << getName() << "\"" << endl;
-      return false;
-    }
-    if (getInputPortName(i) == "-") {
-      mNegativeSummandPorts.push_back(matrixPort);
-    } else {
-      mPositiveSummandPorts.push_back(matrixPort);
-    }
-
-    Matrix a = matrixPort.getMatrixValue();
-    if (i == 0) {
-      mSum.resize(a);
-    } else {
-      if (size(mSum) != size(a)) {
-        Log(Model, Error) << "Input port sizes for Summer \""
-                          << getName() << "\" do not match." << endl;
-        return false;
-      }
-    }
-  }
-
-  return Model::init();
-}
-
 void
-Summer::output(const TaskInfo&)
+Summer::output(Context& context) const
 {
-  mSum.clear();
-
-  std::vector<MatrixPortHandle>::iterator it = mNegativeSummandPorts.begin();
-  while (it != mNegativeSummandPorts.end()) {
-    mSum -= (*it).getMatrixValue();
-    ++it;
-  }
-  it = mPositiveSummandPorts.begin();
-  while (it != mPositiveSummandPorts.end()) {
-    mSum += (*it).getMatrixValue();
-    ++it;
-  }
-
-  Log(Model,Debug3) << "Output of Summer \"" << getName() << "\" "
-                    << mSum << endl;
+  if (!getNumInputPorts())
+    return;
+  context.getOutputValue() = context.getInputValue(0);
+  for (unsigned i = 1; i < getNumInputPorts(); ++i)
+    context.getOutputValue() += context.getInputValue(i);
 }
 
-const Matrix&
-Summer::getSum(void) const
-{
-  return mSum;
-}
+// unsigned
+// Summer::getNumSummands(void) const
+// {
+//   return getNumInputPorts();
+// }
 
-unsigned
-Summer::getNumSummands(void) const
-{
-  return getNumInputPorts();
-}
+// void
+// Summer::setNumSummands(unsigned num)
+// {
+//   unsigned oldnum = getNumSummands();
+//   setNumInputPorts(num);
+//   for (; oldnum < num; ++oldnum)
+//     setInputPortName(oldnum, "+");
+// }
 
-void
-Summer::setNumSummands(unsigned num)
-{
-  unsigned oldnum = getNumSummands();
-  setNumInputPorts(num);
-  for (; oldnum < num; ++oldnum)
-    setInputPortName(oldnum, "+");
-}
+// void
+// Summer::setInputSign(unsigned num, Sign sign)
+// {
+//   if (getNumSummands() <= num)
+//     return;
+//   if (sign == Minus)
+//     setInputPortName(num, "-");
+//   else
+//     setInputPortName(num, "+");
+// }
 
-void
-Summer::setInputSign(unsigned num, Sign sign)
-{
-  if (getNumSummands() <= num)
-    return;
-  if (sign == Minus)
-    setInputPortName(num, "-");
-  else
-    setInputPortName(num, "+");
-}
+// Summer::Sign
+// Summer::getInputSign(unsigned num) const
+// {
+//   if (getNumSummands() <= num)
+//     return Plus;
+//   if (getInputPortName(num) == "-")
+//     return Minus;
+//   else
+//     return Plus;
+// }
 
-Summer::Sign
-Summer::getInputSign(unsigned num) const
-{
-  if (getNumSummands() <= num)
-    return Plus;
-  if (getInputPortName(num) == "-")
-    return Minus;
-  else
-    return Plus;
-}
-
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Summer.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Summer.h	2008-11-25 20:00:02 UTC (rev 797)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Summer.h	2008-11-26 19:32:26 UTC (rev 798)
@@ -6,34 +6,24 @@
 #define OpenFDM_Summer_H
 
 #include <string>
+#include "SimpleDirectModel.h"
 
-#include "Matrix.h"
-#include "Model.h"
-
 namespace OpenFDM {
 
-class Summer : public Model {
-  OPENFDM_OBJECT(Summer, Model);
+class Summer : public SimpleDirectModel {
+  OPENFDM_OBJECT(Summer, SimpleDirectModel);
 public:
   Summer(const std::string& name);
   virtual ~Summer(void);
   
-  virtual bool init(void);
-  virtual void output(const TaskInfo&);
+  virtual void output(Context& context) const;
 
-  const Matrix& getSum(void) const;
+//   unsigned getNumSummands(void) const;
+//   void setNumSummands(unsigned num);
 
-  unsigned getNumSummands(void) const;
-  void setNumSummands(unsigned num);
-
-  enum Sign { Plus, Minus };
-  void setInputSign(unsigned num, Sign sign);
-  Sign getInputSign(unsigned num) const;
-
-private:
-  Matrix mSum;
-  std::vector<MatrixPortHandle> mPositiveSummandPorts;
-  std::vector<MatrixPortHandle> mNegativeSummandPorts;
+//   enum Sign { Plus, Minus };
+//   void setInputSign(unsigned num, Sign sign);
+//   Sign getInputSign(unsigned num) const;
 };
 
 } // namespace OpenFDM



From frohlich at mail.berlios.de  Thu Nov 27 06:55:52 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Thu, 27 Nov 2008 06:55:52 +0100
Subject: [OpenFDM-svn] r799 - in branches/OpenFDM-StateSeparation/src:
	OpenFDM test
Message-ID: <200811270555.mAR5tq8c031437@sheep.berlios.de>

Author: frohlich
Date: 2008-11-27 06:55:50 +0100 (Thu, 27 Nov 2008)
New Revision: 799

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/SimpleDirectModel.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/SimpleDirectModel.h
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Do not use the global port value storage. Will vanish at some time.

M    src/test/structure.cpp
M    src/OpenFDM/SimpleDirectModel.h
M    src/OpenFDM/SimpleDirectModel.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/SimpleDirectModel.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/SimpleDirectModel.cpp	2008-11-26 19:32:26 UTC (rev 798)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/SimpleDirectModel.cpp	2008-11-27 05:55:50 UTC (rev 799)
@@ -28,6 +28,24 @@
 {
   return *mModel;
 }
+
+const PortValue*
+SimpleDirectModel::Context::getPortValue(const PortInfo& portInfo) const
+{
+  if (mModel->mOutputPort == &portInfo)
+    return mOutputValue;
+  OpenFDMAssert(mInputValues.size() == mModel->mInputPorts.size());
+  for (unsigned i = 0; i < mInputValues.size(); ++i)
+    if (mModel->mInputPorts[i] == &portInfo)
+      return mInputValues[i];
+  return 0;
+}
+
+void
+SimpleDirectModel::Context::setPortValue(const PortInfo& i, PortValue* v)
+{
+  OpenFDMAssert(false);
+}
     
 void
 SimpleDirectModel::Context::initOutput(const /*Init*/Task&)
@@ -119,28 +137,7 @@
     }
   }
   
-  SharedPtr<Context> context;
-  context = new Context(this, inputValues, outputPortValue);
-  /// FIXME, this is for legacy lport value stuff ...
-  for (unsigned i = 0; i < getNumPorts(); ++i) {
-    PortValue* portValue = portValueList.getPortValue(i);
-    if (!portValue) {
-      Log(Model, Error) << "No port value given for model \"" << getName()
-                        << "\" and port \"" << getPort(i)->getName()
-                        << "\"" << endl;
-      return 0;
-    }
-    context->setPortValue(*getPort(i), portValue);
-  }
-  
-  /// FIXME, should not need to do that either ...
-  if (!context->allocStates()) {
-    Log(Model, Warning) << "Could not alloc for model \""
-                        << getName() << "\"" << endl;
-    return 0;
-  }
-  
-  return context.release();
+  return new Context(this, inputValues, outputPortValue);
 }
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/SimpleDirectModel.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/SimpleDirectModel.h	2008-11-26 19:32:26 UTC (rev 798)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/SimpleDirectModel.h	2008-11-27 05:55:50 UTC (rev 799)
@@ -34,6 +34,8 @@
     virtual ~Context();
     
     virtual const SimpleDirectModel& getNode() const;
+    virtual const PortValue* getPortValue(const PortInfo&) const;
+    virtual void setPortValue(const PortInfo&, PortValue*);
     
     virtual void initOutput(const /*Init*/Task&);
     virtual void output(const Task&);

Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-11-26 19:32:26 UTC (rev 798)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-11-27 05:55:50 UTC (rev 799)
@@ -8,6 +8,7 @@
 #include <OpenFDM/GroupOutput.h>
 #include <OpenFDM/LibraryNode.h>
 #include <OpenFDM/LibraryModel.h>
+#include <OpenFDM/Summer.h>
 #include <OpenFDM/System.h>
 #include <OpenFDM/SystemOutput.h>
 
@@ -121,11 +122,18 @@
   Group::NodeId delay = group->addChild(new Delay("D"));
   Group::NodeId outputDelay = group->addChild(new Output("OD"));
 
+  Summer* summer = new Summer("S");
+  summer->addInputPort("input0");
+  summer->addInputPort("input1");
+  Group::NodeId summerId = group->addChild(summer);
+
   group->connect(integrator1, "output", integrator2, "input");
   group->connect(integrator2, "output", gain, "input");
   group->connect(gain, "output", integrator1, "input");
+  group->connect(gain, "output", summerId, "input0");
+  group->connect(gain, "output", summerId, "input1");
   group->connect(integrator2, "output", output, "input");
-  group->connect(gain, "output", delay, "input");
+  group->connect(summerId, "output", delay, "input");
   group->connect(delay, "output", outputDelay, "input");
 
   Group::NodeId groupOutputNode = group->addChild(new GroupOutput("GIO"));



From frohlich at mail.berlios.de  Thu Nov 27 07:26:31 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Thu, 27 Nov 2008 07:26:31 +0100
Subject: [OpenFDM-svn] r800 - in branches/OpenFDM-StateSeparation/src:
	OpenFDM test
Message-ID: <200811270626.mAR6QVM5029932@sheep.berlios.de>

Author: frohlich
Date: 2008-11-27 07:26:21 +0100 (Thu, 27 Nov 2008)
New Revision: 800

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
   branches/OpenFDM-StateSeparation/src/OpenFDM/MaxModel.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/MinModel.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Product.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Product.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/SimpleDirectModel.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Summer.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Summer.h
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
All the multi input models are back up for use.

M    src/test/structure.cpp
M    src/OpenFDM/Summer.h
M    src/OpenFDM/Makefile.am
M    src/OpenFDM/Product.cpp
M    src/OpenFDM/MaxModel.cpp
M    src/OpenFDM/SimpleDirectModel.h
M    src/OpenFDM/Product.h
M    src/OpenFDM/Summer.cpp
M    src/OpenFDM/MinModel.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-11-27 05:55:50 UTC (rev 799)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-11-27 06:26:21 UTC (rev 800)
@@ -258,6 +258,7 @@
   MaxModel.cpp \
   MinModel.cpp \
   Output.cpp \
+  Product.cpp \
   Saturation.cpp \
   SimpleDirectModel.cpp \
   SimulationTime.cpp \
@@ -267,7 +268,6 @@
   UnitConversion.cpp
 
 #   DiscBrake.cpp \
-#   Product.cpp \
 #   Table.cpp \
 #   TimeDerivative.cpp \
 #   TransferFunction.cpp \

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MaxModel.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MaxModel.cpp	2008-11-27 05:55:50 UTC (rev 799)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MaxModel.cpp	2008-11-27 06:26:21 UTC (rev 800)
@@ -5,6 +5,7 @@
 #include "MaxModel.h"
 
 #include <string>
+#include <sstream>
 #include "Types.h"
 #include "Matrix.h"
 #include "Model.h"
@@ -18,6 +19,7 @@
 MaxModel::MaxModel(const std::string& name) :
   SimpleDirectModel(name)
 {
+  setNumMaxInputs(2);
 }
 
 MaxModel::~MaxModel(void)
@@ -44,7 +46,14 @@
 void
 MaxModel::setNumMaxInputs(unsigned num)
 {
-//   setNumInputPorts(num);
+  unsigned oldnum = getNumInputPorts();
+  for (; oldnum < num; ++oldnum) {
+    std::stringstream s;
+    s << "input" << oldnum;
+    addInputPort(s.str());
+  }
+  for (; num < oldnum; --oldnum)
+    removeInputPort(getInputPort(oldnum-1));
 }
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MinModel.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MinModel.cpp	2008-11-27 05:55:50 UTC (rev 799)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MinModel.cpp	2008-11-27 06:26:21 UTC (rev 800)
@@ -5,6 +5,7 @@
 #include "MinModel.h"
 
 #include <string>
+#include <sstream>
 #include "Types.h"
 #include "Matrix.h"
 #include "Model.h"
@@ -44,7 +45,14 @@
 void
 MinModel::setNumMinInputs(unsigned num)
 {
-//   setNumInputPorts(num);
+  unsigned oldnum = getNumInputPorts();
+  for (; oldnum < num; ++oldnum) {
+    std::stringstream s;
+    s << "input" << oldnum;
+    addInputPort(s.str());
+  }
+  for (; num < oldnum; --oldnum)
+    removeInputPort(getInputPort(oldnum-1));
 }
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Product.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Product.cpp	2008-11-27 05:55:50 UTC (rev 799)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Product.cpp	2008-11-27 06:26:21 UTC (rev 800)
@@ -5,96 +5,40 @@
 #include "Product.h"
 
 #include <string>
+#include <sstream>
 #include "Types.h"
 #include "Matrix.h"
-#include "Model.h"
 
 namespace OpenFDM {
 
-BEGIN_OPENFDM_OBJECT_DEF(Product, Model)
+BEGIN_OPENFDM_OBJECT_DEF(Product, SimpleDirectModel)
   DEF_OPENFDM_PROPERTY(Unsigned, NumFactors, Serialized)
   END_OPENFDM_OBJECT_DEF
 
 Product::Product(const std::string& name) :
-  Model(name)
+  SimpleDirectModel(name)
 {
-  setDirectFeedThrough(true);
-  setNumInputPorts(2);
-  setInputPortName(0, "*");
-  setInputPortName(1, "*");
-  
-  setNumOutputPorts(1);
-  setOutputPort(0, "output", this, &Product::getProduct);
+  setNumFactors(2);
 }
 
 Product::~Product(void)
 {
 }
 
-bool
-Product::init(void)
-{
-  mScalarFactorPorts.clear();
-  mMatrixFactorPorts.clear();
-  for (unsigned i = 0; i < getNumInputPorts(); ++i) {
-    RealPortHandle scalarHandle = getInputPort(i)->toRealPortHandle();
-    if (scalarHandle.isConnected())
-      mScalarFactorPorts.push_back(scalarHandle);
-    else {
-      MatrixPortHandle matrixHandle = getInputPort(i)->toMatrixPortHandle();
-      if (matrixHandle.isConnected()) {
-        if (!mMatrixFactorPorts.empty()) {
-          unsigned lastCols = cols(mMatrixFactorPorts.back().getMatrixValue());
-          unsigned thisRows = rows(matrixHandle.getMatrixValue());
-          if (lastCols != thisRows) {
-            Log(Model, Error) << "Dimensions for Product \""
-                              << getName() << "\" do not agree!" << endl;
-            return false;
-          }
-        }
-
-        mMatrixFactorPorts.push_back(matrixHandle);
-      } else {
-        Log(Model, Error) << "Found unconnected input Port for Product \""
-                          << getName() << "\"" << endl;
-        return false;
-      }
-    }
-  }
-  if (mMatrixFactorPorts.empty()) {
-    mProduct.resize(1, 1);
-  } else {
-    mProduct.resize(rows(mMatrixFactorPorts.front().getMatrixValue()),
-                    cols(mMatrixFactorPorts.back().getMatrixValue()));
-  }
-
-  return Model::init();
-}
-
 void
-Product::output(const TaskInfo&)
+Product::output(Context& context) const
 {
-  real_type scalarFac = 1;
-  for (unsigned i = 0; i < mScalarFactorPorts.size(); ++i)
-    scalarFac *= mScalarFactorPorts[i].getRealValue();
-  if (mMatrixFactorPorts.empty()) {
-    mProduct(0, 0) = scalarFac;
-  } else {
-    mProduct = mMatrixFactorPorts[0].getMatrixValue();
-    for (unsigned i = 1; i < mMatrixFactorPorts.size(); ++i)
-      mProduct = mProduct*mMatrixFactorPorts[i].getMatrixValue();
-    mProduct *= scalarFac;
+  if (!getNumInputPorts())
+    return;
+  Size sz = size(context.getInputValue(0));
+  context.getOutputValue() = context.getInputValue(0);
+  for (unsigned i = 1; i < getNumInputPorts(); ++i) {
+    for (unsigned j = 0; j < sz(0); ++j)
+      for (unsigned k = 0; k < sz(1); ++k)
+        context.getOutputValue()(j, k) *= context.getInputValue(i)(j, k);
   }
-  Log(Model,Debug3) << "Output of Product \"" << getName() << "\" "
-                    << mProduct << endl;
 }
 
-const Matrix&
-Product::getProduct(void) const
-{
-  return mProduct;
-}
-
 unsigned
 Product::getNumFactors(void) const
 {
@@ -105,9 +49,13 @@
 Product::setNumFactors(unsigned num)
 {
   unsigned oldnum = getNumFactors();
-  setNumInputPorts(num);
-  for (; oldnum < num; ++oldnum)
-    setInputPortName(oldnum, "*");
+  for (; oldnum < num; ++oldnum) {
+    std::stringstream s;
+    s << "input" << oldnum;
+    addInputPort(s.str());
+  }
+  for (; num < oldnum; --oldnum)
+    removeInputPort(getInputPort(oldnum-1));
 }
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Product.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Product.h	2008-11-27 05:55:50 UTC (rev 799)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Product.h	2008-11-27 06:26:21 UTC (rev 800)
@@ -7,29 +7,22 @@
 
 #include <string>
 
-#include "Matrix.h"
-#include "Model.h"
+#include "SimpleDirectModel.h"
 
 namespace OpenFDM {
 
-class Product : public Model {
-  OPENFDM_OBJECT(Product, Model);
+class Product : public SimpleDirectModel {
+  OPENFDM_OBJECT(Product, SimpleDirectModel);
 public:
   Product(const std::string& name);
   virtual ~Product(void);
 
-  virtual bool init(void);
-  virtual void output(const TaskInfo&);
+  // FIXME implements only pointwise products. Also want matrix products
 
-  const Matrix& getProduct(void) const;
+  virtual void output(Context& context) const;
 
   unsigned getNumFactors(void) const;
   void setNumFactors(unsigned num);
-
-private:
-  Matrix mProduct;
-  std::vector<RealPortHandle> mScalarFactorPorts;
-  std::vector<MatrixPortHandle> mMatrixFactorPorts;
 };
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/SimpleDirectModel.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/SimpleDirectModel.h	2008-11-27 05:55:50 UTC (rev 799)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/SimpleDirectModel.h	2008-11-27 06:26:21 UTC (rev 800)
@@ -21,6 +21,14 @@
 
   unsigned getNumInputPorts() const
   { return mInputPorts.size(); }
+  PortId getInputPort(unsigned i) const
+  {
+    if (mInputPorts.size() <= i)
+      return PortId();
+    return PortId(mInputPorts[i]);
+  }
+  PortId getOutputPort() const
+  { return PortId(mOutputPort); }
 
   class Context;
   virtual ModelContext* newModelContext(PortValueList& portValueList) const;
@@ -56,7 +64,7 @@
     SharedPtr<NumericPortValue> mOutputValue;
   };
 
-// protected:
+protected:
   PortId addInputPort(const std::string& name)
   {
     mInputPorts.push_back(new InputPortInfo(this, name, Size(0, 0), true));

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Summer.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Summer.cpp	2008-11-27 05:55:50 UTC (rev 799)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Summer.cpp	2008-11-27 06:26:21 UTC (rev 800)
@@ -5,6 +5,7 @@
 #include "Summer.h"
 
 #include <string>
+#include <sstream>
 #include "Types.h"
 #include "Matrix.h"
 #include "Model.h"
@@ -12,12 +13,13 @@
 namespace OpenFDM {
 
 BEGIN_OPENFDM_OBJECT_DEF(Summer, SimpleDirectModel)
-//   DEF_OPENFDM_PROPERTY(Unsigned, NumSummands, Serialized)
+  DEF_OPENFDM_PROPERTY(Unsigned, NumSummands, Serialized)
   END_OPENFDM_OBJECT_DEF
 
 Summer::Summer(const std::string& name) :
   SimpleDirectModel(name)
 {
+  setNumSummands(2);
 }
 
 Summer::~Summer(void)
@@ -29,46 +31,52 @@
 {
   if (!getNumInputPorts())
     return;
-  context.getOutputValue() = context.getInputValue(0);
-  for (unsigned i = 1; i < getNumInputPorts(); ++i)
-    context.getOutputValue() += context.getInputValue(i);
+  if (mSigns.front() == Plus)
+    context.getOutputValue() = context.getInputValue(0);
+  else
+    context.getOutputValue() = -context.getInputValue(0);
+  for (unsigned i = 1; i < getNumInputPorts(); ++i) {
+    if (mSigns[i] == Plus)
+      context.getOutputValue() += context.getInputValue(i);
+    else
+      context.getOutputValue() -= context.getInputValue(i);
+  }
 }
 
-// unsigned
-// Summer::getNumSummands(void) const
-// {
-//   return getNumInputPorts();
-// }
+unsigned
+Summer::getNumSummands(void) const
+{
+  return getNumInputPorts();
+}
 
-// void
-// Summer::setNumSummands(unsigned num)
-// {
-//   unsigned oldnum = getNumSummands();
-//   setNumInputPorts(num);
-//   for (; oldnum < num; ++oldnum)
-//     setInputPortName(oldnum, "+");
-// }
+void
+Summer::setNumSummands(unsigned num)
+{
+  mSigns.resize(num, Plus);
+  unsigned oldnum = getNumSummands();
+  for (; oldnum < num; ++oldnum) {
+    std::stringstream s;
+    s << "input" << oldnum;
+    addInputPort(s.str());
+  }
+  for (; num < oldnum; --oldnum)
+    removeInputPort(getInputPort(oldnum-1));
+}
 
-// void
-// Summer::setInputSign(unsigned num, Sign sign)
-// {
-//   if (getNumSummands() <= num)
-//     return;
-//   if (sign == Minus)
-//     setInputPortName(num, "-");
-//   else
-//     setInputPortName(num, "+");
-// }
+void
+Summer::setInputSign(unsigned num, Sign sign)
+{
+  if (mSigns.size() <= num)
+    return;
+  mSigns[num] = sign;
+}
 
-// Summer::Sign
-// Summer::getInputSign(unsigned num) const
-// {
-//   if (getNumSummands() <= num)
-//     return Plus;
-//   if (getInputPortName(num) == "-")
-//     return Minus;
-//   else
-//     return Plus;
-// }
+Summer::Sign
+Summer::getInputSign(unsigned num) const
+{
+  if (mSigns.size() <= num)
+    return Plus;
+  return mSigns[num];
+}
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Summer.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Summer.h	2008-11-27 05:55:50 UTC (rev 799)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Summer.h	2008-11-27 06:26:21 UTC (rev 800)
@@ -18,12 +18,15 @@
   
   virtual void output(Context& context) const;
 
-//   unsigned getNumSummands(void) const;
-//   void setNumSummands(unsigned num);
+  unsigned getNumSummands(void) const;
+  void setNumSummands(unsigned num);
 
-//   enum Sign { Plus, Minus };
-//   void setInputSign(unsigned num, Sign sign);
-//   Sign getInputSign(unsigned num) const;
+  enum Sign { Plus, Minus };
+  void setInputSign(unsigned num, Sign sign);
+  Sign getInputSign(unsigned num) const;
+
+private:
+  std::vector<Sign> mSigns;
 };
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-11-27 05:55:50 UTC (rev 799)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-11-27 06:26:21 UTC (rev 800)
@@ -123,8 +123,6 @@
   Group::NodeId outputDelay = group->addChild(new Output("OD"));
 
   Summer* summer = new Summer("S");
-  summer->addInputPort("input0");
-  summer->addInputPort("input1");
   Group::NodeId summerId = group->addChild(summer);
 
   group->connect(integrator1, "output", integrator2, "input");



From frohlich at mail.berlios.de  Thu Nov 27 20:16:41 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Thu, 27 Nov 2008 20:16:41 +0100
Subject: [OpenFDM-svn] r801 - in branches/OpenFDM-StateSeparation/src:
	JSBSim OpenFDM
Message-ID: <200811271916.mARJGfnM026937@sheep.berlios.de>

Author: frohlich
Date: 2008-11-27 20:16:40 +0100 (Thu, 27 Nov 2008)
New Revision: 801

Modified:
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimAerosurfaceScale.cpp
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimKinemat.cpp
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.h
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.cpp
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.h
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimScheduledGain.cpp
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimScheduledGain.h
   branches/OpenFDM-StateSeparation/src/JSBSim/Tablereader.cpp
   branches/OpenFDM-StateSeparation/src/JSBSim/Tablereader.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Table.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Table.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/TableData.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Variant.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Variant.h
Log:
TableLookup->BreakPointVector.
Use a Vector for lookup instead of a map.

M    src/JSBSim/JSBSimKinemat.cpp
M    src/JSBSim/JSBSimReaderBase.cpp
M    src/JSBSim/JSBSimScheduledGain.cpp
M    src/JSBSim/JSBSimReader.cpp
M    src/JSBSim/JSBSimReaderBase.h
M    src/JSBSim/Tablereader.cpp
M    src/JSBSim/JSBSimScheduledGain.h
M    src/JSBSim/JSBSimAerosurfaceScale.cpp
M    src/JSBSim/JSBSimReader.h
M    src/JSBSim/Tablereader.h
M    src/OpenFDM/Variant.cpp
M    src/OpenFDM/Table.h
M    src/OpenFDM/TableData.h
M    src/OpenFDM/Table.cpp
M    src/OpenFDM/Variant.h


Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimAerosurfaceScale.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimAerosurfaceScale.cpp	2008-11-27 06:26:21 UTC (rev 800)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimAerosurfaceScale.cpp	2008-11-27 19:16:40 UTC (rev 801)
@@ -31,11 +31,11 @@
   mInputSaturation->setMaxSaturation(tmp);
 
   mTablePreLookup = new TablePreLookup("Table Lookup");
-  TableLookup tl;
+  BreakPointVector tl;
   tl.setAtIndex(0, -1);
   tl.setAtIndex(1, 0);
   tl.setAtIndex(2, 1);
-  mTablePreLookup->setTableLookup(tl);
+  mTablePreLookup->setBreakPointVector(tl);
   getModelGroup()->addModel(mTablePreLookup);
   Connection::connect(mTablePreLookup->getInputPort(0),
                       mInputSaturation->getOutputPort(0));
@@ -80,9 +80,9 @@
   Matrix tmp(1, 1);
   tmp(0, 0) = minDomain;
   mInputSaturation->setMinSaturation(tmp);
-  TableLookup tl = mTablePreLookup->getTableLookup();
+  BreakPointVector tl = mTablePreLookup->getBreakPointVector();
   tl.setAtIndex(0, minDomain);
-  mTablePreLookup->setTableLookup(tl);
+  mTablePreLookup->setBreakPointVector(tl);
 }
 
 void
@@ -91,16 +91,16 @@
   Matrix tmp(1, 1);
   tmp(0, 0) = maxDomain;
   mInputSaturation->setMaxSaturation(tmp);
-  TableLookup tl = mTablePreLookup->getTableLookup();
+  BreakPointVector tl = mTablePreLookup->getBreakPointVector();
   tl.setAtIndex(tl.size()-1, maxDomain);
-  mTablePreLookup->setTableLookup(tl);
+  mTablePreLookup->setBreakPointVector(tl);
 }
 
 void
 JSBSimAerosurfaceScale::setCentered(bool centered)
 {
-  TableLookup tlOld = mTablePreLookup->getTableLookup();
-  TableLookup tl;
+  BreakPointVector tlOld = mTablePreLookup->getBreakPointVector();
+  BreakPointVector tl;
 
   TableData<1> tableDataOld = mTable->getTableData();
   TableData<1>::SizeVector sz;
@@ -136,7 +136,7 @@
     tableData(iv) = oldVal;
   }
 
-  mTablePreLookup->setTableLookup(tl);
+  mTablePreLookup->setBreakPointVector(tl);
   mTable->setTableData(tableData);
 }
 
@@ -153,7 +153,7 @@
 void
 JSBSimAerosurfaceScale::setMaxValue(real_type maxValue)
 {
-  TableLookup tl = mTablePreLookup->getTableLookup();
+  BreakPointVector tl = mTablePreLookup->getBreakPointVector();
   TableData<1> tableData = mTable->getTableData();
   TableData<1>::Index iv;
   iv(0) = tl.size()-1;
@@ -164,7 +164,7 @@
 void
 JSBSimAerosurfaceScale::setGain(real_type gain)
 {
-  TableLookup tl = mTablePreLookup->getTableLookup();
+  BreakPointVector tl = mTablePreLookup->getBreakPointVector();
   TableData<1> tableData = mTable->getTableData();
   TableData<1>::Index iv;
   iv(0) = 0;

Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimKinemat.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimKinemat.cpp	2008-11-27 06:26:21 UTC (rev 800)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimKinemat.cpp	2008-11-27 19:16:40 UTC (rev 801)
@@ -26,7 +26,7 @@
   //                                |
   //  -------------------------------
   //  |
-  //  o-|TableLookup|-o-|Minus|-| FIXME: that table lookup is still missing
+  //  o-|BreakPointVector|-o-|Minus|-| FIXME: that table lookup is still missing
   //  |               |         |
   //  +-|ErrorGain|--|Min|----|Max|-|Integrator|-o-|Outgain|-
   //  |                                          |

Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp	2008-11-27 06:26:21 UTC (rev 800)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp	2008-11-27 19:16:40 UTC (rev 801)
@@ -1353,7 +1353,7 @@
       return error("Table for scheduled gain is not 1 dimensional");
 
     TableData<1> data;
-    TableLookup lookup;
+    BreakPointVector lookup;
     if (!readTable1D(tbl, data, lookup))
       return error("Cannot read table");
     sGain->setTableData(data, lookup);
@@ -1613,7 +1613,7 @@
       unsigned dim = getNumTableDims(*ait);
       if (dim == 1) {
         TableData<1> data;
-        TableLookup lookup;
+        BreakPointVector lookup;
         if (!readTable1D(*ait, data, lookup)) {
           error("Cannot read 1D table data.");
           return std::list<PortProvider*>();
@@ -1630,7 +1630,7 @@
 
       } else if (dim == 2) {
         TableData<2> data;
-        TableLookup lookup[2];
+        BreakPointVector lookup[2];
         if (!readTable2D(*ait, data, lookup)) {
           error("Cannot read 2D table data.");
           return std::list<PortProvider*>();
@@ -1659,7 +1659,7 @@
 
       } else if (dim == 3) {
         TableData<3> data;
-        TableLookup lookup[3];
+        BreakPointVector lookup[3];
         if (!readTable3D(*ait, data, lookup)) {
           error("Cannot read 1D table data.");
           return std::list<PortProvider*>();
@@ -1714,7 +1714,7 @@
 
 bool
 JSBSimReader::readTable1D(const XMLElement* tableElem,
-                          TableData<1>& data, TableLookup& lookup)
+                          TableData<1>& data, BreakPointVector& lookup)
 {
   std::string input = stringData(tableElem->getElement("independentVar"));
 
@@ -1750,7 +1750,7 @@
 
 bool
 JSBSimReader::readTable2D(const XMLElement* tableElem,
-                          TableData<2>& data, TableLookup lookup[2])
+                          TableData<2>& data, BreakPointVector lookup[2])
 {
   std::list<const XMLElement*> indeps
     = tableElem->getElements("independentVar");
@@ -1813,7 +1813,7 @@
 
 bool
 JSBSimReader::readTable3D(const XMLElement* tableElem,
-                          TableData<3>& data, TableLookup lookup[3])
+                          TableData<3>& data, BreakPointVector lookup[3])
 {
   return false;
 //   std::list<const XMLElement*> indeps

Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.h	2008-11-27 06:26:21 UTC (rev 800)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.h	2008-11-27 19:16:40 UTC (rev 801)
@@ -61,11 +61,11 @@
 
   unsigned getNumTableDims(const XMLElement* tableElem);
   bool readTable1D(const XMLElement* tableElem,
-                   TableData<1>& data, TableLookup& lookup);
+                   TableData<1>& data, BreakPointVector& lookup);
   bool readTable2D(const XMLElement* tableElem,
-                   TableData<2>& data, TableLookup lookup[2]);
+                   TableData<2>& data, BreakPointVector lookup[2]);
   bool readTable3D(const XMLElement* tableElem,
-                   TableData<3>& data, TableLookup lookup[3]);
+                   TableData<3>& data, BreakPointVector lookup[3]);
 };
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.cpp	2008-11-27 06:26:21 UTC (rev 800)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.cpp	2008-11-27 19:16:40 UTC (rev 801)
@@ -830,7 +830,7 @@
 
 PortProvider*
 JSBSimReaderBase::getTablePrelookup(const std::string& name, PortProvider* in,
-                                    const TableLookup& tl)
+                                    const BreakPointVector& tl)
 {
   if (!in)
     return 0;
@@ -841,8 +841,8 @@
   // First check if we already have a table lookup for this port/brakepoint
   // combination. If so return that output port
   std::vector<SharedPtr<TablePreLookup> >::iterator it;
-  for (it = mTableLookups.begin(); it != mTableLookups.end(); ++it) {
-    if (tl == (*it)->getTableLookup() &&
+  for (it = mBreakPointVectors.begin(); it != mBreakPointVectors.end(); ++it) {
+    if (tl == (*it)->getBreakPointVector() &&
         nin->getPortInterface() == (*it)->getInputPort(0)->getPortInterface())
       return (*it)->getOutputPort(0);
   }
@@ -851,9 +851,9 @@
   TablePreLookup* tablePreLookup
     = new TablePreLookup(name + " Table Prelookup");
   addMultiBodyModel(tablePreLookup);
-  tablePreLookup->setTableLookup(tl);
+  tablePreLookup->setBreakPointVector(tl);
   Connection::connect(in, tablePreLookup->getInputPort(0));
-  mTableLookups.push_back(tablePreLookup);
+  mBreakPointVectors.push_back(tablePreLookup);
   return tablePreLookup->getOutputPort(0);
 }
 

Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.h	2008-11-27 06:26:21 UTC (rev 800)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.h	2008-11-27 19:16:40 UTC (rev 801)
@@ -263,7 +263,7 @@
   PortProvider* addMultiBodyConstModel(const std::string& name, real_type value);
   void addMultiBodyModel(Model* model);
   /// </FIXME> document and rethink
-  PortProvider* getTablePrelookup(const std::string& name, PortProvider* in, const TableLookup& tl);
+  PortProvider* getTablePrelookup(const std::string& name, PortProvider* in, const BreakPointVector& tl);
   /// List for the aircraft search path.
   std::list<std::string> mAircraftPath;
   /// List for the engine search path.
@@ -271,7 +271,7 @@
 
   PropertyMap mExpressionTable;
   SharedPtr<AeroForce> mAeroForce;
-  std::vector<SharedPtr<TablePreLookup> > mTableLookups;
+  std::vector<SharedPtr<TablePreLookup> > mBreakPointVectors;
 
   // For now just copies from the prevous try ...
   Vector3 structToBody(const Vector3& v)

Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimScheduledGain.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimScheduledGain.cpp	2008-11-27 06:26:21 UTC (rev 800)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimScheduledGain.cpp	2008-11-27 19:16:40 UTC (rev 801)
@@ -55,10 +55,10 @@
 
 void
 JSBSimScheduledGain::setTableData(const TableData<1>& tableData,
-                                  const TableLookup& lookup)
+                                  const BreakPointVector& lookup)
 {
   mTable->setTableData(tableData);
-  mTablePreLookup->setTableLookup(lookup);
+  mTablePreLookup->setBreakPointVector(lookup);
 }
 
 } //namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimScheduledGain.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimScheduledGain.h	2008-11-27 06:26:21 UTC (rev 800)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimScheduledGain.h	2008-11-27 19:16:40 UTC (rev 801)
@@ -19,7 +19,7 @@
   JSBSimScheduledGain(const std::string& name);
   virtual ~JSBSimScheduledGain(void);
 
-  void setTableData(const TableData<1>& tableData, const TableLookup& lookup);
+  void setTableData(const TableData<1>& tableData, const BreakPointVector& lookup);
 
 private:
   SharedPtr<TablePreLookup> mTablePreLookup;

Modified: branches/OpenFDM-StateSeparation/src/JSBSim/Tablereader.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/Tablereader.cpp	2008-11-27 06:26:21 UTC (rev 800)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/Tablereader.cpp	2008-11-27 19:16:40 UTC (rev 801)
@@ -9,7 +9,7 @@
 namespace OpenFDM {
 
 bool
-parseTable1D(std::istream& s, TableData<1>& data, TableLookup& lookup)
+parseTable1D(std::istream& s, TableData<1>& data, BreakPointVector& lookup)
 {
   /// FIXME error handling
   for (unsigned i = 0; s && i < data.size(0); ++i) {
@@ -25,7 +25,7 @@
 }
 
 bool
-parseTable2D(std::istream& s, TableData<2>& data, TableLookup lookup[2])
+parseTable2D(std::istream& s, TableData<2>& data, BreakPointVector lookup[2])
 {
   /// FIXME error handling
   for (unsigned j = 0; s && j < data.size(1); ++j) {
@@ -57,7 +57,7 @@
 }
 
 bool
-parseTable3D(std::istream& s, TableData<3>& data, TableLookup lookup[3])
+parseTable3D(std::istream& s, TableData<3>& data, BreakPointVector lookup[3])
 {
   for (unsigned k = 0; s && k < data.size(2); ++k) {
     real_type in = 0;

Modified: branches/OpenFDM-StateSeparation/src/JSBSim/Tablereader.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/Tablereader.h	2008-11-27 06:26:21 UTC (rev 800)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/Tablereader.h	2008-11-27 19:16:40 UTC (rev 801)
@@ -12,13 +12,13 @@
 namespace OpenFDM {
 
 bool
-parseTable1D(std::istream& s, TableData<1>& data, TableLookup& lookup);
+parseTable1D(std::istream& s, TableData<1>& data, BreakPointVector& lookup);
 
 bool
-parseTable2D(std::istream& s, TableData<2>& data, TableLookup lookup[2]);
+parseTable2D(std::istream& s, TableData<2>& data, BreakPointVector lookup[2]);
 
 bool
-parseTable3D(std::istream& s, TableData<3>& data, TableLookup lookup[3]);
+parseTable3D(std::istream& s, TableData<3>& data, BreakPointVector lookup[3]);
 
 } // namespace OpenFDM
 

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Table.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Table.cpp	2008-11-27 06:26:21 UTC (rev 800)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Table.cpp	2008-11-27 19:16:40 UTC (rev 801)
@@ -12,9 +12,7 @@
 namespace OpenFDM {
 
 BEGIN_OPENFDM_OBJECT_DEF(TablePreLookup, Model)
-/// FIXME
-//   DEF_OPENFDM_PROPERTY(TablePreLookup, LookupVector, Serialized)
-  DEF_OPENFDM_PROPERTY(TablePreLookup, TableLookup, Serialized)
+  DEF_OPENFDM_PROPERTY(TablePreLookup, BreakPointVector, Serialized)
   END_OPENFDM_OBJECT_DEF
 
 TablePreLookup::TablePreLookup(const std::string& name) :
@@ -49,7 +47,7 @@
 TablePreLookup::output(const TaskInfo&)
 {
   OpenFDMAssert(mInputPortHandle.isConnected());
-  mOutput = mTableLookup.lookup(mInputPortHandle.getRealValue());
+  mOutput = mBreakPointVector.lookup(mInputPortHandle.getRealValue());
   Log(Model,Debug3) << "Output of TablePreLookup \"" << getName() << "\" "
                     << mOutput << endl;
 }

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Table.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Table.h	2008-11-27 06:26:21 UTC (rev 800)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Table.h	2008-11-27 19:16:40 UTC (rev 801)
@@ -21,14 +21,14 @@
 
   const real_type& getOutput(void) const;
 
-  void setTableLookup(const TableLookup& tl)
-  { mTableLookup = tl; }
-  const TableLookup& getTableLookup(void) const
-  { return mTableLookup; }
+  void setBreakPointVector(const BreakPointVector& tl)
+  { mBreakPointVector = tl; }
+  const BreakPointVector& getBreakPointVector(void) const
+  { return mBreakPointVector; }
 
 private:
   real_type mOutput;
-  TableLookup mTableLookup;
+  BreakPointVector mBreakPointVector;
   RealPortHandle mInputPortHandle;
 };
 

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/TableData.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/TableData.h	2008-11-27 06:26:21 UTC (rev 800)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/TableData.h	2008-11-27 19:16:40 UTC (rev 801)
@@ -7,157 +7,71 @@
 
 #include <iosfwd>
 #include <map>
+#include <vector>
+#include <algorithm>
 #include "Vector.h"
 
 namespace OpenFDM {
 
-class TableLookup {
-  typedef std::map<real_type, unsigned> Table;
-  typedef std::pair<real_type, unsigned> Pair;
- 
+class BreakPointVector {
 public:
-  TableLookup(void)
-  {}
+  typedef real_type value_type;
+  typedef std::vector<value_type> vector_type;
 
   /// Return the breakpoint at the given index i
   /// If it does not exist in the lookup table, zero is returned
-  real_type getAtIndex(unsigned i) const
-  {
-    Table::const_iterator it;
-    for (it = mTable.begin(); it != mTable.end(); ++it) {
-      if (it->second == i)
-        return it->first;
-    }
-    return 0;
-  }
+  const value_type& operator[](unsigned i) const
+  { OpenFDMAssert(i < mVector.size()); return mVector[i]; }
+
   /// Set the breakpoint value at index i, the lookup table is extended if
   /// required. Keep in mind, that the table lookup behaves undefined if
   /// the sequence of indices does not increase or decrease strictly monotonic
   /// with the values.
-  void setAtIndex(unsigned i, real_type value)
+  void insert(const value_type& value)
   {
-    Table::iterator it = mTable.begin();
-    while (it != mTable.end()) {
-      if (it->second == i) {
-        mTable.erase(it);
-        it = mTable.begin();
-      }
-      else
-        ++it;
-    }
-    mTable.insert(it, Pair(value, i));
+    vector_type::iterator i;
+    i = std::lower_bound(mVector.begin(), mVector.end(), value);
+    mVector.insert(i, value);
+    mVector.erase(std::unique(mVector.begin(), mVector.end()), mVector.end());
   }
 
   /// Returns the size of the lookup table
   unsigned size(void) const
-  {
-    unsigned sz = 0;
-    Table::const_iterator it;
-    for (it = mTable.begin(); it != mTable.end(); ++it) {
-      sz = max(sz, it->second);
-    }
-    return sz;
-  }
+  { return mVector.size(); }
 
-  /// Check for consistency, that is, the breakpoint indices are strictly
-  /// ordered and there are no holes in the sequence of indices
-  bool isValid(void) const
+  value_type lookup(const value_type& input) const
   {
-    Table::const_iterator it = mTable.begin();
-    if (it == mTable.end())
-      return false;
-    int indexDir = 0;
-    int valueDir = 0;
-    real_type prevValue = it->first;
-    unsigned prevIndex = it->second;
-    for (++it; it != mTable.end(); ++it) {
-      // We do not yet know which direction we should check
-      if (indexDir == 0) {
-        // Check for the direction of the indices
-        if (prevIndex + 1 == it->second) {
-          indexDir = 1;
-        } else if (prevIndex == it->second + 1) {
-          indexDir = -1;
-        } else {
-          // Duplicate index ...
-          return false;
-        }
-        
-        // Check for the direction of the lookup keys
-        if (prevValue < it->first) {
-          valueDir = 1;
-        } else if (prevValue > it->first) {
-          valueDir = -1;
-        } else {
-          // Duplicate lookup keys ...
-          return false;
-        }
-
-      } else if (indexDir == -1) {
-        // Check if the direction is still the same
-        if (prevIndex != it->second + 1)
-          return false;
-        if (prevValue*valueDir >= it->first*valueDir)
-          return false;
-      } else {
-        // Check if the direction is still the same
-        if (prevIndex + 1 != it->second)
-          return false;
-        if (prevValue*valueDir >= it->first*valueDir)
-          return false;
-      }
-
-      prevValue = it->first;
-      prevIndex = it->second;
-    }
-    return true;
-  }
-
-  real_type lookup(real_type input) const
-  {
     // Empty table??
     // FIXME
-    if (mTable.empty())
-      return 0;
+    if (mVector.empty())
+      return value_type(0);
 
+    vector_type::const_iterator vectorBegin = mVector.begin();
+    vector_type::const_iterator vectorEnd = mVector.end();
+
     // Find the table bounds for the requested input.
-    Table::const_iterator upBoundIt = mTable.upper_bound(input);
-    Table::const_iterator loBoundIt = upBoundIt;
+    vector_type::const_iterator upBoundIt;
+    upBoundIt = std::upper_bound(vectorBegin, vectorEnd, input);
+    vector_type::const_iterator loBoundIt = upBoundIt;
     --loBoundIt;
 
-    Table::const_iterator beg = mTable.begin();
-    if (upBoundIt == beg)
-      return 0;
-    if (upBoundIt == mTable.end()) {
-      unsigned last = mTable.rbegin()->second;
-      return last;
-    }
+    if (upBoundIt == vectorBegin)
+      return value_type(0);
+    if (upBoundIt == vectorEnd)
+      return value_type(mVector.size() - 1);
 
     // Just do linear interpolation.
-    real_type loBound = loBoundIt->first;
-    real_type upBound = upBoundIt->first;
-    unsigned loIdx = loBoundIt->second;
-    if (loBound == upBound)
+    value_type loIdx = value_type(std::distance(vectorBegin, loBoundIt));
+    if (loBoundIt == upBoundIt)
       return loIdx;
-    real_type theta = (input - loBound)/(upBound-loBound);
-    return loIdx + theta;
+    return loIdx + (input - *loBoundIt)/(*upBoundIt - *loBoundIt);
   }
 
-  bool operator==(const TableLookup& tl) const
-  {
-    Table::const_iterator i1 = mTable.begin();
-    Table::const_iterator i2 = tl.mTable.begin();
-    while (i1 != mTable.end() && i2 != tl.mTable.end()) {
-      if (i1->first != i2->first || i1->second != i2->second)
-        return false;
-      ++i1;
-      ++i2;
-    }
-    return i1 == mTable.end() && i2 == tl.mTable.end();
-  }
+  bool operator==(const BreakPointVector& bv) const
+  { return mVector == bv.mVector; }
 
 private:
-  Table mTable;
+  vector_type mVector;
 };
 
 template<unsigned numDims>
@@ -289,18 +203,19 @@
 template<typename char_type, typename traits_type> 
 inline
 std::basic_ostream<char_type, traits_type>&
-operator<<(std::basic_ostream<char_type, traits_type>& os, const TableLookup& tl)
+operator<<(std::basic_ostream<char_type, traits_type>& os,
+           const BreakPointVector& breakPointVector)
 {
-  for (unsigned idx = 0; idx < tl.size(); ++idx) {
-    os << tl.getAtIndex(idx) << ' ';
-  }
+  for (unsigned i = 0; i < breakPointVector.size(); ++i)
+    os << breakPointVector[i] << ' ';
   return os;
 }
 
 template<typename char_type, typename traits_type> 
 inline
 std::basic_ostream<char_type, traits_type>&
-operator<<(std::basic_ostream<char_type, traits_type>& os, const TableData<1>& td)
+operator<<(std::basic_ostream<char_type, traits_type>& os,
+           const TableData<1>& td)
 {
   TableData<1>::SizeVector sz = td.size();
 
@@ -315,7 +230,8 @@
 template<typename char_type, typename traits_type> 
 inline
 std::basic_ostream<char_type, traits_type>&
-operator<<(std::basic_ostream<char_type, traits_type>& os, const TableData<2>& td)
+operator<<(std::basic_ostream<char_type, traits_type>& os,
+           const TableData<2>& td)
 {
   TableData<2>::SizeVector sz = td.size();
 
@@ -334,7 +250,8 @@
 template<typename char_type, typename traits_type> 
 inline
 std::basic_ostream<char_type, traits_type>&
-operator<<(std::basic_ostream<char_type, traits_type>& os, const TableData<3>& td)
+operator<<(std::basic_ostream<char_type, traits_type>& os,
+           const TableData<3>& td)
 {
   TableData<3>::SizeVector sz = td.size();
 

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Variant.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Variant.cpp	2008-11-27 06:26:21 UTC (rev 800)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Variant.cpp	2008-11-27 19:16:40 UTC (rev 801)
@@ -49,7 +49,7 @@
       return sstr.str();
     }
 
-    const TableLookupVariantData* tableLookupData = mData->toTableLookupVariant();
+    const BreakPointVectorVariantData* tableLookupData = mData->toBreakPointVectorVariant();
     if (tableLookupData) {
       std::stringstream sstr;
       sstr << tableLookupData->mData;
@@ -174,13 +174,13 @@
   return Matrix();
 }
 
-TableLookup
-Variant::toTableLookup(void) const
+BreakPointVector
+Variant::toBreakPointVector(void) const
 {
-  const TableLookupVariantData* data = mData->toTableLookupVariant();
+  const BreakPointVectorVariantData* data = mData->toBreakPointVectorVariant();
   if (data)
     return data->mData;
-  return TableLookup();
+  return BreakPointVector();
 }
 
 TableData<1>

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Variant.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Variant.h	2008-11-27 06:26:21 UTC (rev 800)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Variant.h	2008-11-27 19:16:40 UTC (rev 801)
@@ -48,8 +48,8 @@
   {}
 
   // FIXME: just to hack reflection for now
-  Variant(const TableLookup& value) :
-    mData(new TableLookupVariantData(value))
+  Variant(const BreakPointVector& value) :
+    mData(new BreakPointVectorVariantData(value))
   {}
   Variant(const TableData<1>& value) :
     mData(new Table1DVariantData(value))
@@ -77,7 +77,7 @@
   inline bool isMatrix(void) const;
 
   // FIXME: just to hack reflection for now
-  inline bool isTableLookup(void) const;
+  inline bool isBreakPointVector(void) const;
   inline bool isTable1D(void) const;
   inline bool isTable2D(void) const;
   inline bool isTable3D(void) const;
@@ -94,7 +94,7 @@
   Matrix toMatrix(void) const;
 
   // FIXME: just to hack reflection for now
-  TableLookup toTableLookup(void) const;
+  BreakPointVector toBreakPointVector(void) const;
   TableData<1> toTable1D(void) const;
   TableData<2> toTable2D(void) const;
   TableData<3> toTable3D(void) const;
@@ -107,7 +107,7 @@
   struct MatrixVariantData;
   struct StringVariantData;
 
-  struct TableLookupVariantData;
+  struct BreakPointVectorVariantData;
   struct Table1DVariantData;
   struct Table2DVariantData;
   struct Table3DVariantData;
@@ -127,7 +127,7 @@
     virtual const StringVariantData* toStringVariant(void) const
     { return 0; }
 
-    virtual const TableLookupVariantData* toTableLookupVariant(void) const
+    virtual const BreakPointVectorVariantData* toBreakPointVectorVariant(void) const
     { return 0; }
     virtual const Table1DVariantData* toTable1DVariant(void) const
     { return 0; }
@@ -172,9 +172,9 @@
     { return this; }
   };
 
-  struct TableLookupVariantData : VariantDataImpl<TableLookup> {
-    TableLookupVariantData(const TableLookup& data) { mData = data; }
-    virtual const TableLookupVariantData* toTableLookupVariant(void) const
+  struct BreakPointVectorVariantData : VariantDataImpl<BreakPointVector> {
+    BreakPointVectorVariantData(const BreakPointVector& data) { mData = data; }
+    virtual const BreakPointVectorVariantData* toBreakPointVectorVariant(void) const
     { return this; }
   };
   struct Table1DVariantData : VariantDataImpl<TableData<1> > {
@@ -240,9 +240,9 @@
 }
 
 inline bool
-Variant::isTableLookup() const
+Variant::isBreakPointVector() const
 {
-  return mData && mData->toTableLookupVariant();
+  return mData && mData->toBreakPointVectorVariant();
 }
 
 inline bool
@@ -296,8 +296,8 @@
 
 template<> 
 inline void
-variant_copy(const Variant& variant, TableLookup& value)
-{ value = variant.toTableLookup(); }
+variant_copy(const Variant& variant, BreakPointVector& value)
+{ value = variant.toBreakPointVector(); }
 
 template<> 
 inline void



From frohlich at mail.berlios.de  Thu Nov 27 20:24:56 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Thu, 27 Nov 2008 20:24:56 +0100
Subject: [OpenFDM-svn] r802 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811271924.mARJOuSO027843@sheep.berlios.de>

Author: frohlich
Date: 2008-11-27 20:24:55 +0100 (Thu, 27 Nov 2008)
New Revision: 802

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/MaxModel.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/MinModel.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Product.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/SimpleDirectModel.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/SimpleDirectModel.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Summer.cpp
Log:
Move common functionality of the SimpleDirectModels
into the base class.

M    src/OpenFDM/Product.cpp
M    src/OpenFDM/MaxModel.cpp
M    src/OpenFDM/SimpleDirectModel.h
M    src/OpenFDM/Summer.cpp
M    src/OpenFDM/MinModel.cpp
M    src/OpenFDM/SimpleDirectModel.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MaxModel.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MaxModel.cpp	2008-11-27 19:16:40 UTC (rev 801)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MaxModel.cpp	2008-11-27 19:24:55 UTC (rev 802)
@@ -5,7 +5,6 @@
 #include "MaxModel.h"
 
 #include <string>
-#include <sstream>
 #include "Types.h"
 #include "Matrix.h"
 #include "Model.h"
@@ -46,14 +45,7 @@
 void
 MaxModel::setNumMaxInputs(unsigned num)
 {
-  unsigned oldnum = getNumInputPorts();
-  for (; oldnum < num; ++oldnum) {
-    std::stringstream s;
-    s << "input" << oldnum;
-    addInputPort(s.str());
-  }
-  for (; num < oldnum; --oldnum)
-    removeInputPort(getInputPort(oldnum-1));
+  setNumInputPorts(num);
 }
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MinModel.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MinModel.cpp	2008-11-27 19:16:40 UTC (rev 801)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MinModel.cpp	2008-11-27 19:24:55 UTC (rev 802)
@@ -5,7 +5,6 @@
 #include "MinModel.h"
 
 #include <string>
-#include <sstream>
 #include "Types.h"
 #include "Matrix.h"
 #include "Model.h"
@@ -45,14 +44,7 @@
 void
 MinModel::setNumMinInputs(unsigned num)
 {
-  unsigned oldnum = getNumInputPorts();
-  for (; oldnum < num; ++oldnum) {
-    std::stringstream s;
-    s << "input" << oldnum;
-    addInputPort(s.str());
-  }
-  for (; num < oldnum; --oldnum)
-    removeInputPort(getInputPort(oldnum-1));
+  setNumInputPorts(num);
 }
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Product.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Product.cpp	2008-11-27 19:16:40 UTC (rev 801)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Product.cpp	2008-11-27 19:24:55 UTC (rev 802)
@@ -5,7 +5,6 @@
 #include "Product.h"
 
 #include <string>
-#include <sstream>
 #include "Types.h"
 #include "Matrix.h"
 
@@ -48,14 +47,7 @@
 void
 Product::setNumFactors(unsigned num)
 {
-  unsigned oldnum = getNumFactors();
-  for (; oldnum < num; ++oldnum) {
-    std::stringstream s;
-    s << "input" << oldnum;
-    addInputPort(s.str());
-  }
-  for (; num < oldnum; --oldnum)
-    removeInputPort(getInputPort(oldnum-1));
+  setNumInputPorts(num);
 }
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/SimpleDirectModel.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/SimpleDirectModel.cpp	2008-11-27 19:16:40 UTC (rev 801)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/SimpleDirectModel.cpp	2008-11-27 19:24:55 UTC (rev 802)
@@ -4,6 +4,7 @@
 
 #include "SimpleDirectModel.h"
 
+#include <sstream>
 #include "Matrix.h"
 #include "AbstractModel.h"
 #include "ModelContext.h"
@@ -140,4 +141,38 @@
   return new Context(this, inputValues, outputPortValue);
 }
 
+void
+SimpleDirectModel::setNumInputPorts(unsigned numInputPorts)
+{
+  unsigned oldnum = getNumInputPorts();
+  for (; oldnum < numInputPorts; ++oldnum) {
+    std::stringstream s;
+    s << "input" << oldnum;
+    addInputPort(s.str());
+  }
+  for (; numInputPorts < oldnum; --oldnum)
+    removeInputPort(getInputPort(oldnum-1));
+}
+
+PortId
+SimpleDirectModel::addInputPort(const std::string& name)
+{
+  mInputPorts.push_back(new InputPortInfo(this, name, Size(0, 0), true));
+  return PortId(mInputPorts.back());
+}
+
+void
+SimpleDirectModel::removeInputPort(const PortId& portId)
+{
+  InputPortVector::iterator i = mInputPorts.begin();
+  while (i != mInputPorts.end()) {
+    if (portId != PortId(*i)) {
+      ++i;
+      continue;
+    }
+    (*i)->clear();
+    i = mInputPorts.erase(i);
+  }
+}
+
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/SimpleDirectModel.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/SimpleDirectModel.h	2008-11-27 19:16:40 UTC (rev 801)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/SimpleDirectModel.h	2008-11-27 19:24:55 UTC (rev 802)
@@ -65,23 +65,9 @@
   };
 
 protected:
-  PortId addInputPort(const std::string& name)
-  {
-    mInputPorts.push_back(new InputPortInfo(this, name, Size(0, 0), true));
-    return PortId(mInputPorts.back());
-  }
-  void removeInputPort(const PortId& portId)
-  {
-    InputPortVector::iterator i = mInputPorts.begin();
-    while (i != mInputPorts.end()) {
-      if (portId != PortId(*i)) {
-        ++i;
-        continue;
-      }
-      (*i)->clear();
-      i = mInputPorts.erase(i);
-    }
-  }
+  void setNumInputPorts(unsigned numInputPorts);
+  PortId addInputPort(const std::string& name);
+  void removeInputPort(const PortId& portId);
 
 private:
   typedef std::vector<SharedPtr<InputPortInfo> > InputPortVector;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Summer.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Summer.cpp	2008-11-27 19:16:40 UTC (rev 801)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Summer.cpp	2008-11-27 19:24:55 UTC (rev 802)
@@ -5,7 +5,6 @@
 #include "Summer.h"
 
 #include <string>
-#include <sstream>
 #include "Types.h"
 #include "Matrix.h"
 #include "Model.h"
@@ -53,14 +52,7 @@
 Summer::setNumSummands(unsigned num)
 {
   mSigns.resize(num, Plus);
-  unsigned oldnum = getNumSummands();
-  for (; oldnum < num; ++oldnum) {
-    std::stringstream s;
-    s << "input" << oldnum;
-    addInputPort(s.str());
-  }
-  for (; num < oldnum; --oldnum)
-    removeInputPort(getInputPort(oldnum-1));
+  setNumInputPorts(num);
 }
 
 void



From frohlich at mail.berlios.de  Thu Nov 27 20:38:32 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Thu, 27 Nov 2008 20:38:32 +0100
Subject: [OpenFDM-svn] r803 - in branches/OpenFDM-StateSeparation/src:
	JSBSim OpenFDM
Message-ID: <200811271938.mARJcWsI029272@sheep.berlios.de>

Author: frohlich
Date: 2008-11-27 20:38:31 +0100 (Thu, 27 Nov 2008)
New Revision: 803

Modified:
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimAerosurfaceScale.cpp
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimAerosurfaceScale.h
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.cpp
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.h
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimScheduledGain.cpp
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimScheduledGain.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
   branches/OpenFDM-StateSeparation/src/OpenFDM/Table.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Table.h
Log:
Reactivate table lookup models.

M    src/JSBSim/JSBSimReaderBase.cpp
M    src/JSBSim/JSBSimScheduledGain.cpp
M    src/JSBSim/JSBSimReaderBase.h
M    src/JSBSim/JSBSimScheduledGain.h
M    src/JSBSim/JSBSimAerosurfaceScale.cpp
M    src/JSBSim/JSBSimAerosurfaceScale.h
M    src/OpenFDM/Makefile.am
M    src/OpenFDM/Table.h
M    src/OpenFDM/Table.cpp


Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimAerosurfaceScale.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimAerosurfaceScale.cpp	2008-11-27 19:24:55 UTC (rev 802)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimAerosurfaceScale.cpp	2008-11-27 19:38:31 UTC (rev 803)
@@ -19,7 +19,7 @@
 {
   // Such a component is a simple table lookup
   //
-  // -|InputSaturation|-|TablePreLookup|-|Table1D|-
+  // -|InputSaturation|-|BreakPointLookup|-|Table1D|-
   //
 
   mInputSaturation = new Saturation("Input Saturation");
@@ -30,14 +30,14 @@
   tmp(0, 0) = 1;
   mInputSaturation->setMaxSaturation(tmp);
 
-  mTablePreLookup = new TablePreLookup("Table Lookup");
+  mBreakPointLookup = new BreakPointLookup("Table Lookup");
   BreakPointVector tl;
   tl.setAtIndex(0, -1);
   tl.setAtIndex(1, 0);
   tl.setAtIndex(2, 1);
-  mTablePreLookup->setBreakPointVector(tl);
-  getModelGroup()->addModel(mTablePreLookup);
-  Connection::connect(mTablePreLookup->getInputPort(0),
+  mBreakPointLookup->setBreakPointVector(tl);
+  getModelGroup()->addModel(mBreakPointLookup);
+  Connection::connect(mBreakPointLookup->getInputPort(0),
                       mInputSaturation->getOutputPort(0));
 
   mTable = new Table1D("Table");
@@ -54,7 +54,7 @@
   mTable->setTableData(tableData);
   getModelGroup()->addModel(mTable);
   Connection::connect(mTable->getInputPort(0),
-                      mTablePreLookup->getOutputPort(0));
+                      mBreakPointLookup->getOutputPort(0));
 
   // Now connect the input and the output to this groups in and outputs
   GroupInput* groupInput = new GroupInput("Input");
@@ -80,9 +80,9 @@
   Matrix tmp(1, 1);
   tmp(0, 0) = minDomain;
   mInputSaturation->setMinSaturation(tmp);
-  BreakPointVector tl = mTablePreLookup->getBreakPointVector();
+  BreakPointVector tl = mBreakPointLookup->getBreakPointVector();
   tl.setAtIndex(0, minDomain);
-  mTablePreLookup->setBreakPointVector(tl);
+  mBreakPointLookup->setBreakPointVector(tl);
 }
 
 void
@@ -91,15 +91,15 @@
   Matrix tmp(1, 1);
   tmp(0, 0) = maxDomain;
   mInputSaturation->setMaxSaturation(tmp);
-  BreakPointVector tl = mTablePreLookup->getBreakPointVector();
+  BreakPointVector tl = mBreakPointLookup->getBreakPointVector();
   tl.setAtIndex(tl.size()-1, maxDomain);
-  mTablePreLookup->setBreakPointVector(tl);
+  mBreakPointLookup->setBreakPointVector(tl);
 }
 
 void
 JSBSimAerosurfaceScale::setCentered(bool centered)
 {
-  BreakPointVector tlOld = mTablePreLookup->getBreakPointVector();
+  BreakPointVector tlOld = mBreakPointLookup->getBreakPointVector();
   BreakPointVector tl;
 
   TableData<1> tableDataOld = mTable->getTableData();
@@ -136,7 +136,7 @@
     tableData(iv) = oldVal;
   }
 
-  mTablePreLookup->setBreakPointVector(tl);
+  mBreakPointLookup->setBreakPointVector(tl);
   mTable->setTableData(tableData);
 }
 
@@ -153,7 +153,7 @@
 void
 JSBSimAerosurfaceScale::setMaxValue(real_type maxValue)
 {
-  BreakPointVector tl = mTablePreLookup->getBreakPointVector();
+  BreakPointVector tl = mBreakPointLookup->getBreakPointVector();
   TableData<1> tableData = mTable->getTableData();
   TableData<1>::Index iv;
   iv(0) = tl.size()-1;
@@ -164,7 +164,7 @@
 void
 JSBSimAerosurfaceScale::setGain(real_type gain)
 {
-  BreakPointVector tl = mTablePreLookup->getBreakPointVector();
+  BreakPointVector tl = mBreakPointLookup->getBreakPointVector();
   TableData<1> tableData = mTable->getTableData();
   TableData<1>::Index iv;
   iv(0) = 0;

Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimAerosurfaceScale.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimAerosurfaceScale.h	2008-11-27 19:24:55 UTC (rev 802)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimAerosurfaceScale.h	2008-11-27 19:38:31 UTC (rev 803)
@@ -32,7 +32,7 @@
 
 private:
   SharedPtr<Saturation> mInputSaturation;
-  SharedPtr<TablePreLookup> mTablePreLookup;
+  SharedPtr<BreakPointLookup> mBreakPointLookup;
   SharedPtr<Table1D> mTable;
   real_type mGain;
 };

Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.cpp	2008-11-27 19:24:55 UTC (rev 802)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.cpp	2008-11-27 19:38:31 UTC (rev 803)
@@ -840,7 +840,7 @@
 
   // First check if we already have a table lookup for this port/brakepoint
   // combination. If so return that output port
-  std::vector<SharedPtr<TablePreLookup> >::iterator it;
+  std::vector<SharedPtr<BreakPointLookup> >::iterator it;
   for (it = mBreakPointVectors.begin(); it != mBreakPointVectors.end(); ++it) {
     if (tl == (*it)->getBreakPointVector() &&
         nin->getPortInterface() == (*it)->getInputPort(0)->getPortInterface())
@@ -848,8 +848,8 @@
   }
 
   // No sharable table lookup found, we need to create a new one
-  TablePreLookup* tablePreLookup
-    = new TablePreLookup(name + " Table Prelookup");
+  BreakPointLookup* tablePreLookup
+    = new BreakPointLookup(name + " Table Prelookup");
   addMultiBodyModel(tablePreLookup);
   tablePreLookup->setBreakPointVector(tl);
   Connection::connect(in, tablePreLookup->getInputPort(0));

Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.h	2008-11-27 19:24:55 UTC (rev 802)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.h	2008-11-27 19:38:31 UTC (rev 803)
@@ -271,7 +271,7 @@
 
   PropertyMap mExpressionTable;
   SharedPtr<AeroForce> mAeroForce;
-  std::vector<SharedPtr<TablePreLookup> > mBreakPointVectors;
+  std::vector<SharedPtr<BreakPointLookup> > mBreakPointVectors;
 
   // For now just copies from the prevous try ...
   Vector3 structToBody(const Vector3& v)

Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimScheduledGain.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimScheduledGain.cpp	2008-11-27 19:24:55 UTC (rev 802)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimScheduledGain.cpp	2008-11-27 19:38:31 UTC (rev 803)
@@ -17,21 +17,21 @@
   // Such a component is a simple product and a table lookup
   //
   // -------------------------------|
-  // --|TablePreLookup|-|Table|-|Product|-
+  // --|BreakPointLookup|-|Table|-|Product|-
   //
 
   Product* product = new Product("Product");
   getModelGroup()->addModel(product);
 
-  mTablePreLookup = new TablePreLookup("Table Lookup");
-  getModelGroup()->addModel(mTablePreLookup);
+  mBreakPointLookup = new BreakPointLookup("Table Lookup");
+  getModelGroup()->addModel(mBreakPointLookup);
 
   mTable = new Table1D("Table");
   getModelGroup()->addModel(mTable);
   Connection::connect(product->getInputPort(0),
                       mTable->getOutputPort(0));
   Connection::connect(mTable->getInputPort(0),
-                      mTablePreLookup->getOutputPort(0));
+                      mBreakPointLookup->getOutputPort(0));
 
   // Now connect the input and the output to this groups in and outputs
   GroupInput* groupInput = new GroupInput("Input");
@@ -41,7 +41,7 @@
  
   groupInput = new GroupInput("Schedule Input");
   getModelGroup()->addModel(groupInput);
-  Connection::connect(mTablePreLookup->getInputPort(0),
+  Connection::connect(mBreakPointLookup->getInputPort(0),
                       groupInput->getOutputPort(0));
 
   // That single output port is this one
@@ -58,7 +58,7 @@
                                   const BreakPointVector& lookup)
 {
   mTable->setTableData(tableData);
-  mTablePreLookup->setBreakPointVector(lookup);
+  mBreakPointLookup->setBreakPointVector(lookup);
 }
 
 } //namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimScheduledGain.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimScheduledGain.h	2008-11-27 19:24:55 UTC (rev 802)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimScheduledGain.h	2008-11-27 19:38:31 UTC (rev 803)
@@ -22,7 +22,7 @@
   void setTableData(const TableData<1>& tableData, const BreakPointVector& lookup);
 
 private:
-  SharedPtr<TablePreLookup> mTablePreLookup;
+  SharedPtr<BreakPointLookup> mBreakPointLookup;
   SharedPtr<Table1D> mTable;
 };
 

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-11-27 19:24:55 UTC (rev 802)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-11-27 19:38:31 UTC (rev 803)
@@ -263,12 +263,12 @@
   SimpleDirectModel.cpp \
   SimulationTime.cpp \
   Summer.cpp \
+  Table.cpp \
   UnaryFunction.cpp \
   UnaryModel.cpp \
   UnitConversion.cpp
 
 #   DiscBrake.cpp \
-#   Table.cpp \
 #   TimeDerivative.cpp \
 #   TransferFunction.cpp \
 #

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Table.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Table.cpp	2008-11-27 19:24:55 UTC (rev 802)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Table.cpp	2008-11-27 19:38:31 UTC (rev 803)
@@ -11,211 +11,114 @@
 
 namespace OpenFDM {
 
-BEGIN_OPENFDM_OBJECT_DEF(TablePreLookup, Model)
-  DEF_OPENFDM_PROPERTY(TablePreLookup, BreakPointVector, Serialized)
+BEGIN_OPENFDM_OBJECT_DEF(BreakPointLookup, SimpleDirectModel)
+  DEF_OPENFDM_PROPERTY(BreakPointLookup, BreakPointVector, Serialized)
   END_OPENFDM_OBJECT_DEF
 
-TablePreLookup::TablePreLookup(const std::string& name) :
-  Model(name)
+BreakPointLookup::BreakPointLookup(const std::string& name) :
+  SimpleDirectModel(name)
 {
-  setDirectFeedThrough(true);
-  
   setNumInputPorts(1);
-  setInputPortName(0, "input");
-  
-  setNumOutputPorts(1);
-  setOutputPort(0, "output", this, &TablePreLookup::getOutput);
 }
 
-TablePreLookup::~TablePreLookup(void)
+BreakPointLookup::~BreakPointLookup(void)
 {
 }
 
-bool
-TablePreLookup::init(void)
+void
+BreakPointLookup::output(Context& context) const
 {
-  mInputPortHandle = getInputPort(0)->toRealPortHandle();
-  if (!mInputPortHandle.isConnected()) {
-    Log(Model,Error) << "Input port to TablePreLookup Model \""
-                     << getName() << "\" is not connected" << endl;
-    return false;
+  Size sz = size(context.getInputValue(0));
+  for (unsigned j = 0; j < sz(0); ++j) {
+    for (unsigned k = 0; k < sz(1); ++k) {
+      real_type input = context.getInputValue(0)(j, k);
+      context.getOutputValue()(j, k) = mBreakPointVector.lookup(input);
+    }
   }
-  return Model::init();
 }
 
-void
-TablePreLookup::output(const TaskInfo&)
-{
-  OpenFDMAssert(mInputPortHandle.isConnected());
-  mOutput = mBreakPointVector.lookup(mInputPortHandle.getRealValue());
-  Log(Model,Debug3) << "Output of TablePreLookup \"" << getName() << "\" "
-                    << mOutput << endl;
-}
-
-const real_type&
-TablePreLookup::getOutput(void) const
-{
-  return mOutput;
-}
-
-BEGIN_OPENFDM_OBJECT_DEF(Table1D, Model)
+BEGIN_OPENFDM_OBJECT_DEF(Table1D, SimpleDirectModel)
   DEF_OPENFDM_PROPERTY(Table1D, TableData, Serialized)
   END_OPENFDM_OBJECT_DEF
 
 Table1D::Table1D(const std::string& name) :
-  Model(name)
+  SimpleDirectModel(name)
 {
-  setDirectFeedThrough(true);
-  
   setNumInputPorts(1);
-  setInputPortName(0, "input");
-  
-  setNumOutputPorts(1);
-  setOutputPort(0, "output", this, &Table1D::getOutput);
 }
 
 Table1D::~Table1D(void)
 {
 }
   
-bool
-Table1D::init(void)
+void
+Table1D::output(Context& context) const
 {
-  mInputPortHandle = getInputPort(0)->toRealPortHandle();
-  if (!mInputPortHandle.isConnected()) {
-    Log(Model,Error) << "Input port to Table1D Model \""
-                     << getName() << "\" is not connected" << endl;
-    return false;
+  Size sz = size(context.getInputValue(0));
+  for (unsigned j = 0; j < sz(0); ++j) {
+    for (unsigned k = 0; k < sz(1); ++k) {
+      TableData<1>::InterpVector input;
+      input(0) = context.getInputValue(0)(j, k);
+      context.getOutputValue()(j, k) = mTableData.interpolate(input);
+    }
   }
-  return Model::init();
 }
 
-void
-Table1D::output(const TaskInfo&)
-{
-  OpenFDMAssert(mInputPortHandle.isConnected());
-  TableData<1>::InterpVector interpVec;
-  interpVec(0) = mInputPortHandle.getRealValue();
-  mOutput = mTableData.interpolate(interpVec);
-  Log(Model,Debug3) << "Output of Table1D \"" << getName() << "\" "
-                    << mOutput << endl;
-}
-
-const real_type&
-Table1D::getOutput(void) const
-{
-  return mOutput;
-}
-
-BEGIN_OPENFDM_OBJECT_DEF(Table2D, Model)
+BEGIN_OPENFDM_OBJECT_DEF(Table2D, SimpleDirectModel)
   DEF_OPENFDM_PROPERTY(Table2D, TableData, Serialized)
   END_OPENFDM_OBJECT_DEF
 
 Table2D::Table2D(const std::string& name) :
-  Model(name)
+  SimpleDirectModel(name)
 {
-  setDirectFeedThrough(true);
-  
   setNumInputPorts(2);
-  setInputPortName(0, "input 0");
-  setInputPortName(1, "input 1");
-  
-  setNumOutputPorts(1);
-  setOutputPort(0, "output", this, &Table2D::getOutput);
 }
 
 Table2D::~Table2D(void)
 {
 }
 
-bool
-Table2D::init(void)
+void
+Table2D::output(Context& context) const
 {
-  for (unsigned idx = 0; idx < 2; ++idx) {
-    mInputPortHandle[idx] = getInputPort(idx)->toRealPortHandle();
-    if (!mInputPortHandle[idx].isConnected()) {
-      Log(Model,Error) << "Input port to Table2D Model \""
-                       << getName() << "\" is not connected" << endl;
-      return false;
+  Size sz = size(context.getInputValue(0));
+  for (unsigned j = 0; j < sz(0); ++j) {
+    for (unsigned k = 0; k < sz(1); ++k) {
+      TableData<2>::InterpVector input;
+      input(0) = context.getInputValue(0)(j, k);
+      input(1) = context.getInputValue(1)(j, k);
+      context.getOutputValue()(j, k) = mTableData.interpolate(input);
     }
   }
-  return Model::init();
 }
 
-void
-Table2D::output(const TaskInfo&)
-{
-  OpenFDMAssert(mInputPortHandle[0].isConnected());
-  OpenFDMAssert(mInputPortHandle[1].isConnected());
-  TableData<2>::InterpVector interpVec;
-  interpVec(0) = mInputPortHandle[0].getRealValue();
-  interpVec(1) = mInputPortHandle[1].getRealValue();
-  mOutput = mTableData.interpolate(interpVec);
-  Log(Model, Debug3) << "Output of Table2D \"" << getName() << "\" "
-                     << mOutput << endl;
-}
-
-const real_type&
-Table2D::getOutput(void) const
-{
-  return mOutput;
-}
-
-BEGIN_OPENFDM_OBJECT_DEF(Table3D, Model)
+BEGIN_OPENFDM_OBJECT_DEF(Table3D, SimpleDirectModel)
   DEF_OPENFDM_PROPERTY(Table3D, TableData, Serialized)
   END_OPENFDM_OBJECT_DEF
 
 Table3D::Table3D(const std::string& name) :
-  Model(name)
+  SimpleDirectModel(name)
 {
-  setDirectFeedThrough(true);
-  
-  setNumInputPorts(3);
-  setInputPortName(0, "input 0");
-  setInputPortName(1, "input 1");
-  setInputPortName(2, "input 2");
-  
-  setNumOutputPorts(1);
-  setOutputPort(0, "output", this, &Table3D::getOutput);
+  setNumInputPorts(2);
 }
 
 Table3D::~Table3D(void)
 {
 }
   
-bool
-Table3D::init(void)
+void
+Table3D::output(Context& context) const
 {
-  for (unsigned idx = 0; idx < 3; ++idx) {
-    mInputPortHandle[idx] = getInputPort(idx)->toRealPortHandle();
-    if (!mInputPortHandle[idx].isConnected()) {
-      Log(Model,Error) << "Input port to Table3D Model \""
-                       << getName() << "\" is not connected" << endl;
-      return false;
+  Size sz = size(context.getInputValue(0));
+  for (unsigned j = 0; j < sz(0); ++j) {
+    for (unsigned k = 0; k < sz(1); ++k) {
+      TableData<3>::InterpVector input;
+      input(0) = context.getInputValue(0)(j, k);
+      input(1) = context.getInputValue(1)(j, k);
+      input(2) = context.getInputValue(2)(j, k);
+      context.getOutputValue()(j, k) = mTableData.interpolate(input);
     }
   }
-  return Model::init();
 }
 
-void
-Table3D::output(const TaskInfo&)
-{
-  OpenFDMAssert(mInputPortHandle[0].isConnected());
-  OpenFDMAssert(mInputPortHandle[1].isConnected());
-  OpenFDMAssert(mInputPortHandle[2].isConnected());
-  TableData<3>::InterpVector interpVec;
-  interpVec(0) = mInputPortHandle[0].getRealValue();
-  interpVec(1) = mInputPortHandle[1].getRealValue();
-  interpVec(2) = mInputPortHandle[2].getRealValue();
-  mOutput = mTableData.interpolate(interpVec);
-  Log(Model, Debug3) << "Output of Table3D \"" << getName() << "\" "
-                     << mOutput << endl;
-}
-
-const real_type&
-Table3D::getOutput(void) const
-{
-  return mOutput;
-}
-
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Table.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Table.h	2008-11-27 19:24:55 UTC (rev 802)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Table.h	2008-11-27 19:38:31 UTC (rev 803)
@@ -7,42 +7,35 @@
 
 #include "TableData.h"
 #include "Model.h"
+#include "SimpleDirectModel.h"
 
 namespace OpenFDM {
 
-class TablePreLookup : public Model {
-  OPENFDM_OBJECT(TablePreLookup, Model);
+class BreakPointLookup : public SimpleDirectModel {
+  OPENFDM_OBJECT(BreakPointLookup, SimpleDirectModel);
 public:
-  TablePreLookup(const std::string& name);
-  virtual ~TablePreLookup(void);
+  BreakPointLookup(const std::string& name);
+  virtual ~BreakPointLookup(void);
 
-  virtual bool init(void);
-  virtual void output(const TaskInfo&);
+  virtual void output(Context& context) const;
 
-  const real_type& getOutput(void) const;
-
-  void setBreakPointVector(const BreakPointVector& tl)
-  { mBreakPointVector = tl; }
+  void setBreakPointVector(const BreakPointVector& breakPointVector)
+  { mBreakPointVector = breakPointVector; }
   const BreakPointVector& getBreakPointVector(void) const
   { return mBreakPointVector; }
 
 private:
-  real_type mOutput;
   BreakPointVector mBreakPointVector;
-  RealPortHandle mInputPortHandle;
 };
 
-class Table1D : public Model {
-  OPENFDM_OBJECT(Table1D, Model);
+class Table1D : public SimpleDirectModel {
+  OPENFDM_OBJECT(Table1D, SimpleDirectModel);
 public:
   Table1D(const std::string& name);
   virtual ~Table1D(void);
   
-  virtual bool init(void);
-  virtual void output(const TaskInfo&);
+  virtual void output(Context& context) const;
 
-  const real_type& getOutput(void) const;
-
   void setTableData(const TableData<1>& table)
   { mTableData = table; }
   const TableData<1>& getTableData(void) const 
@@ -51,22 +44,17 @@
   { return mTableData; }
 
 private:
-  real_type mOutput;
   TableData<1> mTableData;
-  RealPortHandle mInputPortHandle;
 };
 
-class Table2D : public Model {
-  OPENFDM_OBJECT(Table2D, Model);
+class Table2D : public SimpleDirectModel {
+  OPENFDM_OBJECT(Table2D, SimpleDirectModel);
 public:
   Table2D(const std::string& name);
   virtual ~Table2D(void);
   
-  virtual bool init(void);
-  virtual void output(const TaskInfo&);
+  virtual void output(Context& context) const;
 
-  const real_type& getOutput(void) const;
-
   void setTableData(const TableData<2>& table)
   { mTableData = table; }
   const TableData<2>& getTableData(void) const 
@@ -75,22 +63,17 @@
   { return mTableData; }
 
 private:
-  real_type mOutput;
   TableData<2> mTableData;
-  RealPortHandle mInputPortHandle[2];
 };
 
-class Table3D : public Model {
-  OPENFDM_OBJECT(Table3D, Model);
+class Table3D : public SimpleDirectModel {
+  OPENFDM_OBJECT(Table3D, SimpleDirectModel);
 public:
   Table3D(const std::string& name);
   virtual ~Table3D(void);
   
-  virtual bool init(void);
-  virtual void output(const TaskInfo&);
+  virtual void output(Context& context) const;
 
-  const real_type& getOutput(void) const;
-
   void setTableData(const TableData<3>& table)
   { mTableData = table; }
   const TableData<3>& getTableData(void) const 
@@ -99,9 +82,7 @@
   { return mTableData; }
 
 private:
-  real_type mOutput;
   TableData<3> mTableData;
-  RealPortHandle mInputPortHandle[3];
 };
 
 } // namespace OpenFDM



From frohlich at mail.berlios.de  Thu Nov 27 20:39:10 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Thu, 27 Nov 2008 20:39:10 +0100
Subject: [OpenFDM-svn] r804 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811271939.mARJdA5x029347@sheep.berlios.de>

Author: frohlich
Date: 2008-11-27 20:39:10 +0100 (Thu, 27 Nov 2008)
New Revision: 804

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Table.h
Log:
Remove unused header.

M    src/OpenFDM/Table.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Table.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Table.h	2008-11-27 19:38:31 UTC (rev 803)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Table.h	2008-11-27 19:39:10 UTC (rev 804)
@@ -6,7 +6,6 @@
 #define OpenFDM_Table_H
 
 #include "TableData.h"
-#include "Model.h"
 #include "SimpleDirectModel.h"
 
 namespace OpenFDM {



From frohlich at mail.berlios.de  Fri Nov 28 07:53:58 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Fri, 28 Nov 2008 07:53:58 +0100
Subject: [OpenFDM-svn] r805 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811280653.mAS6rw4l014112@sheep.berlios.de>

Author: frohlich
Date: 2008-11-28 07:53:56 +0100 (Fri, 28 Nov 2008)
New Revision: 805

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.h
Log:
Implement load in the sensor.
Add an enableAll method.

M    OpenFDM/Sensor.cpp
M    OpenFDM/Sensor.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.cpp	2008-11-27 19:39:10 UTC (rev 804)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.cpp	2008-11-28 06:53:56 UTC (rev 805)
@@ -95,22 +95,31 @@
 Sensor::acceleration(const Task&, const ContinousStateValueVector&,
                      PortValueList& portValues, const Matrix&, Vector&) const
 {
+  const Environment* environment;
+  environment = portValues[mMechanicLink].getEnvironment();
   const Frame& frame = portValues[mMechanicLink].getFrame();
 
   // FIXME, for now relative position
   Vector3 position = mPosition - portValues[mMechanicLink].getDesignPosition();
 
-  if (getEnableCentrifugalAcceleration()) {
+  bool enableCentrifugalAcceleration = getEnableCentrifugalAcceleration();
+  bool enableLoad = getEnableLoad();
+  if (enableCentrifugalAcceleration || enableLoad) {
     Vector6 spatialVel = motionTo(position, frame.getSpVel());
     Vector6 spatialAccel = motionTo(position, frame.getSpAccel());
     Vector3 centrifugalAccel = spatialAccel.getLinear();
     centrifugalAccel += cross(spatialVel.getAngular(), spatialVel.getLinear());
 
-    portValues[mCentrifugalAccelerationPort] = centrifugalAccel;
+    if (enableCentrifugalAcceleration)
+      portValues[mCentrifugalAccelerationPort] = centrifugalAccel;
+    if (enableLoad) {
+      // May be cache that from the velocity step??
+      Vector3 refPosition = frame.posToRef(position);
+      Vector3 gravity = environment->getGravityAcceleration(refPosition);
+      gravity = frame.rotFromRef(gravity);
+      portValues[mLoadPort] = centrifugalAccel - gravity;
+    }
   }
-
-//   if (getEnableLoadAcceleration())
-//     portValues[mLoadAccelerationPort] = centrifugalAccel + gravity;
 }
 
 void
@@ -230,6 +239,23 @@
 }
 
 void
+Sensor::setEnableLoad(bool enable)
+{
+  if (enable == getEnableLoad())
+    return;
+  if (enable)
+    mLoadPort = MatrixOutputPort(this, "load", Size(3, 1), true);
+  else
+    mLoadPort.clear();
+}
+
+bool
+Sensor::getEnableLoad() const
+{
+  return !mLoadPort.empty();
+}
+
+void
 Sensor::setEnableWindVelocity(bool enable)
 {
   if (enable == getEnableWindVelocity())
@@ -280,4 +306,19 @@
   return !mPressurePort.empty();
 }
 
+void
+Sensor::setEnableAll(bool enable)
+{
+  setEnablePosition(enable);
+  setEnableOrientation(enable);
+  setEnableEulerAngles(enable);
+  setEnableLinearVelocity(enable);
+  setEnableAngularVelocity(enable);
+  setEnableCentrifugalAcceleration(enable);
+  setEnableLoad(enable);
+  setEnableWindVelocity(enable);
+  setEnableTemperature(enable);
+  setEnablePressure(enable);
+}
+
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.h	2008-11-27 19:39:10 UTC (rev 804)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.h	2008-11-28 06:53:56 UTC (rev 805)
@@ -60,7 +60,12 @@
   /// Get availabilty of the linear acceleration output port
   bool getEnableCentrifugalAcceleration() const;
 
+  /// Set availabilty of the load output port
+  void setEnableLoad(bool enable);
+  /// Get availabilty of the load output port
+  bool getEnableLoad() const;
 
+
   /// Set availabilty of the wind velocity output port
   void setEnableWindVelocity(bool enable);
   /// Get availabilty of the wind velocity output port
@@ -77,6 +82,10 @@
   /// Get availabilty of the pressure output port
   bool getEnablePressure() const;
 
+  /// Set availabilty of all output ports
+  /// This is mostly for convinience in testing
+  void setEnableAll(bool enable);
+
 private:
   MechanicLink mMechanicLink;
 
@@ -90,6 +99,7 @@
   MatrixOutputPort mAngularVelocityPort;
 
   MatrixOutputPort mCentrifugalAccelerationPort;
+  MatrixOutputPort mLoadPort;
 
   MatrixOutputPort mWindVelocityPort;
 



From frohlich at mail.berlios.de  Fri Nov 28 08:00:26 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Fri, 28 Nov 2008 08:00:26 +0100
Subject: [OpenFDM-svn] r806 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811280700.mAS70QhO024947@sheep.berlios.de>

Author: frohlich
Date: 2008-11-28 08:00:24 +0100 (Fri, 28 Nov 2008)
New Revision: 806

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.cpp
Log:
Correct wind sensing.

M    Sensor.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.cpp	2008-11-28 06:53:56 UTC (rev 805)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.cpp	2008-11-28 07:00:24 UTC (rev 806)
@@ -64,21 +64,23 @@
   // Velocity related sensing
   bool enableAngularVelocity = getEnableAngularVelocity();
   bool enableLinearVelocity = getEnableLinearVelocity();
-  if (enableAngularVelocity || enableLinearVelocity) {
+  bool enableWindVelocity = getEnableWindVelocity();
+  if (enableAngularVelocity || enableLinearVelocity || enableWindVelocity) {
     Vector6 refVelocity = frame.getRefVelAt(position);
     if (enableAngularVelocity)
       portValues[mAngularVelocityPort] = refVelocity.getAngular();
     
     if (enableLinearVelocity)
       portValues[mLinearVelocityPort] = refVelocity.getLinear();
+
+    // Wind sensing
+    if (enableWindVelocity) {
+      Vector6 wind = environment->getWindVelocity(task.getTime(), position);
+      wind -= refVelocity;
+      portValues[mWindVelocityPort] = frame.rotFromRef(wind.getLinear());
+    }
   }
 
-  // Wind sensing
-  if (getEnableWindVelocity()) {
-    Vector6 wind = environment->getWindVelocity(task.getTime(), position);
-    portValues[mWindVelocityPort] = frame.rotFromRef(wind.getLinear());
-  }
- 
   // Atmosphere related sensing
   bool enableTemperature = getEnableTemperature();
   bool enablePressure = getEnablePressure();



From frohlich at mail.berlios.de  Fri Nov 28 08:01:01 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Fri, 28 Nov 2008 08:01:01 +0100
Subject: [OpenFDM-svn] r807 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200811280701.mAS711Yi025488@sheep.berlios.de>

Author: frohlich
Date: 2008-11-28 08:01:01 +0100 (Fri, 28 Nov 2008)
New Revision: 807

Modified:
   branches/OpenFDM-StateSeparation/src/test/foucault.cpp
   branches/OpenFDM-StateSeparation/src/test/mechanic.cpp
Log:
Add sensors to all test cases.

M    test/foucault.cpp
M    test/mechanic.cpp


Modified: branches/OpenFDM-StateSeparation/src/test/foucault.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/foucault.cpp	2008-11-28 07:00:24 UTC (rev 806)
+++ branches/OpenFDM-StateSeparation/src/test/foucault.cpp	2008-11-28 07:01:01 UTC (rev 807)
@@ -35,12 +35,7 @@
 
   Sensor* sensor = new Sensor("Sensor");
   sensor->setPosition(mass->getPosition());
-  sensor->setEnablePosition(true);
-  sensor->setEnableOrientation(true);
-  sensor->setEnableEulerAngles(true);
-  sensor->setEnableLinearVelocity(true);
-  sensor->setEnableAngularVelocity(true);
-  sensor->setEnableCentrifugalAcceleration(true);
+  sensor->setEnableAll(true);
   Group::NodeId sensorId = group->addChild(sensor);
 
   group->connect(fixedRootJointId, 0, rotationalJoint1Id, 0);

Modified: branches/OpenFDM-StateSeparation/src/test/mechanic.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/mechanic.cpp	2008-11-28 07:00:24 UTC (rev 806)
+++ branches/OpenFDM-StateSeparation/src/test/mechanic.cpp	2008-11-28 07:01:01 UTC (rev 807)
@@ -4,6 +4,7 @@
 #include <OpenFDM/MobileRootJoint.h>
 #include <OpenFDM/RevoluteJoint.h>
 #include <OpenFDM/RigidBody.h>
+#include <OpenFDM/Sensor.h>
 #include <OpenFDM/System.h>
 #include <OpenFDM/SystemOutput.h>
 
@@ -20,41 +21,73 @@
   /// paris pendulum: coriolis
 
   SharedPtr<Group> group = new Group("G");
-  Group::NodeId rootJoint = group->addChild(new MobileRootJoint("Root Joint"));
-  Group::NodeId rigidBody = group->addChild(new RigidBody("Rigid Body"));
-  Group::NodeId mass = group->addChild(new Mass("Mass", 1, InertiaMatrix(1, 0, 0, 1, 0, 1)));
 
-  group->connect(rootJoint, "link", rigidBody, "link0");
-  group->connect(rigidBody, "link1", mass, "link");
+  MobileRootJoint* mobileRootJoint = new MobileRootJoint("Root Joint");
+  Group::NodeId rootJointId = group->addChild(mobileRootJoint);
+  RigidBody* rigidBody = new RigidBody("Rigid Body");
+  rigidBody->addLink("sensorLink");
+  Group::NodeId rigidBodyId = group->addChild(rigidBody);
+  Mass* mass = new Mass("Mass", 1, InertiaMatrix(1, 0, 0, 1, 0, 1));
+  Group::NodeId massId = group->addChild(mass);
 
+  Sensor* sensor = new Sensor("Sensor");
+  sensor->setPosition(mass->getPosition());
+  sensor->setEnableAll(true);
+  Group::NodeId sensorId = group->addChild(sensor);
+
+  group->connect(rootJointId, "link", rigidBodyId, "link0");
+  group->connect(rigidBodyId, "link1", massId, "link");
+  group->connect(rigidBodyId, "sensorLink", sensorId, "link");
+
   return group.release();
 }
 
 Node* buildSimpleMechanicExample2()
 {
   SharedPtr<Group> group = new Group("G");
-  Group::NodeId rootJoint = group->addChild(new MobileRootJoint("Root Joint"));
-  RigidBody *body = new RigidBody("Rigid Body");
-  body->addLink("link2");
-  Group::NodeId rigidBody = group->addChild(body);
+
+  MobileRootJoint* mobileRootJoint = new MobileRootJoint("Root Joint");
+  Group::NodeId rootJointId = group->addChild(mobileRootJoint);
+
+  RigidBody *rigidBody = new RigidBody("Rigid Body");
+  rigidBody->addLink("link2");
+  rigidBody->addLink("sensorLink");
+  Group::NodeId rigidBodyId = group->addChild(rigidBody);
   InertiaMatrix inertia(1, 0, 0, 1, 0, 1);
-  Group::NodeId mass = group->addChild(new Mass("Mass", 1, inertia));
+  Mass* mass = new Mass("Mass", 1, inertia);
+  Group::NodeId massId = group->addChild(mass);
   RevoluteJoint* revoluteJoint = new RevoluteJoint("Revolute Joint");
   revoluteJoint->setEnableExternalForce(true);
-  Group::NodeId revolute = group->addChild(revoluteJoint);
-  Group::NodeId rigidBody2 = group->addChild(new RigidBody("Rigid Body 2"));
-  Group::NodeId mass2 = group->addChild(new Mass("Mass 2", 1, inertia));
+  Group::NodeId revoluteId = group->addChild(revoluteJoint);
+  RigidBody *rigidBody2 = new RigidBody("Rigid Body 2");
+  rigidBody2->addLink("sensorLink");
+  Group::NodeId rigidBody2Id = group->addChild(rigidBody2);
+  Mass* mass2 = new Mass("Mass 2", 1, inertia);
+  Group::NodeId mass2Id = group->addChild(mass2);
 
-  group->connect(rootJoint, "link", rigidBody, "link0");
-  group->connect(rigidBody, "link1", mass, "link");
-  group->connect(rigidBody, "link2", revolute, "link0");
-  group->connect(revolute, "link1", rigidBody2, "link0");
-  group->connect(rigidBody2, "link1", mass2, "link");
+  Sensor* sensor = new Sensor("Sensor");
+  sensor->setPosition(mass->getPosition());
+  sensor->setEnableAll(true);
+  Group::NodeId sensorId = group->addChild(sensor);
 
-  Group::NodeId jointForce = group->addChild(new ConstModel("Joint Force", 1));
+  Sensor* sensor2 = new Sensor("Sensor 2");
+  sensor2->setPosition(mass2->getPosition());
+  sensor2->setEnableAll(true);
+  Group::NodeId sensorId2 = group->addChild(sensor2);
 
-  group->connect(jointForce, "output", revolute, "force");
+  group->connect(rootJointId, "link", rigidBodyId, "link0");
+  group->connect(rigidBodyId, "link1", massId, "link");
+  group->connect(rigidBodyId, "link2", revoluteId, "link0");
+  group->connect(revoluteId, "link1", rigidBody2Id, "link0");
+  group->connect(rigidBody2Id, "link1", mass2Id, "link");
+  group->connect(rigidBodyId, "sensorLink", sensorId, "link");
+  group->connect(rigidBody2Id, "sensorLink", sensorId2, "link");
 
+  ConstModel* jointForce = new ConstModel("Joint Force", 1);
+  Group::NodeId jointForceId = group->addChild(jointForce);
+
+  group->connect(jointForceId, "output", revoluteId, "force");
+
   return group.release();
 }
 



From frohlich at mail.berlios.de  Fri Nov 28 15:43:54 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Fri, 28 Nov 2008 15:43:54 +0100
Subject: [OpenFDM-svn] r808 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811281443.mASEhsCQ008533@sheep.berlios.de>

Author: frohlich
Date: 2008-11-28 15:43:54 +0100 (Fri, 28 Nov 2008)
New Revision: 808

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Integrator.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Integrator.h
Log:
Add convinience function.

M    OpenFDM/Integrator.h
M    OpenFDM/Integrator.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Integrator.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Integrator.cpp	2008-11-28 07:01:01 UTC (rev 807)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Integrator.cpp	2008-11-28 14:43:54 UTC (rev 808)
@@ -94,6 +94,13 @@
   mInitialValue = initialValue;
 }
 
+void
+Integrator::setInitialValue(const real_type& initialValue)
+{
+  mInitialValue.resize(1, 1);
+  mInitialValue(0, 0) = initialValue;
+}
+
 const Matrix&
 Integrator::getInitialValue() const
 {

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Integrator.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Integrator.h	2008-11-28 07:01:01 UTC (rev 807)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Integrator.h	2008-11-28 14:43:54 UTC (rev 808)
@@ -31,6 +31,7 @@
                           ContinousStateValueVector& deriv) const;
 
   void setInitialValue(const Matrix& initialValue);
+  void setInitialValue(const real_type& initialValue);
   const Matrix& getInitialValue() const;
 
   void setEnableInitialValuePort(bool enable);



From frohlich at mail.berlios.de  Fri Nov 28 15:54:49 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Fri, 28 Nov 2008 15:54:49 +0100
Subject: [OpenFDM-svn] r809 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200811281454.mASEsnrr009406@sheep.berlios.de>

Author: frohlich
Date: 2008-11-28 15:54:49 +0100 (Fri, 28 Nov 2008)
New Revision: 809

Modified:
   branches/OpenFDM-StateSeparation/src/test/Makefile.am
   branches/OpenFDM-StateSeparation/src/test/constintegral.cpp
   branches/OpenFDM-StateSeparation/src/test/harmonic.cpp
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Reactivate some old test programs.

M    src/test/harmonic.cpp
M    src/test/structure.cpp
M    src/test/Makefile.am
M    src/test/constintegral.cpp


Modified: branches/OpenFDM-StateSeparation/src/test/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/Makefile.am	2008-11-28 14:43:54 UTC (rev 808)
+++ branches/OpenFDM-StateSeparation/src/test/Makefile.am	2008-11-28 14:54:49 UTC (rev 809)
@@ -5,8 +5,7 @@
 bin_PROGRAMS = structure mechanic foucault
 
 # define some unit tests
-#check_PROGRAMS = quattest unitstest structure simulationtime constintegral harmonic limit
-check_PROGRAMS = quattest unitstest simulationtime limit linalg
+check_PROGRAMS = constintegral harmonic limit linalg quattest simulationtime unitstest
 TESTS          = $(check_PROGRAMS)
 
 # tiretestrig_SOURCES = tiretestrig.cpp
@@ -33,11 +32,11 @@
 simulationtime_SOURCES = simulationtime.cpp
 simulationtime_LDADD = ../OpenFDM/libOpenFDM.la
 
-# constintegral_SOURCES = constintegral.cpp
-# constintegral_LDADD = ../OpenFDM/libOpenFDM.la
+constintegral_SOURCES = constintegral.cpp
+constintegral_LDADD = ../OpenFDM/libOpenFDM.la
 
-# harmonic_SOURCES = harmonic.cpp
-# harmonic_LDADD = ../OpenFDM/libOpenFDM.la
+harmonic_SOURCES = harmonic.cpp
+harmonic_LDADD = ../OpenFDM/libOpenFDM.la
 
 limit_SOURCES = limit.cpp
 limit_LDADD = ../OpenFDM/libOpenFDM.la

Modified: branches/OpenFDM-StateSeparation/src/test/constintegral.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/constintegral.cpp	2008-11-28 14:43:54 UTC (rev 808)
+++ branches/OpenFDM-StateSeparation/src/test/constintegral.cpp	2008-11-28 14:54:49 UTC (rev 809)
@@ -5,6 +5,7 @@
 #include <cstdlib>
 #include <iostream>
 #include <OpenFDM/ConstModel.h>
+#include <OpenFDM/Group.h>
 #include <OpenFDM/Integrator.h>
 #include <OpenFDM/Output.h>
 #include <OpenFDM/SimulationTime.h>
@@ -17,49 +18,43 @@
 int
 main(int argc, char *argv[])
 {
-  real_type rate = 0.1;
+  real_type rate = 0.01;
 
-  SharedPtr<System> system = new System("Constant Integration");
+  SharedPtr<Group> group = new Group("Group");
 
-  Matrix m(1, 1);
-  m(0, 0) = 1;
+  ConstModel* constModel = new ConstModel("Constant", 1);
+  Group::NodeId constModelId = group->addChild(constModel);
 
-  ConstModel* constModel = new ConstModel("Constant", m);
-  system->addModel(constModel);
-
   Integrator* integrator = new Integrator("Integrator");
-  system->addModel(integrator);
-  m(0, 0) = 0;
-  integrator->setInitialValue(m);
+  integrator->setInitialValue(0);
+  Group::NodeId integratorId = group->addChild(integrator);
+  group->connect(constModelId, "output", integratorId, "input");
 
-  Connection::connect(integrator->getInputPort(0),
-                      constModel->getOutputPort(0));
-
   SimulationTime* simulationTime = new SimulationTime("Simulation Time");
-  system->addModel(simulationTime);
+  Group::NodeId simulationTimeId = group->addChild(simulationTime);
 
   Summer* summer = new Summer("Error to exact Solution");
-  system->addModel(summer);
+  Group::NodeId summerId = group->addChild(summer);
   summer->setNumSummands(2);
   summer->setInputSign(0, Summer::Plus);
-  Connection::connect(simulationTime->getOutputPort(0),
-                      summer->getInputPort(0));
+  group->connect(simulationTimeId, "output", summerId, "input0");
   summer->setInputSign(1, Summer::Minus);
-  Connection::connect(integrator->getOutputPort(0),
-                      summer->getInputPort(1));
+  group->connect(integratorId, "output", summerId, "input1");
 
+
   Output* output = new Output("Error Output");
   SharedPtr<ErrorCollectorCallback> errors;
   errors = new ErrorCollectorCallback;
   output->setCallback(errors);
-  output->addSampleTime(rate);
-  system->addModel(output);
-  Connection::connect(output->getInputPort(0), summer->getOutputPort(0));
+//   output->addSampleTime(rate);
+  Group::NodeId outputId = group->addChild(output);
+  group->connect(summerId, "output", outputId, "input");
 
-  if (!system->init()) {
-    std::cout << "Could not initialize the system" << std::endl;
+  SharedPtr<System> system = new System("Constant Integration");
+  system->setNode(group);
+
+  if (!system->init())
     return EXIT_FAILURE;
-  }
 
   system->simulate(10);
 

Modified: branches/OpenFDM-StateSeparation/src/test/harmonic.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/harmonic.cpp	2008-11-28 14:43:54 UTC (rev 808)
+++ branches/OpenFDM-StateSeparation/src/test/harmonic.cpp	2008-11-28 14:54:49 UTC (rev 809)
@@ -6,6 +6,7 @@
 #include <iostream>
 #include <OpenFDM/DoPri5.h>
 #include <OpenFDM/Gain.h>
+#include <OpenFDM/Group.h>
 #include <OpenFDM/Integrator.h>
 #include <OpenFDM/Output.h>
 #include <OpenFDM/SimulationTime.h>
@@ -21,97 +22,80 @@
 {
   real_type omega = 2;
 
-  SharedPtr<System> system = new System("Harmonic Oszilator");
-  system->addSampleTime(real_type(1)/real_type(100));
-  system->setTimestepper(new DoPri5);
-  
-  Integrator* integrator0 = new Integrator("Acceleration Integrator");
-  Matrix initialValue(1, 1);
-  initialValue(0, 0) = 0;
-  integrator0->setInitialValue(initialValue);
-  system->addModel(integrator0);
+  SharedPtr<Group> group = new Group("Group");
 
-  Integrator* integrator1 = new Integrator("Velocity Integrator");
-  initialValue(0, 0) = 1;
-  integrator1->setInitialValue(initialValue);
-  system->addModel(integrator1);
+  // Build up a harmonic oszilator
+  Group::NodeId gainId = group->addChild(new Gain("gain", -omega*omega));
+  Integrator* integrator0 = new Integrator("Velocity Integrator");
+  integrator0->setInitialValue(omega);
+  Group::NodeId integrator0Id = group->addChild(integrator0);
+  Integrator* integrator1 = new Integrator("Position Integrator");
+  integrator1->setInitialValue(0);
+  Group::NodeId integrator1Id = group->addChild(integrator1);
 
-  Gain* gain = new Gain("Gain");
-  gain->setGain(-omega*omega);
-  system->addModel(gain);
+  group->connect(gainId, "output", integrator0Id, "input");
+  group->connect(integrator0Id, "output", integrator1Id, "input");
+  group->connect(integrator1Id, "output", gainId, "input");
 
-  Connection::connect(gain->getInputPort(0),
-                      integrator1->getOutputPort(0));
-  Connection::connect(integrator1->getInputPort(0),
-                      integrator0->getOutputPort(0));
-  Connection::connect(integrator0->getInputPort(0),
-                      gain->getOutputPort(0));
-
+  // Build up the exact solution
   SimulationTime* simulationTime = new SimulationTime("Simulation Time");
-  system->addModel(simulationTime);
+  Group::NodeId simulationTimeId = group->addChild(simulationTime);
 
-  gain = new Gain("Cosinus Input Gain");
-  system->addModel(gain);
-  gain->setGain(omega);
-  Connection::connect(gain->getInputPort(0),
-                      simulationTime->getOutputPort(0));
+  Gain* cosInputGain = new Gain("Cosinus Input Gain", omega);
+  Group::NodeId cosInputGainId = group->addChild(cosInputGain);
+  group->connect(simulationTimeId, "output", cosInputGainId, "input");
 
-  UnaryFunction* cosFunction
-    = new UnaryFunction("Exact Pos Solution", UnaryFunction::Cos);
-  system->addModel(cosFunction);
-  Connection::connect(cosFunction->getInputPort(0),
-                      gain->getOutputPort(0));
+  UnaryFunction* cosFunction;
+  cosFunction = new UnaryFunction("Exact Vel Solution", UnaryFunction::Cos);
+  Group::NodeId cosFunctionId = group->addChild(cosFunction);
+  group->connect(cosInputGainId, "output", cosFunctionId, "input");
 
-  UnaryFunction* sinFunction
-    = new UnaryFunction("Exact Vel Solution", UnaryFunction::Sin);
-  system->addModel(sinFunction);
-  Connection::connect(sinFunction->getInputPort(0),
-                      gain->getOutputPort(0));
+  Gain* velOutputGain = new Gain("Velocity Output Gain", omega);
+  Group::NodeId velOutputGainId = group->addChild(velOutputGain);
+  group->connect(cosFunctionId, "output", velOutputGainId, "input");
 
-  gain = new Gain("Cosinus Output Gain");
-  system->addModel(gain);
-  gain->setGain(-omega);
-  Connection::connect(gain->getInputPort(0),
-                      sinFunction->getOutputPort(0));
+  UnaryFunction* sinFunction;
+  sinFunction = new UnaryFunction("Exact Pos Solution", UnaryFunction::Sin);
+  Group::NodeId sinFunctionId = group->addChild(sinFunction);
+  group->connect(cosInputGainId, "output", sinFunctionId, "input");
 
 
-  Summer* summer0 = new Summer("Position Error to exact Solution");
-  system->addModel(summer0);
+  // Now build the differences
+
+  Summer* summer0 = new Summer("Velocity Error to exact Solution");
+  Group::NodeId summer0Id = group->addChild(summer0);
   summer0->setNumSummands(2);
   summer0->setInputSign(0, Summer::Plus);
-  Connection::connect(cosFunction->getOutputPort(0),
-                      summer0->getInputPort(0));
+  group->connect(velOutputGainId, "output", summer0Id, "input0");
   summer0->setInputSign(1, Summer::Minus);
-  Connection::connect(integrator1->getOutputPort(0),
-                      summer0->getInputPort(1));
+  group->connect(integrator0Id, "output", summer0Id, "input1");
 
-  Output* output = new Output("Position Error Output");
-  SharedPtr<ErrorCollectorCallback> posErrorCallback;
-  posErrorCallback = new ErrorCollectorCallback;
-  output->setCallback(posErrorCallback);
-  output->addSampleTime(real_type(1)/real_type(10));
-  system->addModel(output);
-  Connection::connect(output->getInputPort(0), summer0->getOutputPort(0));
+  Output* output0 = new Output("Velocity Error Output");
+  SharedPtr<ErrorCollectorCallback> velErrorCallback;
+  velErrorCallback = new ErrorCollectorCallback;
+  output0->setCallback(velErrorCallback);
+  Group::NodeId output0Id = group->addChild(output0);
+  group->connect(summer0Id, "output", output0Id, "input");
 
 
-  Summer* summer1 = new Summer("Velocity Error to exact Solution");
-  system->addModel(summer1);
+  Summer* summer1 = new Summer("Position Error to exact Solution");
+  Group::NodeId summer1Id = group->addChild(summer1);
   summer1->setNumSummands(2);
   summer1->setInputSign(0, Summer::Plus);
-  Connection::connect(gain->getOutputPort(0),
-                      summer1->getInputPort(0));
+  group->connect(sinFunctionId, "output", summer1Id, "input0");
   summer1->setInputSign(1, Summer::Minus);
-  Connection::connect(integrator0->getOutputPort(0),
-                      summer1->getInputPort(1));
+  group->connect(integrator1Id, "output", summer1Id, "input1");
 
-  output = new Output("Velocity Error Output");
-  SharedPtr<ErrorCollectorCallback> velErrorCallback;
-  velErrorCallback = new ErrorCollectorCallback;
-  output->setCallback(velErrorCallback);
-  output->addSampleTime(real_type(1)/real_type(10));
-  system->addModel(output);
-  Connection::connect(output->getInputPort(0), summer1->getOutputPort(0));
+  Output* output1 = new Output("Position Error Output");
+  SharedPtr<ErrorCollectorCallback> posErrorCallback;
+  posErrorCallback = new ErrorCollectorCallback;
+  output1->setCallback(posErrorCallback);
+  Group::NodeId output1Id = group->addChild(output1);
+  group->connect(summer1Id, "output", output1Id, "input");
 
+  SharedPtr<System> system = new System("Harmonic Oszilator");
+  system->setNode(group);
+
   if (!system->init()) {
     std::cout << "Could not initialize the system" << std::endl;
     return EXIT_FAILURE;

Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-11-28 14:43:54 UTC (rev 808)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-11-28 14:54:49 UTC (rev 809)
@@ -113,9 +113,7 @@
   SharedPtr<Group> group = new Group("G0");
   Group::NodeId gain = group->addChild(new Gain("gain", -1));
   Integrator* i1 = new Integrator("I1");
-  Matrix v(1, 1);
-  v(0, 0) = 1;
-  i1->setInitialValue(v);
+  i1->setInitialValue(1);
   Group::NodeId integrator1 = group->addChild(i1);
   Group::NodeId integrator2 = group->addChild(new Integrator("I2"));
   Group::NodeId output = group->addChild(new Output("O"));



From frohlich at mail.berlios.de  Sat Nov 29 11:42:02 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 29 Nov 2008 11:42:02 +0100
Subject: [OpenFDM-svn] r810 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811291042.mATAg2hc018427@sheep.berlios.de>

Author: frohlich
Date: 2008-11-29 11:42:01 +0100 (Sat, 29 Nov 2008)
New Revision: 810

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Environment.h
Log:
Implement access to environment classes.

M    Environment.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Environment.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Environment.h	2008-11-28 14:54:49 UTC (rev 809)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Environment.h	2008-11-29 10:42:01 UTC (rev 810)
@@ -24,6 +24,36 @@
   Environment();
   virtual ~Environment();
 
+  void setInertial(const AbstractInertial* inertial)
+  { mInertial = inertial; }
+  const AbstractInertial* getInertial()
+  { return mInertial; }
+
+  void setGravity(const AbstractGravity* gravity)
+  { mGravity = gravity; }
+  const AbstractGravity* getGravity()
+  { return mGravity; }
+
+  void setWind(const AbstractWind* wind)
+  { mWind = wind; }
+  const AbstractWind* getWind()
+  { return mWind; }
+
+  void setPlanet(const AbstractPlanet* planet)
+  { mPlanet = planet; }
+  const AbstractPlanet* getPlanet()
+  { return mPlanet; }
+
+  void setAtmosphere(const AbstractAtmosphere* atmosphere)
+  { mAtmosphere = atmosphere; }
+  const AbstractAtmosphere* getAtmosphere()
+  { return mAtmosphere; }
+
+  void setGround(const AbstractGround* ground)
+  { mGround = ground; }
+  const AbstractGround* getGround()
+  { return mGround; }
+
   ///////////////////////////////////////////////////////////////////////////
   // Inertial related
   // FIXME may be this can be split out???



From frohlich at mail.berlios.de  Sat Nov 29 11:42:47 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 29 Nov 2008 11:42:47 +0100
Subject: [OpenFDM-svn] r811 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811291042.mATAglu7018502@sheep.berlios.de>

Author: frohlich
Date: 2008-11-29 11:42:47 +0100 (Sat, 29 Nov 2008)
New Revision: 811

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
Log:
Correclty list the CentralMass gravity model.

M    Makefile.am


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-11-29 10:42:01 UTC (rev 810)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-11-29 10:42:47 UTC (rev 811)
@@ -24,7 +24,7 @@
   Assert.h \
   Atomic.h \
   BoolStateInfo.h \
-  CentralMassGravity.cpp \
+  CentralMassGravity.h \
   ConstNodeVisitor.h \
   ContinousStateInfo.h \
   ContinousStateInfoVector.h \
@@ -143,6 +143,7 @@
   Assert.cpp \
   AtmosphereSTD1976.cpp \
   Atomic.cpp \
+  CentralMassGravity.cpp \
   ConstNodeVisitor.cpp \
   ContinousStateValue.cpp \
   DoPri5.cpp \
@@ -199,7 +200,6 @@
   Bias.h \
   BinaryFunction.h \
   CartesianJoint.h \
-  CentralMassGravity.h \
   ConstModel.h \
   Contact.h \
   DeadBand.h \



From frohlich at mail.berlios.de  Sat Nov 29 11:43:14 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 29 Nov 2008 11:43:14 +0100
Subject: [OpenFDM-svn] r812 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811291043.mATAhEOg018572@sheep.berlios.de>

Author: frohlich
Date: 2008-11-29 11:43:14 +0100 (Sat, 29 Nov 2008)
New Revision: 812

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/CentralMassGravity.cpp
Log:
Make the central mass model compile.

M    CentralMassGravity.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/CentralMassGravity.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/CentralMassGravity.cpp	2008-11-29 10:42:47 UTC (rev 811)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/CentralMassGravity.cpp	2008-11-29 10:43:14 UTC (rev 812)
@@ -9,7 +9,6 @@
 #include "Unit.h"
 #include "Vector.h"
 #include "Quaternion.h"
-#include "Gravity.h"
 
 namespace OpenFDM {
 



From frohlich at mail.berlios.de  Sat Nov 29 11:44:19 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 29 Nov 2008 11:44:19 +0100
Subject: [OpenFDM-svn] r813 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200811291044.mATAiJe5018659@sheep.berlios.de>

Author: frohlich
Date: 2008-11-29 11:44:18 +0100 (Sat, 29 Nov 2008)
New Revision: 813

Modified:
   branches/OpenFDM-StateSeparation/src/test/foucault.cpp
Log:
Put the pendulum to paris.

M    test/foucault.cpp


Modified: branches/OpenFDM-StateSeparation/src/test/foucault.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/foucault.cpp	2008-11-29 10:43:14 UTC (rev 812)
+++ branches/OpenFDM-StateSeparation/src/test/foucault.cpp	2008-11-29 10:44:18 UTC (rev 813)
@@ -6,22 +6,39 @@
 #include <OpenFDM/Sensor.h>
 #include <OpenFDM/System.h>
 #include <OpenFDM/SystemOutput.h>
-// #include <OpenFDM/Planet.h>
+#include <OpenFDM/EllipticPlanet.h>
+#include <OpenFDM/CentralMassGravity.h>
 
 using namespace OpenFDM;
 
+class EarthInertial : public AbstractInertial {
+public:
+  virtual Vector3 getAngularVelocity(const real_type& t) const
+  { return Vector3(0, 0, pi2/(24*60*60)); }
+  virtual Vector6 getAcceleration(const real_type& t) const
+  { return Vector6::zeros(); }
+};
+
 int main()
 {
+  SharedPtr<EllipticPlanet> planet = new EllipticPlanet;
+
   // Model of the paris pendulum or foucault pendulum to test coriolis effects.
 
+  // N 48deg 50.781 E 2deg 20.709
+  // 28 kg, 67 meters pendulum
+  // Deviation 11deg/h
+  // 16,5s cycle time(?back and forth?)
+
   // Position of the pendulum
-//   Geocentric geocentric()
+  Geodetic geodetic(rad2deg*(48 + 50.781/60), rad2deg*(2 + 20.709/60), 0);
   // Test the direction of the velocity vector projected to the ground plane
 
   // FIXME, need usable environment stuff like gravity first ...
   SharedPtr<Group> group = new Group("Foucault");
   FixedRootJoint* fixedRootJoint = new FixedRootJoint("Root");
-  fixedRootJoint->setPosition(Vector3(0, 0, 1));
+  fixedRootJoint->setPosition(planet->toCart(geodetic));
+  fixedRootJoint->setOrientation(planet->getGeodHLOrientation(geodetic));
   Group::NodeId fixedRootJointId = group->addChild(fixedRootJoint);
   RotationalJoint* rotationalJoint1 = new RotationalJoint("Rotational Joint 1");
   Group::NodeId rotationalJoint1Id = group->addChild(rotationalJoint1);
@@ -29,8 +46,8 @@
   rigidBody1->addLink("sensorLink");
   Group::NodeId rigidBody1Id = group->addChild(rigidBody1);
 
-  Mass* mass = new Mass("Mass", 1, InertiaMatrix(1, 0, 0, 1, 0, 1));
-  mass->setPosition(Vector3(1, 1, 0));
+  Mass* mass = new Mass("Mass", 28, InertiaMatrix(1, 0, 0, 1, 0, 1));
+  mass->setPosition(Vector3(3, 0, 67));
   Group::NodeId massId = group->addChild(mass);
 
   Sensor* sensor = new Sensor("Sensor");
@@ -45,12 +62,18 @@
 
   SharedPtr<System> system = new System("System", group);
 
+  SharedPtr<EarthInertial> inertial = new EarthInertial;
+  SharedPtr<CentralMassGravity> gravity = new CentralMassGravity;
+  system->getEnvironment()->setInertial(inertial);
+  system->getEnvironment()->setPlanet(planet);
+  system->getEnvironment()->setGravity(gravity);
   system->attach(SystemOutput::newDefaultSystemOutput("foucault.h5"));
 
   if (!system->init())
     return 1;
 
 //   system->simulate(24*60*60);
+//   system->simulate(60*60);
   system->simulate(60);
 
   return 0;



From frohlich at mail.berlios.de  Sun Nov 30 08:56:16 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 30 Nov 2008 08:56:16 +0100
Subject: [OpenFDM-svn] r814 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811300756.mAU7uGxd015147@sheep.berlios.de>

Author: frohlich
Date: 2008-11-30 08:56:15 +0100 (Sun, 30 Nov 2008)
New Revision: 814

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Node.h
Log:
Simplify node path computation.

M    Node.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Node.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Node.h	2008-11-29 10:44:18 UTC (rev 813)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Node.h	2008-11-30 07:56:15 UTC (rev 814)
@@ -63,15 +63,14 @@
 
   static std::string toNodePathName(const NodePath& nodePath)
   {
-    if (nodePath.empty())
-      return std::string();
-    std::string path = nodePath.front()->getName();
     NodePath::const_iterator i = nodePath.begin();
-    if (i != nodePath.end()) {
-      for (++i; i != nodePath.end(); ++i) {
-        path += '/';
-        path += (*i)->getName();
-      }
+    if (i == nodePath.end())
+      return std::string();
+
+    std::string path = (*i)->getName();
+    for (++i; i != nodePath.end(); ++i) {
+      path += '/';
+      path += (*i)->getName();
     }
     return path;
   }



From frohlich at mail.berlios.de  Sun Nov 30 09:21:42 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 30 Nov 2008 09:21:42 +0100
Subject: [OpenFDM-svn] r815 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811300821.mAU8LgHR017064@sheep.berlios.de>

Author: frohlich
Date: 2008-11-30 09:21:41 +0100 (Sun, 30 Nov 2008)
New Revision: 815

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Mass.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Mass.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.h
Log:
Remove some Joint leftovers from Interact.

M    src/OpenFDM/Mass.h
M    src/OpenFDM/Interact.cpp
M    src/OpenFDM/Mass.cpp
M    src/OpenFDM/Interact.h
M    src/OpenFDM/Sensor.cpp
M    src/OpenFDM/Sensor.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.cpp	2008-11-30 07:56:15 UTC (rev 814)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.cpp	2008-11-30 08:21:41 UTC (rev 815)
@@ -38,27 +38,23 @@
   }
   virtual void articulation(const Task& task)
   {
-    mInteract->articulation(task, mContinousState, mPortValueList, hIh);
+    mInteract->articulation(task, mContinousState, mPortValueList);
   }
   virtual void accelerations(const Task& task)
   {
-    mInteract->acceleration(task, mContinousState, mPortValueList, hIh, velDot);
+    mInteract->acceleration(task, mContinousState, mPortValueList);
   }
 
-  virtual void derivative(const Task&)
+  virtual void derivative(const Task& task)
   {
-    mInteract->derivative(mDiscreteState, mContinousState, mPortValueList,
-                              velDot, mContinousStateDerivative);
+    mInteract->derivative(task, mDiscreteState, mContinousState, mPortValueList,
+                          mContinousStateDerivative);
   }
  
   virtual void update(const DiscreteTask&)
   { }
 
 private:
-  // Stores some values persistent accross velocity/articulation/acceleration
-  Matrix hIh;
-  Vector velDot;
-
   SharedPtr<const Interact> mInteract;
 };
 

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.h	2008-11-30 07:56:15 UTC (rev 814)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.h	2008-11-30 08:21:41 UTC (rev 815)
@@ -36,14 +36,14 @@
                         PortValueList&) const
   { }
   virtual void articulation(const Task&, const ContinousStateValueVector&,
-                            PortValueList&, Matrix&) const
+                            PortValueList&) const
   { }
   virtual void acceleration(const Task&, const ContinousStateValueVector&,
-                            PortValueList&, const Matrix&, Vector&) const
+                            PortValueList&) const
   { }
-  virtual void derivative(const DiscreteStateValueVector&,
+  virtual void derivative(const Task&, const DiscreteStateValueVector&,
                           const ContinousStateValueVector&,
-                          const PortValueList&, const Vector&,
+                          const PortValueList&,
                           ContinousStateValueVector&) const
   { }
 

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Mass.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Mass.cpp	2008-11-30 07:56:15 UTC (rev 814)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Mass.cpp	2008-11-30 08:21:41 UTC (rev 815)
@@ -36,7 +36,7 @@
 
 void
 Mass::articulation(const Task&, const ContinousStateValueVector&,
-                   PortValueList& portValues, Matrix&) const
+                   PortValueList& portValues) const
 {
   const Environment* environment;
   environment = portValues[mMechanicLink].getEnvironment();

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Mass.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Mass.h	2008-11-30 07:56:15 UTC (rev 814)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Mass.h	2008-11-30 08:21:41 UTC (rev 815)
@@ -20,7 +20,7 @@
 
   virtual void initDesignPosition(PortValueList&) const;
   virtual void articulation(const Task&, const ContinousStateValueVector&,
-                            PortValueList&, Matrix&) const;
+                            PortValueList&) const;
 
   const InertiaMatrix& getInertia(void) const;
   void setInertia(const InertiaMatrix& inertia);

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.cpp	2008-11-30 07:56:15 UTC (rev 814)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.cpp	2008-11-30 08:21:41 UTC (rev 815)
@@ -95,7 +95,7 @@
 
 void
 Sensor::acceleration(const Task&, const ContinousStateValueVector&,
-                     PortValueList& portValues, const Matrix&, Vector&) const
+                     PortValueList& portValues) const
 {
   const Environment* environment;
   environment = portValues[mMechanicLink].getEnvironment();

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.h	2008-11-30 07:56:15 UTC (rev 814)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Sensor.h	2008-11-30 08:21:41 UTC (rev 815)
@@ -23,7 +23,7 @@
   virtual void velocity(const Task&, const ContinousStateValueVector&,
                         PortValueList&) const;
   virtual void acceleration(const Task&, const ContinousStateValueVector&,
-                            PortValueList&, const Matrix&, Vector&) const;
+                            PortValueList&) const;
 
   /// Set the position of the sensor in design coordinates
   void setPosition(const Vector3& position);



From frohlich at mail.berlios.de  Sun Nov 30 09:56:05 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 30 Nov 2008 09:56:05 +0100
Subject: [OpenFDM-svn] r816 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811300856.mAU8u5uU019204@sheep.berlios.de>

Author: frohlich
Date: 2008-11-30 09:56:04 +0100 (Sun, 30 Nov 2008)
New Revision: 816

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractModel.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeContext.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeContext.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/LeafContext.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Model.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/ModelContext.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/SimpleDirectModel.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/SimpleDirectModel.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
Log:
Move generic state and port arrays into the
implementations that need them.

M    src/OpenFDM/CartesianJoint.h
M    src/OpenFDM/Model.h
M    src/OpenFDM/Interact.cpp
M    src/OpenFDM/RootJoint.cpp
M    src/OpenFDM/AbstractModel.h
M    src/OpenFDM/AbstractNodeContext.cpp
M    src/OpenFDM/SimpleDirectModel.h
M    src/OpenFDM/LeafContext.h
M    src/OpenFDM/System.cpp
M    src/OpenFDM/SimpleDirectModel.cpp
M    src/OpenFDM/ModelContext.h
M    src/OpenFDM/AbstractNodeContext.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractModel.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractModel.h	2008-11-30 08:21:41 UTC (rev 815)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractModel.h	2008-11-30 08:56:04 UTC (rev 816)
@@ -12,7 +12,7 @@
 
 namespace OpenFDM {
 
-class ModelContext;
+class AbstractModelContext;
 class PortValueList;
 
 class AbstractModel : public LeafNode {
@@ -24,7 +24,7 @@
   virtual void accept(NodeVisitor& visitor);
   virtual void accept(ConstNodeVisitor& visitor) const;
 
-  virtual ModelContext* newModelContext(PortValueList&) const = 0;
+  virtual AbstractModelContext* newModelContext(PortValueList&) const = 0;
 };
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeContext.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeContext.cpp	2008-11-30 08:21:41 UTC (rev 815)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeContext.cpp	2008-11-30 08:56:04 UTC (rev 816)
@@ -14,17 +14,4 @@
 {
 }
 
-const PortValue*
-AbstractNodeContext::getPortValue(const PortInfo& portInfo) const
-{
-  return mPortValueList.getPortValue(portInfo);
-}
-
-void
-AbstractNodeContext::setPortValue(const PortInfo& portInfo,
-                                  PortValue* portValue)
-{
-  mPortValueList.setPortValue(portInfo.getIndex(), portValue);
-}
-
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeContext.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeContext.h	2008-11-30 08:21:41 UTC (rev 815)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeContext.h	2008-11-30 08:56:04 UTC (rev 816)
@@ -19,13 +19,7 @@
   virtual const Node& getNode() const = 0;
 
   /// Port value accessors for System external usage.
-  virtual const PortValue* getPortValue(const PortInfo&) const;
-
-  /// Set port value for the given port.
-  virtual void setPortValue(const PortInfo&, PortValue*);
-
-protected:
-  PortValueList mPortValueList;
+  virtual const PortValue* getPortValue(const PortInfo&) const = 0;
 };
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h	2008-11-30 08:21:41 UTC (rev 815)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h	2008-11-30 08:56:04 UTC (rev 816)
@@ -259,6 +259,45 @@
     const VectorN& getVelDot() const
     { return velDot; }
     
+  bool allocStates()
+  {
+    unsigned numContinousStates = getNode().getNumContinousStateValues();
+    for (unsigned i = 0; i < numContinousStates; ++i) {
+      const ContinousStateInfo* continousStateInfo;
+      continousStateInfo = getNode().getContinousStateInfo(i);
+      mContinousState.setValue(*continousStateInfo, *this);
+      mContinousStateDerivative.setValue(*continousStateInfo, *this);
+    }
+    unsigned numDiscreteStates = getNode().getNumDiscreteStateValues();
+    for (unsigned i = 0; i < numDiscreteStates; ++i) {
+      const StateInfo* stateInfo;
+      stateInfo = getNode().getDiscreteStateInfo(i);
+      mDiscreteState.setValue(*stateInfo, *this);
+    }
+    return true;
+  }
+
+  virtual ContinousStateValue* getStateValue(const ContinousStateInfo& info)
+  { return mContinousState.getValue(info); }
+  virtual ContinousStateValue* getStateDerivative(const ContinousStateInfo& info)
+  { return mContinousStateDerivative.getValue(info); }
+
+  /// Set port value for the given port.
+  virtual const PortValue* getPortValue(const PortInfo& portInfo) const
+  {  return mPortValueList.getPortValue(portInfo); }
+    void setPortValue(const PortInfo& portInfo, PortValue* portValue)
+    { mPortValueList.setPortValue(portInfo.getIndex(), portValue); }
+  
+protected:
+  // PortValues
+  PortValueList mPortValueList;
+
+  // Continous States
+  ContinousStateValueVector mContinousState;
+  ContinousStateValueVector mContinousStateDerivative;
+  // Discrete States
+  DiscreteStateValueVector mDiscreteState;
+
   private:
     // Stores some values persistent accross velocity/articulation/acceleration
     MatrixFactorsNN hIh;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.cpp	2008-11-30 08:21:41 UTC (rev 815)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.cpp	2008-11-30 08:56:04 UTC (rev 816)
@@ -18,9 +18,6 @@
   virtual const Interact& getNode() const
   { return *mInteract; }
 
-  virtual bool alloc()
-  { return allocStates(); }
-
   virtual void initDesignPosition()
   {
     mInteract->initDesignPosition(mPortValueList);
@@ -54,6 +51,45 @@
   virtual void update(const DiscreteTask&)
   { }
 
+  bool alloc()
+  {
+    unsigned numContinousStates = getNode().getNumContinousStateValues();
+    for (unsigned i = 0; i < numContinousStates; ++i) {
+      const ContinousStateInfo* continousStateInfo;
+      continousStateInfo = getNode().getContinousStateInfo(i);
+      mContinousState.setValue(*continousStateInfo, *this);
+      mContinousStateDerivative.setValue(*continousStateInfo, *this);
+    }
+    unsigned numDiscreteStates = getNode().getNumDiscreteStateValues();
+    for (unsigned i = 0; i < numDiscreteStates; ++i) {
+      const StateInfo* stateInfo;
+      stateInfo = getNode().getDiscreteStateInfo(i);
+      mDiscreteState.setValue(*stateInfo, *this);
+    }
+    return true;
+  }
+
+  virtual ContinousStateValue* getStateValue(const ContinousStateInfo& info)
+  { return mContinousState.getValue(info); }
+  virtual ContinousStateValue* getStateDerivative(const ContinousStateInfo& info)
+  { return mContinousStateDerivative.getValue(info); }
+
+  /// Set port value for the given port.
+  virtual const PortValue* getPortValue(const PortInfo& portInfo) const
+  {  return mPortValueList.getPortValue(portInfo); }
+  void setPortValue(const PortInfo& portInfo, PortValue* portValue)
+  { mPortValueList.setPortValue(portInfo.getIndex(), portValue); }
+  
+protected:
+  // PortValues
+  PortValueList mPortValueList;
+
+  // Continous States
+  ContinousStateValueVector mContinousState;
+  ContinousStateValueVector mContinousStateDerivative;
+  // Discrete States
+  DiscreteStateValueVector mDiscreteState;
+
 private:
   SharedPtr<const Interact> mInteract;
 };

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/LeafContext.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/LeafContext.h	2008-11-30 08:21:41 UTC (rev 815)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/LeafContext.h	2008-11-30 08:56:04 UTC (rev 816)
@@ -18,42 +18,8 @@
   virtual ~LeafContext() {}
   virtual const LeafNode& getNode() const = 0;
 
-  void setContinousStateSize(const MatrixStateInfo& stateInfo,
-                             const Size& sz)
-  {
-    mContinousState[stateInfo].resize(sz(0), sz(1));
-    mContinousStateDerivative[stateInfo].resize(sz(0), sz(1));
-  }
-
-  bool allocStates()
-  {
-    unsigned numContinousStates = getNode().getNumContinousStateValues();
-    for (unsigned i = 0; i < numContinousStates; ++i) {
-      const ContinousStateInfo* continousStateInfo;
-      continousStateInfo = getNode().getContinousStateInfo(i);
-      mContinousState.setValue(*continousStateInfo, *this);
-      mContinousStateDerivative.setValue(*continousStateInfo, *this);
-    }
-    unsigned numDiscreteStates = getNode().getNumDiscreteStateValues();
-    for (unsigned i = 0; i < numDiscreteStates; ++i) {
-      const StateInfo* stateInfo;
-      stateInfo = getNode().getDiscreteStateInfo(i);
-      mDiscreteState.setValue(*stateInfo, *this);
-    }
-    return true;
-  }
-
-  virtual ContinousStateValue* getStateValue(const ContinousStateInfo& info)
-  { return mContinousState.getValue(info); }
-  virtual ContinousStateValue* getStateDerivative(const ContinousStateInfo& info)
-  { return mContinousStateDerivative.getValue(info); }
-  
-protected:
-  // Continous States
-  ContinousStateValueVector mContinousState;
-  ContinousStateValueVector mContinousStateDerivative;
-  // Discrete States
-  DiscreteStateValueVector mDiscreteState;
+  virtual ContinousStateValue* getStateValue(const ContinousStateInfo&) = 0;
+  virtual ContinousStateValue* getStateDerivative(const ContinousStateInfo&) =0;
 };
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Model.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Model.h	2008-11-30 08:21:41 UTC (rev 815)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Model.h	2008-11-30 08:56:04 UTC (rev 816)
@@ -12,6 +12,7 @@
 #include "AbstractModel.h"
 #include "MatrixInputPort.h"
 #include "MatrixOutputPort.h"
+#include "ModelContext.h"
 #include "RealInputPort.h"
 #include "RealOutputPort.h"
 

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/ModelContext.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ModelContext.h	2008-11-30 08:21:41 UTC (rev 815)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ModelContext.h	2008-11-30 08:56:04 UTC (rev 816)
@@ -17,11 +17,11 @@
 class DiscreteTask;
 class InitTask;
 
-//// This one is used to execute the simulation system
-class ModelContext : public LeafContext {
+/// This one is used to execute the simulation system
+class AbstractModelContext : public LeafContext {
 public:
-  ModelContext() {}
-  virtual ~ModelContext();
+  AbstractModelContext() {}
+  virtual ~AbstractModelContext() {}
 
   virtual const AbstractModel& getNode() const = 0;
 
@@ -30,18 +30,77 @@
   virtual void update(const DiscreteTask& discreteTask) = 0;
   virtual void derivative(const Task&) = 0;
 
+private:
+  AbstractModelContext(const AbstractModelContext&);
+  AbstractModelContext& operator=(const AbstractModelContext&);
+};
+
+
+
+class ModelContext : public AbstractModelContext {
+public:
+  ModelContext() {}
+  virtual ~ModelContext();
+
   /// might vanish???
   PortValueList& getPortValueList()
   { return mPortValueList; }
 
+  virtual void setContinousStateSize(const MatrixStateInfo& stateInfo,
+                                     const Size& sz)
+  {
+    mContinousState[stateInfo].resize(sz(0), sz(1));
+    mContinousStateDerivative[stateInfo].resize(sz(0), sz(1));
+  }
+
+  virtual bool allocStates()
+  {
+    unsigned numContinousStates = getNode().getNumContinousStateValues();
+    for (unsigned i = 0; i < numContinousStates; ++i) {
+      const ContinousStateInfo* continousStateInfo;
+      continousStateInfo = getNode().getContinousStateInfo(i);
+      mContinousState.setValue(*continousStateInfo, *this);
+      mContinousStateDerivative.setValue(*continousStateInfo, *this);
+    }
+    unsigned numDiscreteStates = getNode().getNumDiscreteStateValues();
+    for (unsigned i = 0; i < numDiscreteStates; ++i) {
+      const StateInfo* stateInfo;
+      stateInfo = getNode().getDiscreteStateInfo(i);
+      mDiscreteState.setValue(*stateInfo, *this);
+    }
+    return true;
+  }
+
+  virtual ContinousStateValue* getStateValue(const ContinousStateInfo& info)
+  { return mContinousState.getValue(info); }
+  virtual ContinousStateValue* getStateDerivative(const ContinousStateInfo& info)
+  { return mContinousStateDerivative.getValue(info); }
+
+  /// Set port value for the given port.
+  virtual const PortValue* getPortValue(const PortInfo& portInfo) const
+  {  return mPortValueList.getPortValue(portInfo); }
+  virtual void setPortValue(const PortInfo& portInfo, PortValue* portValue)
+  { mPortValueList.setPortValue(portInfo.getIndex(), portValue); }
+
+  
+protected:
+  // PortValues
+  PortValueList mPortValueList;
+
+  // Continous States
+  ContinousStateValueVector mContinousState;
+  ContinousStateValueVector mContinousStateDerivative;
+  // Discrete States
+  DiscreteStateValueVector mDiscreteState;
+
 private:
   ModelContext(const ModelContext&);
   ModelContext& operator=(const ModelContext&);
 };
 
-class ModelContextList : public std::list<SharedPtr<ModelContext> > {
+class ModelContextList : public std::list<SharedPtr<AbstractModelContext> > {
 public:
-  typedef std::list<SharedPtr<ModelContext> > list_type;
+  typedef std::list<SharedPtr<AbstractModelContext> > list_type;
 
   void initOutput(const /*Init*/Task& task) const
   {

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.cpp	2008-11-30 08:21:41 UTC (rev 815)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.cpp	2008-11-30 08:56:04 UTC (rev 816)
@@ -50,7 +50,47 @@
   
   virtual void update(const DiscreteTask&)
   { }
+
+  virtual bool allocStates()
+  {
+    unsigned numContinousStates = getNode().getNumContinousStateValues();
+    for (unsigned i = 0; i < numContinousStates; ++i) {
+      const ContinousStateInfo* continousStateInfo;
+      continousStateInfo = getNode().getContinousStateInfo(i);
+      mContinousState.setValue(*continousStateInfo, *this);
+      mContinousStateDerivative.setValue(*continousStateInfo, *this);
+    }
+    unsigned numDiscreteStates = getNode().getNumDiscreteStateValues();
+    for (unsigned i = 0; i < numDiscreteStates; ++i) {
+      const StateInfo* stateInfo;
+      stateInfo = getNode().getDiscreteStateInfo(i);
+      mDiscreteState.setValue(*stateInfo, *this);
+    }
+    return true;
+  }
   
+  virtual ContinousStateValue* getStateValue(const ContinousStateInfo& info)
+  { return mContinousState.getValue(info); }
+  virtual ContinousStateValue* getStateDerivative(const ContinousStateInfo& info)
+  { return mContinousStateDerivative.getValue(info); }
+  
+  /// Set port value for the given port.
+  virtual const PortValue* getPortValue(const PortInfo& portInfo) const
+  {  return mPortValueList.getPortValue(portInfo); }
+  void setPortValue(const PortInfo& portInfo, PortValue* portValue)
+  { mPortValueList.setPortValue(portInfo.getIndex(), portValue); }
+  
+  
+protected:
+  // PortValues
+  PortValueList mPortValueList;
+  
+  // Continous States
+  ContinousStateValueVector mContinousState;
+  ContinousStateValueVector mContinousStateDerivative;
+  // Discrete States
+  DiscreteStateValueVector mDiscreteState;
+  
 private:
   SharedPtr<const RootJoint> mRootJoint;
 };

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/SimpleDirectModel.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/SimpleDirectModel.cpp	2008-11-30 08:21:41 UTC (rev 815)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/SimpleDirectModel.cpp	2008-11-30 08:56:04 UTC (rev 816)
@@ -42,12 +42,18 @@
   return 0;
 }
 
-void
-SimpleDirectModel::Context::setPortValue(const PortInfo& i, PortValue* v)
+ContinousStateValue*
+SimpleDirectModel::Context::getStateValue(const ContinousStateInfo&)
 {
-  OpenFDMAssert(false);
+  return 0;
 }
-    
+
+ContinousStateValue*
+SimpleDirectModel::Context::getStateDerivative(const ContinousStateInfo&)
+{
+  return 0;
+}
+
 void
 SimpleDirectModel::Context::initOutput(const /*Init*/Task&)
 {
@@ -83,7 +89,7 @@
 {
 }
 
-ModelContext*
+AbstractModelContext*
 SimpleDirectModel::newModelContext(PortValueList& portValueList) const
 {
   if (mInputPorts.empty()) {

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/SimpleDirectModel.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/SimpleDirectModel.h	2008-11-30 08:21:41 UTC (rev 815)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/SimpleDirectModel.h	2008-11-30 08:56:04 UTC (rev 816)
@@ -31,11 +31,11 @@
   { return PortId(mOutputPort); }
 
   class Context;
-  virtual ModelContext* newModelContext(PortValueList& portValueList) const;
+  virtual AbstractModelContext* newModelContext(PortValueList& portValueList) const;
   virtual void output(Context& context) const = 0;
 
   typedef std::vector<SharedPtr<const NumericPortValue> > InputValueVector;
-  class Context : public ModelContext {
+  class Context : public AbstractModelContext {
   public:
     Context(const SimpleDirectModel* model, const InputValueVector& inputValues,
             NumericPortValue* outputValue);
@@ -43,7 +43,9 @@
     
     virtual const SimpleDirectModel& getNode() const;
     virtual const PortValue* getPortValue(const PortInfo&) const;
-    virtual void setPortValue(const PortInfo&, PortValue*);
+
+    virtual ContinousStateValue* getStateValue(const ContinousStateInfo&);
+    virtual ContinousStateValue* getStateDerivative(const ContinousStateInfo&);
     
     virtual void initOutput(const /*Init*/Task&);
     virtual void output(const Task&);

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-30 08:21:41 UTC (rev 815)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-11-30 08:56:04 UTC (rev 816)
@@ -115,7 +115,8 @@
   }
 
   void appendModelContext(const SampleTime& sampleTime,
-                          ModelContext* modelContext, unsigned listIndex)
+                          AbstractModelContext* modelContext,
+                          unsigned listIndex)
   {
     // The init task contains them all
     mInitTask->mModelContextList[listIndex].push_back(modelContext);
@@ -532,12 +533,12 @@
     virtual AbstractNodeInstance* newNodeInstance()
     { return new LeafInstance(mSampleTime, mModelContext); }
 
-    ModelContext* getModelContext()
+    AbstractModelContext* getModelContext()
     { return mModelContext; }
 
   private:
     SharedPtr<const AbstractModel> mModel;
-    SharedPtr<ModelContext> mModelContext;
+    SharedPtr<AbstractModelContext> mModelContext;
   };
   struct MechanicInstanceData : public InstanceData {
     MechanicInstanceData(const MechanicNode& mechanicNode,



From frohlich at mail.berlios.de  Sun Nov 30 10:04:51 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 30 Nov 2008 10:04:51 +0100
Subject: [OpenFDM-svn] r817 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811300904.mAU94pHS019874@sheep.berlios.de>

Author: frohlich
Date: 2008-11-30 10:04:51 +0100 (Sun, 30 Nov 2008)
New Revision: 817

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/BinaryFunction.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/BinaryFunction.h
Log:
Derive Binary functions from SimpleDirectModel

M    src/OpenFDM/BinaryFunction.h
M    src/OpenFDM/BinaryFunction.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/BinaryFunction.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/BinaryFunction.cpp	2008-11-30 08:56:04 UTC (rev 816)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/BinaryFunction.cpp	2008-11-30 09:04:51 UTC (rev 817)
@@ -1,4 +1,4 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich
  *
  */
 
@@ -9,61 +9,36 @@
 
 namespace OpenFDM {
 
-BEGIN_OPENFDM_OBJECT_DEF(BinaryFunction, Model)
+BEGIN_OPENFDM_OBJECT_DEF(BinaryFunction, SimpleDirectModel)
   END_OPENFDM_OBJECT_DEF
 
 BinaryFunction::BinaryFunction(const std::string& name, Type type) :
-  Model(name),
-  mInput0Port(newMatrixInputPort("input0", true)),
-  mInput1Port(newMatrixInputPort("input1", true)),
-  mOutputPort(newMatrixOutputPort("output"))
+  SimpleDirectModel(name)
 {
+  setNumInputPorts(2);
 }
 
 BinaryFunction::~BinaryFunction(void)
 {
 }
 
-bool
-BinaryFunction::alloc(ModelContext& context) const
-{
-  Size sz = size(context.getPortValueList()[mInput0Port]);
-  Log(Initialization, Debug)
-    << "Size for BinaryFunction is detemined by input0 "
-    << "port with size: " << trans(sz) << std::endl;
-  if (!context.getPortValueList().setOrCheckPortSize(mInput1Port, sz)) {
-    Log(Initialization, Error)
-      << "Size for input1 port does not match!" << std::endl;
-    return false;
-  }
-  if (!context.getPortValueList().setOrCheckPortSize(mOutputPort, sz)) {
-    Log(Initialization, Error)
-      << "Size for output port does not match!" << std::endl;
-    return false;
-  }
-  return true;
-}
-
 void
-BinaryFunction::output(const Task&,const DiscreteStateValueVector&,
-                       const ContinousStateValueVector&,
-                       PortValueList& portValues) const
+BinaryFunction::output(Context& context) const
 {
-  Size sz = size(portValues[mOutputPort]);
+  Size sz = size(context.getInputValue(0));
   for (unsigned j = 0; j < sz(1); ++j) {
     for (unsigned i = 0; i < sz(0); ++i) {
+      real_type input0 = context.getInputValue(0)(i, j);
+      real_type input1 = context.getInputValue(1)(i, j);
       switch (mType) {
       case Atan2:
-        portValues[mOutputPort](i, j) =
-          atan2(portValues[mInput0Port](i, j), portValues[mInput1Port](i, j));
+        context.getOutputValue()(i, j) = atan2(input0, input1);
         break;
       case Pow:
-        portValues[mOutputPort](i, j) =
-          pow(portValues[mInput0Port](i, j), portValues[mInput1Port](i, j));
+        context.getOutputValue()(i, j) = pow(input0, input1);
         break;
       case Div:
-        portValues[mOutputPort](i, j) =
-          portValues[mInput0Port](i, j) / portValues[mInput1Port](i, j);
+        context.getOutputValue()(i, j) = input0 / input1;
         break;
       default:
         OpenFDMAssert(false);

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/BinaryFunction.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/BinaryFunction.h	2008-11-30 08:56:04 UTC (rev 816)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/BinaryFunction.h	2008-11-30 09:04:51 UTC (rev 817)
@@ -6,13 +6,13 @@
 #define OpenFDM_BinaryFunction_H
 
 #include <string>
-#include "Model.h"
+#include "SimpleDirectModel.h"
 
 namespace OpenFDM {
 
 /// Class representing a model with exactly two inputs.
-class BinaryFunction : public Model {
-  OPENFDM_OBJECT(BinaryFunction, Model);
+class BinaryFunction : public SimpleDirectModel {
+  OPENFDM_OBJECT(BinaryFunction, SimpleDirectModel);
 public:
   enum Type {
     Atan2,
@@ -23,19 +23,12 @@
   BinaryFunction(const std::string& name, Type type);
   virtual ~BinaryFunction(void);
 
-  virtual bool alloc(ModelContext&) const;
-  virtual void output(const Task&, const DiscreteStateValueVector&,
-                      const ContinousStateValueVector&,
-                      PortValueList& portValues) const;
+  virtual void output(Context& context) const;
 
   void setType(const Type& type);
   const Type& getType(void) const;
 
 private:
-  MatrixInputPort mInput0Port;
-  MatrixInputPort mInput1Port;
-  MatrixOutputPort mOutputPort;
-  
   Type mType;
 };
 



From frohlich at mail.berlios.de  Sun Nov 30 10:10:47 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 30 Nov 2008 10:10:47 +0100
Subject: [OpenFDM-svn] r818 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811300910.mAU9AlgU020345@sheep.berlios.de>

Author: frohlich
Date: 2008-11-30 10:10:47 +0100 (Sun, 30 Nov 2008)
New Revision: 818

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Table.cpp
Log:
Fix number of table inputs.

M    src/OpenFDM/Table.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Table.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Table.cpp	2008-11-30 09:04:51 UTC (rev 817)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Table.cpp	2008-11-30 09:10:47 UTC (rev 818)
@@ -99,7 +99,7 @@
 Table3D::Table3D(const std::string& name) :
   SimpleDirectModel(name)
 {
-  setNumInputPorts(2);
+  setNumInputPorts(3);
 }
 
 Table3D::~Table3D(void)



From frohlich at mail.berlios.de  Sun Nov 30 10:14:30 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 30 Nov 2008 10:14:30 +0100
Subject: [OpenFDM-svn] r819 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811300914.mAU9EUDs020459@sheep.berlios.de>

Author: frohlich
Date: 2008-11-30 10:14:30 +0100 (Sun, 30 Nov 2008)
New Revision: 819

Added:
   branches/OpenFDM-StateSeparation/src/OpenFDM/BreakPointLookup.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/BreakPointLookup.h
Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
   branches/OpenFDM-StateSeparation/src/OpenFDM/Table.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Table.h
Log:
Put BreakPointLookup into its own implementation file.

A    src/OpenFDM/BreakPointLookup.h
M    src/OpenFDM/Makefile.am
M    src/OpenFDM/Table.h
A    src/OpenFDM/BreakPointLookup.cpp
M    src/OpenFDM/Table.cpp


Added: branches/OpenFDM-StateSeparation/src/OpenFDM/BreakPointLookup.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/BreakPointLookup.cpp	2008-11-30 09:10:47 UTC (rev 818)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/BreakPointLookup.cpp	2008-11-30 09:14:30 UTC (rev 819)
@@ -0,0 +1,40 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich
+ *
+ */
+
+#include "BreakPointLookup.h"
+
+#include <map>
+#include <iostream>
+#include "Matrix.h"
+#include "Vector.h"
+
+namespace OpenFDM {
+
+BEGIN_OPENFDM_OBJECT_DEF(BreakPointLookup, SimpleDirectModel)
+  DEF_OPENFDM_PROPERTY(BreakPointLookup, BreakPointVector, Serialized)
+  END_OPENFDM_OBJECT_DEF
+
+BreakPointLookup::BreakPointLookup(const std::string& name) :
+  SimpleDirectModel(name)
+{
+  setNumInputPorts(1);
+}
+
+BreakPointLookup::~BreakPointLookup(void)
+{
+}
+
+void
+BreakPointLookup::output(Context& context) const
+{
+  Size sz = size(context.getInputValue(0));
+  for (unsigned j = 0; j < sz(0); ++j) {
+    for (unsigned k = 0; k < sz(1); ++k) {
+      real_type input = context.getInputValue(0)(j, k);
+      context.getOutputValue()(j, k) = mBreakPointVector.lookup(input);
+    }
+  }
+}
+
+} // namespace OpenFDM

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/BreakPointLookup.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/BreakPointLookup.h	2008-11-30 09:10:47 UTC (rev 818)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/BreakPointLookup.h	2008-11-30 09:14:30 UTC (rev 819)
@@ -0,0 +1,32 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich
+ *
+ */
+
+#ifndef OpenFDM_BreakPointLookup_H
+#define OpenFDM_BreakPointLookup_H
+
+#include "TableData.h"
+#include "SimpleDirectModel.h"
+
+namespace OpenFDM {
+
+class BreakPointLookup : public SimpleDirectModel {
+  OPENFDM_OBJECT(BreakPointLookup, SimpleDirectModel);
+public:
+  BreakPointLookup(const std::string& name);
+  virtual ~BreakPointLookup(void);
+
+  virtual void output(Context& context) const;
+
+  void setBreakPointVector(const BreakPointVector& breakPointVector)
+  { mBreakPointVector = breakPointVector; }
+  const BreakPointVector& getBreakPointVector(void) const
+  { return mBreakPointVector; }
+
+private:
+  BreakPointVector mBreakPointVector;
+};
+
+} // namespace OpenFDM
+
+#endif

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-11-30 09:10:47 UTC (rev 818)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-11-30 09:14:30 UTC (rev 819)
@@ -199,6 +199,7 @@
   AtmosphereSTD1976.h \
   Bias.h \
   BinaryFunction.h \
+  BreakPointLookup.h \
   CartesianJoint.h \
   ConstModel.h \
   Contact.h \
@@ -247,6 +248,7 @@
   AirSpring.cpp \
   Bias.cpp \
   BinaryFunction.cpp \
+  BreakPointLookup.cpp \
   ConstModel.cpp \
   DeadBand.cpp \
   Delay.cpp \

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Table.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Table.cpp	2008-11-30 09:10:47 UTC (rev 818)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Table.cpp	2008-11-30 09:14:30 UTC (rev 819)
@@ -11,32 +11,6 @@
 
 namespace OpenFDM {
 
-BEGIN_OPENFDM_OBJECT_DEF(BreakPointLookup, SimpleDirectModel)
-  DEF_OPENFDM_PROPERTY(BreakPointLookup, BreakPointVector, Serialized)
-  END_OPENFDM_OBJECT_DEF
-
-BreakPointLookup::BreakPointLookup(const std::string& name) :
-  SimpleDirectModel(name)
-{
-  setNumInputPorts(1);
-}
-
-BreakPointLookup::~BreakPointLookup(void)
-{
-}
-
-void
-BreakPointLookup::output(Context& context) const
-{
-  Size sz = size(context.getInputValue(0));
-  for (unsigned j = 0; j < sz(0); ++j) {
-    for (unsigned k = 0; k < sz(1); ++k) {
-      real_type input = context.getInputValue(0)(j, k);
-      context.getOutputValue()(j, k) = mBreakPointVector.lookup(input);
-    }
-  }
-}
-
 BEGIN_OPENFDM_OBJECT_DEF(Table1D, SimpleDirectModel)
   DEF_OPENFDM_PROPERTY(Table1D, TableData, Serialized)
   END_OPENFDM_OBJECT_DEF

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Table.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Table.h	2008-11-30 09:10:47 UTC (rev 818)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Table.h	2008-11-30 09:14:30 UTC (rev 819)
@@ -10,23 +10,6 @@
 
 namespace OpenFDM {
 
-class BreakPointLookup : public SimpleDirectModel {
-  OPENFDM_OBJECT(BreakPointLookup, SimpleDirectModel);
-public:
-  BreakPointLookup(const std::string& name);
-  virtual ~BreakPointLookup(void);
-
-  virtual void output(Context& context) const;
-
-  void setBreakPointVector(const BreakPointVector& breakPointVector)
-  { mBreakPointVector = breakPointVector; }
-  const BreakPointVector& getBreakPointVector(void) const
-  { return mBreakPointVector; }
-
-private:
-  BreakPointVector mBreakPointVector;
-};
-
 class Table1D : public SimpleDirectModel {
   OPENFDM_OBJECT(Table1D, SimpleDirectModel);
 public:



From frohlich at mail.berlios.de  Sun Nov 30 10:40:05 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 30 Nov 2008 10:40:05 +0100
Subject: [OpenFDM-svn] r820 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811300940.mAU9e5OP021717@sheep.berlios.de>

Author: frohlich
Date: 2008-11-30 10:40:03 +0100 (Sun, 30 Nov 2008)
New Revision: 820

Removed:
   branches/OpenFDM-StateSeparation/src/OpenFDM/UnaryModel.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/UnaryModel.h
Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Bias.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Bias.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/DeadBand.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/DeadBand.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Gain.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Gain.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
   branches/OpenFDM-StateSeparation/src/OpenFDM/Saturation.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Saturation.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/UnaryFunction.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/UnaryFunction.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/UnitConversion.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/UnitConversion.h
Log:
Use SimpleDirectModel instead of UnaryModel.
Remove UnaryModel.

M    src/OpenFDM/Saturation.h
M    src/OpenFDM/Gain.cpp
M    src/OpenFDM/DeadBand.cpp
M    src/OpenFDM/Makefile.am
M    src/OpenFDM/DeadBand.h
M    src/OpenFDM/UnitConversion.h
M    src/OpenFDM/Bias.h
D    src/OpenFDM/UnaryModel.cpp
M    src/OpenFDM/UnaryFunction.h
M    src/OpenFDM/UnitConversion.cpp
M    src/OpenFDM/UnaryFunction.cpp
M    src/OpenFDM/Bias.cpp
M    src/OpenFDM/Gain.h
M    src/OpenFDM/Saturation.cpp
D    src/OpenFDM/UnaryModel.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Bias.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Bias.cpp	2008-11-30 09:14:30 UTC (rev 819)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Bias.cpp	2008-11-30 09:40:03 UTC (rev 820)
@@ -14,30 +14,33 @@
 
 namespace OpenFDM {
 
-BEGIN_OPENFDM_OBJECT_DEF(Bias, UnaryModel)
+BEGIN_OPENFDM_OBJECT_DEF(Bias, SimpleDirectModel)
   DEF_OPENFDM_PROPERTY(Matrix, Bias, Serialized)
   END_OPENFDM_OBJECT_DEF
 
 Bias::Bias(const std::string& name, const real_type& bias) :
-  UnaryModel(name)
+  SimpleDirectModel(name)
 {
   setBias(bias);
+  addInputPort("input");
 }
 
 Bias::~Bias(void)
 {
 }
   
-ModelContext*
-Bias::newModelContext(PortValueList& portValueList) const
-{
-  return UnaryModel::newModelContext(this, portValueList);
-}
-
 void
-Bias::output(const Matrix& inputValue, Matrix& outputValue) const
+Bias::output(Context& context) const
 {
-  outputValue = mBias + inputValue;
+  Size sz = size(context.getInputValue(0));
+  // FIXME: can we check that in advance???
+  OpenFDMAssert(sz == size(mBias));
+  for (unsigned j = 0; j < sz(0); ++j) {
+    for (unsigned k = 0; k < sz(1); ++k) {
+      context.getOutputValue()(j, k)
+        = mBias(j, k) + context.getInputValue(0)(j, k);
+    }
+  }
 }
 
 const Matrix&

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Bias.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Bias.h	2008-11-30 09:14:30 UTC (rev 819)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Bias.h	2008-11-30 09:40:03 UTC (rev 820)
@@ -7,18 +7,17 @@
 
 #include <string>
 
-#include "UnaryModel.h"
+#include "SimpleDirectModel.h"
 
 namespace OpenFDM {
 
-class Bias : public UnaryModel {
-  OPENFDM_OBJECT(Bias, UnaryModel);
+class Bias : public SimpleDirectModel {
+  OPENFDM_OBJECT(Bias, SimpleDirectModel);
 public:
   Bias(const std::string& name, const real_type& bias = real_type(0));
   virtual ~Bias(void);
 
-  ModelContext* newModelContext(PortValueList&) const;
-  void output(const Matrix& inputValue, Matrix& outputValue) const;
+  void output(Context& context) const;
 
   const Matrix& getBias(void) const;
   void setBias(const Matrix& bias);

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/DeadBand.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/DeadBand.cpp	2008-11-30 09:14:30 UTC (rev 819)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/DeadBand.cpp	2008-11-30 09:40:03 UTC (rev 820)
@@ -8,32 +8,29 @@
 
 namespace OpenFDM {
 
-BEGIN_OPENFDM_OBJECT_DEF(DeadBand, UnaryModel)
+BEGIN_OPENFDM_OBJECT_DEF(DeadBand, SimpleDirectModel)
   DEF_OPENFDM_PROPERTY(Real, Width, Serialized)
   END_OPENFDM_OBJECT_DEF
 
 DeadBand::DeadBand(const std::string& name, const real_type& width) :
-  UnaryModel(name),
+  SimpleDirectModel(name),
   mWidth(width)
 {
+  addInputPort("input");
 }
 
 DeadBand::~DeadBand(void)
 {
 }
   
-ModelContext*
-DeadBand::newModelContext(PortValueList& portValueList) const
-{
-  return UnaryModel::newModelContext(this, portValueList);
-}
-
 void
-DeadBand::output(const Matrix& inputValue, Matrix& outputValue) const
+DeadBand::output(Context& context) const
 {
-  for (unsigned i = 0; i < rows(inputValue); ++i)
-    for (unsigned j = 0; j < cols(inputValue); ++j)
-      outputValue(i, j) = deadBand(inputValue(i, j), mWidth);
+  Size sz = size(context.getInputValue(0));
+  for (unsigned i = 0; i < sz(0); ++i)
+    for (unsigned j = 0; j < sz(1); ++j)
+      context.getOutputValue()(i, j)
+        = deadBand(context.getInputValue(0)(i, j), mWidth);
 }
 
 const real_type&

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/DeadBand.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/DeadBand.h	2008-11-30 09:14:30 UTC (rev 819)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/DeadBand.h	2008-11-30 09:40:03 UTC (rev 820)
@@ -7,20 +7,18 @@
 
 #include <string>
 
-#include "UnaryModel.h"
+#include "SimpleDirectModel.h"
 
 namespace OpenFDM {
 
-class DeadBand : public UnaryModel {
-  OPENFDM_OBJECT(DeadBand, UnaryModel);
+class DeadBand : public SimpleDirectModel {
+  OPENFDM_OBJECT(DeadBand, SimpleDirectModel);
 public:
   DeadBand(const std::string& name, const real_type& width = real_type(0));
   virtual ~DeadBand(void);
 
-  ModelContext* newModelContext(PortValueList&) const;
+  void output(Context& context) const;
 
-  void output(const Matrix& inputValue, Matrix& outputValue) const;
-
   const real_type& getWidth(void) const;
   void setWidth(const real_type& width);
 

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Gain.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Gain.cpp	2008-11-30 09:14:30 UTC (rev 819)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Gain.cpp	2008-11-30 09:40:03 UTC (rev 820)
@@ -9,30 +9,30 @@
 
 namespace OpenFDM {
 
-BEGIN_OPENFDM_OBJECT_DEF(Gain, UnaryModel)
+BEGIN_OPENFDM_OBJECT_DEF(Gain, SimpleDirectModel)
   DEF_OPENFDM_PROPERTY(Real, Gain, Serialized)
   END_OPENFDM_OBJECT_DEF
 
 Gain::Gain(const std::string& name, const real_type& gain) :
-  UnaryModel(name),
+  SimpleDirectModel(name),
   mGain(gain)
 {
+  addInputPort("input");
 }
 
 Gain::~Gain(void)
 {
 }
 
-ModelContext*
-Gain::newModelContext(PortValueList& portValueList) const
-{
-  return UnaryModel::newModelContext(this, portValueList);
-}
-
 void
-Gain::output(const Matrix& inputValue, Matrix& outputValue) const
+Gain::output(Context& context) const
 {
-  outputValue = mGain*inputValue;
+  Size sz = size(context.getInputValue(0));
+  for (unsigned j = 0; j < sz(0); ++j) {
+    for (unsigned k = 0; k < sz(1); ++k) {
+      context.getOutputValue()(j, k) = mGain*context.getInputValue(0)(j, k);
+    }
+  }
 }
 
 const real_type&

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Gain.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Gain.h	2008-11-30 09:14:30 UTC (rev 819)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Gain.h	2008-11-30 09:40:03 UTC (rev 820)
@@ -7,21 +7,19 @@
 
 #include <string>
 
-#include "UnaryModel.h"
+#include "SimpleDirectModel.h"
 #include "ModelContext.h"
 
 namespace OpenFDM {
 
-class Gain : public UnaryModel {
-  OPENFDM_OBJECT(Gain, UnaryModel);
+class Gain : public SimpleDirectModel {
+  OPENFDM_OBJECT(Gain, SimpleDirectModel);
 public:
   Gain(const std::string& name, const real_type& gain = real_type(1));
   virtual ~Gain(void);
 
-  ModelContext* newModelContext(PortValueList&) const;
+  void output(Context& context) const;
 
-  void output(const Matrix& inputValue, Matrix& outputValue) const;
-
   const real_type& getGain(void) const;
   void setGain(const real_type& gain);
 

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-11-30 09:14:30 UTC (rev 819)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-11-30 09:40:03 UTC (rev 820)
@@ -239,7 +239,6 @@
   TimeDerivative.h \
   TransferFunction.h \
   UnaryFunction.h \
-  UnaryModel.h \
   UnitConversion.h \
   UniversalJoint.h \
   WheelContact.h
@@ -267,7 +266,6 @@
   Summer.cpp \
   Table.cpp \
   UnaryFunction.cpp \
-  UnaryModel.cpp \
   UnitConversion.cpp
 
 #   DiscBrake.cpp \

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Saturation.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Saturation.cpp	2008-11-30 09:14:30 UTC (rev 819)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Saturation.cpp	2008-11-30 09:40:03 UTC (rev 820)
@@ -8,34 +8,31 @@
 
 namespace OpenFDM {
 
-BEGIN_OPENFDM_OBJECT_DEF(Saturation, UnaryModel)
+BEGIN_OPENFDM_OBJECT_DEF(Saturation, SimpleDirectModel)
   DEF_OPENFDM_PROPERTY(Matrix, MinSaturation, Serialized)
   DEF_OPENFDM_PROPERTY(Matrix, MaxSaturation, Serialized)
   END_OPENFDM_OBJECT_DEF
 
 Saturation::Saturation(const std::string& name) :
-  UnaryModel(name)
+  SimpleDirectModel(name)
 {
+  addInputPort("input");
 }
 
 Saturation::~Saturation(void)
 {
 }
   
-ModelContext*
-Saturation::newModelContext(PortValueList& portValueList) const
-{
-  return UnaryModel::newModelContext(this, portValueList);
-}
-
 void
-Saturation::output(const Matrix& inputValue, Matrix& outputValue) const
+Saturation::output(Context& context) const
 {
-  outputValue = inputValue;
+  context.getOutputValue() = context.getInputValue(0);
   if (0 < rows(mMaxSaturation) && 0 < cols(mMaxSaturation))
-    outputValue = LinAlg::min(outputValue, mMaxSaturation);
+    context.getOutputValue()
+      = LinAlg::min(context.getOutputValue(), mMaxSaturation);
   if (0 < rows(mMinSaturation) && 0 < cols(mMinSaturation))
-    outputValue = LinAlg::max(outputValue, mMinSaturation);
+    context.getOutputValue()
+      = LinAlg::max(context.getOutputValue(), mMinSaturation);
 }
 
 const Matrix&

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Saturation.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Saturation.h	2008-11-30 09:14:30 UTC (rev 819)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Saturation.h	2008-11-30 09:40:03 UTC (rev 820)
@@ -8,20 +8,18 @@
 #include <string>
 
 #include "Matrix.h"
-#include "UnaryModel.h"
+#include "SimpleDirectModel.h"
 
 namespace OpenFDM {
 
-class Saturation : public UnaryModel {
-  OPENFDM_OBJECT(Saturation, UnaryModel);
+class Saturation : public SimpleDirectModel {
+  OPENFDM_OBJECT(Saturation, SimpleDirectModel);
 public:
   Saturation(const std::string& name);
   virtual ~Saturation(void);
   
-  ModelContext* newModelContext(PortValueList&) const;
+  void output(Context& context) const;
 
-  void output(const Matrix& inputValue, Matrix& outputValue) const;
-
   const Matrix& getMinSaturation(void) const;
   void setMinSaturation(const Matrix& minSaturation);
   const Matrix& getMaxSaturation(void) const;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/UnaryFunction.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/UnaryFunction.cpp	2008-11-30 09:14:30 UTC (rev 819)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/UnaryFunction.cpp	2008-11-30 09:40:03 UTC (rev 820)
@@ -8,81 +8,77 @@
 
 namespace OpenFDM {
 
-BEGIN_OPENFDM_OBJECT_DEF(UnaryFunction, UnaryModel)
+BEGIN_OPENFDM_OBJECT_DEF(UnaryFunction, SimpleDirectModel)
   END_OPENFDM_OBJECT_DEF
 
 UnaryFunction::UnaryFunction(const std::string& name, const Type& type) :
-  UnaryModel(name),
+  SimpleDirectModel(name),
   mType(type)
 {
+  addInputPort("input");
 }
 
 UnaryFunction::~UnaryFunction(void)
 {
 }
 
-ModelContext*
-UnaryFunction::newModelContext(PortValueList& portValueList) const
-{
-  return UnaryModel::newModelContext(this, portValueList);
-}
-
 void
-UnaryFunction::output(const Matrix& inputValue, Matrix& outputValue) const
+UnaryFunction::output(Context& context) const
 {
   // FIXME, optimize, move that into a proper context ...
   // For now make it work
-  Size sz = size(inputValue);
+  Size sz = size(context.getInputValue(0));
   for (unsigned j = 0; j < sz(1); ++j) {
     for (unsigned i = 0; i < sz(0); ++i) {
       switch (mType) {
       case Abs:
-        outputValue(i, j) = fabs(inputValue(i, j));
+        context.getOutputValue()(i, j) = fabs(context.getInputValue(0)(i, j));
         break;
       case Acos:
-        outputValue(i, j) = acos(inputValue(i, j));
+        context.getOutputValue()(i, j) = acos(context.getInputValue(0)(i, j));
         break;
       case Asin:
-        outputValue(i, j) = asin(inputValue(i, j));
+        context.getOutputValue()(i, j) = asin(context.getInputValue(0)(i, j));
         break;
       case Atan:
-        outputValue(i, j) = atan(inputValue(i, j));
+        context.getOutputValue()(i, j) = atan(context.getInputValue(0)(i, j));
         break;
       case Ceil:
-        outputValue(i, j) = ceil(inputValue(i, j));
+        context.getOutputValue()(i, j) = ceil(context.getInputValue(0)(i, j));
         break;
       case Cos:
-        outputValue(i, j) = cos(inputValue(i, j));
+        context.getOutputValue()(i, j) = cos(context.getInputValue(0)(i, j));
         break;
       case Exp:
-        outputValue(i, j) = exp(inputValue(i, j));
+        context.getOutputValue()(i, j) = exp(context.getInputValue(0)(i, j));
         break;
       case Floor:
-        outputValue(i, j) = floor(inputValue(i, j));
+        context.getOutputValue()(i, j) = floor(context.getInputValue(0)(i, j));
         break;
       case Log:
-        outputValue(i, j) = log(inputValue(i, j));
+        context.getOutputValue()(i, j) = log(context.getInputValue(0)(i, j));
         break;
       case Log10:
-        outputValue(i, j) = log10(inputValue(i, j));
+        context.getOutputValue()(i, j) = log10(context.getInputValue(0)(i, j));
         break;
       case Minus:
-        outputValue(i, j) = -inputValue(i, j);
+        context.getOutputValue()(i, j) = -context.getInputValue(0)(i, j);
         break;
       case Sin:
-        outputValue(i, j) = sin(inputValue(i, j));
+        context.getOutputValue()(i, j) = sin(context.getInputValue(0)(i, j));
         break;
       case Sqr:
-        outputValue(i, j) = inputValue(i, j)*inputValue(i, j);
+        context.getOutputValue()(i, j)
+          = context.getInputValue(0)(i, j)*context.getInputValue(0)(i, j);
         break;
       case Sqrt:
-        outputValue(i, j) = sqrt(inputValue(i, j));
+        context.getOutputValue()(i, j) = sqrt(context.getInputValue(0)(i, j));
         break;
       case Tan:
-        outputValue(i, j) = tan(inputValue(i, j));
+        context.getOutputValue()(i, j) = tan(context.getInputValue(0)(i, j));
         break;
       default:
-        outputValue(i, j) = inputValue(i, j);
+        context.getOutputValue()(i, j) = context.getInputValue(0)(i, j);
         break;
       }
     }

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/UnaryFunction.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/UnaryFunction.h	2008-11-30 09:14:30 UTC (rev 819)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/UnaryFunction.h	2008-11-30 09:40:03 UTC (rev 820)
@@ -6,13 +6,13 @@
 #define OpenFDM_UnaryFunction_H
 
 #include <string>
-#include "UnaryModel.h"
+#include "SimpleDirectModel.h"
 
 namespace OpenFDM {
 
 /// Class representing a model with exactly one input.
-class UnaryFunction : public UnaryModel {
-  OPENFDM_OBJECT(UnaryFunction, UnaryModel);
+class UnaryFunction : public SimpleDirectModel {
+  OPENFDM_OBJECT(UnaryFunction, SimpleDirectModel);
 public:
   enum Type {
     Abs,
@@ -35,8 +35,7 @@
   UnaryFunction(const std::string& name, const Type& type);
   virtual ~UnaryFunction(void);
 
-  ModelContext* newModelContext(PortValueList&) const;
-  void output(const Matrix& inputValue, Matrix& outputValue) const;
+  void output(Context& context) const;
 
   void setType(const Type& type);
   const Type& getType(void) const;

Deleted: branches/OpenFDM-StateSeparation/src/OpenFDM/UnaryModel.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/UnaryModel.cpp	2008-11-30 09:14:30 UTC (rev 819)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/UnaryModel.cpp	2008-11-30 09:40:03 UTC (rev 820)
@@ -1,25 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
- *
- */
-
-#include "UnaryModel.h"
-
-#include "LogStream.h"
-
-namespace OpenFDM {
-
-BEGIN_OPENFDM_OBJECT_DEF(UnaryModel, AbstractModel)
-  END_OPENFDM_OBJECT_DEF
-
-UnaryModel::UnaryModel(const std::string& name) :
-  AbstractModel(name),
-  mInputPort(new InputPortInfo(this, "input", Size(0, 0), true)),
-  mOutputPort(new OutputPortInfo(this, "output", Size(0, 0), false))
-{
-}
-
-UnaryModel::~UnaryModel()
-{
-}
-
-} // namespace OpenFDM

Deleted: branches/OpenFDM-StateSeparation/src/OpenFDM/UnaryModel.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/UnaryModel.h	2008-11-30 09:14:30 UTC (rev 819)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/UnaryModel.h	2008-11-30 09:40:03 UTC (rev 820)
@@ -1,99 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
- *
- */
-
-#ifndef OpenFDM_UnaryModel_H
-#define OpenFDM_UnaryModel_H
-
-#include <string>
-
-#include "AbstractModel.h"
-#include "ModelContext.h"
-
-namespace OpenFDM {
-
-class UnaryModel : public AbstractModel {
-  OPENFDM_OBJECT(UnaryModel, AbstractModel);
-public:
-  UnaryModel(const std::string& name);
-  virtual ~UnaryModel();
-
-protected:
-  template<typename UM>
-  ModelContext* newModelContext(UM* um, PortValueList& portValueList) const
-  {
-    Size sz = size(portValueList.getPortValue(mInputPort)->getValue());
-    Log(Initialization, Debug)
-      << "Size for Model \"" << getName()
-      << "\" is detemined by the input port with size: "
-      << trans(sz) << std::endl;
-    if (!portValueList.setOrCheckPortSize(mOutputPort, sz)) {
-      Log(Initialization, Warning)
-        << "Size for output port from Model \"" << getName()
-        << "\" does not match!" << std::endl;
-      return 0;
-    }
-
-    SharedPtr<Context<UM> > context;
-    context = new Context<UM>(um, portValueList.getPortValue(mInputPort),
-                              portValueList.getPortValue(mOutputPort));
-    for (unsigned i = 0; i < getNumPorts(); ++i) {
-      PortValue* portValue = portValueList.getPortValue(i);
-      if (!portValue) {
-        Log(Model, Error) << "No port value given for model \"" << getName()
-                          << "\" and port \"" << getPort(i)->getName()
-                          << "\"" << endl;
-        return 0;
-      }
-      context->setPortValue(*getPort(i), portValue);
-    }
-    if (!context->allocStates()) {
-      Log(Model, Warning) << "Could not alloc for model \""
-                          << getName() << "\"" << endl;
-      return 0;
-    }
-    return context.release();
-  }
-
-  template<typename UM>
-  class Context : public ModelContext {
-  public:
-    Context(const UM* unaryModel, const NumericPortValue* inputValue,
-            NumericPortValue* outputValue) :
-      mUnaryModel(unaryModel),
-      mInputValue(inputValue),
-      mOutputValue(outputValue)
-    { }
-    virtual ~Context()
-    { }
-    
-    virtual const UM& getNode() const
-    { return *mUnaryModel; }
-    
-    virtual void initOutput(const /*Init*/Task&)
-    { mUnaryModel->output(mInputValue->getValue(), mOutputValue->getValue()); }
-    virtual void output(const Task&)
-    { mUnaryModel->output(mInputValue->getValue(), mOutputValue->getValue()); }
-    virtual void update(const DiscreteTask&)
-    { }
-    virtual void derivative(const Task&)
-    { }
-    
-  private:
-    Context();
-    Context(const Context&);
-    Context& operator=(const Context&);
-    
-    SharedPtr<const UM> mUnaryModel;
-    SharedPtr<const NumericPortValue> mInputValue;
-    SharedPtr<NumericPortValue> mOutputValue;
-  };
-
-private:
-  SharedPtr<InputPortInfo> mInputPort;
-  SharedPtr<OutputPortInfo> mOutputPort;
-};
-
-} // namespace OpenFDM
-
-#endif

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/UnitConversion.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/UnitConversion.cpp	2008-11-30 09:14:30 UTC (rev 819)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/UnitConversion.cpp	2008-11-30 09:40:03 UTC (rev 820)
@@ -6,34 +6,29 @@
 
 namespace OpenFDM {
 
-BEGIN_OPENFDM_OBJECT_DEF(UnitConversion, UnaryModel)
+BEGIN_OPENFDM_OBJECT_DEF(UnitConversion, SimpleDirectModel)
   END_OPENFDM_OBJECT_DEF
 
 UnitConversion::UnitConversion(const std::string& name, const Type& type,
                                const Unit& unit) :
-  UnaryModel(name),
+  SimpleDirectModel(name),
   mType(type),
   mUnit(unit)
 {
+  addInputPort("input");
 }
 
 UnitConversion::~UnitConversion(void)
 {
 }
 
-ModelContext*
-UnitConversion::newModelContext(PortValueList& portValueList) const
-{
-  return UnaryModel::newModelContext(this, portValueList);
-}
-
 void
-UnitConversion::output(const Matrix& inputValue, Matrix& outputValue) const
+UnitConversion::output(Context& context) const
 {
   if (mType == UnitToBaseUnit) {
-    outputValue = mUnit.convertFrom(inputValue);
+    context.getOutputValue() = mUnit.convertFrom(context.getInputValue(0));
   } else {
-    outputValue = mUnit.convertTo(inputValue);
+    context.getOutputValue() = mUnit.convertTo(context.getInputValue(0));
   }
 }
 

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/UnitConversion.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/UnitConversion.h	2008-11-30 09:14:30 UTC (rev 819)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/UnitConversion.h	2008-11-30 09:40:03 UTC (rev 820)
@@ -8,12 +8,12 @@
 #include <string>
 
 #include "Unit.h"
-#include "UnaryModel.h"
+#include "SimpleDirectModel.h"
 
 namespace OpenFDM {
 
-class UnitConversion : public UnaryModel {
-  OPENFDM_OBJECT(UnitConversion, UnaryModel);
+class UnitConversion : public SimpleDirectModel {
+  OPENFDM_OBJECT(UnitConversion, SimpleDirectModel);
 public:
   enum Type {
     UnitToBaseUnit,
@@ -23,8 +23,7 @@
   UnitConversion(const std::string& name, const Type& type, const Unit& unit);
   virtual ~UnitConversion(void);
 
-  ModelContext* newModelContext(PortValueList&) const;
-  void output(const Matrix& inputValue, Matrix& outputValue) const;
+  void output(Context& context) const;
 
   void setType(const Type& type);
   const Type& getType(void) const;



From frohlich at mail.berlios.de  Sun Nov 30 11:39:38 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 30 Nov 2008 11:39:38 +0100
Subject: [OpenFDM-svn] r821 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811301039.mAUAdcmM025562@sheep.berlios.de>

Author: frohlich
Date: 2008-11-30 11:39:38 +0100 (Sun, 30 Nov 2008)
New Revision: 821

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
   branches/OpenFDM-StateSeparation/src/OpenFDM/TimeDerivative.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/TimeDerivative.h
Log:
Readd the TimeDerivative model.

M    src/OpenFDM/Makefile.am
M    src/OpenFDM/TimeDerivative.cpp
M    src/OpenFDM/TimeDerivative.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-11-30 09:40:03 UTC (rev 820)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-11-30 10:39:38 UTC (rev 821)
@@ -265,11 +265,11 @@
   SimulationTime.cpp \
   Summer.cpp \
   Table.cpp \
+  TimeDerivative.cpp \
   UnaryFunction.cpp \
   UnitConversion.cpp
 
 #   DiscBrake.cpp \
-#   TimeDerivative.cpp \
 #   TransferFunction.cpp \
 #
 

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/TimeDerivative.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/TimeDerivative.cpp	2008-11-30 09:40:03 UTC (rev 820)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/TimeDerivative.cpp	2008-11-30 10:39:38 UTC (rev 821)
@@ -5,6 +5,7 @@
 #include "TimeDerivative.h"
 
 #include "Assert.h"
+#include "Task.h"
 
 namespace OpenFDM {
 
@@ -12,13 +13,16 @@
   END_OPENFDM_OBJECT_DEF
 
 TimeDerivative::TimeDerivative(const std::string& name) :
-  Model(name)
+  Model(name),
+  mInputPort(newMatrixInputPort("input", false)),
+  mOutputPort(newMatrixOutputPort("output"))
 {
-  setDirectFeedThrough(true);
-  setNumInputPorts(1);
-
-  setNumOutputPorts(1);
-  setOutputPort(0, "output", this, &TimeDerivative::getDerivativeOutput);
+  mDerivativeStateInfo = new MatrixStateInfo;
+  addDiscreteStateInfo(mDerivativeStateInfo);
+  mOldValueStateInfo = new MatrixStateInfo;
+  addDiscreteStateInfo(mOldValueStateInfo);
+  mOldTStateInfo = new MatrixStateInfo;
+  addDiscreteStateInfo(mOldTStateInfo);
 }
 
 TimeDerivative::~TimeDerivative(void)
@@ -26,57 +30,82 @@
 }
 
 bool
-TimeDerivative::init(void)
+TimeDerivative::alloc(ModelContext& leafContext) const
 {
-  mInputPort = getInputPort(0)->toMatrixPortHandle();
-  if (!mInputPort.isConnected()) {
-    Log(Model, Error) << "Initialization of TimeDerivative model \""
-                      << getName()
-                      << "\" failed: Input port \"" << getInputPortName(0)
-                      << "\" is not connected!" << endl;
+  Size sz = size(leafContext.getPortValueList()[mInputPort]);
+  Log(Initialization, Debug)
+    << "Size for Integrator is detemined by the initial input "
+    << "port with size: " << trans(sz) << std::endl;
+  if (!leafContext.getPortValueList().setOrCheckPortSize(mOutputPort, sz)) {
+    Log(Initialization, Error)
+      << "Size for input port does not match!" << std::endl;
     return false;
   }
+  return true;
+}
 
-  mDerivativeOutput.resize(mInputPort.getMatrixValue());
-
-  // Set a mark for the first step.
-  mDt = 0.0;
-
-  return Model::init();
+void
+TimeDerivative::init(const Task& task, DiscreteStateValueVector& discreteState,
+                     ContinousStateValueVector&,
+                     const PortValueList& portValues) const
+{
+  Size sz = size(portValues[mInputPort]);
+  discreteState[*mDerivativeStateInfo].resize(sz(0), sz(1));
+  discreteState[*mDerivativeStateInfo].clear();
+  discreteState[*mOldValueStateInfo].resize(sz(0), sz(1));
+  discreteState[*mOldValueStateInfo] = portValues[mInputPort];
+  discreteState[*mOldTStateInfo].resize(1, 1);
+  discreteState[*mOldTStateInfo](0, 0) = task.getTime();
 }
 
 void
-TimeDerivative::output(const TaskInfo&)
+TimeDerivative::output(const Task& task,
+                       const DiscreteStateValueVector& discreteState,
+                       const ContinousStateValueVector&,
+                       PortValueList& portValues) const
 {
-  // If we are here at the first time, dt is set to zero.
-  // So, computing a derivative is not possible in the first step.
-  // Prepare zero output in this case.
-  if (mDt != 0.0) {
-    OpenFDMAssert(size(mInputPort.getMatrixValue()) == size(mPastInput));
-    if (size(mInputPort.getMatrixValue()) == size(mPastInput)) {
-      mDerivativeOutput = mInputPort.getMatrixValue() - mPastInput;
-      mDerivativeOutput *= 1/mDt;
+  real_type tOld = discreteState[*mOldTStateInfo](0, 0);
+  real_type dt = task.getTime() - tOld;
+  real_type dtMin = sqrt(Limits<real_type>::epsilon());
+  if (dt < dtMin) {
+    // For times very near at tOld, just use the old derivative
+    portValues[mOutputPort] = discreteState[*mDerivativeStateInfo];
+  } else {
+    // The numerical derivative
+    Matrix deriv = portValues[mInputPort] - discreteState[*mOldValueStateInfo];
+    deriv *= 1/dt;
+
+    if (dt < 2*dtMin) {
+      // For times where numerical derivative starts having a value beyond
+      // roundoff interpolate between the old and the numerical derivative
+      portValues[mOutputPort]
+        = interpolate(dt, dtMin, discreteState[*mDerivativeStateInfo],
+                      2*dtMin, deriv);
+    } else {
+      // For times where numerical derivative provides valid values use the
+      // numerical derivative
+      portValues[mOutputPort] = deriv;
     }
-  } else {
-    mDerivativeOutput.resize(mInputPort.getMatrixValue());
-    mDerivativeOutput.clear();
   }
 }
 
 void
-TimeDerivative::update(const TaskInfo& taskInfo)
+TimeDerivative::update(const DiscreteTask& discreteTask,
+                       DiscreteStateValueVector& discreteState,
+                       const ContinousStateValueVector&,
+                       const PortValueList& portValues) const
 {
-  // FIXME
-  real_type dt = (*taskInfo.getSampleTimeSet().begin()).getSampleTime();
-  // Updating is just storing required information for the next output step.
-  mPastInput = mInputPort.getMatrixValue();
-  mDt = dt;
-}
+  // Just compute the derivative.
+  real_type tOld = discreteState[*mOldTStateInfo](0, 0);
+  real_type dt = discreteTask.getTime() - tOld;
+  if (Limits<real_type>::safe_min() < fabs(dt)) {
+    discreteState[*mDerivativeStateInfo]
+      = (1/dt)*(portValues[mInputPort] - discreteState[*mOldValueStateInfo]);
+  }
 
-const Matrix&
-TimeDerivative::getDerivativeOutput(void) const
-{
-  return mDerivativeOutput;
+  // Store the old value and this current stepsize
+  discreteState[*mOldValueStateInfo] = portValues[mInputPort];
+  discreteState[*mOldTStateInfo](0, 0) = discreteTask.getTime();
 }
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/TimeDerivative.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/TimeDerivative.h	2008-11-30 09:40:03 UTC (rev 820)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/TimeDerivative.h	2008-11-30 10:39:38 UTC (rev 821)
@@ -7,6 +7,7 @@
 
 #include "Types.h"
 #include "Model.h"
+#include "TemplateDiscreteStateInfo.h"
 
 namespace OpenFDM {
 
@@ -16,20 +17,24 @@
   TimeDerivative(const std::string& name);
   virtual ~TimeDerivative(void);
 
-  virtual bool init(void);
-  virtual void output(const TaskInfo&);
-  virtual void update(const TaskInfo& taskInfo);
+  virtual bool alloc(ModelContext&) const;
+  virtual void init(const Task&,DiscreteStateValueVector& discreteState,
+                    ContinousStateValueVector&, const PortValueList&) const;
+  virtual void output(const Task&,const DiscreteStateValueVector& discreteState,
+                      const ContinousStateValueVector&,
+                      PortValueList& portValues) const;
+  virtual void update(const DiscreteTask&, DiscreteStateValueVector&,
+                      const ContinousStateValueVector&,
+                      const PortValueList&) const;
 
-  const Matrix& getDerivativeOutput(void) const;
-
 private:
-  /// Holds the current output.
-  Matrix mDerivativeOutput;
-  Matrix mPastInput;
-  double mDt;
+  typedef TemplateDiscreteStateInfo<Matrix> MatrixStateInfo;
 
-  /// The input port handle
-  MatrixPortHandle mInputPort;
+  MatrixInputPort mInputPort;
+  MatrixOutputPort mOutputPort;
+  SharedPtr<MatrixStateInfo> mDerivativeStateInfo;
+  SharedPtr<MatrixStateInfo> mOldValueStateInfo;
+  SharedPtr<MatrixStateInfo> mOldTStateInfo;
 };
 
 } // namespace OpenFDM



From frohlich at mail.berlios.de  Sun Nov 30 12:11:47 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 30 Nov 2008 12:11:47 +0100
Subject: [OpenFDM-svn] r822 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811301111.mAUBBlMI028382@sheep.berlios.de>

Author: frohlich
Date: 2008-11-30 12:11:46 +0100 (Sun, 30 Nov 2008)
New Revision: 822

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/DiscBrake.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/DiscBrake.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
Log:
Reactivate DiscBrake

M    src/OpenFDM/DiscBrake.cpp
M    src/OpenFDM/Makefile.am
M    src/OpenFDM/DiscBrake.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/DiscBrake.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/DiscBrake.cpp	2008-11-30 10:39:38 UTC (rev 821)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/DiscBrake.cpp	2008-11-30 11:11:46 UTC (rev 822)
@@ -16,96 +16,61 @@
 DiscBrake::DiscBrake(const std::string& name) :
   Model(name),
   mMinForce(0),
-  mMaxForce(1)
+  mMaxForce(1),
+  mSigma(100),
+  mZStateInfo(new Vector1StateInfo),
+  mBrakeInputPort(this, "brakeInput", true),
+  mVelocityPort(this, "velocity", true),
+  mForcePort(this, "force")
 {
-  setDirectFeedThrough(true);
-
-  setNumContinousStates(1);
-
-  setNumInputPorts(2);
-  setInputPortName(0, "brakePressure");
-  setInputPortName(1, "velocity");
-  
-  setNumOutputPorts(1);
-  setOutputPort(0, "force", this, &DiscBrake::getForce);
+  addContinousStateInfo(mZStateInfo);
 }
 
 DiscBrake::~DiscBrake(void)
 {
 }
 
-bool
-DiscBrake::init(void)
+void
+DiscBrake::init(const Task&, DiscreteStateValueVector&,
+                ContinousStateValueVector& state, const PortValueList&) const
 {
-  mBrakePressurePort = getInputPort(0)->toRealPortHandle();
-  if (!mBrakePressurePort.isConnected()) {
-    Log(Model, Error) << "Initialization of DiscBrake model \"" << getName()
-                      << "\" failed: Input port \"" << getInputPortName(0)
-                      << "\" is not connected!" << endl;
-    return false;
-  }
+  state[*mZStateInfo](0, 0) = 0;
+}
 
-  mVelocityPort = getInputPort(1)->toRealPortHandle();
-  if (!mVelocityPort.isConnected()) {
-    Log(Model, Error) << "Initialization of DiscBrake model \"" << getName()
-                      << "\" failed: Input port \"" << getInputPortName(1)
-                      << "\" is not connected!" << endl;
-    return false;
-  }
-
-  // start with zero friction force
-  mZ = 0;
-
-  return Model::init();
+void
+DiscBrake::output(const Task&, const DiscreteStateValueVector&,
+                  const ContinousStateValueVector& state,
+                  PortValueList& portValues) const
+{
+  real_type brakeInput = portValues[mBrakeInputPort];
+  real_type z = state[*mZStateInfo](0, 0);
+  // now the output force, modulate with the brake input
+  portValues[mForcePort] = -interpolate(brakeInput, real_type(0), mMinForce,
+                                        real_type(1), mMaxForce)*mSigma*z;
 }
 
 void
-DiscBrake::output(const TaskInfo& taskInfo)
+DiscBrake::derivative(const DiscreteStateValueVector&,
+                      const ContinousStateValueVector& state,
+                      const PortValueList& portValues,
+                      ContinousStateValueVector& deriv) const
 {
-  real_type sigma = 100;
-  real_type brakeInput = mBrakePressurePort.getRealValue();
-  real_type vel = mVelocityPort.getRealValue();
-  // with this sigma the model is already very crisp and reaches the
+  real_type z = state[*mZStateInfo](0, 0);
+  real_type vel = portValues[mVelocityPort];
+  // with this mSigma the model is already very crisp and reaches the
   // maximum force relatively fast, thus we do not need to make it even faster
   // with higher speeds
 //   vel = saturate(vel, real_type(1));
   vel = smoothSaturate(vel, real_type(1));
   // the time derivative of the friction state
-  mZDeriv = vel - sigma*fabs(vel)*mZ;
+  real_type zDeriv = vel - mSigma*fabs(vel)*z;
   // this is to limit the stiffness of this model
-//   mZDeriv = saturate(mZDeriv, real_type(10));
-  mZDeriv = smoothSaturate(mZDeriv, real_type(10));
-  // now the output force, modulate with the brake input
-  mForce = -interpolate(brakeInput,
-                        real_type(0), mMinForce,
-                        real_type(1), mMaxForce)*sigma*mZ;
+//   zDeriv = saturate(zDeriv, real_type(10));
+  zDeriv = smoothSaturate(zDeriv, real_type(10));
+  deriv[*mZStateInfo](0, 0) = zDeriv;
 }
 
-void
-DiscBrake::setState(const StateStream& state)
-{
-  state.readSubState(mZ);
-}
-
-void
-DiscBrake::getState(StateStream& state) const
-{
-  state.writeSubState(mZ);
-}
-
-void
-DiscBrake::getStateDeriv(StateStream& stateDeriv)
-{
-  stateDeriv.writeSubState(mZDeriv);
-}
-
 const real_type&
-DiscBrake::getForce(void) const
-{
-  return mForce;
-}
-
-const real_type&
 DiscBrake::getMinForce(void) const
 {
   return mMinForce;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/DiscBrake.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/DiscBrake.h	2008-11-30 10:39:38 UTC (rev 821)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/DiscBrake.h	2008-11-30 11:11:46 UTC (rev 822)
@@ -19,37 +19,42 @@
   DiscBrake(const std::string& name);
   virtual ~DiscBrake(void);
 
-  virtual bool init(void);
-  virtual void output(const TaskInfo& taskInfo);
+  virtual void init(const Task&,DiscreteStateValueVector&,
+                    ContinousStateValueVector&, const PortValueList&) const;
+  virtual void output(const Task&, const DiscreteStateValueVector&,
+                      const ContinousStateValueVector&,
+                      PortValueList& portValues) const;
+  virtual void derivative(const DiscreteStateValueVector&,
+                          const ContinousStateValueVector&,
+                          const PortValueList&,
+                          ContinousStateValueVector&) const;
 
-  virtual void setState(const StateStream& state);
-  virtual void getState(StateStream& state) const;
-  virtual void getStateDeriv(StateStream& stateDeriv);
-
-  const real_type& getForce(void) const;
-
   const real_type& getMinForce(void) const;
   void setMinForce(const real_type& minForce);
 
   const real_type& getMaxForce(void) const;
   void setMaxForce(const real_type& maxForce);
 
+  const real_type& getSigma(void) const;
+  void setSigma(const real_type& sigma);
+
 private:
-  /// The output brake force
-  real_type mForce;
-  /// The frictions state
-  real_type mZ;
-  /// The frictions stes derivative
-  real_type mZDeriv;
   /// The maximum force when brakes are applied
   real_type mMaxForce;
   /// The maximum force when brakes are not applied
   real_type mMinForce;
+  /// The stiffness of the friction model
+  real_type mSigma;
 
-  /// The intput port which must provide the position
-  RealPortHandle mBrakePressurePort;
-  /// The intput port which must provide the velocity
-  RealPortHandle mVelocityPort;
+  // State of this model
+  SharedPtr<Vector1StateInfo> mZStateInfo;
+
+  /// The input port which must provide brake input
+  RealInputPort mBrakeInputPort;
+  /// The input port which must provide the velocity
+  RealInputPort mVelocityPort;
+  /// The resulting force output
+  RealOutputPort mForcePort;
 };
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-11-30 10:39:38 UTC (rev 821)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-11-30 11:11:46 UTC (rev 822)
@@ -251,6 +251,7 @@
   ConstModel.cpp \
   DeadBand.cpp \
   Delay.cpp \
+  DiscBrake.cpp \
   DiscreteIntegrator.cpp \
   Gain.cpp \
   Input.cpp \
@@ -269,7 +270,6 @@
   UnaryFunction.cpp \
   UnitConversion.cpp
 
-#   DiscBrake.cpp \
 #   TransferFunction.cpp \
 #
 
@@ -289,12 +289,13 @@
 #   Contact.cpp \
 #   ExternalForceModel.cpp \
 #   Force.cpp \
-#   Launchbar.cpp \
 #   SimpleContact.cpp \
 #   SimpleGear.cpp \
-#   Tailhook.cpp \
 #   Tank.cpp \
 #   WheelContact.cpp
+
+#   Launchbar.cpp \
+#   Tailhook.cpp \
 #
 
 nobase_OpenFDMinclude_HEADERS = $(OpenFDMCoreHEADERS) $(OpenFDMModelsHEADERS)



From frohlich at mail.berlios.de  Sun Nov 30 21:50:11 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 30 Nov 2008 21:50:11 +0100
Subject: [OpenFDM-svn] r823 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200811302050.mAUKoB8W030705@sheep.berlios.de>

Author: frohlich
Date: 2008-11-30 21:50:10 +0100 (Sun, 30 Nov 2008)
New Revision: 823

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Group.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Group.h
Log:
Remove the extra Child object in the Group.

M    src/OpenFDM/Group.h
M    src/OpenFDM/Group.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Group.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Group.cpp	2008-11-30 11:11:46 UTC (rev 822)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Group.cpp	2008-11-30 20:50:10 UTC (rev 823)
@@ -36,14 +36,14 @@
 {
   ChildList::const_iterator i;
   for (i = _childList.begin(); i != _childList.end(); ++i)
-    (*i)->node->accept(visitor);
+    (*i)->accept(visitor);
 }
 
 void Group::traverse(ConstNodeVisitor& visitor) const
 {
   ChildList::const_iterator i;
   for (i = _childList.begin(); i != _childList.end(); ++i)
-    (*i)->node->accept(visitor);
+    (*i)->accept(visitor);
 }
 
 Group::NodeId
@@ -53,8 +53,8 @@
     return NodeId();
   if (!node->addParent(this))
     return NodeId();
-  _childList.push_back(new Child(this, node));
-  return NodeId(_childList.back());
+  _childList.push_back(node);
+  return node.get();
 }
 
 unsigned
@@ -66,13 +66,8 @@
 unsigned
 Group::getChildNumber(const NodeId& nodeId) const
 {
-  SharedPtr<Child> child = nodeId._child.lock();
-  if (!child)
-    return ~0u;
-  if (child->group.lock() != this)
-    return ~0u;
   ChildList::const_iterator i;
-  i = std::find(_childList.begin(), _childList.end(), child);
+  i = std::find(_childList.begin(), _childList.end(), nodeId);
   if (i == _childList.end())
     return ~0u;
   return std::distance(_childList.begin(), i);
@@ -83,7 +78,7 @@
 {
   if (_childList.size() <= i)
     return 0;
-  return _childList[i]->node;
+  return _childList[i];
 }
 
 SharedPtr<const Node>
@@ -91,32 +86,19 @@
 {
   if (_childList.size() <= i)
     return 0;
-  return _childList[i]->node;
+  return _childList[i];
 }
 
 SharedPtr<Node>
 Group::getChild(const NodeId& nodeId)
 {
-  SharedPtr<Child> child = nodeId._child.lock();
-  if (!child)
-    return 0;
-  // Check if it belongs to this current group
-  if (child->group.lock() != this)
-    return 0;
-  return child->node;
+  return getChild(getChildNumber(nodeId));
 }
 
 SharedPtr<const Node>
 Group::getChild(const NodeId& nodeId) const
 {
-  SharedPtr<Child> child = nodeId._child.lock();
-  if (!child)
-    return 0;
-  // Check if it belongs to this current group
-  SharedPtr<Group> group = child->group.lock();
-  if (group != this)
-    return 0;
-  return child->node;
+  return getChild(getChildNumber(nodeId));
 }
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Group.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Group.h	2008-11-30 11:11:46 UTC (rev 822)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Group.h	2008-11-30 20:50:10 UTC (rev 823)
@@ -18,7 +18,7 @@
 class Group : public Node {
   OPENFDM_OBJECT(Group, Node);
 public:
-  class NodeId;
+  typedef const Node* NodeId;
 
   Group(const std::string& name);
   virtual ~Group();
@@ -36,12 +36,12 @@
 
   bool connect(const NodeId& nodeId0, const std::string& portName0,
                const NodeId& nodeId1, const std::string& portName1)
-  { return connect(nodeId0, nodeId0.getPortId(portName0),
-                   nodeId1, nodeId1.getPortId(portName1)); }
+  { return connect(nodeId0, PortId(nodeId0->getPort(portName0)),
+                   nodeId1, PortId(nodeId1->getPort(portName1))); }
   bool connect(const NodeId& nodeId0, unsigned portNum0,
                const NodeId& nodeId1, unsigned portNum1)
-  { return connect(nodeId0, nodeId0.getPortId(portNum0),
-                   nodeId1, nodeId1.getPortId(portNum1)); }
+  { return connect(nodeId0, PortId(nodeId0->getPort(portNum0)),
+                   nodeId1, PortId(nodeId1->getPort(portNum1))); }
 
   bool connect(const NodeId& nodeId0, const PortId& portId0,
                const NodeId& nodeId1, const PortId& portId1)
@@ -75,7 +75,6 @@
     return true;
   }
 
-
   unsigned getNumConnects() const
   { return _connectList.size(); }
 
@@ -113,57 +112,7 @@
   unsigned getChildNumber(const NodeId& nodeId) const;
   SharedPtr<Node> getChild(const NodeId& nodeId);
   SharedPtr<const Node> getChild(const NodeId& nodeId) const;
-  class Child;
-public:
-  class NodeId {
-    // FIXME a node ID has an associated name and that is unique. That should
-    // be the blocks name where it can be referenced. May be the NodeId should
-    // just contain that string??
-    // A serialized group can refere these names.
-    // May be the same should happen with portid's???
-    //
-    // Remove the name from the Object.
-    // Store Connects as seperate objects
-  public:
-    NodeId() {}
-    PortId getPortId(unsigned i) const
-    {
-      SharedPtr<Child> child = _child.lock();
-      if (!child)
-        return PortId();
-      SharedPtr<Node> node = child->node;
-      if (!node)
-        return PortId();
-      return node->getPortId(i);
-    }
-    PortId getPortId(const std::string& name) const
-    {
-      SharedPtr<Child> child = _child.lock();
-      if (!child)
-        return PortId();
-      SharedPtr<Node> node = child->node;
-      if (!node)
-        return PortId();
-      return node->getPortId(name);
-    }
 
-  private:
-    friend class Group;
-    NodeId(const SharedPtr<Child>& child) : _child(child) {}
-    WeakPtr<Child> _child;
-  };
-
-private:
-
-  struct Child : public WeakReferenced {
-    Child(Group* _group, Node* _node) :
-      group(_group), node(_node)
-    { }
-    WeakPtr<Group> group;
-    SharedPtr<Node> node;
-    // name extension to make name uniqe?
-  };
-
   struct Connect : public WeakReferenced {
     NodeId _nodeId0;
     PortId _portId0;
@@ -178,7 +127,7 @@
   typedef std::vector<SharedPtr<Connect> > ConnectList;
   ConnectList _connectList;
 
-  typedef std::vector<SharedPtr<Child> > ChildList;
+  typedef std::vector<SharedPtr<Node> > ChildList;
   ChildList _childList;
 };
 



