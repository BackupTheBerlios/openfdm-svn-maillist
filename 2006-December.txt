From frohlich at mail.berlios.de  Wed Dec 13 19:50:58 2006
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Wed, 13 Dec 2006 19:50:58 +0100
Subject: [OpenFDM-svn] r299 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200612131850.kBDIowSj021919@sheep.berlios.de>

Author: frohlich
Date: 2006-12-13 19:50:57 +0100 (Wed, 13 Dec 2006)
New Revision: 299

Added:
   trunk/OpenFDM/src/OpenFDM/Atomic.cpp
Modified:
   trunk/OpenFDM/src/OpenFDM/Atomic.h
   trunk/OpenFDM/src/OpenFDM/Makefile.am
Log:
Make it work without -march= on i386


Added: trunk/OpenFDM/src/OpenFDM/Atomic.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Atomic.cpp	2006-11-10 05:36:02 UTC (rev 298)
+++ trunk/OpenFDM/src/OpenFDM/Atomic.cpp	2006-12-13 18:50:57 UTC (rev 299)
@@ -0,0 +1,47 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2006 Mathias Froehlich 
+ *
+ */
+
+#include "Atomic.h"
+
+#if defined(OpenFDM_USE_GCC4_BUILTINS) && defined(__i386__)
+
+// Usually the apropriate functions are inlined by gcc.
+// But if gcc is called with something aequivalent to -march=i386,
+// it will not assume that there is a lock instruction and instead
+// calls this pair of functions. We will provide them here in this case.
+// Note that this assembler code will not work on a i386 chip anymore.
+// But I hardly believe that we can assume to run at least on a i486 ...
+
+extern "C" {
+
+unsigned __sync_sub_and_fetch_4(volatile void *ptr, unsigned value)
+{
+  register volatile unsigned* mem = reinterpret_cast<volatile unsigned*>(ptr);
+  register unsigned result;
+  __asm__ __volatile__("lock; xadd{l} {%0,%1|%1,%0}"
+                       : "=r" (result), "=m" (*mem)
+                       : "0" (-value), "m" (*mem)
+                       : "memory");
+  return result;
+}
+
+unsigned __sync_add_and_fetch_4(volatile void *ptr, unsigned value)
+{
+  register volatile unsigned* mem = reinterpret_cast<volatile unsigned*>(ptr);
+  register unsigned result;
+  __asm__ __volatile__("lock; xadd{l} {%0,%1|%1,%0}"
+                       : "=r" (result), "=m" (*mem)
+                       : "0" (value), "m" (*mem)
+                       : "memory");
+  return result;
+}
+
+void __sync_synchronize()
+{
+  __asm__ __volatile__("": : : "memory");
+}
+
+} // extern "C"
+
+#endif

Modified: trunk/OpenFDM/src/OpenFDM/Atomic.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Atomic.h	2006-11-10 05:36:02 UTC (rev 298)
+++ trunk/OpenFDM/src/OpenFDM/Atomic.h	2006-12-13 18:50:57 UTC (rev 299)
@@ -5,7 +5,8 @@
 #ifndef OpenFDM_Atomic_H
 #define OpenFDM_Atomic_H
 
-#if defined(__GNUC__) && (4 <= __GNUC__) && (1 <= __GNUC_MINOR__)
+#if defined(__GNUC__) && (4 <= __GNUC__) && (1 <= __GNUC_MINOR__) \
+  && (defined(__i386__) || defined(__x86_64__))
 // No need to include something. Is a Compiler API ...
 # define OpenFDM_USE_GCC4_BUILTINS
 #elif defined(WIN32) || defined(_WIN32) || defined(__WIN32__)
@@ -63,9 +64,13 @@
   Atomic(const Atomic&);
   Atomic& operator=(const Atomic&);
 
-#if !defined(OpenFDM_USE_GCC4_BUILTINS) && !defined(OpenFDM_USE_WIN32_INTERLOCKED)
+#if !defined(OpenFDM_USE_GCC4_BUILTINS) \
+  && !defined(OpenFDM_USE_WIN32_INTERLOCKED)
   mutable Mutex mMutex;
 #endif
+#ifdef OpenFDM_USE_WIN32_INTERLOCKED
+  __declspec(align(32))
+#endif
   unsigned mValue;
 };
 

Modified: trunk/OpenFDM/src/OpenFDM/Makefile.am
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Makefile.am	2006-11-10 05:36:02 UTC (rev 298)
+++ trunk/OpenFDM/src/OpenFDM/Makefile.am	2006-12-13 18:50:57 UTC (rev 299)
@@ -151,6 +151,7 @@
   Assert.cpp \
   Atmosphere.cpp \
   AtmosphereSTD1976.cpp \
+  Atomic.cpp \
   Bias.cpp \
   BinaryFunctionModel.cpp \
   Connection.cpp \



From frohlich at mail.berlios.de  Wed Dec 13 19:51:44 2006
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Wed, 13 Dec 2006 19:51:44 +0100
Subject: [OpenFDM-svn] r300 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200612131851.kBDIpiHC021976@sheep.berlios.de>

Author: frohlich
Date: 2006-12-13 19:51:43 +0100 (Wed, 13 Dec 2006)
New Revision: 300

Modified:
   trunk/OpenFDM/src/OpenFDM/AeroForce.cpp
Log:
Move own header to the top.


Modified: trunk/OpenFDM/src/OpenFDM/AeroForce.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/AeroForce.cpp	2006-12-13 18:50:57 UTC (rev 299)
+++ trunk/OpenFDM/src/OpenFDM/AeroForce.cpp	2006-12-13 18:51:43 UTC (rev 300)
@@ -2,13 +2,13 @@
  *
  */
 
-#include "Assert.h"
+#include "AeroForce.h"
+
 #include "Object.h"
 #include "Vector.h"
 #include "Frame.h"
 #include "Force.h"
 #include "Atmosphere.h"
-#include "AeroForce.h"
 
 namespace OpenFDM {
 



From frohlich at mail.berlios.de  Wed Dec 13 20:49:52 2006
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Wed, 13 Dec 2006 20:49:52 +0100
Subject: [OpenFDM-svn] r302 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200612131949.kBDJnq4t027727@sheep.berlios.de>

Author: frohlich
Date: 2006-12-13 20:49:51 +0100 (Wed, 13 Dec 2006)
New Revision: 302

Modified:
   trunk/OpenFDM/src/OpenFDM/Output.cpp
Log:
Add missing dtor


Modified: trunk/OpenFDM/src/OpenFDM/Output.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Output.cpp	2006-12-13 19:38:29 UTC (rev 301)
+++ trunk/OpenFDM/src/OpenFDM/Output.cpp	2006-12-13 19:49:51 UTC (rev 302)
@@ -11,6 +11,10 @@
   DEF_OPENFDM_PROPERTY(String, OutputName, Serialized)
   END_OPENFDM_OBJECT_DEF
 
+Output::Callback::~Callback()
+{
+}
+
 Output::Output(const std::string& name) :
   Model(name),
   mOutputGain(1)



From frohlich at mail.berlios.de  Wed Dec 13 20:54:57 2006
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Wed, 13 Dec 2006 20:54:57 +0100
Subject: [OpenFDM-svn] r303 - trunk/flightgear
Message-ID: <200612131954.kBDJsvlf028408@sheep.berlios.de>

Author: frohlich
Date: 2006-12-13 20:54:57 +0100 (Wed, 13 Dec 2006)
New Revision: 303

Modified:
   trunk/flightgear/FGOpenFDM.cpp
   trunk/flightgear/FGPropertyAdapter.h
Log:
Make use of the Callbacks


Modified: trunk/flightgear/FGOpenFDM.cpp
===================================================================
--- trunk/flightgear/FGOpenFDM.cpp	2006-12-13 19:49:51 UTC (rev 302)
+++ trunk/flightgear/FGOpenFDM.cpp	2006-12-13 19:54:57 UTC (rev 303)
@@ -229,7 +229,7 @@
   {
     // Check for input models
     // If so, we need to register a change notifier in flightgears properties
-    Input* inputModel = dynamic_cast<Input*>(&model);
+    Input* inputModel = model.toInput();
     if (!inputModel)
       return;
 
@@ -237,9 +237,7 @@
            "Registering input for \"" << inputModel->getName() << "\"");
     std::string pName = inputModel->getInputName();
     SGPropertyNode* sgProp = mAircraftRootNode->getNode(pName.c_str(), true);
-    // That adds a change listener to the property node which in turn
-    // writes changes to the property back to the input model.
-    inputModel->setUserData(new InputChangeUserData(inputModel, sgProp));
+    inputModel->setCallback(new FGInputCallback(sgProp));
   }
   virtual void apply(ModelGroup& modelGroup)
   { traverse(modelGroup); }

Modified: trunk/flightgear/FGPropertyAdapter.h
===================================================================
--- trunk/flightgear/FGPropertyAdapter.h	2006-12-13 19:49:51 UTC (rev 302)
+++ trunk/flightgear/FGPropertyAdapter.h	2006-12-13 19:54:57 UTC (rev 303)
@@ -147,78 +147,51 @@
   { return new FGIntegerPropertyAdapter(*this); }
 };
 
-// This one is used to write changes to input properties into their input
-// models
-class InputChangeListener : public SGPropertyChangeListener {
+class FGInputCallback : public Input::Callback {
 public:
-  InputChangeListener(Input* inputModel) : mInputModel(inputModel) {}
-  virtual ~InputChangeListener(void) {}
-  virtual void valueChanged(SGPropertyNode * node)
-  {
-    // Just to be sure
-    if (!node)
-      return;
-    // Check if it is still valid
-    if (!mInputModel)
-      return;
-    // Set the input from the nodes's value.
-    mInputModel->setInputValue(node->getDoubleValue());
-  }
+  FGInputCallback(const SGPropertyNode* propertyNode) :
+    mPropertyNode(propertyNode)
+  { }
+  virtual real_type getValue() const
+  { return mPropertyNode->getDoubleValue(); }
 private:
-  // Holds the input model where it should write the value
-  // Note that this shal not be a SharedPtr, since we get a recursive
-  // ref count loop in that case.
-  WeakPtr<Input> mInputModel;
+  SGSharedPtr<const SGPropertyNode> mPropertyNode;
 };
 
-// That class just takes care that the listeners to a specific Input are
-// cleaned up past the input is deleted.
-class InputChangeUserData : public Object {
+class FGOutputCallback : public Output::Callback {
 public:
-  InputChangeUserData(Input* inputModel, SGPropertyNode* node) :
-    mListener(new InputChangeListener(inputModel))
-  {
-    node->addChangeListener(mListener);
-    // Don't forget to set the initial value
-    mListener->valueChanged(node);
-  }
-  virtual ~InputChangeUserData(void)
-  {
-    // Also deregisters itself at the SGPropertyNode.
-    // is deleted in the property system, don't do here
-    // FIXME: this might be a place where we can use the new refcounting thing
-    // of flightgear
-//     delete mListener;
-  }
+  FGOutputCallback() : mValue(0)
+  { }
+  virtual void setValue(real_type value)
+  { mValue = value; }
+  real_type getValue(void) const
+  { return mValue; }
 private:
-  InputChangeListener* mListener;
+  real_type mValue;
 };
 
 class FGOutputReflector :
     public SGRawValue<double> {
 public:
   FGOutputReflector(Output* output) :
-    mOutputModel(output)
-  {}
+    mOutputCallback(new FGOutputCallback)
+  {
+    if (!output)
+      return;
+    output->setCallback(mOutputCallback);
+  }
 
   virtual bool setValue(double value)
   { return false; }
   
   virtual double getValue(void) const
-  {
-    if (!mOutputModel)
-      return 0;
-    return mOutputModel->getValue();
-  }
+  { return mOutputCallback->getValue(); }
 
   virtual FGOutputReflector* clone(void) const
   { return new FGOutputReflector(*this); }
 
 private:
-  // Holds the output model where it should write the value
-  // Note that this shal not be a SharedPtr, since we get a recursive
-  // ref count loop in that case.
-  WeakPtr<Output> mOutputModel;
+  SharedPtr<FGOutputCallback> mOutputCallback;
 };
 
 class FGRealPortReflector :



From frohlich at mail.berlios.de  Wed Dec 13 21:46:42 2006
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Wed, 13 Dec 2006 21:46:42 +0100
Subject: [OpenFDM-svn] r304 - trunk/flightgear
Message-ID: <200612132046.kBDKkgja002585@sheep.berlios.de>

Author: frohlich
Date: 2006-12-13 21:46:42 +0100 (Wed, 13 Dec 2006)
New Revision: 304

Modified:
   trunk/flightgear/FGOpenFDM.cpp
Log:
Move input initialization


Modified: trunk/flightgear/FGOpenFDM.cpp
===================================================================
--- trunk/flightgear/FGOpenFDM.cpp	2006-12-13 19:54:57 UTC (rev 303)
+++ trunk/flightgear/FGOpenFDM.cpp	2006-12-13 20:46:42 UTC (rev 304)
@@ -321,6 +321,10 @@
   // Call what needs to be done ... ;-)
   common_init();
 
+  // connect the input models with the input properties
+  InputConnectModelVisitor icmv(mAircraftRootNode);
+  vehicle->getSystem()->accept(icmv);
+
   // Hmm, twice ??
   if (!vehicle->init()) {
     mData->vehicle = 0;
@@ -355,10 +359,6 @@
     mobileRootJoint->setRelVel(Vector6::zeros());
   }
 
-  // connect the input models with the input properties
-  InputConnectModelVisitor icmv(mAircraftRootNode);
-  mData->vehicle->getSystem()->accept(icmv);
-
   // Try to find a stable set of states
   if (!vehicle->trim())
     SG_LOG(SG_FLIGHT, SG_WARN, "Trimming failed!");



From frohlich at mail.berlios.de  Wed Dec 13 21:48:45 2006
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Wed, 13 Dec 2006 21:48:45 +0100
Subject: [OpenFDM-svn] r305 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200612132048.kBDKmjwe002858@sheep.berlios.de>

Author: frohlich
Date: 2006-12-13 21:48:44 +0100 (Wed, 13 Dec 2006)
New Revision: 305

Modified:
   trunk/OpenFDM/src/OpenFDM/Input.cpp
   trunk/OpenFDM/src/OpenFDM/Input.h
   trunk/OpenFDM/src/OpenFDM/Output.cpp
   trunk/OpenFDM/src/OpenFDM/Output.h
Log:
Removed unused functions


Modified: trunk/OpenFDM/src/OpenFDM/Input.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Input.cpp	2006-12-13 20:46:42 UTC (rev 304)
+++ trunk/OpenFDM/src/OpenFDM/Input.cpp	2006-12-13 20:48:44 UTC (rev 305)
@@ -42,17 +42,19 @@
 bool
 Input::init(void)
 {
+  if (!mCallback) {
+    Log(Model, Error) << "Initialization of Input model \"" << getName()
+                      << "\" failed: Input Callback not set!" << endl;
+    return false;
+  }
+
   return Model::init();
 }
 
 void
 Input::output(const TaskInfo&)
 {
-  if (mCallback) {
-    mOutputValue = mCallback->getValue();
-  } else {
-    mOutputValue = mInputValue*mInputGain;
-  }
+  mOutputValue = mInputGain*mCallback->getValue();
 }
 
 Input::Callback*
@@ -68,18 +70,6 @@
 }
 
 const real_type&
-Input::getInputValue(void) const
-{
-  return mInputValue;
-}
-
-void
-Input::setInputValue(const real_type& value)
-{
-  mInputValue = value;
-}
-
-const real_type&
 Input::getInputGain(void) const
 {
   return mInputGain;

Modified: trunk/OpenFDM/src/OpenFDM/Input.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Input.h	2006-12-13 20:46:42 UTC (rev 304)
+++ trunk/OpenFDM/src/OpenFDM/Input.h	2006-12-13 20:48:44 UTC (rev 305)
@@ -30,9 +30,6 @@
   Callback* getCallback(void) const;
   void setCallback(Callback* callback);
 
-  const real_type& getInputValue(void) const;
-  void setInputValue(const real_type& value);
-
   const real_type& getInputGain(void) const;
   void setInputGain(const real_type& inputGain);
 
@@ -43,8 +40,6 @@
 
 private:
   SharedPtr<Callback> mCallback;
-
-  real_type mInputValue;
   real_type mOutputValue;
   real_type mInputGain;
   std::string mInputName;

Modified: trunk/OpenFDM/src/OpenFDM/Output.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Output.cpp	2006-12-13 20:46:42 UTC (rev 304)
+++ trunk/OpenFDM/src/OpenFDM/Output.cpp	2006-12-13 20:48:44 UTC (rev 305)
@@ -16,8 +16,7 @@
 }
 
 Output::Output(const std::string& name) :
-  Model(name),
-  mOutputGain(1)
+  Model(name)
 {
   setDirectFeedThrough(true);
   setNumInputPorts(1);
@@ -38,6 +37,11 @@
                       << "\" is not connected!" << endl;
     return false;
   }
+//   if (!mCallback) {
+//     Log(Model, Error) << "Initialization of Output model \"" << getName()
+//                       << "\" failed: Output Callback not set!" << endl;
+//     return false;
+//   }
 
   return Model::init();
 }
@@ -57,9 +61,9 @@
 void
 Output::output(const TaskInfo&)
 {
-  mValue = mInputPort.getRealValue();
-  if (mCallback)
-    mCallback->setValue(mInputPort.getRealValue());
+  if (!mCallback)
+    return;
+  mCallback->setValue(mOutputGain*mInputPort.getRealValue());
 }
 
 Output::Callback*
@@ -75,12 +79,6 @@
 }
 
 const real_type&
-Output::getValue(void) const
-{
-  return mValue;
-}
-
-const real_type&
 Output::getOutputGain(void) const
 {
   return mOutputGain;

Modified: trunk/OpenFDM/src/OpenFDM/Output.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Output.h	2006-12-13 20:46:42 UTC (rev 304)
+++ trunk/OpenFDM/src/OpenFDM/Output.h	2006-12-13 20:48:44 UTC (rev 305)
@@ -30,8 +30,6 @@
   Callback* getCallback(void) const;
   void setCallback(Callback* callback);
 
-  const real_type& getValue(void) const;
-
   const real_type& getOutputGain(void) const;
   void setOutputGain(const real_type& outputGain);
 
@@ -41,8 +39,6 @@
 private:
   RealPortHandle mInputPort;
   SharedPtr<Callback> mCallback;
-
-  real_type mValue;
   real_type mOutputGain;
   std::string mOutputName;
 };



From frohlich at mail.berlios.de  Fri Dec 15 21:13:34 2006
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Fri, 15 Dec 2006 21:13:34 +0100
Subject: [OpenFDM-svn] r306 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200612152013.kBFKDYwJ024213@sheep.berlios.de>

Author: frohlich
Date: 2006-12-15 21:13:33 +0100 (Fri, 15 Dec 2006)
New Revision: 306

Modified:
   trunk/OpenFDM/src/OpenFDM/Object.cpp
   trunk/OpenFDM/src/OpenFDM/Object.h
   trunk/OpenFDM/src/OpenFDM/Referenced.h
   trunk/OpenFDM/src/OpenFDM/SharedPtr.h
Log:
Implement possibility to make destrictors protected.
Use that the the Object datatype.


Modified: trunk/OpenFDM/src/OpenFDM/Object.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Object.cpp	2006-12-13 20:48:44 UTC (rev 305)
+++ trunk/OpenFDM/src/OpenFDM/Object.cpp	2006-12-15 20:13:33 UTC (rev 306)
@@ -22,10 +22,6 @@
 {
 }
 
-Object::~Object(void)
-{
-}
-
 const TypeInfo&
 Object::getTypeInfo(void) const
 {
@@ -58,4 +54,14 @@
   sTypeInfo.getPropertyInfoList(props);
 }
 
+void
+Object::destroy(const Object* object)
+{
+  delete object;
+}
+
+Object::~Object(void)
+{
+}
+
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/Object.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Object.h	2006-12-13 20:48:44 UTC (rev 305)
+++ trunk/OpenFDM/src/OpenFDM/Object.h	2006-12-15 20:13:33 UTC (rev 306)
@@ -92,7 +92,6 @@
   OPENFDM_OBJECT(Object, );
 public:
   Object(const std::string& name = "Unnamed Object");
-  virtual ~Object(void);
 
   /// Returns the Objects name.
   const std::string& getName(void) const
@@ -114,6 +113,13 @@
   void setUserData(Object* userData)
   { mUserData = userData; }
 
+  /// overwrites the destroy function in Referenced
+  static void destroy(const Object* object);
+
+protected:
+  /// Objects must not be put onto the stack
+  virtual ~Object(void);
+
 private:
   /// Such objects can not be copied.
   Object(const Object&);

Modified: trunk/OpenFDM/src/OpenFDM/Referenced.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Referenced.h	2006-12-13 20:48:44 UTC (rev 305)
+++ trunk/OpenFDM/src/OpenFDM/Referenced.h	2006-12-15 20:13:33 UTC (rev 306)
@@ -29,6 +29,10 @@
   static bool shared(const Referenced* ref)
   { if (ref) return 1u < ref->_refcount; else return false; }
 
+  template<typename T>
+  static void destroy(T* ref)
+  { delete ref; }
+
 private:
   mutable Atomic _refcount;
 };

Modified: trunk/OpenFDM/src/OpenFDM/SharedPtr.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/SharedPtr.h	2006-12-13 20:48:44 UTC (rev 305)
+++ trunk/OpenFDM/src/OpenFDM/SharedPtr.h	2006-12-15 20:13:33 UTC (rev 306)
@@ -64,7 +64,7 @@
   { Referenced::get(p); put(); _ptr = p; }
 
   void put(void)
-  { if (!Referenced::put(_ptr)) { delete _ptr; _ptr = 0; } }
+  { if (!Referenced::put(_ptr)) { T::destroy(_ptr); _ptr = 0; } }
   
   // The reference itself.
   T* _ptr;



From frohlich at mail.berlios.de  Sat Dec 16 19:02:02 2006
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 16 Dec 2006 19:02:02 +0100
Subject: [OpenFDM-svn] r307 - in trunk/OpenFDM: . src src/OpenFDM src/test
Message-ID: <200612161802.kBGI22Qn031537@sheep.berlios.de>

Author: frohlich
Date: 2006-12-16 19:02:00 +0100 (Sat, 16 Dec 2006)
New Revision: 307

Added:
   trunk/OpenFDM/src/test/
   trunk/OpenFDM/src/test/Makefile.am
   trunk/OpenFDM/src/test/quattest.cpp
   trunk/OpenFDM/src/test/unitstest.cpp
Removed:
   trunk/OpenFDM/src/OpenFDM/quattest.cpp
   trunk/OpenFDM/src/OpenFDM/unitstest.cpp
Modified:
   trunk/OpenFDM/configure.ac
   trunk/OpenFDM/src/Makefile.am
   trunk/OpenFDM/src/OpenFDM/Makefile.am
Log:
Move tests into a separate directory


Modified: trunk/OpenFDM/configure.ac
===================================================================
--- trunk/OpenFDM/configure.ac	2006-12-15 20:13:33 UTC (rev 306)
+++ trunk/OpenFDM/configure.ac	2006-12-16 18:02:00 UTC (rev 307)
@@ -132,6 +132,7 @@
   src/OpenFDM/Makefile
   src/OpenFDM/XML/Makefile
   src/JSBSim/Makefile
+  src/test/Makefile
   src/builder/Makefile
   share/Makefile
   share/objects/Makefile

Modified: trunk/OpenFDM/src/Makefile.am
===================================================================
--- trunk/OpenFDM/src/Makefile.am	2006-12-15 20:13:33 UTC (rev 306)
+++ trunk/OpenFDM/src/Makefile.am	2006-12-16 18:02:00 UTC (rev 307)
@@ -1,4 +1,4 @@
-SUBDIRS = OpenFDM JSBSim
+SUBDIRS = OpenFDM JSBSim test
 if ENABLE_BUILDER
 SUBDIRS += builder
 endif

Modified: trunk/OpenFDM/src/OpenFDM/Makefile.am
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Makefile.am	2006-12-15 20:13:33 UTC (rev 306)
+++ trunk/OpenFDM/src/OpenFDM/Makefile.am	2006-12-16 18:02:00 UTC (rev 307)
@@ -2,19 +2,6 @@
 
 INCLUDES = -I$(srcdir)/..
 
-noinst_PROGRAMS = unitstest
-
-# define some unit tests
-check_PROGRAMS = quattest
-TESTS          = $(check_PROGRAMS)
-
-unitstest_SOURCES = unitstest.cpp
-unitstest_LDADD = libOpenFDM.la
-
-quattest_SOURCES = quattest.cpp
-quattest_LDADD = Units.o
-#quattest_LDADD = libOpenFDM.la
-
 OpenFDMincludedir = $(includedir)/OpenFDM
 
 lib_LTLIBRARIES = libOpenFDM.la

Deleted: trunk/OpenFDM/src/OpenFDM/quattest.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/quattest.cpp	2006-12-15 20:13:33 UTC (rev 306)
+++ trunk/OpenFDM/src/OpenFDM/quattest.cpp	2006-12-16 18:02:00 UTC (rev 307)
@@ -1,97 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2006 Mathias Froehlich 
- *
- */
-
-#include <cstdlib>
-#include <iostream>
-#include "Quaternion.h"
-
-namespace OpenFDM {
-
-/// Return random vector
-Vector3
-rVec(void)
-{
-  return Vector3(drand48()-0.5, drand48()-0.5, drand48()-0.5);
-}
-
-/// Return normalized random vector
-Vector3
-rnVec(void)
-{
-  return normalize(rVec());
-}
-
-int
-quattest(void)
-{
-  real_type eps = Limits<real_type>::epsilon();
-  unsigned nTests = 10000;
-
-  // Testing fromRotateTo factory
-  for (unsigned i = 0; i < nTests; ++i) {
-    Vector3 from = rnVec();
-    Vector3 to = rnVec();
-    Quaternion q = Quaternion::fromRotateTo(from, to);
-
-    if (!equal(q.transform(from), to, 100*eps)) {
-      std::cerr << "Failing on test " << i << " Quaternion::fromRotateTo("
-                << trans(from) << ", " << trans(to) << "):\n"
-                << "q = " << q << "\n"
-                << "q.transform(from) = " << trans(q.transform(from)) << "\n"
-                << "q.backTransform(from) = " << trans(q.backTransform(from))
-                << std::endl;
-      return -1;
-    }
-  }
-
-  // Testing fromRotateTo factory
-  for (unsigned i = 0; i < nTests; ++i) {
-    Vector3 from1 = rnVec();
-    unsigned i1 = 1;
-    Vector3 from2 = rnVec();
-    unsigned i2 = 2;
-    // Make sure they are not linearily dependent
-    while (dot(from1, from2) < 0.1) {
-      from2 = rnVec();
-    }
-
-    Quaternion q = Quaternion::fromRotateTo(from1, i1, from2, i2);
-
-    if (!equal(q.transform(from1), Vector3::unit(i1), 1e2*eps)) {
-      std::cerr << "Failing on test " << i << " Quaternion::fromRotateTo("
-                << trans(from1) << ", " << i1 << ", "
-                << trans(from2) << ", " << i2 << "):\n"
-                << "q = " << q << "\n"
-                << "q.transform(from1) = " << trans(q.transform(from1)) << "\n"
-                << "q.backTransform(from1) = " << trans(q.backTransform(from1))
-                << std::endl;
-      return -1;
-    }
-    Vector3 from2Orth = normalize(cross(cross(from1, from2), from1));
-    if (!equal(q.transform(from2Orth), Vector3::unit(i2), 1e3*eps)
-        || (0 > dot(q.transform(from2), Vector3::unit(i2)))) {
-      std::cerr << "Failing on test " << i << " Quaternion::fromRotateTo("
-                << trans(from1) << ", " << i1 << ", "
-                << trans(from2) << ", " << i2 << "):\n"
-                << "q = " << q << "\n"
-                << "q.transform(from2Orth) = "
-                << trans(q.transform(from2Orth)) << "\n"
-                << "q.backTransform(from2Orth) = "
-                << trans(q.backTransform(from2Orth))
-                << std::endl;
-      return -1;
-    }
-
-  }
-
-  return 0;
-}
-
-}
-
-int
-main(int argc, char *argv[])
-{
-  return OpenFDM::quattest();
-}

Deleted: trunk/OpenFDM/src/OpenFDM/unitstest.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/unitstest.cpp	2006-12-15 20:13:33 UTC (rev 306)
+++ trunk/OpenFDM/src/OpenFDM/unitstest.cpp	2006-12-16 18:02:00 UTC (rev 307)
@@ -1,541 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2006 Mathias Froehlich 
- *
- */
-
-#include <iostream>
-#include <sstream>
-#include <string>
-
-#include <OpenFDM/Units.h>
-
-using namespace OpenFDM;
-
-template<typename char_type, typename traits_type> 
-inline
-std::basic_istream<char_type, traits_type>&
-operator>>(std::basic_istream<char_type, traits_type>& stream, Unit2& u)
-{
-  // need to know the locale
-  std::locale loc = stream.getloc();
-
-  // eat whitespace
-  stream >> std::ws;
-
-  // a more or less hand written parser
-  // since prefices are not distinguishable from units, this seems the
-  // only alternative
-
-  char_type first = stream.peek();
-  if (first == stream.widen('c')) {
-    stream.get();
-    char_type second = stream.peek();
-    if (second == stream.widen('a')) {
-      stream.get();
-      char_type third = stream.peek();
-      if (third == stream.widen('l')) {
-        // calories ...
-        u = Unit2::energy(4.1868/*FIXME*/);
-        return stream;
-      } else {
-        stream.setstate(std::ios::failbit); // FIXME true?
-        return stream;
-      }
-    } else if (second == stream.widen('m')) {
-      // centimeters
-      u = Unit2::length(1e-2);
-      return stream;
-    } else {
-      // now c must be centi = 1e-2
-      Unit2 tmpU;
-      stream >> tmpU;
-      u = Unit2(tmpU.getPhysicalDimension(), 1e-2*tmpU.getFactor(),
-                tmpU.getOffset());
-      return stream;
-    }
-  } else if (first == stream.widen('f')) {
-    stream.get();
-    char_type second = stream.peek();
-    if (second == stream.widen('t')) {
-      stream.get();
-      // feet ...
-      u = Unit2::feet;
-      return stream;
-    } else {
-      stream.setstate(std::ios::failbit); // FIXME true?
-      return stream;
-    }
-  } else if (first == stream.widen('g')) {
-    // g for gramm
-    stream.get();
-    u = Unit2::mass(1e-3);
-    return stream;
-  } else if (first == stream.widen('h')) {
-    // h
-    stream.get();
-    char_type second = stream.peek();
-    if (second == stream.widen('o')) {
-      // ho
-      stream.get();
-      char_type third = stream.peek();
-      if (third == stream.widen('u')) {
-        // hou
-        stream.get();
-        char_type fourth = stream.peek();
-        if (fourth == stream.widen('r')) {
-          // hour
-          stream.get();
-          u = Unit2::hour;
-          return stream;
-        } else {
-          // hou*
-          stream.setstate(std::ios::failbit); // FIXME true?
-          return stream;
-        }
-      } else {
-        // ho*
-        stream.setstate(std::ios::failbit); // FIXME true?
-        return stream;
-      }
-    } else {
-      // just h
-      u = Unit2::hour;
-      return stream;
-    }
-  } else if (first == stream.widen('i')) {
-    stream.get();
-    char_type second = stream.peek();
-    if (second == stream.widen('n')) {
-      stream.get();
-      // inch ...
-      u = Unit2::inch;
-      return stream;
-    } else {
-      stream.setstate(std::ios::failbit); // FIXME true?
-      return stream;
-    }
-  } else if (first == stream.widen('k')) {
-    // k
-    stream.get();
-    char_type second = stream.peek();
-    if (second == stream.widen('t')) {
-      // kt
-      stream.get();
-      char_type third = stream.peek();
-      if (third == stream.widen('s')) {
-        // kts
-        stream.get();
-        u = Unit2::knots;
-        return stream;
-      } else {
-        stream.setstate(std::ios::failbit); // FIXME true?
-        return stream;
-      }
-    } else {
-      // k must be kilo = 1e3
-      Unit2 tmpU;
-      stream >> tmpU;
-      u = Unit2(tmpU.getPhysicalDimension(), 1e3*tmpU.getFactor(),
-                tmpU.getOffset());
-      return stream;
-    }
-  } else if (first == stream.widen('l')) {
-    // l
-    stream.get();
-    char_type second = stream.peek();
-    if (second == stream.widen('b')) {
-      // lb
-      stream.get();
-      char_type third = stream.peek();
-      if (third == stream.widen('s')) {
-        // lbs
-        stream.get();
-        u = Unit2::lbs;
-        return stream;
-      } else if (third == stream.widen('f')) {
-        // lbf
-        stream.get();
-        u = Unit2::lbf;
-        return stream;
-      } else {
-        // just lb
-        u = Unit2::lbf;
-        return stream;
-      }
-    } else {
-      // just l is liters
-      u = Unit2::volume(1e-3);
-      return stream;
-    }
-  } else if (first == stream.widen('m')) {
-    // m
-    stream.get();
-    char_type second = stream.peek();
-    if (second == stream.widen('m')) {
-      // mm
-      stream.get();
-      // milimeter ...
-      u = Unit2::length(1e-3);
-      return stream;
-    } else if (second == stream.widen('i')) {
-      // mi
-      stream.get();
-      char_type third = stream.peek();
-      if (third == stream.widen('n')) {
-        // min
-        stream.get();
-        u = Unit2::minute;
-        return stream;
-      } else {
-        stream.setstate(std::ios::failbit); // FIXME true?
-        return stream;
-      }
-    } else if (std::isalpha(second, loc)) {
-      // hmm m must be milli = 1e-3 ?? FIXME
-      Unit2 tmpU;
-      stream >> tmpU;
-      u = Unit2(tmpU.getPhysicalDimension(), 1e-3*tmpU.getFactor(),
-                tmpU.getOffset());
-      return stream;
-    } else {
-      // Ok, must have been a meters length
-      u = Unit2::length();
-      return stream;
-    }
-  } else if (first == stream.widen('n')) {
-    // n
-    stream.get();
-    char_type second = stream.peek();
-    if (second == stream.widen('m')) {
-      // nm
-      stream.get();
-      char_type third = stream.peek();
-      if (third == stream.widen('i')) {
-        // nmi for nautical miles
-        stream.get();
-        u = Unit2::nauticalMile;
-        return stream;
-      } else {
-        // just nm
-        u = Unit2::nauticalMile;
-        return stream;
-      }
-    } else {
-      stream.setstate(std::ios::failbit); // FIXME true?
-      return stream;
-    }
-  } else if (first == stream.widen('s')) {
-    // s
-    stream.get();
-    char_type second = stream.peek();
-    if (second == stream.widen('e')) {
-      // se
-      stream.get();
-      char_type third = stream.peek();
-      if (third == stream.widen('c')) {
-        // sec
-        stream.get();
-        u = Unit2::time();
-        return stream;
-      } else {
-        stream.setstate(std::ios::failbit); // FIXME true?
-        return stream;
-      }
-    } else if (second == stream.widen('l')) {
-      // sl
-      stream.get();
-      char_type third = stream.peek();
-      if (third == stream.widen('u')) {
-        // slu
-        stream.get();
-        char_type fourth = stream.peek();
-        if (fourth == stream.widen('g')) {
-          // slug
-          stream.get();
-          u = Unit2::slugs;
-          return stream;
-        } else {
-          stream.setstate(std::ios::failbit); // FIXME true?
-          return stream;
-        }
-      } else {
-        stream.setstate(std::ios::failbit); // FIXME true?
-        return stream;
-      }
-    } else if (second == stream.widen('m')) {
-      // sm
-      stream.get();
-      char_type third = stream.peek();
-      if (third == stream.widen('i')) {
-        // smi for statute miles
-        stream.get();
-        u = Unit2::statuteMile;
-        return stream;
-      } else {
-        stream.setstate(std::ios::failbit); // FIXME true?
-        return stream;
-      }
-    } else {
-      // just s for seconds
-      u = Unit2::time();
-      return stream;
-    }
-  } else if (first == stream.widen('C')) {
-    // C elsius //FIXME C oulomb
-    stream.get();
-    u = Unit2::degreeCelsius;
-    return stream;
-  } else if (first == stream.widen('F')) {
-    // F arenheit //FIXME F arrad
-    stream.get();
-    u = Unit2::degreeFarenheit;
-    return stream;
-  } else if (first == stream.widen('G')) {
-    // G must be giga = 1e9
-    stream.get();
-    Unit2 tmpU;
-    stream >> tmpU;
-    u = Unit2(tmpU.getPhysicalDimension(), 1e9*tmpU.getFactor(),
-              tmpU.getOffset());
-    return stream;
-  } else if (first == stream.widen('J')) {
-    // J oule
-    stream.get();
-    u = Unit2::energy();
-    return stream;
-  } else if (first == stream.widen('K')) {
-    // K elvin
-    stream.get();
-    u = Unit2::temperature();
-    return stream;
-  } else if (first == stream.widen('M')) {
-    // M must be mega = 1e6
-    stream.get();
-    Unit2 tmpU;
-    stream >> tmpU;
-    u = Unit2(tmpU.getPhysicalDimension(), 1e6*tmpU.getFactor(),
-              tmpU.getOffset());
-    return stream;
-  } else if (first == stream.widen('N')) {
-    // N ewton
-    stream.get();
-    u = Unit2::N;
-    return stream;
-  } else if (first == stream.widen('P')) {
-    // P
-    stream.get();
-    char_type second = stream.peek();
-    if (second == stream.widen('a')) {
-      // Pa
-      stream.get();
-      u = Unit2::Pa;
-      return stream;
-    } else {
-      stream.setstate(std::ios::failbit); // FIXME true?
-      return stream;
-    }
-  } else if (first == stream.widen('R')) {
-    // R ankine
-    stream.get();
-    u = Unit2::rankine;
-    return stream;
-  } else if (first == stream.widen('T')) {
-    // T must be terra = 1e12
-    stream.get();
-    Unit2 tmpU;
-    stream >> tmpU;
-    u = Unit2(tmpU.getPhysicalDimension(), 1e12*tmpU.getFactor(),
-              tmpU.getOffset());
-    return stream;
-  } else if (first == stream.widen('W')) {
-    // W att
-    stream.get();
-    u = Unit2::power();
-    return stream;
-  }
-
-
-
-//   General
-//      non-dimensional            ND              non-dimensional
-
-//   Prefix 2
-//      tera                       T               1e12 * parameter
-//      giga                       G               1e9 * parameter
-//      mega                       M               1e6 * parameter
-//      kilo                       k               1e3 * parameter
-//      deci                       d               1e-1 * parameter
-//      centi                      c               1e-2 * parameter
-//      milli                      m               1e-3 * parameter
-
-//   Time
-//      Solar year                 yr
-//      Solar day                  day
-//      hour                       h
-//      minute                     min
-//      second                     s               SI Standard
-
-//   Length
-//      metres                     m               SI Standard
-//      inch                       in
-//      feet                       ft
-//      yard                       yd
-//      nautical mile              nmi
-//      statute mile               smi
-
-//   Velocity 5
-//      knot                       kn              nmi h-1
-
-//   Volume
-//      litre                      l               10-3 m3
-//      US gallon                  USgal
-//      UK gallon                  UKgal           Imperial Gallon
-
-//   Mass
-//      kilogram                   kg              SI Standard -- 103g
-//      gram                       g
-//      tonne                      tonne
-//      slug                       slug
-//      short ton                  USton           US Ton
-//      long ton                   UKton           UK Ton
-//      force at sealevel          lbs             not a mass as such, but handy
-
-//   Force
-//      Newton                     N               SI Standard
-//      Pound Force                lbf
-
-//   Pressure
-//      Pascal                     Pa              N m-2
-//      millimetres Mercury        mmHg
-//      Pounds per square foot     lbf ft-2        lbf ft-2
-//      Pounds per square inch     lbf in-2        lbf in-2
-//      inches Mercury             inHg
-//      Atmosphere                 atm
-
-//   Temperature
-//      degrees Kelvin             K               SI Standard
-//      degrees Centigrade         C
-//      degrees Farenheight        F
-//      degrees Rankin             R
-
-//   Viscosity
-//      Poise                      Ps              Dynamic viscosity
-//      Stokes                     St              Kinematic viscosity
-
-//   Plane Angle
-//      degree                     deg
-//      radian                     rad
-//      revolution                 rev
-
-//   Power, Energy
-//      Watt                       W               SI Standard
-//      horsepower                 hp              550 ft lbf s-1
-//      joule                      jou             SI Standard
-//      British thermal unit       btu
-//      calorie                    cal
-//      erg                        erg
-
-//   Electrical, Magnetic
-//      volt direct current        Vdc
-//      volt alternating current   Vac
-//      ampere                     A               SI Standard
-//      omh, resistance            ohm             SI Standard
-//      cycle                      cyc
-//      henry                      hy
-//      farad                      fd
-//      Telsa                      T               field strength
-  return stream;
-}
-
-Unit2 stringToUnit(const std::string& s)
-{
-  std::stringstream sstr(s);
-  Unit2 unit;
-  sstr >> unit;
-  return unit;
-}
-
-void printConversion(const std::string& s)
-{
-  std::cout << "Original String \"" << s << "\", parsed unit: \""
-            << stringToUnit(s) << "\"" << std::endl;
-}
-
-int main(int argc, char *argv[])
-{
-  std::cout << "Mass units:\n";
-  printConversion("kg");
-  printConversion("mg");
-  printConversion("g");
-  printConversion("slug");
-  printConversion("lbs");
-
-  std::cout << "\nForce units:\n";
-  printConversion("N");
-  printConversion("kN");
-  printConversion("mN");
-  printConversion("lb");
-  printConversion("lbf");
-
-  std::cout << "\nLength units:\n";
-  printConversion("m");
-  printConversion("cm");
-  printConversion("mm");
-  printConversion("km");
-  printConversion("nmi");
-  printConversion("nm");
-  printConversion("smi");
-  printConversion("ft");
-  printConversion("in");
-  printConversion("inch");
-
-  std::cout << "\nSpeed units:\n";
-  printConversion("kts"); // FIXME
-  printConversion("m/s"); // FIXME
-  printConversion("m s-1"); // FIXME
-  printConversion("km h-1"); // FIXME
-  printConversion("km/h"); // FIXME
-  printConversion("ft/s"); // FIXME
-  printConversion("ft/min"); // FIXME
-  printConversion("ft min-1"); // FIXME
-  printConversion("ft s-1"); // FIXME
-
-  std::cout << "\nAngular nonunits:\n";
-  printConversion("deg");
-  printConversion("rad");
-
-  std::cout << "\nTime units:\n";
-  printConversion("s");
-  printConversion("sec");
-  printConversion("min");
-  printConversion("h");
-  printConversion("hour");
-
-  std::cout << "\nTemperature units:\n";
-  printConversion("K");
-  printConversion("R");
-  printConversion("C");
-  printConversion("F");
-
-  std::cout << "\nPressure units:\n";
-  printConversion("Pa");
-
-  std::cout << "\nEnergy units:\n";
-  printConversion("Nm"); // FIXME
-  printConversion("J");
-  printConversion("jou"); // FIXME
-  printConversion("cal");
-
-  std::cout << "\nPower units:\n";
-  printConversion("W");
-
-//   std::cout << "m/s:       " << Unit2::meterPerSecond << std::endl;
-//   std::cout << "km/h:      " << Unit2::kiloMeterPerHour << std::endl;
-//   std::cout << "ft/s:      " << Unit2::feetPerSecond << std::endl;
-//   std::cout << "ft/min:    " << Unit2::feetPerMinute << std::endl;
-//   std::cout << "kts:       " << Unit2::knots << std::endl;
-
-//   std::cout << "m/s^2:     " << Unit2::meterPerSecond2 << std::endl;
-
-  return 0;
-}
-

Added: trunk/OpenFDM/src/test/Makefile.am
===================================================================
--- trunk/OpenFDM/src/test/Makefile.am	2006-12-15 20:13:33 UTC (rev 306)
+++ trunk/OpenFDM/src/test/Makefile.am	2006-12-16 18:02:00 UTC (rev 307)
@@ -0,0 +1,12 @@
+INCLUDES = -I$(srcdir)/..
+
+# define some unit tests
+check_PROGRAMS = quattest unitstest
+TESTS          = $(check_PROGRAMS)
+
+unitstest_SOURCES = unitstest.cpp
+unitstest_LDADD = ../OpenFDM/libOpenFDM.la
+
+quattest_SOURCES = quattest.cpp
+quattest_LDADD = ../OpenFDM/libOpenFDM.la
+

Copied: trunk/OpenFDM/src/test/quattest.cpp (from rev 305, trunk/OpenFDM/src/OpenFDM/quattest.cpp)
===================================================================
--- trunk/OpenFDM/src/OpenFDM/quattest.cpp	2006-12-13 20:48:44 UTC (rev 305)
+++ trunk/OpenFDM/src/test/quattest.cpp	2006-12-16 18:02:00 UTC (rev 307)
@@ -0,0 +1,97 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2006 Mathias Froehlich 
+ *
+ */
+
+#include <cstdlib>
+#include <iostream>
+#include <OpenFDM/Quaternion.h>
+
+namespace OpenFDM {
+
+/// Return random vector
+Vector3
+rVec(void)
+{
+  return Vector3(drand48()-0.5, drand48()-0.5, drand48()-0.5);
+}
+
+/// Return normalized random vector
+Vector3
+rnVec(void)
+{
+  return normalize(rVec());
+}
+
+int
+quattest(void)
+{
+  real_type eps = Limits<real_type>::epsilon();
+  unsigned nTests = 10000;
+
+  // Testing fromRotateTo factory
+  for (unsigned i = 0; i < nTests; ++i) {
+    Vector3 from = rnVec();
+    Vector3 to = rnVec();
+    Quaternion q = Quaternion::fromRotateTo(from, to);
+
+    if (!equal(q.transform(from), to, 100*eps)) {
+      std::cerr << "Failing on test " << i << " Quaternion::fromRotateTo("
+                << trans(from) << ", " << trans(to) << "):\n"
+                << "q = " << q << "\n"
+                << "q.transform(from) = " << trans(q.transform(from)) << "\n"
+                << "q.backTransform(from) = " << trans(q.backTransform(from))
+                << std::endl;
+      return -1;
+    }
+  }
+
+  // Testing fromRotateTo factory
+  for (unsigned i = 0; i < nTests; ++i) {
+    Vector3 from1 = rnVec();
+    unsigned i1 = 1;
+    Vector3 from2 = rnVec();
+    unsigned i2 = 2;
+    // Make sure they are not linearily dependent
+    while (dot(from1, from2) < 0.1) {
+      from2 = rnVec();
+    }
+
+    Quaternion q = Quaternion::fromRotateTo(from1, i1, from2, i2);
+
+    if (!equal(q.transform(from1), Vector3::unit(i1), 1e2*eps)) {
+      std::cerr << "Failing on test " << i << " Quaternion::fromRotateTo("
+                << trans(from1) << ", " << i1 << ", "
+                << trans(from2) << ", " << i2 << "):\n"
+                << "q = " << q << "\n"
+                << "q.transform(from1) = " << trans(q.transform(from1)) << "\n"
+                << "q.backTransform(from1) = " << trans(q.backTransform(from1))
+                << std::endl;
+      return -1;
+    }
+    Vector3 from2Orth = normalize(cross(cross(from1, from2), from1));
+    if (!equal(q.transform(from2Orth), Vector3::unit(i2), 1e3*eps)
+        || (0 > dot(q.transform(from2), Vector3::unit(i2)))) {
+      std::cerr << "Failing on test " << i << " Quaternion::fromRotateTo("
+                << trans(from1) << ", " << i1 << ", "
+                << trans(from2) << ", " << i2 << "):\n"
+                << "q = " << q << "\n"
+                << "q.transform(from2Orth) = "
+                << trans(q.transform(from2Orth)) << "\n"
+                << "q.backTransform(from2Orth) = "
+                << trans(q.backTransform(from2Orth))
+                << std::endl;
+      return -1;
+    }
+
+  }
+
+  return 0;
+}
+
+}
+
+int
+main(int argc, char *argv[])
+{
+  return OpenFDM::quattest();
+}

Copied: trunk/OpenFDM/src/test/unitstest.cpp (from rev 305, trunk/OpenFDM/src/OpenFDM/unitstest.cpp)



From frohlich at mail.berlios.de  Sun Dec 24 14:28:52 2006
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 24 Dec 2006 14:28:52 +0100
Subject: [OpenFDM-svn] r309 - trunk/flightgear
Message-ID: <200612241328.kBODSqre032378@sheep.berlios.de>

Author: frohlich
Date: 2006-12-24 14:28:52 +0100 (Sun, 24 Dec 2006)
New Revision: 309

Modified:
   trunk/flightgear/FGOpenFDM.cpp
   trunk/flightgear/FGPropertyAdapter.h
Log:
Index shift by one


Modified: trunk/flightgear/FGOpenFDM.cpp
===================================================================
--- trunk/flightgear/FGOpenFDM.cpp	2006-12-24 13:28:30 UTC (rev 308)
+++ trunk/flightgear/FGOpenFDM.cpp	2006-12-24 13:28:52 UTC (rev 309)
@@ -39,7 +39,7 @@
   virtual GroundValues
   getGroundPlane(real_type t, const Vector3& refPos) const
   {
-    double loc_cart[3] = { refPos(1), refPos(2), refPos(3) };
+    double loc_cart[3] = { refPos(0), refPos(1), refPos(2) };
     double contact[3], normal[3], vel[3], lc, ff, agl;
     int groundtype;
     // FIXME!!!!!!!
@@ -62,7 +62,7 @@
     if (!mIfce)
       return Limits<real_type>::max();
 
-    double pt[3] = { refPos(1), refPos(2), refPos(3) };
+    double pt[3] = { refPos(0), refPos(1), refPos(2) };
     double end[2][3];
     double vel[2][3];
     real_type dist = mIfce->get_cat_m(t, pt, end, vel);
@@ -71,7 +71,7 @@
     Vector3 p1 = Vector3(end[1][0], end[1][1], end[1][2]);
 
     catVal.position = p0;
-    catVal.orientation = Quaternion::fromRotateTo(p1 - p0, Vector3::unit(1));
+    catVal.orientation = Quaternion::fromRotateTo(p1 - p0, Vector3::unit(0));
     /// FIXME: wrong ...
     catVal.velocity = Vector6(Vector3::zeros(),
                               Vector3(vel[0][0], vel[0][1], vel[0][2]));
@@ -89,10 +89,10 @@
     Vector3 oldTip = old.basePosition + old.hookVector;
     Vector3 currentTip = current.basePosition + current.hookVector;
     double pt[4][3] = {
-      { old.basePosition(1), old.basePosition(2), old.basePosition(3) },
-      { oldTip(1), oldTip(2), oldTip(3) },
-      { currentTip(1), currentTip(2), currentTip(3) },
-      { current.basePosition(1), current.basePosition(2), current.basePosition(3) },
+      { old.basePosition(0), old.basePosition(1), old.basePosition(2) },
+      { oldTip(0), oldTip(1), oldTip(2) },
+      { currentTip(0), currentTip(1), currentTip(2) },
+      { current.basePosition(0), current.basePosition(1), current.basePosition(2) },
     };
     return mIfce->caught_wire_m(old.t, pt);
   }
@@ -162,7 +162,7 @@
    */
   virtual Geodetic toGeod(const Vector3& cart) const
   {
-    double xyz[3] = { cart(1), cart(2), cart(3) };
+    double xyz[3] = { cart(0), cart(1), cart(2) };
     double lat, lon, alt;
     sgCartToGeod(xyz, &lat, &lon, &alt);
     return Geodetic(lat, lon, alt);
@@ -189,7 +189,7 @@
   // FIXME: make pure virtual
   virtual Vector3 getWindVel(const Vector3& pos) const
   {
-    double xyz[3] = { pos(1), pos(2), pos(3) };
+    double xyz[3] = { pos(0), pos(1), pos(2) };
     double lat, lon, alt;
     sgCartToGeod(xyz, &lat, &lon, &alt);
 
@@ -441,7 +441,7 @@
   double groundCacheRadius = acrad
     + 2*dt*norm(vehicle->getVelocity().getLinear());
   Vector3 cart = vehicle->getCartPosition();
-  double cart_pos[3] = { cart(1), cart(2), cart(3) };
+  double cart_pos[3] = { cart(0), cart(1), cart(2) };
   double t = vehicle->getTime();
   if (!prepare_ground_cache_m(t, cart_pos, groundCacheRadius))
     SG_LOG(SG_FLIGHT, SG_WARN,
@@ -459,37 +459,37 @@
 
   Rotation geodOr = vehicle->getGeodOrientation();
   euler = geodOr.getEuler();
-  _set_Euler_Angles(euler(1), euler(2), euler(3));
+  _set_Euler_Angles(euler(0), euler(1), euler(2));
 
   // FIXME: wrong velocities are set here ...
   Vector3 velWrtWind = vehicle->getVelocity().getLinear();
   _set_V_rel_wind(convertTo(uFeetPSecond, norm(velWrtWind)));
-  _set_Velocities_Wind_Body(convertTo(uFeetPSecond, velWrtWind(1)),
-                            convertTo(uFeetPSecond, velWrtWind(2)),
-                            convertTo(uFeetPSecond, velWrtWind(3)));
+  _set_Velocities_Wind_Body(convertTo(uFeetPSecond, velWrtWind(0)),
+                            convertTo(uFeetPSecond, velWrtWind(1)),
+                            convertTo(uFeetPSecond, velWrtWind(2)));
   _set_V_equiv_kts(convertTo(uKnots, norm(velWrtWind)));
   _set_V_calibrated_kts(convertTo(uKnots, norm(velWrtWind)));
   _set_Mach_number(norm(velWrtWind)/340);
 
   Vector3 localVel = convertTo(uFeetPSecond, geodOr.backTransform(velWrtWind));
-  _set_Velocities_Local(localVel(1),localVel(2), localVel(3));
+  _set_Velocities_Local(localVel(0),localVel(1), localVel(2));
   _set_V_ground_speed(convertTo(uFeetPSecond,
-             sqrt(localVel(1)*localVel(1) + localVel(2)*localVel(2))));
-  _set_Velocities_Ground(localVel(1),localVel(2), -localVel(3));;
-  _set_Climb_Rate(-localVel(3));
+             sqrt(localVel(0)*localVel(0) + localVel(1)*localVel(1))));
+  _set_Velocities_Ground(localVel(0), localVel(1), -localVel(2));;
+  _set_Climb_Rate(-localVel(2));
 
   const RigidBody* topBody = vehicle->getTopBody();
   Vector3 bodyAccel = convertTo(uFeetPSec2, topBody->getFrame()->getClassicAccel().getLinear());
-  _set_Accels_Body(bodyAccel(1), bodyAccel(2), bodyAccel(3));
-  _set_Accels_Pilot_Body(bodyAccel(1), bodyAccel(2), bodyAccel(3));
-  _set_Accels_CG_Body(bodyAccel(1), bodyAccel(2), bodyAccel(3));
+  _set_Accels_Body(bodyAccel(0), bodyAccel(1), bodyAccel(2));
+  _set_Accels_Pilot_Body(bodyAccel(0), bodyAccel(1), bodyAccel(2));
+  _set_Accels_CG_Body(bodyAccel(0), bodyAccel(1), bodyAccel(2));
   // It is not clear in any way how this 'local acceleration is meant'
   // Just provide one possible interpretation
   Vector3 localAccel = geodOr.backTransform(bodyAccel);
-  _set_Accels_Local(localAccel(1), localAccel(2), localAccel(3));
+  _set_Accels_Local(localAccel(0), localAccel(1), localAccel(2));
 
   Vector3 nAccel = 1/convertTo(uFeetPSec2, 9.81) * bodyAccel;
-  _set_Accels_CG_Body_N(nAccel(1), nAccel(2), nAccel(3));
+  _set_Accels_CG_Body_N(nAccel(0), nAccel(1), nAccel(2));
 
 
   SGPropertyNode* sgProp;
@@ -499,7 +499,7 @@
     _set_Nlf( sgProp->getDoubleValue() );
 
   Vector3 angVel = topBody->getFrame()->getRelVel().getAngular();
-  _set_Omega_Body(angVel(1), angVel(2), angVel(3));
+  _set_Omega_Body(angVel(0), angVel(1), angVel(2));
 
   // is already in the property tree, but fool the HUD now
   sgProp = mAircraftRootNode->getNode("orientation/alpha-deg", false);

Modified: trunk/flightgear/FGPropertyAdapter.h
===================================================================
--- trunk/flightgear/FGPropertyAdapter.h	2006-12-24 13:28:30 UTC (rev 308)
+++ trunk/flightgear/FGPropertyAdapter.h	2006-12-24 13:28:52 UTC (rev 309)
@@ -84,11 +84,11 @@
     if (getPropertyValue(variantValue))
       return false;
     Matrix m = variantValue.toMatrix();
-    unsigned r = mIndex % rows(m) + 1;
-    unsigned c = mIndex / rows(m) + 1;
-    if (r < 1 || rows(m) < r)
+    unsigned r = mIndex % rows(m);
+    unsigned c = mIndex / rows(m);
+    if (rows(m) <= r)
       return false;
-    if (c < 1 || cols(m) < c)
+    if (cols(m) <= c)
       return false;
     
     m(r, c) = value;
@@ -107,11 +107,11 @@
       if (!getPropertyValue(variantValue))
         return 0;
       Matrix m = variantValue.toMatrix();
-      unsigned r = mIndex % rows(m) + 1;
-      unsigned c = mIndex / rows(m) + 1;
-      if (r < 1 || rows(m) < r)
+      unsigned r = mIndex % rows(m);
+      unsigned c = mIndex / rows(m);
+      if (rows(m) <= r)
         return 0;
-      if (c < 1 || cols(m) < c)
+      if (cols(m) <= c)
         return 0;
       return m(r, c);
     }
@@ -221,11 +221,11 @@
       MatrixPortHandle matrixPortHandle = port->getPortInterface()->toMatrixPortInterface();
       if (matrixPortHandle.isConnected()) {
         Matrix m = matrixPortHandle.getMatrixValue();
-        unsigned r = mIndex % rows(m) + 1;
-        unsigned c = mIndex / rows(m) + 1;
-        if (r < 1 || rows(m) < r)
+        unsigned r = mIndex % rows(m);
+        unsigned c = mIndex / rows(m);
+        if (rows(m) <= r)
           return 0;
-        if (c < 1 || cols(m) < c)
+        if (cols(m) <= c)
           return 0;
         return m(r, c);
       } else



