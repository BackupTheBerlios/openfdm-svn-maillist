From frohlich at mail.berlios.de  Wed Sep  3 20:50:39 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Wed, 3 Sep 2008 20:50:39 +0200
Subject: [OpenFDM-svn] r436 - in branches/OpenFDM-StateSeparation/src:
	OpenFDM test
Message-ID: <200809031850.m83IodV5011964@sheep.berlios.de>

Author: frohlich
Date: 2008-09-03 20:50:38 +0200 (Wed, 03 Sep 2008)
New Revision: 436

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Group.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Group.h
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Move some methods in the implementation file.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Group.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Group.cpp	2008-08-31 10:24:50 UTC (rev 435)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Group.cpp	2008-09-03 18:50:38 UTC (rev 436)
@@ -7,9 +7,6 @@
 
 namespace OpenFDM {
 
-BEGIN_OPENFDM_OBJECT_DEF(Group, Node)
-  END_OPENFDM_OBJECT_DEF
-
 GroupAcceptorNode::GroupAcceptorNode() :
   _groupInternalPort(new ProxyProviderPortInfo(this, "output"))
 {
@@ -20,4 +17,100 @@
 {
 }
 
+BEGIN_OPENFDM_OBJECT_DEF(Group, Node)
+  END_OPENFDM_OBJECT_DEF
+
+Group::Group(const std::string& name) :
+  Node(name)
+{
+}
+
+Group::~Group()
+{
+}
+
+void
+Group::accept(NodeVisitor& visitor)
+{
+  visitor.apply(*this);
+}
+
+Group::NodeId
+Group::addChild(const SharedPtr<Node>& node)
+{
+  std::string identifier = getUniqueIdentifier(node->getName());
+  _childList.push_back(new Child(this, node, identifier));
+  return NodeId(_childList.back());
+}
+
+unsigned
+Group::getNumChildren() const
+{
+  return _childList.size();
+}
+
+Group::NodeId
+Group::getNodeId(unsigned i) const
+{
+  if (_childList.size() <= i)
+    return NodeId();
+  return NodeId(_childList[i]);
+}
+
+unsigned
+Group::getChildNumber(const NodeId& nodeId) const
+{
+  SharedPtr<Child> child = nodeId._child.lock();
+  if (!child)
+    return ~0u;
+  if (child->group.lock() != this)
+    return ~0u;
+  ChildList::const_iterator i;
+  i = std::find(_childList.begin(), _childList.end(), child);
+  if (i == _childList.end())
+    return ~0u;
+  return std::distance(_childList.begin(), i);
+}
+
+SharedPtr<Node>
+Group::getChild(unsigned i)
+{
+  if (_childList.size() <= i)
+    return 0;
+  return _childList[i]->node;
+}
+
+SharedPtr<const Node>
+Group::getChild(unsigned i) const
+{
+  if (_childList.size() <= i)
+    return 0;
+  return _childList[i]->node;
+}
+
+SharedPtr<Node>
+Group::getChild(const NodeId& nodeId)
+{
+  SharedPtr<Child> child = nodeId._child.lock();
+  if (!child)
+    return 0;
+  // Check if it belongs to this current group
+  if (child->group.lock() != this)
+    return 0;
+  return child->node;
+}
+
+SharedPtr<const Node>
+Group::getChild(const NodeId& nodeId) const
+{
+  SharedPtr<Child> child = nodeId._child.lock();
+  if (!child)
+    return 0;
+  // Check if it belongs to this current group
+  SharedPtr<Group> group = child->group.lock();
+  if (group != this)
+    return 0;
+  return child->node;
+}
+
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Group.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Group.h	2008-08-31 10:24:50 UTC (rev 435)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Group.h	2008-09-03 18:50:38 UTC (rev 436)
@@ -70,76 +70,22 @@
 class Group : public Node {
   OPENFDM_OBJECT(Group, Node);
 public:
-  Group(const std::string& name) : Node(name) {}
-  virtual ~Group() {}
-
-  virtual void accept(NodeVisitor& visitor)
-  { visitor.apply(*this); }
-
   class NodeId;
 
-  NodeId addChild(const SharedPtr<Node>& node)
-  {
-    std::string identifier = getUniqueIdentifier(node->getName());
-    _childList.push_back(new Child(this, node, identifier));
-    return NodeId(_childList.back());
-  }
-  unsigned getNumChildren() const
-  { return _childList.size(); }
-  NodeId getNodeId(unsigned i) const
-  {
-    if (_childList.size() <= i)
-      return NodeId();
-    return NodeId(_childList[i]);
-  }
-  unsigned getChildNumber(const NodeId& nodeId) const
-  {
-    SharedPtr<Child> child = nodeId._child.lock();
-    if (!child)
-      return ~0u;
-    if (child->group.lock() != this)
-      return ~0u;
-    ChildList::const_iterator i;
-    i = std::find(_childList.begin(), _childList.end(), child);
-    if (i == _childList.end())
-      return ~0u;
-    return std::distance(_childList.begin(), i);
-  }
+  Group(const std::string& name);
+  virtual ~Group();
 
-  SharedPtr<Node> getChild(unsigned i)
-  {
-    if (_childList.size() <= i)
-      return 0;
-    return _childList[i]->node;
-  }
-  SharedPtr<const Node> getChild(unsigned i) const
-  {
-    if (_childList.size() <= i)
-      return 0;
-    return _childList[i]->node;
-  }
-  SharedPtr<Node> getChild(const NodeId& nodeId)
-  {
-    SharedPtr<Child> child = nodeId._child.lock();
-    if (!child)
-      return 0;
-    /// Check if it belongs to this current group
-    if (child->group.lock() != this)
-      return 0;
-    return child->node;
-  }
-  SharedPtr<const Node> getChild(const NodeId& nodeId) const
-  {
-    SharedPtr<Child> child = nodeId._child.lock();
-    if (!child)
-      return 0;
-    /// Check if it belongs to this current group
-    SharedPtr<Group> group = child->group.lock();
-    if (group != this)
-      return 0;
-    return child->node;
-  }
+  virtual void accept(NodeVisitor& visitor);
 
+  NodeId addChild(const SharedPtr<Node>& node);
+  unsigned getNumChildren() const;
+  NodeId getNodeId(unsigned i) const;
+  unsigned getChildNumber(const NodeId& nodeId) const;
+  SharedPtr<Node> getChild(unsigned i);
+  SharedPtr<const Node> getChild(unsigned i) const;
+  SharedPtr<Node> getChild(const NodeId& nodeId);
+  SharedPtr<const Node> getChild(const NodeId& nodeId) const;
+
   NodeId getGroupAcceptorNode(const PortId& portId) const
   {
     SharedPtr<const PortInfo> port = getPort(portId);

Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-08-31 10:24:50 UTC (rev 435)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-03 18:50:38 UTC (rev 436)
@@ -86,7 +86,9 @@
     Model(name),
     mInputPort(newRealInputPort("input"))
   { }
-  virtual void output(const DiscreteStateValueVector&, const ContinousStateValueVector&, PortValueList& portValues) const
+  virtual void output(const DiscreteStateValueVector&,
+                      const ContinousStateValueVector&,
+                      PortValueList& portValues) const
   { std::cout << portValues[mInputPort] << std::endl; }
   virtual bool dependsOn(const PortId&, const PortId&) const
   { return false; }



From frohlich at mail.berlios.de  Wed Sep  3 20:55:57 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Wed, 3 Sep 2008 20:55:57 +0200
Subject: [OpenFDM-svn] r437 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200809031855.m83ItvFj013689@sheep.berlios.de>

Author: frohlich
Date: 2008-09-03 20:55:57 +0200 (Wed, 03 Sep 2008)
New Revision: 437

Modified:
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Remove unused methods.


Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-03 18:50:38 UTC (rev 436)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-03 18:55:57 UTC (rev 437)
@@ -147,27 +147,6 @@
   typedef std::vector<SharedPtr<ProviderPortData> > ProviderPortDataList;
   ProviderPortDataList _providerPortData;
 
-  AcceptorPortData* getAcceptorPortData(const AcceptorPortInfo* acceptorPort)
-  {
-    AcceptorPortDataList::const_iterator i;
-    for (i = _acceptorPortData.begin(); i != _acceptorPortData.end(); ++i) {
-      for (unsigned j = 0; j < (*i)->_acceptorPortList.size(); ++j) {
-        if ((*i)->_acceptorPortList[j] == acceptorPort)
-          return *i;
-      }
-    }
-    return 0;
-  }
-  ProviderPortData* getProviderPortData(const ProviderPortInfo* providerPort)
-  {
-    ProviderPortDataList::const_iterator i;
-    for (i = _providerPortData.begin(); i != _providerPortData.end(); ++i) {
-      if ((*i)->_providerPort == providerPort)
-        return *i;
-    }
-    return 0;
-  }
-
   AcceptorPortData* getAcceptorPortData(const PortId& portId)
   {
     AcceptorPortDataList::const_iterator i;



From frohlich at mail.berlios.de  Thu Sep  4 21:48:24 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Thu, 4 Sep 2008 21:48:24 +0200
Subject: [OpenFDM-svn] r438 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200809041948.m84JmOlK028141@sheep.berlios.de>

Author: frohlich
Date: 2008-09-04 21:48:23 +0200 (Thu, 04 Sep 2008)
New Revision: 438

Modified:
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Cleanup.


Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-03 18:55:57 UTC (rev 437)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-04 19:48:23 UTC (rev 438)
@@ -101,72 +101,92 @@
   struct AcceptorPortData;
   struct ProviderPortData;
 
-  LeafInstance(const LeafNode* leaf) :
-    _leaf(leaf)
-  { allocPorts(leaf); }
+  class PortData : public WeakReferenced {
+  public:
+    PortData(LeafInstance* leafInstance, const PortInfo* portInfo) :
+      mLeafInstance(leafInstance),
+      mPortInfo(portInfo)
+    { }
+    virtual ~PortData() {}
 
-  void allocPorts(const Node* node)
-  {
-    for (unsigned i = 0; i < node->getNumPorts(); ++i) {
-      SharedPtr<const PortInfo> port = node->getPort(i);
-      const ProviderPortInfo* providerPort = port->toProviderPortInfo();
-      if (providerPort) {
-        _providerPortData.push_back(new ProviderPortData(this, providerPort));
-      }
-      const AcceptorPortInfo* acceptorPort = port->toAcceptorPortInfo();
-      if (acceptorPort) {
-        _acceptorPortData.push_back(new AcceptorPortData(this, acceptorPort));
-      }
-    }
-  }
+    virtual AcceptorPortData* toAcceptorPortData()
+    { return 0; }
+    virtual ProviderPortData* toProviderPortData()
+    { return 0; }
+    
+    /// Return the LeafInstance this PortData belongs to.
+    SharedPtr<LeafInstance> getLeafInstance() const
+    { return mLeafInstance.lock(); }
 
-  // The subsystem leaf node
-  SharedPtr<const LeafNode> _leaf;
+  private:
+    WeakPtr<LeafInstance> mLeafInstance;
+    SharedPtr<const PortInfo> mPortInfo;
+  };
 
-  struct ProviderPortData : public WeakReferenced {
+  struct ProviderPortData : public PortData {
     ProviderPortData(LeafInstance* leafInstance,
                      const ProviderPortInfo* providerPort) :
-      _leafInstance(leafInstance),
+      PortData(leafInstance, providerPort),
       _providerPort(providerPort)
-    {}
-    WeakPtr<LeafInstance> _leafInstance;
+    { }
+    virtual ProviderPortData* toProviderPortData()
+    { return this; }
     SharedPtr<const ProviderPortInfo> _providerPort;
     std::vector<WeakPtr<const AcceptorPortData> > _acceptorPortDataList;
   };
-  struct AcceptorPortData : public WeakReferenced {
+  struct AcceptorPortData : public PortData {
     AcceptorPortData(LeafInstance* leafInstance,
                      const AcceptorPortInfo* acceptorPort) :
-      _leafInstance(leafInstance)
+      PortData(leafInstance, acceptorPort)
     { _acceptorPortList.push_back(acceptorPort); }
-    WeakPtr<LeafInstance> _leafInstance;
+    virtual AcceptorPortData* toAcceptorPortData()
+    { return this; }
     std::vector<SharedPtr<const AcceptorPortInfo> > _acceptorPortList;
     WeakPtr<const ProviderPortData> _providerPortData;
   };
-  typedef std::vector<SharedPtr<AcceptorPortData> > AcceptorPortDataList;
-  AcceptorPortDataList _acceptorPortData;
-  typedef std::vector<SharedPtr<ProviderPortData> > ProviderPortDataList;
-  ProviderPortDataList _providerPortData;
 
-  AcceptorPortData* getAcceptorPortData(const PortId& portId)
+
+
+  LeafInstance(const LeafNode* leaf) :
+    mLeafNode(leaf)
+  { allocPorts(leaf); }
+
+  PortData* getPortData(const PortId& portId)
   {
-    AcceptorPortDataList::const_iterator i;
-    for (i = _acceptorPortData.begin(); i != _acceptorPortData.end(); ++i) {
-      for (unsigned j = 0; j < (*i)->_acceptorPortList.size(); ++j) {
-        if (PortId(SharedPtr<const PortInfo>((*i)->_acceptorPortList[j])) == portId)
-          return *i;
-      }
-    }
-    return 0;
+    OpenFDMAssert(getLeafNode());
+    unsigned index = getLeafNode()->getPortIndex(portId);
+    // FIXME, is an error condition, not an assert???
+    OpenFDMAssert(index < mPortData.size());
+    return mPortData[index];
   }
+  AcceptorPortData* getAcceptorPortData(const PortId& portId)
+  { return getPortData(portId)->toAcceptorPortData(); }
   ProviderPortData* getProviderPortData(const PortId& portId)
+  { return getPortData(portId)->toProviderPortData(); }
+
+  const SharedPtr<const LeafNode>& getLeafNode() const
+  { return mLeafNode; }
+
+private:
+  void allocPorts(const Node* node)
   {
-    ProviderPortDataList::const_iterator i;
-    for (i = _providerPortData.begin(); i != _providerPortData.end(); ++i) {
-      if (PortId(SharedPtr<const PortInfo>((*i)->_providerPort)) == portId)
-        return *i;
+    for (unsigned i = 0; i < node->getNumPorts(); ++i) {
+      SharedPtr<const PortInfo> port = node->getPort(i);
+      const ProviderPortInfo* providerPort = port->toProviderPortInfo();
+      if (providerPort)
+        mPortData.push_back(new ProviderPortData(this, providerPort));
+      const AcceptorPortInfo* acceptorPort = port->toAcceptorPortInfo();
+      if (acceptorPort)
+        mPortData.push_back(new AcceptorPortData(this, acceptorPort));
     }
-    return 0;
   }
+
+  // The subsystem leaf node
+  SharedPtr<const LeafNode> mLeafNode;
+
+  // List of port dependent info used to build up the connect info and
+  // the sorted list of leafs.
+  std::vector<SharedPtr<PortData> > mPortData;
 };
 
 class LeafInstanceCollector : public NodeVisitor {
@@ -419,7 +439,7 @@
   for (i = nodeInstanceCollector._leafInstanceList.begin();
        i != nodeInstanceCollector._leafInstanceList.end();
        ++i) {
-    std::cout << "Node: " << (*i)->_leaf->getName() << std::endl;
+    std::cout << "Node: " << (*i)->getLeafNode()->getName() << std::endl;
   }
 
   return 0;



From frohlich at mail.berlios.de  Sat Sep  6 13:13:44 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 6 Sep 2008 13:13:44 +0200
Subject: [OpenFDM-svn] r439 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200809061113.m86BDiOC032285@sheep.berlios.de>

Author: frohlich
Date: 2008-09-06 13:13:44 +0200 (Sat, 06 Sep 2008)
New Revision: 439

Modified:
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Add connect method.


Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-04 19:48:23 UTC (rev 438)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-06 11:13:44 UTC (rev 439)
@@ -118,6 +118,8 @@
     SharedPtr<LeafInstance> getLeafInstance() const
     { return mLeafInstance.lock(); }
 
+    virtual bool connect(PortData*) = 0;
+
   private:
     WeakPtr<LeafInstance> mLeafInstance;
     SharedPtr<const PortInfo> mPortInfo;
@@ -131,6 +133,18 @@
     { }
     virtual ProviderPortData* toProviderPortData()
     { return this; }
+
+    virtual bool connect(PortData* portData)
+    {
+      if (!portData)
+        return false;
+      AcceptorPortData* acceptorPortData = portData->toAcceptorPortData();
+      if (!acceptorPortData)
+        return false;
+      return acceptorPortData->connectToProvider(this);
+    }
+
+  public:
     SharedPtr<const ProviderPortInfo> _providerPort;
     std::vector<WeakPtr<const AcceptorPortData> > _acceptorPortDataList;
   };
@@ -141,6 +155,29 @@
     { _acceptorPortList.push_back(acceptorPort); }
     virtual AcceptorPortData* toAcceptorPortData()
     { return this; }
+
+    virtual bool connect(PortData* portData)
+    {
+      if (!portData)
+        return false;
+      ProviderPortData* providerPortData = portData->toProviderPortData();
+      if (!providerPortData)
+        return false;
+      return connectToProvider(providerPortData);
+    }
+
+    bool connectToProvider(ProviderPortData* providerPortData)
+    {
+      // The current one must not be connected already ...
+      OpenFDMAssert(!_providerPortData.lock());
+      if (!providerPortData)
+        return false;
+      providerPortData->_acceptorPortDataList.push_back(this);
+      _providerPortData = providerPortData;
+      return true;
+    }
+  public:
+
     std::vector<SharedPtr<const AcceptorPortInfo> > _acceptorPortList;
     WeakPtr<const ProviderPortData> _providerPortData;
   };
@@ -296,11 +333,8 @@
         continue;
       }
 
-      // FIXME Error message ??? and abort visiting???
-      if (acceptorPortData->_providerPortData.lock())
-        std::cerr << "??? already have a provider port????" << std::endl;
-      acceptorPortData->_providerPortData = providerPortData;
-      providerPortData->_acceptorPortDataList.push_back(acceptorPortData);
+      if (!acceptorPortData->connect(providerPortData))
+        std::cerr << "Cannot connect????" << std::endl;
     }
 
     // Add a proxy LeafInstance that holds this groups ports, will be removed



From frohlich at mail.berlios.de  Sat Sep  6 17:24:37 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 6 Sep 2008 17:24:37 +0200
Subject: [OpenFDM-svn] r440 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200809061524.m86FOaJj015819@sheep.berlios.de>

Author: frohlich
Date: 2008-09-06 17:24:36 +0200 (Sat, 06 Sep 2008)
New Revision: 440

Modified:
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Add some debug code. Move around code where it fits better.


Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-06 11:13:44 UTC (rev 439)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-06 15:24:36 UTC (rev 440)
@@ -118,8 +118,15 @@
     SharedPtr<LeafInstance> getLeafInstance() const
     { return mLeafInstance.lock(); }
 
+    const SharedPtr<const PortInfo>& getPortInfo() const
+    { return mPortInfo; }
+
     virtual bool connect(PortData*) = 0;
+    virtual bool merge(PortData*) = 0;
 
+    virtual void print()
+    { }
+
   private:
     WeakPtr<LeafInstance> mLeafInstance;
     SharedPtr<const PortInfo> mPortInfo;
@@ -144,7 +151,36 @@
       return acceptorPortData->connectToProvider(this);
     }
 
-  public:
+    virtual bool merge(PortData* portData)
+    {
+      if (!portData)
+        return false;
+      AcceptorPortData* acceptorPortData = portData->toAcceptorPortData();
+      if (!acceptorPortData)
+        return false;
+      SharedPtr<const LeafInstance::ProviderPortData> providerPortData;
+      providerPortData = acceptorPortData->_providerPortData.lock();
+      OpenFDMAssert(providerPortData);
+      _providerPort = providerPortData->_providerPort;
+    }
+
+    virtual void print()
+    {
+      std::cout << "  Provider Port \"" << getPortInfo()->getName()
+                << "\" connected to:" << std::endl;
+      for (unsigned i = 0; i < _acceptorPortDataList.size(); ++i) {
+        SharedPtr<const AcceptorPortData> acceptorPortData;
+        acceptorPortData = _acceptorPortDataList[i].lock();
+        if (!acceptorPortData)
+          continue;
+        SharedPtr<LeafInstance> leafInstance;
+        leafInstance = acceptorPortData->getLeafInstance();
+        std::cout << "    Node \"" << leafInstance->getLeafNode()->getName()
+                  << "\" Port \"" << acceptorPortData->getPortInfo()->getName()
+                  << "\"" << std::endl;
+      }
+    }
+
     SharedPtr<const ProviderPortInfo> _providerPort;
     std::vector<WeakPtr<const AcceptorPortData> > _acceptorPortDataList;
   };
@@ -176,8 +212,43 @@
       _providerPortData = providerPortData;
       return true;
     }
-  public:
 
+    virtual bool merge(PortData* portData)
+    {
+      if (!portData)
+        return false;
+      ProviderPortData* providerPortData = portData->toProviderPortData();
+      if (!providerPortData)
+        return false;
+
+      for (unsigned i = 0; i < providerPortData->_acceptorPortDataList.size(); ++i) {
+        SharedPtr<const LeafInstance::AcceptorPortData> acceptorPortData;
+        acceptorPortData = providerPortData->_acceptorPortDataList[i].lock();
+        OpenFDMAssert(acceptorPortData);
+        for (unsigned j = 0; j < _acceptorPortList.size(); ++j) {
+          _acceptorPortList.push_back(acceptorPortData->_acceptorPortList[j]);
+        }
+      }
+    }
+
+    virtual void print()
+    {
+      // FIXME: seems to be a list???
+      std::cout << "  Acceptor Port \"" << getPortInfo()->getName()
+                << "\" connected from:" << std::endl;
+
+      SharedPtr<const ProviderPortData> providerPortData;
+      providerPortData = _providerPortData.lock();
+      if (!providerPortData)
+        return;
+ 
+      SharedPtr<LeafInstance> leafInstance;
+      leafInstance = providerPortData->getLeafInstance();
+      std::cout << "    Node \"" << leafInstance->getLeafNode()->getName()
+                << "\" Port \"" << providerPortData->getPortInfo()->getName()
+                << "\"" << std::endl;
+    }
+
     std::vector<SharedPtr<const AcceptorPortInfo> > _acceptorPortList;
     WeakPtr<const ProviderPortData> _providerPortData;
   };
@@ -196,14 +267,18 @@
     OpenFDMAssert(index < mPortData.size());
     return mPortData[index];
   }
-  AcceptorPortData* getAcceptorPortData(const PortId& portId)
-  { return getPortData(portId)->toAcceptorPortData(); }
-  ProviderPortData* getProviderPortData(const PortId& portId)
-  { return getPortData(portId)->toProviderPortData(); }
 
   const SharedPtr<const LeafNode>& getLeafNode() const
   { return mLeafNode; }
 
+  void print()
+  {
+    std::cout << "Leaf \"" << mLeafNode->getName() << "\"" << std::endl;
+    for (unsigned i = 0; i < mPortData.size(); ++i) {
+      mPortData[i]->print();
+    }
+  }
+
 private:
   void allocPorts(const Node* node)
   {
@@ -239,10 +314,9 @@
   {
     OpenFDMAssert(leaf.getPort(0));
     PortId portId = leaf.getPortId(0);
-    _leafPortDataMap[getCurrentNodeId()][portId]._acceptorPortData = 0;
     LeafInstance::ProviderPortData* pd
       = new LeafInstance::ProviderPortData(0, leaf._groupInternalPort);
-    _leafPortDataMap[getCurrentNodeId()][portId]._providerPortData = pd;
+    _leafPortDataMap[getCurrentNodeId()][portId].setPortData(pd);
   }
   // Aussen provider, innen acceptor
   virtual void apply(GroupProviderNode& leaf)
@@ -251,8 +325,7 @@
     PortId portId = leaf.getPortId(0);
     LeafInstance::AcceptorPortData* ad
       = new LeafInstance::AcceptorPortData(0, leaf._groupInternalPort);
-    _leafPortDataMap[getCurrentNodeId()][portId]._acceptorPortData = ad;
-    _leafPortDataMap[getCurrentNodeId()][portId]._providerPortData = 0;
+    _leafPortDataMap[getCurrentNodeId()][portId].setPortData(ad);
   }
   virtual void apply(LeafNode& leaf)
   {
@@ -263,10 +336,8 @@
 
     for (unsigned i = 0; i < leaf.getNumPorts(); ++i) {
       PortId portId = leaf.getPortId(i);
-      _leafPortDataMap[getCurrentNodeId()][portId]._acceptorPortData
-        = leafInstance->getAcceptorPortData(portId);
-      _leafPortDataMap[getCurrentNodeId()][portId]._providerPortData
-        = leafInstance->getProviderPortData(portId);
+      LeafInstance::PortData* portData = leafInstance->getPortData(portId);
+      _leafPortDataMap[getCurrentNodeId()][portId].setPortData(portData);
     }
   }
   virtual void apply(Group& group)
@@ -319,21 +390,8 @@
         continue;
       }
 
-      LeafInstance::AcceptorPortData* acceptorPortData =
-        _leafPortDataMap[acceptorNodeId][acceptorPortId]._acceptorPortData;
-      LeafInstance::ProviderPortData* providerPortData =
-        _leafPortDataMap[providerNodeId][providerPortId]._providerPortData;
-
-      if (!acceptorPortData) {
-        std::cout << "Cannot find acceptor Port data" << std::endl;
-        continue;
-      }
-      if (!providerPortData) {
-        std::cout << "Cannot find provider Port data" << std::endl;
-        continue;
-      }
-
-      if (!acceptorPortData->connect(providerPortData))
+      if (!_leafPortDataMap[acceptorNodeId][acceptorPortId].
+          connect(_leafPortDataMap[providerNodeId][providerPortId]))
         std::cerr << "Cannot connect????" << std::endl;
     }
 
@@ -346,12 +404,16 @@
     for (unsigned i = 0; i < group.getNumPorts(); ++i) {
       PortId portId = group.getPortId(i);
       Group::NodeId nodeId = group.getGroupPortNode(portId);
-      if (group.getPort(i)->toAcceptorPortInfo())
-        parentLeafPortDataMap[getCurrentNodeId()][portId]._acceptorPortData
-          = new LeafInstance::AcceptorPortData(0, group.getPort(i)->toAcceptorPortInfo());
-      if (group.getPort(i)->toProviderPortInfo())
-        parentLeafPortDataMap[getCurrentNodeId()][portId]._providerPortData
-          = new LeafInstance::ProviderPortData(0, group.getPort(i)->toProviderPortInfo());
+      if (group.getPort(i)->toAcceptorPortInfo()) {
+        LeafInstance::AcceptorPortData* ad;
+        ad = new LeafInstance::AcceptorPortData(0, group.getPort(i)->toAcceptorPortInfo());
+        parentLeafPortDataMap[getCurrentNodeId()][portId].setPortData(ad);
+      }
+      if (group.getPort(i)->toProviderPortInfo()) {
+        LeafInstance::ProviderPortData* pd;
+        pd = new LeafInstance::ProviderPortData(0, group.getPort(i)->toProviderPortInfo());
+        parentLeafPortDataMap[getCurrentNodeId()][portId].setPortData(pd);
+      }
 
       if (_leafPortDataMap[nodeId].empty()) {
         // FIXME, is this an internal error ???
@@ -359,8 +421,10 @@
                   << i << std::endl;
         continue;
       }
-      parentLeafPortDataMap[getCurrentNodeId()][portId].
-        merge(_leafPortDataMap[nodeId].begin()->second);
+
+      if (!parentLeafPortDataMap[getCurrentNodeId()][portId].
+          merge(_leafPortDataMap[nodeId].begin()->second))
+        std::cerr << "Hmm, cannot merge port data" << std::endl;
     }
 
     parentLeafPortDataMap.swap(_leafPortDataMap);
@@ -373,44 +437,25 @@
 
   ////////////////////////////////////////////////////////////////////////////
   // Used to map connections in groups ...
-  struct PortData {
-    SharedPtr<LeafInstance::ProviderPortData> _providerPortData;
-    SharedPtr<LeafInstance::AcceptorPortData> _acceptorPortData;
+  struct PortDataRef {
+    void setPortData(LeafInstance::PortData* portData)
+    {
+      _portData = portData;
+    }
+    bool connect(PortDataRef& other)
+    { return _portData->connect(other._portData); }
 
     // Merge the argument from the child group into the current groups data
-    void merge(const PortData& portData)
-    {
-      if (_providerPortData) {
-        OpenFDMAssert(portData._acceptorPortData);
-        SharedPtr<const LeafInstance::ProviderPortData> providerPortData =
-          portData._acceptorPortData->_providerPortData.lock();
-        OpenFDMAssert(providerPortData);
-        _providerPortData->_providerPort = providerPortData->_providerPort;
-      }
-
-      if (_acceptorPortData) {
-        OpenFDMAssert(portData._providerPortData);
-        for (unsigned i = 0;
-             i < portData._providerPortData->_acceptorPortDataList.size();
-             ++i) {
-          SharedPtr<const LeafInstance::AcceptorPortData> acceptorPortData =
-            portData._providerPortData->_acceptorPortDataList[i].lock();
-          
-          OpenFDMAssert(acceptorPortData);
-          for (unsigned j = 0;
-               j < acceptorPortData->_acceptorPortList.size(); ++j) {
-            _acceptorPortData->_acceptorPortList.
-              push_back(acceptorPortData->_acceptorPortList[j]);
-          }
-        }
-      }
-    }
+    bool merge(const PortDataRef& portData)
+    { return _portData->merge(portData._portData); }
+  private:
+    SharedPtr<LeafInstance::PortData> _portData;
   };
-  typedef std::map<PortId, PortData> NodePortDataMap;
+  typedef std::map<PortId, PortDataRef> NodePortDataMap;
+//   typedef std::map<PortId, SharedPtr<LeafInstance::PortData> > NodePortDataMap;
   typedef std::map<Group::NodeId, NodePortDataMap> LeafPortDataMap;
   LeafPortDataMap _leafPortDataMap;
 
-
   void pushNodeId(const Group::NodeId& nodeId)
   { _nodeIdStack.push_back(nodeId); }
   void popNodeId()
@@ -473,7 +518,7 @@
   for (i = nodeInstanceCollector._leafInstanceList.begin();
        i != nodeInstanceCollector._leafInstanceList.end();
        ++i) {
-    std::cout << "Node: " << (*i)->getLeafNode()->getName() << std::endl;
+    (*i)->print();
   }
 
   return 0;



From frohlich at mail.berlios.de  Sat Sep  6 17:26:13 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 6 Sep 2008 17:26:13 +0200
Subject: [OpenFDM-svn] r441 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200809061526.m86FQDCO016097@sheep.berlios.de>

Author: frohlich
Date: 2008-09-06 17:26:13 +0200 (Sat, 06 Sep 2008)
New Revision: 441

Modified:
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Remove intermediate data structure just containing a single pointer.


Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-06 15:24:36 UTC (rev 440)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-06 15:26:13 UTC (rev 441)
@@ -316,7 +316,7 @@
     PortId portId = leaf.getPortId(0);
     LeafInstance::ProviderPortData* pd
       = new LeafInstance::ProviderPortData(0, leaf._groupInternalPort);
-    _leafPortDataMap[getCurrentNodeId()][portId].setPortData(pd);
+    _leafPortDataMap[getCurrentNodeId()][portId] = pd;
   }
   // Aussen provider, innen acceptor
   virtual void apply(GroupProviderNode& leaf)
@@ -325,7 +325,7 @@
     PortId portId = leaf.getPortId(0);
     LeafInstance::AcceptorPortData* ad
       = new LeafInstance::AcceptorPortData(0, leaf._groupInternalPort);
-    _leafPortDataMap[getCurrentNodeId()][portId].setPortData(ad);
+    _leafPortDataMap[getCurrentNodeId()][portId] = ad;
   }
   virtual void apply(LeafNode& leaf)
   {
@@ -337,7 +337,7 @@
     for (unsigned i = 0; i < leaf.getNumPorts(); ++i) {
       PortId portId = leaf.getPortId(i);
       LeafInstance::PortData* portData = leafInstance->getPortData(portId);
-      _leafPortDataMap[getCurrentNodeId()][portId].setPortData(portData);
+      _leafPortDataMap[getCurrentNodeId()][portId] = portData;
     }
   }
   virtual void apply(Group& group)
@@ -390,7 +390,7 @@
         continue;
       }
 
-      if (!_leafPortDataMap[acceptorNodeId][acceptorPortId].
+      if (!_leafPortDataMap[acceptorNodeId][acceptorPortId]->
           connect(_leafPortDataMap[providerNodeId][providerPortId]))
         std::cerr << "Cannot connect????" << std::endl;
     }
@@ -407,12 +407,12 @@
       if (group.getPort(i)->toAcceptorPortInfo()) {
         LeafInstance::AcceptorPortData* ad;
         ad = new LeafInstance::AcceptorPortData(0, group.getPort(i)->toAcceptorPortInfo());
-        parentLeafPortDataMap[getCurrentNodeId()][portId].setPortData(ad);
+        parentLeafPortDataMap[getCurrentNodeId()][portId] = ad;
       }
       if (group.getPort(i)->toProviderPortInfo()) {
         LeafInstance::ProviderPortData* pd;
         pd = new LeafInstance::ProviderPortData(0, group.getPort(i)->toProviderPortInfo());
-        parentLeafPortDataMap[getCurrentNodeId()][portId].setPortData(pd);
+        parentLeafPortDataMap[getCurrentNodeId()][portId] = pd;
       }
 
       if (_leafPortDataMap[nodeId].empty()) {
@@ -422,7 +422,7 @@
         continue;
       }
 
-      if (!parentLeafPortDataMap[getCurrentNodeId()][portId].
+      if (!parentLeafPortDataMap[getCurrentNodeId()][portId]->
           merge(_leafPortDataMap[nodeId].begin()->second))
         std::cerr << "Hmm, cannot merge port data" << std::endl;
     }
@@ -437,22 +437,7 @@
 
   ////////////////////////////////////////////////////////////////////////////
   // Used to map connections in groups ...
-  struct PortDataRef {
-    void setPortData(LeafInstance::PortData* portData)
-    {
-      _portData = portData;
-    }
-    bool connect(PortDataRef& other)
-    { return _portData->connect(other._portData); }
-
-    // Merge the argument from the child group into the current groups data
-    bool merge(const PortDataRef& portData)
-    { return _portData->merge(portData._portData); }
-  private:
-    SharedPtr<LeafInstance::PortData> _portData;
-  };
-  typedef std::map<PortId, PortDataRef> NodePortDataMap;
-//   typedef std::map<PortId, SharedPtr<LeafInstance::PortData> > NodePortDataMap;
+  typedef std::map<PortId, SharedPtr<LeafInstance::PortData> > NodePortDataMap;
   typedef std::map<Group::NodeId, NodePortDataMap> LeafPortDataMap;
   LeafPortDataMap _leafPortDataMap;
 



From frohlich at mail.berlios.de  Sat Sep  6 17:40:24 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 6 Sep 2008 17:40:24 +0200
Subject: [OpenFDM-svn] r442 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200809061540.m86FeOFk018314@sheep.berlios.de>

Author: frohlich
Date: 2008-09-06 17:40:24 +0200 (Sat, 06 Sep 2008)
New Revision: 442

Modified:
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Cosmetic changes.


Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-06 15:26:13 UTC (rev 441)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-06 15:40:24 UTC (rev 442)
@@ -161,7 +161,14 @@
       SharedPtr<const LeafInstance::ProviderPortData> providerPortData;
       providerPortData = acceptorPortData->_providerPortData.lock();
       OpenFDMAssert(providerPortData);
+
+      // FIXME: think about that. Not yet completely functional
+
       _providerPort = providerPortData->_providerPort;
+      // Merge must happen before the group this PortData belongs to is
+      // connected
+      OpenFDMAssert(_acceptorPortDataList.empty());
+      _acceptorPortDataList = providerPortData->_acceptorPortDataList;
     }
 
     virtual void print()
@@ -221,7 +228,14 @@
       if (!providerPortData)
         return false;
 
-      for (unsigned i = 0; i < providerPortData->_acceptorPortDataList.size(); ++i) {
+      // FIXME: think about that. Not yet completely functional
+
+      // Merge must happen before the group this PortData belongs to is
+      // connected
+      OpenFDMAssert(!_providerPortData.lock());
+
+      unsigned i = 0;
+      for (i = 0; i < providerPortData->_acceptorPortDataList.size(); ++i) {
         SharedPtr<const LeafInstance::AcceptorPortData> acceptorPortData;
         acceptorPortData = providerPortData->_acceptorPortDataList[i].lock();
         OpenFDMAssert(acceptorPortData);
@@ -314,8 +328,8 @@
   {
     OpenFDMAssert(leaf.getPort(0));
     PortId portId = leaf.getPortId(0);
-    LeafInstance::ProviderPortData* pd
-      = new LeafInstance::ProviderPortData(0, leaf._groupInternalPort);
+    LeafInstance::ProviderPortData* pd;
+    pd = new LeafInstance::ProviderPortData(0, leaf._groupInternalPort);
     _leafPortDataMap[getCurrentNodeId()][portId] = pd;
   }
   // Aussen provider, innen acceptor
@@ -323,8 +337,8 @@
   {
     OpenFDMAssert(leaf.getPort(0));
     PortId portId = leaf.getPortId(0);
-    LeafInstance::AcceptorPortData* ad
-      = new LeafInstance::AcceptorPortData(0, leaf._groupInternalPort);
+    LeafInstance::AcceptorPortData* ad;
+    ad = new LeafInstance::AcceptorPortData(0, leaf._groupInternalPort);
     _leafPortDataMap[getCurrentNodeId()][portId] = ad;
   }
   virtual void apply(LeafNode& leaf)



From frohlich at mail.berlios.de  Mon Sep  8 05:58:22 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Mon, 8 Sep 2008 05:58:22 +0200
Subject: [OpenFDM-svn] r443 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200809080358.m883wM5v017132@sheep.berlios.de>

Author: frohlich
Date: 2008-09-08 05:58:21 +0200 (Mon, 08 Sep 2008)
New Revision: 443

Modified:
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Make group connects work.


Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-06 15:40:24 UTC (rev 442)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-08 03:58:21 UTC (rev 443)
@@ -100,6 +100,7 @@
 public:
   struct AcceptorPortData;
   struct ProviderPortData;
+  struct ProxyPortData;
 
   class PortData : public WeakReferenced {
   public:
@@ -113,6 +114,8 @@
     { return 0; }
     virtual ProviderPortData* toProviderPortData()
     { return 0; }
+    virtual ProxyPortData* toProxyPortData()
+    { return 0; }
     
     /// Return the LeafInstance this PortData belongs to.
     SharedPtr<LeafInstance> getLeafInstance() const
@@ -122,7 +125,6 @@
     { return mPortInfo; }
 
     virtual bool connect(PortData*) = 0;
-    virtual bool merge(PortData*) = 0;
 
     virtual void print()
     { }
@@ -145,38 +147,21 @@
     {
       if (!portData)
         return false;
+      ProxyPortData* proxyPortData = portData->toProxyPortData();
+      if (proxyPortData)
+        return proxyPortData->connect(this);
       AcceptorPortData* acceptorPortData = portData->toAcceptorPortData();
       if (!acceptorPortData)
         return false;
       return acceptorPortData->connectToProvider(this);
     }
 
-    virtual bool merge(PortData* portData)
-    {
-      if (!portData)
-        return false;
-      AcceptorPortData* acceptorPortData = portData->toAcceptorPortData();
-      if (!acceptorPortData)
-        return false;
-      SharedPtr<const LeafInstance::ProviderPortData> providerPortData;
-      providerPortData = acceptorPortData->_providerPortData.lock();
-      OpenFDMAssert(providerPortData);
-
-      // FIXME: think about that. Not yet completely functional
-
-      _providerPort = providerPortData->_providerPort;
-      // Merge must happen before the group this PortData belongs to is
-      // connected
-      OpenFDMAssert(_acceptorPortDataList.empty());
-      _acceptorPortDataList = providerPortData->_acceptorPortDataList;
-    }
-
     virtual void print()
     {
       std::cout << "  Provider Port \"" << getPortInfo()->getName()
                 << "\" connected to:" << std::endl;
       for (unsigned i = 0; i < _acceptorPortDataList.size(); ++i) {
-        SharedPtr<const AcceptorPortData> acceptorPortData;
+        SharedPtr<AcceptorPortData> acceptorPortData;
         acceptorPortData = _acceptorPortDataList[i].lock();
         if (!acceptorPortData)
           continue;
@@ -189,13 +174,14 @@
     }
 
     SharedPtr<const ProviderPortInfo> _providerPort;
-    std::vector<WeakPtr<const AcceptorPortData> > _acceptorPortDataList;
+    std::vector<WeakPtr<AcceptorPortData> > _acceptorPortDataList;
   };
   struct AcceptorPortData : public PortData {
     AcceptorPortData(LeafInstance* leafInstance,
                      const AcceptorPortInfo* acceptorPort) :
-      PortData(leafInstance, acceptorPort)
-    { _acceptorPortList.push_back(acceptorPort); }
+      PortData(leafInstance, acceptorPort),
+      _acceptorPort(acceptorPort)
+    { }
     virtual AcceptorPortData* toAcceptorPortData()
     { return this; }
 
@@ -203,6 +189,9 @@
     {
       if (!portData)
         return false;
+      ProxyPortData* proxyPortData = portData->toProxyPortData();
+      if (proxyPortData)
+        return proxyPortData->connect(this);
       ProviderPortData* providerPortData = portData->toProviderPortData();
       if (!providerPortData)
         return false;
@@ -220,38 +209,12 @@
       return true;
     }
 
-    virtual bool merge(PortData* portData)
-    {
-      if (!portData)
-        return false;
-      ProviderPortData* providerPortData = portData->toProviderPortData();
-      if (!providerPortData)
-        return false;
-
-      // FIXME: think about that. Not yet completely functional
-
-      // Merge must happen before the group this PortData belongs to is
-      // connected
-      OpenFDMAssert(!_providerPortData.lock());
-
-      unsigned i = 0;
-      for (i = 0; i < providerPortData->_acceptorPortDataList.size(); ++i) {
-        SharedPtr<const LeafInstance::AcceptorPortData> acceptorPortData;
-        acceptorPortData = providerPortData->_acceptorPortDataList[i].lock();
-        OpenFDMAssert(acceptorPortData);
-        for (unsigned j = 0; j < _acceptorPortList.size(); ++j) {
-          _acceptorPortList.push_back(acceptorPortData->_acceptorPortList[j]);
-        }
-      }
-    }
-
     virtual void print()
     {
-      // FIXME: seems to be a list???
       std::cout << "  Acceptor Port \"" << getPortInfo()->getName()
                 << "\" connected from:" << std::endl;
 
-      SharedPtr<const ProviderPortData> providerPortData;
+      SharedPtr<ProviderPortData> providerPortData;
       providerPortData = _providerPortData.lock();
       if (!providerPortData)
         return;
@@ -263,11 +226,47 @@
                 << "\"" << std::endl;
     }
 
-    std::vector<SharedPtr<const AcceptorPortInfo> > _acceptorPortList;
-    WeakPtr<const ProviderPortData> _providerPortData;
+    SharedPtr<const AcceptorPortInfo> _acceptorPort;
+    WeakPtr<ProviderPortData> _providerPortData;
   };
 
+  // Hmm, an other idea. How about treating the group input/output block
+  // as a regular block with inputs and outputs?
+  // Then in the output routine do nothing and just connect the PortValues of
+  // the inputs directly to the PortValues of the outputs??
+  // That would at least make the Proxy stuff simpler??
 
+  class ProxyPortData : public PortData {
+  public:
+    ProxyPortData(PortData* portData) :
+      PortData(0, 0)
+    {
+      if (!portData)
+        return;
+      AcceptorPortData* acceptorPortData = portData->toAcceptorPortData();
+      if (acceptorPortData) {
+        mPortDataList.push_back(acceptorPortData->_providerPortData.lock());
+      }
+      ProviderPortData* providerPortData = portData->toProviderPortData();
+      if (providerPortData) {
+        unsigned i;
+        for (i = 0; i < providerPortData->_acceptorPortDataList.size(); ++i) {
+          mPortDataList.push_back(providerPortData->_acceptorPortDataList[i].lock());
+        }
+      }
+    }
+    virtual ProxyPortData* toProxyPortData()
+    { return this; }
+    virtual bool connect(PortData* portData)
+    {
+      for (unsigned i = 0; i < mPortDataList.size(); ++i) {
+        if (!mPortDataList[i]->connect(portData))
+          return false;
+      }
+      return true;
+    }
+    std::vector<SharedPtr<PortData> > mPortDataList;
+  };
 
   LeafInstance(const LeafNode* leaf) :
     mLeafNode(leaf)
@@ -418,17 +417,6 @@
     for (unsigned i = 0; i < group.getNumPorts(); ++i) {
       PortId portId = group.getPortId(i);
       Group::NodeId nodeId = group.getGroupPortNode(portId);
-      if (group.getPort(i)->toAcceptorPortInfo()) {
-        LeafInstance::AcceptorPortData* ad;
-        ad = new LeafInstance::AcceptorPortData(0, group.getPort(i)->toAcceptorPortInfo());
-        parentLeafPortDataMap[getCurrentNodeId()][portId] = ad;
-      }
-      if (group.getPort(i)->toProviderPortInfo()) {
-        LeafInstance::ProviderPortData* pd;
-        pd = new LeafInstance::ProviderPortData(0, group.getPort(i)->toProviderPortInfo());
-        parentLeafPortDataMap[getCurrentNodeId()][portId] = pd;
-      }
-
       if (_leafPortDataMap[nodeId].empty()) {
         // FIXME, is this an internal error ???
         std::cerr << "Hmm, cannot find GroupPortNode for external port "
@@ -436,9 +424,8 @@
         continue;
       }
 
-      if (!parentLeafPortDataMap[getCurrentNodeId()][portId]->
-          merge(_leafPortDataMap[nodeId].begin()->second))
-        std::cerr << "Hmm, cannot merge port data" << std::endl;
+      parentLeafPortDataMap[getCurrentNodeId()][portId] = 
+          new LeafInstance::ProxyPortData(_leafPortDataMap[nodeId].begin()->second);
     }
 
     parentLeafPortDataMap.swap(_leafPortDataMap);



From frohlich at mail.berlios.de  Mon Sep  8 06:53:20 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Mon, 8 Sep 2008 06:53:20 +0200
Subject: [OpenFDM-svn] r444 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200809080453.m884rK6E019066@sheep.berlios.de>

Author: frohlich
Date: 2008-09-08 06:53:19 +0200 (Mon, 08 Sep 2008)
New Revision: 444

Modified:
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Sort the list of leafs.


Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-08 03:58:21 UTC (rev 443)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-08 04:53:19 UTC (rev 444)
@@ -125,6 +125,8 @@
     { return mPortInfo; }
 
     virtual bool connect(PortData*) = 0;
+    virtual bool isConnected(PortData*)
+    { return false; }
 
     virtual void print()
     { }
@@ -156,6 +158,16 @@
       return acceptorPortData->connectToProvider(this);
     }
 
+    virtual bool isConnected(PortData* portData)
+    {
+      if (!portData)
+        return false;
+      AcceptorPortData* acceptorPortData = portData->toAcceptorPortData();
+      if (!acceptorPortData)
+        return false;
+      return acceptorPortData->isConnectedToProvider(this);
+    }
+
     virtual void print()
     {
       std::cout << "  Provider Port \"" << getPortInfo()->getName()
@@ -209,6 +221,23 @@
       return true;
     }
 
+    virtual bool isConnected(PortData* portData)
+    {
+      if (!portData)
+        return false;
+      ProviderPortData* providerPortData = portData->toProviderPortData();
+      if (!providerPortData)
+        return false;
+      return isConnectedToProvider(providerPortData);
+    }
+
+    bool isConnectedToProvider(ProviderPortData* providerPortData)
+    {
+      if (!providerPortData)
+        return false;
+      return providerPortData == _providerPortData.lock();
+    }
+
     virtual void print()
     {
       std::cout << "  Acceptor Port \"" << getPortInfo()->getName()
@@ -265,6 +294,11 @@
       }
       return true;
     }
+    // FIXME, make class hierarchy so that this cannot happen anyway ...
+    // Make the leaf instance have a pointer to a leaf port data and just use
+    // the proxy stuff to build the leaf list ...
+    virtual bool isConnected(PortData* portData)
+    { OpenFDMAssert(false); return false; }
     std::vector<SharedPtr<PortData> > mPortDataList;
   };
 
@@ -284,6 +318,27 @@
   const SharedPtr<const LeafNode>& getLeafNode() const
   { return mLeafNode; }
 
+  // Return true if this leaf directly depends on one of leafInstance outputs
+  bool dependsOn(LeafInstance* leafInstance)
+  {
+    for (unsigned i = 0; i < mPortData.size(); ++i) {
+      for (unsigned j = 0; j < leafInstance->mPortData.size(); ++j) {
+        if (!mPortData[i]->isConnected(leafInstance->mPortData[j]))
+          continue;
+        PortId inPortId = mLeafNode->getPortId(i);
+
+        // FIXME, may be other concept:
+        // make Model return a list of 'direct feedthrough ports'?
+        for (unsigned k = 0; k < mPortData.size(); ++k) {
+          PortId outPortId = mLeafNode->getPortId(k);
+          if (mLeafNode->dependsOn(inPortId, outPortId))
+            return true;
+        }
+      }
+    }
+    return false;
+  }
+
   void print()
   {
     std::cout << "Leaf \"" << mLeafNode->getName() << "\"" << std::endl;
@@ -442,6 +497,31 @@
   typedef std::map<Group::NodeId, NodePortDataMap> LeafPortDataMap;
   LeafPortDataMap _leafPortDataMap;
 
+
+  // method to sort the leafs according to their dependency
+  bool sortLeafList()
+  {
+    LeafInstanceList sortedLeafInstanceList;
+    while (!_leafInstanceList.empty()) {
+      SharedPtr<LeafInstance> leafInstance = _leafInstanceList.front();
+      _leafInstanceList.pop_front();
+
+      LeafInstanceList::iterator i;
+      for (i = sortedLeafInstanceList.begin();
+           i != sortedLeafInstanceList.end();
+           ++i) {
+        if (!(*i)->dependsOn(leafInstance))
+          continue;
+        sortedLeafInstanceList.insert(i, leafInstance);
+        break;
+      }
+      if (i == sortedLeafInstanceList.end())
+        sortedLeafInstanceList.push_back(leafInstance);
+    }
+    _leafInstanceList.swap(sortedLeafInstanceList);
+  }
+
+  
   void pushNodeId(const Group::NodeId& nodeId)
   { _nodeIdStack.push_back(nodeId); }
   void popNodeId()
@@ -498,6 +578,8 @@
   LeafInstanceCollector nodeInstanceCollector;
   topGroup->accept(nodeInstanceCollector);
   
+  nodeInstanceCollector.sortLeafList();
+
   std::cout << nodeInstanceCollector._leafInstanceList.size() << std::endl;
 
   LeafInstanceCollector::LeafInstanceList::const_iterator i;



From frohlich at mail.berlios.de  Mon Sep  8 07:09:44 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Mon, 8 Sep 2008 07:09:44 +0200
Subject: [OpenFDM-svn] r445 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200809080509.m8859iau006124@sheep.berlios.de>

Author: frohlich
Date: 2008-09-08 07:09:43 +0200 (Mon, 08 Sep 2008)
New Revision: 445

Modified:
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Introduce additional PortData class type to remove one FIXME ...


Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-08 04:53:19 UTC (rev 444)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-08 05:09:43 UTC (rev 445)
@@ -98,34 +98,44 @@
 
 class LeafInstance : public WeakReferenced {
 public:
+  struct LeafPortData;
   struct AcceptorPortData;
   struct ProviderPortData;
   struct ProxyPortData;
 
   class PortData : public WeakReferenced {
   public:
-    PortData(LeafInstance* leafInstance, const PortInfo* portInfo) :
-      mLeafInstance(leafInstance),
-      mPortInfo(portInfo)
-    { }
     virtual ~PortData() {}
-
+    virtual LeafPortData* toLeafPortData()
+    { return 0; }
+    virtual ProxyPortData* toProxyPortData()
+    { return 0; }
     virtual AcceptorPortData* toAcceptorPortData()
     { return 0; }
     virtual ProviderPortData* toProviderPortData()
     { return 0; }
-    virtual ProxyPortData* toProxyPortData()
-    { return 0; }
+    virtual bool connect(PortData*) = 0;
+  };
+
+  class LeafPortData : public PortData {
+  public:
+    LeafPortData(LeafInstance* leafInstance, const PortInfo* portInfo) :
+      mLeafInstance(leafInstance),
+      mPortInfo(portInfo)
+    { }
+    virtual ~LeafPortData() {}
+
+    virtual LeafPortData* toLeafPortData()
+    { return this; }
     
-    /// Return the LeafInstance this PortData belongs to.
+    /// Return the LeafInstance this LeafPortData belongs to.
     SharedPtr<LeafInstance> getLeafInstance() const
     { return mLeafInstance.lock(); }
 
     const SharedPtr<const PortInfo>& getPortInfo() const
     { return mPortInfo; }
 
-    virtual bool connect(PortData*) = 0;
-    virtual bool isConnected(PortData*)
+    virtual bool isConnected(LeafPortData*)
     { return false; }
 
     virtual void print()
@@ -136,10 +146,10 @@
     SharedPtr<const PortInfo> mPortInfo;
   };
 
-  struct ProviderPortData : public PortData {
+  struct ProviderPortData : public LeafPortData {
     ProviderPortData(LeafInstance* leafInstance,
                      const ProviderPortInfo* providerPort) :
-      PortData(leafInstance, providerPort),
+      LeafPortData(leafInstance, providerPort),
       _providerPort(providerPort)
     { }
     virtual ProviderPortData* toProviderPortData()
@@ -158,7 +168,7 @@
       return acceptorPortData->connectToProvider(this);
     }
 
-    virtual bool isConnected(PortData* portData)
+    virtual bool isConnected(LeafPortData* portData)
     {
       if (!portData)
         return false;
@@ -188,10 +198,10 @@
     SharedPtr<const ProviderPortInfo> _providerPort;
     std::vector<WeakPtr<AcceptorPortData> > _acceptorPortDataList;
   };
-  struct AcceptorPortData : public PortData {
+  struct AcceptorPortData : public LeafPortData {
     AcceptorPortData(LeafInstance* leafInstance,
                      const AcceptorPortInfo* acceptorPort) :
-      PortData(leafInstance, acceptorPort),
+      LeafPortData(leafInstance, acceptorPort),
       _acceptorPort(acceptorPort)
     { }
     virtual AcceptorPortData* toAcceptorPortData()
@@ -221,7 +231,7 @@
       return true;
     }
 
-    virtual bool isConnected(PortData* portData)
+    virtual bool isConnected(LeafPortData* portData)
     {
       if (!portData)
         return false;
@@ -267,8 +277,7 @@
 
   class ProxyPortData : public PortData {
   public:
-    ProxyPortData(PortData* portData) :
-      PortData(0, 0)
+    ProxyPortData(PortData* portData)
     {
       if (!portData)
         return;
@@ -294,11 +303,6 @@
       }
       return true;
     }
-    // FIXME, make class hierarchy so that this cannot happen anyway ...
-    // Make the leaf instance have a pointer to a leaf port data and just use
-    // the proxy stuff to build the leaf list ...
-    virtual bool isConnected(PortData* portData)
-    { OpenFDMAssert(false); return false; }
     std::vector<SharedPtr<PortData> > mPortDataList;
   };
 
@@ -306,7 +310,7 @@
     mLeafNode(leaf)
   { allocPorts(leaf); }
 
-  PortData* getPortData(const PortId& portId)
+  LeafPortData* getPortData(const PortId& portId)
   {
     OpenFDMAssert(getLeafNode());
     unsigned index = getLeafNode()->getPortIndex(portId);
@@ -366,7 +370,7 @@
 
   // List of port dependent info used to build up the connect info and
   // the sorted list of leafs.
-  std::vector<SharedPtr<PortData> > mPortData;
+  std::vector<SharedPtr<LeafPortData> > mPortData;
 };
 
 class LeafInstanceCollector : public NodeVisitor {
@@ -404,7 +408,7 @@
 
     for (unsigned i = 0; i < leaf.getNumPorts(); ++i) {
       PortId portId = leaf.getPortId(i);
-      LeafInstance::PortData* portData = leafInstance->getPortData(portId);
+      LeafInstance::LeafPortData* portData = leafInstance->getPortData(portId);
       _leafPortDataMap[getCurrentNodeId()][portId] = portData;
     }
   }



From frohlich at mail.berlios.de  Mon Sep  8 21:26:08 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Mon, 8 Sep 2008 21:26:08 +0200
Subject: [OpenFDM-svn] r446 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200809081926.m88JQ8F0002281@sheep.berlios.de>

Author: frohlich
Date: 2008-09-08 21:26:01 +0200 (Mon, 08 Sep 2008)
New Revision: 446

Added:
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicPortValue.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicPortValue.h
Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
Log:
Add MechanicPortValue.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-09-08 05:09:43 UTC (rev 445)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-09-08 19:26:01 UTC (rev 446)
@@ -49,6 +49,7 @@
   MatrixStateValue.h \
   MatrixStateInfo.h \
   MidpointRule.h \
+  MechanicPortValue.h \
   Model.h \
   Mutex.h \
   MPFRFloat.h \
@@ -112,6 +113,7 @@
   LeafNode.cpp \
   Logger.cpp \
   MatrixStateValue.cpp \
+  MechanicPortValue.cpp \
   Model.cpp \
   Node.cpp \
   NodeVisitor.cpp \

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicPortValue.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicPortValue.cpp	2008-09-08 05:09:43 UTC (rev 445)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicPortValue.cpp	2008-09-08 19:26:01 UTC (rev 446)
@@ -0,0 +1,13 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
+ *
+ */
+
+#include "MechanicPortValue.h"
+
+namespace OpenFDM {
+
+MechanicPortValue::~MechanicPortValue()
+{
+}
+
+} // namespace OpenFDM

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicPortValue.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicPortValue.h	2008-09-08 05:09:43 UTC (rev 445)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicPortValue.h	2008-09-08 19:26:01 UTC (rev 446)
@@ -0,0 +1,37 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_MechanicPortValue_H
+#define OpenFDM_MechanicPortValue_H
+
+#include "Inertia.h"
+#include "PortValue.h"
+#include "Rotation.h"
+#include "Vector.h"
+
+namespace OpenFDM {
+
+class MechanicPortValue : public PortValue {
+public:
+  virtual ~MechanicPortValue();
+
+// protected:
+  Vector3 mPosition;
+  Rotation mOrientation;
+  Vector6 mSpatialVelocity;
+  Vector6 mSpatialAcceleration;
+  Vector6 mArticulatedForce;
+  SpatialInertia mArticulatedInertia;
+  // Frame????
+  // FIXME: how to show who is responsible for setting the values???
+  // Solution:
+  // Ok, if set the joint is responsible for filling the velocities
+  // and accelerations, the body is responsible for the inertia -
+  // if unset it is the other way round ...
+  bool mDownStream;
+};
+
+} // namespace OpenFDM
+
+#endif



From frohlich at mail.berlios.de  Mon Sep  8 21:37:25 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Mon, 8 Sep 2008 21:37:25 +0200
Subject: [OpenFDM-svn] r447 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200809081937.m88JbPIZ003227@sheep.berlios.de>

Author: frohlich
Date: 2008-09-08 21:37:25 +0200 (Mon, 08 Sep 2008)
New Revision: 447

Added:
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicAcceptorPortInfo.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicProviderPortInfo.h
Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
   branches/OpenFDM-StateSeparation/src/OpenFDM/NumericProviderPortInfo.h
Log:
Add new mechanic port info.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-09-08 19:26:01 UTC (rev 446)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-09-08 19:37:25 UTC (rev 447)
@@ -50,6 +50,8 @@
   MatrixStateInfo.h \
   MidpointRule.h \
   MechanicPortValue.h \
+  MechanicAcceptorPortInfo.h \
+  MechanicProviderPortInfo.h \
   Model.h \
   Mutex.h \
   MPFRFloat.h \

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicAcceptorPortInfo.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicAcceptorPortInfo.h	2008-09-08 19:26:01 UTC (rev 446)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicAcceptorPortInfo.h	2008-09-08 19:37:25 UTC (rev 447)
@@ -0,0 +1,22 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_MechanicAcceptorPortInfo_H
+#define OpenFDM_MechanicAcceptorPortInfo_H
+
+#include <string>
+#include "AcceptorPortInfo.h"
+
+namespace OpenFDM {
+
+class MechanicAcceptorPortInfo : public AcceptorPortInfo {
+public:
+  MechanicAcceptorPortInfo(Node* node, const std::string& name) :
+    AcceptorPortInfo(node, name)
+  { }
+};
+
+} // namespace OpenFDM
+
+#endif

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicProviderPortInfo.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicProviderPortInfo.h	2008-09-08 19:26:01 UTC (rev 446)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicProviderPortInfo.h	2008-09-08 19:37:25 UTC (rev 447)
@@ -0,0 +1,26 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_MechanicProviderPortInfo_H
+#define OpenFDM_MechanicProviderPortInfo_H
+
+#include <string>
+#include "MechanicPortValue.h"
+#include "ProviderPortInfo.h"
+
+namespace OpenFDM {
+
+class MechanicProviderPortInfo : public ProviderPortInfo {
+public:
+  MechanicProviderPortInfo(Node* node, const std::string& name) :
+    ProviderPortInfo(node, name)
+  { }
+protected:
+  virtual MechanicPortValue* newValueImplementation() const
+  { return new MechanicPortValue; }
+};
+
+} // namespace OpenFDM
+
+#endif

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/NumericProviderPortInfo.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/NumericProviderPortInfo.h	2008-09-08 19:26:01 UTC (rev 446)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/NumericProviderPortInfo.h	2008-09-08 19:37:25 UTC (rev 447)
@@ -6,6 +6,7 @@
 #define OpenFDM_NumericProviderPortInfo_H
 
 #include <string>
+#include "NumericPortValue.h"
 #include "ProviderPortInfo.h"
 
 namespace OpenFDM {



From frohlich at mail.berlios.de  Mon Sep  8 21:39:13 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Mon, 8 Sep 2008 21:39:13 +0200
Subject: [OpenFDM-svn] r448 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200809081939.m88JdDVB003431@sheep.berlios.de>

Author: frohlich
Date: 2008-09-08 21:39:13 +0200 (Mon, 08 Sep 2008)
New Revision: 448

Modified:
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Add sketch of mechanic Nodes


Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-08 19:37:25 UTC (rev 447)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-08 19:39:13 UTC (rev 448)
@@ -96,6 +96,56 @@
   RealInputPort mInputPort;
 };
 
+class MechanicNode : public Node {
+public:
+  virtual void accept(NodeVisitor& visitor)
+  { visitor.apply(*this); }
+
+  virtual void velocity(const ContinousStateValueVector&,
+                        PortValueList&) const
+  { }
+  virtual void articulation(const ContinousStateValueVector&,
+                            PortValueList&) const
+  { }
+  virtual void derivative(const ContinousStateValueVector&,
+                          const PortValueList&,
+                          ContinousStateValueVector&) const
+  { }
+};
+
+class Body : public MechanicNode {
+public:
+  virtual void accept(NodeVisitor& visitor)
+  { visitor.apply(*this); }
+
+  // FIXME: is unclear: normal output port may depend on the velocities
+  // or depend harder on the accelerations. The interface cannot ask for this
+  // how about that??
+//   enum OutputStage { Velocity, Articulation, Acceleration };
+//   virtual bool dependsOn(OutputStage outputStage,
+//                          const PortId& in, const PortId& out) const = 0;
+};
+
+class Interact : public MechanicNode {
+public:
+  virtual void accept(NodeVisitor& visitor)
+  { visitor.apply(*this); }
+
+  // FIXME: is unclear: normal output port may depend on the velocities
+  // or depend harder on the accelerations. The interface cannot ask for this
+  // how about that??
+//   enum OutputStage { Velocity, Articulation, Acceleration };
+//   virtual bool dependsOn(OutputStage outputStage,
+//                          const PortId& in, const PortId& out) const = 0;
+};
+
+
+
+
+
+
+
+
 class LeafInstance : public WeakReferenced {
 public:
   struct LeafPortData;
@@ -595,3 +645,58 @@
 
   return 0;
 }
+
+// class CompositeNode : public Object /*??*/ {
+//   // Might be something that behaves like a model, but depending on the input
+//   // and output port types issues different final leafs scheduler ...
+
+//   // FIXME: is it possible to make 'Library models' from that one?
+//   // would be good, would simplify groups enormous
+// };
+
+// class LibraryNode;
+
+// class LibraryModel : public Object {
+// public:
+//   LibraryModel(const std::string& name, Node* node = 0) :
+//     Object(name),
+//     mNode(node)
+//   { }
+
+//   unsigned getNumParents() const
+//   { return mParents.size(); }
+  
+//   WeakPtr<LibraryNode> getParent(unsigned i)
+//   { if (mParents.size() <= i) return 0; return mParents[i]; }
+//   WeakPtr<const LibraryNode> getParent(unsigned i) const
+//   { if (mParents.size() <= i) return 0; return mParents[i]; }
+
+//   SharedPtr<Node> getNode()
+//   { return mNode; }
+//   SharedPtr<const Node> getNode() const
+//   { return mNode; }
+
+// private:
+//   SharedPtr<Node> mNode;
+//   std::vector<WeakPtr<LibraryNode> > mParents;
+// };
+
+// class LibraryNode : public Node {
+// public:
+//   LibraryNode(const std::string& name, LibraryModel* libraryModel = 0) :
+//     Node(name),
+//     mLibraryModel(libraryModel)
+//   { }
+
+//   // Hmm, how do we map ports??
+//   // May be the Node just gets virtuals for ports???
+//   // May be changing ports means informing the parent about that???
+
+//   SharedPtr<LibraryModel> getLibraryModel()
+//   { return mLibraryModel; }
+//   SharedPtr<const LibraryModel> getLibraryModel() const
+//   { return mLibraryModel; }
+
+// private:
+//   SharedPtr<LibraryModel> mLibraryModel;
+// };



From frohlich at mail.berlios.de  Tue Sep  9 18:59:10 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Tue, 9 Sep 2008 18:59:10 +0200
Subject: [OpenFDM-svn] r449 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200809091659.m89GxAYR003817@sheep.berlios.de>

Author: frohlich
Date: 2008-09-09 18:59:05 +0200 (Tue, 09 Sep 2008)
New Revision: 449

Modified:
   trunk/OpenFDM/src/OpenFDM/LogStream.h
Log:
Call functions by that pointers.


Modified: trunk/OpenFDM/src/OpenFDM/LogStream.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/LogStream.h	2008-09-08 19:39:13 UTC (rev 448)
+++ trunk/OpenFDM/src/OpenFDM/LogStream.h	2008-09-09 16:59:05 UTC (rev 449)
@@ -57,11 +57,11 @@
   LogProxy operator<<(const T& value)
   { if (mStream) (*mStream) << value; return *this; }
   LogProxy operator<<(ios_base_type& (*mptr)(ios_base_type&))
-  { if (mStream) (*mStream) << mptr; return *this; }
+  { if (mStream) mptr(*mStream); return *this; }
   LogProxy operator<<(basic_ios_type& (*mptr)(basic_ios_type&))
-  { if (mStream) (*mStream) << mptr; return *this; }
+  { if (mStream) mptr(*mStream); return *this; }
   LogProxy operator<<(basic_ostream_type& (*mptr)(basic_ostream_type&))
-  { if (mStream) (*mStream) << mptr; return *this; }
+  { if (mStream) mptr(*mStream); return *this; }
 
 private:
   template<Category category, Priority priority>



From frohlich at mail.berlios.de  Tue Sep  9 19:19:08 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Tue, 9 Sep 2008 19:19:08 +0200
Subject: [OpenFDM-svn] r450 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200809091719.m89HJ8HZ025821@sheep.berlios.de>

Author: frohlich
Date: 2008-09-09 19:19:08 +0200 (Tue, 09 Sep 2008)
New Revision: 450

Added:
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicBodyPort.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicInteractPort.h
Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
   branches/OpenFDM-StateSeparation/src/OpenFDM/PortValueList.h
Log:
More on mechanic ports.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-09-09 16:59:05 UTC (rev 449)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-09-09 17:19:08 UTC (rev 450)
@@ -49,6 +49,8 @@
   MatrixStateValue.h \
   MatrixStateInfo.h \
   MidpointRule.h \
+  MechanicBodyPort.h \
+  MechanicInteractPort.h \
   MechanicPortValue.h \
   MechanicAcceptorPortInfo.h \
   MechanicProviderPortInfo.h \

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicBodyPort.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicBodyPort.h	2008-09-09 16:59:05 UTC (rev 449)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicBodyPort.h	2008-09-09 17:19:08 UTC (rev 450)
@@ -0,0 +1,34 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_MechanicBodyPort_H
+#define OpenFDM_MechanicBodyPort_H
+
+#include "MechanicProviderPortInfo.h"
+#include "MechanicPortValue.h"
+#include "SharedPtr.h"
+
+namespace OpenFDM {
+
+class MechanicBodyPort {
+public:
+  MechanicBodyPort(Node* node, const std::string& name) :
+    mPort(new MechanicProviderPortInfo(node, name))
+  {}
+  MechanicPortValue* getPortValue(const PortValueVector& portValueVector) const
+  {
+    PortValue* portValue = mPort->getPortValue(portValueVector);
+    OpenFDMAssert(portValue);
+    OpenFDMAssert(dynamic_cast<MechanicPortValue*>(portValue));
+    return static_cast<MechanicPortValue*>(portValue);
+  }
+  unsigned getPortIndex() const
+  { return mPort->getIndex(); }
+private:
+  SharedPtr<MechanicProviderPortInfo> mPort;
+};
+
+} // namespace OpenFDM
+
+#endif

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicInteractPort.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicInteractPort.h	2008-09-09 16:59:05 UTC (rev 449)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicInteractPort.h	2008-09-09 17:19:08 UTC (rev 450)
@@ -0,0 +1,34 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_MechanicInteractPort_H
+#define OpenFDM_MechanicInteractPort_H
+
+#include "MechanicAcceptorPortInfo.h"
+#include "MechanicPortValue.h"
+#include "SharedPtr.h"
+
+namespace OpenFDM {
+
+class MechanicInteractPort {
+public:
+  MechanicInteractPort(Node* node, const std::string& name) :
+    mPort(new MechanicAcceptorPortInfo(node, name))
+  {}
+  MechanicPortValue* getPortValue(const PortValueVector& portValueVector) const
+  {
+    PortValue* portValue = mPort->getPortValue(portValueVector);
+    OpenFDMAssert(portValue);
+    OpenFDMAssert(dynamic_cast<MechanicPortValue*>(portValue));
+    return static_cast<MechanicPortValue*>(portValue);
+  }
+  unsigned getPortIndex() const
+  { return mPort->getIndex(); }
+private:
+  SharedPtr<MechanicAcceptorPortInfo> mPort;
+};
+
+} // namespace OpenFDM
+
+#endif

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/PortValueList.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/PortValueList.h	2008-09-09 16:59:05 UTC (rev 449)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/PortValueList.h	2008-09-09 17:19:08 UTC (rev 450)
@@ -8,6 +8,8 @@
 #include "PortValue.h"
 #include "MatrixInputPort.h"
 #include "MatrixOutputPort.h"
+#include "MechanicBodyPort.h"
+#include "MechanicInteractPort.h"
 #include "RealInputPort.h"
 #include "RealOutputPort.h"
 
@@ -50,6 +52,21 @@
   { return port.getPortValue(mPortValueVector)->getValue(); }
 
 
+  // Accessors for matrix valued ports
+  bool isConnected(const MechanicBodyPort& port) const
+  { return port.getPortValue(mPortValueVector); }
+  bool isConnected(const MechanicInteractPort& port) const
+  { return port.getPortValue(mPortValueVector); }
+
+  // FIXME Implement access control for the port value
+  MechanicPortValue& operator[](const MechanicBodyPort& port) const
+  { return *port.getPortValue(mPortValueVector); }
+  MechanicPortValue& operator[](const MechanicInteractPort& port)
+  { return *port.getPortValue(mPortValueVector); }
+
+
+
+
   // FIXME, avoid this method here. With this method the output stage of a model
   // can change the port values, this should not be available in a model.
   // may be this must be a derived class that provides some more access??



From frohlich at mail.berlios.de  Tue Sep  9 19:25:33 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Tue, 9 Sep 2008 19:25:33 +0200
Subject: [OpenFDM-svn] r451 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200809091725.m89HPX64000203@sheep.berlios.de>

Author: frohlich
Date: 2008-09-09 19:25:32 +0200 (Tue, 09 Sep 2008)
New Revision: 451

Modified:
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Make use of the mechanic ports.


Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-09 17:19:08 UTC (rev 450)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-09 17:25:32 UTC (rev 451)
@@ -7,18 +7,14 @@
 #include <OpenFDM/PortValue.h>
 #include <OpenFDM/PortValueList.h>
 #include <OpenFDM/PortId.h>
-#include <OpenFDM/PortInfo.h>
-#include <OpenFDM/AcceptorPortInfo.h>
-#include <OpenFDM/ProviderPortInfo.h>
-#include <OpenFDM/NumericPortValue.h>
 #include <OpenFDM/Node.h>
 #include <OpenFDM/NodeVisitor.h>
-#include <OpenFDM/NumericAcceptorPortInfo.h>
-#include <OpenFDM/NumericProviderPortInfo.h>
 #include <OpenFDM/MatrixInputPort.h>
 #include <OpenFDM/MatrixOutputPort.h>
 #include <OpenFDM/RealInputPort.h>
 #include <OpenFDM/RealOutputPort.h>
+#include <OpenFDM/MechanicBodyPort.h>
+#include <OpenFDM/MechanicInteractPort.h>
 
 #include <OpenFDM/StateInfo.h>
 #include <OpenFDM/StateValue.h>
@@ -43,10 +39,6 @@
 
 #include <OpenFDM/Group.h>
 
-#include <iterator>
-#include <algorithm>
-#include <sstream>
-
 namespace OpenFDM {
 
 /// Evaluation orders:
@@ -124,6 +116,10 @@
 //   enum OutputStage { Velocity, Articulation, Acceleration };
 //   virtual bool dependsOn(OutputStage outputStage,
 //                          const PortId& in, const PortId& out) const = 0;
+
+  MechanicBodyPort
+  newMechanicBodyPort(const std::string& name)
+  { return MechanicBodyPort(this, name); }
 };
 
 class Interact : public MechanicNode {
@@ -137,6 +133,10 @@
 //   enum OutputStage { Velocity, Articulation, Acceleration };
 //   virtual bool dependsOn(OutputStage outputStage,
 //                          const PortId& in, const PortId& out) const = 0;
+
+  MechanicInteractPort
+  newMechanicInteractPort(const std::string& name)
+  { return MechanicInteractPort(this, name); }
 };
 
 



From frohlich at mail.berlios.de  Tue Sep  9 19:30:26 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Tue, 9 Sep 2008 19:30:26 +0200
Subject: [OpenFDM-svn] r452 - in branches/OpenFDM-StateSeparation: .
	src/OpenFDM
Message-ID: <200809091730.m89HUQNd011801@sheep.berlios.de>

Author: frohlich
Date: 2008-09-09 19:30:21 +0200 (Tue, 09 Sep 2008)
New Revision: 452

Modified:
   branches/OpenFDM-StateSeparation/MERGE-REVISION
   branches/OpenFDM-StateSeparation/src/OpenFDM/LogStream.h
Log:
Merge changes from trunk.


Modified: branches/OpenFDM-StateSeparation/MERGE-REVISION
===================================================================
--- branches/OpenFDM-StateSeparation/MERGE-REVISION	2008-09-09 17:25:32 UTC (rev 451)
+++ branches/OpenFDM-StateSeparation/MERGE-REVISION	2008-09-09 17:30:21 UTC (rev 452)
@@ -1 +1 @@
-434
\ No newline at end of file
+451

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/LogStream.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/LogStream.h	2008-09-09 17:25:32 UTC (rev 451)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/LogStream.h	2008-09-09 17:30:21 UTC (rev 452)
@@ -57,11 +57,11 @@
   LogProxy operator<<(const T& value)
   { if (mStream) (*mStream) << value; return *this; }
   LogProxy operator<<(ios_base_type& (*mptr)(ios_base_type&))
-  { if (mStream) (*mStream) << mptr; return *this; }
+  { if (mStream) mptr(*mStream); return *this; }
   LogProxy operator<<(basic_ios_type& (*mptr)(basic_ios_type&))
-  { if (mStream) (*mStream) << mptr; return *this; }
+  { if (mStream) mptr(*mStream); return *this; }
   LogProxy operator<<(basic_ostream_type& (*mptr)(basic_ostream_type&))
-  { if (mStream) (*mStream) << mptr; return *this; }
+  { if (mStream) mptr(*mStream); return *this; }
 
 private:
   template<Category category, Priority priority>



From frohlich at mail.berlios.de  Tue Sep  9 20:56:57 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Tue, 9 Sep 2008 20:56:57 +0200
Subject: [OpenFDM-svn] r453 - in branches/OpenFDM-StateSeparation/src:
	OpenFDM test
Message-ID: <200809091856.m89IuvR6004556@sheep.berlios.de>

Author: frohlich
Date: 2008-09-09 20:56:57 +0200 (Tue, 09 Sep 2008)
New Revision: 453

Added:
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.h
Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
   branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.h
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Move MechanicNode to the library directory.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-09-09 17:30:21 UTC (rev 452)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-09-09 18:56:57 UTC (rev 453)
@@ -51,6 +51,7 @@
   MidpointRule.h \
   MechanicBodyPort.h \
   MechanicInteractPort.h \
+  MechanicNode.h \
   MechanicPortValue.h \
   MechanicAcceptorPortInfo.h \
   MechanicProviderPortInfo.h \
@@ -117,6 +118,7 @@
   LeafNode.cpp \
   Logger.cpp \
   MatrixStateValue.cpp \
+  MechanicNode.cpp \
   MechanicPortValue.cpp \
   Model.cpp \
   Node.cpp \

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.cpp	2008-09-09 17:30:21 UTC (rev 452)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.cpp	2008-09-09 18:56:57 UTC (rev 453)
@@ -0,0 +1,28 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
+ *
+ */
+
+#include "MechanicNode.h"
+#include "NodeVisitor.h"
+
+namespace OpenFDM {
+
+BEGIN_OPENFDM_OBJECT_DEF(MechanicNode, LeafNode)
+  END_OPENFDM_OBJECT_DEF
+
+MechanicNode::MechanicNode(const std::string& name) :
+  LeafNode(name)
+{
+}
+
+MechanicNode::~MechanicNode()
+{
+}
+
+void
+MechanicNode::accept(NodeVisitor& visitor)
+{
+  visitor.apply(*this);
+}
+
+} // namespace OpenFDM

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.h	2008-09-09 17:30:21 UTC (rev 452)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.h	2008-09-09 18:56:57 UTC (rev 453)
@@ -0,0 +1,37 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_MechanicNode_H
+#define OpenFDM_MechanicNode_H
+
+#include <string>
+#include "LeafNode.h"
+
+namespace OpenFDM {
+
+class PortValueList;
+
+class MechanicNode : public LeafNode {
+  OPENFDM_OBJECT(MechanicNode, LeafNode);
+public:
+  MechanicNode(const std::string& name);
+  virtual ~MechanicNode();
+
+  virtual void accept(NodeVisitor& visitor);
+
+  virtual void velocity(const ContinousStateValueVector&,
+                        PortValueList&) const
+  { }
+  virtual void articulation(const ContinousStateValueVector&,
+                            PortValueList&) const
+  { }
+  virtual void derivative(const ContinousStateValueVector&,
+                          const PortValueList&,
+                          ContinousStateValueVector&) const
+  { }
+};
+
+} // namespace OpenFDM
+
+#endif

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.cpp	2008-09-09 17:30:21 UTC (rev 452)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.cpp	2008-09-09 18:56:57 UTC (rev 453)
@@ -5,6 +5,7 @@
 #include "NodeVisitor.h"
 
 #include "LeafNode.h"
+#include "MechanicNode.h"
 #include "Model.h"
 #include "Group.h"
 
@@ -49,4 +50,10 @@
   apply(static_cast<LeafNode&>(node));
 }
 
+void
+NodeVisitor::apply(MechanicNode& node)
+{
+  apply(static_cast<LeafNode&>(node));
+}
+
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.h	2008-09-09 17:30:21 UTC (rev 452)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.h	2008-09-09 18:56:57 UTC (rev 453)
@@ -8,11 +8,12 @@
 namespace OpenFDM {
 
 class Node;
+class Group;
 class GroupAcceptorNode;
 class GroupProviderNode;
 class LeafNode;
 class Model;
-class Group;
+class MechanicNode;
 
 class NodeVisitor {
 public:
@@ -24,6 +25,7 @@
   virtual void apply(GroupProviderNode&);
   virtual void apply(LeafNode&);
   virtual void apply(Model&);
+  virtual void apply(MechanicNode&);
 };
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-09 17:30:21 UTC (rev 452)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-09 18:56:57 UTC (rev 453)
@@ -33,6 +33,8 @@
 
 #include <OpenFDM/LeafContext.h>
 
+#include <OpenFDM/MechanicNode.h>
+
 #include <OpenFDM/Gain.h>
 #include <OpenFDM/Integrator.h>
 #include <OpenFDM/Delay.h>
@@ -74,7 +76,7 @@
 
 class Print : public Model {
 public:
-  Print(const std::string& name = std::string()) :
+  Print(const std::string& name) :
     Model(name),
     mInputPort(newRealInputPort("input"))
   { }
@@ -88,23 +90,6 @@
   RealInputPort mInputPort;
 };
 
-class MechanicNode : public Node {
-public:
-  virtual void accept(NodeVisitor& visitor)
-  { visitor.apply(*this); }
-
-  virtual void velocity(const ContinousStateValueVector&,
-                        PortValueList&) const
-  { }
-  virtual void articulation(const ContinousStateValueVector&,
-                            PortValueList&) const
-  { }
-  virtual void derivative(const ContinousStateValueVector&,
-                          const PortValueList&,
-                          ContinousStateValueVector&) const
-  { }
-};
-
 class Body : public MechanicNode {
 public:
   virtual void accept(NodeVisitor& visitor)
@@ -117,6 +102,7 @@
 //   virtual bool dependsOn(OutputStage outputStage,
 //                          const PortId& in, const PortId& out) const = 0;
 
+protected:
   MechanicBodyPort
   newMechanicBodyPort(const std::string& name)
   { return MechanicBodyPort(this, name); }
@@ -134,6 +120,7 @@
 //   virtual bool dependsOn(OutputStage outputStage,
 //                          const PortId& in, const PortId& out) const = 0;
 
+protected:
   MechanicInteractPort
   newMechanicInteractPort(const std::string& name)
   { return MechanicInteractPort(this, name); }



From frohlich at mail.berlios.de  Tue Sep  9 21:13:00 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Tue, 9 Sep 2008 21:13:00 +0200
Subject: [OpenFDM-svn] r454 - in branches/OpenFDM-StateSeparation/src:
	OpenFDM test
Message-ID: <200809091913.m89JD0wc006510@sheep.berlios.de>

Author: frohlich
Date: 2008-09-09 21:12:57 +0200 (Tue, 09 Sep 2008)
New Revision: 454

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
   branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/RigidBody.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/RigidBody.h
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Interact and RigidBody sketch.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.cpp	2008-09-09 18:56:57 UTC (rev 453)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.cpp	2008-09-09 19:12:57 UTC (rev 454)
@@ -1,132 +1,29 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
+/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
  *
  */
 
 #include "Interact.h"
+#include "NodeVisitor.h"
 
-#include <iosfwd>
-#include <list>
-#include <string>
-
-#include "Assert.h"
-#include "Object.h"
-#include "Vector.h"
-#include "Matrix.h"
-#include "Quaternion.h"
-#include "Inertia.h"
-#include "RigidBody.h"
-#include "ModelVisitor.h"
-
 namespace OpenFDM {
 
-BEGIN_OPENFDM_OBJECT_DEF(Interact, Model)
+BEGIN_OPENFDM_OBJECT_DEF(Interact, MechanicNode)
   END_OPENFDM_OBJECT_DEF
 
-Interact::Interact(const std::string& name, unsigned numParents) :
-  Model(name),
-  mParents(numParents)
+Interact::Interact(const std::string& name) :
+  MechanicNode(name)
 {
 }
 
-Interact::~Interact(void)
+Interact::~Interact()
 {
 }
 
-const Interact*
-Interact::toInteract(void) const
-{
-  return this;
-}
-
-Interact*
-Interact::toInteract(void)
-{
-  return this;
-}
-
 void
-Interact::accept(ModelVisitor& visitor)
+Interact::accept(NodeVisitor& visitor)
 {
   visitor.apply(*this);
 }
 
-bool
-Interact::dependsDirectOn(Model* model)
-{
-  // HACK HACK HACK FIXME
-  // non joint interacts need to have their inputs, but the outputs are
-  // already present when the state is set ...
-  // We need to split out sensors which could be scheduled earlier
-  setDirectFeedThrough(true);
-  if (Model::dependsDirectOn(model)) {
-    setDirectFeedThrough(false);
-    return true;
-  }
-  setDirectFeedThrough(false);
-  
-  return false;
-}
 
-bool
-Interact::isChildOf(const RigidBody* const rigidBody) const
-{
-  if (!rigidBody)
-    return false;
-  ParentList::const_iterator it = mParents.begin();
-  while (it != mParents.end()) {
-    if ((*it).lock() == rigidBody)
-      return true;
-    ++it;
-  }
-  return false;
-}
-
-bool
-Interact::attachTo(RigidBody* rigidBody, bool upstream)
-{
-  if (!rigidBody) {
-    Log(MultiBody,Error) << "Got 0 RigidBody pointer to attach to." << endl;
-    return false;
-  }
-  ParentList::iterator it;
-  for (it = mParents.begin(); it != mParents.end(); ++it) {
-    if ((*it).lock() == 0) {
-      (*it) = rigidBody;
-      if (upstream && it != mParents.begin())
-        swapParents();
-      recheckTopology();
-      return true;
-    }
-  }
-  
-  Log(MultiBody,Error) << "Cannot attach Interact \"" << getName()
-                       << "\" to RigidBody \"" << rigidBody->getName()
-                       << "\": Already attached to 2 Rigid bodies."
-                       << endl;
-  return false;
-}
-
-bool
-Interact::detachFrom(RigidBody* rigidBody)
-{
-  if (!rigidBody) {
-    Log(MultiBody,Error) << "Got 0 RigidBody pointer to attach to." << endl;
-    return false;
-  }
-  ParentList::iterator it;
-  for (it = mParents.begin(); it != mParents.end(); ++it) {
-    if ((*it).lock() == rigidBody) {
-      (*it).clear();
-      recheckTopology();
-      return true;
-    }
-  }
-  
-  Log(MultiBody,Error) << "Cannot detatach Interact \"" << getName()
-                       << "\" from RigidBody \"" << rigidBody->getName()
-                       << "\": Interact is not attached to that RigidBody."
-                       << endl;
-  return false;
-}
-
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.h	2008-09-09 18:56:57 UTC (rev 453)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.h	2008-09-09 19:12:57 UTC (rev 454)
@@ -1,76 +1,27 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
+/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
  *
  */
 
 #ifndef OpenFDM_Interact_H
 #define OpenFDM_Interact_H
 
-#include <iosfwd>
-#include <list>
 #include <string>
+#include "MechanicInteractPort.h"
+#include "MechanicNode.h"
 
-#include "Assert.h"
-#include "Object.h"
-#include "Vector.h"
-#include "Matrix.h"
-#include "Quaternion.h"
-#include "Inertia.h"
-#include "Frame.h"
-#include "RigidBody.h"
-#include "Model.h"
-
 namespace OpenFDM {
 
-class Interact : public Model {
-  OPENFDM_OBJECT(Interact, Model);
+class Interact : public MechanicNode {
+  OPENFDM_OBJECT(Interact, MechanicNode);
 public:
-  Interact(const std::string& name, unsigned numParents);
-  virtual ~Interact(void);
+  Interact(const std::string& name);
+  virtual ~Interact();
 
-  virtual const Interact* toInteract(void) const;
-  virtual Interact* toInteract(void);
+  virtual void accept(NodeVisitor& visitor);
 
-  /// Double dispatch helper for the multibody system visitor
-  virtual void accept(ModelVisitor& visitor);
-  /// Double dispatch helper for the multibody system visitor
-//   virtual void accept(ConstModelVisitor& visitor) const;
-
-  /// This is the primary gate function which handles interaction
-  virtual void interactWith(RigidBody* rigidBody) = 0;
-
-  virtual bool dependsDirectOn(Model* model);
-
-  SharedPtr<const RigidBody> getParentRigidBody(unsigned id = 0) const
-  {
-    OpenFDMAssert(id < mParents.size());
-    return mParents[id].lock();
-  }
-  SharedPtr<RigidBody> getParentRigidBody(unsigned id = 0)
-  {
-    OpenFDMAssert(id < mParents.size());
-    return mParents[id].lock();
-  }
-  bool isChildOf(const RigidBody* const rigidBody) const;
-
-private:
-  bool attachTo(RigidBody* rigidBody, bool upstream);
-  bool detachFrom(RigidBody* rigidBody);
-
-  /// Called whenever the local topology chages, use to manage frames with this
-  /// interact
-  virtual void recheckTopology(void) {}
-
-  friend class RigidBody;
-
-  void swapParents(void)
-  {
-    OpenFDMAssert(2 == mParents.size());
-    mParents[0].swap(mParents[1]);
-  }
-
-private:
-  typedef std::vector<WeakPtr<RigidBody> > ParentList;
-  ParentList mParents;
+protected:
+  MechanicInteractPort newMechanicInteractPort(const std::string& name)
+  { return MechanicInteractPort(this, name); }
 };
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-09-09 18:56:57 UTC (rev 453)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-09-09 19:12:57 UTC (rev 454)
@@ -30,6 +30,7 @@
   Group.h \
   ImplicitEuler.h \
   Inertia.h \
+  Interact.h \
   LeafContext.h \
   LeafNode.h \
   Limits.h \
@@ -81,6 +82,7 @@
   RealOutputPort.h \
   RealStateInfo.h \
   Referenced.h \
+  RigidBody.h \
   Rotation.h \
   SampleTime.h \
   ScopeLock.h \
@@ -115,6 +117,7 @@
   ContinousStateValue.cpp \
   Frame.cpp \
   Group.cpp \
+  Interact.cpp \
   LeafNode.cpp \
   Logger.cpp \
   MatrixStateValue.cpp \
@@ -128,6 +131,7 @@
   Planet.cpp \
   PortInfo.cpp \
   PortValue.cpp \
+  RigidBody.cpp \
   SampleTime.cpp \
   StateValue.cpp \
   Time.cpp \
@@ -175,7 +179,6 @@
   Ground.h \
   Input.h \
   Integrator.h \
-  Interact.h \
   Joint.h \
   Launchbar.h \
   LinearSpringDamper.h \
@@ -192,7 +195,6 @@
   RevoluteActuatorFrame.h \
   RevoluteJoint.h \
   RevoluteJointFrame.h \
-  RigidBody.h \
   RootFrame.h \
   Saturation.h \
   Sensor.h \
@@ -236,7 +238,6 @@
 #   Gravity.cpp \
 #   Ground.cpp \
 #   Input.cpp \
-#   Interact.cpp \
 #   Joint.cpp \
 #   Launchbar.cpp \
 #   LinearSpringDamper.cpp \

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.cpp	2008-09-09 18:56:57 UTC (rev 453)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.cpp	2008-09-09 19:12:57 UTC (rev 454)
@@ -4,10 +4,12 @@
 
 #include "NodeVisitor.h"
 
+#include "Group.h"
+#include "Interact.h"
 #include "LeafNode.h"
 #include "MechanicNode.h"
 #include "Model.h"
-#include "Group.h"
+#include "RigidBody.h"
 
 namespace OpenFDM {
 
@@ -56,4 +58,16 @@
   apply(static_cast<LeafNode&>(node));
 }
 
+void
+NodeVisitor::apply(RigidBody& node)
+{
+  apply(static_cast<MechanicNode&>(node));
+}
+
+void
+NodeVisitor::apply(Interact& node)
+{
+  apply(static_cast<MechanicNode&>(node));
+}
+
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.h	2008-09-09 18:56:57 UTC (rev 453)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.h	2008-09-09 19:12:57 UTC (rev 454)
@@ -14,6 +14,8 @@
 class LeafNode;
 class Model;
 class MechanicNode;
+class RigidBody;
+class Interact;
 
 class NodeVisitor {
 public:
@@ -26,6 +28,8 @@
   virtual void apply(LeafNode&);
   virtual void apply(Model&);
   virtual void apply(MechanicNode&);
+  virtual void apply(RigidBody&);
+  virtual void apply(Interact&);
 };
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RigidBody.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RigidBody.cpp	2008-09-09 18:56:57 UTC (rev 453)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RigidBody.cpp	2008-09-09 19:12:57 UTC (rev 454)
@@ -1,93 +1,29 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
+/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
  *
  */
 
 #include "RigidBody.h"
-#include "Assert.h"
-#include "LogStream.h"
-#include "Object.h"
-#include "Vector.h"
-#include "Matrix.h"
-#include "Quaternion.h"
-#include "Inertia.h"
-#include "Frame.h"
-#include "Force.h"
-#include "Mass.h"
-#include "Joint.h"
-#include "ModelGroup.h"
+#include "NodeVisitor.h"
 
 namespace OpenFDM {
 
+BEGIN_OPENFDM_OBJECT_DEF(RigidBody, MechanicNode)
+  END_OPENFDM_OBJECT_DEF
+
 RigidBody::RigidBody(const std::string& name) :
-  Model(name)
+  MechanicNode(name)
 {
 }
 
-RigidBody::~RigidBody(void)
+RigidBody::~RigidBody()
 {
 }
 
 void
-RigidBody::output(const TaskInfo& taskInfo)
+RigidBody::accept(NodeVisitor& visitor)
 {
-  Log(ArtBody, Debug) << "Entry of computeArtValues of \"" << getName()
-                      << "\"" << endl;
-
-  // At first this is the inertia matrix of the current body.
-  mArtInertia.clear();
-  mArtForce.clear();
-
-  // Collect all articulated forces and inertias
-  InteractList::iterator it;
-  for (it = mInteracts.begin(); it != mInteracts.end(); ++it)
-    (*it)->interactWith(this);
-  
-  Log(ArtBody, Debug3) << "On exit of computeArtValues of \"" << getName()
-                       << "\" Force is:\n" << trans(mArtForce)
-                       << "\nInertia:\n" << mArtInertia << endl;
+  visitor.apply(*this);
 }
 
-bool
-RigidBody::dependsDirectOn(Model* model)
-{
-  InteractList::const_iterator i;
-  for (i = mInteracts.begin(); i != mInteracts.end(); ++i)
-    if ((*i) == model)
-      return true;
-  return Model::dependsDirectOn(model);
-}
 
-bool
-RigidBody::setInboardJoint(Joint* joint)
-{
-  if (!joint->attachTo(this, true))
-    return false;
-  mInboardJoint = joint;
-  return true;
-}
-
-bool
-RigidBody::addInteract(Interact* interact)
-{
-  if (!interact->attachTo(this, false))
-    return false;
-  mInteracts.push_back(interact);
-  return true;
-}
-
-bool
-RigidBody::removeInteract(Interact* interact)
-{
-  InteractList::iterator it;
-  for (it = mInteracts.begin(); it != mInteracts.end(); ++it) {
-    if ((*it) == interact) {
-      mInteracts.erase(it);
-      if (!interact->detachFrom(this))
-        return false;
-      return true;
-    }
-  }
-  return false;
-}
-
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RigidBody.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RigidBody.h	2008-09-09 18:56:57 UTC (rev 453)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RigidBody.h	2008-09-09 19:12:57 UTC (rev 454)
@@ -1,4 +1,4 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
+/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
  *
  */
 
@@ -6,118 +6,22 @@
 #define OpenFDM_RigidBody_H
 
 #include <string>
-#include <vector>
+#include "MechanicInteractPort.h"
+#include "MechanicNode.h"
 
-#include "Model.h"
-#include "Vector.h"
-#include "Inertia.h"
-#include "Frame.h"
-
 namespace OpenFDM {
 
-class Interact;
-
-// Rename to Body???
-class RigidBody :
-    public Model {
+class RigidBody : public MechanicNode {
+  OPENFDM_OBJECT(RigidBody, MechanicNode);
 public:
-  /// Constructor
   RigidBody(const std::string& name);
-  /// Destructor
-  virtual ~RigidBody(void);
+  virtual ~RigidBody();
 
-  /** Compute articulated values outboard including this body.
-      That function is part of the articulated body algorithm.
-      It is used to compute the articulated force and articulated inertia
-      of the tree of rigid bodies mounted below the current one.
-      These articulated values (inertia and force) is then stored in the
-      rigid body class and can be queried for computation of the inboard
-      articulated values as well as for the computations of the relative
-      accelerations in the next step.
-      @see const SpatialInertia& getArtInertia(void) const
-      @see const Vector6& getArtForce(void) const
-   */
-  virtual void output(const TaskInfo& taskInfo);
+  virtual void accept(NodeVisitor& visitor);
 
-  /// Returns true if the Model this depends directly on @ref model.
-  virtual bool dependsDirectOn(Model* model);
-
-// protected:
-  /** Get the outboard articulated inertia.
-      Returns a reference to the outboard articulated inertia.
-      The returned inertia matrix is computed prevously by a call to
-      @see computeArtValues(void).
-   */
-  const SpatialInertia& getArtInertia(void) const
-  { return mArtInertia; }
-
-  /** Get the outboard articulated force.
-      Returns a reference to the outboard articulated force.
-      The returned force vector is computed prevously by a call to
-      @see computeArtValues(void).
-   */
-  const Vector6& getArtForce(void) const
-  { return mArtForce; }
-
-  /// Apply a force to that rigid body
-  void applyForce(const Vector6& force)
-  { mArtForce -= force; }
-
-  /// Contribute articulated force as used in the articulated body algorithm
-  void contributeForce(const Vector6& force)
-  { mArtForce += force; }
-
-  /// Contribute articulated inertia as used in the articulated body algorithm
-  void contributeInertia(const SpatialInertia& inertia)
-  { mArtInertia += inertia; }
-
-  /// Contribute the articulated inertia and force of a local Mass object
-  void contributeLocalInertia(const SpatialInertia& inertia)
-  {
-    Vector6 iv = getFrame()->getSpVel();
-    Vector6 Jiv = inertia*iv;
-    mArtForce += Vector6(cross(iv.getAngular(), Jiv.getAngular()) +
-                         cross(iv.getLinear(), Jiv.getLinear()),
-                         cross(iv.getAngular(), Jiv.getLinear()));
-    mArtInertia += inertia;
-  }
-
-  /// Introduce an interface routine
-  void setFrame(Frame* frame)
-  {
-    // take over all children
-    frame->reparentChildren(mFrame);
-    mFrame = frame;
-  }
-  Frame* getFrame(void)
-  { return mFrame; }
-  const Frame* getFrame(void) const
-  { return mFrame; }
-
-  bool setInboardJoint(Joint* joint);
-  bool addInteract(Interact* interact);
-  bool removeInteract(Interact* interact);
-
-private:
-  /// Outboard articulated inertia
-  SpatialInertia mArtInertia;
-
-  /// Outboard articulated force
-  Vector6 mArtForce;
-
-  /// Frame attached to this rigid body
-  SharedPtr<Frame> mFrame;
-
-  /// One of our interacts is special ...
-  /// FIXME Make that dynamic later, for now we need to know the tree root at
-  /// MultiBodySystem build time
-  SharedPtr<Joint> mInboardJoint;
-  /// All Interacts attached to this RigidBody
-  typedef std::vector<SharedPtr<Interact> > InteractList;
-  InteractList mInteracts;
-
-  // HMM ... FIXME
-  friend class Interact;
+protected:
+  MechanicInteractPort newMechanicInteractPort(const std::string& name)
+  { return MechanicInteractPort(this, name); }
 };
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-09 18:56:57 UTC (rev 453)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-09 19:12:57 UTC (rev 454)
@@ -33,7 +33,8 @@
 
 #include <OpenFDM/LeafContext.h>
 
-#include <OpenFDM/MechanicNode.h>
+#include <OpenFDM/RigidBody.h>
+#include <OpenFDM/Interact.h>
 
 #include <OpenFDM/Gain.h>
 #include <OpenFDM/Integrator.h>
@@ -90,49 +91,6 @@
   RealInputPort mInputPort;
 };
 
-class Body : public MechanicNode {
-public:
-  virtual void accept(NodeVisitor& visitor)
-  { visitor.apply(*this); }
-
-  // FIXME: is unclear: normal output port may depend on the velocities
-  // or depend harder on the accelerations. The interface cannot ask for this
-  // how about that??
-//   enum OutputStage { Velocity, Articulation, Acceleration };
-//   virtual bool dependsOn(OutputStage outputStage,
-//                          const PortId& in, const PortId& out) const = 0;
-
-protected:
-  MechanicBodyPort
-  newMechanicBodyPort(const std::string& name)
-  { return MechanicBodyPort(this, name); }
-};
-
-class Interact : public MechanicNode {
-public:
-  virtual void accept(NodeVisitor& visitor)
-  { visitor.apply(*this); }
-
-  // FIXME: is unclear: normal output port may depend on the velocities
-  // or depend harder on the accelerations. The interface cannot ask for this
-  // how about that??
-//   enum OutputStage { Velocity, Articulation, Acceleration };
-//   virtual bool dependsOn(OutputStage outputStage,
-//                          const PortId& in, const PortId& out) const = 0;
-
-protected:
-  MechanicInteractPort
-  newMechanicInteractPort(const std::string& name)
-  { return MechanicInteractPort(this, name); }
-};
-
-
-
-
-
-
-
-
 class LeafInstance : public WeakReferenced {
 public:
   struct LeafPortData;



From frohlich at mail.berlios.de  Wed Sep 10 07:00:03 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Wed, 10 Sep 2008 07:00:03 +0200
Subject: [OpenFDM-svn] r455 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200809100500.m8A503e1013161@sheep.berlios.de>

Author: frohlich
Date: 2008-09-10 07:00:00 +0200 (Wed, 10 Sep 2008)
New Revision: 455

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicBodyPort.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicInteractPort.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicPortValue.h
Log:
Exchange provider and accaptor port roles for mechanic stuff.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicBodyPort.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicBodyPort.h	2008-09-09 19:12:57 UTC (rev 454)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicBodyPort.h	2008-09-10 05:00:00 UTC (rev 455)
@@ -5,7 +5,7 @@
 #ifndef OpenFDM_MechanicBodyPort_H
 #define OpenFDM_MechanicBodyPort_H
 
-#include "MechanicProviderPortInfo.h"
+#include "MechanicAcceptorPortInfo.h"
 #include "MechanicPortValue.h"
 #include "SharedPtr.h"
 
@@ -14,7 +14,7 @@
 class MechanicBodyPort {
 public:
   MechanicBodyPort(Node* node, const std::string& name) :
-    mPort(new MechanicProviderPortInfo(node, name))
+    mPort(new MechanicAcceptorPortInfo(node, name))
   {}
   MechanicPortValue* getPortValue(const PortValueVector& portValueVector) const
   {
@@ -26,7 +26,7 @@
   unsigned getPortIndex() const
   { return mPort->getIndex(); }
 private:
-  SharedPtr<MechanicProviderPortInfo> mPort;
+  SharedPtr<MechanicAcceptorPortInfo> mPort;
 };
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicInteractPort.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicInteractPort.h	2008-09-09 19:12:57 UTC (rev 454)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicInteractPort.h	2008-09-10 05:00:00 UTC (rev 455)
@@ -5,7 +5,7 @@
 #ifndef OpenFDM_MechanicInteractPort_H
 #define OpenFDM_MechanicInteractPort_H
 
-#include "MechanicAcceptorPortInfo.h"
+#include "MechanicProviderPortInfo.h"
 #include "MechanicPortValue.h"
 #include "SharedPtr.h"
 
@@ -14,7 +14,7 @@
 class MechanicInteractPort {
 public:
   MechanicInteractPort(Node* node, const std::string& name) :
-    mPort(new MechanicAcceptorPortInfo(node, name))
+    mPort(new MechanicProviderPortInfo(node, name))
   {}
   MechanicPortValue* getPortValue(const PortValueVector& portValueVector) const
   {
@@ -26,7 +26,7 @@
   unsigned getPortIndex() const
   { return mPort->getIndex(); }
 private:
-  SharedPtr<MechanicAcceptorPortInfo> mPort;
+  SharedPtr<MechanicProviderPortInfo> mPort;
 };
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicPortValue.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicPortValue.h	2008-09-09 19:12:57 UTC (rev 454)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicPortValue.h	2008-09-10 05:00:00 UTC (rev 455)
@@ -17,6 +17,13 @@
   virtual ~MechanicPortValue();
 
 // protected:
+  // FIXME:
+  // Since the interact side is the provider port, an interact might provide
+  // different typed ports, the Rigid body can test for at init time and
+  // avoid inertia computations for ports not contributing that ...
+  // May be build a class hierarchy that accounts for different inputs
+  // and outputs a rigid body can have.
+  // Example: force port, force and inertia, frame port, velocity port
   Vector3 mPosition;
   Rotation mOrientation;
   Vector6 mSpatialVelocity;



From frohlich at mail.berlios.de  Wed Sep 10 07:04:24 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Wed, 10 Sep 2008 07:04:24 +0200
Subject: [OpenFDM-svn] r456 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200809100504.m8A54O2h015999@sheep.berlios.de>

Author: frohlich
Date: 2008-09-10 07:04:23 +0200 (Wed, 10 Sep 2008)
New Revision: 456

Modified:
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
We may distinguish between models and mechanic stuff in the near future.


Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-10 05:00:00 UTC (rev 455)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-10 05:04:23 UTC (rev 456)
@@ -407,6 +407,16 @@
       _leafPortDataMap[getCurrentNodeId()][portId] = portData;
     }
   }
+
+  virtual void apply(MechanicNode& node)
+  {
+    apply(static_cast<LeafNode&>(node));
+  }
+  virtual void apply(Model& node)
+  {
+    apply(static_cast<LeafNode&>(node));
+  }
+
   virtual void apply(Group& group)
   {
     // Prepare a new leaf map for the child group



From frohlich at mail.berlios.de  Wed Sep 10 07:17:02 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Wed, 10 Sep 2008 07:17:02 +0200
Subject: [OpenFDM-svn] r457 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200809100517.m8A5H2kG027926@sheep.berlios.de>

Author: frohlich
Date: 2008-09-10 07:16:58 +0200 (Wed, 10 Sep 2008)
New Revision: 457

Modified:
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
New name idea??


Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-10 05:04:23 UTC (rev 456)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-10 05:16:58 UTC (rev 457)
@@ -601,6 +601,10 @@
   return 0;
 }
 
+
+// Kabelbaum <-> PortBundle ??? Original Kabelbaum == Cabel Bundle
+// Oder Cable Set <-> Port Set???
+
 // class CompositeNode : public Object /*??*/ {
 //   // Might be something that behaves like a model, but depending on the input
 //   // and output port types issues different final leafs scheduler ...



From frohlich at mail.berlios.de  Wed Sep 10 20:45:53 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Wed, 10 Sep 2008 20:45:53 +0200
Subject: [OpenFDM-svn] r458 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200809101845.m8AIjrM3013795@sheep.berlios.de>

Author: frohlich
Date: 2008-09-10 20:45:53 +0200 (Wed, 10 Sep 2008)
New Revision: 458

Modified:
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
distinguish between model types.


Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-10 05:16:58 UTC (rev 457)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-10 18:45:53 UTC (rev 458)
@@ -301,8 +301,7 @@
     std::vector<SharedPtr<PortData> > mPortDataList;
   };
 
-  LeafInstance(const LeafNode* leaf) :
-    mLeafNode(leaf)
+  LeafInstance(const LeafNode* leaf)
   { allocPorts(leaf); }
 
   LeafPortData* getPortData(const PortId& portId)
@@ -314,8 +313,7 @@
     return mPortData[index];
   }
 
-  const SharedPtr<const LeafNode>& getLeafNode() const
-  { return mLeafNode; }
+  virtual const LeafNode* getLeafNode() const = 0;
 
   // Return true if this leaf directly depends on one of leafInstance outputs
   bool dependsOn(LeafInstance* leafInstance)
@@ -324,13 +322,13 @@
       for (unsigned j = 0; j < leafInstance->mPortData.size(); ++j) {
         if (!mPortData[i]->isConnected(leafInstance->mPortData[j]))
           continue;
-        PortId inPortId = mLeafNode->getPortId(i);
+        PortId inPortId = getLeafNode()->getPortId(i);
 
         // FIXME, may be other concept:
         // make Model return a list of 'direct feedthrough ports'?
         for (unsigned k = 0; k < mPortData.size(); ++k) {
-          PortId outPortId = mLeafNode->getPortId(k);
-          if (mLeafNode->dependsOn(inPortId, outPortId))
+          PortId outPortId = getLeafNode()->getPortId(k);
+          if (getLeafNode()->dependsOn(inPortId, outPortId))
             return true;
         }
       }
@@ -340,7 +338,7 @@
 
   void print()
   {
-    std::cout << "Leaf \"" << mLeafNode->getName() << "\"" << std::endl;
+    std::cout << "Leaf \"" << getLeafNode()->getName() << "\"" << std::endl;
     for (unsigned i = 0; i < mPortData.size(); ++i) {
       mPortData[i]->print();
     }
@@ -360,21 +358,45 @@
     }
   }
 
-  // The subsystem leaf node
-  SharedPtr<const LeafNode> mLeafNode;
-
   // List of port dependent info used to build up the connect info and
   // the sorted list of leafs.
   std::vector<SharedPtr<LeafPortData> > mPortData;
 };
 
+class ModelInstance : public LeafInstance {
+public:
+  ModelInstance(const Model* model) :
+    LeafInstance(model),
+    mModel(model)
+  { }
+
+  virtual const Model* getLeafNode() const
+  { return mModel; }
+
+  SharedPtr<const Model> mModel;
+};
+
+class MechanicInstance : public LeafInstance {
+public:
+  MechanicInstance(const MechanicNode* mechanicNode) :
+    LeafInstance(mechanicNode),
+    mMechanicNode(mechanicNode)
+  { }
+
+  virtual const MechanicNode* getLeafNode() const
+  { return mMechanicNode; }
+
+  SharedPtr<const MechanicNode> mMechanicNode;
+};
+
+
 class LeafInstanceCollector : public NodeVisitor {
 public:
 
   virtual void apply(Node& node)
-  {
-    std::cerr << __PRETTY_FUNCTION__ << std::endl;
-  }
+  { std::cerr << __PRETTY_FUNCTION__ << std::endl; }
+  virtual void apply(LeafNode& leaf)
+  { std::cerr << __PRETTY_FUNCTION__ << std::endl; }
 
   // Aussen acceptor, innen provider
   virtual void apply(GroupAcceptorNode& leaf)
@@ -394,13 +416,10 @@
     ad = new LeafInstance::AcceptorPortData(0, leaf._groupInternalPort);
     _leafPortDataMap[getCurrentNodeId()][portId] = ad;
   }
-  virtual void apply(LeafNode& leaf)
+
+  void allocPortData(LeafInstance* leafInstance, LeafNode& leaf)
   {
-    // FIXME: assert that the current node id is something valid ...
-
-    LeafInstance* leafInstance = new LeafInstance(&leaf);
-    _leafInstanceList.push_back(leafInstance);
-
+    // FIXME: move to LeafInstance??
     for (unsigned i = 0; i < leaf.getNumPorts(); ++i) {
       PortId portId = leaf.getPortId(i);
       LeafInstance::LeafPortData* portData = leafInstance->getPortData(portId);
@@ -410,11 +429,17 @@
 
   virtual void apply(MechanicNode& node)
   {
-    apply(static_cast<LeafNode&>(node));
+    MechanicInstance* mechanicInstance = new MechanicInstance(&node);
+    _leafInstanceList.push_back(mechanicInstance);
+    _mechanicInstanceList.push_back(mechanicInstance);
+    allocPortData(mechanicInstance, node);
   }
   virtual void apply(Model& node)
   {
-    apply(static_cast<LeafNode&>(node));
+    ModelInstance* modelInstance = new ModelInstance(&node);
+    _leafInstanceList.push_back(modelInstance);
+    _modelInstanceList.push_back(modelInstance);
+    allocPortData(modelInstance, node);
   }
 
   virtual void apply(Group& group)
@@ -500,6 +525,11 @@
   typedef std::list<SharedPtr<LeafInstance> > LeafInstanceList;
   LeafInstanceList _leafInstanceList;
 
+  typedef std::list<SharedPtr<ModelInstance> > ModelInstanceList;
+  ModelInstanceList _modelInstanceList;
+  typedef std::list<SharedPtr<MechanicInstance> > MechanicInstanceList;
+  MechanicInstanceList _mechanicInstanceList;
+
   ////////////////////////////////////////////////////////////////////////////
   // Used to map connections in groups ...
   typedef std::map<PortId, SharedPtr<LeafInstance::PortData> > NodePortDataMap;
@@ -508,26 +538,26 @@
 
 
   // method to sort the leafs according to their dependency
-  bool sortLeafList()
+  bool sortModelList()
   {
-    LeafInstanceList sortedLeafInstanceList;
-    while (!_leafInstanceList.empty()) {
-      SharedPtr<LeafInstance> leafInstance = _leafInstanceList.front();
-      _leafInstanceList.pop_front();
+    ModelInstanceList sortedModelInstanceList;
+    while (!_modelInstanceList.empty()) {
+      SharedPtr<ModelInstance> modelInstance = _modelInstanceList.front();
+      _modelInstanceList.pop_front();
 
-      LeafInstanceList::iterator i;
-      for (i = sortedLeafInstanceList.begin();
-           i != sortedLeafInstanceList.end();
+      ModelInstanceList::iterator i;
+      for (i = sortedModelInstanceList.begin();
+           i != sortedModelInstanceList.end();
            ++i) {
-        if (!(*i)->dependsOn(leafInstance))
+        if (!(*i)->dependsOn(modelInstance))
           continue;
-        sortedLeafInstanceList.insert(i, leafInstance);
+        sortedModelInstanceList.insert(i, modelInstance);
         break;
       }
-      if (i == sortedLeafInstanceList.end())
-        sortedLeafInstanceList.push_back(leafInstance);
+      if (i == sortedModelInstanceList.end())
+        sortedModelInstanceList.push_back(modelInstance);
     }
-    _leafInstanceList.swap(sortedLeafInstanceList);
+    _modelInstanceList.swap(sortedModelInstanceList);
   }
 
   
@@ -587,13 +617,11 @@
   LeafInstanceCollector nodeInstanceCollector;
   topGroup->accept(nodeInstanceCollector);
   
-  nodeInstanceCollector.sortLeafList();
+  nodeInstanceCollector.sortModelList();
 
-  std::cout << nodeInstanceCollector._leafInstanceList.size() << std::endl;
-
-  LeafInstanceCollector::LeafInstanceList::const_iterator i;
-  for (i = nodeInstanceCollector._leafInstanceList.begin();
-       i != nodeInstanceCollector._leafInstanceList.end();
+  LeafInstanceCollector::ModelInstanceList::const_iterator i;
+  for (i = nodeInstanceCollector._modelInstanceList.begin();
+       i != nodeInstanceCollector._modelInstanceList.end();
        ++i) {
     (*i)->print();
   }



From frohlich at mail.berlios.de  Thu Sep 11 18:22:37 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Thu, 11 Sep 2008 18:22:37 +0200
Subject: [OpenFDM-svn] r459 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200809111622.m8BGMbaj031417@sheep.berlios.de>

Author: frohlich
Date: 2008-09-11 18:22:37 +0200 (Thu, 11 Sep 2008)
New Revision: 459

Modified:
   trunk/OpenFDM/src/OpenFDM/LogStream.h
   trunk/OpenFDM/src/OpenFDM/Logger.cpp
Log:
Loggin can be that easy :).


Modified: trunk/OpenFDM/src/OpenFDM/LogStream.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/LogStream.h	2008-09-10 18:45:53 UTC (rev 458)
+++ trunk/OpenFDM/src/OpenFDM/LogStream.h	2008-09-11 16:22:37 UTC (rev 459)
@@ -6,193 +6,72 @@
 #define OpenFDM_LogStream_H
 
 #include <iosfwd>
+// FIXME: because of using std::endl;
 #include <ostream>
 
 namespace OpenFDM {
 
-namespace Log {
-
-enum Category {
-  ArtBody          = 1,
-  MultiBody        = ArtBody << 1,
-  TimeStep         = MultiBody << 1,
-  BoundCheck       = TimeStep << 1,
-  Environment      = BoundCheck << 1,
-  Frame            = Environment << 1,
-  Initialization   = Frame << 1,
-  NewtonMethod     = Initialization << 1,
-  Misc             = NewtonMethod << 1,
-  Model            = Misc << 1,
-  Schedule         = Model << 1,
-  Assert           = ~0
-};
-
-enum Priority {
-  Error            = 0,
-  Warning          = Error + 1,
-  Info             = Warning + 1,
-  Debug            = Info + 1,
-  Debug1           = Debug + 1,
-  Debug2           = Debug1 + 1,
-  Debug3           = Debug2 + 1
-};
-
-template<Category category, Priority priority>
-class LogFactory;
-
-template<typename charT, typename traits = std::char_traits<charT> >
-class LogProxy;
-
-template<typename charT, typename traits = std::char_traits<charT> >
-class LogSink;
-
-template<class charT, class traits>
-class LogProxy {
-public:
-  typedef std::ios_base                    ios_base_type;
-  typedef std::basic_ios<charT,traits>     basic_ios_type;
-  typedef std::basic_ostream<charT,traits> basic_ostream_type;
-
-  template<typename T>
-  LogProxy operator<<(const T& value)
-  { if (mStream) (*mStream) << value; return *this; }
-  LogProxy operator<<(ios_base_type& (*mptr)(ios_base_type&))
-  { if (mStream) mptr(*mStream); return *this; }
-  LogProxy operator<<(basic_ios_type& (*mptr)(basic_ios_type&))
-  { if (mStream) mptr(*mStream); return *this; }
-  LogProxy operator<<(basic_ostream_type& (*mptr)(basic_ostream_type&))
-  { if (mStream) mptr(*mStream); return *this; }
-
-private:
-  template<Category category, Priority priority>
-  friend class LogFactory;
-
-  LogProxy(const LogProxy& lp) : mStream(lp.mStream) {}
-  LogProxy(basic_ostream_type* s) : mStream(s) {}
-  LogProxy& operator=(const LogProxy&);
-
-  // A pointer to a stream we want to do output to.
-  basic_ostream_type* mStream;
-};
-
-template<class charT, class traits>
-class LogSink {
-public:
-  typedef std::ios_base                    ios_base_type;
-  typedef std::basic_ios<charT,traits>     basic_ios_type;
-  typedef std::basic_ostream<charT,traits> basic_ostream_type;
-
-  template<typename T>
-  LogSink operator<<(const T&)
-  { return *this; }
-  LogSink operator<<(ios_base_type& (*mptr)(ios_base_type&))
-  { return *this; }
-  LogSink operator<<(basic_ios_type& (*mptr)(basic_ios_type&))
-  { return *this; }
-  LogSink operator<<(basic_ostream_type& (*mptr)(basic_ostream_type&))
-  { return *this; }
-
-private:
-  template<Category category, Priority priority>
-  friend class LogFactory;
-
-  LogSink(const LogSink&) {}
-  LogSink(void) {}
-  LogSink& operator=(const LogSink&);
-};
-
 class Logger {
 public:
+  enum Category {
+    ArtBody          = 1,
+    MultiBody        = ArtBody << 1,
+    TimeStep         = MultiBody << 1,
+    BoundCheck       = TimeStep << 1,
+    Environment      = BoundCheck << 1,
+    Frame            = Environment << 1,
+    Initialization   = Frame << 1,
+    NewtonMethod     = Initialization << 1,
+    Misc             = NewtonMethod << 1,
+    Model            = Misc << 1,
+    Schedule         = Model << 1,
+    Assert           = ~0
+  };
+  
+  enum Priority {
+    Error            = 0,
+    Warning          = Error + 1,
+    Info             = Warning + 1,
+    Debug            = Info + 1,
+    Debug1           = Debug + 1,
+    Debug2           = Debug1 + 1,
+    Debug3           = Debug2 + 1
+  };
+  
   static void setCategoryEnable(Category category, bool enable = true);
   static void setCategoryDisable(Category category);
   static void setPriority(Priority priority);
 
-  bool enabled(Category category, Priority priority) const
+  static inline bool
+  getStaticEnabled(Category category, Priority priority)
   {
-    return ((category & mCategory) && (priority <= mPriority))
-      || (priority == Error);
+#if defined(NDEBUG) || defined(_NDEBUG)
+    // In the NDEBUG case, give the compilers optimizer a chance to
+    // completely remove the code.
+    if (Info <= priority)
+      return false;
+#endif
+    return Instance()->getEnabled(category, priority);
   }
+  
+  static std::ostream& getStream(Priority priority);
 
-  std::basic_ostream<char>* getStream(void)
-  { return mStream; }
-
 protected:
   static Logger* Instance(void);
+  bool getEnabled(Category category, Priority priority);
 
 private:
-  Logger(std::basic_ostream<char>* stream = 0);
+  Logger(std::ostream* stream = 0);
 
-  std::basic_ostream<char>* mStream;
+  std::ostream* mStream;
   unsigned mCategory;
   int mPriority;
 };
 
-#if defined(NDEBUG)
-
-template<Category category, Priority priority>
-class LogFactory : public Logger {
-public:
-  typedef LogSink<char> proxy_type;
-  static proxy_type
-  CreateInstance(void)
-  { return proxy_type(); }
-};
-
-template<Category category>
-class LogFactory<category,Error> : public Logger {
-public:
-  typedef LogProxy<char> proxy_type;
-  static proxy_type
-  CreateInstance(void)
-  {
-    Logger* logger = Instance();
-    if (logger->enabled(category, Error))
-      return proxy_type(logger->getStream());
-    else
-      return proxy_type(0);
-  }
-};
-
-template<Category category>
-class LogFactory<category,Warning> : public Logger {
-public:
-  typedef LogProxy<char> proxy_type;
-  static proxy_type
-  CreateInstance(void)
-  {
-    Logger* logger = Instance();
-    if (logger->enabled(category, Warning))
-      return proxy_type(logger->getStream());
-    else
-      return proxy_type(0);
-  }
-};
-
-#else /* defined(NDEBUG) */
-
-template<Category category, Priority priority>
-class LogFactory : public Logger {
-public:
-  static LogProxy<char>
-  CreateInstance(void)
-  {
-    Logger* logger = Instance();
-    if (logger->enabled(category, priority))
-      return LogProxy<char>(logger->getStream());
-    else
-      return LogProxy<char>(0);
-  }
-};
-
-#endif /* else defined(NDEBUG) */
-
-} // namespace Log
-
 #define Log(category, priority) \
-  Log::LogFactory<Log::category,Log::priority>::CreateInstance()
+if (Logger::getStaticEnabled(Logger::category, Logger::priority)) \
+  Logger::getStream(Logger::priority)
 
-using Log::Logger;
-
 using std::endl;
 
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/Logger.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Logger.cpp	2008-09-10 18:45:53 UTC (rev 458)
+++ trunk/OpenFDM/src/OpenFDM/Logger.cpp	2008-09-11 16:22:37 UTC (rev 459)
@@ -12,8 +12,6 @@
 
 namespace OpenFDM {
 
-namespace Log {
-
 static unsigned
 atou(const char* s)
 {
@@ -29,23 +27,8 @@
   return value;
 }
 
-Logger::Logger(std::basic_ostream<char>* stream) :
-  mStream(stream),
-  mCategory(~0u),
-  mPriority(Log::Error)
-{
-  // Set some defaults from the environment
-  unsigned value = atou(std::getenv("OPENFDM_DEBUG_PRIORITY"));
-  if (value)
-    mPriority = value;
-      
-  value = atou(std::getenv("OPENFDM_DEBUG_CATEGORY"));
-  if (value)
-    mCategory = value;
-}
-
 void
-Logger::setCategoryEnable(Log::Category category, bool enable)
+Logger::setCategoryEnable(Logger::Category category, bool enable)
 {
   Logger* logger = Instance();
   if (enable) {
@@ -56,18 +39,30 @@
 }
 
 void
-Logger::setCategoryDisable(Log::Category category)
+Logger::setCategoryDisable(Logger::Category category)
 {
   setCategoryEnable(category, false);
 }
 
 void
-Logger::setPriority(Log::Priority priority)
+Logger::setPriority(Logger::Priority priority)
 {
   Logger* logger = Instance();
   logger->mPriority = priority;
 }
 
+std::ostream&
+Logger::getStream(Logger::Priority priority)
+{
+  Logger* logger = Instance();
+  if (logger->mStream)
+    return *logger->mStream;
+  else if (Info <= priority)
+    return std::cout;
+  else
+    return std::cerr;
+}
+
 Logger*
 Logger::Instance(void)
 {
@@ -83,6 +78,29 @@
   return ptr;
 }
 
-} // namespace Log
+bool
+Logger::getEnabled(Logger::Category category, Logger::Priority priority)
+{
+  if (priority == Error)
+    return true;
+  if (!(category & mCategory))
+    return false;
+  return priority <= mPriority;
+}
 
+Logger::Logger(std::ostream* stream) :
+  mStream(stream),
+  mCategory(~0u),
+  mPriority(Error)
+{
+  // Set some defaults from the environment
+  unsigned value = atou(std::getenv("OPENFDM_DEBUG_PRIORITY"));
+  if (value)
+    mPriority = value;
+      
+  value = atou(std::getenv("OPENFDM_DEBUG_CATEGORY"));
+  if (value)
+    mCategory = value;
+}
+
 } // namespace OpenFDM



From frohlich at mail.berlios.de  Thu Sep 11 18:28:48 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Thu, 11 Sep 2008 18:28:48 +0200
Subject: [OpenFDM-svn] r460 - in branches/OpenFDM-StateSeparation: .
	src/OpenFDM
Message-ID: <200809111628.m8BGSm8w031996@sheep.berlios.de>

Author: frohlich
Date: 2008-09-11 18:28:48 +0200 (Thu, 11 Sep 2008)
New Revision: 460

Modified:
   branches/OpenFDM-StateSeparation/MERGE-REVISION
   branches/OpenFDM-StateSeparation/src/OpenFDM/LogStream.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Logger.cpp
Log:
Merge changes from trunk


Modified: branches/OpenFDM-StateSeparation/MERGE-REVISION
===================================================================
--- branches/OpenFDM-StateSeparation/MERGE-REVISION	2008-09-11 16:22:37 UTC (rev 459)
+++ branches/OpenFDM-StateSeparation/MERGE-REVISION	2008-09-11 16:28:48 UTC (rev 460)
@@ -1 +1 @@
-451
+459

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/LogStream.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/LogStream.h	2008-09-11 16:22:37 UTC (rev 459)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/LogStream.h	2008-09-11 16:28:48 UTC (rev 460)
@@ -6,193 +6,72 @@
 #define OpenFDM_LogStream_H
 
 #include <iosfwd>
+// FIXME: because of using std::endl;
 #include <ostream>
 
 namespace OpenFDM {
 
-namespace Log {
-
-enum Category {
-  ArtBody          = 1,
-  MultiBody        = ArtBody << 1,
-  TimeStep         = MultiBody << 1,
-  BoundCheck       = TimeStep << 1,
-  Environment      = BoundCheck << 1,
-  Frame            = Environment << 1,
-  Initialization   = Frame << 1,
-  NewtonMethod     = Initialization << 1,
-  Misc             = NewtonMethod << 1,
-  Model            = Misc << 1,
-  Schedule         = Model << 1,
-  Assert           = ~0
-};
-
-enum Priority {
-  Error            = 0,
-  Warning          = Error + 1,
-  Info             = Warning + 1,
-  Debug            = Info + 1,
-  Debug1           = Debug + 1,
-  Debug2           = Debug1 + 1,
-  Debug3           = Debug2 + 1
-};
-
-template<Category category, Priority priority>
-class LogFactory;
-
-template<typename charT, typename traits = std::char_traits<charT> >
-class LogProxy;
-
-template<typename charT, typename traits = std::char_traits<charT> >
-class LogSink;
-
-template<class charT, class traits>
-class LogProxy {
-public:
-  typedef std::ios_base                    ios_base_type;
-  typedef std::basic_ios<charT,traits>     basic_ios_type;
-  typedef std::basic_ostream<charT,traits> basic_ostream_type;
-
-  template<typename T>
-  LogProxy operator<<(const T& value)
-  { if (mStream) (*mStream) << value; return *this; }
-  LogProxy operator<<(ios_base_type& (*mptr)(ios_base_type&))
-  { if (mStream) mptr(*mStream); return *this; }
-  LogProxy operator<<(basic_ios_type& (*mptr)(basic_ios_type&))
-  { if (mStream) mptr(*mStream); return *this; }
-  LogProxy operator<<(basic_ostream_type& (*mptr)(basic_ostream_type&))
-  { if (mStream) mptr(*mStream); return *this; }
-
-private:
-  template<Category category, Priority priority>
-  friend class LogFactory;
-
-  LogProxy(const LogProxy& lp) : mStream(lp.mStream) {}
-  LogProxy(basic_ostream_type* s) : mStream(s) {}
-  LogProxy& operator=(const LogProxy&);
-
-  // A pointer to a stream we want to do output to.
-  basic_ostream_type* mStream;
-};
-
-template<class charT, class traits>
-class LogSink {
-public:
-  typedef std::ios_base                    ios_base_type;
-  typedef std::basic_ios<charT,traits>     basic_ios_type;
-  typedef std::basic_ostream<charT,traits> basic_ostream_type;
-
-  template<typename T>
-  LogSink operator<<(const T&)
-  { return *this; }
-  LogSink operator<<(ios_base_type& (*mptr)(ios_base_type&))
-  { return *this; }
-  LogSink operator<<(basic_ios_type& (*mptr)(basic_ios_type&))
-  { return *this; }
-  LogSink operator<<(basic_ostream_type& (*mptr)(basic_ostream_type&))
-  { return *this; }
-
-private:
-  template<Category category, Priority priority>
-  friend class LogFactory;
-
-  LogSink(const LogSink&) {}
-  LogSink(void) {}
-  LogSink& operator=(const LogSink&);
-};
-
 class Logger {
 public:
+  enum Category {
+    ArtBody          = 1,
+    MultiBody        = ArtBody << 1,
+    TimeStep         = MultiBody << 1,
+    BoundCheck       = TimeStep << 1,
+    Environment      = BoundCheck << 1,
+    Frame            = Environment << 1,
+    Initialization   = Frame << 1,
+    NewtonMethod     = Initialization << 1,
+    Misc             = NewtonMethod << 1,
+    Model            = Misc << 1,
+    Schedule         = Model << 1,
+    Assert           = ~0
+  };
+  
+  enum Priority {
+    Error            = 0,
+    Warning          = Error + 1,
+    Info             = Warning + 1,
+    Debug            = Info + 1,
+    Debug1           = Debug + 1,
+    Debug2           = Debug1 + 1,
+    Debug3           = Debug2 + 1
+  };
+  
   static void setCategoryEnable(Category category, bool enable = true);
   static void setCategoryDisable(Category category);
   static void setPriority(Priority priority);
 
-  bool enabled(Category category, Priority priority) const
+  static inline bool
+  getStaticEnabled(Category category, Priority priority)
   {
-    return ((category & mCategory) && (priority <= mPriority))
-      || (priority == Error);
+#if defined(NDEBUG) || defined(_NDEBUG)
+    // In the NDEBUG case, give the compilers optimizer a chance to
+    // completely remove the code.
+    if (Info <= priority)
+      return false;
+#endif
+    return Instance()->getEnabled(category, priority);
   }
+  
+  static std::ostream& getStream(Priority priority);
 
-  std::basic_ostream<char>* getStream(void)
-  { return mStream; }
-
 protected:
   static Logger* Instance(void);
+  bool getEnabled(Category category, Priority priority);
 
 private:
-  Logger(std::basic_ostream<char>* stream = 0);
+  Logger(std::ostream* stream = 0);
 
-  std::basic_ostream<char>* mStream;
+  std::ostream* mStream;
   unsigned mCategory;
   int mPriority;
 };
 
-#if defined(NDEBUG)
-
-template<Category category, Priority priority>
-class LogFactory : public Logger {
-public:
-  typedef LogSink<char> proxy_type;
-  static proxy_type
-  CreateInstance(void)
-  { return proxy_type(); }
-};
-
-template<Category category>
-class LogFactory<category,Error> : public Logger {
-public:
-  typedef LogProxy<char> proxy_type;
-  static proxy_type
-  CreateInstance(void)
-  {
-    Logger* logger = Instance();
-    if (logger->enabled(category, Error))
-      return proxy_type(logger->getStream());
-    else
-      return proxy_type(0);
-  }
-};
-
-template<Category category>
-class LogFactory<category,Warning> : public Logger {
-public:
-  typedef LogProxy<char> proxy_type;
-  static proxy_type
-  CreateInstance(void)
-  {
-    Logger* logger = Instance();
-    if (logger->enabled(category, Warning))
-      return proxy_type(logger->getStream());
-    else
-      return proxy_type(0);
-  }
-};
-
-#else /* defined(NDEBUG) */
-
-template<Category category, Priority priority>
-class LogFactory : public Logger {
-public:
-  static LogProxy<char>
-  CreateInstance(void)
-  {
-    Logger* logger = Instance();
-    if (logger->enabled(category, priority))
-      return LogProxy<char>(logger->getStream());
-    else
-      return LogProxy<char>(0);
-  }
-};
-
-#endif /* else defined(NDEBUG) */
-
-} // namespace Log
-
 #define Log(category, priority) \
-  Log::LogFactory<Log::category,Log::priority>::CreateInstance()
+if (Logger::getStaticEnabled(Logger::category, Logger::priority)) \
+  Logger::getStream(Logger::priority)
 
-using Log::Logger;
-
 using std::endl;
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Logger.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Logger.cpp	2008-09-11 16:22:37 UTC (rev 459)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Logger.cpp	2008-09-11 16:28:48 UTC (rev 460)
@@ -12,8 +12,6 @@
 
 namespace OpenFDM {
 
-namespace Log {
-
 static unsigned
 atou(const char* s)
 {
@@ -29,23 +27,8 @@
   return value;
 }
 
-Logger::Logger(std::basic_ostream<char>* stream) :
-  mStream(stream),
-  mCategory(~0u),
-  mPriority(Log::Error)
-{
-  // Set some defaults from the environment
-  unsigned value = atou(std::getenv("OPENFDM_DEBUG_PRIORITY"));
-  if (value)
-    mPriority = value;
-      
-  value = atou(std::getenv("OPENFDM_DEBUG_CATEGORY"));
-  if (value)
-    mCategory = value;
-}
-
 void
-Logger::setCategoryEnable(Log::Category category, bool enable)
+Logger::setCategoryEnable(Logger::Category category, bool enable)
 {
   Logger* logger = Instance();
   if (enable) {
@@ -56,18 +39,30 @@
 }
 
 void
-Logger::setCategoryDisable(Log::Category category)
+Logger::setCategoryDisable(Logger::Category category)
 {
   setCategoryEnable(category, false);
 }
 
 void
-Logger::setPriority(Log::Priority priority)
+Logger::setPriority(Logger::Priority priority)
 {
   Logger* logger = Instance();
   logger->mPriority = priority;
 }
 
+std::ostream&
+Logger::getStream(Logger::Priority priority)
+{
+  Logger* logger = Instance();
+  if (logger->mStream)
+    return *logger->mStream;
+  else if (Info <= priority)
+    return std::cout;
+  else
+    return std::cerr;
+}
+
 Logger*
 Logger::Instance(void)
 {
@@ -83,6 +78,29 @@
   return ptr;
 }
 
-} // namespace Log
+bool
+Logger::getEnabled(Logger::Category category, Logger::Priority priority)
+{
+  if (priority == Error)
+    return true;
+  if (!(category & mCategory))
+    return false;
+  return priority <= mPriority;
+}
 
+Logger::Logger(std::ostream* stream) :
+  mStream(stream),
+  mCategory(~0u),
+  mPriority(Error)
+{
+  // Set some defaults from the environment
+  unsigned value = atou(std::getenv("OPENFDM_DEBUG_PRIORITY"));
+  if (value)
+    mPriority = value;
+      
+  value = atou(std::getenv("OPENFDM_DEBUG_CATEGORY"));
+  if (value)
+    mCategory = value;
+}
+
 } // namespace OpenFDM



From frohlich at mail.berlios.de  Fri Sep 12 13:37:53 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Fri, 12 Sep 2008 13:37:53 +0200
Subject: [OpenFDM-svn] r461 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200809121137.m8CBbrXT025099@sheep.berlios.de>

Author: frohlich
Date: 2008-09-12 13:37:53 +0200 (Fri, 12 Sep 2008)
New Revision: 461

Modified:
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Plug memory leak.


Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-11 16:28:48 UTC (rev 460)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-12 11:37:53 UTC (rev 461)
@@ -303,6 +303,8 @@
 
   LeafInstance(const LeafNode* leaf)
   { allocPorts(leaf); }
+  virtual ~LeafInstance()
+  { }
 
   LeafPortData* getPortData(const PortId& portId)
   {



From frohlich at mail.berlios.de  Fri Sep 12 14:21:37 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Fri, 12 Sep 2008 14:21:37 +0200
Subject: [OpenFDM-svn] r462 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200809121221.m8CCLbuJ030042@sheep.berlios.de>

Author: frohlich
Date: 2008-09-12 14:21:37 +0200 (Fri, 12 Sep 2008)
New Revision: 462

Modified:
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
A bit more initialization.


Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-12 11:37:53 UTC (rev 461)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-12 12:21:37 UTC (rev 462)
@@ -346,6 +346,45 @@
     }
   }
 
+  bool allocAndConnectProviderPortValues()
+  {
+    for (unsigned i = 0; i < getLeafNode()->getNumPorts(); ++i) {
+      const ProviderPortInfo* providerPortInfo;
+      providerPortInfo = getLeafNode()->getPort(i)->toProviderPortInfo();
+      if (providerPortInfo) {
+        PortValue* portValue = providerPortInfo->newValue();
+        mLeafContext.mPortValueList.setPortValue(i, portValue);
+
+        // Also set the port value to all connected ports
+        ProviderPortData* providerPortData = mPortData[i]->toProviderPortData();
+        OpenFDMAssert(providerPortData);
+
+        for (unsigned j = 0; j < providerPortData->_acceptorPortDataList.size();
+             ++j) {
+          SharedPtr<AcceptorPortData> acceptorPortData;
+          acceptorPortData = providerPortData->_acceptorPortDataList[j].lock();
+          // Ok, happens for proxy ports, these still show up here
+          if (acceptorPortData) {
+            SharedPtr<LeafInstance> leafInstance;
+            leafInstance = acceptorPortData->getLeafInstance();
+            OpenFDMAssert(leafInstance);
+            
+            OpenFDMAssert(acceptorPortData->getPortInfo());
+            unsigned index = acceptorPortData->getPortInfo()->getIndex();
+            leafInstance->
+              mLeafContext.mPortValueList.setPortValue(index, portValue);
+          }
+        }
+      }
+    }
+  }
+  bool alloc()
+  {
+    return getLeafNode()->alloc(mLeafContext);
+  }
+
+  LeafContext mLeafContext;
+
 private:
   void allocPorts(const Node* node)
   {
@@ -562,7 +601,38 @@
     _modelInstanceList.swap(sortedModelInstanceList);
   }
 
-  
+  typedef std::vector<SharedPtr<ModelInstance> > ModelContextList;
+
+  bool
+  getModelContextList(ModelContextList& modelContexts)
+  {
+    modelContexts.resize(0);
+
+    ModelContextList modelContextList;
+    modelContextList.reserve(_modelInstanceList.size());
+    ModelInstanceList::const_iterator i;
+    for (i = _modelInstanceList.begin(); i != _modelInstanceList.end(); ++i)
+      modelContextList.push_back((*i));
+
+    ModelContextList::const_iterator j;
+    for (j = modelContextList.begin(); j != modelContextList.end(); ++j) {
+      if (!(*j)->allocAndConnectProviderPortValues()) {
+        Log(Schedule, Error) << "Could not alloc for model ... FIXME" << endl;
+        return false;
+      }
+    }
+
+    for (j = modelContextList.begin(); j != modelContextList.end(); ++j) {
+      if (!(*j)->alloc()) {
+        Log(Schedule, Error) << "Could not alloc for model ... FIXME" << endl;
+        return false;
+      }
+    }
+
+    modelContexts.swap(modelContextList);
+    return true;
+  }
+
   void pushNodeId(const Group::NodeId& nodeId)
   { _nodeIdStack.push_back(nodeId); }
   void popNodeId()
@@ -628,6 +698,9 @@
     (*i)->print();
   }
 
+  LeafInstanceCollector::ModelContextList modelContextList;
+  nodeInstanceCollector.getModelContextList(modelContextList);
+
   return 0;
 }
 



From frohlich at mail.berlios.de  Fri Sep 12 14:28:48 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Fri, 12 Sep 2008 14:28:48 +0200
Subject: [OpenFDM-svn] r463 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200809121228.m8CCSmem031090@sheep.berlios.de>

Author: frohlich
Date: 2008-09-12 14:28:48 +0200 (Fri, 12 Sep 2008)
New Revision: 463

Modified:
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
More sketches ...


Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-12 12:21:37 UTC (rev 462)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-12 12:28:48 UTC (rev 463)
@@ -708,7 +708,7 @@
 // Kabelbaum <-> PortBundle ??? Original Kabelbaum == Cabel Bundle
 // Oder Cable Set <-> Port Set???
 
-// class CompositeNode : public Object /*??*/ {
+// class CompositeNode : public Node {
 //   // Might be something that behaves like a model, but depending on the input
 //   // and output port types issues different final leafs scheduler ...
 
@@ -716,6 +716,9 @@
 //   // would be good, would simplify groups enormous
 // };
 
+// class Group : public CompositeNode {
+// };
+
 // class LibraryNode;
 
 // class LibraryModel : public Object {
@@ -737,13 +740,15 @@
 //   { return mNode; }
 //   SharedPtr<const Node> getNode() const
 //   { return mNode; }
+//   void setNode(Node* node)
+//   { mNode = node; }
 
 // private:
 //   SharedPtr<Node> mNode;
 //   std::vector<WeakPtr<LibraryNode> > mParents;
 // };
 
-// class LibraryNode : public Node {
+// class LibraryNode : public CompositeNode {
 // public:
 //   LibraryNode(const std::string& name, LibraryModel* libraryModel = 0) :
 //     Node(name),



From frohlich at mail.berlios.de  Fri Sep 12 14:36:56 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Fri, 12 Sep 2008 14:36:56 +0200
Subject: [OpenFDM-svn] r464 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200809121236.m8CCau1I032021@sheep.berlios.de>

Author: frohlich
Date: 2008-09-12 14:36:55 +0200 (Fri, 12 Sep 2008)
New Revision: 464

Modified:
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
more sketches ...


Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-12 12:28:48 UTC (rev 463)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-12 12:36:55 UTC (rev 464)
@@ -728,13 +728,13 @@
 //     mNode(node)
 //   { }
 
-//   unsigned getNumParents() const
-//   { return mParents.size(); }
+//   unsigned getNumParentNodes() const
+//   { return mParentNodes.size(); }
   
 //   WeakPtr<LibraryNode> getParent(unsigned i)
-//   { if (mParents.size() <= i) return 0; return mParents[i]; }
+//   { if (mParentNodes.size() <= i) return 0; return mParentNodes[i]; }
 //   WeakPtr<const LibraryNode> getParent(unsigned i) const
-//   { if (mParents.size() <= i) return 0; return mParents[i]; }
+//   { if (mParentNodes.size() <= i) return 0; return mParentNodes[i]; }
 
 //   SharedPtr<Node> getNode()
 //   { return mNode; }
@@ -745,7 +745,7 @@
 
 // private:
 //   SharedPtr<Node> mNode;
-//   std::vector<WeakPtr<LibraryNode> > mParents;
+//   std::vector<WeakPtr<LibraryNode> > mParentNodes;
 // };
 
 // class LibraryNode : public CompositeNode {
@@ -763,6 +763,8 @@
 //   { return mLibraryModel; }
 //   SharedPtr<const LibraryModel> getLibraryModel() const
 //   { return mLibraryModel; }
+//   void setLibraryModel(LibraryModel* libraryModel)
+//   { mLibraryModel = libraryModel; }
 
 // private:
 //   SharedPtr<LibraryModel> mLibraryModel;



From frohlich at mail.berlios.de  Fri Sep 12 19:43:42 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Fri, 12 Sep 2008 19:43:42 +0200
Subject: [OpenFDM-svn] r465 - in branches/OpenFDM-StateSeparation/src:
	OpenFDM test
Message-ID: <200809121743.m8CHhg8R029850@sheep.berlios.de>

Author: frohlich
Date: 2008-09-12 19:43:41 +0200 (Fri, 12 Sep 2008)
New Revision: 465

Added:
   branches/OpenFDM-StateSeparation/src/OpenFDM/LibraryModel.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/LibraryModel.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/LibraryNode.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/LibraryNode.h
Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
   branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.h
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Move Library nodes into the real implementation.


Added: branches/OpenFDM-StateSeparation/src/OpenFDM/LibraryModel.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/LibraryModel.cpp	2008-09-12 12:36:55 UTC (rev 464)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/LibraryModel.cpp	2008-09-12 17:43:41 UTC (rev 465)
@@ -0,0 +1,64 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
+ *
+ */
+
+#include "LibraryModel.h"
+
+#include "LibraryNode.h"
+
+namespace OpenFDM {
+
+BEGIN_OPENFDM_OBJECT_DEF(LibraryModel, Object)
+  END_OPENFDM_OBJECT_DEF
+
+LibraryModel::LibraryModel(const std::string& name, Node* node) :
+  Object(name),
+  mNode(node)
+{
+}
+
+LibraryModel::~LibraryModel()
+{
+}
+
+unsigned
+LibraryModel::getNumParentNodes() const
+{
+  return mParentNodes.size();
+}
+  
+WeakPtr<LibraryNode>
+LibraryModel::getParent(unsigned i)
+{
+  if (mParentNodes.size() <= i)
+    return 0;
+  return mParentNodes[i];
+}
+
+WeakPtr<const LibraryNode>
+LibraryModel::getParent(unsigned i) const
+{
+  if (mParentNodes.size() <= i)
+    return 0;
+  return mParentNodes[i];
+}
+
+SharedPtr<Node>
+LibraryModel::getNode()
+{
+  return mNode;
+}
+
+SharedPtr<const Node>
+LibraryModel::getNode() const
+{
+  return mNode;
+}
+
+void
+LibraryModel::setNode(Node* node)
+{
+  mNode = node;
+}
+
+} // namespace OpenFDM

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/LibraryModel.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/LibraryModel.h	2008-09-12 12:36:55 UTC (rev 464)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/LibraryModel.h	2008-09-12 17:43:41 UTC (rev 465)
@@ -0,0 +1,40 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_LibraryModel_H
+#define OpenFDM_LibraryModel_H
+
+#include <string>
+#include <vector>
+#include "Object.h"
+#include "Node.h"
+#include "SharedPtr.h"
+
+namespace OpenFDM {
+
+class LibraryNode;
+
+class LibraryModel : public Object {
+  OPENFDM_OBJECT(LibraryModel, Object);
+public:
+  LibraryModel(const std::string& name, Node* node = 0);
+  virtual ~LibraryModel();
+
+  unsigned getNumParentNodes() const;
+  
+  WeakPtr<LibraryNode> getParent(unsigned i);
+  WeakPtr<const LibraryNode> getParent(unsigned i) const;
+
+  SharedPtr<Node> getNode();
+  SharedPtr<const Node> getNode() const;
+  void setNode(Node* node);
+
+private:
+  SharedPtr<Node> mNode;
+  std::vector<WeakPtr<LibraryNode> > mParentNodes;
+};
+
+} // namespace OpenFDM
+
+#endif

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/LibraryNode.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/LibraryNode.cpp	2008-09-12 12:36:55 UTC (rev 464)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/LibraryNode.cpp	2008-09-12 17:43:41 UTC (rev 465)
@@ -0,0 +1,48 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
+ *
+ */
+
+#include "LibraryNode.h"
+
+#include "NodeVisitor.h"
+
+namespace OpenFDM {
+
+BEGIN_OPENFDM_OBJECT_DEF(LibraryNode, Node)
+  END_OPENFDM_OBJECT_DEF
+
+LibraryNode::LibraryNode(const std::string& name, LibraryModel* libraryModel) :
+  Node(name),
+  mLibraryModel(libraryModel)
+{
+}
+
+LibraryNode::~LibraryNode()
+{
+}
+
+void
+LibraryNode::accept(NodeVisitor& visitor)
+{
+  visitor.apply(*this);
+}
+
+SharedPtr<LibraryModel>
+LibraryNode::getLibraryModel()
+{
+  return mLibraryModel;
+}
+
+SharedPtr<const LibraryModel>
+LibraryNode::getLibraryModel() const
+{
+  return mLibraryModel;
+}
+
+void
+LibraryNode::setLibraryModel(LibraryModel* libraryModel)
+{
+  mLibraryModel = libraryModel;
+}
+
+} // namespace OpenFDM

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/LibraryNode.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/LibraryNode.h	2008-09-12 12:36:55 UTC (rev 464)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/LibraryNode.h	2008-09-12 17:43:41 UTC (rev 465)
@@ -0,0 +1,37 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_LibraryNode_H
+#define OpenFDM_LibraryNode_H
+
+#include <string>
+#include "LibraryModel.h"
+#include "Node.h"
+#include "SharedPtr.h"
+
+namespace OpenFDM {
+
+class LibraryNode : public Node {
+  OPENFDM_OBJECT(LibraryNode, Node);
+public:
+  LibraryNode(const std::string& name, LibraryModel* libraryModel = 0);
+  virtual ~LibraryNode();
+
+  virtual void accept(NodeVisitor& visitor);
+
+  // FIXME: Hmm, how do we map ports??
+  // May be the Node just gets virtuals for ports???
+  // May be changing ports means informing the parent about that???
+
+  SharedPtr<LibraryModel> getLibraryModel();
+  SharedPtr<const LibraryModel> getLibraryModel() const;
+  void setLibraryModel(LibraryModel* libraryModel);
+
+private:
+  SharedPtr<LibraryModel> mLibraryModel;
+};
+
+} // namespace OpenFDM
+
+#endif

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-09-12 12:36:55 UTC (rev 464)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-09-12 17:43:41 UTC (rev 465)
@@ -33,6 +33,8 @@
   Interact.h \
   LeafContext.h \
   LeafNode.h \
+  LibraryModel.h \
+  LibraryNode.h \
   Limits.h \
   LinAlg/Algorithm.h \
   LinAlg/Array.h \
@@ -119,6 +121,8 @@
   Group.cpp \
   Interact.cpp \
   LeafNode.cpp \
+  LibraryModel.cpp \
+  LibraryNode.cpp \
   Logger.cpp \
   MatrixStateValue.cpp \
   MechanicNode.cpp \

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.cpp	2008-09-12 12:36:55 UTC (rev 464)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.cpp	2008-09-12 17:43:41 UTC (rev 465)
@@ -6,6 +6,7 @@
 
 #include "Group.h"
 #include "Interact.h"
+#include "LibraryNode.h"
 #include "LeafNode.h"
 #include "MechanicNode.h"
 #include "Model.h"
@@ -41,6 +42,12 @@
 }
 
 void
+NodeVisitor::apply(LibraryNode& libraryNode)
+{
+  apply(static_cast<Node&>(libraryNode));
+}
+
+void
 NodeVisitor::apply(LeafNode& leafNode)
 {
   apply(static_cast<Node&>(leafNode));

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.h	2008-09-12 12:36:55 UTC (rev 464)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.h	2008-09-12 17:43:41 UTC (rev 465)
@@ -11,6 +11,7 @@
 class Group;
 class GroupAcceptorNode;
 class GroupProviderNode;
+class LibraryNode;
 class LeafNode;
 class Model;
 class MechanicNode;
@@ -22,11 +23,16 @@
   virtual ~NodeVisitor();
 
   virtual void apply(Node&);
+
   virtual void apply(Group&);
   virtual void apply(GroupAcceptorNode&);
   virtual void apply(GroupProviderNode&);
+
+  virtual void apply(LibraryNode&);
+
   virtual void apply(LeafNode&);
   virtual void apply(Model&);
+
   virtual void apply(MechanicNode&);
   virtual void apply(RigidBody&);
   virtual void apply(Interact&);

Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-12 12:36:55 UTC (rev 464)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-12 17:43:41 UTC (rev 465)
@@ -438,6 +438,8 @@
   { std::cerr << __PRETTY_FUNCTION__ << std::endl; }
   virtual void apply(LeafNode& leaf)
   { std::cerr << __PRETTY_FUNCTION__ << std::endl; }
+  virtual void apply(LibraryNode& libraryNode)
+  { std::cerr << __PRETTY_FUNCTION__ << std::endl; }
 
   // Aussen acceptor, innen provider
   virtual void apply(GroupAcceptorNode& leaf)
@@ -708,64 +710,3 @@
 // Kabelbaum <-> PortBundle ??? Original Kabelbaum == Cabel Bundle
 // Oder Cable Set <-> Port Set???
 
-// class CompositeNode : public Node {
-//   // Might be something that behaves like a model, but depending on the input
-//   // and output port types issues different final leafs scheduler ...
-
-//   // FIXME: is it possible to make 'Library models' from that one?
-//   // would be good, would simplify groups enormous
-// };
-
-// class Group : public CompositeNode {
-// };
-
-// class LibraryNode;
-
-// class LibraryModel : public Object {
-// public:
-//   LibraryModel(const std::string& name, Node* node = 0) :
-//     Object(name),
-//     mNode(node)
-//   { }
-
-//   unsigned getNumParentNodes() const
-//   { return mParentNodes.size(); }
-  
-//   WeakPtr<LibraryNode> getParent(unsigned i)
-//   { if (mParentNodes.size() <= i) return 0; return mParentNodes[i]; }
-//   WeakPtr<const LibraryNode> getParent(unsigned i) const
-//   { if (mParentNodes.size() <= i) return 0; return mParentNodes[i]; }
-
-//   SharedPtr<Node> getNode()
-//   { return mNode; }
-//   SharedPtr<const Node> getNode() const
-//   { return mNode; }
-//   void setNode(Node* node)
-//   { mNode = node; }
-
-// private:
-//   SharedPtr<Node> mNode;
-//   std::vector<WeakPtr<LibraryNode> > mParentNodes;
-// };
-
-// class LibraryNode : public CompositeNode {
-// public:
-//   LibraryNode(const std::string& name, LibraryModel* libraryModel = 0) :
-//     Node(name),
-//     mLibraryModel(libraryModel)
-//   { }
-
-//   // Hmm, how do we map ports??
-//   // May be the Node just gets virtuals for ports???
-//   // May be changing ports means informing the parent about that???
-
-//   SharedPtr<LibraryModel> getLibraryModel()
-//   { return mLibraryModel; }
-//   SharedPtr<const LibraryModel> getLibraryModel() const
-//   { return mLibraryModel; }
-//   void setLibraryModel(LibraryModel* libraryModel)
-//   { mLibraryModel = libraryModel; }
-
-// private:
-//   SharedPtr<LibraryModel> mLibraryModel;
-// };



From frohlich at mail.berlios.de  Fri Sep 12 19:50:42 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Fri, 12 Sep 2008 19:50:42 +0200
Subject: [OpenFDM-svn] r466 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200809121750.m8CHogI2030559@sheep.berlios.de>

Author: frohlich
Date: 2008-09-12 19:50:41 +0200 (Fri, 12 Sep 2008)
New Revision: 466

Modified:
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Reindent.


Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-12 17:43:41 UTC (rev 465)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-12 17:50:41 UTC (rev 466)
@@ -351,30 +351,29 @@
     for (unsigned i = 0; i < getLeafNode()->getNumPorts(); ++i) {
       const ProviderPortInfo* providerPortInfo;
       providerPortInfo = getLeafNode()->getPort(i)->toProviderPortInfo();
-      if (providerPortInfo) {
-        PortValue* portValue = providerPortInfo->newValue();
-        mLeafContext.mPortValueList.setPortValue(i, portValue);
+      if (!providerPortInfo)
+        continue;
 
-        // Also set the port value to all connected ports
-        ProviderPortData* providerPortData = mPortData[i]->toProviderPortData();
-        OpenFDMAssert(providerPortData);
-
-        for (unsigned j = 0; j < providerPortData->_acceptorPortDataList.size();
-             ++j) {
-          SharedPtr<AcceptorPortData> acceptorPortData;
-          acceptorPortData = providerPortData->_acceptorPortDataList[j].lock();
-          // Ok, happens for proxy ports, these still show up here
-          if (acceptorPortData) {
-            SharedPtr<LeafInstance> leafInstance;
-            leafInstance = acceptorPortData->getLeafInstance();
-            OpenFDMAssert(leafInstance);
-            
-            OpenFDMAssert(acceptorPortData->getPortInfo());
-            unsigned index = acceptorPortData->getPortInfo()->getIndex();
-            leafInstance->
-              mLeafContext.mPortValueList.setPortValue(index, portValue);
-          }
-        }
+      PortValue* portValue = providerPortInfo->newValue();
+      mLeafContext.mPortValueList.setPortValue(i, portValue);
+      
+      // Also set the port value to all connected ports
+      ProviderPortData* providerPortData = mPortData[i]->toProviderPortData();
+      OpenFDMAssert(providerPortData);
+      
+      for (unsigned j = 0; j < providerPortData->_acceptorPortDataList.size(); ++j) {
+        SharedPtr<AcceptorPortData> acceptorPortData;
+        acceptorPortData = providerPortData->_acceptorPortDataList[j].lock();
+        // Ok, happens for proxy ports, these still show up here
+        if (!acceptorPortData)
+          continue;
+        SharedPtr<LeafInstance> leafInstance;
+        leafInstance = acceptorPortData->getLeafInstance();
+        OpenFDMAssert(leafInstance);
+        
+        OpenFDMAssert(acceptorPortData->getPortInfo());
+        unsigned index = acceptorPortData->getPortInfo()->getIndex();
+        leafInstance->mLeafContext.mPortValueList.setPortValue(index, portValue);
       }
     }
   }



From frohlich at mail.berlios.de  Fri Sep 12 20:04:19 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Fri, 12 Sep 2008 20:04:19 +0200
Subject: [OpenFDM-svn] r467 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200809121804.m8CI4J79032071@sheep.berlios.de>

Author: frohlich
Date: 2008-09-12 20:04:18 +0200 (Fri, 12 Sep 2008)
New Revision: 467

Added:
   branches/OpenFDM-StateSeparation/src/OpenFDM/ConstNodeVisitor.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/ConstNodeVisitor.h
Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Group.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Group.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/LeafNode.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/LeafNode.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/LibraryNode.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/LibraryNode.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Model.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Model.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Node.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Node.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/RigidBody.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/RigidBody.h
Log:
Add ConstNodeVisitor.


Added: branches/OpenFDM-StateSeparation/src/OpenFDM/ConstNodeVisitor.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ConstNodeVisitor.cpp	2008-09-12 17:50:41 UTC (rev 466)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ConstNodeVisitor.cpp	2008-09-12 18:04:18 UTC (rev 467)
@@ -0,0 +1,80 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
+ *
+ */
+
+#include "ConstNodeVisitor.h"
+
+#include "Group.h"
+#include "Interact.h"
+#include "LibraryNode.h"
+#include "LeafNode.h"
+#include "MechanicNode.h"
+#include "Model.h"
+#include "RigidBody.h"
+
+namespace OpenFDM {
+
+ConstNodeVisitor::~ConstNodeVisitor()
+{
+}
+
+void
+ConstNodeVisitor::apply(const Node&)
+{
+}
+
+void
+ConstNodeVisitor::apply(const Group& node)
+{
+  apply(static_cast<const Node&>(node));
+}
+
+void
+ConstNodeVisitor::apply(const GroupAcceptorNode& node)
+{
+  apply(static_cast<const Node&>(node));
+}
+
+void
+ConstNodeVisitor::apply(const GroupProviderNode& node)
+{
+  apply(static_cast<const Node&>(node));
+}
+
+void
+ConstNodeVisitor::apply(const LibraryNode& libraryNode)
+{
+  apply(static_cast<const Node&>(libraryNode));
+}
+
+void
+ConstNodeVisitor::apply(const LeafNode& leafNode)
+{
+  apply(static_cast<const Node&>(leafNode));
+}
+
+void
+ConstNodeVisitor::apply(const Model& node)
+{
+  apply(static_cast<const LeafNode&>(node));
+}
+
+void
+ConstNodeVisitor::apply(const MechanicNode& node)
+{
+  apply(static_cast<const LeafNode&>(node));
+}
+
+void
+ConstNodeVisitor::apply(const RigidBody& node)
+{
+  apply(static_cast<const MechanicNode&>(node));
+}
+
+void
+ConstNodeVisitor::apply(const Interact& node)
+{
+  apply(static_cast<const MechanicNode&>(node));
+}
+
+} // namespace OpenFDM

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/ConstNodeVisitor.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ConstNodeVisitor.h	2008-09-12 17:50:41 UTC (rev 466)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ConstNodeVisitor.h	2008-09-12 18:04:18 UTC (rev 467)
@@ -0,0 +1,43 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_ConstNodeVisitor_H
+#define OpenFDM_ConstNodeVisitor_H
+
+namespace OpenFDM {
+
+class Node;
+class Group;
+class GroupAcceptorNode;
+class GroupProviderNode;
+class LibraryNode;
+class LeafNode;
+class Model;
+class MechanicNode;
+class RigidBody;
+class Interact;
+
+class ConstNodeVisitor {
+public:
+  virtual ~ConstNodeVisitor();
+
+  virtual void apply(const Node&);
+
+  virtual void apply(const Group&);
+  virtual void apply(const GroupAcceptorNode&);
+  virtual void apply(const GroupProviderNode&);
+
+  virtual void apply(const LibraryNode&);
+
+  virtual void apply(const LeafNode&);
+  virtual void apply(const Model&);
+
+  virtual void apply(const MechanicNode&);
+  virtual void apply(const RigidBody&);
+  virtual void apply(const Interact&);
+};
+
+} // namespace OpenFDM
+
+#endif

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Group.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Group.cpp	2008-09-12 17:50:41 UTC (rev 466)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Group.cpp	2008-09-12 18:04:18 UTC (rev 467)
@@ -3,6 +3,7 @@
  */
 
 #include "Group.h"
+#include "ConstNodeVisitor.h"
 #include "NodeVisitor.h"
 
 namespace OpenFDM {
@@ -35,6 +36,12 @@
   visitor.apply(*this);
 }
 
+void
+Group::accept(ConstNodeVisitor& visitor) const
+{
+  visitor.apply(*this);
+}
+
 Group::NodeId
 Group::addChild(const SharedPtr<Node>& node)
 {

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Group.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Group.h	2008-09-12 17:50:41 UTC (rev 466)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Group.h	2008-09-12 18:04:18 UTC (rev 467)
@@ -9,6 +9,7 @@
 #include <vector>
 #include <sstream>
 #include "AcceptorPortInfo.h"
+#include "ConstNodeVisitor.h"
 #include "Node.h"
 #include "NodeVisitor.h"
 #include "Object.h"
@@ -27,6 +28,8 @@
   GroupAcceptorNode();
   virtual void accept(NodeVisitor& visitor)
   { visitor.apply(*this); }
+  virtual void accept(ConstNodeVisitor& visitor) const
+  { visitor.apply(*this); }
 // private:
   SharedPtr<ProxyProviderPortInfo> _groupInternalPort;
 //   WeakPtr<ProxyAcceptorPortInfo> _groupExternalPort;
@@ -37,6 +40,8 @@
   GroupProviderNode();
   virtual void accept(NodeVisitor& visitor)
   { visitor.apply(*this); }
+  virtual void accept(ConstNodeVisitor& visitor) const
+  { visitor.apply(*this); }
 // private:
   SharedPtr<ProxyAcceptorPortInfo> _groupInternalPort;
 //   WeakPtr<ProxyProviderPortInfo> _groupExternalPort;
@@ -76,6 +81,7 @@
   virtual ~Group();
 
   virtual void accept(NodeVisitor& visitor);
+  virtual void accept(ConstNodeVisitor& visitor) const;
 
   NodeId addChild(const SharedPtr<Node>& node);
   unsigned getNumChildren() const;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.cpp	2008-09-12 17:50:41 UTC (rev 466)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.cpp	2008-09-12 18:04:18 UTC (rev 467)
@@ -3,6 +3,8 @@
  */
 
 #include "Interact.h"
+
+#include "ConstNodeVisitor.h"
 #include "NodeVisitor.h"
 
 namespace OpenFDM {
@@ -25,5 +27,10 @@
   visitor.apply(*this);
 }
 
+void
+Interact::accept(ConstNodeVisitor& visitor) const
+{
+  visitor.apply(*this);
+}
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.h	2008-09-12 17:50:41 UTC (rev 466)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.h	2008-09-12 18:04:18 UTC (rev 467)
@@ -18,6 +18,7 @@
   virtual ~Interact();
 
   virtual void accept(NodeVisitor& visitor);
+  virtual void accept(ConstNodeVisitor& visitor) const;
 
 protected:
   MechanicInteractPort newMechanicInteractPort(const std::string& name)

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/LeafNode.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/LeafNode.cpp	2008-09-12 17:50:41 UTC (rev 466)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/LeafNode.cpp	2008-09-12 18:04:18 UTC (rev 467)
@@ -3,6 +3,8 @@
  */
 
 #include "LeafNode.h"
+
+#include "ConstNodeVisitor.h"
 #include "NodeVisitor.h"
 
 namespace OpenFDM {
@@ -25,4 +27,10 @@
   visitor.apply(*this);
 }
 
+void
+LeafNode::accept(ConstNodeVisitor& visitor) const
+{
+  visitor.apply(*this);
+}
+
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/LeafNode.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/LeafNode.h	2008-09-12 17:50:41 UTC (rev 466)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/LeafNode.h	2008-09-12 18:04:18 UTC (rev 467)
@@ -23,6 +23,7 @@
   LeafNode(const std::string& name);
 
   virtual void accept(NodeVisitor& visitor);
+  virtual void accept(ConstNodeVisitor& visitor) const;
 
   // Is done once before a model starts to live
   // Should have connect information here, can setup memory allocations and

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/LibraryNode.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/LibraryNode.cpp	2008-09-12 17:50:41 UTC (rev 466)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/LibraryNode.cpp	2008-09-12 18:04:18 UTC (rev 467)
@@ -4,6 +4,7 @@
 
 #include "LibraryNode.h"
 
+#include "ConstNodeVisitor.h"
 #include "NodeVisitor.h"
 
 namespace OpenFDM {
@@ -27,6 +28,12 @@
   visitor.apply(*this);
 }
 
+void
+LibraryNode::accept(ConstNodeVisitor& visitor) const
+{
+  visitor.apply(*this);
+}
+
 SharedPtr<LibraryModel>
 LibraryNode::getLibraryModel()
 {

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/LibraryNode.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/LibraryNode.h	2008-09-12 17:50:41 UTC (rev 466)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/LibraryNode.h	2008-09-12 18:04:18 UTC (rev 467)
@@ -19,6 +19,7 @@
   virtual ~LibraryNode();
 
   virtual void accept(NodeVisitor& visitor);
+  virtual void accept(ConstNodeVisitor& visitor) const;
 
   // FIXME: Hmm, how do we map ports??
   // May be the Node just gets virtuals for ports???

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-09-12 17:50:41 UTC (rev 466)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-09-12 18:04:18 UTC (rev 467)
@@ -13,6 +13,7 @@
   Atomic.h \
   BoolStateInfo.h \
   ConstFrameVisitor.h \
+  ConstNodeVisitor.h \
   ContinousStateInfo.h \
   ContinousStateInfoVector.h \
   ContinousStateValue.h \
@@ -116,6 +117,7 @@
 OpenFDMCoreSOURCES = \
   Assert.cpp \
   Atomic.cpp \
+  ConstNodeVisitor.cpp \
   ContinousStateValue.cpp \
   Frame.cpp \
   Group.cpp \

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.cpp	2008-09-12 17:50:41 UTC (rev 466)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.cpp	2008-09-12 18:04:18 UTC (rev 467)
@@ -3,6 +3,8 @@
  */
 
 #include "MechanicNode.h"
+
+#include "ConstNodeVisitor.h"
 #include "NodeVisitor.h"
 
 namespace OpenFDM {
@@ -25,4 +27,10 @@
   visitor.apply(*this);
 }
 
+void
+MechanicNode::accept(ConstNodeVisitor& visitor) const
+{
+  visitor.apply(*this);
+}
+
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.h	2008-09-12 17:50:41 UTC (rev 466)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.h	2008-09-12 18:04:18 UTC (rev 467)
@@ -19,6 +19,7 @@
   virtual ~MechanicNode();
 
   virtual void accept(NodeVisitor& visitor);
+  virtual void accept(ConstNodeVisitor& visitor) const;
 
   virtual void velocity(const ContinousStateValueVector&,
                         PortValueList&) const

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Model.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Model.cpp	2008-09-12 17:50:41 UTC (rev 466)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Model.cpp	2008-09-12 18:04:18 UTC (rev 467)
@@ -4,6 +4,7 @@
 
 #include "Model.h"
 
+#include "ConstNodeVisitor.h"
 #include "LogStream.h"
 #include "NodeVisitor.h"
 
@@ -27,4 +28,10 @@
   visitor.apply(*this);
 }
 
+void
+Model::accept(ConstNodeVisitor& visitor) const
+{
+  visitor.apply(*this);
+}
+
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Model.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Model.h	2008-09-12 17:50:41 UTC (rev 466)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Model.h	2008-09-12 18:04:18 UTC (rev 467)
@@ -29,6 +29,7 @@
   virtual ~Model();
 
   virtual void accept(NodeVisitor& visitor);
+  virtual void accept(ConstNodeVisitor& visitor) const;
 
   // FIXME: May be we want to collapse all state values in one
   // argument? May be it is sufficient to have a const and non const version??

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Node.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Node.cpp	2008-09-12 17:50:41 UTC (rev 466)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Node.cpp	2008-09-12 18:04:18 UTC (rev 467)
@@ -3,6 +3,8 @@
  */
 
 #include "Node.h"
+
+#include "ConstNodeVisitor.h"
 #include "NodeVisitor.h"
 
 namespace OpenFDM {
@@ -25,6 +27,12 @@
   visitor.apply(*this);
 }
 
+void
+Node::accept(ConstNodeVisitor& visitor) const
+{
+  visitor.apply(*this);
+}
+
 SharedPtr<const PortInfo>
 Node::getPort(const PortId& portId) const
 {

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Node.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Node.h	2008-09-12 17:50:41 UTC (rev 466)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Node.h	2008-09-12 18:04:18 UTC (rev 467)
@@ -15,6 +15,7 @@
 namespace OpenFDM {
 
 class NodeVisitor;
+class ConstNodeVisitor;
 
 class Node : public Object {
   OPENFDM_OBJECT(Node, Object);
@@ -23,6 +24,7 @@
   virtual ~Node();
 
   virtual void accept(NodeVisitor& visitor);
+  virtual void accept(ConstNodeVisitor& visitor) const;
 
   SharedPtr<const PortInfo> getPort(const PortId& portId) const;
   SharedPtr<const PortInfo> getPort(unsigned index) const;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RigidBody.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RigidBody.cpp	2008-09-12 17:50:41 UTC (rev 466)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RigidBody.cpp	2008-09-12 18:04:18 UTC (rev 467)
@@ -3,6 +3,8 @@
  */
 
 #include "RigidBody.h"
+
+#include "ConstNodeVisitor.h"
 #include "NodeVisitor.h"
 
 namespace OpenFDM {
@@ -25,5 +27,10 @@
   visitor.apply(*this);
 }
 
+void
+RigidBody::accept(ConstNodeVisitor& visitor) const
+{
+  visitor.apply(*this);
+}
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RigidBody.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RigidBody.h	2008-09-12 17:50:41 UTC (rev 466)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RigidBody.h	2008-09-12 18:04:18 UTC (rev 467)
@@ -18,6 +18,7 @@
   virtual ~RigidBody();
 
   virtual void accept(NodeVisitor& visitor);
+  virtual void accept(ConstNodeVisitor& visitor) const;
 
 protected:
   MechanicInteractPort newMechanicInteractPort(const std::string& name)



From frohlich at mail.berlios.de  Fri Sep 12 20:42:21 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Fri, 12 Sep 2008 20:42:21 +0200
Subject: [OpenFDM-svn] r468 - in branches/OpenFDM-StateSeparation/src:
	OpenFDM test
Message-ID: <200809121842.m8CIgL4x003387@sheep.berlios.de>

Author: frohlich
Date: 2008-09-12 20:42:20 +0200 (Fri, 12 Sep 2008)
New Revision: 468

Added:
   branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.h
Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/ConstNodeVisitor.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/ConstNodeVisitor.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
   branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.h
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Introduce an abstract root joint.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/ConstNodeVisitor.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ConstNodeVisitor.cpp	2008-09-12 18:04:18 UTC (rev 467)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ConstNodeVisitor.cpp	2008-09-12 18:42:20 UTC (rev 468)
@@ -11,6 +11,8 @@
 #include "MechanicNode.h"
 #include "Model.h"
 #include "RigidBody.h"
+#include "RootJoint.h"
+#include "Interact.h"
 
 namespace OpenFDM {
 
@@ -77,4 +79,10 @@
   apply(static_cast<const MechanicNode&>(node));
 }
 
+void
+ConstNodeVisitor::apply(const RootJoint& node)
+{
+  apply(static_cast<const Interact&>(node));
+}
+
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/ConstNodeVisitor.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ConstNodeVisitor.h	2008-09-12 18:04:18 UTC (rev 467)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ConstNodeVisitor.h	2008-09-12 18:42:20 UTC (rev 468)
@@ -16,6 +16,7 @@
 class Model;
 class MechanicNode;
 class RigidBody;
+class RootJoint;
 class Interact;
 
 class ConstNodeVisitor {
@@ -34,8 +35,11 @@
   virtual void apply(const Model&);
 
   virtual void apply(const MechanicNode&);
+
   virtual void apply(const RigidBody&);
+
   virtual void apply(const Interact&);
+  virtual void apply(const RootJoint&);
 };
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-09-12 18:04:18 UTC (rev 467)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-09-12 18:42:20 UTC (rev 468)
@@ -86,6 +86,7 @@
   RealStateInfo.h \
   Referenced.h \
   RigidBody.h \
+  RootJoint.h \
   Rotation.h \
   SampleTime.h \
   ScopeLock.h \
@@ -138,6 +139,7 @@
   PortInfo.cpp \
   PortValue.cpp \
   RigidBody.cpp \
+  RootJoint.cpp \
   SampleTime.cpp \
   StateValue.cpp \
   Time.cpp \

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.cpp	2008-09-12 18:04:18 UTC (rev 467)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.cpp	2008-09-12 18:42:20 UTC (rev 468)
@@ -11,6 +11,8 @@
 #include "MechanicNode.h"
 #include "Model.h"
 #include "RigidBody.h"
+#include "RootJoint.h"
+#include "Interact.h"
 
 namespace OpenFDM {
 
@@ -77,4 +79,10 @@
   apply(static_cast<MechanicNode&>(node));
 }
 
+void
+NodeVisitor::apply(RootJoint& node)
+{
+  apply(static_cast<Interact&>(node));
+}
+
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.h	2008-09-12 18:04:18 UTC (rev 467)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.h	2008-09-12 18:42:20 UTC (rev 468)
@@ -16,6 +16,7 @@
 class Model;
 class MechanicNode;
 class RigidBody;
+class RootJoint;
 class Interact;
 
 class NodeVisitor {
@@ -34,8 +35,11 @@
   virtual void apply(Model&);
 
   virtual void apply(MechanicNode&);
+
   virtual void apply(RigidBody&);
+
   virtual void apply(Interact&);
+  virtual void apply(RootJoint&);
 };
 
 } // namespace OpenFDM

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.cpp	2008-09-12 18:04:18 UTC (rev 467)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.cpp	2008-09-12 18:42:20 UTC (rev 468)
@@ -0,0 +1,36 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
+ *
+ */
+
+#include "RootJoint.h"
+
+#include "ConstNodeVisitor.h"
+#include "NodeVisitor.h"
+
+namespace OpenFDM {
+
+BEGIN_OPENFDM_OBJECT_DEF(RootJoint, Interact)
+  END_OPENFDM_OBJECT_DEF
+
+RootJoint::RootJoint(const std::string& name) :
+  Interact(name)
+{
+}
+
+RootJoint::~RootJoint()
+{
+}
+
+void
+RootJoint::accept(NodeVisitor& visitor)
+{
+  visitor.apply(*this);
+}
+
+void
+RootJoint::accept(ConstNodeVisitor& visitor) const
+{
+  visitor.apply(*this);
+}
+
+} // namespace OpenFDM

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.h	2008-09-12 18:04:18 UTC (rev 467)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.h	2008-09-12 18:42:20 UTC (rev 468)
@@ -0,0 +1,25 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_RootJoint_H
+#define OpenFDM_RootJoint_H
+
+#include <string>
+#include "Interact.h"
+
+namespace OpenFDM {
+
+class RootJoint : public Interact {
+  OPENFDM_OBJECT(RootJoint, Interact);
+public:
+  RootJoint(const std::string& name);
+  virtual ~RootJoint();
+
+  virtual void accept(NodeVisitor& visitor);
+  virtual void accept(ConstNodeVisitor& visitor) const;
+};
+
+} // namespace OpenFDM
+
+#endif

Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-12 18:04:18 UTC (rev 467)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-12 18:42:20 UTC (rev 468)
@@ -15,6 +15,7 @@
 #include <OpenFDM/RealOutputPort.h>
 #include <OpenFDM/MechanicBodyPort.h>
 #include <OpenFDM/MechanicInteractPort.h>
+#include <OpenFDM/RootJoint.h>
 
 #include <OpenFDM/StateInfo.h>
 #include <OpenFDM/StateValue.h>
@@ -440,6 +441,13 @@
   virtual void apply(LibraryNode& libraryNode)
   { std::cerr << __PRETTY_FUNCTION__ << std::endl; }
 
+  virtual void apply(RootJoint& node)
+  {
+    // Need to stor the root nodes to build up the spanning tree for the
+    // mechanical system here.
+    apply(static_cast<Interact&>(node));
+  }
+
   // Aussen acceptor, innen provider
   virtual void apply(GroupAcceptorNode& leaf)
   {



From frohlich at mail.berlios.de  Fri Sep 12 20:47:32 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Fri, 12 Sep 2008 20:47:32 +0200
Subject: [OpenFDM-svn] r469 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200809121847.m8CIlWVi003798@sheep.berlios.de>

Author: frohlich
Date: 2008-09-12 20:47:32 +0200 (Fri, 12 Sep 2008)
New Revision: 469

Modified:
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Make use of ConstNodeVisitor.


Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-12 18:42:20 UTC (rev 468)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-12 18:47:32 UTC (rev 469)
@@ -431,25 +431,25 @@
 };
 
 
-class LeafInstanceCollector : public NodeVisitor {
+class LeafInstanceCollector : public ConstNodeVisitor {
 public:
 
-  virtual void apply(Node& node)
+  virtual void apply(const Node& node)
   { std::cerr << __PRETTY_FUNCTION__ << std::endl; }
-  virtual void apply(LeafNode& leaf)
+  virtual void apply(const LeafNode& leaf)
   { std::cerr << __PRETTY_FUNCTION__ << std::endl; }
-  virtual void apply(LibraryNode& libraryNode)
+  virtual void apply(const LibraryNode& libraryNode)
   { std::cerr << __PRETTY_FUNCTION__ << std::endl; }
 
-  virtual void apply(RootJoint& node)
+  virtual void apply(const RootJoint& node)
   {
     // Need to stor the root nodes to build up the spanning tree for the
     // mechanical system here.
-    apply(static_cast<Interact&>(node));
+    apply(static_cast<const Interact&>(node));
   }
 
   // Aussen acceptor, innen provider
-  virtual void apply(GroupAcceptorNode& leaf)
+  virtual void apply(const GroupAcceptorNode& leaf)
   {
     OpenFDMAssert(leaf.getPort(0));
     PortId portId = leaf.getPortId(0);
@@ -458,7 +458,7 @@
     _leafPortDataMap[getCurrentNodeId()][portId] = pd;
   }
   // Aussen provider, innen acceptor
-  virtual void apply(GroupProviderNode& leaf)
+  virtual void apply(const GroupProviderNode& leaf)
   {
     OpenFDMAssert(leaf.getPort(0));
     PortId portId = leaf.getPortId(0);
@@ -467,7 +467,7 @@
     _leafPortDataMap[getCurrentNodeId()][portId] = ad;
   }
 
-  void allocPortData(LeafInstance* leafInstance, LeafNode& leaf)
+  void allocPortData(LeafInstance* leafInstance, const LeafNode& leaf)
   {
     // FIXME: move to LeafInstance??
     for (unsigned i = 0; i < leaf.getNumPorts(); ++i) {
@@ -477,14 +477,14 @@
     }
   }
 
-  virtual void apply(MechanicNode& node)
+  virtual void apply(const MechanicNode& node)
   {
     MechanicInstance* mechanicInstance = new MechanicInstance(&node);
     _leafInstanceList.push_back(mechanicInstance);
     _mechanicInstanceList.push_back(mechanicInstance);
     allocPortData(mechanicInstance, node);
   }
-  virtual void apply(Model& node)
+  virtual void apply(const Model& node)
   {
     ModelInstance* modelInstance = new ModelInstance(&node);
     _leafInstanceList.push_back(modelInstance);
@@ -492,7 +492,7 @@
     allocPortData(modelInstance, node);
   }
 
-  virtual void apply(Group& group)
+  virtual void apply(const Group& group)
   {
     // Prepare a new leaf map for the child group
     LeafPortDataMap parentLeafPortDataMap;
@@ -713,7 +713,6 @@
   return 0;
 }
 
-
 // Kabelbaum <-> PortBundle ??? Original Kabelbaum == Cabel Bundle
 // Oder Cable Set <-> Port Set???
 



From frohlich at mail.berlios.de  Sat Sep 13 08:22:34 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 13 Sep 2008 08:22:34 +0200
Subject: [OpenFDM-svn] r470 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200809130622.m8D6MY6u027003@sheep.berlios.de>

Author: frohlich
Date: 2008-09-13 08:22:34 +0200 (Sat, 13 Sep 2008)
New Revision: 470

Modified:
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Store the RootJoints seperately


Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-12 18:47:32 UTC (rev 469)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-13 06:22:34 UTC (rev 470)
@@ -441,13 +441,6 @@
   virtual void apply(const LibraryNode& libraryNode)
   { std::cerr << __PRETTY_FUNCTION__ << std::endl; }
 
-  virtual void apply(const RootJoint& node)
-  {
-    // Need to stor the root nodes to build up the spanning tree for the
-    // mechanical system here.
-    apply(static_cast<const Interact&>(node));
-  }
-
   // Aussen acceptor, innen provider
   virtual void apply(const GroupAcceptorNode& leaf)
   {
@@ -477,6 +470,16 @@
     }
   }
 
+  virtual void apply(const RootJoint& node)
+  {
+    // Need to stor the root nodes to build up the spanning tree for the
+    // mechanical system here.
+    MechanicInstance* mechanicInstance = new MechanicInstance(&node);
+    _leafInstanceList.push_back(mechanicInstance);
+//     _mechanicInstanceList.push_back(mechanicInstance);
+    _rootJointInstanceList.push_back(mechanicInstance);
+    allocPortData(mechanicInstance, node);
+  }
   virtual void apply(const MechanicNode& node)
   {
     MechanicInstance* mechanicInstance = new MechanicInstance(&node);
@@ -579,6 +582,9 @@
   ModelInstanceList _modelInstanceList;
   typedef std::list<SharedPtr<MechanicInstance> > MechanicInstanceList;
   MechanicInstanceList _mechanicInstanceList;
+//   typedef std::list<SharedPtr<RootJointInstance> > RootJointInstanceList;
+  typedef std::list<SharedPtr<MechanicInstance> > RootJointInstanceList;
+  RootJointInstanceList _rootJointInstanceList;
 
   ////////////////////////////////////////////////////////////////////////////
   // Used to map connections in groups ...



From frohlich at mail.berlios.de  Sat Sep 13 11:13:04 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 13 Sep 2008 11:13:04 +0200
Subject: [OpenFDM-svn] r471 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200809130913.m8D9D4to006691@sheep.berlios.de>

Author: frohlich
Date: 2008-09-13 11:13:04 +0200 (Sat, 13 Sep 2008)
New Revision: 471

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/ConstNodeVisitor.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/ConstNodeVisitor.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
   branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Output.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Output.h
Log:
Readd the output model.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/ConstNodeVisitor.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ConstNodeVisitor.cpp	2008-09-13 06:22:34 UTC (rev 470)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ConstNodeVisitor.cpp	2008-09-13 09:13:04 UTC (rev 471)
@@ -10,6 +10,7 @@
 #include "LeafNode.h"
 #include "MechanicNode.h"
 #include "Model.h"
+#include "Output.h"
 #include "RigidBody.h"
 #include "RootJoint.h"
 #include "Interact.h"
@@ -62,6 +63,12 @@
 }
 
 void
+ConstNodeVisitor::apply(const Output& node)
+{
+  apply(static_cast<const Model&>(node));
+}
+
+void
 ConstNodeVisitor::apply(const MechanicNode& node)
 {
   apply(static_cast<const LeafNode&>(node));

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/ConstNodeVisitor.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ConstNodeVisitor.h	2008-09-13 06:22:34 UTC (rev 470)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ConstNodeVisitor.h	2008-09-13 09:13:04 UTC (rev 471)
@@ -14,6 +14,7 @@
 class LibraryNode;
 class LeafNode;
 class Model;
+class Output;
 class MechanicNode;
 class RigidBody;
 class RootJoint;
@@ -33,6 +34,7 @@
 
   virtual void apply(const LeafNode&);
   virtual void apply(const Model&);
+  virtual void apply(const Output&);
 
   virtual void apply(const MechanicNode&);
 

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-09-13 06:22:34 UTC (rev 470)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-09-13 09:13:04 UTC (rev 471)
@@ -224,7 +224,8 @@
 OpenFDMModelsSOURCES = \
   Delay.cpp \
   Gain.cpp \
-  Integrator.cpp
+  Integrator.cpp \
+  Output.cpp
 
 #   AeroForce.cpp \
 #   AirSpring.cpp \

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.cpp	2008-09-13 06:22:34 UTC (rev 470)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.cpp	2008-09-13 09:13:04 UTC (rev 471)
@@ -10,6 +10,7 @@
 #include "LeafNode.h"
 #include "MechanicNode.h"
 #include "Model.h"
+#include "Output.h"
 #include "RigidBody.h"
 #include "RootJoint.h"
 #include "Interact.h"
@@ -62,6 +63,12 @@
 }
 
 void
+NodeVisitor::apply(Output& node)
+{
+  apply(static_cast<Model&>(node));
+}
+
+void
 NodeVisitor::apply(MechanicNode& node)
 {
   apply(static_cast<LeafNode&>(node));

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.h	2008-09-13 06:22:34 UTC (rev 470)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.h	2008-09-13 09:13:04 UTC (rev 471)
@@ -14,6 +14,7 @@
 class LibraryNode;
 class LeafNode;
 class Model;
+class Output;
 class MechanicNode;
 class RigidBody;
 class RootJoint;
@@ -33,6 +34,7 @@
 
   virtual void apply(LeafNode&);
   virtual void apply(Model&);
+  virtual void apply(Output&);
 
   virtual void apply(MechanicNode&);
 

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Output.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Output.cpp	2008-09-13 06:22:34 UTC (rev 470)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Output.cpp	2008-09-13 09:13:04 UTC (rev 471)
@@ -3,7 +3,9 @@
  */
 
 #include "Output.h"
-#include "ModelVisitor.h"
+#include "ConstNodeVisitor.h"
+#include "LeafContext.h"
+#include "NodeVisitor.h"
 
 namespace OpenFDM {
 
@@ -18,11 +20,9 @@
 
 Output::Output(const std::string& name) :
   Model(name),
+  mInputPort(newRealInputPort("input")),
   mOutputGain(1)
 {
-  setDirectFeedThrough(true);
-  setNumInputPorts(1);
-  setInputPortName(0, "input");
 }
 
 Output::~Output(void)
@@ -30,48 +30,25 @@
 }
 
 void
-Output::accept(ModelVisitor& visitor)
+Output::accept(NodeVisitor& visitor)
 {
   visitor.apply(*this);
 }
 
-bool
-Output::init(void)
+void
+Output::accept(ConstNodeVisitor& visitor) const
 {
-  mInputPort = getInputPort(0)->toRealPortHandle();
-  if (!mInputPort.isConnected()) {
-    Log(Model, Error) << "Initialization of Output model \"" << getName()
-                      << "\" failed: Input port \"" << getInputPortName(0)
-                      << "\" is not connected!" << endl;
-    return false;
-  }
-//   if (!mCallback) {
-//     Log(Model, Error) << "Initialization of Output model \"" << getName()
-//                       << "\" failed: Output Callback not set!" << endl;
-//     return false;
-//   }
-
-  return Model::init();
+  visitor.apply(*this);
 }
 
-const Output*
-Output::toOutput(void) const
-{
-  return this;
-}
-
-Output*
-Output::toOutput(void)
-{
-  return this;
-}
-
 void
-Output::output(const TaskInfo&)
+Output::output(const DiscreteStateValueVector&,
+               const ContinousStateValueVector&,
+               PortValueList& portValues) const
 {
   if (!mCallback)
     return;
-  mCallback->setValue(mOutputGain*mInputPort.getRealValue());
+  mCallback->setValue(mOutputGain*portValues[mInputPort]);
 }
 
 Output::Callback*

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Output.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Output.h	2008-09-13 06:22:34 UTC (rev 470)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Output.h	2008-09-13 09:13:04 UTC (rev 471)
@@ -16,16 +16,17 @@
   virtual ~Output(void);
   
   /// Double dispatch helper for the system visitor
-  virtual void accept(ModelVisitor& visitor);
-  /// Double dispatch helper for the system visitor
-//   virtual void accept(ConstModelVisitor& visitor) const;
+  virtual void accept(NodeVisitor& visitor);
+  virtual void accept(ConstNodeVisitor& visitor) const;
 
-  virtual const Output* toOutput(void) const;
-  virtual Output* toOutput(void);
+  virtual void output(const DiscreteStateValueVector&,
+                      const ContinousStateValueVector&,
+                      PortValueList& portValues) const;
+  // FIXME: dependsOn semantic is broken. May be some kind of
+  // needPortInOutput in the port info???
+  virtual bool dependsOn(const PortId&, const PortId&) const
+  { return true; }
 
-  virtual bool init(void);
-  virtual void output(const TaskInfo&);
-
   class Callback : public WeakReferenced {
   public:
     virtual ~Callback();
@@ -42,7 +43,7 @@
   void setOutputName(const std::string& outputName);
 
 private:
-  RealPortHandle mInputPort;
+  RealInputPort mInputPort;
   SharedPtr<Callback> mCallback;
   real_type mOutputGain;
   std::string mOutputName;



From frohlich at mail.berlios.de  Sat Sep 13 11:25:04 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 13 Sep 2008 11:25:04 +0200
Subject: [OpenFDM-svn] r472 - in branches/OpenFDM-StateSeparation/src:
	OpenFDM test
Message-ID: <200809130925.m8D9P49x007499@sheep.berlios.de>

Author: frohlich
Date: 2008-09-13 11:25:03 +0200 (Sat, 13 Sep 2008)
New Revision: 472

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Output.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Output.h
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Use the Output model to do that prints.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Output.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Output.cpp	2008-09-13 09:13:04 UTC (rev 471)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Output.cpp	2008-09-13 09:25:03 UTC (rev 472)
@@ -18,9 +18,10 @@
 {
 }
 
-Output::Output(const std::string& name) :
+Output::Output(const std::string& name, Output::Callback* callback) :
   Model(name),
   mInputPort(newRealInputPort("input")),
+  mCallback(callback),
   mOutputGain(1)
 {
 }

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Output.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Output.h	2008-09-13 09:13:04 UTC (rev 471)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Output.h	2008-09-13 09:25:03 UTC (rev 472)
@@ -12,7 +12,13 @@
 class Output : public Model {
   OPENFDM_OBJECT(Output, Model);
 public:
-  Output(const std::string& name);
+  class Callback : public WeakReferenced {
+  public:
+    virtual ~Callback();
+    virtual void setValue(real_type value) = 0;
+  };
+
+  Output(const std::string& name, Callback* callback = 0);
   virtual ~Output(void);
   
   /// Double dispatch helper for the system visitor
@@ -27,12 +33,6 @@
   virtual bool dependsOn(const PortId&, const PortId&) const
   { return true; }
 
-  class Callback : public WeakReferenced {
-  public:
-    virtual ~Callback();
-    virtual void setValue(real_type value) = 0;
-  };
-
   Callback* getCallback(void) const;
   void setCallback(Callback* callback);
 

Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-13 09:13:04 UTC (rev 471)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-13 09:25:03 UTC (rev 472)
@@ -40,6 +40,7 @@
 #include <OpenFDM/Gain.h>
 #include <OpenFDM/Integrator.h>
 #include <OpenFDM/Delay.h>
+#include <OpenFDM/Output.h>
 
 #include <OpenFDM/Group.h>
 
@@ -76,22 +77,6 @@
 /// FIXME: IMO THIS MUST WORK THIS WAY
 ///
 
-class Print : public Model {
-public:
-  Print(const std::string& name) :
-    Model(name),
-    mInputPort(newRealInputPort("input"))
-  { }
-  virtual void output(const DiscreteStateValueVector&,
-                      const ContinousStateValueVector&,
-                      PortValueList& portValues) const
-  { std::cout << portValues[mInputPort] << std::endl; }
-  virtual bool dependsOn(const PortId&, const PortId&) const
-  { return false; }
-private:
-  RealInputPort mInputPort;
-};
-
 class LeafInstance : public WeakReferenced {
 public:
   struct LeafPortData;
@@ -668,22 +653,28 @@
 
 using namespace OpenFDM;
 
+class PrintOutput : public Output::Callback {
+public:
+  virtual void setValue(real_type value)
+  { std::cout << value << std::endl; }
+};
+
 int main()
 {
   SharedPtr<Group> group = new Group("G0");
   Group::NodeId gain = group->addChild(new Gain("gain"));
   Group::NodeId integrator1 = group->addChild(new Integrator("I1"));
   Group::NodeId integrator2 = group->addChild(new Integrator("I2"));
-  Group::NodeId print = group->addChild(new Print("P"));
+  Group::NodeId output = group->addChild(new Output("O", new PrintOutput));
   Group::NodeId delay = group->addChild(new Delay("D"));
-  Group::NodeId printDelay = group->addChild(new Print("PD"));
+  Group::NodeId outputDelay = group->addChild(new Output("OD", new PrintOutput));
 
   group->connect(integrator1, "output", integrator2, "input");
   group->connect(integrator2, "output", gain, "input");
   group->connect(gain, "output", integrator1, "input");
-  group->connect(integrator2, "output", print, "input");
+  group->connect(integrator2, "output", output, "input");
   group->connect(gain, "output", delay, "input");
-  group->connect(delay, "output", printDelay, "input");
+  group->connect(delay, "output", outputDelay, "input");
 
   //FIXME: broken naming
 //   Group::NodeId groupOutputNode = group->addAcceptorPort();
@@ -694,10 +685,10 @@
   Group::NodeId child0 = topGroup->addChild(group);
   Group::NodeId child1 = topGroup->addChild(group);
 
-  Group::NodeId print0 = topGroup->addChild(new Print("P2"));
-  topGroup->connect(child0, 0, print0, 0);
-  Group::NodeId print1 = topGroup->addChild(new Print("P3"));
-  topGroup->connect(child1, 0, print1, 0);
+  Group::NodeId output0 = topGroup->addChild(new Output("O2", new PrintOutput));
+  topGroup->connect(child0, 0, output0, 0);
+  Group::NodeId output1 = topGroup->addChild(new Output("O3", new PrintOutput));
+  topGroup->connect(child1, 0, output1, 0);
 
   /////////////////////////////////////////////////
 



From frohlich at mail.berlios.de  Sat Sep 13 11:50:46 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 13 Sep 2008 11:50:46 +0200
Subject: [OpenFDM-svn] r473 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200809130950.m8D9okb4010139@sheep.berlios.de>

Author: frohlich
Date: 2008-09-13 11:50:46 +0200 (Sat, 13 Sep 2008)
New Revision: 473

Modified:
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Move the LeafContext data into a struct where it
does not need to be copied later.


Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-13 09:25:03 UTC (rev 472)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-13 09:50:46 UTC (rev 473)
@@ -77,6 +77,62 @@
 /// FIXME: IMO THIS MUST WORK THIS WAY
 ///
 
+
+
+///
+/// ----------------
+/// | LeafInstance |
+/// ----------------
+///             | |     ------------
+///             | ----->| PortData |
+///             |       ------------
+///             |       --------------------------------
+///             ------->| ModelContext/MechanicContext |
+///                     --------------------------------
+///
+/// The LeafInstanceCollector walks the graph of models and collects
+/// the leaf nodes in the system. For each leaf node there is a
+/// LeafInstance class. Each LeafInstance has a list of PortData pointers
+/// that is used to connect the Ports of leafs. Also there is a LeafContext
+/// in each instance that is later needed to run the model.
+///
+
+class ModelContext : public Referenced {
+public:
+  ModelContext(const Model* model) :
+    mModel(model)
+  { }
+
+  bool alloc()
+  { return mModel->alloc(mLeafContext); }
+
+  SharedPtr<const Model> mModel;
+  LeafContext mLeafContext;
+
+private:
+  ModelContext();
+  ModelContext(const ModelContext&);
+  ModelContext& operator=(const ModelContext&);
+};
+
+class MechanicContext : public Referenced {
+public:
+  MechanicContext(const MechanicNode* mechanicNode) :
+    mMechanicNode(mechanicNode)
+  { }
+
+  bool alloc()
+  { return mMechanicNode->alloc(mLeafContext); }
+
+  SharedPtr<const MechanicNode> mMechanicNode;
+  LeafContext mLeafContext;
+
+private:
+  MechanicContext();
+  MechanicContext(const MechanicContext&);
+  MechanicContext& operator=(const MechanicContext&);
+};
+
 class LeafInstance : public WeakReferenced {
 public:
   struct LeafPortData;
@@ -302,6 +358,7 @@
   }
 
   virtual const LeafNode* getLeafNode() const = 0;
+  virtual void setPortValue(unsigned, PortValue*) const = 0;
 
   // Return true if this leaf directly depends on one of leafInstance outputs
   bool dependsOn(LeafInstance* leafInstance)
@@ -341,7 +398,7 @@
         continue;
 
       PortValue* portValue = providerPortInfo->newValue();
-      mLeafContext.mPortValueList.setPortValue(i, portValue);
+      setPortValue(i, portValue);
       
       // Also set the port value to all connected ports
       ProviderPortData* providerPortData = mPortData[i]->toProviderPortData();
@@ -359,17 +416,11 @@
         
         OpenFDMAssert(acceptorPortData->getPortInfo());
         unsigned index = acceptorPortData->getPortInfo()->getIndex();
-        leafInstance->mLeafContext.mPortValueList.setPortValue(index, portValue);
+        leafInstance->setPortValue(index, portValue);
       }
     }
   }
-  bool alloc()
-  {
-    return getLeafNode()->alloc(mLeafContext);
-  }
 
-  LeafContext mLeafContext;
-
 private:
   void allocPorts(const Node* node)
   {
@@ -393,26 +444,38 @@
 public:
   ModelInstance(const Model* model) :
     LeafInstance(model),
-    mModel(model)
+    mModelContext(new ModelContext(model))
   { }
 
   virtual const Model* getLeafNode() const
-  { return mModel; }
+  { return mModelContext->mModel; }
 
-  SharedPtr<const Model> mModel;
+  virtual void setPortValue(unsigned i, PortValue* portValue) const
+  { mModelContext->mLeafContext.mPortValueList.setPortValue(i, portValue); }
+
+  bool alloc()
+  { return mModelContext->alloc(); }
+
+  SharedPtr<ModelContext> mModelContext;
 };
 
 class MechanicInstance : public LeafInstance {
 public:
   MechanicInstance(const MechanicNode* mechanicNode) :
     LeafInstance(mechanicNode),
-    mMechanicNode(mechanicNode)
+    mMechanicContext(new MechanicContext(mechanicNode))
   { }
 
   virtual const MechanicNode* getLeafNode() const
-  { return mMechanicNode; }
+  { return mMechanicContext->mMechanicNode; }
 
-  SharedPtr<const MechanicNode> mMechanicNode;
+  virtual void setPortValue(unsigned i, PortValue* portValue) const
+  { mMechanicContext->mLeafContext.mPortValueList.setPortValue(i, portValue); }
+
+  bool alloc()
+  { return mMechanicContext->alloc(); }
+
+  SharedPtr<MechanicContext> mMechanicContext;
 };
 
 



From frohlich at mail.berlios.de  Sat Sep 13 13:32:48 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 13 Sep 2008 13:32:48 +0200
Subject: [OpenFDM-svn] r474 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200809131132.m8DBWmr8009437@sheep.berlios.de>

Author: frohlich
Date: 2008-09-13 13:32:48 +0200 (Sat, 13 Sep 2008)
New Revision: 474

Modified:
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
First outputs :)


Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-13 09:50:46 UTC (rev 473)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-13 11:32:48 UTC (rev 474)
@@ -105,7 +105,21 @@
 
   bool alloc()
   { return mModel->alloc(mLeafContext); }
+  void init()
+  { mModel->init(mLeafContext.mDiscreteState, mLeafContext.mContinousState); }
+  void output()
+  { mModel->output(mLeafContext.mDiscreteState, mLeafContext.mContinousState,
+                   mLeafContext.mPortValueList); }
+  void update()
+  { mModel->update(mLeafContext.mDiscreteState, mLeafContext.mContinousState,
+                   mLeafContext.mPortValueList); }
 
+//   void derivative()
+//   { mModel->derivative(mLeafContext.mDiscreteState,
+//                        mLeafContext.mContinousState,
+//                        mLeafContext.mPortValueList,
+//                        mLeafContext.mContinousStateDerivative); }
+
   SharedPtr<const Model> mModel;
   LeafContext mLeafContext;
 
@@ -455,6 +469,12 @@
 
   bool alloc()
   { return mModelContext->alloc(); }
+  void init()
+  { mModelContext->init(); }
+  void output()
+  { mModelContext->output(); }
+  void update()
+  { mModelContext->update(); }
 
   SharedPtr<ModelContext> mModelContext;
 };
@@ -692,6 +712,12 @@
       }
     }
 
+    // FIXME is here just for curiousity :)
+    for (j = modelContextList.begin(); j != modelContextList.end(); ++j) {
+      (*j)->init();
+      (*j)->output();
+    }
+
     modelContexts.swap(modelContextList);
     return true;
   }



From frohlich at mail.berlios.de  Sat Sep 13 17:25:18 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 13 Sep 2008 17:25:18 +0200
Subject: [OpenFDM-svn] r475 - in branches/OpenFDM-StateSeparation/src:
	OpenFDM test
Message-ID: <200809131525.m8DFPIWt006713@sheep.berlios.de>

Author: frohlich
Date: 2008-09-13 17:25:18 +0200 (Sat, 13 Sep 2008)
New Revision: 475

Added:
   branches/OpenFDM-StateSeparation/src/OpenFDM/NodeContext.h
Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/LeafContext.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
More thughts on model execution and the interfaces therefore.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/LeafContext.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/LeafContext.h	2008-09-13 11:32:48 UTC (rev 474)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/LeafContext.h	2008-09-13 15:25:18 UTC (rev 475)
@@ -7,16 +7,12 @@
 
 #include "ContinousStateValueVector.h"
 #include "DiscreteStateValueVector.h"
-#include "PortValueList.h"
+#include "NodeContext.h"
 
 namespace OpenFDM {
 
-class LeafContext {
+class LeafContext : public NodeContext {
 public:
-  // PortValues
-  PortValueList mPortValueList;
-  // Hmm, port connect information?? How to store??
-  
   // Continous States
   ContinousStateValueVector mContinousState;
   // Discrete States
@@ -24,11 +20,8 @@
 
   // Task id's ???
 
-  // Output Watch, used to monitor outputs during simulation
-
-  // May be complete path in the system?
-
   // functors to the operations to do??
+
 };
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-09-13 11:32:48 UTC (rev 474)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-09-13 15:25:18 UTC (rev 475)
@@ -64,6 +64,7 @@
   MPFRFloat.h \
   Newton.h \
   Node.h \
+  NodeContext.h \
   NodeVisitor.h \
   NumericPortValue.h \
   NumericAcceptorPortInfo.h \

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/NodeContext.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/NodeContext.h	2008-09-13 11:32:48 UTC (rev 474)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/NodeContext.h	2008-09-13 15:25:18 UTC (rev 475)
@@ -0,0 +1,32 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_NodeContext_H
+#define OpenFDM_NodeContext_H
+
+#include "Node.h"
+#include "PortValueList.h"
+
+namespace OpenFDM {
+
+/// Hmm, NodeContext is not base of LeafContext for now. FIXME!!!
+/// This class might not be user visible. Is implemented somewhere
+/// in the simulation backend.
+class NodeContext : public Referenced {
+public:
+  virtual ~NodeContext() { }
+  virtual const Node& getNode() const = 0;
+
+  PortValueList& getPortValueList()
+  { return mPortValueList; }
+  const PortValueList& getPortValueList() const
+  { return mPortValueList; }
+
+  // PortValues
+  PortValueList mPortValueList;
+};
+
+} // namespace OpenFDM
+
+#endif

Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-13 11:32:48 UTC (rev 474)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-13 15:25:18 UTC (rev 475)
@@ -28,6 +28,8 @@
 #include <OpenFDM/ContinousStateValueVector.h>
 #include <OpenFDM/DiscreteStateValueVector.h>
 
+#include <OpenFDM/SampleTime.h>
+
 #include <OpenFDM/BoolStateInfo.h>
 #include <OpenFDM/RealStateInfo.h>
 #include <OpenFDM/MatrixStateInfo.h>
@@ -81,47 +83,119 @@
 
 ///
 /// ----------------
-/// | LeafInstance |
+/// | NodeInstance |
 /// ----------------
-///             | |     ------------
-///             | ----->| PortData |
-///             |       ------------
-///             |       --------------------------------
-///             ------->| ModelContext/MechanicContext |
-///                     --------------------------------
+///             | |     --------
+///             | ----->| Node |
+///             |       --------
+///             |       ---------------
+///             ------->| NodeContext |
+///                     ---------------
 ///
-/// The LeafInstanceCollector walks the graph of models and collects
-/// the leaf nodes in the system. For each leaf node there is a
-/// LeafInstance class. Each LeafInstance has a list of PortData pointers
-/// that is used to connect the Ports of leafs. Also there is a LeafContext
-/// in each instance that is later needed to run the model.
+/// The NodeInstance is used to present the user a handle to the simulation
+/// models runtime data. Each instance has an execution context and a pointer
+/// to the actual node.
 ///
+/// For model execution we have a list of ModelContexs and a list of
+/// MechanicContexts. Both of them are derived from the NodeContext from above.
+///
+/// To connect the ports and propagate the port values over the NodeContexts
+/// there must be a PortData like structure that is only built during simulation
+/// model initialization.
 
-class ModelContext : public Referenced {
+/// A NodeInstance represents an effictive model node in a ready to run
+/// System. You can access the Nodes Ports values for example.
+/// This class is meant to show up in the user interface of this simulation.
+class NodeInstance : public WeakReferenced {
 public:
+  virtual ~NodeInstance() {}
+
+  /// The actual Node this NodeInstance stems from
+  const Node& getNode() const
+  { return getNodeContext().getNode(); }
+
+  /// FIXME: put this to some global place
+//   typedef std::vector<SharedPtr<const Node> > NodePath;
+//   const NodePath& getNodePath() const { return mNodePath; }
+//   NodePath mNodePath;
+
+//   /// Set the sample times this node will run on
+//   void setSampleTimeSet(const SampleTimeSet& sampleTimeSet)
+//   { mSampleTimeSet = sampleTimeSet; }
+//   /// Get the sample times this node will run on
+//   const SampleTimeSet& getSampleTimeSet() const
+//   { return mSampleTimeSet; }
+
+protected:
+  NodeInstance() {}
+
+  /// The node context that belongs to this instance.
+  virtual NodeContext& getNodeContext() = 0;
+  virtual const NodeContext& getNodeContext() const = 0;
+
+private:
+  NodeInstance(const NodeInstance&);
+  NodeInstance& operator=(const NodeInstance&);
+
+//   /// The sample times this node will run on
+//   SampleTimeSet mSampleTimeSet;
+};
+
+// typedef std::vector<SharedPtr<NodeInstance> > NodeInstanceList;
+// typedef std::vector<SharedPtr<const NodeInstance> > ConstNodeInstanceList;
+
+
+
+
+////////////////////////////////////////////////////////////////////////////
+
+/// This one will not show up in any execution list, but will be used
+/// to fill NodeContext's for Node's that have nothing to execute,
+/// should be reflected to the user of the simulation system. Group's
+/// inputs ad outputs and their input and output models are such examples.
+class GenericNodeContext : public NodeContext {
+public:
+  GenericNodeContext(const Node* node) :
+    mNode(node)
+  { }
+
+  virtual const Node& getNode() const
+  { return *mNode; }
+
+private:
+  GenericNodeContext();
+  GenericNodeContext(const GenericNodeContext&);
+  GenericNodeContext& operator=(const GenericNodeContext&);
+
+  SharedPtr<const Node> mNode;
+};
+
+//// This one is used to execute the simulation system
+class ModelContext : public LeafContext {
+public:
   ModelContext(const Model* model) :
     mModel(model)
   { }
 
+  virtual const Node& getNode() const
+  { return *mModel; }
+
   bool alloc()
-  { return mModel->alloc(mLeafContext); }
+  { return mModel->alloc(*this); }
   void init()
-  { mModel->init(mLeafContext.mDiscreteState, mLeafContext.mContinousState); }
+  { mModel->init(mDiscreteState, mContinousState); }
   void output()
-  { mModel->output(mLeafContext.mDiscreteState, mLeafContext.mContinousState,
-                   mLeafContext.mPortValueList); }
+  { mModel->output(mDiscreteState, mContinousState, mPortValueList); }
   void update()
-  { mModel->update(mLeafContext.mDiscreteState, mLeafContext.mContinousState,
-                   mLeafContext.mPortValueList); }
+  { mModel->update(mDiscreteState, mContinousState, mPortValueList); }
 
 //   void derivative()
-//   { mModel->derivative(mLeafContext.mDiscreteState,
-//                        mLeafContext.mContinousState,
-//                        mLeafContext.mPortValueList,
-//                        mLeafContext.mContinousStateDerivative); }
+//   { mModel->derivative(mDiscreteState,
+//                        mContinousState,
+//                        mPortValueList,
+//                        mContinousStateDerivative); }
 
   SharedPtr<const Model> mModel;
-  LeafContext mLeafContext;
 
 private:
   ModelContext();
@@ -129,17 +203,21 @@
   ModelContext& operator=(const ModelContext&);
 };
 
-class MechanicContext : public Referenced {
+class MechanicContext : public LeafContext {
 public:
   MechanicContext(const MechanicNode* mechanicNode) :
     mMechanicNode(mechanicNode)
   { }
 
+  virtual const Node& getNode() const
+  { return *mMechanicNode; }
+
   bool alloc()
-  { return mMechanicNode->alloc(mLeafContext); }
+  { return mMechanicNode->alloc(*this); }
+  void init()
+  { mMechanicNode->init(mDiscreteState, mContinousState); }
 
   SharedPtr<const MechanicNode> mMechanicNode;
-  LeafContext mLeafContext;
 
 private:
   MechanicContext();
@@ -147,7 +225,10 @@
   MechanicContext& operator=(const MechanicContext&);
 };
 
-class LeafInstance : public WeakReferenced {
+
+
+
+class LeafInstance : public NodeInstance {
 public:
   struct LeafPortData;
   struct AcceptorPortData;
@@ -372,8 +453,10 @@
   }
 
   virtual const LeafNode* getLeafNode() const = 0;
-  virtual void setPortValue(unsigned, PortValue*) const = 0;
 
+  void setPortValue(unsigned i, PortValue* portValue)
+  { getNodeContext().getPortValueList().setPortValue(i, portValue); }
+
   // Return true if this leaf directly depends on one of leafInstance outputs
   bool dependsOn(LeafInstance* leafInstance)
   {
@@ -461,21 +544,14 @@
     mModelContext(new ModelContext(model))
   { }
 
+  virtual ModelContext& getNodeContext()
+  { return *mModelContext; }
+  virtual const ModelContext& getNodeContext() const
+  { return *mModelContext; }
+
   virtual const Model* getLeafNode() const
   { return mModelContext->mModel; }
 
-  virtual void setPortValue(unsigned i, PortValue* portValue) const
-  { mModelContext->mLeafContext.mPortValueList.setPortValue(i, portValue); }
-
-  bool alloc()
-  { return mModelContext->alloc(); }
-  void init()
-  { mModelContext->init(); }
-  void output()
-  { mModelContext->output(); }
-  void update()
-  { mModelContext->update(); }
-
   SharedPtr<ModelContext> mModelContext;
 };
 
@@ -486,15 +562,14 @@
     mMechanicContext(new MechanicContext(mechanicNode))
   { }
 
+  virtual MechanicContext& getNodeContext()
+  { return *mMechanicContext; }
+  virtual const MechanicContext& getNodeContext() const
+  { return *mMechanicContext; }
+
   virtual const MechanicNode* getLeafNode() const
   { return mMechanicContext->mMechanicNode; }
 
-  virtual void setPortValue(unsigned i, PortValue* portValue) const
-  { mMechanicContext->mLeafContext.mPortValueList.setPortValue(i, portValue); }
-
-  bool alloc()
-  { return mMechanicContext->alloc(); }
-
   SharedPtr<MechanicContext> mMechanicContext;
 };
 
@@ -706,7 +781,7 @@
     }
 
     for (j = modelContextList.begin(); j != modelContextList.end(); ++j) {
-      if (!(*j)->alloc()) {
+      if (!(*j)->getNodeContext().alloc()) {
         Log(Schedule, Error) << "Could not alloc for model ... FIXME" << endl;
         return false;
       }
@@ -714,8 +789,8 @@
 
     // FIXME is here just for curiousity :)
     for (j = modelContextList.begin(); j != modelContextList.end(); ++j) {
-      (*j)->init();
-      (*j)->output();
+      (*j)->getNodeContext().init();
+      (*j)->getNodeContext().output();
     }
 
     modelContexts.swap(modelContextList);



From frohlich at mail.berlios.de  Sun Sep 14 19:28:28 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 14 Sep 2008 19:28:28 +0200
Subject: [OpenFDM-svn] r476 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200809141728.m8EHSSZT022649@sheep.berlios.de>

Author: frohlich
Date: 2008-09-14 19:28:28 +0200 (Sun, 14 Sep 2008)
New Revision: 476

Modified:
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Step in refactoring port connections.


Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-13 15:25:18 UTC (rev 475)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-14 17:28:28 UTC (rev 476)
@@ -129,6 +129,7 @@
 protected:
   NodeInstance() {}
 
+public: // FIXME????
   /// The node context that belongs to this instance.
   virtual NodeContext& getNodeContext() = 0;
   virtual const NodeContext& getNodeContext() const = 0;
@@ -230,6 +231,9 @@
 
 class LeafInstance : public NodeInstance {
 public:
+
+  class PortDataList;
+
   struct LeafPortData;
   struct AcceptorPortData;
   struct ProviderPortData;
@@ -237,6 +241,7 @@
 
   class PortData : public WeakReferenced {
   public:
+    PortData(PortDataList* portDataList) : mParentPortDataList(portDataList) { }
     virtual ~PortData() {}
     virtual LeafPortData* toLeafPortData()
     { return 0; }
@@ -247,12 +252,28 @@
     virtual ProviderPortData* toProviderPortData()
     { return 0; }
     virtual bool connect(PortData*) = 0;
+
+    SharedPtr<PortDataList> getParentPortDataList() const
+    { return mParentPortDataList.lock(); }
+
+    std::string getNodeName() const
+    {
+      SharedPtr<PortDataList> portDataList = getParentPortDataList();
+      if (!portDataList)
+        return std::string();
+      SharedPtr<NodeInstance> nodeInstance = portDataList->mNodeInstance.lock();
+      if (!nodeInstance)
+        return std::string();
+      return nodeInstance->getNode().getName();
+    }
+
+    WeakPtr<PortDataList> mParentPortDataList;
   };
 
   class LeafPortData : public PortData {
   public:
-    LeafPortData(LeafInstance* leafInstance, const PortInfo* portInfo) :
-      mLeafInstance(leafInstance),
+    LeafPortData(PortDataList* portDataList, const PortInfo* portInfo) :
+      PortData(portDataList),
       mPortInfo(portInfo)
     { }
     virtual ~LeafPortData() {}
@@ -260,10 +281,6 @@
     virtual LeafPortData* toLeafPortData()
     { return this; }
     
-    /// Return the LeafInstance this LeafPortData belongs to.
-    SharedPtr<LeafInstance> getLeafInstance() const
-    { return mLeafInstance.lock(); }
-
     const SharedPtr<const PortInfo>& getPortInfo() const
     { return mPortInfo; }
 
@@ -274,14 +291,13 @@
     { }
 
   private:
-    WeakPtr<LeafInstance> mLeafInstance;
     SharedPtr<const PortInfo> mPortInfo;
   };
 
   struct ProviderPortData : public LeafPortData {
-    ProviderPortData(LeafInstance* leafInstance,
+    ProviderPortData(PortDataList* portDataList,
                      const ProviderPortInfo* providerPort) :
-      LeafPortData(leafInstance, providerPort),
+      LeafPortData(portDataList, providerPort),
       _providerPort(providerPort)
     { }
     virtual ProviderPortData* toProviderPortData()
@@ -319,9 +335,7 @@
         acceptorPortData = _acceptorPortDataList[i].lock();
         if (!acceptorPortData)
           continue;
-        SharedPtr<LeafInstance> leafInstance;
-        leafInstance = acceptorPortData->getLeafInstance();
-        std::cout << "    Node \"" << leafInstance->getLeafNode()->getName()
+        std::cout << "    Node \"" << acceptorPortData->getNodeName()
                   << "\" Port \"" << acceptorPortData->getPortInfo()->getName()
                   << "\"" << std::endl;
       }
@@ -331,9 +345,9 @@
     std::vector<WeakPtr<AcceptorPortData> > _acceptorPortDataList;
   };
   struct AcceptorPortData : public LeafPortData {
-    AcceptorPortData(LeafInstance* leafInstance,
+    AcceptorPortData(PortDataList* portDataList,
                      const AcceptorPortInfo* acceptorPort) :
-      LeafPortData(leafInstance, acceptorPort),
+      LeafPortData(portDataList, acceptorPort),
       _acceptorPort(acceptorPort)
     { }
     virtual AcceptorPortData* toAcceptorPortData()
@@ -390,9 +404,7 @@
       if (!providerPortData)
         return;
  
-      SharedPtr<LeafInstance> leafInstance;
-      leafInstance = providerPortData->getLeafInstance();
-      std::cout << "    Node \"" << leafInstance->getLeafNode()->getName()
+      std::cout << "    Node \"" << providerPortData->getNodeName()
                 << "\" Port \"" << providerPortData->getPortInfo()->getName()
                 << "\"" << std::endl;
     }
@@ -409,7 +421,8 @@
 
   class ProxyPortData : public PortData {
   public:
-    ProxyPortData(PortData* portData)
+    ProxyPortData(PortData* portData) :
+      PortData(0 /*FIXME*/)
     {
       if (!portData)
         return;
@@ -439,102 +452,132 @@
   };
 
   LeafInstance(const LeafNode* leaf)
-  { allocPorts(leaf); }
+  { }
   virtual ~LeafInstance()
   { }
 
-  LeafPortData* getPortData(const PortId& portId)
+  void print()
   {
-    OpenFDMAssert(getLeafNode());
-    unsigned index = getLeafNode()->getPortIndex(portId);
-    // FIXME, is an error condition, not an assert???
-    OpenFDMAssert(index < mPortData.size());
-    return mPortData[index];
+    std::cout << "Leaf \"" << getNode().getName() << "\"" << std::endl;
+    for (unsigned i = 0; i < getPortData().size(); ++i) {
+      getPortData()[i]->print();
+    }
   }
 
-  virtual const LeafNode* getLeafNode() const = 0;
-
-  void setPortValue(unsigned i, PortValue* portValue)
-  { getNodeContext().getPortValueList().setPortValue(i, portValue); }
-
   // Return true if this leaf directly depends on one of leafInstance outputs
   bool dependsOn(LeafInstance* leafInstance)
   {
-    for (unsigned i = 0; i < mPortData.size(); ++i) {
-      for (unsigned j = 0; j < leafInstance->mPortData.size(); ++j) {
-        if (!mPortData[i]->isConnected(leafInstance->mPortData[j]))
+    return getPortDataList()->dependsOn(leafInstance->getPortDataList());
+  }
+
+  class PortDataList : public WeakReferenced {
+  public:
+    PortDataList(NodeInstance* nodeInstance) :
+      mNodeInstance(nodeInstance)
+    { }
+    
+    AcceptorPortData* newAcceptorPortData(const AcceptorPortInfo* acceptorPort)
+    {
+      AcceptorPortData* acceptorPortData;
+      acceptorPortData = new AcceptorPortData(this, acceptorPort);
+      mPortDataVector.push_back(acceptorPortData);
+      return acceptorPortData;
+    }
+    ProviderPortData* newProviderPortData(const ProviderPortInfo* providerPort)
+    {
+      ProviderPortData* providerPortData;
+      providerPortData = new ProviderPortData(this, providerPort);
+      mPortDataVector.push_back(providerPortData);
+      return providerPortData;
+    }
+    
+    const Node& getNode() const
+    { return mNodeInstance.lock()->getNode(); }
+    
+    bool allocAndConnectProviderPortValues()
+    {
+      for (unsigned i = 0; i < getNode().getNumPorts(); ++i) {
+        const ProviderPortInfo* providerPortInfo;
+        providerPortInfo = getNode().getPort(i)->toProviderPortInfo();
+        if (!providerPortInfo)
           continue;
-        PortId inPortId = getLeafNode()->getPortId(i);
-
-        // FIXME, may be other concept:
-        // make Model return a list of 'direct feedthrough ports'?
-        for (unsigned k = 0; k < mPortData.size(); ++k) {
-          PortId outPortId = getLeafNode()->getPortId(k);
-          if (getLeafNode()->dependsOn(inPortId, outPortId))
-            return true;
+        
+        PortValue* portValue = providerPortInfo->newValue();
+        setPortValue(i, portValue);
+        
+        // Also set the port value to all connected ports
+        ProviderPortData* providerPortData = mPortDataVector[i]->toProviderPortData();
+        OpenFDMAssert(providerPortData);
+        
+        for (unsigned j = 0; j < providerPortData->_acceptorPortDataList.size(); ++j) {
+          SharedPtr<AcceptorPortData> acceptorPortData;
+          acceptorPortData = providerPortData->_acceptorPortDataList[j].lock();
+          // Ok, happens for proxy ports, these still show up here
+          if (!acceptorPortData)
+            continue;
+          
+          SharedPtr<PortDataList> portDataList;
+          portDataList = acceptorPortData->getParentPortDataList();
+          OpenFDMAssert(portDataList);
+          
+          OpenFDMAssert(acceptorPortData->getPortInfo());
+          unsigned index = acceptorPortData->getPortInfo()->getIndex();
+          portDataList->setPortValue(index, portValue);
         }
       }
     }
-    return false;
-  }
-
-  void print()
-  {
-    std::cout << "Leaf \"" << getLeafNode()->getName() << "\"" << std::endl;
-    for (unsigned i = 0; i < mPortData.size(); ++i) {
-      mPortData[i]->print();
-    }
-  }
-
-  bool allocAndConnectProviderPortValues()
-  {
-    for (unsigned i = 0; i < getLeafNode()->getNumPorts(); ++i) {
-      const ProviderPortInfo* providerPortInfo;
-      providerPortInfo = getLeafNode()->getPort(i)->toProviderPortInfo();
-      if (!providerPortInfo)
-        continue;
-
-      PortValue* portValue = providerPortInfo->newValue();
-      setPortValue(i, portValue);
+    void setPortValue(unsigned i, PortValue* portValue)
+    { mNodeInstance.lock()->getNodeContext().getPortValueList().setPortValue(i, portValue); }
       
-      // Also set the port value to all connected ports
-      ProviderPortData* providerPortData = mPortData[i]->toProviderPortData();
-      OpenFDMAssert(providerPortData);
       
-      for (unsigned j = 0; j < providerPortData->_acceptorPortDataList.size(); ++j) {
-        SharedPtr<AcceptorPortData> acceptorPortData;
-        acceptorPortData = providerPortData->_acceptorPortDataList[j].lock();
-        // Ok, happens for proxy ports, these still show up here
-        if (!acceptorPortData)
-          continue;
-        SharedPtr<LeafInstance> leafInstance;
-        leafInstance = acceptorPortData->getLeafInstance();
-        OpenFDMAssert(leafInstance);
-        
-        OpenFDMAssert(acceptorPortData->getPortInfo());
-        unsigned index = acceptorPortData->getPortInfo()->getIndex();
-        leafInstance->setPortValue(index, portValue);
+    // Return true if this leaf directly depends on one of leafInstance outputs
+    bool dependsOn(PortDataList* portDataList)
+    {
+      for (unsigned i = 0; i < mPortDataVector.size(); ++i) {
+        for (unsigned j = 0; j < portDataList->mPortDataVector.size(); ++j) {
+          if (!mPortDataVector[i]->isConnected(portDataList->mPortDataVector[j]))
+            continue;
+          PortId inPortId = getNode().getPortId(i);
+          
+          // FIXME, may be other concept:
+          // make Model return a list of 'direct feedthrough ports'?
+          for (unsigned k = 0; k < mPortDataVector.size(); ++k) {
+            PortId outPortId = getNode().getPortId(k);
+            // FIXME ugly
+            const Node* node = &(mNodeInstance.lock()->getNode());
+            const LeafNode* leafNode = dynamic_cast<const LeafNode*>(node);
+            if (leafNode && leafNode->dependsOn(inPortId, outPortId))
+              return true;
+          }
+        }
       }
+      return false;
     }
-  }
 
-private:
-  void allocPorts(const Node* node)
+    /// The vector of per port connect information
+    typedef std::vector<SharedPtr<LeafPortData> > PortDataVector;
+    PortDataVector mPortDataVector;
+    
+    /// The NodeInstance having some way to reference the
+    /// PortValues to the current connect information.
+    // FIXME: can only be weak so far ...
+    //   SharedPtr<NodeInstance> mNodeInstance;
+    WeakPtr<NodeInstance> mNodeInstance;
+  };
+
+  SharedPtr<PortDataList> getPortDataList()
   {
-    for (unsigned i = 0; i < node->getNumPorts(); ++i) {
-      SharedPtr<const PortInfo> port = node->getPort(i);
-      const ProviderPortInfo* providerPort = port->toProviderPortInfo();
-      if (providerPort)
-        mPortData.push_back(new ProviderPortData(this, providerPort));
-      const AcceptorPortInfo* acceptorPort = port->toAcceptorPortInfo();
-      if (acceptorPort)
-        mPortData.push_back(new AcceptorPortData(this, acceptorPort));
-    }
+    if (!mPortDataList)
+      mPortDataList = new PortDataList(this);
+    return mPortDataList;
   }
+  
+  std::vector<SharedPtr<LeafPortData> >& getPortData()
+  { return getPortDataList()->mPortDataVector; }
 
   // List of port dependent info used to build up the connect info and
   // the sorted list of leafs.
-  std::vector<SharedPtr<LeafPortData> > mPortData;
+  SharedPtr<PortDataList> mPortDataList;
 };
 
 class ModelInstance : public LeafInstance {
@@ -549,9 +592,6 @@
   virtual const ModelContext& getNodeContext() const
   { return *mModelContext; }
 
-  virtual const Model* getLeafNode() const
-  { return mModelContext->mModel; }
-
   SharedPtr<ModelContext> mModelContext;
 };
 
@@ -567,9 +607,6 @@
   virtual const MechanicContext& getNodeContext() const
   { return *mMechanicContext; }
 
-  virtual const MechanicNode* getLeafNode() const
-  { return mMechanicContext->mMechanicNode; }
-
   SharedPtr<MechanicContext> mMechanicContext;
 };
 
@@ -607,9 +644,25 @@
   {
     // FIXME: move to LeafInstance??
     for (unsigned i = 0; i < leaf.getNumPorts(); ++i) {
-      PortId portId = leaf.getPortId(i);
-      LeafInstance::LeafPortData* portData = leafInstance->getPortData(portId);
-      _leafPortDataMap[getCurrentNodeId()][portId] = portData;
+      SharedPtr<const PortInfo> port = leaf.getPort(i);
+      const ProviderPortInfo* providerPort = port->toProviderPortInfo();
+      if (providerPort) {
+        LeafInstance::ProviderPortData* providerPortData;
+        providerPortData =
+          leafInstance->getPortDataList()->newProviderPortData(providerPort);
+
+        PortId portId = leaf.getPortId(i);
+        _leafPortDataMap[getCurrentNodeId()][portId] = providerPortData;
+      }
+      const AcceptorPortInfo* acceptorPort = port->toAcceptorPortInfo();
+      if (acceptorPort) {
+        LeafInstance::AcceptorPortData* acceptorPortData;
+        acceptorPortData =
+          leafInstance->getPortDataList()->newAcceptorPortData(acceptorPort);
+
+        PortId portId = leaf.getPortId(i);
+        _leafPortDataMap[getCurrentNodeId()][portId] = acceptorPortData;
+      }
     }
   }
 
@@ -618,7 +671,7 @@
     // Need to stor the root nodes to build up the spanning tree for the
     // mechanical system here.
     MechanicInstance* mechanicInstance = new MechanicInstance(&node);
-    _leafInstanceList.push_back(mechanicInstance);
+    _nodeInstanceList.push_back(mechanicInstance);
 //     _mechanicInstanceList.push_back(mechanicInstance);
     _rootJointInstanceList.push_back(mechanicInstance);
     allocPortData(mechanicInstance, node);
@@ -626,14 +679,14 @@
   virtual void apply(const MechanicNode& node)
   {
     MechanicInstance* mechanicInstance = new MechanicInstance(&node);
-    _leafInstanceList.push_back(mechanicInstance);
+    _nodeInstanceList.push_back(mechanicInstance);
     _mechanicInstanceList.push_back(mechanicInstance);
     allocPortData(mechanicInstance, node);
   }
   virtual void apply(const Model& node)
   {
     ModelInstance* modelInstance = new ModelInstance(&node);
-    _leafInstanceList.push_back(modelInstance);
+    _nodeInstanceList.push_back(modelInstance);
     _modelInstanceList.push_back(modelInstance);
     allocPortData(modelInstance, node);
   }
@@ -717,10 +770,12 @@
   }
 
   ////////////////////////////////////////////////////////////////////////////
-  // The final list of leafs we have in the system
-  typedef std::list<SharedPtr<LeafInstance> > LeafInstanceList;
-  LeafInstanceList _leafInstanceList;
+  // The final list of Nodes we have in the simulation system
+  typedef std::list<SharedPtr<NodeInstance> > NodeInstanceList;
+  NodeInstanceList _nodeInstanceList;
 
+
+  // The Models list, worthwhile for sorting
   typedef std::list<SharedPtr<ModelInstance> > ModelInstanceList;
   ModelInstanceList _modelInstanceList;
   typedef std::list<SharedPtr<MechanicInstance> > MechanicInstanceList;
@@ -735,7 +790,10 @@
   typedef std::map<Group::NodeId, NodePortDataMap> LeafPortDataMap;
   LeafPortDataMap _leafPortDataMap;
 
+  /// Used to alloc ports
+//   typedef std::list<SharedPtr<LeafInstance::ProviderPortData> > ProviderPortDataList;
 
+
   // method to sort the leafs according to their dependency
   bool sortModelList()
   {
@@ -774,7 +832,7 @@
 
     ModelContextList::const_iterator j;
     for (j = modelContextList.begin(); j != modelContextList.end(); ++j) {
-      if (!(*j)->allocAndConnectProviderPortValues()) {
+      if (!(*j)->getPortDataList()->allocAndConnectProviderPortValues()) {
         Log(Schedule, Error) << "Could not alloc for model ... FIXME" << endl;
         return false;
       }



From frohlich at mail.berlios.de  Mon Sep 15 07:45:50 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Mon, 15 Sep 2008 07:45:50 +0200
Subject: [OpenFDM-svn] r477 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200809150545.m8F5jobX019868@sheep.berlios.de>

Author: frohlich
Date: 2008-09-15 07:45:49 +0200 (Mon, 15 Sep 2008)
New Revision: 477

Modified:
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
More on building up simulation systems.


Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-14 17:28:28 UTC (rev 476)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-15 05:45:49 UTC (rev 477)
@@ -171,6 +171,23 @@
   SharedPtr<const Node> mNode;
 };
 
+class GenericNodeInstance : public NodeInstance {
+public:
+  GenericNodeInstance(NodeContext* nodeContext) :
+    mNodeContext(nodeContext)
+  { }
+
+  /// The node context that belongs to this instance.
+  virtual NodeContext& getNodeContext()
+  { return *mNodeContext; }
+  virtual const NodeContext& getNodeContext() const
+  { return *mNodeContext; }
+
+  SharedPtr<NodeContext> mNodeContext;
+};
+
+
+
 //// This one is used to execute the simulation system
 class ModelContext : public LeafContext {
 public:
@@ -178,7 +195,7 @@
     mModel(model)
   { }
 
-  virtual const Node& getNode() const
+  virtual const Model& getNode() const
   { return *mModel; }
 
   bool alloc()
@@ -204,13 +221,30 @@
   ModelContext& operator=(const ModelContext&);
 };
 
+class ModelInstance : public NodeInstance {
+public:
+  ModelInstance(const Model* model) :
+    mModelContext(new ModelContext(model))
+  { }
+
+  virtual ModelContext& getNodeContext()
+  { return *mModelContext; }
+  virtual const ModelContext& getNodeContext() const
+  { return *mModelContext; }
+
+  SharedPtr<ModelContext> mModelContext;
+};
+
+
+
+
 class MechanicContext : public LeafContext {
 public:
   MechanicContext(const MechanicNode* mechanicNode) :
     mMechanicNode(mechanicNode)
   { }
 
-  virtual const Node& getNode() const
+  virtual const MechanicNode& getNode() const
   { return *mMechanicNode; }
 
   bool alloc()
@@ -226,12 +260,28 @@
   MechanicContext& operator=(const MechanicContext&);
 };
 
+class MechanicInstance : public NodeInstance {
+public:
+  MechanicInstance(const MechanicNode* mechanicNode) :
+    mMechanicContext(new MechanicContext(mechanicNode))
+  { }
 
+  virtual MechanicContext& getNodeContext()
+  { return *mMechanicContext; }
+  virtual const MechanicContext& getNodeContext() const
+  { return *mMechanicContext; }
 
+  SharedPtr<MechanicContext> mMechanicContext;
+};
 
-class LeafInstance : public NodeInstance {
-public:
 
+
+
+
+
+// Just here so that I do not care for intationation order for now ...
+struct PortDataHelper {
+
   class PortDataList;
 
   struct LeafPortData;
@@ -261,7 +311,7 @@
       SharedPtr<PortDataList> portDataList = getParentPortDataList();
       if (!portDataList)
         return std::string();
-      SharedPtr<NodeInstance> nodeInstance = portDataList->mNodeInstance.lock();
+      SharedPtr<NodeInstance> nodeInstance = portDataList->mNodeInstance;
       if (!nodeInstance)
         return std::string();
       return nodeInstance->getNode().getName();
@@ -335,6 +385,8 @@
         acceptorPortData = _acceptorPortDataList[i].lock();
         if (!acceptorPortData)
           continue;
+        if (!acceptorPortData->getPortInfo())
+          continue;
         std::cout << "    Node \"" << acceptorPortData->getNodeName()
                   << "\" Port \"" << acceptorPortData->getPortInfo()->getName()
                   << "\"" << std::endl;
@@ -403,8 +455,9 @@
       providerPortData = _providerPortData.lock();
       if (!providerPortData)
         return;
- 
-      std::cout << "    Node \"" << providerPortData->getNodeName()
+      if (!providerPortData->getPortInfo())
+        return;
+       std::cout << "    Node \"" << providerPortData->getNodeName()
                 << "\" Port \"" << providerPortData->getPortInfo()->getName()
                 << "\"" << std::endl;
     }
@@ -421,8 +474,8 @@
 
   class ProxyPortData : public PortData {
   public:
-    ProxyPortData(PortData* portData) :
-      PortData(0 /*FIXME*/)
+    ProxyPortData(PortDataList* portDataList, PortData* portData) :
+      PortData(portDataList)
     {
       if (!portData)
         return;
@@ -451,25 +504,7 @@
     std::vector<SharedPtr<PortData> > mPortDataList;
   };
 
-  LeafInstance(const LeafNode* leaf)
-  { }
-  virtual ~LeafInstance()
-  { }
-
-  void print()
-  {
-    std::cout << "Leaf \"" << getNode().getName() << "\"" << std::endl;
-    for (unsigned i = 0; i < getPortData().size(); ++i) {
-      getPortData()[i]->print();
-    }
-  }
-
   // Return true if this leaf directly depends on one of leafInstance outputs
-  bool dependsOn(LeafInstance* leafInstance)
-  {
-    return getPortDataList()->dependsOn(leafInstance->getPortDataList());
-  }
-
   class PortDataList : public WeakReferenced {
   public:
     PortDataList(NodeInstance* nodeInstance) :
@@ -490,9 +525,24 @@
       mPortDataVector.push_back(providerPortData);
       return providerPortData;
     }
+    ProxyPortData* newProxyPortData(PortData* portData)
+    {
+      ProxyPortData* proxyPortData;
+      proxyPortData = new ProxyPortData(this, portData);
+      // FIXME
+//       mPortDataVector.push_back(proxyPortData);
+      return proxyPortData;
+    }
     
     const Node& getNode() const
-    { return mNodeInstance.lock()->getNode(); }
+    { return mNodeInstance->getNode(); }
+
+    void print()
+    {
+      for (unsigned i = 0; i < mPortDataVector.size(); ++i) {
+        mPortDataVector[i]->print();
+      }
+    }
     
     bool allocAndConnectProviderPortValues()
     {
@@ -503,6 +553,8 @@
           continue;
         
         PortValue* portValue = providerPortInfo->newValue();
+        if (!portValue)
+          continue;
         setPortValue(i, portValue);
         
         // Also set the port value to all connected ports
@@ -520,16 +572,19 @@
           portDataList = acceptorPortData->getParentPortDataList();
           OpenFDMAssert(portDataList);
           
-          OpenFDMAssert(acceptorPortData->getPortInfo());
+          // FIXME, for now the GenericNodePorts do not have PortValues for
+          // this reason.
+          if (!acceptorPortData->getPortInfo())
+            continue;
           unsigned index = acceptorPortData->getPortInfo()->getIndex();
           portDataList->setPortValue(index, portValue);
         }
       }
+      return true;
     }
     void setPortValue(unsigned i, PortValue* portValue)
-    { mNodeInstance.lock()->getNodeContext().getPortValueList().setPortValue(i, portValue); }
-      
-      
+    { mNodeInstance->getNodeContext().getPortValueList().setPortValue(i, portValue); }
+
     // Return true if this leaf directly depends on one of leafInstance outputs
     bool dependsOn(PortDataList* portDataList)
     {
@@ -544,7 +599,7 @@
           for (unsigned k = 0; k < mPortDataVector.size(); ++k) {
             PortId outPortId = getNode().getPortId(k);
             // FIXME ugly
-            const Node* node = &(mNodeInstance.lock()->getNode());
+            const Node* node = &(mNodeInstance->getNode());
             const LeafNode* leafNode = dynamic_cast<const LeafNode*>(node);
             if (leafNode && leafNode->dependsOn(inPortId, outPortId))
               return true;
@@ -560,57 +615,10 @@
     
     /// The NodeInstance having some way to reference the
     /// PortValues to the current connect information.
-    // FIXME: can only be weak so far ...
-    //   SharedPtr<NodeInstance> mNodeInstance;
-    WeakPtr<NodeInstance> mNodeInstance;
+    SharedPtr<NodeInstance> mNodeInstance;
   };
-
-  SharedPtr<PortDataList> getPortDataList()
-  {
-    if (!mPortDataList)
-      mPortDataList = new PortDataList(this);
-    return mPortDataList;
-  }
-  
-  std::vector<SharedPtr<LeafPortData> >& getPortData()
-  { return getPortDataList()->mPortDataVector; }
-
-  // List of port dependent info used to build up the connect info and
-  // the sorted list of leafs.
-  SharedPtr<PortDataList> mPortDataList;
 };
 
-class ModelInstance : public LeafInstance {
-public:
-  ModelInstance(const Model* model) :
-    LeafInstance(model),
-    mModelContext(new ModelContext(model))
-  { }
-
-  virtual ModelContext& getNodeContext()
-  { return *mModelContext; }
-  virtual const ModelContext& getNodeContext() const
-  { return *mModelContext; }
-
-  SharedPtr<ModelContext> mModelContext;
-};
-
-class MechanicInstance : public LeafInstance {
-public:
-  MechanicInstance(const MechanicNode* mechanicNode) :
-    LeafInstance(mechanicNode),
-    mMechanicContext(new MechanicContext(mechanicNode))
-  { }
-
-  virtual MechanicContext& getNodeContext()
-  { return *mMechanicContext; }
-  virtual const MechanicContext& getNodeContext() const
-  { return *mMechanicContext; }
-
-  SharedPtr<MechanicContext> mMechanicContext;
-};
-
-
 class LeafInstanceCollector : public ConstNodeVisitor {
 public:
 
@@ -621,44 +629,65 @@
   virtual void apply(const LibraryNode& libraryNode)
   { std::cerr << __PRETTY_FUNCTION__ << std::endl; }
 
+  PortDataHelper::PortDataList* buildGenericNodeContext(const Node& node)
+  {
+    GenericNodeContext* genericNodeContext = new GenericNodeContext(&node);
+    GenericNodeInstance* genericNodeInstance;
+    genericNodeInstance = new GenericNodeInstance(genericNodeContext);
+    _nodeInstanceList.push_back(genericNodeInstance);
+    PortDataHelper::PortDataList* portDataList = new PortDataHelper::PortDataList(genericNodeInstance);
+    _portDataListMap[_nodeInstanceList.back()] = portDataList;
+
+    return portDataList;
+  }
+
   // Aussen acceptor, innen provider
   virtual void apply(const GroupAcceptorNode& leaf)
   {
+    PortDataHelper::PortDataList* portDataList = buildGenericNodeContext(leaf);
+
     OpenFDMAssert(leaf.getPort(0));
     PortId portId = leaf.getPortId(0);
-    LeafInstance::ProviderPortData* pd;
-    pd = new LeafInstance::ProviderPortData(0, leaf._groupInternalPort);
-    _leafPortDataMap[getCurrentNodeId()][portId] = pd;
+
+    PortDataHelper::ProviderPortData* providerPortData;
+//     providerPortData = portDataList->newProviderPortData(leaf._groupInternalPort);
+    providerPortData = portDataList->newProviderPortData(0 /*FIXME*/);
+    _leafPortDataMap[getCurrentNodeId()][portId] = providerPortData;
   }
   // Aussen provider, innen acceptor
   virtual void apply(const GroupProviderNode& leaf)
   {
+    PortDataHelper::PortDataList* portDataList = buildGenericNodeContext(leaf);
+
     OpenFDMAssert(leaf.getPort(0));
     PortId portId = leaf.getPortId(0);
-    LeafInstance::AcceptorPortData* ad;
-    ad = new LeafInstance::AcceptorPortData(0, leaf._groupInternalPort);
-    _leafPortDataMap[getCurrentNodeId()][portId] = ad;
+
+    PortDataHelper::AcceptorPortData* acceptorPortData;
+//     acceptorPortData = portDataList->newAcceptorPortData(leaf._groupInternalPort);
+    acceptorPortData = portDataList->newAcceptorPortData(0 /*FIXME*/);
+    _leafPortDataMap[getCurrentNodeId()][portId] = acceptorPortData;
   }
 
-  void allocPortData(LeafInstance* leafInstance, const LeafNode& leaf)
+  void allocPortData(NodeInstance* leafInstance, const LeafNode& leaf)
   {
+    PortDataHelper::PortDataList* portDataList = new PortDataHelper::PortDataList(leafInstance);
+    _portDataListMap[SharedPtr<NodeInstance>(leafInstance)] = portDataList;
+
     // FIXME: move to LeafInstance??
     for (unsigned i = 0; i < leaf.getNumPorts(); ++i) {
       SharedPtr<const PortInfo> port = leaf.getPort(i);
       const ProviderPortInfo* providerPort = port->toProviderPortInfo();
       if (providerPort) {
-        LeafInstance::ProviderPortData* providerPortData;
-        providerPortData =
-          leafInstance->getPortDataList()->newProviderPortData(providerPort);
+        PortDataHelper::ProviderPortData* providerPortData;
+        providerPortData = portDataList->newProviderPortData(providerPort);
 
         PortId portId = leaf.getPortId(i);
         _leafPortDataMap[getCurrentNodeId()][portId] = providerPortData;
       }
       const AcceptorPortInfo* acceptorPort = port->toAcceptorPortInfo();
       if (acceptorPort) {
-        LeafInstance::AcceptorPortData* acceptorPortData;
-        acceptorPortData =
-          leafInstance->getPortDataList()->newAcceptorPortData(acceptorPort);
+        PortDataHelper::AcceptorPortData* acceptorPortData;
+        acceptorPortData = portDataList->newAcceptorPortData(acceptorPort);
 
         PortId portId = leaf.getPortId(i);
         _leafPortDataMap[getCurrentNodeId()][portId] = acceptorPortData;
@@ -746,10 +775,8 @@
         std::cerr << "Cannot connect????" << std::endl;
     }
 
-    // Add a proxy LeafInstance that holds this groups ports, will be removed
-    // when merged into the parent
-    // FIXME: how to tell the parent group which connections need to be done??
-    // FIXME:
+    PortDataHelper::PortDataList* portDataList = buildGenericNodeContext(group);
+
     // add group connect routings
     // merge child list into the global list of instances
     for (unsigned i = 0; i < group.getNumPorts(); ++i) {
@@ -763,7 +790,7 @@
       }
 
       parentLeafPortDataMap[getCurrentNodeId()][portId] = 
-          new LeafInstance::ProxyPortData(_leafPortDataMap[nodeId].begin()->second);
+          portDataList->newProxyPortData(_leafPortDataMap[nodeId].begin()->second);
     }
 
     parentLeafPortDataMap.swap(_leafPortDataMap);
@@ -786,14 +813,16 @@
 
   ////////////////////////////////////////////////////////////////////////////
   // Used to map connections in groups ...
-  typedef std::map<PortId, SharedPtr<LeafInstance::PortData> > NodePortDataMap;
+  typedef std::map<PortId, SharedPtr<PortDataHelper::PortData> > NodePortDataMap;
   typedef std::map<Group::NodeId, NodePortDataMap> LeafPortDataMap;
   LeafPortDataMap _leafPortDataMap;
+  // Just to hold references to all mort data lists we have in the
+  // simulation system. They are just needed during traversal for connect
+  // information and to distribute port value pointers.
+  typedef std::map<SharedPtr<NodeInstance>,SharedPtr<PortDataHelper::PortDataList> > PortDataListMap;
+  PortDataListMap _portDataListMap;
 
-  /// Used to alloc ports
-//   typedef std::list<SharedPtr<LeafInstance::ProviderPortData> > ProviderPortDataList;
 
-
   // method to sort the leafs according to their dependency
   bool sortModelList()
   {
@@ -806,7 +835,12 @@
       for (i = sortedModelInstanceList.begin();
            i != sortedModelInstanceList.end();
            ++i) {
-        if (!(*i)->dependsOn(modelInstance))
+
+        PortDataHelper::PortDataList* portDataListMI
+          = _portDataListMap[modelInstance];
+        PortDataHelper::PortDataList* portDataListI = _portDataListMap[*i];
+
+        if (!portDataListI->dependsOn(portDataListMI))
           continue;
         sortedModelInstanceList.insert(i, modelInstance);
         break;
@@ -832,7 +866,10 @@
 
     ModelContextList::const_iterator j;
     for (j = modelContextList.begin(); j != modelContextList.end(); ++j) {
-      if (!(*j)->getPortDataList()->allocAndConnectProviderPortValues()) {
+      PortDataHelper::PortDataList* portDataList = _portDataListMap[*j];
+      if (!portDataList)
+        continue;
+      if (!portDataList->allocAndConnectProviderPortValues()) {
         Log(Schedule, Error) << "Could not alloc for model ... FIXME" << endl;
         return false;
       }
@@ -855,6 +892,18 @@
     return true;
   }
 
+  void print()
+  {
+    ModelInstanceList::iterator i;
+    for (i = _modelInstanceList.begin(); i != _modelInstanceList.end(); ++i) {
+      std::cout << "Model \"" << (*i)->getNode().getName() << "\"" << std::endl;
+      PortDataHelper::PortDataList* portDataList = _portDataListMap[*i];
+      if (!portDataList)
+        continue;
+      portDataList->print();
+    }
+  }
+
   void pushNodeId(const Group::NodeId& nodeId)
   { _nodeIdStack.push_back(nodeId); }
   void popNodeId()
@@ -919,12 +968,7 @@
   
   nodeInstanceCollector.sortModelList();
 
-  LeafInstanceCollector::ModelInstanceList::const_iterator i;
-  for (i = nodeInstanceCollector._modelInstanceList.begin();
-       i != nodeInstanceCollector._modelInstanceList.end();
-       ++i) {
-    (*i)->print();
-  }
+  nodeInstanceCollector.print();
 
   LeafInstanceCollector::ModelContextList modelContextList;
   nodeInstanceCollector.getModelContextList(modelContextList);



From frohlich at mail.berlios.de  Mon Sep 15 17:46:10 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Mon, 15 Sep 2008 17:46:10 +0200
Subject: [OpenFDM-svn] r478 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200809151546.m8FFkAKP009834@sheep.berlios.de>

Author: frohlich
Date: 2008-09-15 17:46:10 +0200 (Mon, 15 Sep 2008)
New Revision: 478

Modified:
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Small cleanup.


Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-15 05:45:49 UTC (rev 477)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-15 15:46:10 UTC (rev 478)
@@ -126,10 +126,15 @@
 //   const SampleTimeSet& getSampleTimeSet() const
 //   { return mSampleTimeSet; }
 
+  PortValueList& getPortValueList()
+  { return getNodeContext().getPortValueList(); }
+  const PortValueList& getPortValueList() const
+  { return getNodeContext().getPortValueList(); }
+
+
 protected:
   NodeInstance() {}
 
-public: // FIXME????
   /// The node context that belongs to this instance.
   virtual NodeContext& getNodeContext() = 0;
   virtual const NodeContext& getNodeContext() const = 0;
@@ -177,12 +182,14 @@
     mNodeContext(nodeContext)
   { }
 
+protected:
   /// The node context that belongs to this instance.
   virtual NodeContext& getNodeContext()
   { return *mNodeContext; }
   virtual const NodeContext& getNodeContext() const
   { return *mNodeContext; }
 
+private:
   SharedPtr<NodeContext> mNodeContext;
 };
 
@@ -213,12 +220,12 @@
 //                        mPortValueList,
 //                        mContinousStateDerivative); }
 
-  SharedPtr<const Model> mModel;
-
 private:
   ModelContext();
   ModelContext(const ModelContext&);
   ModelContext& operator=(const ModelContext&);
+
+  SharedPtr<const Model> mModel;
 };
 
 class ModelInstance : public NodeInstance {
@@ -227,11 +234,13 @@
     mModelContext(new ModelContext(model))
   { }
 
+// protected: // FIXME
   virtual ModelContext& getNodeContext()
   { return *mModelContext; }
   virtual const ModelContext& getNodeContext() const
   { return *mModelContext; }
 
+private:
   SharedPtr<ModelContext> mModelContext;
 };
 
@@ -266,11 +275,13 @@
     mMechanicContext(new MechanicContext(mechanicNode))
   { }
 
+protected:
   virtual MechanicContext& getNodeContext()
   { return *mMechanicContext; }
   virtual const MechanicContext& getNodeContext() const
   { return *mMechanicContext; }
 
+private:
   SharedPtr<MechanicContext> mMechanicContext;
 };
 
@@ -583,7 +594,7 @@
       return true;
     }
     void setPortValue(unsigned i, PortValue* portValue)
-    { mNodeInstance->getNodeContext().getPortValueList().setPortValue(i, portValue); }
+    { mNodeInstance->getPortValueList().setPortValue(i, portValue); }
 
     // Return true if this leaf directly depends on one of leafInstance outputs
     bool dependsOn(PortDataList* portDataList)



From frohlich at mail.berlios.de  Mon Sep 15 21:44:17 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Mon, 15 Sep 2008 21:44:17 +0200
Subject: [OpenFDM-svn] r479 - in branches/OpenFDM-StateSeparation/src:
	OpenFDM test
Message-ID: <200809151944.m8FJiH6l024040@sheep.berlios.de>

Author: frohlich
Date: 2008-09-15 21:44:16 +0200 (Mon, 15 Sep 2008)
New Revision: 479

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/AcceptorPortInfo.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Gain.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Gain.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Integrator.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Integrator.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/LeafNode.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/MatrixInputPort.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Model.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/NumericAcceptorPortInfo.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Output.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Output.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/PortValueList.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/RealInputPort.h
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Implement better concept for dependency analysis.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/AcceptorPortInfo.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/AcceptorPortInfo.h	2008-09-15 15:46:10 UTC (rev 478)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/AcceptorPortInfo.h	2008-09-15 19:44:16 UTC (rev 479)
@@ -13,12 +13,17 @@
 class AcceptorPortInfo : public PortInfo {
 public:
   AcceptorPortInfo(Node* node, const std::string& name) :
-    PortInfo(node, name) {}
+    PortInfo(node, name)
+  { }
+  virtual ~AcceptorPortInfo() {}
 
   virtual AcceptorPortInfo* toAcceptorPortInfo()
   { return this; }
   virtual const AcceptorPortInfo* toAcceptorPortInfo() const
   { return this; }
+
+  virtual bool getDirectInput() const
+  { return false; }
 };
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.cpp	2008-09-15 15:46:10 UTC (rev 478)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.cpp	2008-09-15 19:44:16 UTC (rev 479)
@@ -21,7 +21,7 @@
 
 Delay::Delay(const std::string& name) :
   Model(name),
-  mInputPort(newMatrixInputPort("input")),
+  mInputPort(newMatrixInputPort("input", true)),
   mOutputPort(newMatrixOutputPort("output")),
   mDelay(0)
 {
@@ -67,15 +67,6 @@
   discreteState[*mMatrixStateInfo].rotate(portValues[mInputPort]);
 }
 
-bool
-Delay::dependsOn(const PortId& in, const PortId& out) const
-{
-  if (mDelay != 0)
-    return false;
-  return in == getPortId(mInputPort.getPortIndex())
-    && out == getPortId(mOutputPort.getPortIndex());
-}
-
 unsigned
 Delay::getDelay(void) const
 {
@@ -86,6 +77,7 @@
 Delay::setDelay(unsigned delay)
 {
   mDelay = delay;
+  mInputPort.setDirectInput(mDelay == 0);
 }
 
 const Matrix&

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.h	2008-09-15 15:46:10 UTC (rev 478)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.h	2008-09-15 19:44:16 UTC (rev 479)
@@ -28,8 +28,6 @@
                       ContinousStateValueVector&,
                       const PortValueList& portValues) const;
 
-  virtual bool dependsOn(const PortId& in, const PortId& out) const;
-
   /// The delay number of timeslices
   unsigned getDelay(void) const;
   void setDelay(unsigned delay);

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Gain.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Gain.cpp	2008-09-15 15:46:10 UTC (rev 478)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Gain.cpp	2008-09-15 19:44:16 UTC (rev 479)
@@ -21,7 +21,7 @@
 
 Gain::Gain(const std::string& name) :
   Model(name),
-  mInputPort(newMatrixInputPort("input")),
+  mInputPort(newMatrixInputPort("input", true)),
   mOutputPort(newMatrixOutputPort("output")),
   mGain(1)
 {
@@ -46,16 +46,6 @@
   portValues[mOutputPort] = mGain*portValues[mInputPort];
 }
 
-bool
-Gain::dependsOn(const PortId& in, const PortId& out) const
-{
-  if (in != getPortId(mInputPort.getPortIndex()))
-    return false;
-  if (out != getPortId(mOutputPort.getPortIndex()))
-    return false;
-  return true;
-}
-
 const real_type&
 Gain::getGain(void) const
 {

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Gain.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Gain.h	2008-09-15 15:46:10 UTC (rev 478)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Gain.h	2008-09-15 19:44:16 UTC (rev 479)
@@ -21,7 +21,6 @@
   virtual void output(const DiscreteStateValueVector&,
                       const ContinousStateValueVector&,
                       PortValueList& portValues) const;
-  virtual bool dependsOn(const PortId& in, const PortId& out) const;
 
   const real_type& getGain(void) const;
   void setGain(const real_type& gain);

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Integrator.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Integrator.cpp	2008-09-15 15:46:10 UTC (rev 478)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Integrator.cpp	2008-09-15 19:44:16 UTC (rev 479)
@@ -15,9 +15,9 @@
 
 Integrator::Integrator(const std::string& name = std::string()) :
   Model(name),
-  mInputPort(newMatrixInputPort("input")),
+  mInputPort(newMatrixInputPort("input", false)),
   mOutputPort(newMatrixOutputPort("output")),
-  mInitialValuePort(newMatrixInputPort("initialValue"))
+  mInitialValuePort(newMatrixInputPort("initialValue", true))
 {
   mMatrixStateInfo = new MatrixStateInfo;
   addContinousStateInfo(mMatrixStateInfo);
@@ -69,13 +69,6 @@
   deriv[*mMatrixStateInfo] = portValues[mInputPort];
 }
 
-bool
-Integrator::dependsOn(const PortId&, const PortId&) const
-{
-  // FIXME, make the initial value port depend here ...
-  return false;
-}
-
 void
 Integrator::setInitialValue(const Matrix& initialValue)
 {

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Integrator.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Integrator.h	2008-09-15 15:46:10 UTC (rev 478)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Integrator.h	2008-09-15 19:44:16 UTC (rev 479)
@@ -24,8 +24,6 @@
   virtual void output(const DiscreteStateValueVector&, const ContinousStateValueVector& continousState, PortValueList& portValues) const;
   virtual void derivative(const DiscreteStateValueVector&, const ContinousStateValueVector& state, const PortValueList& portValues, ContinousStateValueVector& deriv) const;
 
-  virtual bool dependsOn(const PortId&, const PortId&) const;
-
   void setInitialValue(const Matrix& initialValue);
   const Matrix& getInitialValue() const;
 

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/LeafNode.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/LeafNode.h	2008-09-15 15:46:10 UTC (rev 478)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/LeafNode.h	2008-09-15 19:44:16 UTC (rev 479)
@@ -35,9 +35,6 @@
   virtual void init(DiscreteStateValueVector&, ContinousStateValueVector&) const // = 0;
   { }
 
-  // for dependency analysis
-  virtual bool dependsOn(const PortId& in, const PortId& out) const = 0;
-
   unsigned getNumContinousStateValues() const
   { return mContinousStateInfoVector.size(); }
   const ContinousStateInfo* getContinousStateInfo(unsigned index) const

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MatrixInputPort.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MatrixInputPort.h	2008-09-15 15:46:10 UTC (rev 478)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MatrixInputPort.h	2008-09-15 19:44:16 UTC (rev 479)
@@ -13,8 +13,9 @@
 
 class MatrixInputPort {
 public:
-  MatrixInputPort(Node* node, const std::string& name, const Size& size) :
-    mPort(new NumericAcceptorPortInfo(node, name, size))
+  MatrixInputPort(Node* node, const std::string& name,
+                  const Size& size, bool directInput) :
+    mPort(new NumericAcceptorPortInfo(node, name, size, directInput))
   {}
   NumericPortValue* getPortValue(const PortValueVector& portValueVector) const
   {
@@ -25,6 +26,10 @@
   }
   unsigned getPortIndex() const
   { return mPort->getIndex(); }
+  bool getDirectInput() const
+  { return mPort->getDirectInput(); }
+  void setDirectInput(bool directInput) const
+  { mPort->setDirectInput(directInput); }
 private:
   SharedPtr<NumericAcceptorPortInfo> mPort;
 };

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Model.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Model.h	2008-09-15 15:46:10 UTC (rev 478)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Model.h	2008-09-15 19:44:16 UTC (rev 479)
@@ -50,14 +50,15 @@
   newMatrixOutputPort(const std::string& name, const Size& size = Size(0, 0))
   { return MatrixOutputPort(this, name, size); }
   MatrixInputPort
-  newMatrixInputPort(const std::string& name, const Size& size = Size(0, 0))
-  { return MatrixInputPort(this, name, size); }
+  newMatrixInputPort(const std::string& name, bool directInput,
+                     const Size& size = Size(0, 0))
+  { return MatrixInputPort(this, name, size, directInput); }
   RealOutputPort
   newRealOutputPort(const std::string& name)
   { return RealOutputPort(this, name); }
   RealInputPort
-  newRealInputPort(const std::string& name)
-  { return RealInputPort(this, name); }
+  newRealInputPort(const std::string& name, bool directInput)
+  { return RealInputPort(this, name, directInput); }
 };
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/NumericAcceptorPortInfo.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/NumericAcceptorPortInfo.h	2008-09-15 15:46:10 UTC (rev 478)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/NumericAcceptorPortInfo.h	2008-09-15 19:44:16 UTC (rev 479)
@@ -12,13 +12,21 @@
 
 class NumericAcceptorPortInfo : public AcceptorPortInfo {
 public:
-  NumericAcceptorPortInfo(Node* node, const std::string& name, const Size& size) :
+  NumericAcceptorPortInfo(Node* node, const std::string& name,
+                          const Size& size, bool directInput) :
     AcceptorPortInfo(node, name),
-    mSize(size)
+    mSize(size),
+    mDirectInput(directInput)
   { }
 
+  virtual bool getDirectInput() const
+  { return mDirectInput; }
+  void setDirectInput(bool directInput)
+  { mDirectInput = directInput; }
+
 private:
   Size mSize;
+  bool mDirectInput;
 };
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Output.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Output.cpp	2008-09-15 15:46:10 UTC (rev 478)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Output.cpp	2008-09-15 19:44:16 UTC (rev 479)
@@ -20,7 +20,7 @@
 
 Output::Output(const std::string& name, Output::Callback* callback) :
   Model(name),
-  mInputPort(newRealInputPort("input")),
+  mInputPort(newRealInputPort("input", true)),
   mCallback(callback),
   mOutputGain(1)
 {

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Output.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Output.h	2008-09-15 15:46:10 UTC (rev 478)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Output.h	2008-09-15 19:44:16 UTC (rev 479)
@@ -28,10 +28,6 @@
   virtual void output(const DiscreteStateValueVector&,
                       const ContinousStateValueVector&,
                       PortValueList& portValues) const;
-  // FIXME: dependsOn semantic is broken. May be some kind of
-  // needPortInOutput in the port info???
-  virtual bool dependsOn(const PortId&, const PortId&) const
-  { return true; }
 
   Callback* getCallback(void) const;
   void setCallback(Callback* callback);

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/PortValueList.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/PortValueList.h	2008-09-15 15:46:10 UTC (rev 478)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/PortValueList.h	2008-09-15 19:44:16 UTC (rev 479)
@@ -80,6 +80,12 @@
   {
     setPortValue(port.getPortIndex(), new NumericPortValue(size));
   }
+  const PortValue* getPortValue(unsigned idx) const
+  {
+    if (mPortValueVector.size() <= idx)
+      return 0;
+    return mPortValueVector[idx];
+  }
 
 protected:
   PortValueVector mPortValueVector;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RealInputPort.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RealInputPort.h	2008-09-15 15:46:10 UTC (rev 478)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RealInputPort.h	2008-09-15 19:44:16 UTC (rev 479)
@@ -13,8 +13,8 @@
 
 class RealInputPort {
 public:
-  RealInputPort(Node* node, const std::string& name) :
-    mPort(new NumericAcceptorPortInfo(node, name, Size(1, 1)))
+  RealInputPort(Node* node, const std::string& name, bool directInput) :
+    mPort(new NumericAcceptorPortInfo(node, name, Size(1, 1), directInput))
   {}
   NumericPortValue* getPortValue(const PortValueVector& portValueVector) const
   {
@@ -25,6 +25,10 @@
   }
   unsigned getPortIndex() const
   { return mPort->getIndex(); }
+  bool getDirectInput() const
+  { return mPort->getDirectInput(); }
+  void setDirectInput(bool directInput) const
+  { mPort->setDirectInput(directInput); }
 private:
   SharedPtr<NumericAcceptorPortInfo> mPort;
 };

Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-15 15:46:10 UTC (rev 478)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-15 19:44:16 UTC (rev 479)
@@ -220,6 +220,36 @@
 //                        mPortValueList,
 //                        mContinousStateDerivative); }
 
+  // Return true if this leaf directly depends on one of leafInstance outputs
+  bool dependsOn(const ModelContext* modelContext) const
+  {
+    unsigned numPorts = mModel->getNumPorts();
+    for (unsigned i = 0; i < numPorts; ++i) {
+      const AcceptorPortInfo* acceptorPortInfo;
+      acceptorPortInfo = mModel->getPort(i)->toAcceptorPortInfo();
+      if (!acceptorPortInfo)
+        continue;
+      if (!acceptorPortInfo->getDirectInput())
+        continue;
+      const PortValue* portValue = getPortValueList().getPortValue(i);
+      if (!portValue)
+        continue;
+      unsigned otherNumPorts = modelContext->mModel->getNumPorts();
+      for (unsigned j = 0; j < otherNumPorts; ++j) {
+        if (!modelContext->mModel->getPort(j)->toProviderPortInfo())
+          continue;
+
+        const PortValue* otherPortValue;
+        otherPortValue = modelContext->getPortValueList().getPortValue(j);
+        if (portValue != otherPortValue)
+          continue;
+
+        return true;
+      }
+    }
+    return false;
+  }
+
 private:
   ModelContext();
   ModelContext(const ModelContext&);
@@ -234,6 +264,10 @@
     mModelContext(new ModelContext(model))
   { }
 
+  // Return true if this leaf directly depends on one of leafInstance outputs
+  bool dependsOn(const ModelInstance* modelInstance) const
+  { return mModelContext->dependsOn(modelInstance->mModelContext); }
+
 // protected: // FIXME
   virtual ModelContext& getNodeContext()
   { return *mModelContext; }
@@ -302,10 +336,11 @@
 
   class PortData : public WeakReferenced {
   public:
-    PortData(PortDataList* portDataList) : mParentPortDataList(portDataList) { }
-    virtual ~PortData() {}
-    virtual LeafPortData* toLeafPortData()
-    { return 0; }
+    PortData(PortDataList* portDataList) :
+      mParentPortDataList(portDataList)
+    { }
+    virtual ~PortData()
+    { }
     virtual ProxyPortData* toProxyPortData()
     { return 0; }
     virtual AcceptorPortData* toAcceptorPortData()
@@ -314,6 +349,9 @@
     { return 0; }
     virtual bool connect(PortData*) = 0;
 
+    virtual void print()
+    { }
+
     SharedPtr<PortDataList> getParentPortDataList() const
     { return mParentPortDataList.lock(); }
 
@@ -339,18 +377,9 @@
     { }
     virtual ~LeafPortData() {}
 
-    virtual LeafPortData* toLeafPortData()
-    { return this; }
-    
     const SharedPtr<const PortInfo>& getPortInfo() const
     { return mPortInfo; }
 
-    virtual bool isConnected(LeafPortData*)
-    { return false; }
-
-    virtual void print()
-    { }
-
   private:
     SharedPtr<const PortInfo> mPortInfo;
   };
@@ -377,16 +406,6 @@
       return acceptorPortData->connectToProvider(this);
     }
 
-    virtual bool isConnected(LeafPortData* portData)
-    {
-      if (!portData)
-        return false;
-      AcceptorPortData* acceptorPortData = portData->toAcceptorPortData();
-      if (!acceptorPortData)
-        return false;
-      return acceptorPortData->isConnectedToProvider(this);
-    }
-
     virtual void print()
     {
       std::cout << "  Provider Port \"" << getPortInfo()->getName()
@@ -440,23 +459,6 @@
       return true;
     }
 
-    virtual bool isConnected(LeafPortData* portData)
-    {
-      if (!portData)
-        return false;
-      ProviderPortData* providerPortData = portData->toProviderPortData();
-      if (!providerPortData)
-        return false;
-      return isConnectedToProvider(providerPortData);
-    }
-
-    bool isConnectedToProvider(ProviderPortData* providerPortData)
-    {
-      if (!providerPortData)
-        return false;
-      return providerPortData == _providerPortData.lock();
-    }
-
     virtual void print()
     {
       std::cout << "  Acceptor Port \"" << getPortInfo()->getName()
@@ -540,8 +542,7 @@
     {
       ProxyPortData* proxyPortData;
       proxyPortData = new ProxyPortData(this, portData);
-      // FIXME
-//       mPortDataVector.push_back(proxyPortData);
+      mPortDataVector.push_back(proxyPortData);
       return proxyPortData;
     }
     
@@ -557,6 +558,7 @@
     
     bool allocAndConnectProviderPortValues()
     {
+      // FIXME: move that into the PortData stuff
       for (unsigned i = 0; i < getNode().getNumPorts(); ++i) {
         const ProviderPortInfo* providerPortInfo;
         providerPortInfo = getNode().getPort(i)->toProviderPortInfo();
@@ -596,32 +598,8 @@
     void setPortValue(unsigned i, PortValue* portValue)
     { mNodeInstance->getPortValueList().setPortValue(i, portValue); }
 
-    // Return true if this leaf directly depends on one of leafInstance outputs
-    bool dependsOn(PortDataList* portDataList)
-    {
-      for (unsigned i = 0; i < mPortDataVector.size(); ++i) {
-        for (unsigned j = 0; j < portDataList->mPortDataVector.size(); ++j) {
-          if (!mPortDataVector[i]->isConnected(portDataList->mPortDataVector[j]))
-            continue;
-          PortId inPortId = getNode().getPortId(i);
-          
-          // FIXME, may be other concept:
-          // make Model return a list of 'direct feedthrough ports'?
-          for (unsigned k = 0; k < mPortDataVector.size(); ++k) {
-            PortId outPortId = getNode().getPortId(k);
-            // FIXME ugly
-            const Node* node = &(mNodeInstance->getNode());
-            const LeafNode* leafNode = dynamic_cast<const LeafNode*>(node);
-            if (leafNode && leafNode->dependsOn(inPortId, outPortId))
-              return true;
-          }
-        }
-      }
-      return false;
-    }
-
     /// The vector of per port connect information
-    typedef std::vector<SharedPtr<LeafPortData> > PortDataVector;
+    typedef std::vector<SharedPtr<PortData> > PortDataVector;
     PortDataVector mPortDataVector;
     
     /// The NodeInstance having some way to reference the
@@ -816,9 +794,11 @@
   // The Models list, worthwhile for sorting
   typedef std::list<SharedPtr<ModelInstance> > ModelInstanceList;
   ModelInstanceList _modelInstanceList;
+  // The mechanical system list, also for sorting
   typedef std::list<SharedPtr<MechanicInstance> > MechanicInstanceList;
   MechanicInstanceList _mechanicInstanceList;
-//   typedef std::list<SharedPtr<RootJointInstance> > RootJointInstanceList;
+  // The list of root nodes in the mechanicla system. Will be a starting point
+  // for sorting the tree of mechanical models downwards
   typedef std::list<SharedPtr<MechanicInstance> > RootJointInstanceList;
   RootJointInstanceList _rootJointInstanceList;
 
@@ -847,11 +827,7 @@
            i != sortedModelInstanceList.end();
            ++i) {
 
-        PortDataHelper::PortDataList* portDataListMI
-          = _portDataListMap[modelInstance];
-        PortDataHelper::PortDataList* portDataListI = _portDataListMap[*i];
-
-        if (!portDataListI->dependsOn(portDataListMI))
+        if (!(*i)->dependsOn(modelInstance))
           continue;
         sortedModelInstanceList.insert(i, modelInstance);
         break;
@@ -865,6 +841,21 @@
   typedef std::vector<SharedPtr<ModelInstance> > ModelContextList;
 
   bool
+  allocPortData()
+  {
+    PortDataListMap::const_iterator i;
+    for (i = _portDataListMap.begin(); i != _portDataListMap.end(); ++i) {
+      PortDataHelper::PortDataList* portDataList = i->second;
+      if (!portDataList)
+        continue;
+      if (!portDataList->allocAndConnectProviderPortValues()) {
+        Log(Schedule, Error) << "Could not alloc for model ... FIXME" << endl;
+        return false;
+      }
+    }
+  }
+
+  bool
   getModelContextList(ModelContextList& modelContexts)
   {
     modelContexts.resize(0);
@@ -877,16 +868,6 @@
 
     ModelContextList::const_iterator j;
     for (j = modelContextList.begin(); j != modelContextList.end(); ++j) {
-      PortDataHelper::PortDataList* portDataList = _portDataListMap[*j];
-      if (!portDataList)
-        continue;
-      if (!portDataList->allocAndConnectProviderPortValues()) {
-        Log(Schedule, Error) << "Could not alloc for model ... FIXME" << endl;
-        return false;
-      }
-    }
-
-    for (j = modelContextList.begin(); j != modelContextList.end(); ++j) {
       if (!(*j)->getNodeContext().alloc()) {
         Log(Schedule, Error) << "Could not alloc for model ... FIXME" << endl;
         return false;
@@ -977,6 +958,8 @@
   LeafInstanceCollector nodeInstanceCollector;
   topGroup->accept(nodeInstanceCollector);
   
+  nodeInstanceCollector.allocPortData();
+
   nodeInstanceCollector.sortModelList();
 
   nodeInstanceCollector.print();



From frohlich at mail.berlios.de  Mon Sep 15 21:54:55 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Mon, 15 Sep 2008 21:54:55 +0200
Subject: [OpenFDM-svn] r480 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200809151954.m8FJstic025086@sheep.berlios.de>

Author: frohlich
Date: 2008-09-15 21:54:55 +0200 (Mon, 15 Sep 2008)
New Revision: 480

Modified:
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Move insitialization to a System class.


Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-15 19:44:16 UTC (rev 479)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-15 19:54:55 UTC (rev 480)
@@ -853,6 +853,7 @@
         return false;
       }
     }
+    return true;
   }
 
   bool
@@ -912,6 +913,80 @@
   NodeIdStack _nodeIdStack;
 };
 
+class System : public Object {
+public:
+  System(const std::string& name, Node* node = 0) :
+    Object(name),
+    mNode(node)
+  { }
+
+  SharedPtr<Node> getNode()
+  { return mNode; }
+  SharedPtr<const Node> getNode() const
+  { return mNode; }
+  void setNode(Node* node)
+  {
+    clear();
+    mNode = node;
+  }
+
+  bool init()
+  {
+    if (!mNode)
+      return true;
+
+    // Build up the lists required to run the model.
+    LeafInstanceCollector nodeInstanceCollector;
+    mNode->accept(nodeInstanceCollector);
+    
+    // Allocates and distributes the PortValues, is required for the sort
+    // steps below
+    if (!nodeInstanceCollector.allocPortData())
+      return false;
+    // The model instances are sorted to match the direct input property
+    if (!nodeInstanceCollector.sortModelList())
+      return false;
+
+    // Just to play :)
+    nodeInstanceCollector.print();
+    
+    LeafInstanceCollector::ModelContextList modelContextList;
+    nodeInstanceCollector.getModelContextList(modelContextList);
+    // ...
+
+    // Ok, all successful so far, get the lists from the visitor
+    mNodeInstanceList.swap(nodeInstanceCollector._nodeInstanceList);
+
+    return true;
+  }
+
+  void clear()
+  {
+  }
+
+  /// Simulate the system until the time tEnd
+  bool simulate(real_type tEnd)
+  {
+    return false;
+  }
+
+  /// Bring the system in an equilibrum state near the current state ...
+  bool trim(void)
+  {
+    return false;
+  }
+
+  /// Return the current simulation time, convenience function
+//   const real_type& getTime(void) const
+//   { return mTime; }
+
+private:
+  SharedPtr<Node> mNode;
+
+  typedef std::list<SharedPtr<NodeInstance> > NodeInstanceList;
+  NodeInstanceList mNodeInstanceList;
+};
+
 } // namespace OpenFDM
 
 using namespace OpenFDM;
@@ -955,18 +1030,11 @@
 
   /////////////////////////////////////////////////
 
-  LeafInstanceCollector nodeInstanceCollector;
-  topGroup->accept(nodeInstanceCollector);
-  
-  nodeInstanceCollector.allocPortData();
+  SharedPtr<System> system = new System("System", topGroup);
 
-  nodeInstanceCollector.sortModelList();
+  if (!system->init())
+    return 1;
 
-  nodeInstanceCollector.print();
-
-  LeafInstanceCollector::ModelContextList modelContextList;
-  nodeInstanceCollector.getModelContextList(modelContextList);
-
   return 0;
 }
 



From frohlich at mail.berlios.de  Tue Sep 16 06:33:10 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Tue, 16 Sep 2008 06:33:10 +0200
Subject: [OpenFDM-svn] r481 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200809160433.m8G4XAgI022521@sheep.berlios.de>

Author: frohlich
Date: 2008-09-16 06:33:09 +0200 (Tue, 16 Sep 2008)
New Revision: 481

Modified:
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Clear the first list member of System in clear ...


Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-15 19:54:55 UTC (rev 480)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-16 04:33:09 UTC (rev 481)
@@ -962,6 +962,7 @@
 
   void clear()
   {
+    mNodeInstanceList.clear();
   }
 
   /// Simulate the system until the time tEnd



From frohlich at mail.berlios.de  Tue Sep 16 07:39:26 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Tue, 16 Sep 2008 07:39:26 +0200
Subject: [OpenFDM-svn] r482 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200809160539.m8G5dQEt018557@sheep.berlios.de>

Author: frohlich
Date: 2008-09-16 07:39:24 +0200 (Tue, 16 Sep 2008)
New Revision: 482

Modified:
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Add check for cyclic loops.


Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-16 04:33:09 UTC (rev 481)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-16 05:39:24 UTC (rev 482)
@@ -114,6 +114,10 @@
   const Node& getNode() const
   { return getNodeContext().getNode(); }
 
+  /// FIXME: is te wrong value, but sufficient for now to debug ...
+  const std::string& getPathString() const
+  { return getNodeContext().getNode().getName(); }
+
   /// FIXME: put this to some global place
 //   typedef std::vector<SharedPtr<const Node> > NodePath;
 //   const NodePath& getNodePath() const { return mNodePath; }
@@ -363,7 +367,7 @@
       SharedPtr<NodeInstance> nodeInstance = portDataList->mNodeInstance;
       if (!nodeInstance)
         return std::string();
-      return nodeInstance->getNode().getName();
+      return nodeInstance->getPathString();
     }
 
     WeakPtr<PortDataList> mParentPortDataList;
@@ -813,7 +817,6 @@
   typedef std::map<SharedPtr<NodeInstance>,SharedPtr<PortDataHelper::PortDataList> > PortDataListMap;
   PortDataListMap _portDataListMap;
 
-
   // method to sort the leafs according to their dependency
   bool sortModelList()
   {
@@ -826,16 +829,41 @@
       for (i = sortedModelInstanceList.begin();
            i != sortedModelInstanceList.end();
            ++i) {
-
         if (!(*i)->dependsOn(modelInstance))
           continue;
-        sortedModelInstanceList.insert(i, modelInstance);
+
+        // Something already sorted in depends on modelInstance,
+        // so schedule that new thing just before.
+        Log(Schedule, Info)
+          << "Inserting Model \"" << modelInstance->getPathString()
+          << "\" before Model \"" << (*i)->getPathString() << "\"" << std::endl;
+        i = sortedModelInstanceList.insert(i, modelInstance);
         break;
       }
-      if (i == sortedModelInstanceList.end())
+      if (i == sortedModelInstanceList.end()) {
+        // nothing found so far that depends on model instance.
+        // So put it at the end.
+        Log(Schedule, Info)
+          << "Appending Model \"" << modelInstance->getPathString()
+          << "\"" << std::endl;
+
         sortedModelInstanceList.push_back(modelInstance);
+      } else {
+        // If it cannot be put at the end, check if modelInstance depends
+        // on any model that is already scheduled behind to detect cyclic loops.
+        for (; i != sortedModelInstanceList.end(); ++i) {
+          if (!modelInstance->dependsOn(*i))
+            continue;
+          Log(Schedule,Error)
+            << "Detected cyclic loop: Model \""
+            << modelInstance->getPathString() << "\" depends on Model \""
+            << (*i)->getPathString() << "\"" << std::endl;
+          return false;
+        }
+      }
     }
     _modelInstanceList.swap(sortedModelInstanceList);
+    return true;
   }
 
   typedef std::vector<SharedPtr<ModelInstance> > ModelContextList;
@@ -889,7 +917,7 @@
   {
     ModelInstanceList::iterator i;
     for (i = _modelInstanceList.begin(); i != _modelInstanceList.end(); ++i) {
-      std::cout << "Model \"" << (*i)->getNode().getName() << "\"" << std::endl;
+      std::cout << "Model \"" << (*i)->getPathString() << "\"" << std::endl;
       PortDataHelper::PortDataList* portDataList = _portDataListMap[*i];
       if (!portDataList)
         continue;



From frohlich at mail.berlios.de  Tue Sep 16 21:43:15 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Tue, 16 Sep 2008 21:43:15 +0200
Subject: [OpenFDM-svn] r483 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200809161943.m8GJhFNx030054@sheep.berlios.de>

Author: frohlich
Date: 2008-09-16 21:43:15 +0200 (Tue, 16 Sep 2008)
New Revision: 483

Modified:
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Move some list types to global scope.


Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-16 05:39:24 UTC (rev 482)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-16 19:43:15 UTC (rev 483)
@@ -103,7 +103,7 @@
 /// there must be a PortData like structure that is only built during simulation
 /// model initialization.
 
-/// A NodeInstance represents an effictive model node in a ready to run
+/// A NodeInstance represents an effective model node in a ready to run
 /// System. You can access the Nodes Ports values for example.
 /// This class is meant to show up in the user interface of this simulation.
 class NodeInstance : public WeakReferenced {
@@ -135,7 +135,6 @@
   const PortValueList& getPortValueList() const
   { return getNodeContext().getPortValueList(); }
 
-
 protected:
   NodeInstance() {}
 
@@ -151,12 +150,9 @@
 //   SampleTimeSet mSampleTimeSet;
 };
 
-// typedef std::vector<SharedPtr<NodeInstance> > NodeInstanceList;
-// typedef std::vector<SharedPtr<const NodeInstance> > ConstNodeInstanceList;
+typedef std::list<SharedPtr<NodeInstance> > NodeInstanceList;
 
 
-
-
 ////////////////////////////////////////////////////////////////////////////
 
 /// This one will not show up in any execution list, but will be used
@@ -262,6 +258,8 @@
   SharedPtr<const Model> mModel;
 };
 
+typedef std::list<SharedPtr<ModelContext> > ModelContextList;
+
 class ModelInstance : public NodeInstance {
 public:
   ModelInstance(const Model* model) :
@@ -282,6 +280,7 @@
   SharedPtr<ModelContext> mModelContext;
 };
 
+typedef std::list<SharedPtr<ModelInstance> > ModelInstanceList;
 
 
 
@@ -307,6 +306,8 @@
   MechanicContext& operator=(const MechanicContext&);
 };
 
+typedef std::list<SharedPtr<MechanicContext> > MechanicContextList;
+
 class MechanicInstance : public NodeInstance {
 public:
   MechanicInstance(const MechanicNode* mechanicNode) :
@@ -323,6 +324,7 @@
   SharedPtr<MechanicContext> mMechanicContext;
 };
 
+typedef std::list<SharedPtr<MechanicInstance> > MechanicInstanceList;
 
 
 
@@ -791,19 +793,16 @@
 
   ////////////////////////////////////////////////////////////////////////////
   // The final list of Nodes we have in the simulation system
-  typedef std::list<SharedPtr<NodeInstance> > NodeInstanceList;
   NodeInstanceList _nodeInstanceList;
 
 
   // The Models list, worthwhile for sorting
-  typedef std::list<SharedPtr<ModelInstance> > ModelInstanceList;
   ModelInstanceList _modelInstanceList;
   // The mechanical system list, also for sorting
-  typedef std::list<SharedPtr<MechanicInstance> > MechanicInstanceList;
   MechanicInstanceList _mechanicInstanceList;
-  // The list of root nodes in the mechanicla system. Will be a starting point
+  // The list of root nodes in the mechanical system. Will be a starting point
   // for sorting the tree of mechanical models downwards
-  typedef std::list<SharedPtr<MechanicInstance> > RootJointInstanceList;
+  typedef MechanicInstanceList RootJointInstanceList;
   RootJointInstanceList _rootJointInstanceList;
 
   ////////////////////////////////////////////////////////////////////////////
@@ -866,8 +865,6 @@
     return true;
   }
 
-  typedef std::vector<SharedPtr<ModelInstance> > ModelContextList;
-
   bool
   allocPortData()
   {
@@ -885,17 +882,16 @@
   }
 
   bool
-  getModelContextList(ModelContextList& modelContexts)
+  getModelContextList(ModelInstanceList& modelContexts)
   {
     modelContexts.resize(0);
 
-    ModelContextList modelContextList;
-    modelContextList.reserve(_modelInstanceList.size());
+    ModelInstanceList modelContextList;
     ModelInstanceList::const_iterator i;
     for (i = _modelInstanceList.begin(); i != _modelInstanceList.end(); ++i)
       modelContextList.push_back((*i));
 
-    ModelContextList::const_iterator j;
+    ModelInstanceList::const_iterator j;
     for (j = modelContextList.begin(); j != modelContextList.end(); ++j) {
       if (!(*j)->getNodeContext().alloc()) {
         Log(Schedule, Error) << "Could not alloc for model ... FIXME" << endl;
@@ -978,7 +974,7 @@
     // Just to play :)
     nodeInstanceCollector.print();
     
-    LeafInstanceCollector::ModelContextList modelContextList;
+    ModelInstanceList modelContextList;
     nodeInstanceCollector.getModelContextList(modelContextList);
     // ...
 
@@ -1012,7 +1008,6 @@
 private:
   SharedPtr<Node> mNode;
 
-  typedef std::list<SharedPtr<NodeInstance> > NodeInstanceList;
   NodeInstanceList mNodeInstanceList;
 };
 



From frohlich at mail.berlios.de  Wed Sep 17 07:15:36 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Wed, 17 Sep 2008 07:15:36 +0200
Subject: [OpenFDM-svn] r484 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200809170515.m8H5FaJ9002563@sheep.berlios.de>

Author: frohlich
Date: 2008-09-17 07:15:33 +0200 (Wed, 17 Sep 2008)
New Revision: 484

Modified:
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Hmm, are these tasks??


Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-16 19:43:15 UTC (rev 483)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-17 05:15:33 UTC (rev 484)
@@ -193,8 +193,10 @@
   SharedPtr<NodeContext> mNodeContext;
 };
 
+class Task;
+class DiscreteTask;
+class ContinousTask;
 
-
 //// This one is used to execute the simulation system
 class ModelContext : public LeafContext {
 public:
@@ -209,9 +211,9 @@
   { return mModel->alloc(*this); }
   void init()
   { mModel->init(mDiscreteState, mContinousState); }
-  void output()
+  void output(const Task&)
   { mModel->output(mDiscreteState, mContinousState, mPortValueList); }
-  void update()
+  void update(const DiscreteTask&)
   { mModel->update(mDiscreteState, mContinousState, mPortValueList); }
 
 //   void derivative()
@@ -258,8 +260,34 @@
   SharedPtr<const Model> mModel;
 };
 
-typedef std::list<SharedPtr<ModelContext> > ModelContextList;
+class ModelContextList : public std::list<SharedPtr<ModelContext> > {
+public:
+  typedef std::list<SharedPtr<ModelContext> > list_type;
 
+  bool alloc() const
+  {
+    for (list_type::const_iterator i = begin(); i != end(); ++i)
+      if (!(*i)->alloc())
+        return false;
+    return true;
+  }
+  void init() const
+  {
+    for (list_type::const_iterator i = begin(); i != end(); ++i)
+      (*i)->init();
+  }
+  void output(const Task& task) const
+  {
+    for (list_type::const_iterator i = begin(); i != end(); ++i)
+      (*i)->output(task);
+  }
+  void update(const DiscreteTask& task) const
+  {
+    for (list_type::const_iterator i = begin(); i != end(); ++i)
+      (*i)->update(task);
+  }
+};
+
 class ModelInstance : public NodeInstance {
 public:
   ModelInstance(const Model* model) :
@@ -298,6 +326,26 @@
   void init()
   { mMechanicNode->init(mDiscreteState, mContinousState); }
 
+  void velocities(const ContinousTask&)
+  { mMechanicNode->velocity(mContinousState, mPortValueList); }
+  void articulation(const ContinousTask&)
+  { mMechanicNode->articulation(mContinousState, mPortValueList); }
+  void accelerations(const ContinousTask&)
+  { }
+
+
+//   virtual void derivative(const ContinousStateValueVector&,
+//                           const PortValueList&,
+//                           ContinousStateValueVector&) const
+ 
+//   void outputVelocities()
+//   { }
+//   void outputAcceperation()
+//   { }
+
+//   void update()
+//   { }
+
   SharedPtr<const MechanicNode> mMechanicNode;
 
 private:
@@ -306,8 +354,40 @@
   MechanicContext& operator=(const MechanicContext&);
 };
 
-typedef std::list<SharedPtr<MechanicContext> > MechanicContextList;
+class MechanicContextList : public std::list<SharedPtr<MechanicContext> > {
+public:
+  typedef std::list<SharedPtr<MechanicContext> > list_type;
 
+  bool alloc() const
+  {
+    for (list_type::const_iterator i = begin(); i != end(); ++i)
+      if (!(*i)->alloc())
+        return false;
+    return true;
+  }
+  void init() const
+  {
+    for (list_type::const_iterator i = begin(); i != end(); ++i)
+      (*i)->init();
+  }
+  void velocities(const ContinousTask& task) const
+  {
+    for (list_type::const_iterator i = begin(); i != end(); ++i)
+      (*i)->velocities(task);
+  }
+  void articulation(const ContinousTask& task) const
+  {
+    // Note that this list is traversed from the mechanic leafs to the root
+    for (list_type::const_reverse_iterator i = rbegin(); i != rend(); ++i)
+      (*i)->articulation(task);
+  }
+  void accelerations(const ContinousTask& task) const
+  {
+    for (list_type::const_iterator i = begin(); i != end(); ++i)
+      (*i)->accelerations(task);
+  }
+};
+
 class MechanicInstance : public NodeInstance {
 public:
   MechanicInstance(const MechanicNode* mechanicNode) :
@@ -902,7 +982,7 @@
     // FIXME is here just for curiousity :)
     for (j = modelContextList.begin(); j != modelContextList.end(); ++j) {
       (*j)->getNodeContext().init();
-      (*j)->getNodeContext().output();
+      (*j)->getNodeContext().output(*reinterpret_cast<Task*>(0));
     }
 
     modelContexts.swap(modelContextList);
@@ -937,6 +1017,84 @@
   NodeIdStack _nodeIdStack;
 };
 
+
+
+
+class Task : public Referenced {
+public:
+
+  void setTime(const real_type& time)
+  { mTime = time; }
+  const real_type& getTime() const
+  { return mTime; }
+
+private:
+  real_type mTime;
+};
+
+class ContinousTask : public Task {
+public:
+
+  void output() const
+  {
+    // The model outputs before mechanical state propagation
+    mModelContextList[0].output(*this);
+    // Now the mechanical state propagation
+    mMechanicContextList.velocities(*this);
+    // The model outputs before mechanical force propagation
+    mModelContextList[1].output(*this);
+    // Now the mechanical force propagation
+    mMechanicContextList.articulation(*this);
+    // The model outputs before mechanical acceleration propagation
+    mModelContextList[2].output(*this);
+    // Now the mechanical acceleration propagation
+    mMechanicContextList.accelerations(*this);
+    // The model outputs past mechanical acceleration propagation
+    mModelContextList[3].output(*this);
+  }
+
+  void derivative() const
+  {
+    // FIXME
+//     for (unsigned i = 0; i < 4; ++i)
+//       mModelContextList[2].derivative(*this);
+//     mMechanicContextList.derivative(*this);
+  }
+
+  ModelContextList mModelContextList[4];
+  MechanicContextList mMechanicContextList;
+};
+
+class DiscreteTask : public Task {
+public:
+  DiscreteTask(const real_type& stepsize) : mStepsize(stepsize)
+  { }
+
+  const real_type& getStepsize() const
+  { return mStepsize; }
+
+  void update()
+  {
+    mModelContextList.update(*this);
+    // FIXME
+//     mMechanicContextList.update(*this);
+  }
+
+  ModelContextList mModelContextList;
+  MechanicContextList mMechanicContextList;
+
+private:
+  real_type mStepsize;
+};
+
+typedef std::list<SharedPtr<DiscreteTask> > DiscreteTaskList;
+
+class TaskScheduler {
+public:
+  DiscreteTaskList mDiscreteTaskList;
+  SharedPtr<ContinousTask> mContinousTask;
+};
+
 class System : public Object {
 public:
   System(const std::string& name, Node* node = 0) :



From frohlich at mail.berlios.de  Thu Sep 18 06:53:30 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Thu, 18 Sep 2008 06:53:30 +0200
Subject: [OpenFDM-svn] r485 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200809180453.m8I4rUKU027165@sheep.berlios.de>

Author: frohlich
Date: 2008-09-18 06:53:28 +0200 (Thu, 18 Sep 2008)
New Revision: 485

Modified:
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Remove the intermediate LeafPortData class...


Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-17 05:15:33 UTC (rev 484)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-18 04:53:28 UTC (rev 485)
@@ -415,15 +415,15 @@
 
   class PortDataList;
 
-  struct LeafPortData;
   struct AcceptorPortData;
   struct ProviderPortData;
   struct ProxyPortData;
 
   class PortData : public WeakReferenced {
   public:
-    PortData(PortDataList* portDataList) :
-      mParentPortDataList(portDataList)
+    PortData(PortDataList* portDataList, const PortInfo* portInfo = 0) :
+      mParentPortDataList(portDataList),
+      mPortInfo(portInfo)
     { }
     virtual ~PortData()
     { }
@@ -453,16 +453,7 @@
     }
 
     WeakPtr<PortDataList> mParentPortDataList;
-  };
 
-  class LeafPortData : public PortData {
-  public:
-    LeafPortData(PortDataList* portDataList, const PortInfo* portInfo) :
-      PortData(portDataList),
-      mPortInfo(portInfo)
-    { }
-    virtual ~LeafPortData() {}
-
     const SharedPtr<const PortInfo>& getPortInfo() const
     { return mPortInfo; }
 
@@ -470,10 +461,10 @@
     SharedPtr<const PortInfo> mPortInfo;
   };
 
-  struct ProviderPortData : public LeafPortData {
+  struct ProviderPortData : public PortData {
     ProviderPortData(PortDataList* portDataList,
                      const ProviderPortInfo* providerPort) :
-      LeafPortData(portDataList, providerPort),
+      PortData(portDataList, providerPort),
       _providerPort(providerPort)
     { }
     virtual ProviderPortData* toProviderPortData()
@@ -512,10 +503,10 @@
     SharedPtr<const ProviderPortInfo> _providerPort;
     std::vector<WeakPtr<AcceptorPortData> > _acceptorPortDataList;
   };
-  struct AcceptorPortData : public LeafPortData {
+  struct AcceptorPortData : public PortData {
     AcceptorPortData(PortDataList* portDataList,
                      const AcceptorPortInfo* acceptorPort) :
-      LeafPortData(portDataList, acceptorPort),
+      PortData(portDataList, acceptorPort),
       _acceptorPort(acceptorPort)
     { }
     virtual AcceptorPortData* toAcceptorPortData()
@@ -727,7 +718,7 @@
     PortDataHelper::ProviderPortData* providerPortData;
 //     providerPortData = portDataList->newProviderPortData(leaf._groupInternalPort);
     providerPortData = portDataList->newProviderPortData(0 /*FIXME*/);
-    _leafPortDataMap[getCurrentNodeId()][portId] = providerPortData;
+    _portDataMap[getCurrentNodeId()][portId] = providerPortData;
   }
   // Aussen provider, innen acceptor
   virtual void apply(const GroupProviderNode& leaf)
@@ -740,7 +731,7 @@
     PortDataHelper::AcceptorPortData* acceptorPortData;
 //     acceptorPortData = portDataList->newAcceptorPortData(leaf._groupInternalPort);
     acceptorPortData = portDataList->newAcceptorPortData(0 /*FIXME*/);
-    _leafPortDataMap[getCurrentNodeId()][portId] = acceptorPortData;
+    _portDataMap[getCurrentNodeId()][portId] = acceptorPortData;
   }
 
   void allocPortData(NodeInstance* leafInstance, const LeafNode& leaf)
@@ -757,7 +748,7 @@
         providerPortData = portDataList->newProviderPortData(providerPort);
 
         PortId portId = leaf.getPortId(i);
-        _leafPortDataMap[getCurrentNodeId()][portId] = providerPortData;
+        _portDataMap[getCurrentNodeId()][portId] = providerPortData;
       }
       const AcceptorPortInfo* acceptorPort = port->toAcceptorPortInfo();
       if (acceptorPort) {
@@ -765,7 +756,7 @@
         acceptorPortData = portDataList->newAcceptorPortData(acceptorPort);
 
         PortId portId = leaf.getPortId(i);
-        _leafPortDataMap[getCurrentNodeId()][portId] = acceptorPortData;
+        _portDataMap[getCurrentNodeId()][portId] = acceptorPortData;
       }
     }
   }
@@ -798,8 +789,8 @@
   virtual void apply(const Group& group)
   {
     // Prepare a new leaf map for the child group
-    LeafPortDataMap parentLeafPortDataMap;
-    parentLeafPortDataMap.swap(_leafPortDataMap);
+    PortDataMap parentPortDataMap;
+    parentPortDataMap.swap(_portDataMap);
 
     // Walk the children
 #if 0
@@ -845,8 +836,8 @@
         continue;
       }
 
-      if (!_leafPortDataMap[acceptorNodeId][acceptorPortId]->
-          connect(_leafPortDataMap[providerNodeId][providerPortId]))
+      if (!_portDataMap[acceptorNodeId][acceptorPortId]->
+          connect(_portDataMap[providerNodeId][providerPortId]))
         std::cerr << "Cannot connect????" << std::endl;
     }
 
@@ -857,18 +848,18 @@
     for (unsigned i = 0; i < group.getNumPorts(); ++i) {
       PortId portId = group.getPortId(i);
       Group::NodeId nodeId = group.getGroupPortNode(portId);
-      if (_leafPortDataMap[nodeId].empty()) {
+      if (_portDataMap[nodeId].empty()) {
         // FIXME, is this an internal error ???
         std::cerr << "Hmm, cannot find GroupPortNode for external port "
                   << i << std::endl;
         continue;
       }
 
-      parentLeafPortDataMap[getCurrentNodeId()][portId] = 
-          portDataList->newProxyPortData(_leafPortDataMap[nodeId].begin()->second);
+      parentPortDataMap[getCurrentNodeId()][portId] = 
+          portDataList->newProxyPortData(_portDataMap[nodeId].begin()->second);
     }
 
-    parentLeafPortDataMap.swap(_leafPortDataMap);
+    parentPortDataMap.swap(_portDataMap);
   }
 
   ////////////////////////////////////////////////////////////////////////////
@@ -888,8 +879,8 @@
   ////////////////////////////////////////////////////////////////////////////
   // Used to map connections in groups ...
   typedef std::map<PortId, SharedPtr<PortDataHelper::PortData> > NodePortDataMap;
-  typedef std::map<Group::NodeId, NodePortDataMap> LeafPortDataMap;
-  LeafPortDataMap _leafPortDataMap;
+  typedef std::map<Group::NodeId, NodePortDataMap> PortDataMap;
+  PortDataMap _portDataMap;
   // Just to hold references to all mort data lists we have in the
   // simulation system. They are just needed during traversal for connect
   // information and to distribute port value pointers.
@@ -1057,7 +1048,7 @@
   {
     // FIXME
 //     for (unsigned i = 0; i < 4; ++i)
-//       mModelContextList[2].derivative(*this);
+//       mModelContextList[i].derivative(*this);
 //     mMechanicContextList.derivative(*this);
   }
 
@@ -1163,6 +1154,10 @@
 //   const real_type& getTime(void) const
 //   { return mTime; }
 
+
+  const NodeInstanceList& getNodeInstanceList() const
+  { return mNodeInstanceList; }
+
 private:
   SharedPtr<Node> mNode;
 



From frohlich at mail.berlios.de  Thu Sep 18 21:49:52 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Thu, 18 Sep 2008 21:49:52 +0200
Subject: [OpenFDM-svn] r486 - in branches/OpenFDM-StateSeparation/src:
	OpenFDM test
Message-ID: <200809181949.m8IJnqVA031474@sheep.berlios.de>

Author: frohlich
Date: 2008-09-18 21:49:52 +0200 (Thu, 18 Sep 2008)
New Revision: 486

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/PortValueList.h
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Also set portvalues in group inputs and outputs.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/PortValueList.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/PortValueList.h	2008-09-18 04:53:28 UTC (rev 485)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/PortValueList.h	2008-09-18 19:49:52 UTC (rev 486)
@@ -78,7 +78,7 @@
   }
   void setPortSize(const MatrixOutputPort& port, const Size& size)
   {
-    setPortValue(port.getPortIndex(), new NumericPortValue(size));
+    port.getPortValue(mPortValueVector)->getValue().resize(size);
   }
   const PortValue* getPortValue(unsigned idx) const
   {

Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-18 04:53:28 UTC (rev 485)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-18 19:49:52 UTC (rev 486)
@@ -333,7 +333,6 @@
   void accelerations(const ContinousTask&)
   { }
 
-
 //   virtual void derivative(const ContinousStateValueVector&,
 //                           const PortValueList&,
 //                           ContinousStateValueVector&) const
@@ -417,9 +416,10 @@
 
   struct AcceptorPortData;
   struct ProviderPortData;
-  struct ProxyPortData;
+  struct ProxyAcceptorPortData;
+  struct ProxyProviderPortData;
 
-  class PortData : public WeakReferenced {
+  struct PortData : public WeakReferenced {
   public:
     PortData(PortDataList* portDataList, const PortInfo* portInfo = 0) :
       mParentPortDataList(portDataList),
@@ -427,37 +427,42 @@
     { }
     virtual ~PortData()
     { }
-    virtual ProxyPortData* toProxyPortData()
-    { return 0; }
     virtual AcceptorPortData* toAcceptorPortData()
     { return 0; }
     virtual ProviderPortData* toProviderPortData()
     { return 0; }
+    virtual ProxyAcceptorPortData* toProxyAcceptorPortData()
+    { return 0; }
+    virtual ProxyProviderPortData* toProxyProviderPortData()
+    { return 0; }
     virtual bool connect(PortData*) = 0;
 
-    virtual void print()
-    { }
-
     SharedPtr<PortDataList> getParentPortDataList() const
     { return mParentPortDataList.lock(); }
-
-    std::string getNodeName() const
+    SharedPtr<NodeInstance> getNodeInstance() const
     {
       SharedPtr<PortDataList> portDataList = getParentPortDataList();
       if (!portDataList)
-        return std::string();
-      SharedPtr<NodeInstance> nodeInstance = portDataList->mNodeInstance;
-      if (!nodeInstance)
-        return std::string();
-      return nodeInstance->getPathString();
+        return 0;
+      return portDataList->mNodeInstance;
     }
 
-    WeakPtr<PortDataList> mParentPortDataList;
-
     const SharedPtr<const PortInfo>& getPortInfo() const
     { return mPortInfo; }
 
+    void setLocalPortValue(PortValue* portValue)
+    {
+      if (!getPortInfo())
+        return;
+      SharedPtr<NodeInstance> nodeInstance = getNodeInstance();
+      if (!nodeInstance)
+        return;
+      unsigned index = getPortInfo()->getIndex();
+      nodeInstance->getPortValueList().setPortValue(index, portValue);
+    }
+
   private:
+    WeakPtr<PortDataList> mParentPortDataList;
     SharedPtr<const PortInfo> mPortInfo;
   };
 
@@ -474,34 +479,29 @@
     {
       if (!portData)
         return false;
-      ProxyPortData* proxyPortData = portData->toProxyPortData();
-      if (proxyPortData)
-        return proxyPortData->connect(this);
       AcceptorPortData* acceptorPortData = portData->toAcceptorPortData();
       if (!acceptorPortData)
         return false;
       return acceptorPortData->connectToProvider(this);
     }
 
-    virtual void print()
+    virtual void createPortValue()
     {
-      std::cout << "  Provider Port \"" << getPortInfo()->getName()
-                << "\" connected to:" << std::endl;
-      for (unsigned i = 0; i < _acceptorPortDataList.size(); ++i) {
-        SharedPtr<AcceptorPortData> acceptorPortData;
-        acceptorPortData = _acceptorPortDataList[i].lock();
-        if (!acceptorPortData)
-          continue;
-        if (!acceptorPortData->getPortInfo())
-          continue;
-        std::cout << "    Node \"" << acceptorPortData->getNodeName()
-                  << "\" Port \"" << acceptorPortData->getPortInfo()->getName()
-                  << "\"" << std::endl;
-      }
+      PortValue* portValue = _providerPort->newValue();
+      if (!portValue)
+        return;
+      setPortValue(portValue);
     }
 
+    void setPortValue(PortValue* portValue)
+    {
+      setLocalPortValue(portValue);
+      for (unsigned i = 0; i < _acceptorPortDataList.size(); ++i)
+        _acceptorPortDataList[i]->setPortValue(portValue);
+    }
+
     SharedPtr<const ProviderPortInfo> _providerPort;
-    std::vector<WeakPtr<AcceptorPortData> > _acceptorPortDataList;
+    std::vector<SharedPtr<AcceptorPortData> > _acceptorPortDataList;
   };
   struct AcceptorPortData : public PortData {
     AcceptorPortData(PortDataList* portDataList,
@@ -516,9 +516,6 @@
     {
       if (!portData)
         return false;
-      ProxyPortData* proxyPortData = portData->toProxyPortData();
-      if (proxyPortData)
-        return proxyPortData->connect(this);
       ProviderPortData* providerPortData = portData->toProviderPortData();
       if (!providerPortData)
         return false;
@@ -536,64 +533,46 @@
       return true;
     }
 
-    virtual void print()
+    virtual void setPortValue(PortValue* portValue)
     {
-      std::cout << "  Acceptor Port \"" << getPortInfo()->getName()
-                << "\" connected from:" << std::endl;
-
-      SharedPtr<ProviderPortData> providerPortData;
-      providerPortData = _providerPortData.lock();
-      if (!providerPortData)
-        return;
-      if (!providerPortData->getPortInfo())
-        return;
-       std::cout << "    Node \"" << providerPortData->getNodeName()
-                << "\" Port \"" << providerPortData->getPortInfo()->getName()
-                << "\"" << std::endl;
+      setLocalPortValue(portValue);
     }
 
     SharedPtr<const AcceptorPortInfo> _acceptorPort;
     WeakPtr<ProviderPortData> _providerPortData;
   };
-
-  // Hmm, an other idea. How about treating the group input/output block
-  // as a regular block with inputs and outputs?
-  // Then in the output routine do nothing and just connect the PortValues of
-  // the inputs directly to the PortValues of the outputs??
-  // That would at least make the Proxy stuff simpler??
-
-  class ProxyPortData : public PortData {
+  struct ProxyAcceptorPortData : public AcceptorPortData {
   public:
-    ProxyPortData(PortDataList* portDataList, PortData* portData) :
-      PortData(portDataList)
-    {
-      if (!portData)
-        return;
-      AcceptorPortData* acceptorPortData = portData->toAcceptorPortData();
-      if (acceptorPortData) {
-        mPortDataList.push_back(acceptorPortData->_providerPortData.lock());
-      }
-      ProviderPortData* providerPortData = portData->toProviderPortData();
-      if (providerPortData) {
-        unsigned i;
-        for (i = 0; i < providerPortData->_acceptorPortDataList.size(); ++i) {
-          mPortDataList.push_back(providerPortData->_acceptorPortDataList[i].lock());
-        }
-      }
-    }
-    virtual ProxyPortData* toProxyPortData()
+    ProxyAcceptorPortData(PortDataList* portDataList,
+                          const AcceptorPortInfo* acceptorPortInfo) :
+      AcceptorPortData(portDataList, acceptorPortInfo)
+    { }
+    virtual ProxyAcceptorPortData* toProxyAcceptorPortData()
     { return this; }
-    virtual bool connect(PortData* portData)
+    virtual void setPortValue(PortValue* portValue)
     {
-      for (unsigned i = 0; i < mPortDataList.size(); ++i) {
-        if (!mPortDataList[i]->connect(portData))
-          return false;
-      }
-      return true;
+      setLocalPortValue(portValue);
+      mProxyProviderPortData->setPortValue(portValue);
     }
-    std::vector<SharedPtr<PortData> > mPortDataList;
+    SharedPtr<ProxyProviderPortData> mProxyProviderPortData;
   };
+  struct ProxyProviderPortData : public ProviderPortData {
+  public:
+    ProxyProviderPortData(PortDataList* portDataList,
+                          const ProviderPortInfo* providerPortInfo) :
+      ProviderPortData(portDataList, providerPortInfo)
+    { }
+    virtual ProxyProviderPortData* toProxyProviderPortData()
+    { return this; }
+    void setProxyAcceptorPortData(ProxyAcceptorPortData* proxyAcceptorPortData)
+    { proxyAcceptorPortData->mProxyProviderPortData = this; }
 
+    // FIXME
+    virtual void createPortValue()
+    { }
+  };
+
+
   // Return true if this leaf directly depends on one of leafInstance outputs
   class PortDataList : public WeakReferenced {
   public:
@@ -615,65 +594,34 @@
       mPortDataVector.push_back(providerPortData);
       return providerPortData;
     }
-    ProxyPortData* newProxyPortData(PortData* portData)
+    ProxyAcceptorPortData* newProxyAcceptorPortData(const AcceptorPortInfo* acceptorPort)
     {
-      ProxyPortData* proxyPortData;
-      proxyPortData = new ProxyPortData(this, portData);
-      mPortDataVector.push_back(proxyPortData);
-      return proxyPortData;
+      ProxyAcceptorPortData* acceptorPortData;
+      acceptorPortData = new ProxyAcceptorPortData(this, acceptorPort);
+      mPortDataVector.push_back(acceptorPortData);
+      return acceptorPortData;
     }
-    
-    const Node& getNode() const
-    { return mNodeInstance->getNode(); }
-
-    void print()
+    ProxyProviderPortData* newProxyProviderPortData(const ProviderPortInfo* providerPort)
     {
-      for (unsigned i = 0; i < mPortDataVector.size(); ++i) {
-        mPortDataVector[i]->print();
-      }
+      ProxyProviderPortData* providerPortData;
+      providerPortData = new ProxyProviderPortData(this, providerPort);
+      mPortDataVector.push_back(providerPortData);
+      return providerPortData;
     }
     
     bool allocAndConnectProviderPortValues()
     {
       // FIXME: move that into the PortData stuff
-      for (unsigned i = 0; i < getNode().getNumPorts(); ++i) {
-        const ProviderPortInfo* providerPortInfo;
-        providerPortInfo = getNode().getPort(i)->toProviderPortInfo();
-        if (!providerPortInfo)
-          continue;
-        
-        PortValue* portValue = providerPortInfo->newValue();
-        if (!portValue)
-          continue;
-        setPortValue(i, portValue);
-        
+      for (unsigned i = 0; i < mPortDataVector.size(); ++i) {
         // Also set the port value to all connected ports
-        ProviderPortData* providerPortData = mPortDataVector[i]->toProviderPortData();
-        OpenFDMAssert(providerPortData);
-        
-        for (unsigned j = 0; j < providerPortData->_acceptorPortDataList.size(); ++j) {
-          SharedPtr<AcceptorPortData> acceptorPortData;
-          acceptorPortData = providerPortData->_acceptorPortDataList[j].lock();
-          // Ok, happens for proxy ports, these still show up here
-          if (!acceptorPortData)
-            continue;
-          
-          SharedPtr<PortDataList> portDataList;
-          portDataList = acceptorPortData->getParentPortDataList();
-          OpenFDMAssert(portDataList);
-          
-          // FIXME, for now the GenericNodePorts do not have PortValues for
-          // this reason.
-          if (!acceptorPortData->getPortInfo())
-            continue;
-          unsigned index = acceptorPortData->getPortInfo()->getIndex();
-          portDataList->setPortValue(index, portValue);
-        }
+        ProviderPortData* providerPortData;
+        providerPortData = mPortDataVector[i]->toProviderPortData();
+        if (!providerPortData)
+          continue;
+        providerPortData->createPortValue();
       }
       return true;
     }
-    void setPortValue(unsigned i, PortValue* portValue)
-    { mNodeInstance->getPortValueList().setPortValue(i, portValue); }
 
     /// The vector of per port connect information
     typedef std::vector<SharedPtr<PortData> > PortDataVector;
@@ -716,8 +664,7 @@
     PortId portId = leaf.getPortId(0);
 
     PortDataHelper::ProviderPortData* providerPortData;
-//     providerPortData = portDataList->newProviderPortData(leaf._groupInternalPort);
-    providerPortData = portDataList->newProviderPortData(0 /*FIXME*/);
+    providerPortData = portDataList->newProxyProviderPortData(leaf._groupInternalPort);
     _portDataMap[getCurrentNodeId()][portId] = providerPortData;
   }
   // Aussen provider, innen acceptor
@@ -729,8 +676,7 @@
     PortId portId = leaf.getPortId(0);
 
     PortDataHelper::AcceptorPortData* acceptorPortData;
-//     acceptorPortData = portDataList->newAcceptorPortData(leaf._groupInternalPort);
-    acceptorPortData = portDataList->newAcceptorPortData(0 /*FIXME*/);
+    acceptorPortData = portDataList->newProxyAcceptorPortData(leaf._groupInternalPort);
     _portDataMap[getCurrentNodeId()][portId] = acceptorPortData;
   }
 
@@ -855,8 +801,42 @@
         continue;
       }
 
-      parentPortDataMap[getCurrentNodeId()][portId] = 
-          portDataList->newProxyPortData(_portDataMap[nodeId].begin()->second);
+      PortDataHelper::PortData* portData = _portDataMap[nodeId].begin()->second;
+      if (portData->toProxyAcceptorPortData()) {
+        PortDataHelper::ProxyAcceptorPortData* proxyAcceptorPortData;
+        proxyAcceptorPortData = portData->toProxyAcceptorPortData();
+
+        const ProviderPortInfo* providerPortInfo;
+        providerPortInfo = group.getPort(i)->toProviderPortInfo();
+        OpenFDMAssert(providerPortInfo);
+
+        PortDataHelper::ProxyProviderPortData* proxyProviderPortData;
+        proxyProviderPortData =
+          portDataList->newProxyProviderPortData(providerPortInfo);
+
+        proxyProviderPortData->setProxyAcceptorPortData(proxyAcceptorPortData);
+
+        parentPortDataMap[getCurrentNodeId()][portId] = proxyProviderPortData;
+
+      } else if (portData->toProxyProviderPortData()) {
+        PortDataHelper::ProxyProviderPortData* proxyProviderPortData;
+        proxyProviderPortData = portData->toProxyProviderPortData();
+
+        const AcceptorPortInfo* acceptorPortInfo;
+        acceptorPortInfo = group.getPort(i)->toAcceptorPortInfo();
+        OpenFDMAssert(acceptorPortInfo);
+
+        PortDataHelper::ProxyAcceptorPortData* proxyAcceptorPortData;
+        proxyAcceptorPortData =
+          portDataList->newProxyAcceptorPortData(acceptorPortInfo);
+
+        proxyProviderPortData->setProxyAcceptorPortData(proxyAcceptorPortData);
+
+        parentPortDataMap[getCurrentNodeId()][portId] = proxyAcceptorPortData;
+
+      } else {
+        OpenFDMAssert(false);
+      }
     }
 
     parentPortDataMap.swap(_portDataMap);
@@ -980,18 +960,6 @@
     return true;
   }
 
-  void print()
-  {
-    ModelInstanceList::iterator i;
-    for (i = _modelInstanceList.begin(); i != _modelInstanceList.end(); ++i) {
-      std::cout << "Model \"" << (*i)->getPathString() << "\"" << std::endl;
-      PortDataHelper::PortDataList* portDataList = _portDataListMap[*i];
-      if (!portDataList)
-        continue;
-      portDataList->print();
-    }
-  }
-
   void pushNodeId(const Group::NodeId& nodeId)
   { _nodeIdStack.push_back(nodeId); }
   void popNodeId()
@@ -1120,9 +1088,6 @@
     if (!nodeInstanceCollector.sortModelList())
       return false;
 
-    // Just to play :)
-    nodeInstanceCollector.print();
-    
     ModelInstanceList modelContextList;
     nodeInstanceCollector.getModelContextList(modelContextList);
     // ...
@@ -1212,6 +1177,21 @@
   if (!system->init())
     return 1;
 
+  NodeInstanceList::const_iterator i;
+  for (i = system->getNodeInstanceList().begin();
+       i != system->getNodeInstanceList().end(); ++i) {
+    std::cout << (*i)->getNode().getName() << std::endl;
+    for (unsigned k = 0; k < (*i)->getNode().getNumPorts(); ++k) {
+      std::cout << "  " << (*i)->getNode().getPort(k)->getName() << " "
+                << (*i)->getPortValueList().getPortValue(k);
+      const NumericPortValue* npv =
+        dynamic_cast<const NumericPortValue*>((*i)->getPortValueList().getPortValue(k));
+      if (npv)
+        std::cout << " " << npv->getValue();
+      std::cout << std::endl;
+    }
+  }
+
   return 0;
 }
 



From frohlich at mail.berlios.de  Fri Sep 19 06:58:08 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Fri, 19 Sep 2008 06:58:08 +0200
Subject: [OpenFDM-svn] r487 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200809190458.m8J4w8RZ022135@sheep.berlios.de>

Author: frohlich
Date: 2008-09-19 06:58:06 +0200 (Fri, 19 Sep 2008)
New Revision: 487

Modified:
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Add a NodePath definition, use it.


Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-18 19:49:52 UTC (rev 486)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-19 04:58:06 UTC (rev 487)
@@ -103,26 +103,25 @@
 /// there must be a PortData like structure that is only built during simulation
 /// model initialization.
 
+typedef std::vector<SharedPtr<const Node> > NodePath;
+
 /// A NodeInstance represents an effective model node in a ready to run
 /// System. You can access the Nodes Ports values for example.
 /// This class is meant to show up in the user interface of this simulation.
 class NodeInstance : public WeakReferenced {
 public:
-  virtual ~NodeInstance() {}
+  NodeInstance(const NodePath& nodePath) :
+    mNodePath(nodePath)
+  { }
+  virtual ~NodeInstance()
+  { }
 
   /// The actual Node this NodeInstance stems from
   const Node& getNode() const
   { return getNodeContext().getNode(); }
 
-  /// FIXME: is te wrong value, but sufficient for now to debug ...
-  const std::string& getPathString() const
-  { return getNodeContext().getNode().getName(); }
+  const NodePath& getNodePath() const { return mNodePath; }
 
-  /// FIXME: put this to some global place
-//   typedef std::vector<SharedPtr<const Node> > NodePath;
-//   const NodePath& getNodePath() const { return mNodePath; }
-//   NodePath mNodePath;
-
 //   /// Set the sample times this node will run on
 //   void setSampleTimeSet(const SampleTimeSet& sampleTimeSet)
 //   { mSampleTimeSet = sampleTimeSet; }
@@ -135,6 +134,21 @@
   const PortValueList& getPortValueList() const
   { return getNodeContext().getPortValueList(); }
 
+  std::string getNodeNamePath() const
+  {
+    if (mNodePath.empty())
+      return std::string();
+    std::string path = mNodePath.front()->getName();
+    NodePath::const_iterator i = mNodePath.begin();
+    if (i != mNodePath.end()) {
+      for (++i; i != mNodePath.end(); ++i) {
+        path += '/';
+        path += (*i)->getName();
+      }
+    }
+    return path;
+  }
+
 protected:
   NodeInstance() {}
 
@@ -148,6 +162,8 @@
 
 //   /// The sample times this node will run on
 //   SampleTimeSet mSampleTimeSet;
+
+  NodePath mNodePath;
 };
 
 typedef std::list<SharedPtr<NodeInstance> > NodeInstanceList;
@@ -178,8 +194,9 @@
 
 class GenericNodeInstance : public NodeInstance {
 public:
-  GenericNodeInstance(NodeContext* nodeContext) :
-    mNodeContext(nodeContext)
+  GenericNodeInstance(const NodePath& nodePath, const Node* node) :
+    NodeInstance(nodePath),
+    mNodeContext(new GenericNodeContext(node))
   { }
 
 protected:
@@ -290,7 +307,8 @@
 
 class ModelInstance : public NodeInstance {
 public:
-  ModelInstance(const Model* model) :
+  ModelInstance(const NodePath& nodePath, const Model* model) :
+    NodeInstance(nodePath),
     mModelContext(new ModelContext(model))
   { }
 
@@ -389,7 +407,9 @@
 
 class MechanicInstance : public NodeInstance {
 public:
-  MechanicInstance(const MechanicNode* mechanicNode) :
+  MechanicInstance(const NodePath& nodePath,
+                   const MechanicNode* mechanicNode) :
+    NodeInstance(nodePath),
     mMechanicContext(new MechanicContext(mechanicNode))
   { }
 
@@ -645,9 +665,8 @@
 
   PortDataHelper::PortDataList* buildGenericNodeContext(const Node& node)
   {
-    GenericNodeContext* genericNodeContext = new GenericNodeContext(&node);
     GenericNodeInstance* genericNodeInstance;
-    genericNodeInstance = new GenericNodeInstance(genericNodeContext);
+    genericNodeInstance = new GenericNodeInstance(mNodePath, &node);
     _nodeInstanceList.push_back(genericNodeInstance);
     PortDataHelper::PortDataList* portDataList = new PortDataHelper::PortDataList(genericNodeInstance);
     _portDataListMap[_nodeInstanceList.back()] = portDataList;
@@ -711,7 +730,7 @@
   {
     // Need to stor the root nodes to build up the spanning tree for the
     // mechanical system here.
-    MechanicInstance* mechanicInstance = new MechanicInstance(&node);
+    MechanicInstance* mechanicInstance = new MechanicInstance(mNodePath, &node);
     _nodeInstanceList.push_back(mechanicInstance);
 //     _mechanicInstanceList.push_back(mechanicInstance);
     _rootJointInstanceList.push_back(mechanicInstance);
@@ -719,14 +738,14 @@
   }
   virtual void apply(const MechanicNode& node)
   {
-    MechanicInstance* mechanicInstance = new MechanicInstance(&node);
+    MechanicInstance* mechanicInstance = new MechanicInstance(mNodePath, &node);
     _nodeInstanceList.push_back(mechanicInstance);
     _mechanicInstanceList.push_back(mechanicInstance);
     allocPortData(mechanicInstance, node);
   }
   virtual void apply(const Model& node)
   {
-    ModelInstance* modelInstance = new ModelInstance(&node);
+    ModelInstance* modelInstance = new ModelInstance(mNodePath, &node);
     _nodeInstanceList.push_back(modelInstance);
     _modelInstanceList.push_back(modelInstance);
     allocPortData(modelInstance, node);
@@ -744,7 +763,9 @@
 #else
     for (unsigned i = 0; i < group.getNumChildren(); ++i) {
       pushNodeId(group.getNodeId(i));
+      mNodePath.push_back(group.getChild(i));
       group.getChild(i)->accept(*this);
+      mNodePath.pop_back();
       popNodeId();
     }
 #endif
@@ -885,8 +906,9 @@
         // Something already sorted in depends on modelInstance,
         // so schedule that new thing just before.
         Log(Schedule, Info)
-          << "Inserting Model \"" << modelInstance->getPathString()
-          << "\" before Model \"" << (*i)->getPathString() << "\"" << std::endl;
+          << "Inserting Model \"" << modelInstance->getNodeNamePath()
+          << "\" before Model \"" << (*i)->getNodeNamePath()
+          << "\"" << std::endl;
         i = sortedModelInstanceList.insert(i, modelInstance);
         break;
       }
@@ -894,7 +916,7 @@
         // nothing found so far that depends on model instance.
         // So put it at the end.
         Log(Schedule, Info)
-          << "Appending Model \"" << modelInstance->getPathString()
+          << "Appending Model \"" << modelInstance->getNodeNamePath()
           << "\"" << std::endl;
 
         sortedModelInstanceList.push_back(modelInstance);
@@ -906,8 +928,8 @@
             continue;
           Log(Schedule,Error)
             << "Detected cyclic loop: Model \""
-            << modelInstance->getPathString() << "\" depends on Model \""
-            << (*i)->getPathString() << "\"" << std::endl;
+            << modelInstance->getNodeNamePath() << "\" depends on Model \""
+            << (*i)->getNodeNamePath() << "\"" << std::endl;
           return false;
         }
       }
@@ -974,6 +996,8 @@
 private:
   typedef std::list<Group::NodeId> NodeIdStack;
   NodeIdStack _nodeIdStack;
+
+  NodePath mNodePath;
 };
 
 
@@ -1180,7 +1204,7 @@
   NodeInstanceList::const_iterator i;
   for (i = system->getNodeInstanceList().begin();
        i != system->getNodeInstanceList().end(); ++i) {
-    std::cout << (*i)->getNode().getName() << std::endl;
+    std::cout << (*i)->getNodeNamePath() << std::endl;
     for (unsigned k = 0; k < (*i)->getNode().getNumPorts(); ++k) {
       std::cout << "  " << (*i)->getNode().getPort(k)->getName() << " "
                 << (*i)->getPortValueList().getPortValue(k);



From frohlich at mail.berlios.de  Sun Sep 21 13:20:39 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 21 Sep 2008 13:20:39 +0200
Subject: [OpenFDM-svn] r488 - in branches/OpenFDM-StateSeparation/src:
	OpenFDM test
Message-ID: <200809211120.m8LBKdUN030774@sheep.berlios.de>

Author: frohlich
Date: 2008-09-21 13:20:38 +0200 (Sun, 21 Sep 2008)
New Revision: 488

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Group.h
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Work with indices instead of the ids for building the model lists.
This will work for a const model structure we definitely have here.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Group.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Group.h	2008-09-19 04:58:06 UTC (rev 487)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Group.h	2008-09-21 11:20:38 UTC (rev 488)
@@ -133,6 +133,10 @@
       return nodeId;
     return getGroupAcceptorNode(portId);
   }
+  unsigned getGroupPortNodeIndex(const PortId& portId) const
+  {
+    return getChildNumber(getGroupPortNode(portId));
+  }
 
   PortId getGroupPort(const NodeId& nodeId) const
   {
@@ -220,12 +224,20 @@
       return NodeId();
     return _connectList[i]->_acceptorNodeId;
   }
+  unsigned getConnectAcceptorNodeIndex(unsigned i) const
+  {
+    return getChildNumber(getConnectAcceptorNodeId(i));
+  }
   NodeId getConnectProviderNodeId(unsigned i) const
   {
     if (getNumConnects() <= i)
       return NodeId();
     return _connectList[i]->_providerNodeId;
   }
+  unsigned getConnectProviderNodeIndex(unsigned i) const
+  {
+    return getChildNumber(getConnectProviderNodeId(i));
+  }
 
   SharedPtr<const AcceptorPortInfo>
   getConnectAcceptorPortInfo(unsigned i) const

Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-19 04:58:06 UTC (rev 487)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-21 11:20:38 UTC (rev 488)
@@ -684,7 +684,7 @@
 
     PortDataHelper::ProviderPortData* providerPortData;
     providerPortData = portDataList->newProxyProviderPortData(leaf._groupInternalPort);
-    _portDataMap[getCurrentNodeId()][portId] = providerPortData;
+    getCurrentNodePortDataMap()[portId] = providerPortData;
   }
   // Aussen provider, innen acceptor
   virtual void apply(const GroupProviderNode& leaf)
@@ -696,7 +696,7 @@
 
     PortDataHelper::AcceptorPortData* acceptorPortData;
     acceptorPortData = portDataList->newProxyAcceptorPortData(leaf._groupInternalPort);
-    _portDataMap[getCurrentNodeId()][portId] = acceptorPortData;
+    getCurrentNodePortDataMap()[portId] = acceptorPortData;
   }
 
   void allocPortData(NodeInstance* leafInstance, const LeafNode& leaf)
@@ -713,7 +713,7 @@
         providerPortData = portDataList->newProviderPortData(providerPort);
 
         PortId portId = leaf.getPortId(i);
-        _portDataMap[getCurrentNodeId()][portId] = providerPortData;
+        getCurrentNodePortDataMap()[portId] = providerPortData;
       }
       const AcceptorPortInfo* acceptorPort = port->toAcceptorPortInfo();
       if (acceptorPort) {
@@ -721,7 +721,7 @@
         acceptorPortData = portDataList->newAcceptorPortData(acceptorPort);
 
         PortId portId = leaf.getPortId(i);
-        _portDataMap[getCurrentNodeId()][portId] = acceptorPortData;
+        getCurrentNodePortDataMap()[portId] = acceptorPortData;
       }
     }
   }
@@ -762,7 +762,7 @@
     group.traverse(*this);
 #else
     for (unsigned i = 0; i < group.getNumChildren(); ++i) {
-      pushNodeId(group.getNodeId(i));
+      pushNodeId(i);
       mNodePath.push_back(group.getChild(i));
       group.getChild(i)->accept(*this);
       mNodePath.pop_back();
@@ -773,14 +773,14 @@
     // Apply the group internal connections to the instances
     unsigned numConnects = group.getNumConnects();
     for (unsigned i = 0; i < numConnects; ++i) {
-      Group::NodeId acceptorNodeId = group.getConnectAcceptorNodeId(i);
-      Group::NodeId providerNodeId = group.getConnectProviderNodeId(i);
+      unsigned acceptorNodeIndex = group.getConnectAcceptorNodeIndex(i);
+      unsigned providerNodeIndex = group.getConnectProviderNodeIndex(i);
 
-      if (!group.getChild(acceptorNodeId)) {
+      if (acceptorNodeIndex == ~0u) {
         std::cerr << "Cannot find acceptor node from nodeId" << std::endl;
         continue;
       }
-      if (!group.getChild(acceptorNodeId)) {
+      if (providerNodeIndex == ~0u) {
         std::cerr << "Cannot find provider node from nodeId" << std::endl;
         continue;
       }
@@ -794,35 +794,40 @@
 
       if (!acceptorPort) {
         std::cerr << "Cannot find acceptor Port data node "
-                  << group.getChild(acceptorNodeId)->getName() << std::endl;
+                  << group.getChild(acceptorNodeIndex)->getName() << std::endl;
         continue;
       }
       if (!providerPort) {
         std::cerr << "Cannot find provider Port data node "
-                  << group.getChild(providerNodeId)->getName() << std::endl;
+                  << group.getChild(providerNodeIndex)->getName() << std::endl;
         continue;
       }
 
-      if (!_portDataMap[acceptorNodeId][acceptorPortId]->
-          connect(_portDataMap[providerNodeId][providerPortId]))
+      if (!_portDataMap[acceptorNodeIndex][acceptorPortId]->
+          connect(_portDataMap[providerNodeIndex][providerPortId]))
         std::cerr << "Cannot connect????" << std::endl;
     }
 
     PortDataHelper::PortDataList* portDataList = buildGenericNodeContext(group);
 
+    parentPortDataMap.swap(_portDataMap);
+    // Ok, some nameing niceness
+    PortDataMap childrenPortDataMap;
+    childrenPortDataMap.swap(parentPortDataMap);
+
     // add group connect routings
     // merge child list into the global list of instances
     for (unsigned i = 0; i < group.getNumPorts(); ++i) {
       PortId portId = group.getPortId(i);
-      Group::NodeId nodeId = group.getGroupPortNode(portId);
-      if (_portDataMap[nodeId].empty()) {
+      unsigned nodeIndex = group.getGroupPortNodeIndex(portId);
+      if (childrenPortDataMap[nodeIndex].empty()) {
         // FIXME, is this an internal error ???
         std::cerr << "Hmm, cannot find GroupPortNode for external port "
                   << i << std::endl;
         continue;
       }
 
-      PortDataHelper::PortData* portData = _portDataMap[nodeId].begin()->second;
+      PortDataHelper::PortData* portData = childrenPortDataMap[nodeIndex].begin()->second;
       if (portData->toProxyAcceptorPortData()) {
         PortDataHelper::ProxyAcceptorPortData* proxyAcceptorPortData;
         proxyAcceptorPortData = portData->toProxyAcceptorPortData();
@@ -837,7 +842,7 @@
 
         proxyProviderPortData->setProxyAcceptorPortData(proxyAcceptorPortData);
 
-        parentPortDataMap[getCurrentNodeId()][portId] = proxyProviderPortData;
+        getCurrentNodePortDataMap()[portId] = proxyProviderPortData;
 
       } else if (portData->toProxyProviderPortData()) {
         PortDataHelper::ProxyProviderPortData* proxyProviderPortData;
@@ -853,14 +858,12 @@
 
         proxyProviderPortData->setProxyAcceptorPortData(proxyAcceptorPortData);
 
-        parentPortDataMap[getCurrentNodeId()][portId] = proxyAcceptorPortData;
+        getCurrentNodePortDataMap()[portId] = proxyAcceptorPortData;
 
       } else {
         OpenFDMAssert(false);
       }
     }
-
-    parentPortDataMap.swap(_portDataMap);
   }
 
   ////////////////////////////////////////////////////////////////////////////
@@ -880,7 +883,7 @@
   ////////////////////////////////////////////////////////////////////////////
   // Used to map connections in groups ...
   typedef std::map<PortId, SharedPtr<PortDataHelper::PortData> > NodePortDataMap;
-  typedef std::map<Group::NodeId, NodePortDataMap> PortDataMap;
+  typedef std::map<unsigned, NodePortDataMap> PortDataMap;
   PortDataMap _portDataMap;
   // Just to hold references to all mort data lists we have in the
   // simulation system. They are just needed during traversal for connect
@@ -982,20 +985,20 @@
     return true;
   }
 
-  void pushNodeId(const Group::NodeId& nodeId)
-  { _nodeIdStack.push_back(nodeId); }
+  void pushNodeId(unsigned index)
+  { mNodeIndexStack.push_back(index); }
   void popNodeId()
-  { _nodeIdStack.pop_back(); }
-  Group::NodeId getCurrentNodeId() const
+  { mNodeIndexStack.pop_back(); }
+
+  NodePortDataMap& getCurrentNodePortDataMap()
   {
-    if (_nodeIdStack.empty())
-      return Group::NodeId();
-    return _nodeIdStack.back();
+    OpenFDMAssert(!mNodeIndexStack.empty());
+    return _portDataMap[mNodeIndexStack.back()];
   }
 
 private:
-  typedef std::list<Group::NodeId> NodeIdStack;
-  NodeIdStack _nodeIdStack;
+  typedef std::list<unsigned> NodeIndexStack;
+  NodeIndexStack mNodeIndexStack;
 
   NodePath mNodePath;
 };



From frohlich at mail.berlios.de  Mon Sep 22 07:23:35 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Mon, 22 Sep 2008 07:23:35 +0200
Subject: [OpenFDM-svn] r489 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200809220523.m8M5NZLV010320@sheep.berlios.de>

Author: frohlich
Date: 2008-09-22 07:23:33 +0200 (Mon, 22 Sep 2008)
New Revision: 489

Modified:
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
The map is no longer needed. Replace by a list.


Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-21 11:20:38 UTC (rev 488)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-22 05:23:33 UTC (rev 489)
@@ -669,7 +669,7 @@
     genericNodeInstance = new GenericNodeInstance(mNodePath, &node);
     _nodeInstanceList.push_back(genericNodeInstance);
     PortDataHelper::PortDataList* portDataList = new PortDataHelper::PortDataList(genericNodeInstance);
-    _portDataListMap[_nodeInstanceList.back()] = portDataList;
+    _portDataListList.push_back(portDataList);
 
     return portDataList;
   }
@@ -702,7 +702,7 @@
   void allocPortData(NodeInstance* leafInstance, const LeafNode& leaf)
   {
     PortDataHelper::PortDataList* portDataList = new PortDataHelper::PortDataList(leafInstance);
-    _portDataListMap[SharedPtr<NodeInstance>(leafInstance)] = portDataList;
+    _portDataListList.push_back(portDataList);
 
     // FIXME: move to LeafInstance??
     for (unsigned i = 0; i < leaf.getNumPorts(); ++i) {
@@ -888,8 +888,8 @@
   // Just to hold references to all mort data lists we have in the
   // simulation system. They are just needed during traversal for connect
   // information and to distribute port value pointers.
-  typedef std::map<SharedPtr<NodeInstance>,SharedPtr<PortDataHelper::PortDataList> > PortDataListMap;
-  PortDataListMap _portDataListMap;
+  typedef std::list<SharedPtr<PortDataHelper::PortDataList> > PortDataListList;
+  PortDataListList _portDataListList;
 
   // method to sort the leafs according to their dependency
   bool sortModelList()
@@ -944,12 +944,9 @@
   bool
   allocPortData()
   {
-    PortDataListMap::const_iterator i;
-    for (i = _portDataListMap.begin(); i != _portDataListMap.end(); ++i) {
-      PortDataHelper::PortDataList* portDataList = i->second;
-      if (!portDataList)
-        continue;
-      if (!portDataList->allocAndConnectProviderPortValues()) {
+    PortDataListList::const_iterator i;
+    for (i = _portDataListList.begin(); i != _portDataListList.end(); ++i) {
+      if (!(*i)->allocAndConnectProviderPortValues()) {
         Log(Schedule, Error) << "Could not alloc for model ... FIXME" << endl;
         return false;
       }



From frohlich at mail.berlios.de  Mon Sep 22 07:39:19 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Mon, 22 Sep 2008 07:39:19 +0200
Subject: [OpenFDM-svn] r490 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200809220539.m8M5dJYA022458@sheep.berlios.de>

Author: frohlich
Date: 2008-09-22 07:39:17 +0200 (Mon, 22 Sep 2008)
New Revision: 490

Modified:
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Remove #if 0 part.


Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-22 05:23:33 UTC (rev 489)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-22 05:39:17 UTC (rev 490)
@@ -758,9 +758,6 @@
     parentPortDataMap.swap(_portDataMap);
 
     // Walk the children
-#if 0
-    group.traverse(*this);
-#else
     for (unsigned i = 0; i < group.getNumChildren(); ++i) {
       pushNodeId(i);
       mNodePath.push_back(group.getChild(i));
@@ -768,7 +765,6 @@
       mNodePath.pop_back();
       popNodeId();
     }
-#endif
 
     // Apply the group internal connections to the instances
     unsigned numConnects = group.getNumConnects();



From frohlich at mail.berlios.de  Mon Sep 22 08:15:14 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Mon, 22 Sep 2008 08:15:14 +0200
Subject: [OpenFDM-svn] r491 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200809220615.m8M6FEwY030077@sheep.berlios.de>

Author: frohlich
Date: 2008-09-22 08:15:11 +0200 (Mon, 22 Sep 2008)
New Revision: 491

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Group.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Group.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Node.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Node.h
Log:
A node can have a number of parents. Yet unused.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Group.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Group.cpp	2008-09-22 05:39:17 UTC (rev 490)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Group.cpp	2008-09-22 06:15:11 UTC (rev 491)
@@ -8,12 +8,14 @@
 
 namespace OpenFDM {
 
-GroupAcceptorNode::GroupAcceptorNode() :
+GroupAcceptorNode::GroupAcceptorNode(const std::string& name) :
+  Node(name),
   _groupInternalPort(new ProxyProviderPortInfo(this, "output"))
 {
 }
 
-GroupProviderNode::GroupProviderNode() :
+GroupProviderNode::GroupProviderNode(const std::string& name) :
+  Node(name),
   _groupInternalPort(new ProxyAcceptorPortInfo(this, "input"))
 {
 }

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Group.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Group.h	2008-09-22 05:39:17 UTC (rev 490)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Group.h	2008-09-22 06:15:11 UTC (rev 491)
@@ -25,7 +25,7 @@
 
 class GroupAcceptorNode : public Node {
 public:
-  GroupAcceptorNode();
+  GroupAcceptorNode(const std::string& name = std::string());
   virtual void accept(NodeVisitor& visitor)
   { visitor.apply(*this); }
   virtual void accept(ConstNodeVisitor& visitor) const
@@ -37,7 +37,7 @@
 
 class GroupProviderNode : public Node {
 public:
-  GroupProviderNode();
+  GroupProviderNode(const std::string& name = std::string());
   virtual void accept(NodeVisitor& visitor)
   { visitor.apply(*this); }
   virtual void accept(ConstNodeVisitor& visitor) const

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Node.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Node.cpp	2008-09-22 05:39:17 UTC (rev 490)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Node.cpp	2008-09-22 06:15:11 UTC (rev 491)
@@ -33,6 +33,46 @@
   visitor.apply(*this);
 }
 
+void
+Node::ascend(NodeVisitor& visitor)
+{
+  ParentList::iterator i;
+  for (i = mParentList.begin(); i != mParentList.end(); ++i) {
+    SharedPtr<Node> parent = i->lock();
+    if (!parent)
+      continue;
+    parent->accept(visitor);
+  }
+}
+
+void
+Node::ascend(ConstNodeVisitor& visitor) const
+{
+  ParentList::const_iterator i;
+  for (i = mParentList.begin(); i != mParentList.end(); ++i) {
+    SharedPtr<const Node> parent = i->lock();
+    if (!parent)
+      continue;
+    parent->accept(visitor);
+  }
+}
+
+WeakPtr<const Node>
+Node::getParent(unsigned i) const
+{
+  if (mParentList.size() <= i)
+    return 0;
+  return mParentList[i];
+}
+
+WeakPtr<Node>
+Node::getParent(unsigned i)
+{
+  if (mParentList.size() <= i)
+    return 0;
+  return mParentList[i];
+}
+
 SharedPtr<const PortInfo>
 Node::getPort(const PortId& portId) const
 {
@@ -100,6 +140,27 @@
 }
 
 void
+Node::addParent(Node* parent)
+{
+  if (!parent)
+    return;
+  mParentList.push_back(parent);
+}
+
+void
+Node::removeParent(Node* parent)
+{
+  ParentList::iterator i;
+  for (i = mParentList.begin(); i != mParentList.end();) {
+    SharedPtr<Node> lockedParent = i->lock();
+    if (parent == lockedParent)
+      i = mParentList.erase(i);
+    else
+      ++i;
+  }
+}
+
+void
 Node::addPort(PortInfo* port)
 {
   if (!port)

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Node.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Node.h	2008-09-22 05:39:17 UTC (rev 490)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Node.h	2008-09-22 06:15:11 UTC (rev 491)
@@ -20,12 +20,19 @@
 class Node : public Object {
   OPENFDM_OBJECT(Node, Object);
 public:
-  Node(const std::string& name = std::string());
+  Node(const std::string& name);
   virtual ~Node();
 
   virtual void accept(NodeVisitor& visitor);
   virtual void accept(ConstNodeVisitor& visitor) const;
+  void ascend(NodeVisitor& visitor);
+  void ascend(ConstNodeVisitor& visitor) const;
 
+  unsigned getNumParents() const
+  { return mParentList.size(); }
+  WeakPtr<const Node> getParent(unsigned i) const;
+  WeakPtr<Node> getParent(unsigned i);
+
   SharedPtr<const PortInfo> getPort(const PortId& portId) const;
   SharedPtr<const PortInfo> getPort(unsigned index) const;
   SharedPtr<const PortInfo> getPort(const std::string& name) const;
@@ -39,6 +46,9 @@
 
 protected:
 
+  void addParent(Node* parent);
+  void removeParent(Node* parent);
+
 private:
   Node(const Node&);
   Node& operator=(const Node&);
@@ -50,6 +60,9 @@
   PortList mPortList;
 
   friend class PortInfo;
+
+  typedef std::vector<WeakPtr<Node> > ParentList;
+  ParentList mParentList;
 };
 
 } // namespace OpenFDM



From frohlich at mail.berlios.de  Tue Sep 23 07:00:09 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Tue, 23 Sep 2008 07:00:09 +0200
Subject: [OpenFDM-svn] r492 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200809230500.m8N509NL014939@sheep.berlios.de>

Author: frohlich
Date: 2008-09-23 07:00:07 +0200 (Tue, 23 Sep 2008)
New Revision: 492

Modified:
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Rename method to better match what it does.


Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-22 06:15:11 UTC (rev 491)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-23 05:00:07 UTC (rev 492)
@@ -938,7 +938,7 @@
   }
 
   bool
-  allocPortData()
+  allocPortValues()
   {
     PortDataListList::const_iterator i;
     for (i = _portDataListList.begin(); i != _portDataListList.end(); ++i) {
@@ -1102,7 +1102,7 @@
     
     // Allocates and distributes the PortValues, is required for the sort
     // steps below
-    if (!nodeInstanceCollector.allocPortData())
+    if (!nodeInstanceCollector.allocPortValues())
       return false;
     // The model instances are sorted to match the direct input property
     if (!nodeInstanceCollector.sortModelList())



From frohlich at mail.berlios.de  Tue Sep 23 07:06:38 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Tue, 23 Sep 2008 07:06:38 +0200
Subject: [OpenFDM-svn] r493 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200809230506.m8N56cBN022609@sheep.berlios.de>

Author: frohlich
Date: 2008-09-23 07:06:37 +0200 (Tue, 23 Sep 2008)
New Revision: 493

Modified:
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Make something more private.


Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-23 05:00:07 UTC (rev 492)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-23 05:06:37 UTC (rev 493)
@@ -457,16 +457,6 @@
     { return 0; }
     virtual bool connect(PortData*) = 0;
 
-    SharedPtr<PortDataList> getParentPortDataList() const
-    { return mParentPortDataList.lock(); }
-    SharedPtr<NodeInstance> getNodeInstance() const
-    {
-      SharedPtr<PortDataList> portDataList = getParentPortDataList();
-      if (!portDataList)
-        return 0;
-      return portDataList->mNodeInstance;
-    }
-
     const SharedPtr<const PortInfo>& getPortInfo() const
     { return mPortInfo; }
 
@@ -474,7 +464,10 @@
     {
       if (!getPortInfo())
         return;
-      SharedPtr<NodeInstance> nodeInstance = getNodeInstance();
+      SharedPtr<PortDataList> portDataList = mParentPortDataList.lock();
+      if (!portDataList)
+        return;
+      SharedPtr<NodeInstance> nodeInstance = portDataList->mNodeInstance;
       if (!nodeInstance)
         return;
       unsigned index = getPortInfo()->getIndex();



From frohlich at mail.berlios.de  Fri Sep 26 05:07:34 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Fri, 26 Sep 2008 05:07:34 +0200
Subject: [OpenFDM-svn] r494 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200809260307.m8Q37Y1l007218@sheep.berlios.de>

Author: frohlich
Date: 2008-09-26 05:07:33 +0200 (Fri, 26 Sep 2008)
New Revision: 494

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/ContinousStateValue.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/MatrixStateValue.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/TemplateContinousStateInfo.h
Log:
Adjustments to the state values.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/ContinousStateValue.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ContinousStateValue.h	2008-09-23 05:06:37 UTC (rev 493)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ContinousStateValue.h	2008-09-26 03:07:33 UTC (rev 494)
@@ -5,12 +5,15 @@
 #ifndef OpenFDM_ContinousStateValue_H
 #define OpenFDM_ContinousStateValue_H
 
+#include "StateStream.h"
 #include "StateValue.h"
 
 namespace OpenFDM {
 
 class ContinousStateValue : public StateValue {
 public:
+  virtual void setValue(const StateStream& stateStream) = 0;
+  virtual void getValue(StateStream& stateStream) const = 0;
 
 protected:
   virtual ~ContinousStateValue();

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MatrixStateValue.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MatrixStateValue.h	2008-09-23 05:06:37 UTC (rev 493)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MatrixStateValue.h	2008-09-26 03:07:33 UTC (rev 494)
@@ -14,6 +14,12 @@
 public:
   MatrixStateValue(const Size& size) : mMatrix(size)
   { }
+  MatrixStateValue()
+  { }
+
+  void resize(const Size& size)
+  { mMatrix.resize(size); }
+
   const Matrix& getMatrix() const
   { return mMatrix; }
   Matrix& getMatrix()
@@ -21,6 +27,11 @@
   void setMatrix(const Matrix& matrix)
   { OpenFDMAssert(size(matrix) == size(mMatrix)); mMatrix = matrix; }
 
+  virtual void setValue(const StateStream& stateStream)
+  { stateStream.readSubState(mMatrix); }
+  virtual void getValue(StateStream& stateStream) const
+  { stateStream.writeSubState(mMatrix); }
+
 protected:
   virtual ~MatrixStateValue();
 

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/TemplateContinousStateInfo.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/TemplateContinousStateInfo.h	2008-09-23 05:06:37 UTC (rev 493)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/TemplateContinousStateInfo.h	2008-09-26 03:07:33 UTC (rev 494)
@@ -6,14 +6,14 @@
 #define OpenFDM_TemplateContinousStateInfo_H
 
 #include "ContinousStateInfo.h"
-#include "ContinousStateValue.h"
+#include "MatrixStateValue.h"
 #include "TemplateStateInfo.h"
 
 namespace OpenFDM {
 
 template<typename T>
 class TemplateContinousStateInfo : 
-    public TemplateStateInfo<T, ContinousStateInfo, ContinousStateValue> {
+    public TemplateStateInfo<T, ContinousStateInfo, MatrixStateValue> {
 };
 
 } // namespace OpenFDM



From frohlich at mail.berlios.de  Fri Sep 26 06:13:34 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Fri, 26 Sep 2008 06:13:34 +0200
Subject: [OpenFDM-svn] r495 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200809260413.m8Q4DYFc018590@sheep.berlios.de>

Author: frohlich
Date: 2008-09-26 06:13:33 +0200 (Fri, 26 Sep 2008)
New Revision: 495

Added:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Interval.h
Log:
Add Interval implementation.


Added: branches/OpenFDM-StateSeparation/src/OpenFDM/Interval.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Interval.h	2008-09-26 03:07:33 UTC (rev 494)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Interval.h	2008-09-26 04:13:33 UTC (rev 495)
@@ -0,0 +1,53 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_Interval_H
+#define OpenFDM_Interval_H
+
+#include "Limits.h"
+
+namespace OpenFDM {
+
+template<typename T>
+class Interval {
+public:
+  typedef T value_type;
+
+  Interval() :
+    mBegin(Limits<value_type>::max()), mEnd(-Limits<value_type>::max())
+  { }
+  Interval(const value_type& begin, const value_type& end) :
+    mBegin(begin), mEnd(end)
+  { }
+
+  void setBegin(const value_type& begin) { mBegin = begin; }
+  const value_type& getBegin() const { return mBegin; }
+
+  void setEnd(const value_type& end) { mBegin = end; }
+  const value_type& getEnd() const { return mEnd; }
+
+  bool valid() const
+  { return mBegin <= mEnd; }
+  value_type length() const
+  { return mEnd - mBegin; }
+
+  bool isLeftOf(const value_type& value) const
+  { return value <= mBegin; }
+  bool isStrictlyLeftOf(const value_type& value) const
+  { return value < mBegin; }
+  bool isRightOf(const value_type& value) const
+  { return mEnd <= value; }
+  bool isStrictlyRightOf(const value_type& value) const
+  { return mEnd < value; }
+  bool contains(const value_type& value) const
+  { return mBegin <= value && value <= mEnd; }
+
+private:
+  value_type mBegin;
+  value_type mEnd;
+};
+
+} // namespace OpenFDM
+
+#endif



From frohlich at mail.berlios.de  Fri Sep 26 06:14:09 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Fri, 26 Sep 2008 06:14:09 +0200
Subject: [OpenFDM-svn] r496 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200809260414.m8Q4E95E018823@sheep.berlios.de>

Author: frohlich
Date: 2008-09-26 06:14:08 +0200 (Fri, 26 Sep 2008)
New Revision: 496

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/ContinousStateValue.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/MatrixStateValue.h
Log:
Add a size getter.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/ContinousStateValue.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ContinousStateValue.h	2008-09-26 04:13:33 UTC (rev 495)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ContinousStateValue.h	2008-09-26 04:14:08 UTC (rev 496)
@@ -14,6 +14,7 @@
 public:
   virtual void setValue(const StateStream& stateStream) = 0;
   virtual void getValue(StateStream& stateStream) const = 0;
+  virtual LinAlg::size_type getNumStates() const = 0;
 
 protected:
   virtual ~ContinousStateValue();

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MatrixStateValue.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MatrixStateValue.h	2008-09-26 04:13:33 UTC (rev 495)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MatrixStateValue.h	2008-09-26 04:14:08 UTC (rev 496)
@@ -31,6 +31,8 @@
   { stateStream.readSubState(mMatrix); }
   virtual void getValue(StateStream& stateStream) const
   { stateStream.writeSubState(mMatrix); }
+  virtual LinAlg::size_type getNumStates() const
+  { return rows(mMatrix)*cols(mMatrix); }
 
 protected:
   virtual ~MatrixStateValue();



From frohlich at mail.berlios.de  Fri Sep 26 06:14:26 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Fri, 26 Sep 2008 06:14:26 +0200
Subject: [OpenFDM-svn] r497 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200809260414.m8Q4EQba019363@sheep.berlios.de>

Author: frohlich
Date: 2008-09-26 06:14:25 +0200 (Fri, 26 Sep 2008)
New Revision: 497

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
Log:
Add Interval.h so the build system.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-09-26 04:14:08 UTC (rev 496)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-09-26 04:14:25 UTC (rev 497)
@@ -31,6 +31,7 @@
   Group.h \
   ImplicitEuler.h \
   Inertia.h \
+  Interval.h \
   Interact.h \
   LeafContext.h \
   LeafNode.h \



From frohlich at mail.berlios.de  Fri Sep 26 07:26:12 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Fri, 26 Sep 2008 07:26:12 +0200
Subject: [OpenFDM-svn] r498 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200809260526.m8Q5QC6c010619@sheep.berlios.de>

Author: frohlich
Date: 2008-09-26 07:26:11 +0200 (Fri, 26 Sep 2008)
New Revision: 498

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Interval.h
Log:
Fix thinko.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Interval.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Interval.h	2008-09-26 04:14:25 UTC (rev 497)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Interval.h	2008-09-26 05:26:11 UTC (rev 498)
@@ -29,17 +29,17 @@
 
   bool valid() const
   { return mBegin <= mEnd; }
-  value_type length() const
+  value_type getLength() const
   { return mEnd - mBegin; }
 
   bool isLeftOf(const value_type& value) const
-  { return value <= mBegin; }
+  { return mEnd <= value; }
   bool isStrictlyLeftOf(const value_type& value) const
-  { return value < mBegin; }
+  { return mEnd < value; }
   bool isRightOf(const value_type& value) const
-  { return mEnd <= value; }
+  { return value <= mBegin; }
   bool isStrictlyRightOf(const value_type& value) const
-  { return mEnd < value; }
+  { return value < mBegin; }
   bool contains(const value_type& value) const
   { return mBegin <= value && value <= mEnd; }
 



From frohlich at mail.berlios.de  Sat Sep 27 07:29:29 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 27 Sep 2008 07:29:29 +0200
Subject: [OpenFDM-svn] r499 - in branches/OpenFDM-StateSeparation/src:
	OpenFDM test
Message-ID: <200809270529.m8R5TTS3003394@sheep.berlios.de>

Author: frohlich
Date: 2008-09-27 07:29:27 +0200 (Sat, 27 Sep 2008)
New Revision: 499

Added:
   branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeContext.h
Removed:
   branches/OpenFDM-StateSeparation/src/OpenFDM/NodeContext.h
Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/LeafContext.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
class name shuffling ...


Copied: branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeContext.h (from rev 498, branches/OpenFDM-StateSeparation/src/OpenFDM/NodeContext.h)
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/NodeContext.h	2008-09-26 05:26:11 UTC (rev 498)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeContext.h	2008-09-27 05:29:27 UTC (rev 499)
@@ -0,0 +1,29 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_AbstractNodeContext_H
+#define OpenFDM_AbstractNodeContext_H
+
+#include "Node.h"
+#include "PortValueList.h"
+
+namespace OpenFDM {
+
+class AbstractNodeContext : public Referenced {
+public:
+  virtual ~AbstractNodeContext() { }
+  virtual const Node& getNode() const = 0;
+
+  PortValueList& getPortValueList()
+  { return mPortValueList; }
+  const PortValueList& getPortValueList() const
+  { return mPortValueList; }
+
+  // PortValues
+  PortValueList mPortValueList;
+};
+
+} // namespace OpenFDM
+
+#endif

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/LeafContext.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/LeafContext.h	2008-09-26 05:26:11 UTC (rev 498)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/LeafContext.h	2008-09-27 05:29:27 UTC (rev 499)
@@ -7,11 +7,11 @@
 
 #include "ContinousStateValueVector.h"
 #include "DiscreteStateValueVector.h"
-#include "NodeContext.h"
+#include "AbstractNodeContext.h"
 
 namespace OpenFDM {
 
-class LeafContext : public NodeContext {
+class LeafContext : public AbstractNodeContext {
 public:
   // Continous States
   ContinousStateValueVector mContinousState;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-09-26 05:26:11 UTC (rev 498)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-09-27 05:29:27 UTC (rev 499)
@@ -8,6 +8,7 @@
 libOpenFDM_la_LIBADD = -lrt
 
 OpenFDMCoreHEADERS = \
+  AbstractNodeContext.h \
   AcceptorPortInfo.h \
   Assert.h \
   Atomic.h \
@@ -65,7 +66,6 @@
   MPFRFloat.h \
   Newton.h \
   Node.h \
-  NodeContext.h \
   NodeVisitor.h \
   NumericPortValue.h \
   NumericAcceptorPortInfo.h \

Deleted: branches/OpenFDM-StateSeparation/src/OpenFDM/NodeContext.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/NodeContext.h	2008-09-26 05:26:11 UTC (rev 498)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/NodeContext.h	2008-09-27 05:29:27 UTC (rev 499)
@@ -1,32 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
- *
- */
-
-#ifndef OpenFDM_NodeContext_H
-#define OpenFDM_NodeContext_H
-
-#include "Node.h"
-#include "PortValueList.h"
-
-namespace OpenFDM {
-
-/// Hmm, NodeContext is not base of LeafContext for now. FIXME!!!
-/// This class might not be user visible. Is implemented somewhere
-/// in the simulation backend.
-class NodeContext : public Referenced {
-public:
-  virtual ~NodeContext() { }
-  virtual const Node& getNode() const = 0;
-
-  PortValueList& getPortValueList()
-  { return mPortValueList; }
-  const PortValueList& getPortValueList() const
-  { return mPortValueList; }
-
-  // PortValues
-  PortValueList mPortValueList;
-};
-
-} // namespace OpenFDM
-
-#endif

Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-26 05:26:11 UTC (rev 498)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-27 05:29:27 UTC (rev 499)
@@ -88,9 +88,9 @@
 ///             | |     --------
 ///             | ----->| Node |
 ///             |       --------
-///             |       ---------------
-///             ------->| NodeContext |
-///                     ---------------
+///             |       -----------------------
+///             ------->| AbstractNodeContext |
+///                     -----------------------
 ///
 /// The NodeInstance is used to present the user a handle to the simulation
 /// models runtime data. Each instance has an execution context and a pointer
@@ -108,15 +108,15 @@
 /// A NodeInstance represents an effective model node in a ready to run
 /// System. You can access the Nodes Ports values for example.
 /// This class is meant to show up in the user interface of this simulation.
-class NodeInstance : public WeakReferenced {
+class AbstractNodeInstance : public WeakReferenced {
 public:
-  NodeInstance(const NodePath& nodePath) :
+  AbstractNodeInstance(const NodePath& nodePath) :
     mNodePath(nodePath)
   { }
-  virtual ~NodeInstance()
+  virtual ~AbstractNodeInstance()
   { }
 
-  /// The actual Node this NodeInstance stems from
+  /// The actual Node this AbstractNodeInstance stems from
   const Node& getNode() const
   { return getNodeContext().getNode(); }
 
@@ -150,15 +150,15 @@
   }
 
 protected:
-  NodeInstance() {}
+  AbstractNodeInstance() {}
 
   /// The node context that belongs to this instance.
-  virtual NodeContext& getNodeContext() = 0;
-  virtual const NodeContext& getNodeContext() const = 0;
+  virtual AbstractNodeContext& getNodeContext() = 0;
+  virtual const AbstractNodeContext& getNodeContext() const = 0;
 
 private:
-  NodeInstance(const NodeInstance&);
-  NodeInstance& operator=(const NodeInstance&);
+  AbstractNodeInstance(const AbstractNodeInstance&);
+  AbstractNodeInstance& operator=(const AbstractNodeInstance&);
 
 //   /// The sample times this node will run on
 //   SampleTimeSet mSampleTimeSet;
@@ -166,7 +166,7 @@
   NodePath mNodePath;
 };
 
-typedef std::list<SharedPtr<NodeInstance> > NodeInstanceList;
+typedef std::list<SharedPtr<AbstractNodeInstance> > NodeInstanceList;
 
 
 ////////////////////////////////////////////////////////////////////////////
@@ -175,9 +175,9 @@
 /// to fill NodeContext's for Node's that have nothing to execute,
 /// should be reflected to the user of the simulation system. Group's
 /// inputs ad outputs and their input and output models are such examples.
-class GenericNodeContext : public NodeContext {
+class NodeContext : public AbstractNodeContext {
 public:
-  GenericNodeContext(const Node* node) :
+  NodeContext(const Node* node) :
     mNode(node)
   { }
 
@@ -185,18 +185,18 @@
   { return *mNode; }
 
 private:
-  GenericNodeContext();
-  GenericNodeContext(const GenericNodeContext&);
-  GenericNodeContext& operator=(const GenericNodeContext&);
+  NodeContext();
+  NodeContext(const NodeContext&);
+  NodeContext& operator=(const NodeContext&);
 
   SharedPtr<const Node> mNode;
 };
 
-class GenericNodeInstance : public NodeInstance {
+class NodeInstance : public AbstractNodeInstance {
 public:
-  GenericNodeInstance(const NodePath& nodePath, const Node* node) :
-    NodeInstance(nodePath),
-    mNodeContext(new GenericNodeContext(node))
+  NodeInstance(const NodePath& nodePath, const Node* node) :
+    AbstractNodeInstance(nodePath),
+    mNodeContext(new NodeContext(node))
   { }
 
 protected:
@@ -305,10 +305,10 @@
   }
 };
 
-class ModelInstance : public NodeInstance {
+class ModelInstance : public AbstractNodeInstance {
 public:
   ModelInstance(const NodePath& nodePath, const Model* model) :
-    NodeInstance(nodePath),
+    AbstractNodeInstance(nodePath),
     mModelContext(new ModelContext(model))
   { }
 
@@ -405,11 +405,11 @@
   }
 };
 
-class MechanicInstance : public NodeInstance {
+class MechanicInstance : public AbstractNodeInstance {
 public:
   MechanicInstance(const NodePath& nodePath,
                    const MechanicNode* mechanicNode) :
-    NodeInstance(nodePath),
+    AbstractNodeInstance(nodePath),
     mMechanicContext(new MechanicContext(mechanicNode))
   { }
 
@@ -467,7 +467,7 @@
       SharedPtr<PortDataList> portDataList = mParentPortDataList.lock();
       if (!portDataList)
         return;
-      SharedPtr<NodeInstance> nodeInstance = portDataList->mNodeInstance;
+      SharedPtr<AbstractNodeInstance> nodeInstance = portDataList->mNodeInstance;
       if (!nodeInstance)
         return;
       unsigned index = getPortInfo()->getIndex();
@@ -589,7 +589,7 @@
   // Return true if this leaf directly depends on one of leafInstance outputs
   class PortDataList : public WeakReferenced {
   public:
-    PortDataList(NodeInstance* nodeInstance) :
+    PortDataList(AbstractNodeInstance* nodeInstance) :
       mNodeInstance(nodeInstance)
     { }
     
@@ -640,9 +640,9 @@
     typedef std::vector<SharedPtr<PortData> > PortDataVector;
     PortDataVector mPortDataVector;
     
-    /// The NodeInstance having some way to reference the
+    /// The AbstractNodeInstance having some way to reference the
     /// PortValues to the current connect information.
-    SharedPtr<NodeInstance> mNodeInstance;
+    SharedPtr<AbstractNodeInstance> mNodeInstance;
   };
 };
 
@@ -656,12 +656,12 @@
   virtual void apply(const LibraryNode& libraryNode)
   { std::cerr << __PRETTY_FUNCTION__ << std::endl; }
 
-  PortDataHelper::PortDataList* buildGenericNodeContext(const Node& node)
+  PortDataHelper::PortDataList* buildNodeContext(const Node& node)
   {
-    GenericNodeInstance* genericNodeInstance;
-    genericNodeInstance = new GenericNodeInstance(mNodePath, &node);
-    _nodeInstanceList.push_back(genericNodeInstance);
-    PortDataHelper::PortDataList* portDataList = new PortDataHelper::PortDataList(genericNodeInstance);
+    NodeInstance* nodeInstance;
+    nodeInstance = new NodeInstance(mNodePath, &node);
+    _nodeInstanceList.push_back(nodeInstance);
+    PortDataHelper::PortDataList* portDataList = new PortDataHelper::PortDataList(nodeInstance);
     _portDataListList.push_back(portDataList);
 
     return portDataList;
@@ -670,7 +670,7 @@
   // Aussen acceptor, innen provider
   virtual void apply(const GroupAcceptorNode& leaf)
   {
-    PortDataHelper::PortDataList* portDataList = buildGenericNodeContext(leaf);
+    PortDataHelper::PortDataList* portDataList = buildNodeContext(leaf);
 
     OpenFDMAssert(leaf.getPort(0));
     PortId portId = leaf.getPortId(0);
@@ -682,7 +682,7 @@
   // Aussen provider, innen acceptor
   virtual void apply(const GroupProviderNode& leaf)
   {
-    PortDataHelper::PortDataList* portDataList = buildGenericNodeContext(leaf);
+    PortDataHelper::PortDataList* portDataList = buildNodeContext(leaf);
 
     OpenFDMAssert(leaf.getPort(0));
     PortId portId = leaf.getPortId(0);
@@ -692,7 +692,7 @@
     getCurrentNodePortDataMap()[portId] = acceptorPortData;
   }
 
-  void allocPortData(NodeInstance* leafInstance, const LeafNode& leaf)
+  void allocPortData(AbstractNodeInstance* leafInstance, const LeafNode& leaf)
   {
     PortDataHelper::PortDataList* portDataList = new PortDataHelper::PortDataList(leafInstance);
     _portDataListList.push_back(portDataList);
@@ -797,7 +797,7 @@
         std::cerr << "Cannot connect????" << std::endl;
     }
 
-    PortDataHelper::PortDataList* portDataList = buildGenericNodeContext(group);
+    PortDataHelper::PortDataList* portDataList = buildNodeContext(group);
 
     parentPortDataMap.swap(_portDataMap);
     // Ok, some nameing niceness



From frohlich at mail.berlios.de  Sat Sep 27 07:54:20 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 27 Sep 2008 07:54:20 +0200
Subject: [OpenFDM-svn] r500 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200809270554.m8R5sKYR009327@sheep.berlios.de>

Author: frohlich
Date: 2008-09-27 07:54:20 +0200 (Sat, 27 Sep 2008)
New Revision: 500

Modified:
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Provide some isConnectedTo implementation for mechanic models.


Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-27 05:29:27 UTC (rev 499)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-27 05:54:20 UTC (rev 500)
@@ -239,8 +239,8 @@
 //                        mPortValueList,
 //                        mContinousStateDerivative); }
 
-  // Return true if this leaf directly depends on one of leafInstance outputs
-  bool dependsOn(const ModelContext* modelContext) const
+  // Return true if this model directly depends on one of models outputs
+  bool dependsOn(const ModelContext& modelContext) const
   {
     unsigned numPorts = mModel->getNumPorts();
     for (unsigned i = 0; i < numPorts; ++i) {
@@ -253,13 +253,13 @@
       const PortValue* portValue = getPortValueList().getPortValue(i);
       if (!portValue)
         continue;
-      unsigned otherNumPorts = modelContext->mModel->getNumPorts();
+      unsigned otherNumPorts = modelContext.mModel->getNumPorts();
       for (unsigned j = 0; j < otherNumPorts; ++j) {
-        if (!modelContext->mModel->getPort(j)->toProviderPortInfo())
+        if (!modelContext.mModel->getPort(j)->toProviderPortInfo())
           continue;
 
         const PortValue* otherPortValue;
-        otherPortValue = modelContext->getPortValueList().getPortValue(j);
+        otherPortValue = modelContext.getPortValueList().getPortValue(j);
         if (portValue != otherPortValue)
           continue;
 
@@ -313,8 +313,8 @@
   { }
 
   // Return true if this leaf directly depends on one of leafInstance outputs
-  bool dependsOn(const ModelInstance* modelInstance) const
-  { return mModelContext->dependsOn(modelInstance->mModelContext); }
+  bool dependsOn(const ModelInstance& modelInstance) const
+  { return mModelContext->dependsOn(*modelInstance.mModelContext); }
 
 // protected: // FIXME
   virtual ModelContext& getNodeContext()
@@ -363,6 +363,32 @@
 //   void update()
 //   { }
 
+  bool isConnectedTo(const MechanicContext& mechanicContext) const
+  {
+    unsigned numPorts = mMechanicNode->getNumPorts();
+    for (unsigned i = 0; i < numPorts; ++i) {
+      SharedPtr<const PortInfo> portInfo = mMechanicNode->getPort(i);
+      OpenFDMAssert(portInfo);
+      const PortValue* portValue = getPortValueList().getPortValue(i);
+      if (!portValue)
+        continue;
+      unsigned otherNumPorts = mechanicContext.mMechanicNode->getNumPorts();
+      for (unsigned j = 0; j < otherNumPorts; ++j) {
+        if (!mechanicContext.mMechanicNode->getPort(j)->toProviderPortInfo())
+          continue;
+
+        const PortValue* otherPortValue;
+        otherPortValue = mechanicContext.getPortValueList().getPortValue(j);
+        if (portValue != otherPortValue)
+          continue;
+
+        return true;
+      }
+    }
+    return false;
+  }
+
+private:
   SharedPtr<const MechanicNode> mMechanicNode;
 
 private:
@@ -413,6 +439,9 @@
     mMechanicContext(new MechanicContext(mechanicNode))
   { }
 
+  bool isConnectedTo(const MechanicInstance& mechanicInstance) const
+  { return mMechanicContext->isConnectedTo(*mechanicInstance.mMechanicContext); }
+
 protected:
   virtual MechanicContext& getNodeContext()
   { return *mMechanicContext; }
@@ -646,7 +675,7 @@
   };
 };
 
-class LeafInstanceCollector : public ConstNodeVisitor {
+class NodeInstanceCollector : public ConstNodeVisitor {
 public:
 
   virtual void apply(const Node& node)
@@ -892,7 +921,7 @@
       for (i = sortedModelInstanceList.begin();
            i != sortedModelInstanceList.end();
            ++i) {
-        if (!(*i)->dependsOn(modelInstance))
+        if (!(*i)->dependsOn(*modelInstance))
           continue;
 
         // Something already sorted in depends on modelInstance,
@@ -916,7 +945,7 @@
         // If it cannot be put at the end, check if modelInstance depends
         // on any model that is already scheduled behind to detect cyclic loops.
         for (; i != sortedModelInstanceList.end(); ++i) {
-          if (!modelInstance->dependsOn(*i))
+          if (!modelInstance->dependsOn(*(*i)))
             continue;
           Log(Schedule,Error)
             << "Detected cyclic loop: Model \""
@@ -1090,7 +1119,7 @@
       return true;
 
     // Build up the lists required to run the model.
-    LeafInstanceCollector nodeInstanceCollector;
+    NodeInstanceCollector nodeInstanceCollector;
     mNode->accept(nodeInstanceCollector);
     
     // Allocates and distributes the PortValues, is required for the sort



From frohlich at mail.berlios.de  Sat Sep 27 08:04:39 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 27 Sep 2008 08:04:39 +0200
Subject: [OpenFDM-svn] r501 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200809270604.m8R64dpf026107@sheep.berlios.de>

Author: frohlich
Date: 2008-09-27 08:04:39 +0200 (Sat, 27 Sep 2008)
New Revision: 501

Modified:
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Add some asserts.


Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-27 05:54:20 UTC (rev 500)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-27 06:04:39 UTC (rev 501)
@@ -179,7 +179,7 @@
 public:
   NodeContext(const Node* node) :
     mNode(node)
-  { }
+  { OpenFDMAssert(mNode); }
 
   virtual const Node& getNode() const
   { return *mNode; }
@@ -219,7 +219,7 @@
 public:
   ModelContext(const Model* model) :
     mModel(model)
-  { }
+  { OpenFDMAssert(mModel); }
 
   virtual const Model& getNode() const
   { return *mModel; }
@@ -334,7 +334,7 @@
 public:
   MechanicContext(const MechanicNode* mechanicNode) :
     mMechanicNode(mechanicNode)
-  { }
+  { OpenFDMAssert(mMechanicNode); }
 
   virtual const MechanicNode& getNode() const
   { return *mMechanicNode; }



From frohlich at mail.berlios.de  Sat Sep 27 08:14:04 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 27 Sep 2008 08:14:04 +0200
Subject: [OpenFDM-svn] r502 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200809270614.m8R6E4ca026909@sheep.berlios.de>

Author: frohlich
Date: 2008-09-27 08:14:04 +0200 (Sat, 27 Sep 2008)
New Revision: 502

Modified:
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
USe port indices instead of id's for model connection.


Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-27 06:04:39 UTC (rev 501)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-27 06:14:04 UTC (rev 502)
@@ -702,11 +702,10 @@
     PortDataHelper::PortDataList* portDataList = buildNodeContext(leaf);
 
     OpenFDMAssert(leaf.getPort(0));
-    PortId portId = leaf.getPortId(0);
 
     PortDataHelper::ProviderPortData* providerPortData;
     providerPortData = portDataList->newProxyProviderPortData(leaf._groupInternalPort);
-    getCurrentNodePortDataMap()[portId] = providerPortData;
+    getCurrentNodePortDataMap()[0] = providerPortData;
   }
   // Aussen provider, innen acceptor
   virtual void apply(const GroupProviderNode& leaf)
@@ -714,11 +713,10 @@
     PortDataHelper::PortDataList* portDataList = buildNodeContext(leaf);
 
     OpenFDMAssert(leaf.getPort(0));
-    PortId portId = leaf.getPortId(0);
 
     PortDataHelper::AcceptorPortData* acceptorPortData;
     acceptorPortData = portDataList->newProxyAcceptorPortData(leaf._groupInternalPort);
-    getCurrentNodePortDataMap()[portId] = acceptorPortData;
+    getCurrentNodePortDataMap()[0] = acceptorPortData;
   }
 
   void allocPortData(AbstractNodeInstance* leafInstance, const LeafNode& leaf)
@@ -734,16 +732,14 @@
         PortDataHelper::ProviderPortData* providerPortData;
         providerPortData = portDataList->newProviderPortData(providerPort);
 
-        PortId portId = leaf.getPortId(i);
-        getCurrentNodePortDataMap()[portId] = providerPortData;
+        getCurrentNodePortDataMap()[i] = providerPortData;
       }
       const AcceptorPortInfo* acceptorPort = port->toAcceptorPortInfo();
       if (acceptorPort) {
         PortDataHelper::AcceptorPortData* acceptorPortData;
         acceptorPortData = portDataList->newAcceptorPortData(acceptorPort);
 
-        PortId portId = leaf.getPortId(i);
-        getCurrentNodePortDataMap()[portId] = acceptorPortData;
+        getCurrentNodePortDataMap()[i] = acceptorPortData;
       }
     }
   }
@@ -805,10 +801,8 @@
 
       SharedPtr<const AcceptorPortInfo> acceptorPort;
       acceptorPort = group.getConnectAcceptorPortInfo(i);
-      PortId acceptorPortId = SharedPtr<const PortInfo>(acceptorPort);
       SharedPtr<const ProviderPortInfo> providerPort;
       providerPort = group.getConnectProviderPortInfo(i);
-      PortId providerPortId = SharedPtr<const PortInfo>(providerPort);
 
       if (!acceptorPort) {
         std::cerr << "Cannot find acceptor Port data node "
@@ -821,8 +815,10 @@
         continue;
       }
 
-      if (!_portDataMap[acceptorNodeIndex][acceptorPortId]->
-          connect(_portDataMap[providerNodeIndex][providerPortId]))
+      unsigned acceptorPortNumber = acceptorPort->getIndex();
+      unsigned providerPortNumber = providerPort->getIndex();
+      if (!_portDataMap[acceptorNodeIndex][acceptorPortNumber]->
+          connect(_portDataMap[providerNodeIndex][providerPortNumber]))
         std::cerr << "Cannot connect????" << std::endl;
     }
 
@@ -836,8 +832,7 @@
     // add group connect routings
     // merge child list into the global list of instances
     for (unsigned i = 0; i < group.getNumPorts(); ++i) {
-      PortId portId = group.getPortId(i);
-      unsigned nodeIndex = group.getGroupPortNodeIndex(portId);
+      unsigned nodeIndex = group.getGroupPortNodeIndex(group.getPortId(i));
       if (childrenPortDataMap[nodeIndex].empty()) {
         // FIXME, is this an internal error ???
         std::cerr << "Hmm, cannot find GroupPortNode for external port "
@@ -860,7 +855,7 @@
 
         proxyProviderPortData->setProxyAcceptorPortData(proxyAcceptorPortData);
 
-        getCurrentNodePortDataMap()[portId] = proxyProviderPortData;
+        getCurrentNodePortDataMap()[i] = proxyProviderPortData;
 
       } else if (portData->toProxyProviderPortData()) {
         PortDataHelper::ProxyProviderPortData* proxyProviderPortData;
@@ -876,7 +871,7 @@
 
         proxyProviderPortData->setProxyAcceptorPortData(proxyAcceptorPortData);
 
-        getCurrentNodePortDataMap()[portId] = proxyAcceptorPortData;
+        getCurrentNodePortDataMap()[i] = proxyAcceptorPortData;
 
       } else {
         OpenFDMAssert(false);
@@ -900,7 +895,7 @@
 
   ////////////////////////////////////////////////////////////////////////////
   // Used to map connections in groups ...
-  typedef std::map<PortId, SharedPtr<PortDataHelper::PortData> > NodePortDataMap;
+  typedef std::map<unsigned, SharedPtr<PortDataHelper::PortData> > NodePortDataMap;
   typedef std::map<unsigned, NodePortDataMap> PortDataMap;
   PortDataMap _portDataMap;
   // Just to hold references to all mort data lists we have in the



From frohlich at mail.berlios.de  Sat Sep 27 08:55:27 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 27 Sep 2008 08:55:27 +0200
Subject: [OpenFDM-svn] r503 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200809270655.m8R6tRs1030137@sheep.berlios.de>

Author: frohlich
Date: 2008-09-27 08:55:27 +0200 (Sat, 27 Sep 2008)
New Revision: 503

Modified:
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Use vectors instead of maps where the index is an integer.


Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-27 06:14:04 UTC (rev 502)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-27 06:55:27 UTC (rev 503)
@@ -705,7 +705,7 @@
 
     PortDataHelper::ProviderPortData* providerPortData;
     providerPortData = portDataList->newProxyProviderPortData(leaf._groupInternalPort);
-    getCurrentNodePortDataMap()[0] = providerPortData;
+    setCurrentNodePortData(0, providerPortData);
   }
   // Aussen provider, innen acceptor
   virtual void apply(const GroupProviderNode& leaf)
@@ -716,7 +716,7 @@
 
     PortDataHelper::AcceptorPortData* acceptorPortData;
     acceptorPortData = portDataList->newProxyAcceptorPortData(leaf._groupInternalPort);
-    getCurrentNodePortDataMap()[0] = acceptorPortData;
+    setCurrentNodePortData(0, acceptorPortData);
   }
 
   void allocPortData(AbstractNodeInstance* leafInstance, const LeafNode& leaf)
@@ -732,14 +732,14 @@
         PortDataHelper::ProviderPortData* providerPortData;
         providerPortData = portDataList->newProviderPortData(providerPort);
 
-        getCurrentNodePortDataMap()[i] = providerPortData;
+        setCurrentNodePortData(i, providerPortData);
       }
       const AcceptorPortInfo* acceptorPort = port->toAcceptorPortInfo();
       if (acceptorPort) {
         PortDataHelper::AcceptorPortData* acceptorPortData;
         acceptorPortData = portDataList->newAcceptorPortData(acceptorPort);
 
-        getCurrentNodePortDataMap()[i] = acceptorPortData;
+        setCurrentNodePortData(i, acceptorPortData);
       }
     }
   }
@@ -772,7 +772,7 @@
   virtual void apply(const Group& group)
   {
     // Prepare a new leaf map for the child group
-    PortDataMap parentPortDataMap;
+    PortDataMap parentPortDataMap(group.getNumChildren());
     parentPortDataMap.swap(_portDataMap);
 
     // Walk the children
@@ -840,7 +840,8 @@
         continue;
       }
 
-      PortDataHelper::PortData* portData = childrenPortDataMap[nodeIndex].begin()->second;
+      PortDataHelper::PortData* portData;
+      portData = childrenPortDataMap[nodeIndex].front();
       if (portData->toProxyAcceptorPortData()) {
         PortDataHelper::ProxyAcceptorPortData* proxyAcceptorPortData;
         proxyAcceptorPortData = portData->toProxyAcceptorPortData();
@@ -855,7 +856,7 @@
 
         proxyProviderPortData->setProxyAcceptorPortData(proxyAcceptorPortData);
 
-        getCurrentNodePortDataMap()[i] = proxyProviderPortData;
+        setCurrentNodePortData(i, proxyProviderPortData);
 
       } else if (portData->toProxyProviderPortData()) {
         PortDataHelper::ProxyProviderPortData* proxyProviderPortData;
@@ -871,7 +872,7 @@
 
         proxyProviderPortData->setProxyAcceptorPortData(proxyAcceptorPortData);
 
-        getCurrentNodePortDataMap()[i] = proxyAcceptorPortData;
+        setCurrentNodePortData(i, proxyAcceptorPortData);
 
       } else {
         OpenFDMAssert(false);
@@ -895,8 +896,8 @@
 
   ////////////////////////////////////////////////////////////////////////////
   // Used to map connections in groups ...
-  typedef std::map<unsigned, SharedPtr<PortDataHelper::PortData> > NodePortDataMap;
-  typedef std::map<unsigned, NodePortDataMap> PortDataMap;
+  typedef std::vector<SharedPtr<PortDataHelper::PortData> > PortDataVector;
+  typedef std::vector<PortDataVector> PortDataMap;
   PortDataMap _portDataMap;
   // Just to hold references to all mort data lists we have in the
   // simulation system. They are just needed during traversal for connect
@@ -1000,10 +1001,14 @@
   void popNodeId()
   { mNodeIndexStack.pop_back(); }
 
-  NodePortDataMap& getCurrentNodePortDataMap()
+  void setCurrentNodePortData(unsigned i, PortDataHelper::PortData* portData)
   {
     OpenFDMAssert(!mNodeIndexStack.empty());
-    return _portDataMap[mNodeIndexStack.back()];
+    OpenFDMAssert(mNodeIndexStack.back() < _portDataMap.size());
+    PortDataVector& portDataVector = _portDataMap[mNodeIndexStack.back()];
+    if (portDataVector.size() <= i)
+      portDataVector.resize(i + 1);
+    portDataVector[i] = portData;
   }
 
 private:



From frohlich at mail.berlios.de  Sat Sep 27 10:03:46 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 27 Sep 2008 10:03:46 +0200
Subject: [OpenFDM-svn] r504 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200809270803.m8R83kG5002967@sheep.berlios.de>

Author: frohlich
Date: 2008-09-27 10:03:46 +0200 (Sat, 27 Sep 2008)
New Revision: 504

Modified:
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Use the correct port index for allocating new PortData.


Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-27 06:55:27 UTC (rev 503)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-27 08:03:46 UTC (rev 504)
@@ -626,28 +626,40 @@
     {
       AcceptorPortData* acceptorPortData;
       acceptorPortData = new AcceptorPortData(this, acceptorPort);
-      mPortDataVector.push_back(acceptorPortData);
+      unsigned index = acceptorPort->getIndex();
+      if (mPortDataVector.size() <= index)
+        mPortDataVector.resize(index + 1);
+      mPortDataVector[index] = acceptorPortData;
       return acceptorPortData;
     }
     ProviderPortData* newProviderPortData(const ProviderPortInfo* providerPort)
     {
       ProviderPortData* providerPortData;
       providerPortData = new ProviderPortData(this, providerPort);
-      mPortDataVector.push_back(providerPortData);
+      unsigned index = providerPort->getIndex();
+      if (mPortDataVector.size() <= index)
+        mPortDataVector.resize(index + 1);
+      mPortDataVector[index] = providerPortData;
       return providerPortData;
     }
     ProxyAcceptorPortData* newProxyAcceptorPortData(const AcceptorPortInfo* acceptorPort)
     {
       ProxyAcceptorPortData* acceptorPortData;
       acceptorPortData = new ProxyAcceptorPortData(this, acceptorPort);
-      mPortDataVector.push_back(acceptorPortData);
+      unsigned index = acceptorPort->getIndex();
+      if (mPortDataVector.size() <= index)
+        mPortDataVector.resize(index + 1);
+      mPortDataVector[index] = acceptorPortData;
       return acceptorPortData;
     }
     ProxyProviderPortData* newProxyProviderPortData(const ProviderPortInfo* providerPort)
     {
       ProxyProviderPortData* providerPortData;
       providerPortData = new ProxyProviderPortData(this, providerPort);
-      mPortDataVector.push_back(providerPortData);
+      unsigned index = providerPort->getIndex();
+      if (mPortDataVector.size() <= index)
+        mPortDataVector.resize(index + 1);
+      mPortDataVector[index] = providerPortData;
       return providerPortData;
     }
     



From frohlich at mail.berlios.de  Sat Sep 27 11:14:39 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 27 Sep 2008 11:14:39 +0200
Subject: [OpenFDM-svn] r505 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200809270914.m8R9EdQT008366@sheep.berlios.de>

Author: frohlich
Date: 2008-09-27 11:14:38 +0200 (Sat, 27 Sep 2008)
New Revision: 505

Modified:
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
PortData holds a reference to the NodeInstance instead of
its parent list. Use that directly.


Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-27 08:03:46 UTC (rev 504)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-27 09:14:38 UTC (rev 505)
@@ -470,8 +470,8 @@
 
   struct PortData : public WeakReferenced {
   public:
-    PortData(PortDataList* portDataList, const PortInfo* portInfo = 0) :
-      mParentPortDataList(portDataList),
+    PortData(AbstractNodeInstance* nodeInstance, const PortInfo* portInfo) :
+      mNodeInstance(nodeInstance),
       mPortInfo(portInfo)
     { }
     virtual ~PortData()
@@ -493,25 +493,21 @@
     {
       if (!getPortInfo())
         return;
-      SharedPtr<PortDataList> portDataList = mParentPortDataList.lock();
-      if (!portDataList)
+      if (!mNodeInstance)
         return;
-      SharedPtr<AbstractNodeInstance> nodeInstance = portDataList->mNodeInstance;
-      if (!nodeInstance)
-        return;
       unsigned index = getPortInfo()->getIndex();
-      nodeInstance->getPortValueList().setPortValue(index, portValue);
+      mNodeInstance->getPortValueList().setPortValue(index, portValue);
     }
 
   private:
-    WeakPtr<PortDataList> mParentPortDataList;
+    SharedPtr<AbstractNodeInstance> mNodeInstance;
     SharedPtr<const PortInfo> mPortInfo;
   };
 
   struct ProviderPortData : public PortData {
-    ProviderPortData(PortDataList* portDataList,
+    ProviderPortData(AbstractNodeInstance* nodeInstance,
                      const ProviderPortInfo* providerPort) :
-      PortData(portDataList, providerPort),
+      PortData(nodeInstance, providerPort),
       _providerPort(providerPort)
     { }
     virtual ProviderPortData* toProviderPortData()
@@ -546,9 +542,9 @@
     std::vector<SharedPtr<AcceptorPortData> > _acceptorPortDataList;
   };
   struct AcceptorPortData : public PortData {
-    AcceptorPortData(PortDataList* portDataList,
+    AcceptorPortData(AbstractNodeInstance* nodeInstance,
                      const AcceptorPortInfo* acceptorPort) :
-      PortData(portDataList, acceptorPort),
+      PortData(nodeInstance, acceptorPort),
       _acceptorPort(acceptorPort)
     { }
     virtual AcceptorPortData* toAcceptorPortData()
@@ -585,9 +581,9 @@
   };
   struct ProxyAcceptorPortData : public AcceptorPortData {
   public:
-    ProxyAcceptorPortData(PortDataList* portDataList,
+    ProxyAcceptorPortData(AbstractNodeInstance* nodeInstance,
                           const AcceptorPortInfo* acceptorPortInfo) :
-      AcceptorPortData(portDataList, acceptorPortInfo)
+      AcceptorPortData(nodeInstance, acceptorPortInfo)
     { }
     virtual ProxyAcceptorPortData* toProxyAcceptorPortData()
     { return this; }
@@ -600,9 +596,9 @@
   };
   struct ProxyProviderPortData : public ProviderPortData {
   public:
-    ProxyProviderPortData(PortDataList* portDataList,
+    ProxyProviderPortData(AbstractNodeInstance* nodeInstance,
                           const ProviderPortInfo* providerPortInfo) :
-      ProviderPortData(portDataList, providerPortInfo)
+      ProviderPortData(nodeInstance, providerPortInfo)
     { }
     virtual ProxyProviderPortData* toProxyProviderPortData()
     { return this; }
@@ -625,7 +621,7 @@
     AcceptorPortData* newAcceptorPortData(const AcceptorPortInfo* acceptorPort)
     {
       AcceptorPortData* acceptorPortData;
-      acceptorPortData = new AcceptorPortData(this, acceptorPort);
+      acceptorPortData = new AcceptorPortData(mNodeInstance, acceptorPort);
       unsigned index = acceptorPort->getIndex();
       if (mPortDataVector.size() <= index)
         mPortDataVector.resize(index + 1);
@@ -635,7 +631,7 @@
     ProviderPortData* newProviderPortData(const ProviderPortInfo* providerPort)
     {
       ProviderPortData* providerPortData;
-      providerPortData = new ProviderPortData(this, providerPort);
+      providerPortData = new ProviderPortData(mNodeInstance, providerPort);
       unsigned index = providerPort->getIndex();
       if (mPortDataVector.size() <= index)
         mPortDataVector.resize(index + 1);
@@ -645,7 +641,7 @@
     ProxyAcceptorPortData* newProxyAcceptorPortData(const AcceptorPortInfo* acceptorPort)
     {
       ProxyAcceptorPortData* acceptorPortData;
-      acceptorPortData = new ProxyAcceptorPortData(this, acceptorPort);
+      acceptorPortData = new ProxyAcceptorPortData(mNodeInstance, acceptorPort);
       unsigned index = acceptorPort->getIndex();
       if (mPortDataVector.size() <= index)
         mPortDataVector.resize(index + 1);
@@ -655,7 +651,7 @@
     ProxyProviderPortData* newProxyProviderPortData(const ProviderPortInfo* providerPort)
     {
       ProxyProviderPortData* providerPortData;
-      providerPortData = new ProxyProviderPortData(this, providerPort);
+      providerPortData = new ProxyProviderPortData(mNodeInstance, providerPort);
       unsigned index = providerPort->getIndex();
       if (mPortDataVector.size() <= index)
         mPortDataVector.resize(index + 1);



From frohlich at mail.berlios.de  Sat Sep 27 11:40:56 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 27 Sep 2008 11:40:56 +0200
Subject: [OpenFDM-svn] r506 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200809270940.m8R9eu21010380@sheep.berlios.de>

Author: frohlich
Date: 2008-09-27 11:40:56 +0200 (Sat, 27 Sep 2008)
New Revision: 506

Modified:
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Get rid of that node index stack.


Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-27 09:14:38 UTC (rev 505)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-27 09:40:56 UTC (rev 506)
@@ -614,9 +614,8 @@
   // Return true if this leaf directly depends on one of leafInstance outputs
   class PortDataList : public WeakReferenced {
   public:
-    PortDataList(AbstractNodeInstance* nodeInstance) :
-      mNodeInstance(nodeInstance)
-    { }
+    void setNodeInstance(AbstractNodeInstance* nodeInstance)
+    { mNodeInstance = nodeInstance; }
     
     AcceptorPortData* newAcceptorPortData(const AcceptorPortInfo* acceptorPort)
     {
@@ -698,9 +697,9 @@
     NodeInstance* nodeInstance;
     nodeInstance = new NodeInstance(mNodePath, &node);
     _nodeInstanceList.push_back(nodeInstance);
-    PortDataHelper::PortDataList* portDataList = new PortDataHelper::PortDataList(nodeInstance);
-    _portDataListList.push_back(portDataList);
-
+    PortDataHelper::PortDataList* portDataList;
+    portDataList = getCurrentNodePortDataList();
+    portDataList->setNodeInstance(nodeInstance);
     return portDataList;
   }
 
@@ -713,7 +712,6 @@
 
     PortDataHelper::ProviderPortData* providerPortData;
     providerPortData = portDataList->newProxyProviderPortData(leaf._groupInternalPort);
-    setCurrentNodePortData(0, providerPortData);
   }
   // Aussen provider, innen acceptor
   virtual void apply(const GroupProviderNode& leaf)
@@ -724,30 +722,25 @@
 
     PortDataHelper::AcceptorPortData* acceptorPortData;
     acceptorPortData = portDataList->newProxyAcceptorPortData(leaf._groupInternalPort);
-    setCurrentNodePortData(0, acceptorPortData);
   }
 
-  void allocPortData(AbstractNodeInstance* leafInstance, const LeafNode& leaf)
+  void allocPortData(AbstractNodeInstance* nodeInstance, const LeafNode& leaf)
   {
-    PortDataHelper::PortDataList* portDataList = new PortDataHelper::PortDataList(leafInstance);
-    _portDataListList.push_back(portDataList);
+    PortDataHelper::PortDataList* portDataList;
+    portDataList = getCurrentNodePortDataList();
+    portDataList->setNodeInstance(nodeInstance);
 
-    // FIXME: move to LeafInstance??
     for (unsigned i = 0; i < leaf.getNumPorts(); ++i) {
       SharedPtr<const PortInfo> port = leaf.getPort(i);
       const ProviderPortInfo* providerPort = port->toProviderPortInfo();
       if (providerPort) {
         PortDataHelper::ProviderPortData* providerPortData;
         providerPortData = portDataList->newProviderPortData(providerPort);
-
-        setCurrentNodePortData(i, providerPortData);
       }
       const AcceptorPortInfo* acceptorPort = port->toAcceptorPortInfo();
       if (acceptorPort) {
         PortDataHelper::AcceptorPortData* acceptorPortData;
         acceptorPortData = portDataList->newAcceptorPortData(acceptorPort);
-
-        setCurrentNodePortData(i, acceptorPortData);
       }
     }
   }
@@ -781,15 +774,25 @@
   {
     // Prepare a new leaf map for the child group
     PortDataMap parentPortDataMap(group.getNumChildren());
+    for (unsigned i = 0; i < group.getNumChildren(); ++i) {
+      PortDataHelper::PortDataList* portDataList;
+      portDataList = new PortDataHelper::PortDataList;
+      parentPortDataMap[i] = portDataList;
+      _portDataListList.push_back(portDataList);
+    }
     parentPortDataMap.swap(_portDataMap);
 
     // Walk the children
     for (unsigned i = 0; i < group.getNumChildren(); ++i) {
-      pushNodeId(i);
+      SharedPtr<PortDataHelper::PortDataList> parentNodePortDataList;
+      parentNodePortDataList.swap(mCurrentNodePortDataList);
+      mCurrentNodePortDataList = _portDataMap[i];
+
       mNodePath.push_back(group.getChild(i));
       group.getChild(i)->accept(*this);
       mNodePath.pop_back();
-      popNodeId();
+
+      parentNodePortDataList.swap(mCurrentNodePortDataList);
     }
 
     // Apply the group internal connections to the instances
@@ -825,12 +828,12 @@
 
       unsigned acceptorPortNumber = acceptorPort->getIndex();
       unsigned providerPortNumber = providerPort->getIndex();
-      if (!_portDataMap[acceptorNodeIndex][acceptorPortNumber]->
-          connect(_portDataMap[providerNodeIndex][providerPortNumber]))
+      if (!_portDataMap[acceptorNodeIndex]->mPortDataVector[acceptorPortNumber]->
+          connect(_portDataMap[providerNodeIndex]->mPortDataVector[providerPortNumber]))
         std::cerr << "Cannot connect????" << std::endl;
     }
 
-    PortDataHelper::PortDataList* portDataList = buildNodeContext(group);
+    SharedPtr<PortDataHelper::PortDataList> portDataList = buildNodeContext(group);
 
     parentPortDataMap.swap(_portDataMap);
     // Ok, some nameing niceness
@@ -841,7 +844,7 @@
     // merge child list into the global list of instances
     for (unsigned i = 0; i < group.getNumPorts(); ++i) {
       unsigned nodeIndex = group.getGroupPortNodeIndex(group.getPortId(i));
-      if (childrenPortDataMap[nodeIndex].empty()) {
+      if (childrenPortDataMap[nodeIndex]->mPortDataVector.empty()) {
         // FIXME, is this an internal error ???
         std::cerr << "Hmm, cannot find GroupPortNode for external port "
                   << i << std::endl;
@@ -849,7 +852,7 @@
       }
 
       PortDataHelper::PortData* portData;
-      portData = childrenPortDataMap[nodeIndex].front();
+      portData = childrenPortDataMap[nodeIndex]->mPortDataVector.front();
       if (portData->toProxyAcceptorPortData()) {
         PortDataHelper::ProxyAcceptorPortData* proxyAcceptorPortData;
         proxyAcceptorPortData = portData->toProxyAcceptorPortData();
@@ -864,8 +867,6 @@
 
         proxyProviderPortData->setProxyAcceptorPortData(proxyAcceptorPortData);
 
-        setCurrentNodePortData(i, proxyProviderPortData);
-
       } else if (portData->toProxyProviderPortData()) {
         PortDataHelper::ProxyProviderPortData* proxyProviderPortData;
         proxyProviderPortData = portData->toProxyProviderPortData();
@@ -880,8 +881,6 @@
 
         proxyProviderPortData->setProxyAcceptorPortData(proxyAcceptorPortData);
 
-        setCurrentNodePortData(i, proxyAcceptorPortData);
-
       } else {
         OpenFDMAssert(false);
       }
@@ -904,8 +903,7 @@
 
   ////////////////////////////////////////////////////////////////////////////
   // Used to map connections in groups ...
-  typedef std::vector<SharedPtr<PortDataHelper::PortData> > PortDataVector;
-  typedef std::vector<PortDataVector> PortDataMap;
+  typedef std::vector<SharedPtr<PortDataHelper::PortDataList> > PortDataMap;
   PortDataMap _portDataMap;
   // Just to hold references to all mort data lists we have in the
   // simulation system. They are just needed during traversal for connect
@@ -1004,24 +1002,16 @@
     return true;
   }
 
-  void pushNodeId(unsigned index)
-  { mNodeIndexStack.push_back(index); }
-  void popNodeId()
-  { mNodeIndexStack.pop_back(); }
-
-  void setCurrentNodePortData(unsigned i, PortDataHelper::PortData* portData)
+  PortDataHelper::PortDataList* getCurrentNodePortDataList()
   {
-    OpenFDMAssert(!mNodeIndexStack.empty());
-    OpenFDMAssert(mNodeIndexStack.back() < _portDataMap.size());
-    PortDataVector& portDataVector = _portDataMap[mNodeIndexStack.back()];
-    if (portDataVector.size() <= i)
-      portDataVector.resize(i + 1);
-    portDataVector[i] = portData;
+    if (!mCurrentNodePortDataList)
+      // will happen for the toplevel group node ..
+      mCurrentNodePortDataList = new PortDataHelper::PortDataList;
+    return mCurrentNodePortDataList;
   }
 
 private:
-  typedef std::list<unsigned> NodeIndexStack;
-  NodeIndexStack mNodeIndexStack;
+  SharedPtr<PortDataHelper::PortDataList> mCurrentNodePortDataList;
 
   NodePath mNodePath;
 };



From frohlich at mail.berlios.de  Sat Sep 27 11:42:09 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 27 Sep 2008 11:42:09 +0200
Subject: [OpenFDM-svn] r507 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200809270942.m8R9g9Pw010480@sheep.berlios.de>

Author: frohlich
Date: 2008-09-27 11:42:09 +0200 (Sat, 27 Sep 2008)
New Revision: 507

Modified:
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Remove unused fwd decl.


Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-27 09:40:56 UTC (rev 506)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-27 09:42:09 UTC (rev 507)
@@ -461,8 +461,6 @@
 // Just here so that I do not care for intationation order for now ...
 struct PortDataHelper {
 
-  class PortDataList;
-
   struct AcceptorPortData;
   struct ProviderPortData;
   struct ProxyAcceptorPortData;



From frohlich at mail.berlios.de  Sat Sep 27 12:06:18 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 27 Sep 2008 12:06:18 +0200
Subject: [OpenFDM-svn] r508 - in branches/OpenFDM-StateSeparation/src:
	OpenFDM test
Message-ID: <200809271006.m8RA6IKk012495@sheep.berlios.de>

Author: frohlich
Date: 2008-09-27 12:06:17 +0200 (Sat, 27 Sep 2008)
New Revision: 508

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/ConstNodeVisitor.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJoint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Group.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Input.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Joint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/LeafNode.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/LibraryNode.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJoint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Model.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Node.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Node.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Output.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/RigidBody.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/SimulationTime.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Move node path handling into the visitor.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/ConstNodeVisitor.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ConstNodeVisitor.h	2008-09-27 09:42:09 UTC (rev 507)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ConstNodeVisitor.h	2008-09-27 10:06:17 UTC (rev 508)
@@ -5,6 +5,8 @@
 #ifndef OpenFDM_ConstNodeVisitor_H
 #define OpenFDM_ConstNodeVisitor_H
 
+#include "Node.h"
+
 namespace OpenFDM {
 
 class Node;
@@ -42,6 +44,18 @@
 
   virtual void apply(const Interact&);
   virtual void apply(const RootJoint&);
+
+  const NodePath& getNodePath() const { return mNodePath; }
+
+  template<typename T>
+  void handleNodePathAndApply(T& node)
+  {
+    mNodePath.push_back(&node);
+    apply(node);
+    mNodePath.pop_back();
+  }
+private:
+  NodePath mNodePath;
 };
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJoint.cpp	2008-09-27 09:42:09 UTC (rev 507)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJoint.cpp	2008-09-27 10:06:17 UTC (rev 508)
@@ -33,7 +33,7 @@
 void
 FixedRootJoint::accept(ModelVisitor& visitor)
 {
-  visitor.apply(*this);
+  visitor.handleNodePathAndApply(*this);
 }
 
 bool

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Group.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Group.cpp	2008-09-27 09:42:09 UTC (rev 507)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Group.cpp	2008-09-27 10:06:17 UTC (rev 508)
@@ -35,13 +35,13 @@
 void
 Group::accept(NodeVisitor& visitor)
 {
-  visitor.apply(*this);
+  visitor.handleNodePathAndApply(*this);
 }
 
 void
 Group::accept(ConstNodeVisitor& visitor) const
 {
-  visitor.apply(*this);
+  visitor.handleNodePathAndApply(*this);
 }
 
 Group::NodeId

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Input.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Input.cpp	2008-09-27 09:42:09 UTC (rev 507)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Input.cpp	2008-09-27 10:06:17 UTC (rev 508)
@@ -31,7 +31,7 @@
 void
 Input::accept(ModelVisitor& visitor)
 {
-  visitor.apply(*this);
+  visitor.handleNodePathAndApply(*this);
 }
 
 const Input*

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.cpp	2008-09-27 09:42:09 UTC (rev 507)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.cpp	2008-09-27 10:06:17 UTC (rev 508)
@@ -24,13 +24,13 @@
 void
 Interact::accept(NodeVisitor& visitor)
 {
-  visitor.apply(*this);
+  visitor.handleNodePathAndApply(*this);
 }
 
 void
 Interact::accept(ConstNodeVisitor& visitor) const
 {
-  visitor.apply(*this);
+  visitor.handleNodePathAndApply(*this);
 }
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Joint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Joint.cpp	2008-09-27 09:42:09 UTC (rev 507)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Joint.cpp	2008-09-27 10:06:17 UTC (rev 508)
@@ -33,7 +33,7 @@
 void
 Joint::accept(ModelVisitor& visitor)
 {
-  visitor.apply(*this);
+  visitor.handleNodePathAndApply(*this);
 }
 
 void

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/LeafNode.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/LeafNode.cpp	2008-09-27 09:42:09 UTC (rev 507)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/LeafNode.cpp	2008-09-27 10:06:17 UTC (rev 508)
@@ -24,13 +24,13 @@
 void
 LeafNode::accept(NodeVisitor& visitor)
 {
-  visitor.apply(*this);
+  visitor.handleNodePathAndApply(*this);
 }
 
 void
 LeafNode::accept(ConstNodeVisitor& visitor) const
 {
-  visitor.apply(*this);
+  visitor.handleNodePathAndApply(*this);
 }
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/LibraryNode.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/LibraryNode.cpp	2008-09-27 09:42:09 UTC (rev 507)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/LibraryNode.cpp	2008-09-27 10:06:17 UTC (rev 508)
@@ -25,13 +25,13 @@
 void
 LibraryNode::accept(NodeVisitor& visitor)
 {
-  visitor.apply(*this);
+  visitor.handleNodePathAndApply(*this);
 }
 
 void
 LibraryNode::accept(ConstNodeVisitor& visitor) const
 {
-  visitor.apply(*this);
+  visitor.handleNodePathAndApply(*this);
 }
 
 SharedPtr<LibraryModel>

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.cpp	2008-09-27 09:42:09 UTC (rev 507)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.cpp	2008-09-27 10:06:17 UTC (rev 508)
@@ -24,13 +24,13 @@
 void
 MechanicNode::accept(NodeVisitor& visitor)
 {
-  visitor.apply(*this);
+  visitor.handleNodePathAndApply(*this);
 }
 
 void
 MechanicNode::accept(ConstNodeVisitor& visitor) const
 {
-  visitor.apply(*this);
+  visitor.handleNodePathAndApply(*this);
 }
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJoint.cpp	2008-09-27 09:42:09 UTC (rev 507)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJoint.cpp	2008-09-27 10:06:17 UTC (rev 508)
@@ -35,7 +35,7 @@
 void
 MobileRootJoint::accept(ModelVisitor& visitor)
 {
-  visitor.apply(*this);
+  visitor.handleNodePathAndApply(*this);
 }
 
 bool

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Model.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Model.cpp	2008-09-27 09:42:09 UTC (rev 507)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Model.cpp	2008-09-27 10:06:17 UTC (rev 508)
@@ -25,13 +25,13 @@
 void
 Model::accept(NodeVisitor& visitor)
 {
-  visitor.apply(*this);
+  visitor.handleNodePathAndApply(*this);
 }
 
 void
 Model::accept(ConstNodeVisitor& visitor) const
 {
-  visitor.apply(*this);
+  visitor.handleNodePathAndApply(*this);
 }
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Node.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Node.cpp	2008-09-27 09:42:09 UTC (rev 507)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Node.cpp	2008-09-27 10:06:17 UTC (rev 508)
@@ -24,13 +24,13 @@
 void
 Node::accept(NodeVisitor& visitor)
 {
-  visitor.apply(*this);
+  visitor.handleNodePathAndApply(*this);
 }
 
 void
 Node::accept(ConstNodeVisitor& visitor) const
 {
-  visitor.apply(*this);
+  visitor.handleNodePathAndApply(*this);
 }
 
 void

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Node.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Node.h	2008-09-27 09:42:09 UTC (rev 507)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Node.h	2008-09-27 10:06:17 UTC (rev 508)
@@ -14,9 +14,12 @@
 
 namespace OpenFDM {
 
+class Node;
 class NodeVisitor;
 class ConstNodeVisitor;
 
+typedef std::vector<SharedPtr<const Node> > NodePath;
+
 class Node : public Object {
   OPENFDM_OBJECT(Node, Object);
 public:

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.h	2008-09-27 09:42:09 UTC (rev 507)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.h	2008-09-27 10:06:17 UTC (rev 508)
@@ -5,6 +5,8 @@
 #ifndef OpenFDM_NodeVisitor_H
 #define OpenFDM_NodeVisitor_H
 
+#include "Node.h"
+
 namespace OpenFDM {
 
 class Node;
@@ -42,6 +44,19 @@
 
   virtual void apply(Interact&);
   virtual void apply(RootJoint&);
+
+  const NodePath& getNodePath() const { return mNodePath; }
+
+  template<typename T>
+  void handleNodePathAndApply(T& node)
+  {
+    mNodePath.push_back(&node);
+    apply(node);
+    mNodePath.pop_back();
+  }
+
+private:
+  NodePath mNodePath;
 };
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Output.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Output.cpp	2008-09-27 09:42:09 UTC (rev 507)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Output.cpp	2008-09-27 10:06:17 UTC (rev 508)
@@ -33,13 +33,13 @@
 void
 Output::accept(NodeVisitor& visitor)
 {
-  visitor.apply(*this);
+  visitor.handleNodePathAndApply(*this);
 }
 
 void
 Output::accept(ConstNodeVisitor& visitor) const
 {
-  visitor.apply(*this);
+  visitor.handleNodePathAndApply(*this);
 }
 
 void

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RigidBody.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RigidBody.cpp	2008-09-27 09:42:09 UTC (rev 507)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RigidBody.cpp	2008-09-27 10:06:17 UTC (rev 508)
@@ -24,13 +24,13 @@
 void
 RigidBody::accept(NodeVisitor& visitor)
 {
-  visitor.apply(*this);
+  visitor.handleNodePathAndApply(*this);
 }
 
 void
 RigidBody::accept(ConstNodeVisitor& visitor) const
 {
-  visitor.apply(*this);
+  visitor.handleNodePathAndApply(*this);
 }
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.cpp	2008-09-27 09:42:09 UTC (rev 507)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.cpp	2008-09-27 10:06:17 UTC (rev 508)
@@ -24,13 +24,13 @@
 void
 RootJoint::accept(NodeVisitor& visitor)
 {
-  visitor.apply(*this);
+  visitor.handleNodePathAndApply(*this);
 }
 
 void
 RootJoint::accept(ConstNodeVisitor& visitor) const
 {
-  visitor.apply(*this);
+  visitor.handleNodePathAndApply(*this);
 }
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/SimulationTime.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/SimulationTime.cpp	2008-09-27 09:42:09 UTC (rev 507)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/SimulationTime.cpp	2008-09-27 10:06:17 UTC (rev 508)
@@ -24,7 +24,7 @@
 void
 SimulationTime::accept(ModelVisitor& visitor)
 {
-  visitor.apply(*this);
+  visitor.handleNodePathAndApply(*this);
 }
 
 bool

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-09-27 09:42:09 UTC (rev 507)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-09-27 10:06:17 UTC (rev 508)
@@ -92,7 +92,7 @@
 void
 System::accept(ModelVisitor& visitor)
 {
-  visitor.apply(*this);
+  visitor.handleNodePathAndApply(*this);
 }
 
 static bool

Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-27 09:42:09 UTC (rev 507)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-27 10:06:17 UTC (rev 508)
@@ -103,8 +103,6 @@
 /// there must be a PortData like structure that is only built during simulation
 /// model initialization.
 
-typedef std::vector<SharedPtr<const Node> > NodePath;
-
 /// A NodeInstance represents an effective model node in a ready to run
 /// System. You can access the Nodes Ports values for example.
 /// This class is meant to show up in the user interface of this simulation.
@@ -693,7 +691,7 @@
   PortDataHelper::PortDataList* buildNodeContext(const Node& node)
   {
     NodeInstance* nodeInstance;
-    nodeInstance = new NodeInstance(mNodePath, &node);
+    nodeInstance = new NodeInstance(getNodePath(), &node);
     _nodeInstanceList.push_back(nodeInstance);
     PortDataHelper::PortDataList* portDataList;
     portDataList = getCurrentNodePortDataList();
@@ -747,7 +745,7 @@
   {
     // Need to stor the root nodes to build up the spanning tree for the
     // mechanical system here.
-    MechanicInstance* mechanicInstance = new MechanicInstance(mNodePath, &node);
+    MechanicInstance* mechanicInstance = new MechanicInstance(getNodePath(), &node);
     _nodeInstanceList.push_back(mechanicInstance);
 //     _mechanicInstanceList.push_back(mechanicInstance);
     _rootJointInstanceList.push_back(mechanicInstance);
@@ -755,14 +753,14 @@
   }
   virtual void apply(const MechanicNode& node)
   {
-    MechanicInstance* mechanicInstance = new MechanicInstance(mNodePath, &node);
+    MechanicInstance* mechanicInstance = new MechanicInstance(getNodePath(), &node);
     _nodeInstanceList.push_back(mechanicInstance);
     _mechanicInstanceList.push_back(mechanicInstance);
     allocPortData(mechanicInstance, node);
   }
   virtual void apply(const Model& node)
   {
-    ModelInstance* modelInstance = new ModelInstance(mNodePath, &node);
+    ModelInstance* modelInstance = new ModelInstance(getNodePath(), &node);
     _nodeInstanceList.push_back(modelInstance);
     _modelInstanceList.push_back(modelInstance);
     allocPortData(modelInstance, node);
@@ -786,9 +784,7 @@
       parentNodePortDataList.swap(mCurrentNodePortDataList);
       mCurrentNodePortDataList = _portDataMap[i];
 
-      mNodePath.push_back(group.getChild(i));
       group.getChild(i)->accept(*this);
-      mNodePath.pop_back();
 
       parentNodePortDataList.swap(mCurrentNodePortDataList);
     }
@@ -1010,8 +1006,6 @@
 
 private:
   SharedPtr<PortDataHelper::PortDataList> mCurrentNodePortDataList;
-
-  NodePath mNodePath;
 };
 
 



From frohlich at mail.berlios.de  Sat Sep 27 12:22:45 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 27 Sep 2008 12:22:45 +0200
Subject: [OpenFDM-svn] r509 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200809271022.m8RAMjZW014865@sheep.berlios.de>

Author: frohlich
Date: 2008-09-27 12:22:45 +0200 (Sat, 27 Sep 2008)
New Revision: 509

Modified:
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Update docs


Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-27 10:06:17 UTC (rev 508)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-27 10:22:45 UTC (rev 509)
@@ -94,23 +94,25 @@
 ///
 /// The NodeInstance is used to present the user a handle to the simulation
 /// models runtime data. Each instance has an execution context and a pointer
-/// to the actual node.
+/// to the actual node. That node might be used in more than one NodeInstance
+/// due to library models that can be referenced twice.
 ///
 /// For model execution we have a list of ModelContexs and a list of
-/// MechanicContexts. Both of them are derived from the NodeContext from above.
+/// MechanicContexts. Both of them are derived from the AbstractNodeContext
+/// from above.
 ///
 /// To connect the ports and propagate the port values over the NodeContexts
 /// there must be a PortData like structure that is only built during simulation
 /// model initialization.
 
-/// A NodeInstance represents an effective model node in a ready to run
-/// System. You can access the Nodes Ports values for example.
+/// An Abstract NodeInstance represents an effective model node in a ready
+/// to run System. You can access the Nodes Ports values for example.
 /// This class is meant to show up in the user interface of this simulation.
 class AbstractNodeInstance : public WeakReferenced {
 public:
   AbstractNodeInstance(const NodePath& nodePath) :
     mNodePath(nodePath)
-  { }
+  { OpenFDMAssert(!nodePath.empty()); }
   virtual ~AbstractNodeInstance()
   { }
 



From frohlich at mail.berlios.de  Sat Sep 27 12:54:04 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 27 Sep 2008 12:54:04 +0200
Subject: [OpenFDM-svn] r510 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200809271054.m8RAs4xt008682@sheep.berlios.de>

Author: frohlich
Date: 2008-09-27 12:54:02 +0200 (Sat, 27 Sep 2008)
New Revision: 510

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/ConstNodeVisitor.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Group.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/LeafNode.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/LibraryNode.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Model.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Node.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Output.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/RigidBody.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.cpp
Log:
Use pointers instead of references for the node path handling.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/ConstNodeVisitor.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ConstNodeVisitor.h	2008-09-27 10:22:45 UTC (rev 509)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ConstNodeVisitor.h	2008-09-27 10:54:02 UTC (rev 510)
@@ -5,6 +5,7 @@
 #ifndef OpenFDM_ConstNodeVisitor_H
 #define OpenFDM_ConstNodeVisitor_H
 
+#include "Assert.h"
 #include "Node.h"
 
 namespace OpenFDM {
@@ -48,10 +49,11 @@
   const NodePath& getNodePath() const { return mNodePath; }
 
   template<typename T>
-  void handleNodePathAndApply(T& node)
+  void handleNodePathAndApply(const T* node)
   {
-    mNodePath.push_back(&node);
-    apply(node);
+    OpenFDMAssert(node);
+    mNodePath.push_back(node);
+    apply(*node);
     mNodePath.pop_back();
   }
 private:

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Group.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Group.cpp	2008-09-27 10:22:45 UTC (rev 509)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Group.cpp	2008-09-27 10:54:02 UTC (rev 510)
@@ -35,13 +35,13 @@
 void
 Group::accept(NodeVisitor& visitor)
 {
-  visitor.handleNodePathAndApply(*this);
+  visitor.handleNodePathAndApply(this);
 }
 
 void
 Group::accept(ConstNodeVisitor& visitor) const
 {
-  visitor.handleNodePathAndApply(*this);
+  visitor.handleNodePathAndApply(this);
 }
 
 Group::NodeId

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.cpp	2008-09-27 10:22:45 UTC (rev 509)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Interact.cpp	2008-09-27 10:54:02 UTC (rev 510)
@@ -24,13 +24,13 @@
 void
 Interact::accept(NodeVisitor& visitor)
 {
-  visitor.handleNodePathAndApply(*this);
+  visitor.handleNodePathAndApply(this);
 }
 
 void
 Interact::accept(ConstNodeVisitor& visitor) const
 {
-  visitor.handleNodePathAndApply(*this);
+  visitor.handleNodePathAndApply(this);
 }
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/LeafNode.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/LeafNode.cpp	2008-09-27 10:22:45 UTC (rev 509)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/LeafNode.cpp	2008-09-27 10:54:02 UTC (rev 510)
@@ -24,13 +24,13 @@
 void
 LeafNode::accept(NodeVisitor& visitor)
 {
-  visitor.handleNodePathAndApply(*this);
+  visitor.handleNodePathAndApply(this);
 }
 
 void
 LeafNode::accept(ConstNodeVisitor& visitor) const
 {
-  visitor.handleNodePathAndApply(*this);
+  visitor.handleNodePathAndApply(this);
 }
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/LibraryNode.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/LibraryNode.cpp	2008-09-27 10:22:45 UTC (rev 509)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/LibraryNode.cpp	2008-09-27 10:54:02 UTC (rev 510)
@@ -25,13 +25,13 @@
 void
 LibraryNode::accept(NodeVisitor& visitor)
 {
-  visitor.handleNodePathAndApply(*this);
+  visitor.handleNodePathAndApply(this);
 }
 
 void
 LibraryNode::accept(ConstNodeVisitor& visitor) const
 {
-  visitor.handleNodePathAndApply(*this);
+  visitor.handleNodePathAndApply(this);
 }
 
 SharedPtr<LibraryModel>

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.cpp	2008-09-27 10:22:45 UTC (rev 509)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.cpp	2008-09-27 10:54:02 UTC (rev 510)
@@ -24,13 +24,13 @@
 void
 MechanicNode::accept(NodeVisitor& visitor)
 {
-  visitor.handleNodePathAndApply(*this);
+  visitor.handleNodePathAndApply(this);
 }
 
 void
 MechanicNode::accept(ConstNodeVisitor& visitor) const
 {
-  visitor.handleNodePathAndApply(*this);
+  visitor.handleNodePathAndApply(this);
 }
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Model.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Model.cpp	2008-09-27 10:22:45 UTC (rev 509)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Model.cpp	2008-09-27 10:54:02 UTC (rev 510)
@@ -25,13 +25,13 @@
 void
 Model::accept(NodeVisitor& visitor)
 {
-  visitor.handleNodePathAndApply(*this);
+  visitor.handleNodePathAndApply(this);
 }
 
 void
 Model::accept(ConstNodeVisitor& visitor) const
 {
-  visitor.handleNodePathAndApply(*this);
+  visitor.handleNodePathAndApply(this);
 }
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Node.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Node.cpp	2008-09-27 10:22:45 UTC (rev 509)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Node.cpp	2008-09-27 10:54:02 UTC (rev 510)
@@ -24,13 +24,13 @@
 void
 Node::accept(NodeVisitor& visitor)
 {
-  visitor.handleNodePathAndApply(*this);
+  visitor.handleNodePathAndApply(this);
 }
 
 void
 Node::accept(ConstNodeVisitor& visitor) const
 {
-  visitor.handleNodePathAndApply(*this);
+  visitor.handleNodePathAndApply(this);
 }
 
 void

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.h	2008-09-27 10:22:45 UTC (rev 509)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/NodeVisitor.h	2008-09-27 10:54:02 UTC (rev 510)
@@ -5,6 +5,7 @@
 #ifndef OpenFDM_NodeVisitor_H
 #define OpenFDM_NodeVisitor_H
 
+#include "Assert.h"
 #include "Node.h"
 
 namespace OpenFDM {
@@ -48,10 +49,11 @@
   const NodePath& getNodePath() const { return mNodePath; }
 
   template<typename T>
-  void handleNodePathAndApply(T& node)
+  void handleNodePathAndApply(T* node)
   {
-    mNodePath.push_back(&node);
-    apply(node);
+    OpenFDMAssert(node);
+    mNodePath.push_back(node);
+    apply(*node);
     mNodePath.pop_back();
   }
 

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Output.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Output.cpp	2008-09-27 10:22:45 UTC (rev 509)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Output.cpp	2008-09-27 10:54:02 UTC (rev 510)
@@ -33,13 +33,13 @@
 void
 Output::accept(NodeVisitor& visitor)
 {
-  visitor.handleNodePathAndApply(*this);
+  visitor.handleNodePathAndApply(this);
 }
 
 void
 Output::accept(ConstNodeVisitor& visitor) const
 {
-  visitor.handleNodePathAndApply(*this);
+  visitor.handleNodePathAndApply(this);
 }
 
 void

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RigidBody.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RigidBody.cpp	2008-09-27 10:22:45 UTC (rev 509)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RigidBody.cpp	2008-09-27 10:54:02 UTC (rev 510)
@@ -24,13 +24,13 @@
 void
 RigidBody::accept(NodeVisitor& visitor)
 {
-  visitor.handleNodePathAndApply(*this);
+  visitor.handleNodePathAndApply(this);
 }
 
 void
 RigidBody::accept(ConstNodeVisitor& visitor) const
 {
-  visitor.handleNodePathAndApply(*this);
+  visitor.handleNodePathAndApply(this);
 }
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.cpp	2008-09-27 10:22:45 UTC (rev 509)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RootJoint.cpp	2008-09-27 10:54:02 UTC (rev 510)
@@ -24,13 +24,13 @@
 void
 RootJoint::accept(NodeVisitor& visitor)
 {
-  visitor.handleNodePathAndApply(*this);
+  visitor.handleNodePathAndApply(this);
 }
 
 void
 RootJoint::accept(ConstNodeVisitor& visitor) const
 {
-  visitor.handleNodePathAndApply(*this);
+  visitor.handleNodePathAndApply(this);
 }
 
 } // namespace OpenFDM



From frohlich at mail.berlios.de  Sat Sep 27 12:58:28 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 27 Sep 2008 12:58:28 +0200
Subject: [OpenFDM-svn] r511 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200809271058.m8RAwS9x013836@sheep.berlios.de>

Author: frohlich
Date: 2008-09-27 12:58:26 +0200 (Sat, 27 Sep 2008)
New Revision: 511

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Assert.h
Log:
Hmm, make asserts work somehow ...


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Assert.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Assert.h	2008-09-27 10:54:02 UTC (rev 510)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Assert.h	2008-09-27 10:58:26 UTC (rev 511)
@@ -7,7 +7,8 @@
 
 #include "OpenFDMConfig.h"
 
-#if !defined(NDEBUG) && (OpenFDM_ENABLE_DEBUG == 1)
+// FIXME, appears not to work currently ...
+#if !defined(NDEBUG) //&& (OpenFDM_ENABLE_DEBUG == 1)
 # define OpenFDMDebug
 #endif
 



From frohlich at mail.berlios.de  Sat Sep 27 13:59:33 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 27 Sep 2008 13:59:33 +0200
Subject: [OpenFDM-svn] r512 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200809271159.m8RBxXnq017034@sheep.berlios.de>

Author: frohlich
Date: 2008-09-27 13:59:32 +0200 (Sat, 27 Sep 2008)
New Revision: 512

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Integrator.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Integrator.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/MatrixInputPort.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/PortInfo.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/PortInfo.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/RealInputPort.h
Log:
Allow ports to be enabled and disabled.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Integrator.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Integrator.cpp	2008-09-27 10:58:26 UTC (rev 511)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Integrator.cpp	2008-09-27 11:59:32 UTC (rev 512)
@@ -11,13 +11,13 @@
 
 BEGIN_OPENFDM_OBJECT_DEF(Integrator, Model)
   DEF_OPENFDM_PROPERTY(Matrix, InitialValue, Serialized)
+  DEF_OPENFDM_PROPERTY(Bool, EnableInitialValuePort, Serialized)
   END_OPENFDM_OBJECT_DEF
 
 Integrator::Integrator(const std::string& name = std::string()) :
   Model(name),
   mInputPort(newMatrixInputPort("input", false)),
-  mOutputPort(newMatrixOutputPort("output")),
-  mInitialValuePort(newMatrixInputPort("initialValue", true))
+  mOutputPort(newMatrixOutputPort("output"))
 {
   mMatrixStateInfo = new MatrixStateInfo;
   addContinousStateInfo(mMatrixStateInfo);
@@ -81,4 +81,19 @@
   return mInitialValue;
 }
 
+void
+Integrator::setEnableInitialValuePort(bool enable)
+{
+  if (enable && !mInitialValuePort.empty())
+    mInitialValuePort = newMatrixInputPort("initialValue", true);
+  else if (!enable && mInitialValuePort.empty())
+    mInitialValuePort.clear();
+}
+
+bool
+Integrator::getEnableInitialValuePort() const
+{
+  return mInitialValuePort.empty();
+}
+
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Integrator.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Integrator.h	2008-09-27 10:58:26 UTC (rev 511)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Integrator.h	2008-09-27 11:59:32 UTC (rev 512)
@@ -27,6 +27,9 @@
   void setInitialValue(const Matrix& initialValue);
   const Matrix& getInitialValue() const;
 
+  void setEnableInitialValuePort(bool enable);
+  bool getEnableInitialValuePort() const;
+
 private:
   MatrixInputPort mInputPort;
   MatrixOutputPort mOutputPort;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MatrixInputPort.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MatrixInputPort.h	2008-09-27 10:58:26 UTC (rev 511)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MatrixInputPort.h	2008-09-27 11:59:32 UTC (rev 512)
@@ -13,23 +13,30 @@
 
 class MatrixInputPort {
 public:
+  MatrixInputPort()
+  { }
   MatrixInputPort(Node* node, const std::string& name,
                   const Size& size, bool directInput) :
     mPort(new NumericAcceptorPortInfo(node, name, size, directInput))
-  {}
+  { }
   NumericPortValue* getPortValue(const PortValueVector& portValueVector) const
   {
+    OpenFDMAssert(mPort);
     PortValue* portValue = mPort->getPortValue(portValueVector);
     OpenFDMAssert(portValue);
     OpenFDMAssert(dynamic_cast<NumericPortValue*>(portValue));
     return static_cast<NumericPortValue*>(portValue);
   }
+  bool empty() const
+  { return mPort; }
+  void clear()
+  { if (!mPort) return; mPort->clear(); mPort = 0; }
   unsigned getPortIndex() const
-  { return mPort->getIndex(); }
+  { OpenFDMAssert(mPort); return mPort->getIndex(); }
   bool getDirectInput() const
-  { return mPort->getDirectInput(); }
+  { OpenFDMAssert(mPort); return mPort->getDirectInput(); }
   void setDirectInput(bool directInput) const
-  { mPort->setDirectInput(directInput); }
+  { OpenFDMAssert(mPort); mPort->setDirectInput(directInput); }
 private:
   SharedPtr<NumericAcceptorPortInfo> mPort;
 };

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/PortInfo.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/PortInfo.cpp	2008-09-27 10:58:26 UTC (rev 511)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/PortInfo.cpp	2008-09-27 11:59:32 UTC (rev 512)
@@ -18,9 +18,7 @@
 
 PortInfo::~PortInfo()
 {
-  SharedPtr<Node> node = mNode.lock();
-  if (node)
-    node->removePort(this);
+  clear();
 }
 
 void
@@ -29,4 +27,13 @@
   mName = name;
 }
 
+void
+PortInfo::clear()
+{
+  SharedPtr<Node> node = mNode.lock();
+  if (!node)
+    return;
+  node->removePort(this);
+}
+
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/PortInfo.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/PortInfo.h	2008-09-27 10:58:26 UTC (rev 511)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/PortInfo.h	2008-09-27 11:59:32 UTC (rev 512)
@@ -61,6 +61,8 @@
     return portValueVector[index];
   }
 
+  void clear();
+
 private:
   PortInfo(const PortInfo&);
   PortInfo& operator=(const PortInfo&);

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/RealInputPort.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/RealInputPort.h	2008-09-27 10:58:26 UTC (rev 511)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/RealInputPort.h	2008-09-27 11:59:32 UTC (rev 512)
@@ -13,22 +13,29 @@
 
 class RealInputPort {
 public:
+  RealInputPort()
+  { }
   RealInputPort(Node* node, const std::string& name, bool directInput) :
     mPort(new NumericAcceptorPortInfo(node, name, Size(1, 1), directInput))
-  {}
+  { }
   NumericPortValue* getPortValue(const PortValueVector& portValueVector) const
   {
+    OpenFDMAssert(mPort);
     PortValue* portValue = mPort->getPortValue(portValueVector);
     OpenFDMAssert(portValue);
     OpenFDMAssert(dynamic_cast<NumericPortValue*>(portValue));
     return static_cast<NumericPortValue*>(portValue);
   }
+  bool empty() const
+  { return mPort; }
+  void clear()
+  { if (!mPort) return; mPort->clear(); mPort = 0; }
   unsigned getPortIndex() const
-  { return mPort->getIndex(); }
+  { OpenFDMAssert(mPort); return mPort->getIndex(); }
   bool getDirectInput() const
-  { return mPort->getDirectInput(); }
+  { OpenFDMAssert(mPort); return mPort->getDirectInput(); }
   void setDirectInput(bool directInput) const
-  { mPort->setDirectInput(directInput); }
+  { OpenFDMAssert(mPort); mPort->setDirectInput(directInput); }
 private:
   SharedPtr<NumericAcceptorPortInfo> mPort;
 };



From frohlich at mail.berlios.de  Sat Sep 27 17:30:16 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 27 Sep 2008 17:30:16 +0200
Subject: [OpenFDM-svn] r513 -
	branches/OpenFDM-StateSeparation/src/OpenFDM/LinAlg
Message-ID: <200809271530.m8RFUFEJ002128@sheep.berlios.de>

Author: frohlich
Date: 2008-09-27 17:30:14 +0200 (Sat, 27 Sep 2008)
New Revision: 513

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/LinAlg/Container.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/LinAlg/IO.h
Log:
Updates to the linuea algebra stuff.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/LinAlg/Container.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/LinAlg/Container.h	2008-09-27 11:59:32 UTC (rev 512)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/LinAlg/Container.h	2008-09-27 15:30:14 UTC (rev 513)
@@ -144,6 +144,15 @@
   Matrix& operator*=(value_type scalar)
   { scalarMultiplyMatrix(*this, scalar); return *this; }
 
+  static Matrix zeros(size_type r, size_type c)
+  {
+    Matrix ret(r, c);
+    for (size_type i = 0; i < r; ++i)
+      for (size_type j = 0; j < c; ++j)
+        ret(i, j) = 0;
+    return ret;
+  }
+
 private:
   using MatrixLValue<Matrix<T,rows_,cols_>,rows_,cols_>::assign;
   RectangularArray<T,rows_,cols_> data_;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/LinAlg/IO.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/LinAlg/IO.h	2008-09-27 11:59:32 UTC (rev 512)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/LinAlg/IO.h	2008-09-27 15:30:14 UTC (rev 513)
@@ -38,18 +38,16 @@
 
   size_type rows = A.asImpl().rows();
   size_type cols = A.asImpl().cols();
-  size_type i, j;
-  for (i = 0; i < rows; ++i) {
-    if (i == 0)
-      os << '[';
-    else
-      os << ' ';
+  os << os.widen('[');
+  for (size_type i = 0; i < rows; ++i) {
+    if (0 < i)
+      os << os.widen(' ');
 
-    for (j = 0; j < cols; ++j) {
+    for (size_type j = 0; j < cols; ++j) {
       value_type val = A.asImpl()(i, j);
     
       if (val == 0) {
-        os << std::setw(width) << '0' << ' ';
+        os << std::setw(width) << os.widen('0') << os.widen(' ');
       } else {
         int expo = static_cast<int>(floor(fabs(log10(fabs(val)))));
         
@@ -59,15 +57,14 @@
           os << std::setprecision(width-8);
         }
         
-        os << std::setw(width) << val << ' ';
+        os << std::setw(width) << val << os.widen(' ');
       }
     }
 
-    if (i == rows-1)
-      os << ']';
-    else
+    if (i < rows-1)
       os << std::endl;
   }
+  os << os.widen(']');
 
   // Restore old flags.
   os.flags(old_flags);



From frohlich at mail.berlios.de  Sat Sep 27 17:42:47 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 27 Sep 2008 17:42:47 +0200
Subject: [OpenFDM-svn] r514 - in branches/OpenFDM-StateSeparation/src:
	OpenFDM test
Message-ID: <200809271542.m8RFgl0N003360@sheep.berlios.de>

Author: frohlich
Date: 2008-09-27 17:42:47 +0200 (Sat, 27 Sep 2008)
New Revision: 514

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Gain.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Integrator.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/MatrixStateValue.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/NumericPortValue.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/PortValueList.h
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Make port allocation work somehow.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.cpp	2008-09-27 15:30:14 UTC (rev 513)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.cpp	2008-09-27 15:42:47 UTC (rev 514)
@@ -23,7 +23,8 @@
   Model(name),
   mInputPort(newMatrixInputPort("input", true)),
   mOutputPort(newMatrixOutputPort("output")),
-  mDelay(0)
+  mDelay(0),
+  mInitialValue(Matrix::zeros(1, 1))
 {
   mMatrixStateInfo = new MatrixListStateInfo;
   addDiscreteStateInfo(mMatrixStateInfo);
@@ -36,8 +37,20 @@
 bool
 Delay::alloc(LeafContext& leafContext) const
 {
-  Size sz = size(leafContext.mPortValueList[mInputPort]);
-  leafContext.mPortValueList.setPortSize(mOutputPort, sz);
+  Size sz = size(mInitialValue);
+  Log(Initialization, Debug)
+    << "Size for Delay is detemined by the static initial value "
+    << "with size: " << trans(sz) << std::endl;
+  if (!leafContext.mPortValueList.setOrCheckPortSize(mInputPort, sz)) {
+    Log(Initialization, Error)
+      << "Size for input port does not match!" << std::endl;
+    return false;
+  }
+  if (!leafContext.mPortValueList.setOrCheckPortSize(mOutputPort, sz)) {
+    Log(Initialization, Error)
+      << "Size for output port does not match!" << std::endl;
+    return false;
+  }
   leafContext.mDiscreteState.setValue(*mMatrixStateInfo, leafContext);
   return true;
 }

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Gain.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Gain.cpp	2008-09-27 15:30:14 UTC (rev 513)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Gain.cpp	2008-09-27 15:42:47 UTC (rev 514)
@@ -35,7 +35,14 @@
 Gain::alloc(LeafContext& leafContext) const
 {
   Size sz = size(leafContext.mPortValueList[mInputPort]);
-  leafContext.mPortValueList.setPortSize(mOutputPort, sz);
+  Log(Initialization, Debug)
+    << "Size for Gain is detemined by the input port with size: "
+    << trans(sz) << std::endl;
+  if (!leafContext.mPortValueList.setOrCheckPortSize(mOutputPort, sz)) {
+    Log(Initialization, Error)
+      << "Size for output port does not match!" << std::endl;
+    return false;
+  }
   return true;
 }
 

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Integrator.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Integrator.cpp	2008-09-27 15:30:14 UTC (rev 513)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Integrator.cpp	2008-09-27 15:42:47 UTC (rev 514)
@@ -17,7 +17,8 @@
 Integrator::Integrator(const std::string& name = std::string()) :
   Model(name),
   mInputPort(newMatrixInputPort("input", false)),
-  mOutputPort(newMatrixOutputPort("output"))
+  mOutputPort(newMatrixOutputPort("output")),
+  mInitialValue(Matrix::zeros(1, 1))
 {
   mMatrixStateInfo = new MatrixStateInfo;
   addContinousStateInfo(mMatrixStateInfo);
@@ -30,8 +31,28 @@
 bool
 Integrator::alloc(LeafContext& leafContext) const
 {
-  Size sz = size(leafContext.mPortValueList[mInputPort]);
-  leafContext.mPortValueList.setPortSize(mOutputPort, sz);
+  Size sz;
+  if (getEnableInitialValuePort()) {
+    sz = size(leafContext.mPortValueList[mInitialValuePort]);
+    Log(Initialization, Debug)
+      << "Size for Integrator is detemined by the initial input "
+      << "port with size: " << trans(sz) << std::endl;
+  } else {
+    sz = size(mInitialValue);
+    Log(Initialization, Debug)
+      << "Size for Integrator is detemined by the static initial value "
+      << "with size: " << trans(sz) << std::endl;
+  }
+  if (!leafContext.mPortValueList.setOrCheckPortSize(mInputPort, sz)) {
+    Log(Initialization, Error)
+      << "Size for input port does not match!" << std::endl;
+    return false;
+  }
+  if (!leafContext.mPortValueList.setOrCheckPortSize(mOutputPort, sz)) {
+    Log(Initialization, Error)
+      << "Size for input port does not match!" << std::endl;
+    return false;
+  }
   leafContext.mContinousState.setValue(*mMatrixStateInfo, leafContext);
   return true;
 }
@@ -43,13 +64,14 @@
   // Needs to be done here. Need port values???
   // FIXME, can I ensure that at least the direct dependent ones are
   // available and the other ones are inaccessible at compile time?
-//     if (portValues.isConnected(mInitialValuePort)) {
-//       // external initial condition
-//       continousState[*mMatrixStateInfo] = portValues[mInitialValuePort];
-//     } else {
+  if (getEnableInitialValuePort()) {
+    // external initial condition
+//     continousState[*mMatrixStateInfo] = portValues[mInitialValuePort];
+    continousState[*mMatrixStateInfo].clear();
+  } else {
     // internal initial condition
-    continousState[*mMatrixStateInfo].clear(); // FIXME
-//     }
+    continousState[*mMatrixStateInfo] = mInitialValue;
+  }
 }
 
 void
@@ -57,7 +79,12 @@
                    const ContinousStateValueVector& continousState,
                    PortValueList& portValues) const
 {
-  portValues[mOutputPort] = continousState[*mMatrixStateInfo];
+  // FIXME
+  if (getEnableInitialValuePort()
+      && size(continousState[*mMatrixStateInfo]) == Size(0, 0))
+    portValues[mOutputPort] = portValues[mInitialValuePort];
+  else
+    portValues[mOutputPort] = continousState[*mMatrixStateInfo];
 }
 
 void
@@ -84,9 +111,12 @@
 void
 Integrator::setEnableInitialValuePort(bool enable)
 {
-  if (enable && !mInitialValuePort.empty())
+  if (enable == getEnableInitialValuePort())
+    return;
+
+  if (enable)
     mInitialValuePort = newMatrixInputPort("initialValue", true);
-  else if (!enable && mInitialValuePort.empty())
+  else 
     mInitialValuePort.clear();
 }
 

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MatrixStateValue.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MatrixStateValue.h	2008-09-27 15:30:14 UTC (rev 513)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MatrixStateValue.h	2008-09-27 15:42:47 UTC (rev 514)
@@ -12,13 +12,13 @@
 
 class MatrixStateValue : public ContinousStateValue {
 public:
-  MatrixStateValue(const Size& size) : mMatrix(size)
+  MatrixStateValue(const Size& size) : mMatrix(size(0), size(1))
   { }
   MatrixStateValue()
   { }
 
   void resize(const Size& size)
-  { mMatrix.resize(size); }
+  { mMatrix.resize(size(0), size(1)); }
 
   const Matrix& getMatrix() const
   { return mMatrix; }

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/NumericPortValue.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/NumericPortValue.cpp	2008-09-27 15:30:14 UTC (rev 513)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/NumericPortValue.cpp	2008-09-27 15:42:47 UTC (rev 514)
@@ -7,7 +7,7 @@
 namespace OpenFDM {
 
 NumericPortValue::NumericPortValue(const Size& size) :
-  mMatrix(size)
+  mMatrix(size(0), size(1))
 {
   mMatrix.clear();
 }

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/PortValueList.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/PortValueList.h	2008-09-27 15:30:14 UTC (rev 513)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/PortValueList.h	2008-09-27 15:42:47 UTC (rev 514)
@@ -76,10 +76,30 @@
       mPortValueVector.resize(idx+1);
     mPortValueVector[idx] = portValue;
   }
-  void setPortSize(const MatrixOutputPort& port, const Size& size)
+  bool setOrCheckPortSize(const MatrixOutputPort& port, const Size& sz)
   {
-    port.getPortValue(mPortValueVector)->getValue().resize(size);
+    Size oldSize = size(port.getPortValue(mPortValueVector)->getValue());
+    // If the size is still 0x0, just set to the desired size
+    if (oldSize(0) == 0 || oldSize(1) == 0) {
+      port.getPortValue(mPortValueVector)->getValue().resize(sz(0), sz(1));
+      return true;
+    } else if (oldSize == sz)
+      return true;
+    else
+      return false;
   }
+  bool setOrCheckPortSize(const MatrixInputPort& port, const Size& sz)
+  {
+    Size oldSize = size(port.getPortValue(mPortValueVector)->getValue());
+    // If the size is still 0x0, just set to the desired size
+    if (oldSize(0) == 0 || oldSize(1) == 0) {
+      port.getPortValue(mPortValueVector)->getValue().resize(sz(0), sz(1));
+      return true;
+    } else if (oldSize == sz)
+      return true;
+    else
+      return false;
+  }
   const PortValue* getPortValue(unsigned idx) const
   {
     if (mPortValueVector.size() <= idx)

Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-27 15:30:14 UTC (rev 513)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-27 15:42:47 UTC (rev 514)
@@ -613,46 +613,38 @@
   class PortDataList : public WeakReferenced {
   public:
     void setNodeInstance(AbstractNodeInstance* nodeInstance)
-    { mNodeInstance = nodeInstance; }
+    {
+      OpenFDMAssert(!mNodeInstance);
+      mNodeInstance = nodeInstance;
+      mPortDataVector.resize(nodeInstance->getNode().getNumPorts());
+    }
     
     AcceptorPortData* newAcceptorPortData(const AcceptorPortInfo* acceptorPort)
     {
       AcceptorPortData* acceptorPortData;
       acceptorPortData = new AcceptorPortData(mNodeInstance, acceptorPort);
-      unsigned index = acceptorPort->getIndex();
-      if (mPortDataVector.size() <= index)
-        mPortDataVector.resize(index + 1);
-      mPortDataVector[index] = acceptorPortData;
+      mPortDataVector[acceptorPort->getIndex()] = acceptorPortData;
       return acceptorPortData;
     }
     ProviderPortData* newProviderPortData(const ProviderPortInfo* providerPort)
     {
       ProviderPortData* providerPortData;
       providerPortData = new ProviderPortData(mNodeInstance, providerPort);
-      unsigned index = providerPort->getIndex();
-      if (mPortDataVector.size() <= index)
-        mPortDataVector.resize(index + 1);
-      mPortDataVector[index] = providerPortData;
+      mPortDataVector[providerPort->getIndex()] = providerPortData;
       return providerPortData;
     }
     ProxyAcceptorPortData* newProxyAcceptorPortData(const AcceptorPortInfo* acceptorPort)
     {
       ProxyAcceptorPortData* acceptorPortData;
       acceptorPortData = new ProxyAcceptorPortData(mNodeInstance, acceptorPort);
-      unsigned index = acceptorPort->getIndex();
-      if (mPortDataVector.size() <= index)
-        mPortDataVector.resize(index + 1);
-      mPortDataVector[index] = acceptorPortData;
+      mPortDataVector[acceptorPort->getIndex()] = acceptorPortData;
       return acceptorPortData;
     }
     ProxyProviderPortData* newProxyProviderPortData(const ProviderPortInfo* providerPort)
     {
       ProxyProviderPortData* providerPortData;
       providerPortData = new ProxyProviderPortData(mNodeInstance, providerPort);
-      unsigned index = providerPort->getIndex();
-      if (mPortDataVector.size() <= index)
-        mPortDataVector.resize(index + 1);
-      mPortDataVector[index] = providerPortData;
+      mPortDataVector[providerPort->getIndex()] = providerPortData;
       return providerPortData;
     }
     
@@ -983,7 +975,8 @@
     ModelInstanceList::const_iterator j;
     for (j = modelContextList.begin(); j != modelContextList.end(); ++j) {
       if (!(*j)->getNodeContext().alloc()) {
-        Log(Schedule, Error) << "Could not alloc for model ... FIXME" << endl;
+        Log(Schedule, Error) << "Could not alloc for model \""
+                             << (*j)->getNodeNamePath() << "\"" << endl;
         return false;
       }
     }



From frohlich at mail.berlios.de  Sat Sep 27 17:53:59 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 27 Sep 2008 17:53:59 +0200
Subject: [OpenFDM-svn] r515 - in branches/OpenFDM-StateSeparation/src:
	OpenFDM test
Message-ID: <200809271553.m8RFrxVW004427@sheep.berlios.de>

Author: frohlich
Date: 2008-09-27 17:53:58 +0200 (Sat, 27 Sep 2008)
New Revision: 515

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Integrator.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Integrator.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/LeafNode.h
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Add a port value list to the init method.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.cpp	2008-09-27 15:42:47 UTC (rev 514)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.cpp	2008-09-27 15:53:58 UTC (rev 515)
@@ -57,7 +57,7 @@
 
 void
 Delay::init(DiscreteStateValueVector& discreteState,
-            ContinousStateValueVector&) const
+            ContinousStateValueVector&,const PortValueList&) const
 {
   discreteState[*mMatrixStateInfo].clear();
   for (unsigned i = 0; i <= mDelay; ++i)

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.h	2008-09-27 15:42:47 UTC (rev 514)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.h	2008-09-27 15:53:58 UTC (rev 515)
@@ -20,7 +20,7 @@
 
   virtual bool alloc(LeafContext& leafContext) const;
   virtual void init(DiscreteStateValueVector& discreteState,
-                    ContinousStateValueVector&) const;
+                    ContinousStateValueVector&, const PortValueList&) const;
   virtual void output(const DiscreteStateValueVector& discreteState,
                       const ContinousStateValueVector&,
                       PortValueList& portValues) const;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Integrator.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Integrator.cpp	2008-09-27 15:42:47 UTC (rev 514)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Integrator.cpp	2008-09-27 15:53:58 UTC (rev 515)
@@ -59,15 +59,12 @@
 
 void
 Integrator::init(DiscreteStateValueVector& discreteState,
-                 ContinousStateValueVector& continousState) const
+                 ContinousStateValueVector& continousState,
+                 const PortValueList& portValues) const
 {
-  // Needs to be done here. Need port values???
-  // FIXME, can I ensure that at least the direct dependent ones are
-  // available and the other ones are inaccessible at compile time?
   if (getEnableInitialValuePort()) {
     // external initial condition
-//     continousState[*mMatrixStateInfo] = portValues[mInitialValuePort];
-    continousState[*mMatrixStateInfo].clear();
+    continousState[*mMatrixStateInfo] = portValues[mInitialValuePort];
   } else {
     // internal initial condition
     continousState[*mMatrixStateInfo] = mInitialValue;
@@ -79,12 +76,7 @@
                    const ContinousStateValueVector& continousState,
                    PortValueList& portValues) const
 {
-  // FIXME
-  if (getEnableInitialValuePort()
-      && size(continousState[*mMatrixStateInfo]) == Size(0, 0))
-    portValues[mOutputPort] = portValues[mInitialValuePort];
-  else
-    portValues[mOutputPort] = continousState[*mMatrixStateInfo];
+  portValues[mOutputPort] = continousState[*mMatrixStateInfo];
 }
 
 void

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Integrator.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Integrator.h	2008-09-27 15:42:47 UTC (rev 514)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Integrator.h	2008-09-27 15:53:58 UTC (rev 515)
@@ -19,7 +19,8 @@
 
   virtual bool alloc(LeafContext& leafContext) const;
   virtual void init(DiscreteStateValueVector& discreteState,
-                    ContinousStateValueVector& continousState) const;
+                    ContinousStateValueVector& continousState,
+                    const PortValueList& portValueList) const;
 
   virtual void output(const DiscreteStateValueVector&, const ContinousStateValueVector& continousState, PortValueList& portValues) const;
   virtual void derivative(const DiscreteStateValueVector&, const ContinousStateValueVector& state, const PortValueList& portValues, ContinousStateValueVector& deriv) const;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/LeafNode.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/LeafNode.h	2008-09-27 15:42:47 UTC (rev 514)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/LeafNode.h	2008-09-27 15:53:58 UTC (rev 515)
@@ -16,6 +16,7 @@
 class NodeVisitor;
 class ContinousStateValueVector;
 class DiscreteStateValueVector;
+class PortValueList;
 
 class LeafNode : public Node {
   OPENFDM_OBJECT(LeafNode, Node);
@@ -32,7 +33,8 @@
   virtual bool alloc(LeafContext&) const // = 0;
   { return true; }
 
-  virtual void init(DiscreteStateValueVector&, ContinousStateValueVector&) const // = 0;
+  virtual void init(DiscreteStateValueVector&, ContinousStateValueVector&,
+                    const PortValueList&) const
   { }
 
   unsigned getNumContinousStateValues() const

Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-27 15:42:47 UTC (rev 514)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-27 15:53:58 UTC (rev 515)
@@ -227,7 +227,7 @@
   bool alloc()
   { return mModel->alloc(*this); }
   void init()
-  { mModel->init(mDiscreteState, mContinousState); }
+  { mModel->init(mDiscreteState, mContinousState, mPortValueList); }
   void output(const Task&)
   { mModel->output(mDiscreteState, mContinousState, mPortValueList); }
   void update(const DiscreteTask&)
@@ -342,7 +342,7 @@
   bool alloc()
   { return mMechanicNode->alloc(*this); }
   void init()
-  { mMechanicNode->init(mDiscreteState, mContinousState); }
+  { mMechanicNode->init(mDiscreteState, mContinousState, mPortValueList); }
 
   void velocities(const ContinousTask&)
   { mMechanicNode->velocity(mContinousState, mPortValueList); }



From frohlich at mail.berlios.de  Sat Sep 27 19:52:27 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 27 Sep 2008 19:52:27 +0200
Subject: [OpenFDM-svn] r516 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200809271752.m8RHqRrf004354@sheep.berlios.de>

Author: frohlich
Date: 2008-09-27 19:52:27 +0200 (Sat, 27 Sep 2008)
New Revision: 516

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
Log:
Read Function.cpp to the build.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-09-27 15:53:58 UTC (rev 515)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-09-27 17:52:27 UTC (rev 516)
@@ -123,6 +123,7 @@
   ConstNodeVisitor.cpp \
   ContinousStateValue.cpp \
   Frame.cpp \
+  Function.cpp \
   Group.cpp \
   Interact.cpp \
   LeafNode.cpp \
@@ -153,7 +154,6 @@
 #   EnvironmentObject.cpp \
 #   ExplicitAdams.cpp \
 #   ExplicitEuler.cpp \
-#   Function.cpp \
 #   ImplicitEuler.cpp \
 #   Newton.cpp \
 #   MidpointRule.cpp \



From frohlich at mail.berlios.de  Sat Sep 27 20:18:17 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 27 Sep 2008 20:18:17 +0200
Subject: [OpenFDM-svn] r517 - in branches/OpenFDM-StateSeparation/src:
	OpenFDM test
Message-ID: <200809271818.m8RIIHaK006290@sheep.berlios.de>

Author: frohlich
Date: 2008-09-27 20:18:17 +0200 (Sat, 27 Sep 2008)
New Revision: 517

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
   branches/OpenFDM-StateSeparation/src/OpenFDM/ODESolver.h
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Again provide ode solvers ...


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-09-27 17:52:27 UTC (rev 516)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-09-27 18:18:17 UTC (rev 517)
@@ -122,6 +122,9 @@
   Atomic.cpp \
   ConstNodeVisitor.cpp \
   ContinousStateValue.cpp \
+  DoPri5.cpp \
+  ExplicitAdams.cpp \
+  ExplicitEuler.cpp \
   Frame.cpp \
   Function.cpp \
   Group.cpp \
@@ -133,11 +136,13 @@
   MatrixStateValue.cpp \
   MechanicNode.cpp \
   MechanicPortValue.cpp \
+  MidpointRule.cpp \
   Model.cpp \
   Node.cpp \
   NodeVisitor.cpp \
   NumericPortValue.cpp \
   Object.cpp \
+  ODESolver.cpp \
   Planet.cpp \
   PortInfo.cpp \
   PortValue.cpp \
@@ -149,16 +154,11 @@
   Unit.cpp \
   Variant.cpp
 
-#   DoPri5.cpp \
 #   Environment.cpp \
 #   EnvironmentObject.cpp \
-#   ExplicitAdams.cpp \
-#   ExplicitEuler.cpp \
 #   ImplicitEuler.cpp \
 #   Newton.cpp \
-#   MidpointRule.cpp \
 #   ReaderWriter.cpp \
-#   ODESolver.cpp \
 #   System.cpp \
 #   TaskInfo.cpp \
 #

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/ODESolver.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ODESolver.h	2008-09-27 17:52:27 UTC (rev 516)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ODESolver.h	2008-09-27 18:18:17 UTC (rev 517)
@@ -9,7 +9,7 @@
 #include "Object.h"
 #include "Vector.h"
 #include "Matrix.h"
-#include "System.h"
+#include "Function.h"
 
 namespace OpenFDM {
 
@@ -53,26 +53,19 @@
   { return mStats; }
 
   void evalFunction(real_type t, const Vector& v, Vector& out)
-  {
-    SharedPtr<System> system = mSystem.lock();
-    system->evalFunction(t, v, out);
-  }
+  { mFunction->eval(t, v, out); }
   void evalJacobian(real_type t, const Vector& v, Matrix& jac)
-  {
-    SharedPtr<System> system = mSystem.lock();
-    system->evalJacobian(t, v, jac);
-  }
+  { mFunction->jac(t, v, jac); }
 
-  void setSystem(System* model)
-  { mSystem = model; }
+  void setFunction(Function* function)
+  { mFunction = function; }
 
 protected:
   real_type mStepsize;
   real_type mTime;
   Vector mState;
 
-  /// WeakPtr ???
-  WeakPtr<System> mSystem;
+  SharedPtr<Function> mFunction;
 
   Stats mStats;
 };

Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-27 17:52:27 UTC (rev 516)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-27 18:18:17 UTC (rev 517)
@@ -28,6 +28,8 @@
 #include <OpenFDM/ContinousStateValueVector.h>
 #include <OpenFDM/DiscreteStateValueVector.h>
 
+#include <OpenFDM/ODESolver.h>
+#include <OpenFDM/Function.h>
 #include <OpenFDM/SampleTime.h>
 
 #include <OpenFDM/BoolStateInfo.h>



From frohlich at mail.berlios.de  Sat Sep 27 20:22:23 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 27 Sep 2008 20:22:23 +0200
Subject: [OpenFDM-svn] r518 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200809271822.m8RIMNON006576@sheep.berlios.de>

Author: frohlich
Date: 2008-09-27 20:22:23 +0200 (Sat, 27 Sep 2008)
New Revision: 518

Modified:
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Remove output callback.


Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-27 18:18:17 UTC (rev 517)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-27 18:22:23 UTC (rev 518)
@@ -1162,21 +1162,15 @@
 
 using namespace OpenFDM;
 
-class PrintOutput : public Output::Callback {
-public:
-  virtual void setValue(real_type value)
-  { std::cout << value << std::endl; }
-};
-
 int main()
 {
   SharedPtr<Group> group = new Group("G0");
   Group::NodeId gain = group->addChild(new Gain("gain"));
   Group::NodeId integrator1 = group->addChild(new Integrator("I1"));
   Group::NodeId integrator2 = group->addChild(new Integrator("I2"));
-  Group::NodeId output = group->addChild(new Output("O", new PrintOutput));
+  Group::NodeId output = group->addChild(new Output("O"));
   Group::NodeId delay = group->addChild(new Delay("D"));
-  Group::NodeId outputDelay = group->addChild(new Output("OD", new PrintOutput));
+  Group::NodeId outputDelay = group->addChild(new Output("OD"));
 
   group->connect(integrator1, "output", integrator2, "input");
   group->connect(integrator2, "output", gain, "input");
@@ -1194,9 +1188,9 @@
   Group::NodeId child0 = topGroup->addChild(group);
   Group::NodeId child1 = topGroup->addChild(group);
 
-  Group::NodeId output0 = topGroup->addChild(new Output("O2", new PrintOutput));
+  Group::NodeId output0 = topGroup->addChild(new Output("O2"));
   topGroup->connect(child0, 0, output0, 0);
-  Group::NodeId output1 = topGroup->addChild(new Output("O3", new PrintOutput));
+  Group::NodeId output1 = topGroup->addChild(new Output("O3"));
   topGroup->connect(child1, 0, output1, 0);
 
   /////////////////////////////////////////////////



From frohlich at mail.berlios.de  Sat Sep 27 20:37:57 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 27 Sep 2008 20:37:57 +0200
Subject: [OpenFDM-svn] r519 -
	branches/OpenFDM-StateSeparation/src/OpenFDM/LinAlg
Message-ID: <200809271837.m8RIbvbi007766@sheep.berlios.de>

Author: frohlich
Date: 2008-09-27 20:37:56 +0200 (Sat, 27 Sep 2008)
New Revision: 519

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/LinAlg/IO.h
Log:
Use \n instead of endl.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/LinAlg/IO.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/LinAlg/IO.h	2008-09-27 18:22:23 UTC (rev 518)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/LinAlg/IO.h	2008-09-27 18:37:56 UTC (rev 519)
@@ -62,7 +62,7 @@
     }
 
     if (i < rows-1)
-      os << std::endl;
+      os << os.widen('\n');
   }
   os << os.widen(']');
 



From frohlich at mail.berlios.de  Sat Sep 27 20:59:38 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 27 Sep 2008 20:59:38 +0200
Subject: [OpenFDM-svn] r520 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200809271859.m8RIxcKv009678@sheep.berlios.de>

Author: frohlich
Date: 2008-09-27 20:59:37 +0200 (Sat, 27 Sep 2008)
New Revision: 520

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Interval.h
Log:
Update implementation.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Interval.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Interval.h	2008-09-27 18:37:56 UTC (rev 519)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Interval.h	2008-09-27 18:59:37 UTC (rev 520)
@@ -15,8 +15,12 @@
   typedef T value_type;
 
   Interval() :
-    mBegin(Limits<value_type>::max()), mEnd(-Limits<value_type>::max())
+    mBegin(Limits<value_type>::min_value()),
+    mEnd(Limits<value_type>::max_value())
   { }
+  Interval(const value_type& value) :
+    mBegin(value), mEnd(value)
+  { }
   Interval(const value_type& begin, const value_type& end) :
     mBegin(begin), mEnd(end)
   { }
@@ -27,8 +31,8 @@
   void setEnd(const value_type& end) { mBegin = end; }
   const value_type& getEnd() const { return mEnd; }
 
-  bool valid() const
-  { return mBegin <= mEnd; }
+  bool empty() const
+  { return mEnd < mBegin; }
   value_type getLength() const
   { return mEnd - mBegin; }
 
@@ -43,6 +47,11 @@
   bool contains(const value_type& value) const
   { return mBegin <= value && value <= mEnd; }
 
+  static Interval all()
+  { return Interval(); }
+  static Interval noting()
+  { return Interval(1, -1); }
+
 private:
   value_type mBegin;
   value_type mEnd;



From frohlich at mail.berlios.de  Sat Sep 27 22:14:01 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 27 Sep 2008 22:14:01 +0200
Subject: [OpenFDM-svn] r521 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200809272014.m8RKE1Tk015069@sheep.berlios.de>

Author: frohlich
Date: 2008-09-27 22:14:00 +0200 (Sat, 27 Sep 2008)
New Revision: 521

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/AcceptorPortInfo.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Group.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/PortInfo.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/ProviderPortInfo.h
Log:
Remove non const PortInfo casts.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/AcceptorPortInfo.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/AcceptorPortInfo.h	2008-09-27 18:59:37 UTC (rev 520)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/AcceptorPortInfo.h	2008-09-27 20:14:00 UTC (rev 521)
@@ -17,8 +17,6 @@
   { }
   virtual ~AcceptorPortInfo() {}
 
-  virtual AcceptorPortInfo* toAcceptorPortInfo()
-  { return this; }
   virtual const AcceptorPortInfo* toAcceptorPortInfo() const
   { return this; }
 

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Group.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Group.h	2008-09-27 18:59:37 UTC (rev 520)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Group.h	2008-09-27 20:14:00 UTC (rev 521)
@@ -53,8 +53,6 @@
   ProxyAcceptorPortInfo(Node* node, const std::string& name = std::string()) :
     AcceptorPortInfo(node, name) {}
   SharedPtr<GroupAcceptorNode> mGroupPort;
-  virtual ProxyAcceptorPortInfo* toProxyAcceptorPortInfo()
-  { return this; }
   virtual const ProxyAcceptorPortInfo* toProxyAcceptorPortInfo() const
   { return this; }
 };
@@ -65,8 +63,6 @@
     ProviderPortInfo(node, name) {}
   virtual PortValue* newValueImplementation() const
   { return 0; } //FIXME
-  virtual ProxyProviderPortInfo* toProxyProviderPortInfo()
-  { return this; }
   virtual const ProxyProviderPortInfo* toProxyProviderPortInfo() const
   { return this; }
   SharedPtr<GroupProviderNode> mGroupPort;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/PortInfo.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/PortInfo.h	2008-09-27 18:59:37 UTC (rev 520)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/PortInfo.h	2008-09-27 20:14:00 UTC (rev 521)
@@ -37,20 +37,12 @@
 
   unsigned getIndex() const { return mIndex; }
 
-  virtual AcceptorPortInfo* toAcceptorPortInfo()
-  { return 0; }
   virtual const AcceptorPortInfo* toAcceptorPortInfo() const
   { return 0; }
-  virtual ProviderPortInfo* toProviderPortInfo()
-  { return 0; }
   virtual const ProviderPortInfo* toProviderPortInfo() const
   { return 0; }
-  virtual ProxyAcceptorPortInfo* toProxyAcceptorPortInfo()
-  { return 0; }
   virtual const ProxyAcceptorPortInfo* toProxyAcceptorPortInfo() const
   { return 0; }
-  virtual ProxyProviderPortInfo* toProxyProviderPortInfo()
-  { return 0; }
   virtual const ProxyProviderPortInfo* toProxyProviderPortInfo() const
   { return 0; }
   

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/ProviderPortInfo.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ProviderPortInfo.h	2008-09-27 18:59:37 UTC (rev 520)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ProviderPortInfo.h	2008-09-27 20:14:00 UTC (rev 521)
@@ -20,8 +20,6 @@
   { return newValueImplementation(); }
 
   /// Dynamic casts
-  virtual ProviderPortInfo* toProviderPortInfo()
-  { return this; }
   virtual const ProviderPortInfo* toProviderPortInfo() const
   { return this; }
 



From frohlich at mail.berlios.de  Sat Sep 27 22:42:43 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 27 Sep 2008 22:42:43 +0200
Subject: [OpenFDM-svn] r522 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200809272042.m8RKghGf017450@sheep.berlios.de>

Author: frohlich
Date: 2008-09-27 22:42:43 +0200 (Sat, 27 Sep 2008)
New Revision: 522

Added:
   branches/OpenFDM-StateSeparation/src/OpenFDM/AcceptorPortInfo.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/ProviderPortInfo.cpp
Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/AcceptorPortInfo.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
   branches/OpenFDM-StateSeparation/src/OpenFDM/ProviderPortInfo.h
Log:
Create implementation files for basic port info classes.


Added: branches/OpenFDM-StateSeparation/src/OpenFDM/AcceptorPortInfo.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/AcceptorPortInfo.cpp	2008-09-27 20:14:00 UTC (rev 521)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/AcceptorPortInfo.cpp	2008-09-27 20:42:43 UTC (rev 522)
@@ -0,0 +1,24 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
+ *
+ */
+
+#include "AcceptorPortInfo.h"
+
+namespace OpenFDM {
+
+AcceptorPortInfo::AcceptorPortInfo(Node* node, const std::string& name) :
+  PortInfo(node, name)
+{
+}
+
+AcceptorPortInfo::~AcceptorPortInfo()
+{
+}
+
+const AcceptorPortInfo*
+AcceptorPortInfo::toAcceptorPortInfo() const
+{
+  return this;
+}
+
+} // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/AcceptorPortInfo.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/AcceptorPortInfo.h	2008-09-27 20:14:00 UTC (rev 521)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/AcceptorPortInfo.h	2008-09-27 20:42:43 UTC (rev 522)
@@ -12,13 +12,10 @@
 
 class AcceptorPortInfo : public PortInfo {
 public:
-  AcceptorPortInfo(Node* node, const std::string& name) :
-    PortInfo(node, name)
-  { }
-  virtual ~AcceptorPortInfo() {}
+  AcceptorPortInfo(Node* node, const std::string& name);
+  virtual ~AcceptorPortInfo();
 
-  virtual const AcceptorPortInfo* toAcceptorPortInfo() const
-  { return this; }
+  virtual const AcceptorPortInfo* toAcceptorPortInfo() const;
 
   virtual bool getDirectInput() const
   { return false; }

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-09-27 20:14:00 UTC (rev 521)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-09-27 20:42:43 UTC (rev 522)
@@ -118,6 +118,7 @@
   XMLDumpModelVisitor.h
 
 OpenFDMCoreSOURCES = \
+  AcceptorPortInfo.cpp \
   Assert.cpp \
   Atomic.cpp \
   ConstNodeVisitor.cpp \
@@ -146,6 +147,7 @@
   Planet.cpp \
   PortInfo.cpp \
   PortValue.cpp \
+  ProviderPortInfo.cpp \
   RigidBody.cpp \
   RootJoint.cpp \
   SampleTime.cpp \

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/ProviderPortInfo.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ProviderPortInfo.cpp	2008-09-27 20:14:00 UTC (rev 521)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ProviderPortInfo.cpp	2008-09-27 20:42:43 UTC (rev 522)
@@ -0,0 +1,30 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
+ *
+ */
+
+#include "ProviderPortInfo.h"
+
+namespace OpenFDM {
+
+ProviderPortInfo::ProviderPortInfo(Node* node, const std::string& name) :
+  PortInfo(node, name)
+{
+}
+
+ProviderPortInfo::~ProviderPortInfo()
+{
+}
+
+PortValue*
+ProviderPortInfo::newValue() const
+{
+  return newValueImplementation();
+}
+
+const ProviderPortInfo*
+ProviderPortInfo::toProviderPortInfo() const
+{
+  return this;
+}
+
+} // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/ProviderPortInfo.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ProviderPortInfo.h	2008-09-27 20:14:00 UTC (rev 521)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ProviderPortInfo.h	2008-09-27 20:42:43 UTC (rev 522)
@@ -12,16 +12,14 @@
 
 class ProviderPortInfo : public PortInfo {
 public:
-  ProviderPortInfo(Node* node, const std::string& name) :
-    PortInfo(node, name) {}
+  ProviderPortInfo(Node* node, const std::string& name);
+  virtual ~ProviderPortInfo();
 
   /// Public interface to instantiate a new port value
-  PortValue* newValue() const
-  { return newValueImplementation(); }
+  PortValue* newValue() const;
 
   /// Dynamic casts
-  virtual const ProviderPortInfo* toProviderPortInfo() const
-  { return this; }
+  virtual const ProviderPortInfo* toProviderPortInfo() const;
 
 protected:
   /// The basic property of a provider port is that it can provide



From frohlich at mail.berlios.de  Sat Sep 27 22:54:59 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 27 Sep 2008 22:54:59 +0200
Subject: [OpenFDM-svn] r523 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200809272054.m8RKsxYH018236@sheep.berlios.de>

Author: frohlich
Date: 2008-09-27 22:54:59 +0200 (Sat, 27 Sep 2008)
New Revision: 523

Added:
   branches/OpenFDM-StateSeparation/src/OpenFDM/NumericAcceptorPortInfo.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/NumericProviderPortInfo.cpp
Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
   branches/OpenFDM-StateSeparation/src/OpenFDM/NumericAcceptorPortInfo.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/NumericProviderPortInfo.h
Log:
Add implementation files for Numeric port info classes.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-09-27 20:42:43 UTC (rev 522)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-09-27 20:54:59 UTC (rev 523)
@@ -141,7 +141,9 @@
   Model.cpp \
   Node.cpp \
   NodeVisitor.cpp \
+  NumericAcceptorPortInfo.cpp \
   NumericPortValue.cpp \
+  NumericProviderPortInfo.cpp \
   Object.cpp \
   ODESolver.cpp \
   Planet.cpp \

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/NumericAcceptorPortInfo.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/NumericAcceptorPortInfo.cpp	2008-09-27 20:42:43 UTC (rev 522)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/NumericAcceptorPortInfo.cpp	2008-09-27 20:54:59 UTC (rev 523)
@@ -0,0 +1,21 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
+ *
+ */
+
+#include "NumericAcceptorPortInfo.h"
+
+namespace OpenFDM {
+
+NumericAcceptorPortInfo::NumericAcceptorPortInfo(Node* node,
+        const std::string& name, const Size& size, bool directInput) :
+  AcceptorPortInfo(node, name),
+  mSize(size),
+  mDirectInput(directInput)
+{
+}
+
+NumericAcceptorPortInfo::~NumericAcceptorPortInfo()
+{
+}
+
+} // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/NumericAcceptorPortInfo.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/NumericAcceptorPortInfo.h	2008-09-27 20:42:43 UTC (rev 522)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/NumericAcceptorPortInfo.h	2008-09-27 20:54:59 UTC (rev 523)
@@ -7,17 +7,15 @@
 
 #include <string>
 #include "AcceptorPortInfo.h"
+#include "Matrix.h"
 
 namespace OpenFDM {
 
 class NumericAcceptorPortInfo : public AcceptorPortInfo {
 public:
   NumericAcceptorPortInfo(Node* node, const std::string& name,
-                          const Size& size, bool directInput) :
-    AcceptorPortInfo(node, name),
-    mSize(size),
-    mDirectInput(directInput)
-  { }
+                          const Size& size, bool directInput);
+  virtual ~NumericAcceptorPortInfo();
 
   virtual bool getDirectInput() const
   { return mDirectInput; }

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/NumericProviderPortInfo.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/NumericProviderPortInfo.cpp	2008-09-27 20:42:43 UTC (rev 522)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/NumericProviderPortInfo.cpp	2008-09-27 20:54:59 UTC (rev 523)
@@ -0,0 +1,27 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
+ *
+ */
+
+#include "NumericProviderPortInfo.h"
+
+#include "NumericPortValue.h"
+
+namespace OpenFDM {
+
+NumericProviderPortInfo::NumericProviderPortInfo(Node* node, const std::string& name, const Size& size) :
+  ProviderPortInfo(node, name),
+  mSize(size)
+{
+}
+
+NumericProviderPortInfo::~NumericProviderPortInfo()
+{
+}
+
+NumericPortValue*
+NumericProviderPortInfo::newValueImplementation() const
+{
+  return new NumericPortValue(mSize);
+}
+
+} // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/NumericProviderPortInfo.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/NumericProviderPortInfo.h	2008-09-27 20:42:43 UTC (rev 522)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/NumericProviderPortInfo.h	2008-09-27 20:54:59 UTC (rev 523)
@@ -6,20 +6,18 @@
 #define OpenFDM_NumericProviderPortInfo_H
 
 #include <string>
-#include "NumericPortValue.h"
 #include "ProviderPortInfo.h"
+#include "NumericPortValue.h"
 
 namespace OpenFDM {
 
 class NumericProviderPortInfo : public ProviderPortInfo {
 public:
-  NumericProviderPortInfo(Node* node, const std::string& name, const Size& size) :
-    ProviderPortInfo(node, name),
-    mSize(size)
-  { }
+  NumericProviderPortInfo(Node* node, const std::string& name, const Size& sz);
+  virtual ~NumericProviderPortInfo();
+
 protected:
-  virtual NumericPortValue* newValueImplementation() const
-  { return new NumericPortValue(mSize); }
+  virtual NumericPortValue* newValueImplementation() const;
 private:
   Size mSize;
 };



From frohlich at mail.berlios.de  Sun Sep 28 08:37:52 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 28 Sep 2008 08:37:52 +0200
Subject: [OpenFDM-svn] r524 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200809280637.m8S6bqk0020649@sheep.berlios.de>

Author: frohlich
Date: 2008-09-28 08:37:51 +0200 (Sun, 28 Sep 2008)
New Revision: 524

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Interval.h
Log:
Add typedef for TimeInterval.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Interval.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Interval.h	2008-09-27 20:54:59 UTC (rev 523)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Interval.h	2008-09-28 06:37:51 UTC (rev 524)
@@ -6,6 +6,7 @@
 #define OpenFDM_Interval_H
 
 #include "Limits.h"
+#include "Types.h"
 
 namespace OpenFDM {
 
@@ -49,7 +50,7 @@
 
   static Interval all()
   { return Interval(); }
-  static Interval noting()
+  static Interval nothing()
   { return Interval(1, -1); }
 
 private:
@@ -57,6 +58,8 @@
   value_type mEnd;
 };
 
+typedef Interval<real_type> TimeInterval;
+
 } // namespace OpenFDM
 
 #endif



From frohlich at mail.berlios.de  Sun Sep 28 08:45:36 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 28 Sep 2008 08:45:36 +0200
Subject: [OpenFDM-svn] r525 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200809280645.m8S6jaRS021548@sheep.berlios.de>

Author: frohlich
Date: 2008-09-28 08:45:35 +0200 (Sun, 28 Sep 2008)
New Revision: 525

Added:
   branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractSystem.h
Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
Log:
First sketch of an AbstractSystem to do the scheduling for systems.


Added: branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractSystem.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractSystem.h	2008-09-28 06:37:51 UTC (rev 524)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractSystem.h	2008-09-28 06:45:35 UTC (rev 525)
@@ -0,0 +1,83 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_AbstractSystem_H
+#define OpenFDM_AbstractSystem_H
+
+#include "Interval.h"
+#include "Referenced.h"
+#include "Types.h"
+
+namespace OpenFDM {
+
+class AbstractSystem : public Referenced {
+public:
+  AbstractSystem() :
+    mValidityInterval(TimeInterval::nothing()),
+    mTime(Limits<real_type>::min_value())
+  { }
+  virtual ~AbstractSystem() {}
+
+  const TimeInterval& getValidityInterval() const
+  { return mValidityInterval; }
+  const real_type& getTime() const
+  { return mTime; }
+
+  void outputAt(const real_type& t)
+  {
+    // Cry if we cannot do anything!
+    OpenFDMAssert(!getValidityInterval().empty());
+    // update until our requested end time is in the current interval.
+    while (needUpdate(t))
+      update(t);
+    if (t != mTime)
+      output(t);
+  }
+
+  // Not sure yet who is responsible for calling them at the right times ...
+  void init(const real_type& t)
+  {
+    mValidityInterval = TimeInterval(t);
+    mTime = t;
+    initImplementation(t);
+    Log(Schedule,Info) << "Initialized for time Interval from t = "
+                       << mValidityInterval.getBegin() << " to t = "
+                       << mValidityInterval.getEnd() << std::endl;
+  }
+
+  void update(const real_type& tEndHint)
+  {
+    updateImplementation(tEndHint);
+    Log(Schedule,Info) << "Updated to time Interval from t = "
+                       << mValidityInterval.getBegin() << " to t = "
+                       << mValidityInterval.getEnd() << std::endl;
+  }
+  void output(const real_type& t)
+  {
+    OpenFDMAssert(getValidityInterval().contains(t));
+    mTime = t;
+    outputImplementation(mTime);
+    Log(Schedule,Info) << "Output for time t =  " << t << std::endl;
+  }
+protected:
+
+  void setValidityInterval(const TimeInterval& validityInterval)
+  { mValidityInterval = validityInterval; }
+
+  virtual void initImplementation(const real_type& t) = 0;
+
+  bool needUpdate(const real_type& t) const
+  { return getValidityInterval().isStrictlyLeftOf(t); }
+  virtual void updateImplementation(const real_type& tEndHint) = 0;
+
+  virtual void outputImplementation(const real_type& t) = 0;
+
+private:
+  TimeInterval mValidityInterval;
+  real_type mTime;
+};
+
+} // namespace OpenFDM
+
+#endif

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-09-28 06:37:51 UTC (rev 524)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-09-28 06:45:35 UTC (rev 525)
@@ -9,6 +9,7 @@
 
 OpenFDMCoreHEADERS = \
   AbstractNodeContext.h \
+  AbstractSystem.h \
   AcceptorPortInfo.h \
   Assert.h \
   Atomic.h \



From frohlich at mail.berlios.de  Sun Sep 28 08:58:34 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 28 Sep 2008 08:58:34 +0200
Subject: [OpenFDM-svn] r526 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200809280658.m8S6wY8Z022659@sheep.berlios.de>

Author: frohlich
Date: 2008-09-28 08:58:34 +0200 (Sun, 28 Sep 2008)
New Revision: 526

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractSystem.h
Log:
For now dump some Abstract system implementations here.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractSystem.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractSystem.h	2008-09-28 06:45:35 UTC (rev 525)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractSystem.h	2008-09-28 06:58:34 UTC (rev 526)
@@ -78,6 +78,70 @@
   real_type mTime;
 };
 
+// FIXME: dump them here for now. Will be required later ...
+class EnabledSystem : public AbstractSystem {
+};
+
+class GroupedSystem : public AbstractSystem {
+public:
+  unsigned getNumChildren() const
+  { return mAbstractSystemList.size(); }
+  AbstractSystem* getChild(unsigned index)
+  {
+    if (mAbstractSystemList.size() <= index)
+      return 0;
+    return mAbstractSystemList[index];
+  }
+  unsigned addChild(AbstractSystem* abstractSystem)
+  {
+    unsigned index = mAbstractSystemList.size();
+    mAbstractSystemList.push_back(abstractSystem);
+    return index;
+  }
+  void removeChild(AbstractSystem* abstractSystem)
+  {
+    AbstractSystemList::iterator i;
+    i = std::find(mAbstractSystemList.begin(), mAbstractSystemList.end(),
+                  abstractSystem);
+    if (i == mAbstractSystemList.end())
+      return;
+    mAbstractSystemList.erase(i);
+  }
+
+protected:
+  virtual void initImplementation(const real_type& t)
+  {
+    AbstractSystemList::const_iterator i;
+    for (i = mAbstractSystemList.begin(); i != mAbstractSystemList.end(); ++i) {
+      (*i)->init(t);
+    }
+  }
+  virtual void updateImplementation(const real_type& tEndHint)
+  {
+    // initially set to all
+    TimeInterval validityInterval = TimeInterval::all();
+    AbstractSystemList::const_iterator i;
+    for (i = mAbstractSystemList.begin(); i != mAbstractSystemList.end(); ++i) {
+      (*i)->update(tEndHint);
+      if (validityInterval.getBegin() < (*i)->getValidityInterval().getBegin())
+        validityInterval.setBegin((*i)->getValidityInterval().getBegin());
+      if ((*i)->getValidityInterval().getEnd() < validityInterval.getEnd())
+        validityInterval.setEnd((*i)->getValidityInterval().getEnd());
+    }
+    setValidityInterval(validityInterval);
+  }
+  virtual void outputImplementation(const real_type& t)
+  {
+    AbstractSystemList::const_iterator i;
+    for (i = mAbstractSystemList.begin(); i != mAbstractSystemList.end(); ++i)
+      (*i)->output(t);
+  }
+private:
+  typedef std::vector<SharedPtr<AbstractSystem> > AbstractSystemList;
+  AbstractSystemList mAbstractSystemList;
+};
+
+
 } // namespace OpenFDM
 
 #endif



From frohlich at mail.berlios.de  Sun Sep 28 09:19:55 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 28 Sep 2008 09:19:55 +0200
Subject: [OpenFDM-svn] r527 - in branches/OpenFDM-StateSeparation/src:
	OpenFDM test
Message-ID: <200809280719.m8S7JtL8024405@sheep.berlios.de>

Author: frohlich
Date: 2008-09-28 09:19:55 +0200 (Sun, 28 Sep 2008)
New Revision: 527

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractSystem.h
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Use an AbstractSystem to do simulation.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractSystem.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractSystem.h	2008-09-28 06:58:34 UTC (rev 526)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractSystem.h	2008-09-28 07:19:55 UTC (rev 527)
@@ -15,7 +15,7 @@
 public:
   AbstractSystem() :
     mValidityInterval(TimeInterval::nothing()),
-    mTime(Limits<real_type>::min_value())
+    mTime(Limits<real_type>::quiet_NaN())
   { }
   virtual ~AbstractSystem() {}
 

Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-28 06:58:34 UTC (rev 526)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-28 07:19:55 UTC (rev 527)
@@ -31,7 +31,10 @@
 #include <OpenFDM/ODESolver.h>
 #include <OpenFDM/Function.h>
 #include <OpenFDM/SampleTime.h>
+#include <OpenFDM/Interval.h>
 
+#include <OpenFDM/AbstractSystem.h>
+
 #include <OpenFDM/BoolStateInfo.h>
 #include <OpenFDM/RealStateInfo.h>
 #include <OpenFDM/MatrixStateInfo.h>
@@ -951,6 +954,27 @@
     return true;
   }
 
+  // Here the miracle occurs.
+  // The collected simulation nodes are packed into something that can be used
+  // to simulate the system.
+  AbstractSystem* buildSystem()
+  {
+    // Allocates and distributes the PortValues, is required for the sort
+    // steps below
+    if (!allocPortValues())
+      return 0;
+    // The model instances are sorted to match the direct input property
+    if (!sortModelList())
+      return 0;
+
+    ModelInstanceList modelContextList;
+    getModelContextList(modelContextList);
+    // ...
+
+    // FIXME:
+    return new GroupedSystem;
+  }
+
   bool
   allocPortValues()
   {
@@ -1103,25 +1127,18 @@
   bool init()
   {
     if (!mNode)
-      return true;
+      return false;
 
     // Build up the lists required to run the model.
     NodeInstanceCollector nodeInstanceCollector;
     mNode->accept(nodeInstanceCollector);
     
-    // Allocates and distributes the PortValues, is required for the sort
-    // steps below
-    if (!nodeInstanceCollector.allocPortValues())
+    mAbstractSystem = nodeInstanceCollector.buildSystem();
+    if (!mAbstractSystem)
       return false;
-    // The model instances are sorted to match the direct input property
-    if (!nodeInstanceCollector.sortModelList())
-      return false;
 
-    ModelInstanceList modelContextList;
-    nodeInstanceCollector.getModelContextList(modelContextList);
-    // ...
-
-    // Ok, all successful so far, get the lists from the visitor
+    // Have something to run in our hands.
+    // Not get the information required to reflect the system to the user.
     mNodeInstanceList.swap(nodeInstanceCollector._nodeInstanceList);
 
     return true;
@@ -1129,13 +1146,17 @@
 
   void clear()
   {
+    mAbstractSystem = 0;
     mNodeInstanceList.clear();
   }
 
   /// Simulate the system until the time tEnd
-  bool simulate(real_type tEnd)
+  bool simulate(const real_type& t)
   {
-    return false;
+    if (mAbstractSystem)
+      return false;
+    mAbstractSystem->outputAt(t);
+    return true;
   }
 
   /// Bring the system in an equilibrum state near the current state ...
@@ -1145,16 +1166,20 @@
   }
 
   /// Return the current simulation time, convenience function
-//   const real_type& getTime(void) const
-//   { return mTime; }
+  real_type getTime(void) const
+  {
+    if (!mAbstractSystem)
+      return Limits<real_type>::quiet_NaN();
+    return mAbstractSystem->getTime();
+  }
 
-
   const NodeInstanceList& getNodeInstanceList() const
   { return mNodeInstanceList; }
 
 private:
   SharedPtr<Node> mNode;
 
+  SharedPtr<AbstractSystem> mAbstractSystem;
   NodeInstanceList mNodeInstanceList;
 };
 



From frohlich at mail.berlios.de  Sun Sep 28 09:43:41 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 28 Sep 2008 09:43:41 +0200
Subject: [OpenFDM-svn] r528 - in branches/OpenFDM-StateSeparation/src:
	OpenFDM test
Message-ID: <200809280743.m8S7hfZk025684@sheep.berlios.de>

Author: frohlich
Date: 2008-09-28 09:43:39 +0200 (Sun, 28 Sep 2008)
New Revision: 528

Added:
   branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeInstance.h
Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
   branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/System.h
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Move System (mostly) to regular implementation files.


Added: branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeInstance.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeInstance.h	2008-09-28 07:19:55 UTC (rev 527)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeInstance.h	2008-09-28 07:43:39 UTC (rev 528)
@@ -0,0 +1,82 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_AbstractNodeInstance_H
+#define OpenFDM_AbstractNodeInstance_H
+
+#include <string>
+#include "AbstractNodeContext.h"
+#include "Assert.h"
+#include "Node.h"
+#include "SharedPtr.h"
+#include "WeakReferenced.h"
+
+namespace OpenFDM {
+
+/// An Abstract NodeInstance represents an effective model node in a ready
+/// to run System. You can access the Nodes Ports values for example.
+/// This class is meant to show up in the user interface of this simulation.
+class AbstractNodeInstance : public WeakReferenced {
+public:
+  AbstractNodeInstance(const NodePath& nodePath) :
+    mNodePath(nodePath)
+  { OpenFDMAssert(!nodePath.empty()); }
+  virtual ~AbstractNodeInstance()
+  { }
+
+  /// The actual Node this AbstractNodeInstance stems from
+  const Node& getNode() const
+  { return getNodeContext().getNode(); }
+
+  const NodePath& getNodePath() const { return mNodePath; }
+
+//   /// Set the sample times this node will run on
+//   void setSampleTimeSet(const SampleTimeSet& sampleTimeSet)
+//   { mSampleTimeSet = sampleTimeSet; }
+//   /// Get the sample times this node will run on
+//   const SampleTimeSet& getSampleTimeSet() const
+//   { return mSampleTimeSet; }
+
+  PortValueList& getPortValueList()
+  { return getNodeContext().getPortValueList(); }
+  const PortValueList& getPortValueList() const
+  { return getNodeContext().getPortValueList(); }
+
+  std::string getNodeNamePath() const
+  {
+    if (mNodePath.empty())
+      return std::string();
+    std::string path = mNodePath.front()->getName();
+    NodePath::const_iterator i = mNodePath.begin();
+    if (i != mNodePath.end()) {
+      for (++i; i != mNodePath.end(); ++i) {
+        path += '/';
+        path += (*i)->getName();
+      }
+    }
+    return path;
+  }
+
+protected:
+  AbstractNodeInstance() {}
+
+  /// The node context that belongs to this instance.
+  virtual AbstractNodeContext& getNodeContext() = 0;
+  virtual const AbstractNodeContext& getNodeContext() const = 0;
+
+private:
+  AbstractNodeInstance(const AbstractNodeInstance&);
+  AbstractNodeInstance& operator=(const AbstractNodeInstance&);
+
+//   /// The sample times this node will run on
+//   SampleTimeSet mSampleTimeSet;
+
+  NodePath mNodePath;
+};
+
+typedef std::list<SharedPtr<AbstractNodeInstance> > NodeInstanceList;
+
+} // namespace OpenFDM
+
+#endif

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-09-28 07:19:55 UTC (rev 527)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-09-28 07:43:39 UTC (rev 528)
@@ -9,6 +9,7 @@
 
 OpenFDMCoreHEADERS = \
   AbstractNodeContext.h \
+  AbstractNodeInstance.h \
   AbstractSystem.h \
   AcceptorPortInfo.h \
   Assert.h \
@@ -155,6 +156,7 @@
   RootJoint.cpp \
   SampleTime.cpp \
   StateValue.cpp \
+  System.cpp \
   Time.cpp \
   Unit.cpp \
   Variant.cpp
@@ -164,7 +166,6 @@
 #   ImplicitEuler.cpp \
 #   Newton.cpp \
 #   ReaderWriter.cpp \
-#   System.cpp \
 #   TaskInfo.cpp \
 #
 

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-09-28 07:19:55 UTC (rev 527)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-09-28 07:43:39 UTC (rev 528)
@@ -5,770 +5,63 @@
 #include "System.h"
 
 #include "Object.h"
-#include "Model.h"
-#include "Vector.h"
-#include "Environment.h"
-#include "LogStream.h"
-#include "ODESolver.h"
-#include "ExplicitEuler.h"
-#include "Function.h"
-#include "Newton.h"
-#include "ModelVisitor.h"
-#include "Planet.h"
-#include "MobileRootJoint.h"
+#include "AbstractSystem.h"
 
 namespace OpenFDM {
 
-BEGIN_OPENFDM_OBJECT_DEF(System, ModelGroup)
+BEGIN_OPENFDM_OBJECT_DEF(System, Object)
   END_OPENFDM_OBJECT_DEF
 
-struct ModelListEntry {
-  SharedPtr<Model> model;
-  Node::Path nodePath;
-  SampleTimeSet sampleTimeSet;  
-};
-
-typedef std::list<ModelListEntry> ModelList2;
-
-class ModelCollectVisitor :
-    public ModelVisitor {
-public:
-  virtual ~ModelCollectVisitor(void)
-  { }
-  virtual void apply(Model& model)
-  {
-    ModelListEntry entry;
-    entry.model = &model;
-    entry.nodePath = getNodePath();
-    entry.sampleTimeSet = model.getSampleTimeSet();
-    if (entry.sampleTimeSet.isInherited()) {
-      SampleTimeSet::const_iterator it;
-      for (it = sampleTimeSet.begin(); it != sampleTimeSet.end(); ++it)
-        entry.sampleTimeSet.addSampleTime(*it);
-    }
-
-    SampleTimeSet::const_iterator it;
-    for (it = entry.sampleTimeSet.begin();
-         it != entry.sampleTimeSet.end(); ++it)
-      allSampleTimeSet.addSampleTime(*it);
-
-    modelList.push_back(entry);
-  }
-  virtual void apply(ModelGroup& modelGroup)
-  {
-    SampleTimeSet savedSet = sampleTimeSet;
-    if (modelGroup.getSampleTimeSet().isInherited()) {
-      SampleTimeSet::const_iterator it;
-      for (it = modelGroup.getSampleTimeSet().begin();
-           it != modelGroup.getSampleTimeSet().end(); ++it)
-        sampleTimeSet.addSampleTime(*it);
-    } else {
-      sampleTimeSet = modelGroup.getSampleTimeSet();
-    }
-    traverse(modelGroup);
-    sampleTimeSet = savedSet;
-  }
-
-  ModelList2 modelList;
-  SampleTimeSet sampleTimeSet;
-  SampleTimeSet allSampleTimeSet;
-};
-
-System::System(const std::string& name) :
-  ModelGroup(name),
-  mTime(0),
-  mNumContinousStates(0),
-  mNumDiscreteStates(0)
+System::System(const std::string& name, Node* node) :
+  Object(name),
+  mNode(node)
 {
-  setTimestepper(new ExplicitEuler);
-  mEnvironment = new Environment;
-  addSampleTime(SampleTime::Continous);
 }
 
-System::~System(void)
+System::~System()
 {
 }
 
 void
-System::accept(ModelVisitor& visitor)
+System::setNode(Node* node)
 {
-  visitor.handleNodePathAndApply(*this);
+  clear();
+  mNode = node;
 }
 
-static bool
-sortModels(ModelList2& mModels);
+/// FIXME: here should System::init be
 
-static void
-fillTaskInfo(TaskInfo& taskInfo, const ModelList2& modelList);
-
-bool
-System::init(void)
-{
-  // Reset the task scheduling stuff
-  mContinousModelList.clear();
-  mDiscreteModelList.clear();
-  mDiscreteTaskList.clear();
-  mCurrentTaskNum = 0u;
-  mCurrentSliceTime = 0;
-
-  // For now let init sort them and now build tasks from that
-  ModelCollectVisitor modelCollectVisitor;
-  accept(modelCollectVisitor);
-
-  // sett the environment, FIXME move somewhere into task
-  ModelList2::const_iterator mit;
-  mit = modelCollectVisitor.modelList.begin();
-  while (mit != modelCollectVisitor.modelList.end()) {
-    mit->model->setEnvironment(mEnvironment);
-    ++mit;
-  }
- 
-  OpenFDM::sortModels(modelCollectVisitor.modelList);
-
-  // Compute the basic time slice, that is the greatest time that hits all
-  // discrete sample times boundaries we have in this system
-  real_type gcd = 0;
-  real_type scm = 0;
-  real_type minSampleTime = Limits<real_type>::max();
-  SampleTimeSet sampleTimes = modelCollectVisitor.allSampleTimeSet;
-  SampleTimeSet::const_iterator it;
-  for (it = sampleTimes.begin(); it != sampleTimes.end(); ++it) {
-    if (!it->isDiscrete())
-      continue;
-
-    real_type sampleTime = it->getSampleTime();
-    OpenFDMAssert(0 < sampleTime);
-    minSampleTime = min(minSampleTime, sampleTime);
-    if (0 < gcd) {
-      gcd = greatestCommonDivisor(gcd, sampleTime);
-      scm = scm*sampleTime/greatestCommonDivisor(scm, sampleTime);
-    } else {
-      gcd = sampleTime;
-      scm = sampleTime;
-    }
-  }
-
-  // Now that we know the basic sample time, build the job schedules
-  Log(Schedule, Info) << "Basic time is: " << gcd << endl;
-  if (100*gcd < minSampleTime)
-    Log(Schedule, Warning) << "Basic sample time is less than 100 times "
-      "smaller than the smallest submodels sample time" << endl;
-
-  // We do not have any discrete sample time, just do continous scheduling
-  if (gcd <= 0)
-    return true;
-
-  // Check if we can handle that schedule within the bounds of our data types
-  // If it does not, the time slices are choosen too bad for realtime
-  // simulations anyway
-  real_type stepsPerCycle = floor(scm/gcd + 0.5);
-  if (Limits<unsigned>::max() <= stepsPerCycle) {
-    Log(Schedule, Error) << "Too many basic steps for our datatypes.\n"
-      "You propably want to use sample times fitting together.\n"
-      "Aborting!" << endl;
-    return false;
-  }
-  
-  // Alloc enough empty task infos.
-  mDiscreteTaskList.assign((unsigned)stepsPerCycle, TaskInfo());
-  // Put a TaskInfo entry into the list for all time schedules required
-  for (it = sampleTimes.begin(); it != sampleTimes.end(); ++it) {
-    if (!it->isDiscrete())
-      continue;
-
-    unsigned increment = unsigned(floor(it->getSampleTime()/gcd + 0.5));
-    for (unsigned i = 0; i < mDiscreteTaskList.size(); i += increment)
-      mDiscreteTaskList[i].addSampleTime(*it);
-  }
-  // FIXME: combine this step with the one above
-  TaskList cTL;
-  for (unsigned i = 0; i < mDiscreteTaskList.size(); ++i) {
-    if (!mDiscreteTaskList[i].getSampleTimeSet().empty())
-      cTL.push_back(mDiscreteTaskList[i]);
-    cTL.back().setSliceSize(cTL.back().getSliceSize() + gcd);
-    cTL.back().setNumBasicSteps(cTL.back().getNumBasicSteps() + 1);
-  }
-  mDiscreteTaskList.swap(cTL);
-
-  // Now precompute the list of models to be updated on each task
-  for (unsigned i = 0; i < mDiscreteTaskList.size(); ++i)
-    fillTaskInfo(mDiscreteTaskList[i], modelCollectVisitor.modelList);
-
-  mPerTimestepTask = TaskInfo();
-  mPerTimestepTask.addSampleTime(SampleTime::PerTimestep);
-  fillTaskInfo(mPerTimestepTask, modelCollectVisitor.modelList);
-
-  mContinousTask = TaskInfo();
-  mContinousTask.addSampleTime(SampleTime::Continous);
-  fillTaskInfo(mContinousTask, modelCollectVisitor.modelList);
-
-  mit = modelCollectVisitor.modelList.begin();
-  while (mit != modelCollectVisitor.modelList.end()) {
-    if (!mit->model->init()) {
-      Log(Schedule, Error) << "Error initializing Model \""
-                           << mit->model->getName() << "\".\n"
-                           << "Aborting!" << endl;
-      return false;
-    }
-    ++mit;
-  }
-
-  // build up the lists of stateful models and count the number of states
-  unsigned numContinousStates = 0;
-  unsigned numDiscreteStates = 0;
-  mit = modelCollectVisitor.modelList.begin();
-  while (mit != modelCollectVisitor.modelList.end()) {
-    if (mit->model->getNumContinousStates()) {
-      mContinousModelList.push_back(mit->model);
-      numContinousStates += mit->model->getNumContinousStates();
-    }
-    if (mit->model->getNumDiscreteStates()) {
-      mDiscreteModelList.push_back(mit->model);
-      numDiscreteStates += mit->model->getNumDiscreteStates();
-    }
-    ++mit;
-  }
-  setNumContinousStates(numContinousStates);
-  setNumDiscreteStates(numDiscreteStates);
-
-  // Just a verbose print here ...
-  Log(Schedule, Info) << "gcd of sample times is: " << gcd
-                   << ", scm of sample times is: " << scm << endl;
-  for (unsigned i = 0; i < mDiscreteTaskList.size(); ++i)
-    Log(Schedule, Info) << "Task # " << i << ": # basicSteps "
-                     << mDiscreteTaskList[i].getNumBasicSteps()
-                     << ", sliceSize "
-                     << mDiscreteTaskList[i].getSliceSize()
-                     << ", sample times "
-                     << mDiscreteTaskList[i].getSampleTimeSet() << endl;
-
-  // At the moment we need a timestepper, else the time does not get
-  // incremented
-  if (!mTimestepper) {
-    Log(Schedule, Error) << "Timestepping method is unset.\nAborting!" << endl;
-    return false;
-  }
-
-  mTimestepper->setTime(0);
-  mTime = 0;
-  mTimestepper->setStepsize(gcd);
-  return true;
-}
-
 void
-System::output(const TaskInfo& taskInfo)
+System::clear()
 {
-  taskInfo.output();
+  mAbstractSystem = 0;
+  mNodeInstanceList.clear();
 }
 
-void
-System::update(const TaskInfo& taskInfo)
-{
-  taskInfo.update();
-}
-
-void
-System::setState(const StateStream& state)
-{
-  ModelList::iterator it;
-  for (it = mContinousModelList.begin(); it != mContinousModelList.end(); ++it)
-    (*it)->setState(state);
-}
-
-void
-System::getState(StateStream& state) const
-{
-  ModelList::const_iterator it;
-  for (it = mContinousModelList.begin(); it != mContinousModelList.end(); ++it)
-    (*it)->getState(state);
-}
-
-void
-System::getStateDeriv(StateStream& stateDeriv)
-{
-  ModelList::iterator it;
-  for (it = mContinousModelList.begin(); it != mContinousModelList.end(); ++it)
-    (*it)->getStateDeriv(stateDeriv);
-}
-
-void
-System::setDiscreteState(const StateStream& state)
-{
-  ModelList::iterator it;
-  for (it = mDiscreteModelList.begin(); it != mDiscreteModelList.end(); ++it)
-    (*it)->setDiscreteState(state);
-}
-
-void
-System::getDiscreteState(StateStream& state) const
-{
-  ModelList::const_iterator it;
-  for (it = mDiscreteModelList.begin(); it != mDiscreteModelList.end(); ++it)
-    (*it)->getDiscreteState(state);
-}
-
+/// Simulate the system until the time tEnd
 bool
-System::simulate(real_type tEnd)
+System::simulate(const real_type& t)
 {
-  // Check if we need an ODE timestepper.
-  bool continousStates = 0 < getNumContinousStates();
-
-  // Since it is possible to change the models states in a non physical way
-  // outside this method, we need to read that state and set it into the
-  // timestepper. The timestepper needs to take care if it needs to be
-  // restarted. So just set it here.
-  StateStream stateStream(getNumContinousStates());
-  getState(stateStream);
-  Vector state = stateStream.getState();
-  // Exact check is currect here, the user does not have to fiddle with
-  // the state during simulation, if the state changes despite of that,
-  // Just spend that extra effort.
-  if (state != mTimestepper->getState()) {
-    mTimestepper->setState(state);
-    evalFunction(mTimestepper->getTime(), mTimestepper->getState(), state);
-  }
-
-  while (getTime() < tEnd) {
-    // This is the maximum time we can step in this loop
-    real_type loopTEnd = tEnd;
-
-    // Check if we have discrete systems with any discrete slice time
-    if (mDiscreteTaskList.empty()) {
-      // Leave it to the timestepping algorithm,
-      // to choose the size of the steps
-      loopTEnd = tEnd;
-    } else {
-      // need that  ...
-      mDiscreteTaskList[mCurrentTaskNum].setTime(getTime());
-      
-      if (mCurrentSliceTime == 0) {
-        const TaskInfo& taskInfo = mDiscreteTaskList[mCurrentTaskNum];
-        Log(Schedule, Info) << "Computing discrete output for Task # "
-                         << mCurrentTaskNum << ": # basicSteps "
-                         << taskInfo.getNumBasicSteps() << ", sliceSize "
-                         << taskInfo.getSliceSize() << ", sample times "
-                         << taskInfo.getSampleTimeSet() << endl;
-      
-        output(mDiscreteTaskList[mCurrentTaskNum]);
-        update(mDiscreteTaskList[mCurrentTaskNum]);
-      }
-
-      // Take the minimum of the current discrete tasks end and the given
-      // end time, take care of roundoff
-      real_type taskTEnd = mTime - mCurrentSliceTime
-        + mDiscreteTaskList[mCurrentTaskNum].getSliceSize();
-      if (equal(taskTEnd, tEnd, 100) || taskTEnd <= tEnd) {
-        loopTEnd = taskTEnd;
-        mCurrentSliceTime = 0;
-        ++mCurrentTaskNum;
-        if (mDiscreteTaskList.size() <= mCurrentTaskNum)
-          mCurrentTaskNum = 0;
-      } else {
-        loopTEnd = tEnd;
-        mCurrentSliceTime += tEnd - getTime();
-      }
-    }
-
-    if (!continousStates) {
-      mTime = loopTEnd;
-
-      Log(Schedule, Info) << "Preparing Models: continous output step" << endl;
-      mContinousTask.setTime(getTime());
-      output(mContinousTask);
-
-    } else {
-      // Do the pre integration output round
-      Log(Schedule, Info) << "Preparing Models: pre integration step" << endl;
-      mPerTimestepTask.setTime(getTime());
-      output(mPerTimestepTask);
-      update(mPerTimestepTask);
-
-      Log(Schedule, Info) << "Integration: from time "
-                          << mTimestepper->getTime()
-                          << " up to time " << loopTEnd
-                          << " dt = " << loopTEnd - mTimestepper->getTime()
-                          << endl;
-      // FIXME: check for errors
-      mTimestepper->integrate(loopTEnd);
-      mTime = mTimestepper->getTime();
-      Log(Schedule, Info) << "Integration: finished" << endl;
-      // Croase end check when it is too late, we might do stiffness
-      // detection at least within dopri in an other way ...
-      if (!isFinite(mTimestepper->getState())) {
-        Log(TimeStep, Warning) << "Found infinite values in continous state "
-          "vector. Consider using an other timestepping method or make your "
-          "model less stiff. Aborting!" << endl;
-        return false;
-      }
-
-      // It set's the current state into the models and computes the
-      // accelerations for the mechanical system
-      evalFunction(mTimestepper->getTime(), mTimestepper->getState(), state);
-    }
-
-    if (equal(mTime, tEnd, 10))
-      mTime = tEnd;
-  }
-
+  if (mAbstractSystem)
+    return false;
+  mAbstractSystem->outputAt(t);
   return true;
 }
 
-class TrimCollectorVisitor :
-    public ModelVisitor {
-public:
-  TrimCollectorVisitor(unsigned nStates) :
-    mStateStream(nStates)
-  { }
-  virtual ~TrimCollectorVisitor(void)
-  { }
-  virtual void apply(Model& model)
-  { model.getStateDeriv(mStateStream); }
-  virtual void apply(ModelGroup& modelGroup)
-  { traverse(modelGroup); }
-  virtual void apply(MobileRootJoint& mobileRootJoint)
-  {
-    mGeodPos = mobileRootJoint.getGeodPosition();
-    mGeodOr = mobileRootJoint.getGeodOrientation();
-    mVel = mobileRootJoint.getRelVel();
-    mVelDot = mobileRootJoint.getRelVelDot();
-    mPosDot = mobileRootJoint.getPosDot();
-    mQDot = mobileRootJoint.getQDot();
-    mMobileRootJoint = &mobileRootJoint;
-  }
-  Geodetic mGeodPos;
-  Quaternion mGeodOr;
-  Vector6 mVel;
-  Vector6 mVelDot;
-  Vector3 mPosDot;
-  Vector4 mQDot;
-  StateStream mStateStream;
-  MobileRootJoint* mMobileRootJoint;
-};
-
-class TrimFunction :
-    public Function {
-public:
-  TrimFunction(System& system) :
-    mSystem(system)
-  {
-    unsigned nStates = mSystem.getNumContinousStates();
-    TrimCollectorVisitor tcv(nStates);
-    mSystem.accept(tcv);
-    mGeodPos = tcv.mGeodPos;
-    mGeodOr = tcv.mGeodOr;
-    mVel = tcv.mVel;
-    mVelDot = tcv.mVelDot;
-    mPosDot = tcv.mPosDot;
-    mQDot = tcv.mQDot;
-  }
-  virtual unsigned inSize(void) const
-  { return mSystem.getNumContinousStates(); }
-  virtual unsigned outSize(void) const
-  { return mSystem.getNumContinousStates() + 6; }
-  virtual void eval(real_type t, const Vector& v, Vector& out)
-  {
-    unsigned nStates = mSystem.getNumContinousStates();
-    Vector deriv(nStates);
-    mSystem.evalFunction(t, v, deriv);
-
-    TrimCollectorVisitor tcv(nStates + 6);
-    mSystem.accept(tcv);
-    Vector3 eo = mGeodOr.getEuler();
-    Vector3 en = tcv.mGeodOr.getEuler();
-
-    /// 3 dof for the position
-    real_type tmp = 1e6*(mGeodPos.longitude - tcv.mGeodPos.longitude);
-    tcv.mStateStream.writeSubState(tmp);
-    tmp = 1e6*(mGeodPos.latitude - tcv.mGeodPos.latitude);
-    tcv.mStateStream.writeSubState(tmp);
-    tmp = smoothDeadBand(mGeodPos.altitude - tcv.mGeodPos.altitude, real_type(10));
-    tcv.mStateStream.writeSubState(tmp);
-
-    // The orientation
-    tmp = 1e2*smoothDeadBand(eo(0) - en(0), 20*deg2rad);
-    tcv.mStateStream.writeSubState(tmp);
-    tmp = 1e2*smoothDeadBand(eo(1) - en(1), 20*deg2rad);
-    tcv.mStateStream.writeSubState(tmp);
-    tmp = 1e2*(eo(2) - en(2));
-    tcv.mStateStream.writeSubState(tmp);
-
-//     tcv.mStateStream.writeSubState(1e2*norm(tcv.mQDot) + norm(tcv.mPosDot - mPosDot));
-    tcv.mStateStream.writeSubState(1e8*tcv.mQDot);
-    tcv.mStateStream.writeSubState(tcv.mPosDot - mPosDot);
-    tcv.mStateStream.writeSubState(1e6*tcv.mVelDot);
-
-    out = tcv.mStateStream.getState();
-  }
-// private:
-  System& mSystem;
-  Geodetic mGeodPos;
-  Quaternion mGeodOr;
-  Vector6 mVel;
-  Vector6 mVelDot;
-  Vector3 mPosDot;
-  Vector4 mQDot;
-};
-
-class AltitudeFinderTrimFunction :
-    public Function {
-public:
-  AltitudeFinderTrimFunction(System& system, real_type range) :
-    mSystem(system),
-    mRange(range)
-  {
-    unsigned nStates = mSystem.getNumContinousStates();
-    TrimCollectorVisitor tcv(nStates);
-    mSystem.accept(tcv);
-    mGeodPos = tcv.mGeodPos;
-    mGeodOr = tcv.mGeodOr;
-    mVel = tcv.mVel;
-    mVelDot = tcv.mVelDot;
-    mMobileRootJoint = tcv.mMobileRootJoint;
-  }
-  virtual unsigned inSize(void) const
-  { return 1; }
-  virtual unsigned outSize(void) const
-  { return 7; }
-  virtual void eval(real_type t, const Vector& v, Vector& out)
-  {
-    Geodetic geod = mGeodPos;
-    geod.altitude = mGeodPos.altitude - mRange*0.5 + v(0);
-    mMobileRootJoint->setGeodPosition(geod);
-    
-    unsigned nStates = mSystem.getNumContinousStates();
-    StateStream vv(nStates);
-    mSystem.getState(vv);
-    Vector deriv(nStates);
-    mSystem.evalFunction(t, vv.getState(), deriv);
-
-    TrimCollectorVisitor tcv(nStates + 6);
-    mSystem.accept(tcv);
-
-    /// The line search algorithm sees that the gravitation
-    /// is less in higher regions, thus we need to add a 'minimum altitude'
-    /// criterion
-    out.resize(7, 1);
-    out(Range(0, 5)) = tcv.mVelDot;
-//     out(6) = 1e-1*v(0);
-    out(6) = smoothDeadBand(v(0), mRange);
-    
-//     Log(Model,Error) << trans(v) << endl;
-//     Log(Model,Error) << trans(out) << endl;
-//     Log(Model,Error) << mGeodPos << geod << endl << endl;
-  }
-// private:
-  System& mSystem;
-  real_type mRange;
-  Geodetic mGeodPos;
-  Quaternion mGeodOr;
-  Vector6 mVel;
-  Vector6 mVelDot;
-  MobileRootJoint* mMobileRootJoint;
-};
-
+/// Bring the system in an equilibrum state near the current state ...
 bool
 System::trim(void)
 {
-  // need to prepare the System especially for the per step tasks
-  TaskInfo taskInfo = mDiscreteTaskList[0];
-//   taskInfo.setTime(getTime());
-  taskInfo.addSampleTime(SampleTime::Continous);
-  taskInfo.addSampleTime(SampleTime::PerTimestep);
-  output(taskInfo);
-  output(mPerTimestepTask);
-  output(mContinousTask);
-
-  /// First try to find an altitude where the acceleration is minimal,
-  /// this is most likely a good starting point for the subsequent total trim
-  real_type range = 20;
-  AltitudeFinderTrimFunction altTrim(*this, range);
-
-  // Buld up the trim function
-  TrimFunction trimFunction(*this);
-
-  Vector altV(1);
-  altV(0) = 0;
-  Vector dk(1);
-  dk(0) = 1;
-  Vector res = LineSearch(altTrim, getTime(), altV, dk, range, 1e-3);
-  altTrim.eval(getTime(), res, dk /*dummy*/);
-  output(taskInfo);
-
-  trimFunction.mGeodPos.altitude = altTrim.mGeodPos.altitude;
-
-  // Get the current state
-  StateStream stateStream(getNumContinousStates());
-  getState(stateStream);
-  Vector state = stateStream.getState();
-
-  Vector trimState = stateStream.getState();
-
-  // Try to find a minimum
-  real_type atol = 1e-10;
-  real_type rtol = 1e-13;
-//   bool ret = GaussNewton(trimFunction, getTime(), trimState, atol, rtol);
-  bool ret = LevenbergMarquart(trimFunction, getTime(), trimState, atol, rtol);
-  if (ret) {
-    Log(Model, Debug) << "Trim did converge" << endl;
-    stateStream.setState(trimState);
-    setState(stateStream);
-  } else {
-    Log(Model, Warning) << "Trim did NOT converge" << endl;
-    stateStream.setState(state);
-    setState(stateStream);
-  }
-
-  return ret;
+  return false;
 }
 
-void
-System::setTimestepper(ODESolver* timestepper)
+/// Return the current simulation time, convenience function
+real_type
+System::getTime(void) const
 {
-  real_type t = 0;
-  if (mTimestepper) {
-    mTimestepper->setSystem(0);
-    t = mTimestepper->getTime();
-  }
-  mTimestepper = timestepper;
-  if (mTimestepper) {
-    mTimestepper->setSystem(this);
-    mTimestepper->setTime(t);
-  }
+  if (!mAbstractSystem)
+    return Limits<real_type>::quiet_NaN();
+  return mAbstractSystem->getTime();
 }
 
-void
-System::evalFunction(real_type t, const Vector& v, Vector& out)
-{
-  /// FIXME Hmm, may be different ...
-  StateStream stateStream(v);
-  setState(v);
-
-  mContinousTask.setTime(t);
-  output(mContinousTask);
-
-  stateStream.reset();
-  getStateDeriv(stateStream);
-  out = stateStream.getState();
-}
-
-void
-System::evalJacobian(real_type t, const Vector& v, Matrix& jac)
-{
-  unsigned nStates = getNumContinousStates();
-
-  // Create space ...
-  // FIXME
-  jac.resize(nStates, nStates);
-
-  // Get the function value at the current position.
-  Vector fv(nStates);
-  evalFunction(t, v, fv);
-
-  real_type sqrteps = 1e4*sqrt(Limits<real_type>::epsilon());
-
-  Vector tmpv = v;
-  Vector tmpfv(nStates);
-  for (unsigned i = 0; i < nStates; ++i) {
-    tmpv(i) += sqrteps;
-
-    // Evaluate then function ...
-    evalFunction(t, tmpv, tmpfv);
-
-    // ... and compute the differencequotient to approximate the derivative.
-    jac(Range(0, nStates-1), i) = (1/sqrteps)*(tmpfv-fv);
-
-    // Restore the original value.
-    tmpv(i) = v(i);
-  }
-}
-
-void
-System::setNumContinousStates(unsigned numContinousStates)
-{
-  mNumContinousStates = numContinousStates;
-}
-
-void
-System::setNumDiscreteStates(unsigned numDiscreteStates)
-{
-  mNumDiscreteStates = numDiscreteStates;
-}
-
-
-// FIXME make a member of TaskInfo
-static void
-fillTaskInfo(TaskInfo& taskInfo, const ModelList2& modelList)
-{
-  ModelList2::const_iterator it;
-  it = modelList.begin();
-  while (it != modelList.end()) {
-    if (nonZeroIntersection(taskInfo.getSampleTimeSet(), it->sampleTimeSet))
-      taskInfo.appendModel(it->model);
-    ++it;
-  }
-}
-
-static bool
-appendModel(ModelList2& mModels, Model* firstModel, ModelListEntry model,
-            ModelList2& newList)
-{
-  if (model.model->dependsDirectOn(firstModel)) {
-    Log(Model,Error) << "Detected circular dependency starting from Model \""
-                     << firstModel->getName() << "\" to Model \""
-                     << model.model->getName() << "\"" << endl;
-  }
-
-  ModelList2::iterator it = mModels.begin();
-  while (it != mModels.end()) {
-    if (model.model->dependsDirectOn(it->model)) {
-      // We need to store that one here since the iterator possibly invalidates
-      // during the next append dependency call
-      ModelListEntry tmpModel = *it;
-      mModels.erase(it);
-      
-      // Now recurse into that model.
-      if (!appendModel(mModels, firstModel, tmpModel, newList))
-        return false;
-
-      // the iterator is most likely invalid ...
-      it = mModels.begin();
-    } else
-      ++it;
-  }
-  newList.push_back(model);
-  return true;
-}
-
-static bool
-sortModels(ModelList2& mModels)
-{
-  // TODO: use better sort algorithm.
-  /// erhm, FIXME: This is a horrible sort thing!!!
-  ModelList2 newList;
-  while (!mModels.empty()) {
-    ModelListEntry tmpModel = mModels.front();
-    mModels.erase(mModels.begin());
-
-    if (!appendModel(mModels, tmpModel.model, tmpModel, newList))
-      return false;
-  }
-  // Now the new ordered list is the current one.
-  mModels.swap(newList);
-
-  // print the schedule ...
-  Log(Schedule,Info) << "Model Schedule:" << endl;
-  ModelList2::const_iterator it;
-  it = mModels.begin();
-  while (it != mModels.end()) {
-    Node::Path::const_iterator ni;
-    for (ni = it->nodePath.begin(); ni != it->nodePath.end(); ++ni)
-      Log(Schedule,Info) << "/" << (*ni)->getName();
-    Log(Schedule,Info) << "/" << it->model->getName() << " "
-                       << it->sampleTimeSet << endl;
-    ++it;
-  }
-
-  return true;
-}
-
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/System.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/System.h	2008-09-28 07:19:55 UTC (rev 527)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/System.h	2008-09-28 07:43:39 UTC (rev 528)
@@ -7,114 +7,47 @@
 
 #include <string>
 
-#include "ModelGroup.h"
-#include "Environment.h"
+#include "AbstractNodeInstance.h"
+#include "Node.h"
+#include "Object.h"
 
 namespace OpenFDM {
 
-/// The System is the top \ref Model node.
-/// It is derived from the \ref ModelGroup and additionally provides
-/// algorithms to simulate and trim the whole system.
+/// The System is the top \ref Node for a simulation system.
+/// Provides algorithms to simulate and trim the whole system.
 
-class TaskInfo;
+class AbstractSystem;
 
-class ODESolver;
-
-class System : public ModelGroup {
-  OPENFDM_OBJECT(System, ModelGroup);
+class System : public Object {
+  OPENFDM_OBJECT(System, Object);
 public:
-  /// Constructor, we need a name
-  System(const std::string& name);
-  virtual ~System(void);
+  System(const std::string& name, Node* node = 0);
+  virtual ~System();
 
-  /// Double dispatch helper for the multibody system visitor
-  virtual void accept(ModelVisitor& visitor);
-  /// Double dispatch helper for the multibody system visitor
-//   virtual void accept(ConstModelVisitor& visitor) const;
+  SharedPtr<Node> getNode() { return mNode; }
+  SharedPtr<const Node> getNode() const { return mNode; }
+  void setNode(Node* node);
 
-  /// Set the system to its initial state
-  virtual bool init(void);
+  bool init();
+  void clear();
 
-  /// Note that this is called *before* update() is called.
-  virtual void output(const TaskInfo& taskInfo);
-  /// Called whenever discrete states need to be updated.
-  virtual void update(const TaskInfo& taskInfo);
-
-  virtual void setState(const StateStream& state);
-  virtual void getState(StateStream& state) const;
-  virtual void getStateDeriv(StateStream& stateDeriv);
-
-  virtual void setDiscreteState(const StateStream& state);
-  virtual void getDiscreteState(StateStream& state) const;
-
   /// Simulate the system until the time tEnd
-  bool simulate(real_type tEnd);
+  bool simulate(const real_type& t);
 
-  /// Bring the system in an equilibrum state near the current state
-  /// ...
+  /// Bring the system in an equilibrum state near the current state ...
   bool trim(void);
 
   /// Return the current simulation time, convenience function
-  real_type getTime(void) const
-  { return mTime; }
+  real_type getTime(void) const;
 
-  /// Sets a timestepping algorithm for use with this system.
-  void setTimestepper(ODESolver* timestepper);
-  /// Return a const reference to the timestepping algorithm
-  const ODESolver* getTimestepper(void) const { return mTimestepper; }
-  /// Return a reference to the timestepping algorithm
-  ODESolver* getTimestepper(void) { return mTimestepper; }
+  const NodeInstanceList& getNodeInstanceList() const
+  { return mNodeInstanceList; }
 
-  /// FIXME Hmm, may be different ...
-  /// May move into System ...
-  void evalFunction(real_type t, const Vector& v, Vector& out);
-  /// Compute the jacobian
-  /// The default implementation computes a numeric approximation by finite
-  /// differences
-  void evalJacobian(real_type t, const Vector& state, Matrix& jac);
-
-  Environment* getEnvironment(void) const
-  { return mEnvironment; }
-
-  /// Return the number of continous states
-  unsigned getNumContinousStates(void) const
-  { return mNumContinousStates; }
-  /// Return the number of discrete states
-  unsigned getNumDiscreteStates(void) const
-  { return mNumDiscreteStates; }
-
-protected:
-  void setNumContinousStates(unsigned numContinousStates);
-  void setNumDiscreteStates(unsigned numDiscreteStates);
-
 private:
-  /// The timestepper used to get time discrete approximate solutions to the
-  /// continous system
-  SharedPtr<ODESolver> mTimestepper;
+  SharedPtr<Node> mNode;
 
-  /// Hmm, need to think about this...
-  typedef std::vector<TaskInfo> TaskList;
-
-  TaskInfo mPerTimestepTask;
-  TaskInfo mContinousTask;
-
-  TaskList mDiscreteTaskList;
-  unsigned mCurrentTaskNum;
-  real_type mCurrentSliceTime;
-
-  typedef std::vector<SharedPtr<Model> > ModelList;
-  ModelList mDiscreteModelList;
-  ModelList mContinousModelList;
-
-  SharedPtr<Environment> mEnvironment;
-
-  /// The actual simulation time for the system
-  real_type mTime;
-
-  /// The number of states in the whole System,
-  /// might move into something like IntegrationGroup
-  unsigned mNumContinousStates;
-  unsigned mNumDiscreteStates;
+  SharedPtr<AbstractSystem> mAbstractSystem;
+  NodeInstanceList mNodeInstanceList;
 };
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-28 07:19:55 UTC (rev 527)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-28 07:43:39 UTC (rev 528)
@@ -34,6 +34,7 @@
 #include <OpenFDM/Interval.h>
 
 #include <OpenFDM/AbstractSystem.h>
+#include <OpenFDM/System.h>
 
 #include <OpenFDM/BoolStateInfo.h>
 #include <OpenFDM/RealStateInfo.h>
@@ -110,70 +111,8 @@
 /// there must be a PortData like structure that is only built during simulation
 /// model initialization.
 
-/// An Abstract NodeInstance represents an effective model node in a ready
-/// to run System. You can access the Nodes Ports values for example.
-/// This class is meant to show up in the user interface of this simulation.
-class AbstractNodeInstance : public WeakReferenced {
-public:
-  AbstractNodeInstance(const NodePath& nodePath) :
-    mNodePath(nodePath)
-  { OpenFDMAssert(!nodePath.empty()); }
-  virtual ~AbstractNodeInstance()
-  { }
 
-  /// The actual Node this AbstractNodeInstance stems from
-  const Node& getNode() const
-  { return getNodeContext().getNode(); }
 
-  const NodePath& getNodePath() const { return mNodePath; }
-
-//   /// Set the sample times this node will run on
-//   void setSampleTimeSet(const SampleTimeSet& sampleTimeSet)
-//   { mSampleTimeSet = sampleTimeSet; }
-//   /// Get the sample times this node will run on
-//   const SampleTimeSet& getSampleTimeSet() const
-//   { return mSampleTimeSet; }
-
-  PortValueList& getPortValueList()
-  { return getNodeContext().getPortValueList(); }
-  const PortValueList& getPortValueList() const
-  { return getNodeContext().getPortValueList(); }
-
-  std::string getNodeNamePath() const
-  {
-    if (mNodePath.empty())
-      return std::string();
-    std::string path = mNodePath.front()->getName();
-    NodePath::const_iterator i = mNodePath.begin();
-    if (i != mNodePath.end()) {
-      for (++i; i != mNodePath.end(); ++i) {
-        path += '/';
-        path += (*i)->getName();
-      }
-    }
-    return path;
-  }
-
-protected:
-  AbstractNodeInstance() {}
-
-  /// The node context that belongs to this instance.
-  virtual AbstractNodeContext& getNodeContext() = 0;
-  virtual const AbstractNodeContext& getNodeContext() const = 0;
-
-private:
-  AbstractNodeInstance(const AbstractNodeInstance&);
-  AbstractNodeInstance& operator=(const AbstractNodeInstance&);
-
-//   /// The sample times this node will run on
-//   SampleTimeSet mSampleTimeSet;
-
-  NodePath mNodePath;
-};
-
-typedef std::list<SharedPtr<AbstractNodeInstance> > NodeInstanceList;
-
-
 ////////////////////////////////////////////////////////////////////////////
 
 /// This one will not show up in any execution list, but will be used
@@ -1107,82 +1046,27 @@
   SharedPtr<ContinousTask> mContinousTask;
 };
 
-class System : public Object {
-public:
-  System(const std::string& name, Node* node = 0) :
-    Object(name),
-    mNode(node)
-  { }
-
-  SharedPtr<Node> getNode()
-  { return mNode; }
-  SharedPtr<const Node> getNode() const
-  { return mNode; }
-  void setNode(Node* node)
-  {
-    clear();
-    mNode = node;
-  }
-
-  bool init()
-  {
-    if (!mNode)
-      return false;
-
-    // Build up the lists required to run the model.
-    NodeInstanceCollector nodeInstanceCollector;
-    mNode->accept(nodeInstanceCollector);
-    
-    mAbstractSystem = nodeInstanceCollector.buildSystem();
-    if (!mAbstractSystem)
-      return false;
-
-    // Have something to run in our hands.
-    // Not get the information required to reflect the system to the user.
-    mNodeInstanceList.swap(nodeInstanceCollector._nodeInstanceList);
-
-    return true;
-  }
-
-  void clear()
-  {
-    mAbstractSystem = 0;
-    mNodeInstanceList.clear();
-  }
-
-  /// Simulate the system until the time tEnd
-  bool simulate(const real_type& t)
-  {
-    if (mAbstractSystem)
-      return false;
-    mAbstractSystem->outputAt(t);
-    return true;
-  }
-
-  /// Bring the system in an equilibrum state near the current state ...
-  bool trim(void)
-  {
+bool
+System::init()
+{
+  if (!mNode)
     return false;
-  }
+  
+  // Build up the lists required to run the model.
+  NodeInstanceCollector nodeInstanceCollector;
+  mNode->accept(nodeInstanceCollector);
+  
+  mAbstractSystem = nodeInstanceCollector.buildSystem();
+  if (!mAbstractSystem)
+    return false;
+  
+  // Have something to run in our hands.
+  // Not get the information required to reflect the system to the user.
+  mNodeInstanceList.swap(nodeInstanceCollector._nodeInstanceList);
+  
+  return true;
+}
 
-  /// Return the current simulation time, convenience function
-  real_type getTime(void) const
-  {
-    if (!mAbstractSystem)
-      return Limits<real_type>::quiet_NaN();
-    return mAbstractSystem->getTime();
-  }
-
-  const NodeInstanceList& getNodeInstanceList() const
-  { return mNodeInstanceList; }
-
-private:
-  SharedPtr<Node> mNode;
-
-  SharedPtr<AbstractSystem> mAbstractSystem;
-  NodeInstanceList mNodeInstanceList;
-};
-
 } // namespace OpenFDM
 
 using namespace OpenFDM;



From frohlich at mail.berlios.de  Sun Sep 28 10:02:40 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 28 Sep 2008 10:02:40 +0200
Subject: [OpenFDM-svn] r529 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200809280802.m8S82egY026744@sheep.berlios.de>

Author: frohlich
Date: 2008-09-28 10:02:40 +0200 (Sun, 28 Sep 2008)
New Revision: 529

Modified:
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Clean up preliminary system setup a bit ...


Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-28 07:43:39 UTC (rev 528)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-28 08:02:40 UTC (rev 529)
@@ -843,6 +843,35 @@
   typedef std::list<SharedPtr<PortDataHelper::PortDataList> > PortDataListList;
   PortDataListList _portDataListList;
 
+  // Here the miracle occurs.
+  // The collected simulation nodes are packed into something that can be used
+  // to simulate the system.
+  AbstractSystem* buildSystem()
+  {
+    // Allocates and distributes the PortValues, is required for the sort
+    // steps below
+    if (!allocPortValues())
+      return 0;
+    // The model instances are sorted to match the direct input property
+    if (!sortModelList())
+      return 0;
+    // Now that they are sorted, allocate the port sizes and with that
+    // knowledge the state values.
+    if (!allocModels())
+      return 0;
+
+    // FIXME is here just for curiousity :)
+    ModelInstanceList::const_iterator i;
+    for (i = _modelInstanceList.begin(); i != _modelInstanceList.end(); ++i) {
+      (*i)->getNodeContext().init();
+      (*i)->getNodeContext().output(*reinterpret_cast<Task*>(0));
+    }
+
+    // FIXME:
+    return new GroupedSystem;
+  }
+
+protected:
   // method to sort the leafs according to their dependency
   bool sortModelList()
   {
@@ -893,27 +922,6 @@
     return true;
   }
 
-  // Here the miracle occurs.
-  // The collected simulation nodes are packed into something that can be used
-  // to simulate the system.
-  AbstractSystem* buildSystem()
-  {
-    // Allocates and distributes the PortValues, is required for the sort
-    // steps below
-    if (!allocPortValues())
-      return 0;
-    // The model instances are sorted to match the direct input property
-    if (!sortModelList())
-      return 0;
-
-    ModelInstanceList modelContextList;
-    getModelContextList(modelContextList);
-    // ...
-
-    // FIXME:
-    return new GroupedSystem;
-  }
-
   bool
   allocPortValues()
   {
@@ -927,32 +935,16 @@
     return true;
   }
 
-  bool
-  getModelContextList(ModelInstanceList& modelContexts)
+  bool allocModels()
   {
-    modelContexts.resize(0);
-
-    ModelInstanceList modelContextList;
     ModelInstanceList::const_iterator i;
-    for (i = _modelInstanceList.begin(); i != _modelInstanceList.end(); ++i)
-      modelContextList.push_back((*i));
-
-    ModelInstanceList::const_iterator j;
-    for (j = modelContextList.begin(); j != modelContextList.end(); ++j) {
-      if (!(*j)->getNodeContext().alloc()) {
+    for (i = _modelInstanceList.begin(); i != _modelInstanceList.end(); ++i) {
+      if (!(*i)->getNodeContext().alloc()) {
         Log(Schedule, Error) << "Could not alloc for model \""
-                             << (*j)->getNodeNamePath() << "\"" << endl;
+                             << (*i)->getNodeNamePath() << "\"" << endl;
         return false;
       }
     }
-
-    // FIXME is here just for curiousity :)
-    for (j = modelContextList.begin(); j != modelContextList.end(); ++j) {
-      (*j)->getNodeContext().init();
-      (*j)->getNodeContext().output(*reinterpret_cast<Task*>(0));
-    }
-
-    modelContexts.swap(modelContextList);
     return true;
   }
 



From frohlich at mail.berlios.de  Sun Sep 28 10:10:10 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 28 Sep 2008 10:10:10 +0200
Subject: [OpenFDM-svn] r530 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200809280810.m8S8AArI027129@sheep.berlios.de>

Author: frohlich
Date: 2008-09-28 10:10:09 +0200 (Sun, 28 Sep 2008)
New Revision: 530

Modified:
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
The init step is an init/output step ...


Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-28 08:02:40 UTC (rev 529)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-28 08:10:09 UTC (rev 530)
@@ -232,10 +232,12 @@
         return false;
     return true;
   }
-  void init() const
+  void init(const Task& task) const
   {
-    for (list_type::const_iterator i = begin(); i != end(); ++i)
+    for (list_type::const_iterator i = begin(); i != end(); ++i) {
       (*i)->init();
+      (*i)->output(task);
+    }
   }
   void output(const Task& task) const
   {



From frohlich at mail.berlios.de  Sun Sep 28 17:08:02 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 28 Sep 2008 17:08:02 +0200
Subject: [OpenFDM-svn] r531 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200809281508.m8SF82ca013782@sheep.berlios.de>

Author: frohlich
Date: 2008-09-28 17:08:01 +0200 (Sun, 28 Sep 2008)
New Revision: 531

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/DiscreteIntegrator.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/DiscreteIntegrator.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
Log:
Reinstantiate the DiscreteIntegrator ...


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/DiscreteIntegrator.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/DiscreteIntegrator.cpp	2008-09-28 08:10:09 UTC (rev 530)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/DiscreteIntegrator.cpp	2008-09-28 15:08:01 UTC (rev 531)
@@ -4,6 +4,7 @@
 
 #include "DiscreteIntegrator.h"
 #include "Assert.h"
+#include "LeafContext.h"
 
 namespace OpenFDM {
 
@@ -14,14 +15,13 @@
   END_OPENFDM_OBJECT_DEF
 
 DiscreteIntegrator::DiscreteIntegrator(const std::string& name) :
-  Model(name)
+  Model(name),
+  mInputPort(newMatrixInputPort("input", false)),
+  mOutputPort(newMatrixOutputPort("output")),
+  mInitialValue(Matrix::zeros(1, 1))
 {
-  setNumInputPorts(2);
-  setInputPortName(0, "derivative");
-  setInputPortName(1, "initialValue");
-
-  setNumOutputPorts(1);
-  setOutputPort(0, "output", this, &DiscreteIntegrator::getIntegralOutput);
+  mMatrixStateInfo = new MatrixStateInfo;
+  addDiscreteStateInfo(mMatrixStateInfo);
 }
 
 DiscreteIntegrator::~DiscreteIntegrator(void)
@@ -29,97 +29,79 @@
 }
 
 bool
-DiscreteIntegrator::init(void)
+DiscreteIntegrator::alloc(LeafContext& leafContext) const
 {
-  mDerivativePort = getInputPort(0)->toMatrixPortHandle();
-  if (!mDerivativePort.isConnected()) {
-    Log(Model,Error) << "Input port to DiscreteIntegrator Model \""
-                     << getName() << "\" is not connected" << endl;
-    return false;
-  }
-
-  // The initial value defaults to zero
-  mInitialValuePort = getInputPort(1)->toMatrixPortHandle();
-  if (mInitialValuePort.isConnected()) {
-    mIntegralState = mInitialValuePort.getMatrixValue();
+  Size sz;
+  if (getEnableInitialValuePort()) {
+    sz = size(leafContext.mPortValueList[mInitialValuePort]);
+    Log(Initialization, Debug)
+      << "Size for Integrator is detemined by the initial input "
+      << "port with size: " << trans(sz) << std::endl;
   } else {
-    if (rows(mInitialValue) == 0 || cols(mInitialValue) == 0) {
-      mInitialValue.resize(mDerivativePort.getMatrixValue());
-      mInitialValue.clear();
-    }
-    mIntegralState = mInitialValue;
+    sz = size(mInitialValue);
+    Log(Initialization, Debug)
+      << "Size for Integrator is detemined by the static initial value "
+      << "with size: " << trans(sz) << std::endl;
   }
-  mIntegralOutput = mIntegralState;
-
-  if (size(mMinSaturation) != Size(0, 0)) {
-    OpenFDMAssert(size(mMinSaturation) == size(mIntegralState));
+  if (!leafContext.mPortValueList.setOrCheckPortSize(mInputPort, sz)) {
+    Log(Initialization, Error)
+      << "Size for input port does not match!" << std::endl;
+    return false;
   }
-  if (size(mMaxSaturation) != Size(0, 0)) {
-    OpenFDMAssert(size(mMaxSaturation) == size(mIntegralState));
+  if (!leafContext.mPortValueList.setOrCheckPortSize(mOutputPort, sz)) {
+    Log(Initialization, Error)
+      << "Size for input port does not match!" << std::endl;
+    return false;
   }
-
-  setNumDiscreteStates(rows(mIntegralState)*cols(mIntegralState));
-  
-  return Model::init();
+  leafContext.mDiscreteState.setValue(*mMatrixStateInfo, leafContext);
+  return true;
 }
 
 void
-DiscreteIntegrator::output(const TaskInfo&)
+DiscreteIntegrator::init(DiscreteStateValueVector& discreteState,
+                         ContinousStateValueVector&,
+                         const PortValueList& portValues) const
 {
-  if (mInitialValuePort.isConnected()) {
-    mIntegralState = mInitialValuePort.getMatrixValue();
-    // FIXME: must have a reset slot or something like that
-    mInitialValuePort = 0;
+  if (getEnableInitialValuePort()) {
+    // external initial condition
+    discreteState[*mMatrixStateInfo] = portValues[mInitialValuePort];
+  } else {
+    // internal initial condition
+    discreteState[*mMatrixStateInfo] = mInitialValue;
   }
-
-  mIntegralOutput = mIntegralState;
 }
 
 void
-DiscreteIntegrator::update(const TaskInfo& taskInfo)
+DiscreteIntegrator::output(const DiscreteStateValueVector& discreteState,
+                           const ContinousStateValueVector&,
+                           PortValueList& portValues) const
 {
-  OpenFDMAssert(mDerivativePort.isConnected());
-
-  // Just compute the integral.
-  // FIXME: make sure this is the only dt ...
-  real_type dt = (*taskInfo.getSampleTimeSet().begin()).getSampleTime();
-  mIntegralState += dt*mDerivativePort.getMatrixValue();
-
-  // Hmm, should that be done on state setting too???
-  if (size(mMaxSaturation) == size(mIntegralState))
-    mIntegralState = LinAlg::min(mIntegralState, mMaxSaturation);
-  if (size(mMinSaturation) == size(mIntegralState))
-    mIntegralState = LinAlg::max(mIntegralState, mMinSaturation);
+  portValues[mOutputPort] = discreteState[*mMatrixStateInfo];
 }
 
 void
-DiscreteIntegrator::setDiscreteState(const StateStream& state)
+DiscreteIntegrator::doUpdate(Matrix& integralValue, const Matrix& derivative,
+                             const real_type& dt) const
 {
-  state.readSubState(mIntegralState);
+  integralValue += dt*derivative;
+
+  if (size(mMaxSaturation) == size(integralValue))
+    integralValue = LinAlg::min(integralValue, mMaxSaturation);
+  if (size(mMinSaturation) == size(integralValue))
+    integralValue = LinAlg::max(integralValue, mMinSaturation);
 }
 
 void
-DiscreteIntegrator::getDiscreteState(StateStream& state) const
+DiscreteIntegrator::update(DiscreteStateValueVector& discreteState,
+                           ContinousStateValueVector&,
+                           const PortValueList& portValues) const
 {
-  state.writeSubState(mIntegralState);
+  // Just compute the integral.
+  // FIXME: have no task info up to now !!!
+  real_type dt = 1;//(*taskInfo.getSampleTimeSet().begin()).getSampleTime();
+  doUpdate(discreteState[*mMatrixStateInfo], portValues[mInputPort], dt);
 }
 
-bool
-DiscreteIntegrator::dependsDirectOn(Model* model)
-{
-  if (getInputPort(1)) {
-    // return true if we find the one connected to the initial value port
-    for (unsigned j = 0; j < model->getNumOutputPorts(); ++j) {
-      if (getInputPort(1)->getPortInterface() &&
-          getInputPort(1)->getPortInterface() ==
-          model->getOutputPort(j)->getPortInterface())
-        return true;
-    }
-  }
-
-  return false;
-}
-
 const Matrix&
 DiscreteIntegrator::getInitialValue(void) const
 {
@@ -132,6 +114,24 @@
   mInitialValue = value;
 }
 
+bool
+DiscreteIntegrator::getEnableInitialValuePort() const
+{
+  return mInitialValuePort.empty();
+}
+
+void
+DiscreteIntegrator::setEnableInitialValuePort(bool enable)
+{
+  if (enable == getEnableInitialValuePort())
+    return;
+
+  if (enable)
+    mInitialValuePort = newMatrixInputPort("initialValue", true);
+  else 
+    mInitialValuePort.clear();
+}
+
 const Matrix&
 DiscreteIntegrator::getMinSaturation(void) const
 {
@@ -156,10 +156,4 @@
   mMaxSaturation = value;
 }
 
-const Matrix&
-DiscreteIntegrator::getIntegralOutput(void) const
-{
-  return mIntegralOutput;
-}
-
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/DiscreteIntegrator.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/DiscreteIntegrator.h	2008-09-28 08:10:09 UTC (rev 530)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/DiscreteIntegrator.h	2008-09-28 15:08:01 UTC (rev 531)
@@ -7,6 +7,7 @@
 
 #include "Types.h"
 #include "Model.h"
+#include "TemplateDiscreteStateInfo.h"
 
 namespace OpenFDM {
 
@@ -16,41 +17,42 @@
   DiscreteIntegrator(const std::string& name);
   virtual ~DiscreteIntegrator(void);
 
-  virtual bool init(void);
-  virtual void output(const TaskInfo&);
-  virtual void update(const TaskInfo& taskInfo);
+  virtual bool alloc(LeafContext& leafContext) const;
+  virtual void init(DiscreteStateValueVector& discreteState,
+                    ContinousStateValueVector&, const PortValueList&) const;
+  virtual void output(const DiscreteStateValueVector& discreteState,
+                      const ContinousStateValueVector&,
+                      PortValueList& portValues) const;
+  virtual void update(DiscreteStateValueVector& discreteState,
+                      ContinousStateValueVector&,
+                      const PortValueList& portValues) const;
 
-  virtual void setDiscreteState(const StateStream& state);
-  virtual void getDiscreteState(StateStream& state) const;
+  /// The initial output values on the output until input values are available.
+  const Matrix& getInitialValue() const;
+  void setInitialValue(const Matrix& initialValue);
 
-  virtual bool dependsDirectOn(Model* model);
+  bool getEnableInitialValuePort() const;
+  void setEnableInitialValuePort(bool enable);
 
-  const Matrix& getInitialValue(void) const;
-  void setInitialValue(const Matrix& value);
-
   const Matrix& getMinSaturation(void) const;
   void setMinSaturation(const Matrix& value);
 
   const Matrix& getMaxSaturation(void) const;
   void setMaxSaturation(const Matrix& value);
 
-  const Matrix& getIntegralOutput(void) const;
+private:
+  void doUpdate(Matrix& integralValue, const Matrix& derivative,
+                const real_type& dt) const;
 
-private:
-  /// Holds the current output.
-  Matrix mIntegralOutput;
-  /// Holds the current integral state.
-  Matrix mIntegralState;
-  /// Holds the current integral initial state.
+  typedef TemplateDiscreteStateInfo<Matrix> MatrixStateInfo;
+
+  MatrixInputPort mInputPort;
+  MatrixOutputPort mOutputPort;
+  MatrixInputPort mInitialValuePort;
   Matrix mInitialValue;
-  /// Holds the minimum saturation
   Matrix mMinSaturation;
-  /// Holds the maximum saturation
   Matrix mMaxSaturation;
-  /// Holds a matrix handle to the integrators input
-  MatrixPortHandle mDerivativePort;
-  /// Holds a matrix handle to the integrators initial value input
-  MatrixPortHandle mInitialValuePort;
+  SharedPtr<MatrixStateInfo> mMatrixStateInfo;
 };
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-09-28 08:10:09 UTC (rev 530)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-09-28 15:08:01 UTC (rev 531)
@@ -231,6 +231,7 @@
 
 OpenFDMModelsSOURCES = \
   Delay.cpp \
+  DiscreteIntegrator.cpp \
   Gain.cpp \
   Integrator.cpp \
   Output.cpp
@@ -248,7 +249,6 @@
 #   DefaultGround.cpp \
 #   DefaultPlanet.cpp \
 #   DiscBrake.cpp \
-#   DiscreteIntegrator.cpp \
 #   ExternalForceModel.cpp \
 #   FixedRootJoint.cpp \
 #   Force.cpp \



From frohlich at mail.berlios.de  Sun Sep 28 17:24:32 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 28 Sep 2008 17:24:32 +0200
Subject: [OpenFDM-svn] r532 - in branches/OpenFDM-StateSeparation/src:
	OpenFDM test
Message-ID: <200809281524.m8SFOWaN014994@sheep.berlios.de>

Author: frohlich
Date: 2008-09-28 17:24:31 +0200 (Sun, 28 Sep 2008)
New Revision: 532

Added:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Task.h
Removed:
   branches/OpenFDM-StateSeparation/src/OpenFDM/TaskInfo.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/TaskInfo.h
Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/DiscreteIntegrator.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/DiscreteIntegrator.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
   branches/OpenFDM-StateSeparation/src/OpenFDM/Model.h
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Introduce a Task and make use of that in the first time ...


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.cpp	2008-09-28 15:08:01 UTC (rev 531)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.cpp	2008-09-28 15:24:31 UTC (rev 532)
@@ -73,7 +73,7 @@
 }
 
 void
-Delay::update(DiscreteStateValueVector& discreteState,
+Delay::update(const DiscreteTask&, DiscreteStateValueVector& discreteState,
               ContinousStateValueVector&,
               const PortValueList& portValues) const
 {

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.h	2008-09-28 15:08:01 UTC (rev 531)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.h	2008-09-28 15:24:31 UTC (rev 532)
@@ -24,9 +24,8 @@
   virtual void output(const DiscreteStateValueVector& discreteState,
                       const ContinousStateValueVector&,
                       PortValueList& portValues) const;
-  virtual void update(DiscreteStateValueVector& discreteState,
-                      ContinousStateValueVector&,
-                      const PortValueList& portValues) const;
+  virtual void update(const DiscreteTask&, DiscreteStateValueVector&,
+                      ContinousStateValueVector&, const PortValueList&) const;
 
   /// The delay number of timeslices
   unsigned getDelay(void) const;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/DiscreteIntegrator.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/DiscreteIntegrator.cpp	2008-09-28 15:08:01 UTC (rev 531)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/DiscreteIntegrator.cpp	2008-09-28 15:24:31 UTC (rev 532)
@@ -5,6 +5,7 @@
 #include "DiscreteIntegrator.h"
 #include "Assert.h"
 #include "LeafContext.h"
+#include "Task.h"
 
 namespace OpenFDM {
 
@@ -92,13 +93,13 @@
 }
 
 void
-DiscreteIntegrator::update(DiscreteStateValueVector& discreteState,
+DiscreteIntegrator::update(const DiscreteTask& discreteTask,
+                           DiscreteStateValueVector& discreteState,
                            ContinousStateValueVector&,
                            const PortValueList& portValues) const
 {
   // Just compute the integral.
-  // FIXME: have no task info up to now !!!
-  real_type dt = 1;//(*taskInfo.getSampleTimeSet().begin()).getSampleTime();
+  real_type dt = discreteTask.getStepsize();
   doUpdate(discreteState[*mMatrixStateInfo], portValues[mInputPort], dt);
 }
 

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/DiscreteIntegrator.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/DiscreteIntegrator.h	2008-09-28 15:08:01 UTC (rev 531)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/DiscreteIntegrator.h	2008-09-28 15:24:31 UTC (rev 532)
@@ -23,9 +23,8 @@
   virtual void output(const DiscreteStateValueVector& discreteState,
                       const ContinousStateValueVector&,
                       PortValueList& portValues) const;
-  virtual void update(DiscreteStateValueVector& discreteState,
-                      ContinousStateValueVector&,
-                      const PortValueList& portValues) const;
+  virtual void update(const DiscreteTask&, DiscreteStateValueVector&,
+                      ContinousStateValueVector&, const PortValueList&) const;
 
   /// The initial output values on the output until input values are available.
   const Matrix& getInitialValue() const;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-09-28 15:08:01 UTC (rev 531)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-09-28 15:24:31 UTC (rev 532)
@@ -101,7 +101,7 @@
   StateValue.h \
   System.h \
   TableData.h \
-  TaskInfo.h \
+  Task.h \
   TemplateContinousStateInfo.h \
   TemplateDiscreteStateInfo.h \
   TemplateInfoVector.h \
@@ -166,7 +166,6 @@
 #   ImplicitEuler.cpp \
 #   Newton.cpp \
 #   ReaderWriter.cpp \
-#   TaskInfo.cpp \
 #
 
 

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Model.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Model.h	2008-09-28 15:08:01 UTC (rev 531)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Model.h	2008-09-28 15:24:31 UTC (rev 532)
@@ -17,6 +17,8 @@
 
 namespace OpenFDM {
 
+class ContinousTask;
+class DiscreteTask;
 class DiscreteStateValueVector;
 class ContinousStateValueVector;
 class PortValueList;
@@ -35,8 +37,8 @@
   // argument? May be it is sufficient to have a const and non const version??
   // FIXME???
   // const TaskInfo& taskInfo
-  virtual void update(DiscreteStateValueVector&, ContinousStateValueVector&,
-                      const PortValueList&) const { }
+  virtual void update(const DiscreteTask&, DiscreteStateValueVector&,
+                      ContinousStateValueVector&, const PortValueList&) const{}
   virtual void output(const DiscreteStateValueVector&,
                       const ContinousStateValueVector&,
                       PortValueList&) const { }

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/Task.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Task.h	2008-09-28 15:08:01 UTC (rev 531)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Task.h	2008-09-28 15:24:31 UTC (rev 532)
@@ -0,0 +1,39 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_Task_H
+#define OpenFDM_Task_H
+
+namespace OpenFDM {
+
+class Task : public Referenced {
+public:
+  virtual ~Task() {}
+
+  const real_type& getTime() const
+  { return mTime; }
+
+// protected:
+  void setTime(const real_type& time)
+  { mTime = time; }
+
+private:
+  real_type mTime;
+};
+
+class DiscreteTask : public Task {
+public:
+  DiscreteTask(const real_type& stepsize) : mStepsize(stepsize) { }
+  virtual ~DiscreteTask() {}
+
+  const real_type& getStepsize() const
+  { return mStepsize; }
+
+private:
+  real_type mStepsize;
+};
+
+} // namespace OpenFDM
+
+#endif

Deleted: branches/OpenFDM-StateSeparation/src/OpenFDM/TaskInfo.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/TaskInfo.cpp	2008-09-28 15:08:01 UTC (rev 531)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/TaskInfo.cpp	2008-09-28 15:24:31 UTC (rev 532)
@@ -1,29 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
- *
- */
-
-#include "TaskInfo.h"
-
-#include "SharedPtr.h"
-#include "SampleTime.h"
-#include "Model.h"
-
-namespace OpenFDM {
-
-void
-TaskInfo::output(void) const
-{
-  ModelList::const_iterator it = mModelList.begin();
-  for (; it != mModelList.end(); ++it)
-    (*it)->outputIfEnabled(*this);
-}
-
-void
-TaskInfo::update(void) const
-{
-  ModelList::const_iterator it = mModelList.begin();
-  for (; it != mModelList.end(); ++it)
-    (*it)->updateIfEnabled(*this);
-}
-
-} // namespace OpenFDM

Deleted: branches/OpenFDM-StateSeparation/src/OpenFDM/TaskInfo.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/TaskInfo.h	2008-09-28 15:08:01 UTC (rev 531)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/TaskInfo.h	2008-09-28 15:24:31 UTC (rev 532)
@@ -1,66 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
- *
- */
-
-#ifndef OpenFDM_TaskInfo_H
-#define OpenFDM_TaskInfo_H
-
-#include "Types.h"
-#include "SampleTime.h"
-#include "SharedPtr.h"
-#include "Model.h"
-
-namespace OpenFDM {
-
-class Model;
-
-class TaskInfo {
-public:
-  TaskInfo(void) :
-    mSliceSize(0),
-    mTime(0),
-    mNumBasicSteps(0)
-  {}
-
-  void setTime(real_type t)
-  { mTime = t; }
-  real_type getTime(void) const
-  { return mTime; }
-  
-  void addSampleTime(const SampleTime& sampleTime)
-  { mSampleTimeSet.addSampleTime(sampleTime); }
-
-  void clear(void)
-  { mSampleTimeSet.clear(); mModelList.clear(); }
-
-  const SampleTimeSet& getSampleTimeSet(void) const
-  { return mSampleTimeSet; }
-
-  real_type getSliceSize(void) const
-  { return mSliceSize; }
-  void setSliceSize(real_type sliceSize)
-  { mSliceSize = sliceSize; }
-
-  unsigned getNumBasicSteps(void) const
-  { return mNumBasicSteps; }
-  void setNumBasicSteps(unsigned numBasicSteps)
-  { mNumBasicSteps = numBasicSteps; }
-
-  void appendModel(SharedPtr<Model> model)
-  { mModelList.push_back(model); }
-
-  void output(void) const;
-  void update(void) const;
-
-private:
-  typedef std::vector<SharedPtr<Model> > ModelList;
-  ModelList mModelList;
-  SampleTimeSet mSampleTimeSet;
-  real_type mSliceSize;
-  real_type mTime;
-  unsigned mNumBasicSteps;
-};
-
-} // namespace OpenFDM
-
-#endif

Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-28 15:08:01 UTC (rev 531)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-28 15:24:31 UTC (rev 532)
@@ -41,6 +41,7 @@
 #include <OpenFDM/MatrixStateInfo.h>
 
 #include <OpenFDM/LeafContext.h>
+#include <OpenFDM/Task.h>
 
 #include <OpenFDM/RigidBody.h>
 #include <OpenFDM/Interact.h>
@@ -154,8 +155,6 @@
   SharedPtr<NodeContext> mNodeContext;
 };
 
-class Task;
-class DiscreteTask;
 class ContinousTask;
 
 //// This one is used to execute the simulation system
@@ -174,8 +173,8 @@
   { mModel->init(mDiscreteState, mContinousState, mPortValueList); }
   void output(const Task&)
   { mModel->output(mDiscreteState, mContinousState, mPortValueList); }
-  void update(const DiscreteTask&)
-  { mModel->update(mDiscreteState, mContinousState, mPortValueList); }
+  void update(const DiscreteTask& discreteTask)
+  { mModel->update(discreteTask, mDiscreteState, mContinousState, mPortValueList); }
 
 //   void derivative()
 //   { mModel->derivative(mDiscreteState,
@@ -963,20 +962,6 @@
 };
 
 
-
-
-class Task : public Referenced {
-public:
-
-  void setTime(const real_type& time)
-  { mTime = time; }
-  const real_type& getTime() const
-  { return mTime; }
-
-private:
-  real_type mTime;
-};
-
 class ContinousTask : public Task {
 public:
 
@@ -1010,14 +995,11 @@
   MechanicContextList mMechanicContextList;
 };
 
-class DiscreteTask : public Task {
+class DiscreteTask2 : public DiscreteTask {
 public:
-  DiscreteTask(const real_type& stepsize) : mStepsize(stepsize)
+  DiscreteTask2(const real_type& stepsize) : DiscreteTask(stepsize)
   { }
 
-  const real_type& getStepsize() const
-  { return mStepsize; }
-
   void update()
   {
     mModelContextList.update(*this);
@@ -1027,12 +1009,9 @@
 
   ModelContextList mModelContextList;
   MechanicContextList mMechanicContextList;
-
-private:
-  real_type mStepsize;
 };
 
-typedef std::list<SharedPtr<DiscreteTask> > DiscreteTaskList;
+typedef std::list<SharedPtr<DiscreteTask2> > DiscreteTaskList;
 
 class TaskScheduler {
 public:



From frohlich at mail.berlios.de  Sun Sep 28 17:37:56 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 28 Sep 2008 17:37:56 +0200
Subject: [OpenFDM-svn] r533 - in branches/OpenFDM-StateSeparation/src:
	OpenFDM test
Message-ID: <200809281537.m8SFbu4s015643@sheep.berlios.de>

Author: frohlich
Date: 2008-09-28 17:37:56 +0200 (Sun, 28 Sep 2008)
New Revision: 533

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/DiscreteIntegrator.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/DiscreteIntegrator.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Model.h
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Add an update stage to the Mechanic stuff.
Constify the ContinousStateValue in all update stages.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.cpp	2008-09-28 15:24:31 UTC (rev 532)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.cpp	2008-09-28 15:37:56 UTC (rev 533)
@@ -74,7 +74,7 @@
 
 void
 Delay::update(const DiscreteTask&, DiscreteStateValueVector& discreteState,
-              ContinousStateValueVector&,
+              const ContinousStateValueVector&,
               const PortValueList& portValues) const
 {
   discreteState[*mMatrixStateInfo].rotate(portValues[mInputPort]);

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.h	2008-09-28 15:24:31 UTC (rev 532)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.h	2008-09-28 15:37:56 UTC (rev 533)
@@ -25,7 +25,8 @@
                       const ContinousStateValueVector&,
                       PortValueList& portValues) const;
   virtual void update(const DiscreteTask&, DiscreteStateValueVector&,
-                      ContinousStateValueVector&, const PortValueList&) const;
+                      const ContinousStateValueVector&,
+                      const PortValueList&) const;
 
   /// The delay number of timeslices
   unsigned getDelay(void) const;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/DiscreteIntegrator.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/DiscreteIntegrator.cpp	2008-09-28 15:24:31 UTC (rev 532)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/DiscreteIntegrator.cpp	2008-09-28 15:37:56 UTC (rev 533)
@@ -95,7 +95,7 @@
 void
 DiscreteIntegrator::update(const DiscreteTask& discreteTask,
                            DiscreteStateValueVector& discreteState,
-                           ContinousStateValueVector&,
+                           const ContinousStateValueVector&,
                            const PortValueList& portValues) const
 {
   // Just compute the integral.

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/DiscreteIntegrator.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/DiscreteIntegrator.h	2008-09-28 15:24:31 UTC (rev 532)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/DiscreteIntegrator.h	2008-09-28 15:37:56 UTC (rev 533)
@@ -24,7 +24,8 @@
                       const ContinousStateValueVector&,
                       PortValueList& portValues) const;
   virtual void update(const DiscreteTask&, DiscreteStateValueVector&,
-                      ContinousStateValueVector&, const PortValueList&) const;
+                      const ContinousStateValueVector&,
+                      const PortValueList&) const;
 
   /// The initial output values on the output until input values are available.
   const Matrix& getInitialValue() const;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.h	2008-09-28 15:24:31 UTC (rev 532)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.h	2008-09-28 15:37:56 UTC (rev 533)
@@ -11,6 +11,7 @@
 namespace OpenFDM {
 
 class PortValueList;
+class DiscreteTask;
 
 class MechanicNode : public LeafNode {
   OPENFDM_OBJECT(MechanicNode, LeafNode);
@@ -31,6 +32,10 @@
                           const PortValueList&,
                           ContinousStateValueVector&) const
   { }
+  virtual void update(const DiscreteTask&, DiscreteStateValueVector&,
+                      const ContinousStateValueVector&,
+                      const PortValueList&) const
+  { }
 };
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Model.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Model.h	2008-09-28 15:24:31 UTC (rev 532)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Model.h	2008-09-28 15:37:56 UTC (rev 533)
@@ -38,7 +38,8 @@
   // FIXME???
   // const TaskInfo& taskInfo
   virtual void update(const DiscreteTask&, DiscreteStateValueVector&,
-                      ContinousStateValueVector&, const PortValueList&) const{}
+                      const ContinousStateValueVector&,
+                      const PortValueList&) const { }
   virtual void output(const DiscreteStateValueVector&,
                       const ContinousStateValueVector&,
                       PortValueList&) const { }

Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-28 15:24:31 UTC (rev 532)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-28 15:37:56 UTC (rev 533)
@@ -305,8 +305,11 @@
 //   void outputAcceperation()
 //   { }
 
-//   void update()
-//   { }
+  void update(const DiscreteTask& discreteTask)
+  {
+    mMechanicNode->update(discreteTask, mDiscreteState,
+                          mContinousState, mPortValueList);
+  }
 
   bool isConnectedTo(const MechanicContext& mechanicContext) const
   {
@@ -374,6 +377,11 @@
     for (list_type::const_iterator i = begin(); i != end(); ++i)
       (*i)->accelerations(task);
   }
+  void update(const DiscreteTask& task) const
+  {
+    for (list_type::const_iterator i = begin(); i != end(); ++i)
+      (*i)->update(task);
+  }
 };
 
 class MechanicInstance : public AbstractNodeInstance {



From frohlich at mail.berlios.de  Sun Sep 28 17:45:47 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 28 Sep 2008 17:45:47 +0200
Subject: [OpenFDM-svn] r534 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200809281545.m8SFjl82016166@sheep.berlios.de>

Author: frohlich
Date: 2008-09-28 17:45:46 +0200 (Sun, 28 Sep 2008)
New Revision: 534

Modified:
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Add an other pure discrete example.


Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-28 15:37:56 UTC (rev 533)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-28 15:45:46 UTC (rev 534)
@@ -47,6 +47,7 @@
 #include <OpenFDM/Interact.h>
 
 #include <OpenFDM/Gain.h>
+#include <OpenFDM/DiscreteIntegrator.h>
 #include <OpenFDM/Integrator.h>
 #include <OpenFDM/Delay.h>
 #include <OpenFDM/Output.h>
@@ -1052,7 +1053,7 @@
 
 using namespace OpenFDM;
 
-int main()
+Node* buildGroupExample()
 {
   SharedPtr<Group> group = new Group("G0");
   Group::NodeId gain = group->addChild(new Gain("gain"));
@@ -1083,10 +1084,34 @@
   Group::NodeId output1 = topGroup->addChild(new Output("O3"));
   topGroup->connect(child1, 0, output1, 0);
 
-  /////////////////////////////////////////////////
+  return topGroup.release();
+}
 
-  SharedPtr<System> system = new System("System", topGroup);
+Node* buildDiscreteExample()
+{
+  SharedPtr<Group> group = new Group("G0");
+  Group::NodeId gain = group->addChild(new Gain("gain"));
+  Group::NodeId integrator1 = group->addChild(new DiscreteIntegrator("I1"));
+  Group::NodeId integrator2 = group->addChild(new DiscreteIntegrator("I2"));
+  Group::NodeId output = group->addChild(new Output("O"));
+  Group::NodeId delay = group->addChild(new Delay("D"));
+  Group::NodeId outputDelay = group->addChild(new Output("OD"));
 
+  group->connect(integrator1, "output", integrator2, "input");
+  group->connect(integrator2, "output", gain, "input");
+  group->connect(gain, "output", integrator1, "input");
+  group->connect(integrator2, "output", output, "input");
+  group->connect(gain, "output", delay, "input");
+  group->connect(delay, "output", outputDelay, "input");
+
+  return group.release();
+}
+
+int main()
+{
+//   SharedPtr<System> system = new System("System", buildGroupExample());
+  SharedPtr<System> system = new System("System", buildDiscreteExample());
+
   if (!system->init())
     return 1;
 



From frohlich at mail.berlios.de  Sun Sep 28 17:59:24 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 28 Sep 2008 17:59:24 +0200
Subject: [OpenFDM-svn] r535 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200809281559.m8SFxO60017046@sheep.berlios.de>

Author: frohlich
Date: 2008-09-28 17:59:24 +0200 (Sun, 28 Sep 2008)
New Revision: 535

Modified:
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Remove unused stuff.


Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-28 15:45:46 UTC (rev 534)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-28 15:59:24 UTC (rev 535)
@@ -970,64 +970,6 @@
   SharedPtr<PortDataHelper::PortDataList> mCurrentNodePortDataList;
 };
 
-
-class ContinousTask : public Task {
-public:
-
-  void output() const
-  {
-    // The model outputs before mechanical state propagation
-    mModelContextList[0].output(*this);
-    // Now the mechanical state propagation
-    mMechanicContextList.velocities(*this);
-    // The model outputs before mechanical force propagation
-    mModelContextList[1].output(*this);
-    // Now the mechanical force propagation
-    mMechanicContextList.articulation(*this);
-    // The model outputs before mechanical acceleration propagation
-    mModelContextList[2].output(*this);
-    // Now the mechanical acceleration propagation
-    mMechanicContextList.accelerations(*this);
-    // The model outputs past mechanical acceleration propagation
-    mModelContextList[3].output(*this);
-  }
-
-  void derivative() const
-  {
-    // FIXME
-//     for (unsigned i = 0; i < 4; ++i)
-//       mModelContextList[i].derivative(*this);
-//     mMechanicContextList.derivative(*this);
-  }
-
-  ModelContextList mModelContextList[4];
-  MechanicContextList mMechanicContextList;
-};
-
-class DiscreteTask2 : public DiscreteTask {
-public:
-  DiscreteTask2(const real_type& stepsize) : DiscreteTask(stepsize)
-  { }
-
-  void update()
-  {
-    mModelContextList.update(*this);
-    // FIXME
-//     mMechanicContextList.update(*this);
-  }
-
-  ModelContextList mModelContextList;
-  MechanicContextList mMechanicContextList;
-};
-
-typedef std::list<SharedPtr<DiscreteTask2> > DiscreteTaskList;
-
-class TaskScheduler {
-public:
-  DiscreteTaskList mDiscreteTaskList;
-  SharedPtr<ContinousTask> mContinousTask;
-};
-
 bool
 System::init()
 {



From frohlich at mail.berlios.de  Mon Sep 29 07:43:00 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Mon, 29 Sep 2008 07:43:00 +0200
Subject: [OpenFDM-svn] r536 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200809290543.m8T5h03u004018@sheep.berlios.de>

Author: frohlich
Date: 2008-09-29 07:43:00 +0200 (Mon, 29 Sep 2008)
New Revision: 536

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Gain.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Gain.h
Log:
Add a gain value to the constructor.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Gain.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Gain.cpp	2008-09-28 15:59:24 UTC (rev 535)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Gain.cpp	2008-09-29 05:43:00 UTC (rev 536)
@@ -19,11 +19,11 @@
   DEF_OPENFDM_PROPERTY(Real, Gain, Serialized)
   END_OPENFDM_OBJECT_DEF
 
-Gain::Gain(const std::string& name) :
+Gain::Gain(const std::string& name, const real_type& gain) :
   Model(name),
   mInputPort(newMatrixInputPort("input", true)),
   mOutputPort(newMatrixOutputPort("output")),
-  mGain(1)
+  mGain(gain)
 {
 }
 

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Gain.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Gain.h	2008-09-28 15:59:24 UTC (rev 535)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Gain.h	2008-09-29 05:43:00 UTC (rev 536)
@@ -14,7 +14,7 @@
 class Gain : public Model {
   OPENFDM_OBJECT(Gain, Model);
 public:
-  Gain(const std::string& name);
+  Gain(const std::string& name, const real_type& gain = real_type(1));
   virtual ~Gain(void);
 
   virtual bool alloc(LeafContext& leafContext) const;



From frohlich at mail.berlios.de  Mon Sep 29 07:43:33 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Mon, 29 Sep 2008 07:43:33 +0200
Subject: [OpenFDM-svn] r537 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200809290543.m8T5hXIb004076@sheep.berlios.de>

Author: frohlich
Date: 2008-09-29 07:43:32 +0200 (Mon, 29 Sep 2008)
New Revision: 537

Modified:
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Make use of that gain. Also set an initial value for one of the integrals.


Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-29 05:43:00 UTC (rev 536)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-29 05:43:32 UTC (rev 537)
@@ -29,6 +29,8 @@
 #include <OpenFDM/DiscreteStateValueVector.h>
 
 #include <OpenFDM/ODESolver.h>
+#include <OpenFDM/ExplicitEuler.h>
+#include <OpenFDM/DoPri5.h>
 #include <OpenFDM/Function.h>
 #include <OpenFDM/SampleTime.h>
 #include <OpenFDM/Interval.h>
@@ -1032,8 +1034,12 @@
 Node* buildDiscreteExample()
 {
   SharedPtr<Group> group = new Group("G0");
-  Group::NodeId gain = group->addChild(new Gain("gain"));
-  Group::NodeId integrator1 = group->addChild(new DiscreteIntegrator("I1"));
+  Group::NodeId gain = group->addChild(new Gain("gain", -1));
+  DiscreteIntegrator* di1 = new DiscreteIntegrator("I1");
+  Matrix v(1, 1);
+  v(0, 0) = 10;
+  di1->setInitialValue(v);
+  Group::NodeId integrator1 = group->addChild(di1);
   Group::NodeId integrator2 = group->addChild(new DiscreteIntegrator("I2"));
   Group::NodeId output = group->addChild(new Output("O"));
   Group::NodeId delay = group->addChild(new Delay("D"));



From frohlich at mail.berlios.de  Mon Sep 29 23:25:34 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Mon, 29 Sep 2008 23:25:34 +0200
Subject: [OpenFDM-svn] r538 - in branches/OpenFDM-StateSeparation/src:
	OpenFDM test
Message-ID: <200809292125.m8TLPYJw013058@sheep.berlios.de>

Author: frohlich
Date: 2008-09-29 23:25:33 +0200 (Mon, 29 Sep 2008)
New Revision: 538

Added:
   branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeContext.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/ModelContext.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/ModelContext.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/NodeContext.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/NodeContext.h
Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeContext.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
   branches/OpenFDM-StateSeparation/src/OpenFDM/TemplateValueVector.h
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Move some more context into implementation files.


Added: branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeContext.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeContext.cpp	2008-09-29 05:43:32 UTC (rev 537)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeContext.cpp	2008-09-29 21:25:33 UTC (rev 538)
@@ -0,0 +1,17 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
+ *
+ */
+
+#include "AbstractNodeContext.h"
+
+namespace OpenFDM {
+
+AbstractNodeContext::AbstractNodeContext()
+{
+}
+
+AbstractNodeContext::~AbstractNodeContext()
+{
+}
+
+} // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeContext.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeContext.h	2008-09-29 05:43:32 UTC (rev 537)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeContext.h	2008-09-29 21:25:33 UTC (rev 538)
@@ -12,7 +12,9 @@
 
 class AbstractNodeContext : public Referenced {
 public:
-  virtual ~AbstractNodeContext() { }
+  AbstractNodeContext();
+  virtual ~AbstractNodeContext();
+
   virtual const Node& getNode() const = 0;
 
   PortValueList& getPortValueList()

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-09-29 05:43:32 UTC (rev 537)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-09-29 21:25:33 UTC (rev 538)
@@ -64,10 +64,12 @@
   MechanicAcceptorPortInfo.h \
   MechanicProviderPortInfo.h \
   Model.h \
+  ModelContext.h \
   Mutex.h \
   MPFRFloat.h \
   Newton.h \
   Node.h \
+  NodeContext.h \
   NodeVisitor.h \
   NumericPortValue.h \
   NumericAcceptorPortInfo.h \
@@ -120,6 +122,7 @@
   XMLDumpModelVisitor.h
 
 OpenFDMCoreSOURCES = \
+  AbstractNodeContext.cpp \
   AcceptorPortInfo.cpp \
   Assert.cpp \
   Atomic.cpp \
@@ -141,7 +144,9 @@
   MechanicPortValue.cpp \
   MidpointRule.cpp \
   Model.cpp \
+  ModelContext.cpp \
   Node.cpp \
+  NodeContext.cpp \
   NodeVisitor.cpp \
   NumericAcceptorPortInfo.cpp \
   NumericPortValue.cpp \

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/ModelContext.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ModelContext.cpp	2008-09-29 05:43:32 UTC (rev 537)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ModelContext.cpp	2008-09-29 21:25:33 UTC (rev 538)
@@ -0,0 +1,55 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
+ *
+ */
+
+#include "Assert.h"
+#include "ModelContext.h"
+
+namespace OpenFDM {
+
+ModelContext::ModelContext(const Model* model) :
+  mModel(model)
+{
+  OpenFDMAssert(mModel);
+}
+
+ModelContext::~ModelContext()
+{
+}
+
+const Model&
+ModelContext::getNode() const
+{
+  return *mModel;
+}
+
+bool ModelContext::dependsOn(const ModelContext& modelContext) const
+{
+  unsigned numPorts = mModel->getNumPorts();
+  for (unsigned i = 0; i < numPorts; ++i) {
+    const AcceptorPortInfo* acceptorPortInfo;
+    acceptorPortInfo = mModel->getPort(i)->toAcceptorPortInfo();
+    if (!acceptorPortInfo)
+      continue;
+    if (!acceptorPortInfo->getDirectInput())
+      continue;
+    const PortValue* portValue = getPortValueList().getPortValue(i);
+    if (!portValue)
+      continue;
+    unsigned otherNumPorts = modelContext.mModel->getNumPorts();
+    for (unsigned j = 0; j < otherNumPorts; ++j) {
+      if (!modelContext.mModel->getPort(j)->toProviderPortInfo())
+        continue;
+      
+      const PortValue* otherPortValue;
+      otherPortValue = modelContext.getPortValueList().getPortValue(j);
+      if (portValue != otherPortValue)
+        continue;
+      
+      return true;
+    }
+  }
+  return false;
+}
+
+} // namespace OpenFDM

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/ModelContext.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ModelContext.h	2008-09-29 05:43:32 UTC (rev 537)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ModelContext.h	2008-09-29 21:25:33 UTC (rev 538)
@@ -0,0 +1,54 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_ModelContext_H
+#define OpenFDM_ModelContext_H
+
+#include "SharedPtr.h"
+#include "LeafContext.h"
+#include "Model.h"
+
+namespace OpenFDM {
+
+class Task;
+class DiscreteTask;
+class ContinousTask;
+
+//// This one is used to execute the simulation system
+class ModelContext : public LeafContext {
+public:
+  ModelContext(const Model* model);
+  virtual ~ModelContext();
+
+  virtual const Model& getNode() const;
+
+  bool alloc()
+  { return mModel->alloc(*this); }
+  void init()
+  { mModel->init(mDiscreteState, mContinousState, mPortValueList); }
+  void output(const Task&)
+  { mModel->output(mDiscreteState, mContinousState, mPortValueList); }
+  void update(const DiscreteTask& discreteTask)
+  { mModel->update(discreteTask, mDiscreteState, mContinousState, mPortValueList); }
+
+//   void derivative()
+//   { mModel->derivative(mDiscreteState,
+//                        mContinousState,
+//                        mPortValueList,
+//                        mContinousStateDerivative); }
+
+  // Return true if this model directly depends on one of models outputs
+  bool dependsOn(const ModelContext& modelContext) const;
+
+private:
+  ModelContext();
+  ModelContext(const ModelContext&);
+  ModelContext& operator=(const ModelContext&);
+
+  SharedPtr<const Model> mModel;
+};
+
+} // namespace OpenFDM
+
+#endif

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/NodeContext.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/NodeContext.cpp	2008-09-29 05:43:32 UTC (rev 537)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/NodeContext.cpp	2008-09-29 21:25:33 UTC (rev 538)
@@ -0,0 +1,26 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
+ *
+ */
+
+#include "Assert.h"
+#include "NodeContext.h"
+
+namespace OpenFDM {
+
+NodeContext::NodeContext(const Node* node) :
+  mNode(node)
+{
+  OpenFDMAssert(mNode);
+}
+
+NodeContext::~NodeContext()
+{
+}
+
+const Node&
+NodeContext::getNode() const
+{
+  return *mNode;
+}
+
+} // namespace OpenFDM

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/NodeContext.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/NodeContext.h	2008-09-29 05:43:32 UTC (rev 537)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/NodeContext.h	2008-09-29 21:25:33 UTC (rev 538)
@@ -0,0 +1,34 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_NodeContext_H
+#define OpenFDM_NodeContext_H
+
+#include "SharedPtr.h"
+#include "AbstractNodeContext.h"
+
+namespace OpenFDM {
+
+/// This one will not show up in any execution list, but will be used
+/// to fill NodeContext's for Node's that have nothing to execute,
+/// should be reflected to the user of the simulation system. Group's
+/// inputs ad outputs and their input and output models are such examples.
+class NodeContext : public AbstractNodeContext {
+public:
+  NodeContext(const Node* node);
+  virtual ~NodeContext();
+
+  virtual const Node& getNode() const;
+
+private:
+  NodeContext();
+  NodeContext(const NodeContext&);
+  NodeContext& operator=(const NodeContext&);
+
+  SharedPtr<const Node> mNode;
+};
+
+} // namespace OpenFDM
+
+#endif

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/TemplateValueVector.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/TemplateValueVector.h	2008-09-29 05:43:32 UTC (rev 537)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/TemplateValueVector.h	2008-09-29 21:25:33 UTC (rev 538)
@@ -10,6 +10,8 @@
 
 namespace OpenFDM {
 
+class LeafContext;
+
 template<typename Info, typename Value>
 class TemplateValueVector {
 public:

Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-29 05:43:32 UTC (rev 537)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-29 21:25:33 UTC (rev 538)
@@ -43,6 +43,8 @@
 #include <OpenFDM/MatrixStateInfo.h>
 
 #include <OpenFDM/LeafContext.h>
+#include <OpenFDM/NodeContext.h>
+#include <OpenFDM/ModelContext.h>
 #include <OpenFDM/Task.h>
 
 #include <OpenFDM/RigidBody.h>
@@ -115,31 +117,6 @@
 /// there must be a PortData like structure that is only built during simulation
 /// model initialization.
 
-
-
-////////////////////////////////////////////////////////////////////////////
-
-/// This one will not show up in any execution list, but will be used
-/// to fill NodeContext's for Node's that have nothing to execute,
-/// should be reflected to the user of the simulation system. Group's
-/// inputs ad outputs and their input and output models are such examples.
-class NodeContext : public AbstractNodeContext {
-public:
-  NodeContext(const Node* node) :
-    mNode(node)
-  { OpenFDMAssert(mNode); }
-
-  virtual const Node& getNode() const
-  { return *mNode; }
-
-private:
-  NodeContext();
-  NodeContext(const NodeContext&);
-  NodeContext& operator=(const NodeContext&);
-
-  SharedPtr<const Node> mNode;
-};
-
 class NodeInstance : public AbstractNodeInstance {
 public:
   NodeInstance(const NodePath& nodePath, const Node* node) :
@@ -160,69 +137,7 @@
 
 class ContinousTask;
 
-//// This one is used to execute the simulation system
-class ModelContext : public LeafContext {
-public:
-  ModelContext(const Model* model) :
-    mModel(model)
-  { OpenFDMAssert(mModel); }
 
-  virtual const Model& getNode() const
-  { return *mModel; }
-
-  bool alloc()
-  { return mModel->alloc(*this); }
-  void init()
-  { mModel->init(mDiscreteState, mContinousState, mPortValueList); }
-  void output(const Task&)
-  { mModel->output(mDiscreteState, mContinousState, mPortValueList); }
-  void update(const DiscreteTask& discreteTask)
-  { mModel->update(discreteTask, mDiscreteState, mContinousState, mPortValueList); }
-
-//   void derivative()
-//   { mModel->derivative(mDiscreteState,
-//                        mContinousState,
-//                        mPortValueList,
-//                        mContinousStateDerivative); }
-
-  // Return true if this model directly depends on one of models outputs
-  bool dependsOn(const ModelContext& modelContext) const
-  {
-    unsigned numPorts = mModel->getNumPorts();
-    for (unsigned i = 0; i < numPorts; ++i) {
-      const AcceptorPortInfo* acceptorPortInfo;
-      acceptorPortInfo = mModel->getPort(i)->toAcceptorPortInfo();
-      if (!acceptorPortInfo)
-        continue;
-      if (!acceptorPortInfo->getDirectInput())
-        continue;
-      const PortValue* portValue = getPortValueList().getPortValue(i);
-      if (!portValue)
-        continue;
-      unsigned otherNumPorts = modelContext.mModel->getNumPorts();
-      for (unsigned j = 0; j < otherNumPorts; ++j) {
-        if (!modelContext.mModel->getPort(j)->toProviderPortInfo())
-          continue;
-
-        const PortValue* otherPortValue;
-        otherPortValue = modelContext.getPortValueList().getPortValue(j);
-        if (portValue != otherPortValue)
-          continue;
-
-        return true;
-      }
-    }
-    return false;
-  }
-
-private:
-  ModelContext();
-  ModelContext(const ModelContext&);
-  ModelContext& operator=(const ModelContext&);
-
-  SharedPtr<const Model> mModel;
-};
-
 class ModelContextList : public std::list<SharedPtr<ModelContext> > {
 public:
   typedef std::list<SharedPtr<ModelContext> > list_type;



From frohlich at mail.berlios.de  Mon Sep 29 23:43:24 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Mon, 29 Sep 2008 23:43:24 +0200
Subject: [OpenFDM-svn] r539 - in branches/OpenFDM-StateSeparation/src:
	OpenFDM test
Message-ID: <200809292143.m8TLhOiv015960@sheep.berlios.de>

Author: frohlich
Date: 2008-09-29 23:43:24 +0200 (Mon, 29 Sep 2008)
New Revision: 539

Added:
   branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeInstance.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/ModelInstance.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/ModelInstance.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/NodeInstance.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/NodeInstance.h
Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeInstance.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
More implementation files.


Added: branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeInstance.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeInstance.cpp	2008-09-29 21:25:33 UTC (rev 538)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeInstance.cpp	2008-09-29 21:43:24 UTC (rev 539)
@@ -0,0 +1,40 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
+ *
+ */
+
+#include "AbstractNodeInstance.h"
+
+#include "Assert.h"
+#include "Node.h"
+#include "SharedPtr.h"
+#include "WeakReferenced.h"
+
+namespace OpenFDM {
+
+AbstractNodeInstance::AbstractNodeInstance(const NodePath& nodePath) :
+  mNodePath(nodePath)
+{
+  OpenFDMAssert(!nodePath.empty());
+}
+
+AbstractNodeInstance::~AbstractNodeInstance()
+{
+}
+
+std::string
+AbstractNodeInstance::getNodeNamePath() const
+{
+  if (mNodePath.empty())
+    return std::string();
+  std::string path = mNodePath.front()->getName();
+  NodePath::const_iterator i = mNodePath.begin();
+  if (i != mNodePath.end()) {
+    for (++i; i != mNodePath.end(); ++i) {
+      path += '/';
+      path += (*i)->getName();
+    }
+  }
+  return path;
+}
+
+} // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeInstance.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeInstance.h	2008-09-29 21:25:33 UTC (rev 538)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractNodeInstance.h	2008-09-29 21:43:24 UTC (rev 539)
@@ -19,11 +19,8 @@
 /// This class is meant to show up in the user interface of this simulation.
 class AbstractNodeInstance : public WeakReferenced {
 public:
-  AbstractNodeInstance(const NodePath& nodePath) :
-    mNodePath(nodePath)
-  { OpenFDMAssert(!nodePath.empty()); }
-  virtual ~AbstractNodeInstance()
-  { }
+  AbstractNodeInstance(const NodePath& nodePath);
+  virtual ~AbstractNodeInstance();
 
   /// The actual Node this AbstractNodeInstance stems from
   const Node& getNode() const
@@ -43,24 +40,9 @@
   const PortValueList& getPortValueList() const
   { return getNodeContext().getPortValueList(); }
 
-  std::string getNodeNamePath() const
-  {
-    if (mNodePath.empty())
-      return std::string();
-    std::string path = mNodePath.front()->getName();
-    NodePath::const_iterator i = mNodePath.begin();
-    if (i != mNodePath.end()) {
-      for (++i; i != mNodePath.end(); ++i) {
-        path += '/';
-        path += (*i)->getName();
-      }
-    }
-    return path;
-  }
+  std::string getNodeNamePath() const;
 
 protected:
-  AbstractNodeInstance() {}
-
   /// The node context that belongs to this instance.
   virtual AbstractNodeContext& getNodeContext() = 0;
   virtual const AbstractNodeContext& getNodeContext() const = 0;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-09-29 21:25:33 UTC (rev 538)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-09-29 21:43:24 UTC (rev 539)
@@ -65,11 +65,13 @@
   MechanicProviderPortInfo.h \
   Model.h \
   ModelContext.h \
+  ModelInstance.h \
   Mutex.h \
   MPFRFloat.h \
   Newton.h \
   Node.h \
   NodeContext.h \
+  NodeInstance.h \
   NodeVisitor.h \
   NumericPortValue.h \
   NumericAcceptorPortInfo.h \
@@ -123,6 +125,7 @@
 
 OpenFDMCoreSOURCES = \
   AbstractNodeContext.cpp \
+  AbstractNodeInstance.cpp \
   AcceptorPortInfo.cpp \
   Assert.cpp \
   Atomic.cpp \
@@ -145,8 +148,10 @@
   MidpointRule.cpp \
   Model.cpp \
   ModelContext.cpp \
+  ModelInstance.cpp \
   Node.cpp \
   NodeContext.cpp \
+  NodeInstance.cpp \
   NodeVisitor.cpp \
   NumericAcceptorPortInfo.cpp \
   NumericPortValue.cpp \

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/ModelInstance.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ModelInstance.cpp	2008-09-29 21:25:33 UTC (rev 538)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ModelInstance.cpp	2008-09-29 21:43:24 UTC (rev 539)
@@ -0,0 +1,31 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
+ *
+ */
+
+#include "ModelInstance.h"
+
+namespace OpenFDM {
+
+ModelInstance::ModelInstance(const NodePath& nodePath, const Model* model) :
+  AbstractNodeInstance(nodePath),
+  mModelContext(new ModelContext(model))
+{
+}
+
+ModelInstance::~ModelInstance()
+{
+}
+
+ModelContext&
+ModelInstance::getNodeContext()
+{
+  return *mModelContext;
+}
+
+const ModelContext&
+ModelInstance::getNodeContext() const
+{
+  return *mModelContext;
+}
+
+} // namespace OpenFDM

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/ModelInstance.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ModelInstance.h	2008-09-29 21:25:33 UTC (rev 538)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ModelInstance.h	2008-09-29 21:43:24 UTC (rev 539)
@@ -0,0 +1,34 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_ModelInstance_H
+#define OpenFDM_ModelInstance_H
+
+#include "AbstractNodeInstance.h"
+#include "ModelContext.h"
+
+namespace OpenFDM {
+
+class ModelInstance : public AbstractNodeInstance {
+public:
+  ModelInstance(const NodePath& nodePath, const Model* model);
+  virtual ~ModelInstance();
+
+  // Return true if this leaf directly depends on one of leafInstance outputs
+  bool dependsOn(const ModelInstance& modelInstance) const
+  { return mModelContext->dependsOn(*modelInstance.mModelContext); }
+
+  // FIXME
+// protected:
+  /// The node context that belongs to this instance.
+  virtual ModelContext& getNodeContext();
+  virtual const ModelContext& getNodeContext() const;
+
+private:
+  SharedPtr<ModelContext> mModelContext;
+};
+
+} // namespace OpenFDM
+
+#endif

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/NodeInstance.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/NodeInstance.cpp	2008-09-29 21:25:33 UTC (rev 538)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/NodeInstance.cpp	2008-09-29 21:43:24 UTC (rev 539)
@@ -0,0 +1,31 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
+ *
+ */
+
+#include "NodeInstance.h"
+
+namespace OpenFDM {
+
+NodeInstance::NodeInstance(const NodePath& nodePath, const Node* node) :
+  AbstractNodeInstance(nodePath),
+  mNodeContext(new NodeContext(node))
+{
+}
+
+NodeInstance::~NodeInstance()
+{
+}
+
+NodeContext&
+NodeInstance::getNodeContext()
+{
+  return *mNodeContext;
+}
+
+const NodeContext&
+NodeInstance::getNodeContext() const
+{
+  return *mNodeContext;
+}
+
+} // namespace OpenFDM

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/NodeInstance.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/NodeInstance.h	2008-09-29 21:25:33 UTC (rev 538)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/NodeInstance.h	2008-09-29 21:43:24 UTC (rev 539)
@@ -0,0 +1,29 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_NodeInstance_H
+#define OpenFDM_NodeInstance_H
+
+#include "AbstractNodeInstance.h"
+#include "NodeContext.h"
+
+namespace OpenFDM {
+
+class NodeInstance : public AbstractNodeInstance {
+public:
+  NodeInstance(const NodePath& nodePath, const Node* node);
+  virtual ~NodeInstance();
+
+protected:
+  /// The node context that belongs to this instance.
+  virtual NodeContext& getNodeContext();
+  virtual const NodeContext& getNodeContext() const;
+
+private:
+  SharedPtr<NodeContext> mNodeContext;
+};
+
+} // namespace OpenFDM
+
+#endif

Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-29 21:25:33 UTC (rev 538)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-29 21:43:24 UTC (rev 539)
@@ -35,6 +35,9 @@
 #include <OpenFDM/SampleTime.h>
 #include <OpenFDM/Interval.h>
 
+#include <OpenFDM/NodeInstance.h>
+#include <OpenFDM/ModelInstance.h>
+
 #include <OpenFDM/AbstractSystem.h>
 #include <OpenFDM/System.h>
 
@@ -117,27 +120,6 @@
 /// there must be a PortData like structure that is only built during simulation
 /// model initialization.
 
-class NodeInstance : public AbstractNodeInstance {
-public:
-  NodeInstance(const NodePath& nodePath, const Node* node) :
-    AbstractNodeInstance(nodePath),
-    mNodeContext(new NodeContext(node))
-  { }
-
-protected:
-  /// The node context that belongs to this instance.
-  virtual NodeContext& getNodeContext()
-  { return *mNodeContext; }
-  virtual const NodeContext& getNodeContext() const
-  { return *mNodeContext; }
-
-private:
-  SharedPtr<NodeContext> mNodeContext;
-};
-
-class ContinousTask;
-
-
 class ModelContextList : public std::list<SharedPtr<ModelContext> > {
 public:
   typedef std::list<SharedPtr<ModelContext> > list_type;
@@ -168,27 +150,6 @@
   }
 };
 
-class ModelInstance : public AbstractNodeInstance {
-public:
-  ModelInstance(const NodePath& nodePath, const Model* model) :
-    AbstractNodeInstance(nodePath),
-    mModelContext(new ModelContext(model))
-  { }
-
-  // Return true if this leaf directly depends on one of leafInstance outputs
-  bool dependsOn(const ModelInstance& modelInstance) const
-  { return mModelContext->dependsOn(*modelInstance.mModelContext); }
-
-// protected: // FIXME
-  virtual ModelContext& getNodeContext()
-  { return *mModelContext; }
-  virtual const ModelContext& getNodeContext() const
-  { return *mModelContext; }
-
-private:
-  SharedPtr<ModelContext> mModelContext;
-};
-
 typedef std::list<SharedPtr<ModelInstance> > ModelInstanceList;
 
 



From frohlich at mail.berlios.de  Tue Sep 30 22:15:19 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Tue, 30 Sep 2008 22:15:19 +0200
Subject: [OpenFDM-svn] r540 - in branches/OpenFDM-StateSeparation/src:
	OpenFDM test
Message-ID: <200809302015.m8UKFJkL031089@sheep.berlios.de>

Author: frohlich
Date: 2008-09-30 22:15:19 +0200 (Tue, 30 Sep 2008)
New Revision: 540

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/ModelInstance.h
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Move ModelInstanceList into ModelInstance.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/ModelInstance.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ModelInstance.h	2008-09-29 21:43:24 UTC (rev 539)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ModelInstance.h	2008-09-30 20:15:19 UTC (rev 540)
@@ -5,8 +5,10 @@
 #ifndef OpenFDM_ModelInstance_H
 #define OpenFDM_ModelInstance_H
 
+#include <list>
 #include "AbstractNodeInstance.h"
 #include "ModelContext.h"
+#include "SharedPtr.h"
 
 namespace OpenFDM {
 
@@ -29,6 +31,8 @@
   SharedPtr<ModelContext> mModelContext;
 };
 
+typedef std::list<SharedPtr<ModelInstance> > ModelInstanceList;
+
 } // namespace OpenFDM
 
 #endif

Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-29 21:43:24 UTC (rev 539)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-30 20:15:19 UTC (rev 540)
@@ -150,10 +150,6 @@
   }
 };
 
-typedef std::list<SharedPtr<ModelInstance> > ModelInstanceList;
-
-
-
 class MechanicContext : public LeafContext {
 public:
   MechanicContext(const MechanicNode* mechanicNode) :
@@ -165,7 +161,7 @@
 
   bool alloc()
   { return mMechanicNode->alloc(*this); }
-  void init()
+  void init(const Task&)
   { mMechanicNode->init(mDiscreteState, mContinousState, mPortValueList); }
 
   void velocities(const ContinousTask&)
@@ -235,10 +231,10 @@
         return false;
     return true;
   }
-  void init() const
+  void init(const Task& task) const
   {
     for (list_type::const_iterator i = begin(); i != end(); ++i)
-      (*i)->init();
+      (*i)->init(task);
   }
   void velocities(const ContinousTask& task) const
   {



From frohlich at mail.berlios.de  Tue Sep 30 22:19:18 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Tue, 30 Sep 2008 22:19:18 +0200
Subject: [OpenFDM-svn] r541 - in branches/OpenFDM-StateSeparation/src:
	OpenFDM test
Message-ID: <200809302019.m8UKJIuE031480@sheep.berlios.de>

Author: frohlich
Date: 2008-09-30 22:19:18 +0200 (Tue, 30 Sep 2008)
New Revision: 541

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/ModelContext.h
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Move ModelInstanceList to ModelInstance.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/ModelContext.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ModelContext.h	2008-09-30 20:15:19 UTC (rev 540)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ModelContext.h	2008-09-30 20:19:18 UTC (rev 541)
@@ -5,6 +5,7 @@
 #ifndef OpenFDM_ModelContext_H
 #define OpenFDM_ModelContext_H
 
+#include <list>
 #include "SharedPtr.h"
 #include "LeafContext.h"
 #include "Model.h"
@@ -49,6 +50,36 @@
   SharedPtr<const Model> mModel;
 };
 
+class ModelContextList : public std::list<SharedPtr<ModelContext> > {
+public:
+  typedef std::list<SharedPtr<ModelContext> > list_type;
+
+  bool alloc() const
+  {
+    for (list_type::const_iterator i = begin(); i != end(); ++i)
+      if (!(*i)->alloc())
+        return false;
+    return true;
+  }
+  void init(const Task& task) const
+  {
+    for (list_type::const_iterator i = begin(); i != end(); ++i) {
+      (*i)->init();
+      (*i)->output(task);
+    }
+  }
+  void output(const Task& task) const
+  {
+    for (list_type::const_iterator i = begin(); i != end(); ++i)
+      (*i)->output(task);
+  }
+  void update(const DiscreteTask& task) const
+  {
+    for (list_type::const_iterator i = begin(); i != end(); ++i)
+      (*i)->update(task);
+  }
+};
+
 } // namespace OpenFDM
 
 #endif

Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-30 20:15:19 UTC (rev 540)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-30 20:19:18 UTC (rev 541)
@@ -120,36 +120,6 @@
 /// there must be a PortData like structure that is only built during simulation
 /// model initialization.
 
-class ModelContextList : public std::list<SharedPtr<ModelContext> > {
-public:
-  typedef std::list<SharedPtr<ModelContext> > list_type;
-
-  bool alloc() const
-  {
-    for (list_type::const_iterator i = begin(); i != end(); ++i)
-      if (!(*i)->alloc())
-        return false;
-    return true;
-  }
-  void init(const Task& task) const
-  {
-    for (list_type::const_iterator i = begin(); i != end(); ++i) {
-      (*i)->init();
-      (*i)->output(task);
-    }
-  }
-  void output(const Task& task) const
-  {
-    for (list_type::const_iterator i = begin(); i != end(); ++i)
-      (*i)->output(task);
-  }
-  void update(const DiscreteTask& task) const
-  {
-    for (list_type::const_iterator i = begin(); i != end(); ++i)
-      (*i)->update(task);
-  }
-};
-
 class MechanicContext : public LeafContext {
 public:
   MechanicContext(const MechanicNode* mechanicNode) :



From frohlich at mail.berlios.de  Tue Sep 30 22:27:20 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Tue, 30 Sep 2008 22:27:20 +0200
Subject: [OpenFDM-svn] r542 - in branches/OpenFDM-StateSeparation/src:
	OpenFDM test
Message-ID: <200809302027.m8UKRKG9032019@sheep.berlios.de>

Author: frohlich
Date: 2008-09-30 22:27:19 +0200 (Tue, 30 Sep 2008)
New Revision: 542

Added:
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicContext.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicContext.h
Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Move MechanicContext stuff into own implementation.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-09-30 20:19:18 UTC (rev 541)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-09-30 20:27:19 UTC (rev 542)
@@ -57,6 +57,7 @@
   MatrixStateValue.h \
   MatrixStateInfo.h \
   MidpointRule.h \
+  MechanicContext.h \
   MechanicBodyPort.h \
   MechanicInteractPort.h \
   MechanicNode.h \
@@ -143,6 +144,7 @@
   LibraryNode.cpp \
   Logger.cpp \
   MatrixStateValue.cpp \
+  MechanicContext.cpp \
   MechanicNode.cpp \
   MechanicPortValue.cpp \
   MidpointRule.cpp \

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicContext.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicContext.cpp	2008-09-30 20:19:18 UTC (rev 541)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicContext.cpp	2008-09-30 20:27:19 UTC (rev 542)
@@ -0,0 +1,51 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
+ *
+ */
+
+#include "MechanicContext.h"
+
+namespace OpenFDM {
+
+MechanicContext::MechanicContext(const MechanicNode* mechanicNode) :
+  mMechanicNode(mechanicNode)
+{
+  OpenFDMAssert(mMechanicNode);
+}
+
+MechanicContext::~MechanicContext()
+{
+}
+
+const MechanicNode&
+MechanicContext::getNode() const
+{
+  return *mMechanicNode;
+}
+
+bool
+MechanicContext::isConnectedTo(const MechanicContext& mechanicContext) const
+{
+  unsigned numPorts = mMechanicNode->getNumPorts();
+  for (unsigned i = 0; i < numPorts; ++i) {
+    SharedPtr<const PortInfo> portInfo = mMechanicNode->getPort(i);
+    OpenFDMAssert(portInfo);
+    const PortValue* portValue = getPortValueList().getPortValue(i);
+    if (!portValue)
+      continue;
+    unsigned otherNumPorts = mechanicContext.mMechanicNode->getNumPorts();
+    for (unsigned j = 0; j < otherNumPorts; ++j) {
+      if (!mechanicContext.mMechanicNode->getPort(j)->toProviderPortInfo())
+        continue;
+      
+      const PortValue* otherPortValue;
+      otherPortValue = mechanicContext.getPortValueList().getPortValue(j);
+      if (portValue != otherPortValue)
+        continue;
+      
+      return true;
+    }
+  }
+  return false;
+}
+
+} // namespace OpenFDM

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicContext.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicContext.h	2008-09-30 20:19:18 UTC (rev 541)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicContext.h	2008-09-30 20:27:19 UTC (rev 542)
@@ -0,0 +1,105 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_MechanicContext_H
+#define OpenFDM_MechanicContext_H
+
+#include <list>
+#include "SharedPtr.h"
+#include "LeafContext.h"
+#include "MechanicNode.h"
+
+namespace OpenFDM {
+
+class Task;
+class DiscreteTask;
+class ContinousTask;
+
+class MechanicContext : public LeafContext {
+public:
+  MechanicContext(const MechanicNode* mechanicNode);
+  virtual ~MechanicContext();
+
+  virtual const MechanicNode& getNode() const;
+
+  bool alloc()
+  { return mMechanicNode->alloc(*this); }
+  void init(const Task&)
+  { mMechanicNode->init(mDiscreteState, mContinousState, mPortValueList); }
+
+  void velocities(const ContinousTask&)
+  { mMechanicNode->velocity(mContinousState, mPortValueList); }
+  void articulation(const ContinousTask&)
+  { mMechanicNode->articulation(mContinousState, mPortValueList); }
+  void accelerations(const ContinousTask&)
+  { }
+
+//   virtual void derivative(const ContinousStateValueVector&,
+//                           const PortValueList&,
+//                           ContinousStateValueVector&) const
+ 
+//   void outputVelocities()
+//   { }
+//   void outputAcceperation()
+//   { }
+
+  void update(const DiscreteTask& discreteTask)
+  {
+    mMechanicNode->update(discreteTask, mDiscreteState,
+                          mContinousState, mPortValueList);
+  }
+
+  bool isConnectedTo(const MechanicContext& mechanicContext) const;
+
+private:
+  SharedPtr<const MechanicNode> mMechanicNode;
+
+private:
+  MechanicContext();
+  MechanicContext(const MechanicContext&);
+  MechanicContext& operator=(const MechanicContext&);
+};
+
+class MechanicContextList : public std::list<SharedPtr<MechanicContext> > {
+public:
+  typedef std::list<SharedPtr<MechanicContext> > list_type;
+
+  bool alloc() const
+  {
+    for (list_type::const_iterator i = begin(); i != end(); ++i)
+      if (!(*i)->alloc())
+        return false;
+    return true;
+  }
+  void init(const Task& task) const
+  {
+    for (list_type::const_iterator i = begin(); i != end(); ++i)
+      (*i)->init(task);
+  }
+  void velocities(const ContinousTask& task) const
+  {
+    for (list_type::const_iterator i = begin(); i != end(); ++i)
+      (*i)->velocities(task);
+  }
+  void articulation(const ContinousTask& task) const
+  {
+    // Note that this list is traversed from the mechanic leafs to the root
+    for (list_type::const_reverse_iterator i = rbegin(); i != rend(); ++i)
+      (*i)->articulation(task);
+  }
+  void accelerations(const ContinousTask& task) const
+  {
+    for (list_type::const_iterator i = begin(); i != end(); ++i)
+      (*i)->accelerations(task);
+  }
+  void update(const DiscreteTask& task) const
+  {
+    for (list_type::const_iterator i = begin(); i != end(); ++i)
+      (*i)->update(task);
+  }
+};
+
+} // namespace OpenFDM
+
+#endif

Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-30 20:19:18 UTC (rev 541)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-30 20:27:19 UTC (rev 542)
@@ -48,6 +48,7 @@
 #include <OpenFDM/LeafContext.h>
 #include <OpenFDM/NodeContext.h>
 #include <OpenFDM/ModelContext.h>
+#include <OpenFDM/MechanicContext.h>
 #include <OpenFDM/Task.h>
 
 #include <OpenFDM/RigidBody.h>
@@ -120,115 +121,6 @@
 /// there must be a PortData like structure that is only built during simulation
 /// model initialization.
 
-class MechanicContext : public LeafContext {
-public:
-  MechanicContext(const MechanicNode* mechanicNode) :
-    mMechanicNode(mechanicNode)
-  { OpenFDMAssert(mMechanicNode); }
-
-  virtual const MechanicNode& getNode() const
-  { return *mMechanicNode; }
-
-  bool alloc()
-  { return mMechanicNode->alloc(*this); }
-  void init(const Task&)
-  { mMechanicNode->init(mDiscreteState, mContinousState, mPortValueList); }
-
-  void velocities(const ContinousTask&)
-  { mMechanicNode->velocity(mContinousState, mPortValueList); }
-  void articulation(const ContinousTask&)
-  { mMechanicNode->articulation(mContinousState, mPortValueList); }
-  void accelerations(const ContinousTask&)
-  { }
-
-//   virtual void derivative(const ContinousStateValueVector&,
-//                           const PortValueList&,
-//                           ContinousStateValueVector&) const
- 
-//   void outputVelocities()
-//   { }
-//   void outputAcceperation()
-//   { }
-
-  void update(const DiscreteTask& discreteTask)
-  {
-    mMechanicNode->update(discreteTask, mDiscreteState,
-                          mContinousState, mPortValueList);
-  }
-
-  bool isConnectedTo(const MechanicContext& mechanicContext) const
-  {
-    unsigned numPorts = mMechanicNode->getNumPorts();
-    for (unsigned i = 0; i < numPorts; ++i) {
-      SharedPtr<const PortInfo> portInfo = mMechanicNode->getPort(i);
-      OpenFDMAssert(portInfo);
-      const PortValue* portValue = getPortValueList().getPortValue(i);
-      if (!portValue)
-        continue;
-      unsigned otherNumPorts = mechanicContext.mMechanicNode->getNumPorts();
-      for (unsigned j = 0; j < otherNumPorts; ++j) {
-        if (!mechanicContext.mMechanicNode->getPort(j)->toProviderPortInfo())
-          continue;
-
-        const PortValue* otherPortValue;
-        otherPortValue = mechanicContext.getPortValueList().getPortValue(j);
-        if (portValue != otherPortValue)
-          continue;
-
-        return true;
-      }
-    }
-    return false;
-  }
-
-private:
-  SharedPtr<const MechanicNode> mMechanicNode;
-
-private:
-  MechanicContext();
-  MechanicContext(const MechanicContext&);
-  MechanicContext& operator=(const MechanicContext&);
-};
-
-class MechanicContextList : public std::list<SharedPtr<MechanicContext> > {
-public:
-  typedef std::list<SharedPtr<MechanicContext> > list_type;
-
-  bool alloc() const
-  {
-    for (list_type::const_iterator i = begin(); i != end(); ++i)
-      if (!(*i)->alloc())
-        return false;
-    return true;
-  }
-  void init(const Task& task) const
-  {
-    for (list_type::const_iterator i = begin(); i != end(); ++i)
-      (*i)->init(task);
-  }
-  void velocities(const ContinousTask& task) const
-  {
-    for (list_type::const_iterator i = begin(); i != end(); ++i)
-      (*i)->velocities(task);
-  }
-  void articulation(const ContinousTask& task) const
-  {
-    // Note that this list is traversed from the mechanic leafs to the root
-    for (list_type::const_reverse_iterator i = rbegin(); i != rend(); ++i)
-      (*i)->articulation(task);
-  }
-  void accelerations(const ContinousTask& task) const
-  {
-    for (list_type::const_iterator i = begin(); i != end(); ++i)
-      (*i)->accelerations(task);
-  }
-  void update(const DiscreteTask& task) const
-  {
-    for (list_type::const_iterator i = begin(); i != end(); ++i)
-      (*i)->update(task);
-  }
-};
-
 class MechanicInstance : public AbstractNodeInstance {
 public:
   MechanicInstance(const NodePath& nodePath,



From frohlich at mail.berlios.de  Tue Sep 30 22:35:49 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Tue, 30 Sep 2008 22:35:49 +0200
Subject: [OpenFDM-svn] r543 - in branches/OpenFDM-StateSeparation/src:
	OpenFDM test
Message-ID: <200809302035.m8UKZnEl000161@sheep.berlios.de>

Author: frohlich
Date: 2008-09-30 22:35:48 +0200 (Tue, 30 Sep 2008)
New Revision: 543

Added:
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicInstance.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicInstance.h
Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
   branches/OpenFDM-StateSeparation/src/OpenFDM/ModelInstance.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/ModelInstance.h
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Move MechanicInstance into the implementation files.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-09-30 20:27:19 UTC (rev 542)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2008-09-30 20:35:48 UTC (rev 543)
@@ -59,6 +59,7 @@
   MidpointRule.h \
   MechanicContext.h \
   MechanicBodyPort.h \
+  MechanicInstance.h \
   MechanicInteractPort.h \
   MechanicNode.h \
   MechanicPortValue.h \
@@ -145,6 +146,7 @@
   Logger.cpp \
   MatrixStateValue.cpp \
   MechanicContext.cpp \
+  MechanicInstance.cpp \
   MechanicNode.cpp \
   MechanicPortValue.cpp \
   MidpointRule.cpp \

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicInstance.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicInstance.cpp	2008-09-30 20:27:19 UTC (rev 542)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicInstance.cpp	2008-09-30 20:35:48 UTC (rev 543)
@@ -0,0 +1,38 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
+ *
+ */
+
+#include "MechanicInstance.h"
+
+namespace OpenFDM {
+
+MechanicInstance::MechanicInstance(const NodePath& nodePath,
+                                   const MechanicNode* mechanicNode) :
+  AbstractNodeInstance(nodePath),
+  mMechanicContext(new MechanicContext(mechanicNode))
+{
+}
+
+MechanicInstance::~MechanicInstance()
+{
+}
+
+bool
+MechanicInstance::isConnectedTo(const MechanicInstance& mechanicInstance) const
+{
+  return mMechanicContext->isConnectedTo(*mechanicInstance.mMechanicContext);
+}
+
+MechanicContext&
+MechanicInstance::getNodeContext()
+{
+  return *mMechanicContext;
+}
+
+const MechanicContext&
+MechanicInstance::getNodeContext() const
+{
+  return *mMechanicContext;
+}
+
+} // namespace OpenFDM

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicInstance.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicInstance.h	2008-09-30 20:27:19 UTC (rev 542)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicInstance.h	2008-09-30 20:35:48 UTC (rev 543)
@@ -0,0 +1,35 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_MechanicInstance_H
+#define OpenFDM_MechanicInstance_H
+
+#include <list>
+#include "AbstractNodeInstance.h"
+#include "MechanicContext.h"
+#include "SharedPtr.h"
+
+namespace OpenFDM {
+
+class MechanicInstance : public AbstractNodeInstance {
+public:
+  MechanicInstance(const NodePath& nodePath,
+                   const MechanicNode* mechanicNode);
+  virtual ~MechanicInstance();
+
+  bool isConnectedTo(const MechanicInstance& mechanicInstance) const;
+
+protected:
+  virtual MechanicContext& getNodeContext();
+  virtual const MechanicContext& getNodeContext() const;
+
+private:
+  SharedPtr<MechanicContext> mMechanicContext;
+};
+
+typedef std::list<SharedPtr<MechanicInstance> > MechanicInstanceList;
+
+} // namespace OpenFDM
+
+#endif

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/ModelInstance.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ModelInstance.cpp	2008-09-30 20:27:19 UTC (rev 542)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ModelInstance.cpp	2008-09-30 20:35:48 UTC (rev 543)
@@ -16,6 +16,12 @@
 {
 }
 
+bool
+ModelInstance::dependsOn(const ModelInstance& modelInstance) const
+{
+  return mModelContext->dependsOn(*modelInstance.mModelContext);
+}
+
 ModelContext&
 ModelInstance::getNodeContext()
 {

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/ModelInstance.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ModelInstance.h	2008-09-30 20:27:19 UTC (rev 542)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ModelInstance.h	2008-09-30 20:35:48 UTC (rev 543)
@@ -18,8 +18,7 @@
   virtual ~ModelInstance();
 
   // Return true if this leaf directly depends on one of leafInstance outputs
-  bool dependsOn(const ModelInstance& modelInstance) const
-  { return mModelContext->dependsOn(*modelInstance.mModelContext); }
+  bool dependsOn(const ModelInstance& modelInstance) const;
 
   // FIXME
 // protected:

Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-30 20:27:19 UTC (rev 542)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-30 20:35:48 UTC (rev 543)
@@ -37,6 +37,7 @@
 
 #include <OpenFDM/NodeInstance.h>
 #include <OpenFDM/ModelInstance.h>
+#include <OpenFDM/MechanicInstance.h>
 
 #include <OpenFDM/AbstractSystem.h>
 #include <OpenFDM/System.h>
@@ -121,33 +122,6 @@
 /// there must be a PortData like structure that is only built during simulation
 /// model initialization.
 
-class MechanicInstance : public AbstractNodeInstance {
-public:
-  MechanicInstance(const NodePath& nodePath,
-                   const MechanicNode* mechanicNode) :
-    AbstractNodeInstance(nodePath),
-    mMechanicContext(new MechanicContext(mechanicNode))
-  { }
-
-  bool isConnectedTo(const MechanicInstance& mechanicInstance) const
-  { return mMechanicContext->isConnectedTo(*mechanicInstance.mMechanicContext); }
-
-protected:
-  virtual MechanicContext& getNodeContext()
-  { return *mMechanicContext; }
-  virtual const MechanicContext& getNodeContext() const
-  { return *mMechanicContext; }
-
-private:
-  SharedPtr<MechanicContext> mMechanicContext;
-};
-
-typedef std::list<SharedPtr<MechanicInstance> > MechanicInstanceList;
-
-
-
-
-
 // Just here so that I do not care for intationation order for now ...
 struct PortDataHelper {
 



From frohlich at mail.berlios.de  Tue Sep 30 22:42:45 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Tue, 30 Sep 2008 22:42:45 +0200
Subject: [OpenFDM-svn] r544 - in branches/OpenFDM-StateSeparation/src:
	OpenFDM test
Message-ID: <200809302042.m8UKgjRA000766@sheep.berlios.de>

Author: frohlich
Date: 2008-09-30 22:42:44 +0200 (Tue, 30 Sep 2008)
New Revision: 544

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/System.h
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Move NodeInstanceCollector into the System scope.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/System.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/System.h	2008-09-30 20:35:48 UTC (rev 543)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/System.h	2008-09-30 20:42:44 UTC (rev 544)
@@ -44,6 +44,8 @@
   { return mNodeInstanceList; }
 
 private:
+  class NodeInstanceCollector;
+
   SharedPtr<Node> mNode;
 
   SharedPtr<AbstractSystem> mAbstractSystem;

Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-30 20:35:48 UTC (rev 543)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-30 20:42:44 UTC (rev 544)
@@ -123,7 +123,8 @@
 /// model initialization.
 
 // Just here so that I do not care for intationation order for now ...
-struct PortDataHelper {
+class System::NodeInstanceCollector : public ConstNodeVisitor {
+public:
 
   struct AcceptorPortData;
   struct ProviderPortData;
@@ -334,10 +335,7 @@
     /// PortValues to the current connect information.
     SharedPtr<AbstractNodeInstance> mNodeInstance;
   };
-};
 
-class NodeInstanceCollector : public ConstNodeVisitor {
-public:
 
   virtual void apply(const Node& node)
   { std::cerr << __PRETTY_FUNCTION__ << std::endl; }
@@ -346,12 +344,12 @@
   virtual void apply(const LibraryNode& libraryNode)
   { std::cerr << __PRETTY_FUNCTION__ << std::endl; }
 
-  PortDataHelper::PortDataList* buildNodeContext(const Node& node)
+  PortDataList* buildNodeContext(const Node& node)
   {
     NodeInstance* nodeInstance;
     nodeInstance = new NodeInstance(getNodePath(), &node);
     _nodeInstanceList.push_back(nodeInstance);
-    PortDataHelper::PortDataList* portDataList;
+    PortDataList* portDataList;
     portDataList = getCurrentNodePortDataList();
     portDataList->setNodeInstance(nodeInstance);
     return portDataList;
@@ -360,27 +358,27 @@
   // Aussen acceptor, innen provider
   virtual void apply(const GroupAcceptorNode& leaf)
   {
-    PortDataHelper::PortDataList* portDataList = buildNodeContext(leaf);
+    PortDataList* portDataList = buildNodeContext(leaf);
 
     OpenFDMAssert(leaf.getPort(0));
 
-    PortDataHelper::ProviderPortData* providerPortData;
+    ProviderPortData* providerPortData;
     providerPortData = portDataList->newProxyProviderPortData(leaf._groupInternalPort);
   }
   // Aussen provider, innen acceptor
   virtual void apply(const GroupProviderNode& leaf)
   {
-    PortDataHelper::PortDataList* portDataList = buildNodeContext(leaf);
+    PortDataList* portDataList = buildNodeContext(leaf);
 
     OpenFDMAssert(leaf.getPort(0));
 
-    PortDataHelper::AcceptorPortData* acceptorPortData;
+    AcceptorPortData* acceptorPortData;
     acceptorPortData = portDataList->newProxyAcceptorPortData(leaf._groupInternalPort);
   }
 
   void allocPortData(AbstractNodeInstance* nodeInstance, const LeafNode& leaf)
   {
-    PortDataHelper::PortDataList* portDataList;
+    PortDataList* portDataList;
     portDataList = getCurrentNodePortDataList();
     portDataList->setNodeInstance(nodeInstance);
 
@@ -388,12 +386,12 @@
       SharedPtr<const PortInfo> port = leaf.getPort(i);
       const ProviderPortInfo* providerPort = port->toProviderPortInfo();
       if (providerPort) {
-        PortDataHelper::ProviderPortData* providerPortData;
+        ProviderPortData* providerPortData;
         providerPortData = portDataList->newProviderPortData(providerPort);
       }
       const AcceptorPortInfo* acceptorPort = port->toAcceptorPortInfo();
       if (acceptorPort) {
-        PortDataHelper::AcceptorPortData* acceptorPortData;
+        AcceptorPortData* acceptorPortData;
         acceptorPortData = portDataList->newAcceptorPortData(acceptorPort);
       }
     }
@@ -429,8 +427,8 @@
     // Prepare a new leaf map for the child group
     PortDataMap parentPortDataMap(group.getNumChildren());
     for (unsigned i = 0; i < group.getNumChildren(); ++i) {
-      PortDataHelper::PortDataList* portDataList;
-      portDataList = new PortDataHelper::PortDataList;
+      PortDataList* portDataList;
+      portDataList = new PortDataList;
       parentPortDataMap[i] = portDataList;
       _portDataListList.push_back(portDataList);
     }
@@ -438,7 +436,7 @@
 
     // Walk the children
     for (unsigned i = 0; i < group.getNumChildren(); ++i) {
-      SharedPtr<PortDataHelper::PortDataList> parentNodePortDataList;
+      SharedPtr<PortDataList> parentNodePortDataList;
       parentNodePortDataList.swap(mCurrentNodePortDataList);
       mCurrentNodePortDataList = _portDataMap[i];
 
@@ -485,7 +483,7 @@
         std::cerr << "Cannot connect????" << std::endl;
     }
 
-    SharedPtr<PortDataHelper::PortDataList> portDataList = buildNodeContext(group);
+    SharedPtr<PortDataList> portDataList = buildNodeContext(group);
 
     parentPortDataMap.swap(_portDataMap);
     // Ok, some nameing niceness
@@ -503,31 +501,31 @@
         continue;
       }
 
-      PortDataHelper::PortData* portData;
+      PortData* portData;
       portData = childrenPortDataMap[nodeIndex]->mPortDataVector.front();
       if (portData->toProxyAcceptorPortData()) {
-        PortDataHelper::ProxyAcceptorPortData* proxyAcceptorPortData;
+        ProxyAcceptorPortData* proxyAcceptorPortData;
         proxyAcceptorPortData = portData->toProxyAcceptorPortData();
 
         const ProviderPortInfo* providerPortInfo;
         providerPortInfo = group.getPort(i)->toProviderPortInfo();
         OpenFDMAssert(providerPortInfo);
 
-        PortDataHelper::ProxyProviderPortData* proxyProviderPortData;
+        ProxyProviderPortData* proxyProviderPortData;
         proxyProviderPortData =
           portDataList->newProxyProviderPortData(providerPortInfo);
 
         proxyProviderPortData->setProxyAcceptorPortData(proxyAcceptorPortData);
 
       } else if (portData->toProxyProviderPortData()) {
-        PortDataHelper::ProxyProviderPortData* proxyProviderPortData;
+        ProxyProviderPortData* proxyProviderPortData;
         proxyProviderPortData = portData->toProxyProviderPortData();
 
         const AcceptorPortInfo* acceptorPortInfo;
         acceptorPortInfo = group.getPort(i)->toAcceptorPortInfo();
         OpenFDMAssert(acceptorPortInfo);
 
-        PortDataHelper::ProxyAcceptorPortData* proxyAcceptorPortData;
+        ProxyAcceptorPortData* proxyAcceptorPortData;
         proxyAcceptorPortData =
           portDataList->newProxyAcceptorPortData(acceptorPortInfo);
 
@@ -555,12 +553,12 @@
 
   ////////////////////////////////////////////////////////////////////////////
   // Used to map connections in groups ...
-  typedef std::vector<SharedPtr<PortDataHelper::PortDataList> > PortDataMap;
+  typedef std::vector<SharedPtr<PortDataList> > PortDataMap;
   PortDataMap _portDataMap;
   // Just to hold references to all mort data lists we have in the
   // simulation system. They are just needed during traversal for connect
   // information and to distribute port value pointers.
-  typedef std::list<SharedPtr<PortDataHelper::PortDataList> > PortDataListList;
+  typedef std::list<SharedPtr<PortDataList> > PortDataListList;
   PortDataListList _portDataListList;
 
   // Here the miracle occurs.
@@ -668,16 +666,16 @@
     return true;
   }
 
-  PortDataHelper::PortDataList* getCurrentNodePortDataList()
+  PortDataList* getCurrentNodePortDataList()
   {
     if (!mCurrentNodePortDataList)
       // will happen for the toplevel group node ..
-      mCurrentNodePortDataList = new PortDataHelper::PortDataList;
+      mCurrentNodePortDataList = new PortDataList;
     return mCurrentNodePortDataList;
   }
 
 private:
-  SharedPtr<PortDataHelper::PortDataList> mCurrentNodePortDataList;
+  SharedPtr<PortDataList> mCurrentNodePortDataList;
 };
 
 bool



From frohlich at mail.berlios.de  Tue Sep 30 22:55:17 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Tue, 30 Sep 2008 22:55:17 +0200
Subject: [OpenFDM-svn] r546 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200809302055.m8UKtHnO002168@sheep.berlios.de>

Author: frohlich
Date: 2008-09-30 22:55:17 +0200 (Tue, 30 Sep 2008)
New Revision: 546

Modified:
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Remove some now unused includes.


Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-30 20:50:10 UTC (rev 545)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2008-09-30 20:55:17 UTC (rev 546)
@@ -1,67 +1,10 @@
-#include <OpenFDM/Matrix.h>
-#include <OpenFDM/Object.h>
-#include <OpenFDM/SharedPtr.h>
-#include <OpenFDM/WeakPtr.h>
-#include <OpenFDM/Rotation.h>
-#include <OpenFDM/Inertia.h>
-#include <OpenFDM/PortValue.h>
-#include <OpenFDM/PortValueList.h>
-#include <OpenFDM/PortId.h>
-#include <OpenFDM/Node.h>
-#include <OpenFDM/NodeVisitor.h>
-#include <OpenFDM/MatrixInputPort.h>
-#include <OpenFDM/MatrixOutputPort.h>
-#include <OpenFDM/RealInputPort.h>
-#include <OpenFDM/RealOutputPort.h>
-#include <OpenFDM/MechanicBodyPort.h>
-#include <OpenFDM/MechanicInteractPort.h>
-#include <OpenFDM/RootJoint.h>
-
-#include <OpenFDM/StateInfo.h>
-#include <OpenFDM/StateValue.h>
-#include <OpenFDM/ContinousStateValue.h>
-#include <OpenFDM/MatrixStateValue.h>
-
-#include <OpenFDM/StateInfoVector.h>
-#include <OpenFDM/ContinousStateInfoVector.h>
-
-#include <OpenFDM/ContinousStateValueVector.h>
-#include <OpenFDM/DiscreteStateValueVector.h>
-
-#include <OpenFDM/ODESolver.h>
-#include <OpenFDM/ExplicitEuler.h>
-#include <OpenFDM/DoPri5.h>
-#include <OpenFDM/Function.h>
-#include <OpenFDM/SampleTime.h>
-#include <OpenFDM/Interval.h>
-
-#include <OpenFDM/NodeInstance.h>
-#include <OpenFDM/ModelInstance.h>
-#include <OpenFDM/MechanicInstance.h>
-
-#include <OpenFDM/AbstractSystem.h>
-#include <OpenFDM/System.h>
-
-#include <OpenFDM/BoolStateInfo.h>
-#include <OpenFDM/RealStateInfo.h>
-#include <OpenFDM/MatrixStateInfo.h>
-
-#include <OpenFDM/LeafContext.h>
-#include <OpenFDM/NodeContext.h>
-#include <OpenFDM/ModelContext.h>
-#include <OpenFDM/MechanicContext.h>
-#include <OpenFDM/Task.h>
-
-#include <OpenFDM/RigidBody.h>
-#include <OpenFDM/Interact.h>
-
 #include <OpenFDM/Gain.h>
 #include <OpenFDM/DiscreteIntegrator.h>
 #include <OpenFDM/Integrator.h>
 #include <OpenFDM/Delay.h>
 #include <OpenFDM/Output.h>
-
 #include <OpenFDM/Group.h>
+#include <OpenFDM/System.h>
 
 using namespace OpenFDM;
 



From frohlich at mail.berlios.de  Tue Sep 30 22:58:06 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Tue, 30 Sep 2008 22:58:06 +0200
Subject: [OpenFDM-svn] r547 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200809302058.m8UKw66Z003499@sheep.berlios.de>

Author: frohlich
Date: 2008-09-30 22:58:05 +0200 (Tue, 30 Sep 2008)
New Revision: 547

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
Log:
Remove cout/cerr with some log messages.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-09-30 20:55:17 UTC (rev 546)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2008-09-30 20:58:05 UTC (rev 547)
@@ -262,11 +262,11 @@
 
 
   virtual void apply(const Node& node)
-  { std::cerr << __PRETTY_FUNCTION__ << std::endl; }
+  { Log(Schedule, Error) << __PRETTY_FUNCTION__ << std::endl; }
   virtual void apply(const LeafNode& leaf)
-  { std::cerr << __PRETTY_FUNCTION__ << std::endl; }
+  { Log(Schedule, Error) << __PRETTY_FUNCTION__ << std::endl; }
   virtual void apply(const LibraryNode& libraryNode)
-  { std::cerr << __PRETTY_FUNCTION__ << std::endl; }
+  { Log(Schedule, Error) << __PRETTY_FUNCTION__ << std::endl; }
 
   PortDataList* buildNodeContext(const Node& node)
   {
@@ -376,11 +376,11 @@
       unsigned providerNodeIndex = group.getConnectProviderNodeIndex(i);
 
       if (acceptorNodeIndex == ~0u) {
-        std::cerr << "Cannot find acceptor node from nodeId" << std::endl;
+        Log(Schedule, Error) << "Cannot find acceptor node from nodeId" << std::endl;
         continue;
       }
       if (providerNodeIndex == ~0u) {
-        std::cerr << "Cannot find provider node from nodeId" << std::endl;
+        Log(Schedule, Error) << "Cannot find provider node from nodeId" << std::endl;
         continue;
       }
 
@@ -390,12 +390,12 @@
       providerPort = group.getConnectProviderPortInfo(i);
 
       if (!acceptorPort) {
-        std::cerr << "Cannot find acceptor Port data node "
+        Log(Schedule, Error) << "Cannot find acceptor Port data node "
                   << group.getChild(acceptorNodeIndex)->getName() << std::endl;
         continue;
       }
       if (!providerPort) {
-        std::cerr << "Cannot find provider Port data node "
+        Log(Schedule, Error) << "Cannot find provider Port data node "
                   << group.getChild(providerNodeIndex)->getName() << std::endl;
         continue;
       }
@@ -404,7 +404,7 @@
       unsigned providerPortNumber = providerPort->getIndex();
       if (!_portDataMap[acceptorNodeIndex]->mPortDataVector[acceptorPortNumber]->
           connect(_portDataMap[providerNodeIndex]->mPortDataVector[providerPortNumber]))
-        std::cerr << "Cannot connect????" << std::endl;
+        Log(Schedule, Error) << "Cannot connect????" << std::endl;
     }
 
     SharedPtr<PortDataList> portDataList = buildNodeContext(group);
@@ -420,8 +420,8 @@
       unsigned nodeIndex = group.getGroupPortNodeIndex(group.getPortId(i));
       if (childrenPortDataMap[nodeIndex]->mPortDataVector.empty()) {
         // FIXME, is this an internal error ???
-        std::cerr << "Hmm, cannot find GroupPortNode for external port "
-                  << i << std::endl;
+        Log(Schedule, Error) << "Hmm, cannot find GroupPortNode for external "
+                             << "port " << i << std::endl;
         continue;
       }
 



