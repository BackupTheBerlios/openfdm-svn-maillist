From frohlich at mail.berlios.de  Sun Mar  2 12:51:59 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 2 Mar 2008 12:51:59 +0100
Subject: [OpenFDM-svn] r368 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200803021151.m22BpxaH025992@sheep.berlios.de>

Author: frohlich
Date: 2008-03-02 12:51:57 +0100 (Sun, 02 Mar 2008)
New Revision: 368

Modified:
   trunk/OpenFDM/src/OpenFDM/Unit.h
Log:
Fix compiler warning.


Modified: trunk/OpenFDM/src/OpenFDM/Unit.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Unit.h	2008-02-29 17:04:44 UTC (rev 367)
+++ trunk/OpenFDM/src/OpenFDM/Unit.h	2008-03-02 11:51:57 UTC (rev 368)
@@ -161,19 +161,19 @@
     mOffset(0)
   { }
   Unit(const PhysicalDimension& physDim) :
-    mPhysicalDimension(physDim),
     mFactor(1),
-    mOffset(0)
+    mOffset(0),
+    mPhysicalDimension(physDim)
   { }
   Unit(const PhysicalDimension& physDim, real_type factor) :
-    mPhysicalDimension(physDim),
     mFactor(factor),
-    mOffset(0)
+    mOffset(0),
+    mPhysicalDimension(physDim)
   { }
   Unit(const PhysicalDimension& physDim, real_type factor, real_type offset) :
-    mPhysicalDimension(physDim),
     mFactor(factor),
-    mOffset(offset)
+    mOffset(offset),
+    mPhysicalDimension(physDim)
   { }
 
   real_type getFactor(void) const



From frohlich at mail.berlios.de  Tue Mar  4 18:29:50 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Tue, 4 Mar 2008 18:29:50 +0100
Subject: [OpenFDM-svn] r369 - trunk/flightgear
Message-ID: <200803041729.m24HToVL007208@sheep.berlios.de>

Author: frohlich
Date: 2008-03-04 18:29:50 +0100 (Tue, 04 Mar 2008)
New Revision: 369

Modified:
   trunk/flightgear/flightgear.diff
Log:
Add -lrt


Modified: trunk/flightgear/flightgear.diff
===================================================================
--- trunk/flightgear/flightgear.diff	2008-03-02 11:51:57 UTC (rev 368)
+++ trunk/flightgear/flightgear.diff	2008-03-04 17:29:50 UTC (rev 369)
@@ -77,13 +77,14 @@
 diff -u -r1.63 Makefile.am
 --- src/Main/Makefile.am	20 Jan 2006 17:19:02 -0000	1.63
 +++ src/Main/Makefile.am	5 Feb 2006 12:39:43 -0000
-@@ -13,6 +13,13 @@
+@@ -13,6 +13,14 @@
  SP_FDM_LIBS = 
  endif
  
 +if ENABLE_OpenFDM_FDM
 +OpenFDM_LIBS = $(top_builddir)/src/FDM/OpenFDM/libFGOpenFDM.a \
-+               -lOpenFDMJSBReader -lOpenFDMeasyxmlXML -lOpenFDMXML -lOpenFDM
++               -lOpenFDMJSBReader -lOpenFDMeasyxmlXML -lOpenFDMXML -lOpenFDM \
++               -lrt
 +else
 +OpenFDM_LIBS = 
 +endif



From frohlich at mail.berlios.de  Fri Mar  7 21:32:50 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Fri, 7 Mar 2008 21:32:50 +0100
Subject: [OpenFDM-svn] r370 - in trunk/OpenFDM/src: OpenFDM test
Message-ID: <200803072032.m27KWo74011226@sheep.berlios.de>

Author: frohlich
Date: 2008-03-07 21:32:49 +0100 (Fri, 07 Mar 2008)
New Revision: 370

Modified:
   trunk/OpenFDM/src/OpenFDM/AirSpring.cpp
   trunk/OpenFDM/src/OpenFDM/DiscBrake.cpp
   trunk/OpenFDM/src/OpenFDM/Newton.cpp
   trunk/OpenFDM/src/OpenFDM/Planet.cpp
   trunk/OpenFDM/src/OpenFDM/SimpleGear.cpp
   trunk/OpenFDM/src/OpenFDM/System.cpp
   trunk/OpenFDM/src/OpenFDM/WheelContact.cpp
   trunk/OpenFDM/src/test/harmonic.cpp
Log:
Compile fixes.


Modified: trunk/OpenFDM/src/OpenFDM/AirSpring.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/AirSpring.cpp	2008-03-04 17:29:50 UTC (rev 369)
+++ trunk/OpenFDM/src/OpenFDM/AirSpring.cpp	2008-03-07 20:32:49 UTC (rev 370)
@@ -79,8 +79,8 @@
   real_type pushDispRatio = pushDisp/maxDisp;
   
   
-  pullDispRatio = max(min(pullDispRatio, 0.95), 0.0);
-  pushDispRatio = max(min(pushDispRatio, 0.95), 0.0);
+  pullDispRatio = max(min(pullDispRatio, real_type(0.95)), real_type(0.0));
+  pushDispRatio = max(min(pushDispRatio, real_type(0.95)), real_type(0.0));
   
   real_type pullPressure = mPullPressure/(1-pow(pullDispRatio, mGamma));
   real_type pushPressure = mPushPressure/(1-pow(pushDispRatio, mGamma));

Modified: trunk/OpenFDM/src/OpenFDM/DiscBrake.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/DiscBrake.cpp	2008-03-04 17:29:50 UTC (rev 369)
+++ trunk/OpenFDM/src/OpenFDM/DiscBrake.cpp	2008-03-07 20:32:49 UTC (rev 370)
@@ -68,15 +68,17 @@
   // with this sigma the model is already very crisp and reaches the
   // maximum force relatively fast, thus we do not need to make it even faster
   // with higher speeds
-//   vel = saturate(vel, 1.0);
-  vel = smoothSaturate(vel, 1.0);
+//   vel = saturate(vel, real_type(1));
+  vel = smoothSaturate(vel, real_type(1));
   // the time derivative of the friction state
   mZDeriv = vel - sigma*fabs(vel)*mZ;
   // this is to limit the stiffness of this model
-//   mZDeriv = saturate(mZDeriv, 10.0);
-  mZDeriv = smoothSaturate(mZDeriv, 10.0);
+//   mZDeriv = saturate(mZDeriv, real_type(10));
+  mZDeriv = smoothSaturate(mZDeriv, real_type(10));
   // now the output force, modulate with the brake input
-  mForce = -interpolate(brakeInput, 0.0, mMinForce, 1.0, mMaxForce)*sigma*mZ;
+  mForce = -interpolate(brakeInput,
+                        real_type(0), mMinForce,
+                        real_type(1), mMaxForce)*sigma*mZ;
 }
 
 void

Modified: trunk/OpenFDM/src/OpenFDM/Newton.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Newton.cpp	2008-03-04 17:29:50 UTC (rev 369)
+++ trunk/OpenFDM/src/OpenFDM/Newton.cpp	2008-03-07 20:32:49 UTC (rev 370)
@@ -370,7 +370,7 @@
       converged = norm1(g) < atol;
       Log(NewtonMethod, Debug) << "||g||_1 = " << norm1(g) << endl;
 
-      mu = mu * max(1.0/3, 1-pow(2*rho-1, 3));
+      mu = mu * max(real_type(1)/3, 1-pow(2*rho-1, real_type(3)));
       nu = 2;
 
     } else {

Modified: trunk/OpenFDM/src/OpenFDM/Planet.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Planet.cpp	2008-03-04 17:29:50 UTC (rev 369)
+++ trunk/OpenFDM/src/OpenFDM/Planet.cpp	2008-03-07 20:32:49 UTC (rev 370)
@@ -25,16 +25,18 @@
 Geocentric
 Planet::toGeoc(const Vector3& cart) const
 {
-  real_type lon = (cart(0) == 0 && cart(1) == 0) ? 0 : atan2(cart(1), cart(0));
+  real_type lon = (cart(0) == 0 && cart(1) == 0)
+    ? real_type(0) : atan2(cart(1), cart(0));
   real_type nxy = sqrt(cart(0)*cart(0)+cart(1)*cart(1));
-  real_type lat = (nxy == 0 && cart(2) == 0) ? 0 : atan2(cart(2), nxy);
+  real_type lat = (nxy == 0 && cart(2) == 0)
+    ? real_type(0) : atan2(cart(2), nxy);
   return Geocentric(lat, lon, norm(cart));
 }
 
 Vector3
 Planet::toCart(const Geocentric& geoc) const
 {
-  real_type slat = std::sin(geoc.latitude);
+  real_type slat = sin(geoc.latitude);
   real_type clat = cos(geoc.latitude);
   real_type slon = sin(geoc.longitude);
   real_type clon = cos(geoc.longitude);

Modified: trunk/OpenFDM/src/OpenFDM/SimpleGear.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/SimpleGear.cpp	2008-03-04 17:29:50 UTC (rev 369)
+++ trunk/OpenFDM/src/OpenFDM/SimpleGear.cpp	2008-03-07 20:32:49 UTC (rev 370)
@@ -189,7 +189,8 @@
 //   Vector2 slip(wheelSlip, slipAngle);
 //   if (1 < norm(slip))
 //     slip = normalize(slip);
-  Vector2 slip(smoothSaturate(wheelSlip, 1.0), smoothSaturate(slipAngle, 1.0));
+  Vector2 slip(smoothSaturate(wheelSlip, real_type(1)),
+               smoothSaturate(slipAngle, real_type(1)));
   
   // The friction force for fast movement.
   Vector2 fricForce = (-friction*mFrictionCoef*normForce)*slip;

Modified: trunk/OpenFDM/src/OpenFDM/System.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/System.cpp	2008-03-04 17:29:50 UTC (rev 369)
+++ trunk/OpenFDM/src/OpenFDM/System.cpp	2008-03-07 20:32:49 UTC (rev 370)
@@ -481,7 +481,7 @@
     tcv.mStateStream.writeSubState(tmp);
     tmp = 1e6*(mGeodPos.latitude - tcv.mGeodPos.latitude);
     tcv.mStateStream.writeSubState(tmp);
-    tmp = smoothDeadBand(mGeodPos.altitude - tcv.mGeodPos.altitude, 10.0);
+    tmp = smoothDeadBand(mGeodPos.altitude - tcv.mGeodPos.altitude, real_type(10));
     tcv.mStateStream.writeSubState(tmp);
 
     // The orientation

Modified: trunk/OpenFDM/src/OpenFDM/WheelContact.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/WheelContact.cpp	2008-03-04 17:29:50 UTC (rev 369)
+++ trunk/OpenFDM/src/OpenFDM/WheelContact.cpp	2008-03-07 20:32:49 UTC (rev 370)
@@ -149,7 +149,8 @@
 //   Vector2 slip(wheelSlip, slipAngle);
 //   if (1 < norm(slip))
 //     slip = normalize(slip);
-  Vector2 slip(smoothSaturate(wheelSlip, 1.0), smoothSaturate(slipAngle, 1.0));
+  Vector2 slip(smoothSaturate(wheelSlip, real_type(1)),
+               smoothSaturate(slipAngle, real_type(1)));
   
   // The friction force for fast movement.
   return (-friction*mFrictionCoeficient*normForce)*slip;

Modified: trunk/OpenFDM/src/test/harmonic.cpp
===================================================================
--- trunk/OpenFDM/src/test/harmonic.cpp	2008-03-04 17:29:50 UTC (rev 369)
+++ trunk/OpenFDM/src/test/harmonic.cpp	2008-03-07 20:32:49 UTC (rev 370)
@@ -22,7 +22,7 @@
   real_type omega = 2;
 
   SharedPtr<System> system = new System("Harmonic Oszilator");
-  system->addSampleTime(0.01);
+  system->addSampleTime(real_type(0.01));
   system->setTimestepper(new DoPri5);
   
   Integrator* integrator0 = new Integrator("Acceleration Integrator");
@@ -89,7 +89,7 @@
   SharedPtr<ErrorCollectorCallback> posErrorCallback;
   posErrorCallback = new ErrorCollectorCallback;
   output->setCallback(posErrorCallback);
-  output->addSampleTime(0.1);
+  output->addSampleTime(real_type(0.1));
   system->addModel(output);
   Connection::connect(output->getInputPort(0), summer0->getOutputPort(0));
 
@@ -108,7 +108,7 @@
   SharedPtr<ErrorCollectorCallback> velErrorCallback;
   velErrorCallback = new ErrorCollectorCallback;
   output->setCallback(velErrorCallback);
-  output->addSampleTime(0.1);
+  output->addSampleTime(real_type(0.1));
   system->addModel(output);
   Connection::connect(output->getInputPort(0), summer1->getOutputPort(0));
 



From frohlich at mail.berlios.de  Fri Mar  7 23:12:19 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Fri, 7 Mar 2008 23:12:19 +0100
Subject: [OpenFDM-svn] r371 - trunk/OpenFDM/src/test
Message-ID: <200803072212.m27MCJgv022331@sheep.berlios.de>

Author: frohlich
Date: 2008-03-07 23:12:19 +0100 (Fri, 07 Mar 2008)
New Revision: 371

Modified:
   trunk/OpenFDM/src/test/harmonic.cpp
Log:
Compute fractions as fractions.


Modified: trunk/OpenFDM/src/test/harmonic.cpp
===================================================================
--- trunk/OpenFDM/src/test/harmonic.cpp	2008-03-07 20:32:49 UTC (rev 370)
+++ trunk/OpenFDM/src/test/harmonic.cpp	2008-03-07 22:12:19 UTC (rev 371)
@@ -22,7 +22,7 @@
   real_type omega = 2;
 
   SharedPtr<System> system = new System("Harmonic Oszilator");
-  system->addSampleTime(real_type(0.01));
+  system->addSampleTime(real_type(1)/real_type(100));
   system->setTimestepper(new DoPri5);
   
   Integrator* integrator0 = new Integrator("Acceleration Integrator");
@@ -89,7 +89,7 @@
   SharedPtr<ErrorCollectorCallback> posErrorCallback;
   posErrorCallback = new ErrorCollectorCallback;
   output->setCallback(posErrorCallback);
-  output->addSampleTime(real_type(0.1));
+  output->addSampleTime(real_type(1)/real_type(10));
   system->addModel(output);
   Connection::connect(output->getInputPort(0), summer0->getOutputPort(0));
 
@@ -108,7 +108,7 @@
   SharedPtr<ErrorCollectorCallback> velErrorCallback;
   velErrorCallback = new ErrorCollectorCallback;
   output->setCallback(velErrorCallback);
-  output->addSampleTime(real_type(0.1));
+  output->addSampleTime(real_type(1)/real_type(10));
   system->addModel(output);
   Connection::connect(output->getInputPort(0), summer1->getOutputPort(0));
 



From frohlich at mail.berlios.de  Sat Mar  8 12:25:14 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 8 Mar 2008 12:25:14 +0100
Subject: [OpenFDM-svn] r372 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200803081125.m28BPEGF022271@sheep.berlios.de>

Author: frohlich
Date: 2008-03-08 12:25:14 +0100 (Sat, 08 Mar 2008)
New Revision: 372

Modified:
   trunk/OpenFDM/src/OpenFDM/AeroForce.cpp
   trunk/OpenFDM/src/OpenFDM/DefaultPlanet.cpp
Log:
Type fixeType fixess


Modified: trunk/OpenFDM/src/OpenFDM/AeroForce.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/AeroForce.cpp	2008-03-07 22:12:19 UTC (rev 371)
+++ trunk/OpenFDM/src/OpenFDM/AeroForce.cpp	2008-03-08 11:25:14 UTC (rev 372)
@@ -636,14 +636,14 @@
   // Calibrated Airspeed
   real_type tube_press;
   if (mach(0) < 1) {   // Calculate total pressure assuming isentropic flow
-    tube_press = p*pow((1 + 0.2*mach(0)*mach(0)), 3.5);
+    tube_press = p*pow((1 + 0.2*mach(0)*mach(0)), real_type(3.5));
   } else {
     // Use Rayleigh pitot tube formula for normal shock in front of pitot tube
     real_type B = 5.76*mach(0)*mach(0)/(5.6*mach(0)*mach(0) - 0.8);
     real_type D = 0.4167*(2.8*mach(0)*mach(0) - 0.4);
-    tube_press = p*pow(B, 3.5)*D;
+    tube_press = p*pow(B, real_type(3.5))*D;
   }
-  real_type A = pow(((tube_press-p)/psl+1), 0.28571);
+  real_type A = pow(((tube_press-p)/psl+1), real_type(0.28571));
   if (mach(0) > 0) {
     mCalibratedAirSpeed = sqrt(7*psl/rhosl*(A-1));
     mEquivalentAirSpeed = sqrt(2*qbar/rhosl);

Modified: trunk/OpenFDM/src/OpenFDM/DefaultPlanet.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/DefaultPlanet.cpp	2008-03-07 22:12:19 UTC (rev 371)
+++ trunk/OpenFDM/src/OpenFDM/DefaultPlanet.cpp	2008-03-08 11:25:14 UTC (rev 372)
@@ -71,7 +71,7 @@
   real_type q = Z*Z*(1-e*e)*ra2;
   real_type r = 1.0/6.0*(p+q-e4);
   real_type s = e4*p*q/(4.0*r*r*r);
-  real_type t = pow(1.0+s+sqrt(s*(2.0+s)), 1.0/3.0);
+  real_type t = pow(1.0+s+sqrt(s*(2.0+s)), real_type(1)/3);
   real_type u = r*(1.0+t+1.0/t);
   real_type v = sqrt(u*u+e4*q);
   real_type w = e2*(u+v-q)/(2.0*v);



From frohlich at mail.berlios.de  Sat Mar  8 12:31:20 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 8 Mar 2008 12:31:20 +0100
Subject: [OpenFDM-svn] r373 - trunk/OpenFDM/src/test
Message-ID: <200803081131.m28BVKbd024413@sheep.berlios.de>

Author: frohlich
Date: 2008-03-08 12:31:18 +0100 (Sat, 08 Mar 2008)
New Revision: 373

Added:
   trunk/OpenFDM/src/test/limit.cpp
Modified:
   trunk/OpenFDM/src/test/Makefile.am
   trunk/OpenFDM/src/test/harmonic.cpp
   trunk/OpenFDM/src/test/quattest.cpp
Log:
Add limits test. Adjust tolerance for euler angles.


Modified: trunk/OpenFDM/src/test/Makefile.am
===================================================================
--- trunk/OpenFDM/src/test/Makefile.am	2008-03-08 11:25:14 UTC (rev 372)
+++ trunk/OpenFDM/src/test/Makefile.am	2008-03-08 11:31:18 UTC (rev 373)
@@ -1,7 +1,7 @@
 INCLUDES = -I$(srcdir)/..
 
 # define some unit tests
-check_PROGRAMS = quattest unitstest simulationtime constintegral harmonic
+check_PROGRAMS = quattest unitstest simulationtime constintegral harmonic limit
 TESTS          = $(check_PROGRAMS)
 
 unitstest_SOURCES = unitstest.cpp
@@ -18,3 +18,6 @@
 
 harmonic_SOURCES = harmonic.cpp
 harmonic_LDADD = ../OpenFDM/libOpenFDM.la
+
+limit_SOURCES = limit.cpp
+limit_LDADD = ../OpenFDM/libOpenFDM.la

Modified: trunk/OpenFDM/src/test/harmonic.cpp
===================================================================
--- trunk/OpenFDM/src/test/harmonic.cpp	2008-03-08 11:25:14 UTC (rev 372)
+++ trunk/OpenFDM/src/test/harmonic.cpp	2008-03-08 11:31:18 UTC (rev 373)
@@ -19,10 +19,10 @@
 int
 main(int argc, char *argv[])
 {
-  real_type omega = 2;
+  real_type omega = 20;
 
   SharedPtr<System> system = new System("Harmonic Oszilator");
-  system->addSampleTime(real_type(1)/real_type(100));
+  system->addSampleTime(real_type(1)/real_type(100000));
   system->setTimestepper(new DoPri5);
   
   Integrator* integrator0 = new Integrator("Acceleration Integrator");
@@ -120,19 +120,19 @@
   system->simulate(10);
 
   real_type posError = posErrorCallback->error();
+  std::cout << "Position error check with error = " << posError << std::endl;
+  real_type velError = velErrorCallback->error();
+  std::cout << "Velocity error check with error = " << velError << std::endl;
   if (1e-6 < posError) {
-    std::cerr << "Position error of " << posError << " is too big" << std::endl;
+    std::cerr << "Position error of is too big!" << std::endl;
     return EXIT_FAILURE;
   }
-  std::cout << "Passed position error check with error = "
-            << posError << std::endl;
-  real_type velError = velErrorCallback->error();
+  std::cout << "Passed position error check." << std::endl;
   if (1e-6 < velError) {
-    std::cerr << "Velocity error of " << velError << " is too big" << std::endl;
+    std::cerr << "Velocity error of is too big!" << std::endl;
     return EXIT_FAILURE;
   }
-  std::cout << "Passed velocity error check with error = "
-            << velError << std::endl;
+  std::cout << "Passed velocity error check." << std::endl;
 
   return EXIT_SUCCESS;
 }

Added: trunk/OpenFDM/src/test/limit.cpp
===================================================================
--- trunk/OpenFDM/src/test/limit.cpp	2008-03-08 11:25:14 UTC (rev 372)
+++ trunk/OpenFDM/src/test/limit.cpp	2008-03-08 11:31:18 UTC (rev 373)
@@ -0,0 +1,115 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2008 Mathias Froehlich 
+ *
+ */
+
+#include <iostream>
+#include <fstream>
+#include <OpenFDM/Types.h>
+#include <OpenFDM/Limits.h>
+
+using namespace OpenFDM;
+
+static real_type estimateEps()
+{
+  // Ok, totally useless outputs, but makes sure that the floating point
+  // registers get dumped out into memory. This actually works around that
+  // totally boring i387 fpu ...
+  std::ofstream dummy("/dev/null");
+
+  real_type eps = 1;
+  dummy << "Compute Epsilon" << std::endl;
+  while (1 + eps != 1) {
+    eps /= 2;
+    dummy << eps << ", ";
+  }
+  eps *= 2;
+  return eps;
+}
+
+static real_type estimateMin(const real_type& eps)
+{
+  // Ok, totally useless outputs, but makes sure that the floating point
+  // registers get dumped out into memory. This actually works around that
+  // totally boring i387 fpu ...
+  std::ofstream dummy("/dev/null");
+
+  real_type minTry = eps;
+  real_type min = eps;
+  while (minTry != 0) {
+    min = minTry;
+    minTry = ldexp(minTry, -128*128);
+    dummy << minTry << ", ";
+  }
+  minTry = min;
+  while (minTry != 0) {
+    min = minTry;
+    minTry = ldexp(minTry, -128);
+    dummy << minTry << ", ";
+  }
+  minTry = min;
+  while (minTry != 0) {
+    min = minTry;
+    minTry /= 2;
+    dummy << minTry << ", ";
+  }
+  return min;
+}
+
+static real_type estimateMax(const real_type& eps)
+{
+  // Ok, totally useless outputs, but makes sure that the floating point
+  // registers get dumped out into memory. This actually works around that
+  // totally boring i387 fpu ...
+  std::ofstream dummy("/dev/null");
+
+  real_type maxTry = 1 - eps;
+  real_type max = 1 - eps;
+  while (isfinite(maxTry)) {
+    max = maxTry;
+    maxTry = ldexp(maxTry, 128*128);
+    dummy << maxTry << ", ";
+  }
+  maxTry = max;
+  while (isfinite(maxTry)) {
+    max = maxTry;
+    maxTry = ldexp(maxTry, 128);
+    dummy << maxTry << ", ";
+  }
+  maxTry = max;
+  while (isfinite(maxTry)) {
+    max = maxTry;
+    maxTry *= 2;
+    dummy << maxTry << ", ";
+  }
+  return max;
+}
+
+int
+main(int argc, char *argv[])
+{
+  real_type eps = estimateEps();
+  std::cout << "Computed Eps = " << eps << std::endl;
+  real_type min = estimateMin(eps);
+  std::cout << "Computed Min = " << min << std::endl;
+  real_type max = estimateMax(eps);
+  std::cout << "Computed Max = " << max << std::endl;
+
+  std::cout << "Epsilon = " << Limits<real_type>::epsilon() << std::endl;
+  std::cout << "Min = " << Limits<real_type>::min() << std::endl;
+  std::cout << "Safe Min = " << Limits<real_type>::safe_min() << std::endl;
+  std::cout << "Max = " << Limits<real_type>::max() << std::endl;
+  std::cout << "Round Error = " << Limits<real_type>::round_error() << std::endl;
+  std::cout << "Infinity = " << Limits<real_type>::infinity() << std::endl;
+  std::cout << "Quiet NaN = " << Limits<real_type>::quiet_NaN() << std::endl;
+  std::cout << "Signaling NaN = " << Limits<real_type>::signaling_NaN() << std::endl;
+  std::cout << "Denormlized Min = " << Limits<real_type>::denorm_min() << std::endl;
+
+  if (eps != Limits<real_type>::epsilon())
+    return EXIT_FAILURE;
+  if (min != Limits<real_type>::min())
+    return EXIT_FAILURE;
+  if (max != Limits<real_type>::max())
+    return EXIT_FAILURE;
+
+  return EXIT_SUCCESS;
+}

Modified: trunk/OpenFDM/src/test/quattest.cpp
===================================================================
--- trunk/OpenFDM/src/test/quattest.cpp	2008-03-08 11:25:14 UTC (rev 372)
+++ trunk/OpenFDM/src/test/quattest.cpp	2008-03-08 11:31:18 UTC (rev 373)
@@ -123,21 +123,23 @@
   // Test euler angle to quaternion and back conversion.
   // special fixed cases
   int fail = 0;
-  fail += eulerTest(Quaternion::fromEuler(0, 0, 0), 100*eps);
-  fail += eulerTest(Quaternion::fromEuler(pi05, 0, 0), 100*eps);
-  fail += eulerTest(Quaternion::fromEuler(pi05, 0, pi05), 100*eps);
-  fail += eulerTest(Quaternion::fromEuler(0, 0, pi05), 100*eps);
+  // Ok, since this conversion has an instability, check with a special eps
+  real_type eulerEps = max(real_type(1e-10), 100*eps);
+  fail += eulerTest(Quaternion::fromEuler(0, 0, 0), eulerEps);
+  fail += eulerTest(Quaternion::fromEuler(pi05, 0, 0), eulerEps);
+  fail += eulerTest(Quaternion::fromEuler(pi05, 0, pi05), eulerEps);
+  fail += eulerTest(Quaternion::fromEuler(0, 0, pi05), eulerEps);
   // special fixed cases at the gimbal lock
-  fail += eulerTest(Quaternion::fromEuler(0, pi05, 0), 100*eps);
-  fail += eulerTest(Quaternion::fromEuler(pi05, pi05, 0), 100*eps);
-  fail += eulerTest(Quaternion::fromEuler(pi05, pi05, pi05), 100*eps);
-  fail += eulerTest(Quaternion::fromEuler(0, pi05, pi05), 100*eps);
-  fail += eulerTest(Quaternion::fromEuler(0, -pi05, 0), 100*eps);
-  fail += eulerTest(Quaternion::fromEuler(pi05, -pi05, 0), 100*eps);
-  fail += eulerTest(Quaternion::fromEuler(pi05, -pi05, pi05), 100*eps);
-  fail += eulerTest(Quaternion::fromEuler(0, -pi05, pi05), 100*eps);
+  fail += eulerTest(Quaternion::fromEuler(0, pi05, 0), eulerEps);
+  fail += eulerTest(Quaternion::fromEuler(pi05, pi05, 0), eulerEps);
+  fail += eulerTest(Quaternion::fromEuler(pi05, pi05, pi05), eulerEps);
+  fail += eulerTest(Quaternion::fromEuler(0, pi05, pi05), eulerEps);
+  fail += eulerTest(Quaternion::fromEuler(0, -pi05, 0), eulerEps);
+  fail += eulerTest(Quaternion::fromEuler(pi05, -pi05, 0), eulerEps);
+  fail += eulerTest(Quaternion::fromEuler(pi05, -pi05, pi05), eulerEps);
+  fail += eulerTest(Quaternion::fromEuler(0, -pi05, pi05), eulerEps);
 
-  real_type gimbalEps = 1e3*eps;
+  real_type gimbalEps = 1e3*eulerEps;
   // special cases around the gimbal lock
   for (unsigned i = 0; i < nTests; ++i) {
     for (unsigned k = 1; k < 1024; k *= 2) {
@@ -163,7 +165,7 @@
   }
   // arbitrary cases
   for (unsigned i = 0; i < nTests; ++i)
-    fail += eulerTest(rnQuat(), 100*eps);
+    fail += eulerTest(rnQuat(), eulerEps);
 
   if (fail)
     return -1;



From frohlich at mail.berlios.de  Sat Mar  8 12:32:49 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 8 Mar 2008 12:32:49 +0100
Subject: [OpenFDM-svn] r374 - trunk/OpenFDM/src/test
Message-ID: <200803081132.m28BWn8w027091@sheep.berlios.de>

Author: frohlich
Date: 2008-03-08 12:32:49 +0100 (Sat, 08 Mar 2008)
New Revision: 374

Modified:
   trunk/OpenFDM/src/test/harmonic.cpp
Log:
Oops, revert too small sample time for the test system.


Modified: trunk/OpenFDM/src/test/harmonic.cpp
===================================================================
--- trunk/OpenFDM/src/test/harmonic.cpp	2008-03-08 11:31:18 UTC (rev 373)
+++ trunk/OpenFDM/src/test/harmonic.cpp	2008-03-08 11:32:49 UTC (rev 374)
@@ -22,7 +22,7 @@
   real_type omega = 20;
 
   SharedPtr<System> system = new System("Harmonic Oszilator");
-  system->addSampleTime(real_type(1)/real_type(100000));
+  system->addSampleTime(real_type(1)/real_type(100));
   system->setTimestepper(new DoPri5);
   
   Integrator* integrator0 = new Integrator("Acceleration Integrator");



From frohlich at mail.berlios.de  Sat Mar  8 15:01:24 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 8 Mar 2008 15:01:24 +0100
Subject: [OpenFDM-svn] r376 - trunk/OpenFDM/src/OpenFDM
Message-ID: <200803081401.m28E1ORF025658@sheep.berlios.de>

Author: frohlich
Date: 2008-03-08 15:01:15 +0100 (Sat, 08 Mar 2008)
New Revision: 376

Modified:
   trunk/OpenFDM/src/OpenFDM/Makefile.am
Log:
Include header file in install file list


Modified: trunk/OpenFDM/src/OpenFDM/Makefile.am
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Makefile.am	2008-03-08 13:59:33 UTC (rev 375)
+++ trunk/OpenFDM/src/OpenFDM/Makefile.am	2008-03-08 14:01:15 UTC (rev 376)
@@ -67,6 +67,7 @@
   Math.h \
   Matrix.h \
   MaxModel.h \
+  Newton.h \
   MidpointRule.h \
   MinModel.h \
   MobileRootJoint.h \
@@ -75,7 +76,7 @@
   ModelGroup.h \
   ModelVisitor.h \
   Mutex.h \
-  Newton.h \
+  MPFRFloat.h \
   NumericPortAcceptor.h \
   NumericPortProvider.h \
   NumericPortProxy.h \



From frohlich at mail.berlios.de  Sat Mar  8 14:59:34 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 8 Mar 2008 14:59:34 +0100
Subject: [OpenFDM-svn] r375 - in trunk/OpenFDM/src: OpenFDM test
Message-ID: <200803081359.m28DxYvA025212@sheep.berlios.de>

Author: frohlich
Date: 2008-03-08 14:59:33 +0100 (Sat, 08 Mar 2008)
New Revision: 375

Added:
   trunk/OpenFDM/src/OpenFDM/MPFRFloat.h
Modified:
   trunk/OpenFDM/src/OpenFDM/DoPri5.cpp
   trunk/OpenFDM/src/OpenFDM/ExplicitAdams.cpp
   trunk/OpenFDM/src/OpenFDM/Math.h
   trunk/OpenFDM/src/OpenFDM/Types.h
   trunk/OpenFDM/src/OpenFDM/Unit.cpp
   trunk/OpenFDM/src/test/harmonic.cpp
Log:
Add mpfr float type for testing purpose.


Modified: trunk/OpenFDM/src/OpenFDM/DoPri5.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/DoPri5.cpp	2008-03-08 11:32:49 UTC (rev 374)
+++ trunk/OpenFDM/src/OpenFDM/DoPri5.cpp	2008-03-08 13:59:33 UTC (rev 375)
@@ -58,7 +58,7 @@
     real_type rtol = 1e-14;
     real_type en = scaledErr(y7, err, atol, rtol);
 
-    if (1.0 < en)
+    if (1 < en)
       Log(TimeStep, Warning) << "DOPRI5: error too big: " << en << endl;
     else
       Log(TimeStep, Info) << "DOPRI5: local error: " << en << endl;
@@ -99,44 +99,44 @@
 }
 
 // The values of the Runge-Kutta tables
-const real_type DoPri5::a21 = 2.0/10.0;
-const real_type DoPri5::a31 = 3.0/40.0;
-const real_type DoPri5::a32 = 9.0/40.0;
-const real_type DoPri5::a41 = 44.0/45.0;
-const real_type DoPri5::a42 = -56.0/15.0;
-const real_type DoPri5::a43 = 32.0/9.0;
-const real_type DoPri5::a51 = 19372.0/6561.0;
-const real_type DoPri5::a52 = -25360.0/2187.0;
-const real_type DoPri5::a53 = 64448.0/6561.0;
-const real_type DoPri5::a54 = -212.0/729.0;
-const real_type DoPri5::a61 = 9017.0/3168.0;
-const real_type DoPri5::a62 = -355.0/33.0;
-const real_type DoPri5::a63 = 46732.0/5247.0;
-const real_type DoPri5::a64 = 49.0/176.0;
-const real_type DoPri5::a65 = -5103.0/18656.0;
-const real_type DoPri5::a71 = 35.0/384.0;
-const real_type DoPri5::a73 = 500.0/1113.0;
-const real_type DoPri5::a74 = 125.0/192.0;
-const real_type DoPri5::a75 = -2187.0/6784.0;
-const real_type DoPri5::a76 = 11.0/84.0;
+const real_type DoPri5::a21 = real_type(2.0)/real_type(10.0);
+const real_type DoPri5::a31 = real_type(3.0)/real_type(40.0);
+const real_type DoPri5::a32 = real_type(9.0)/real_type(40.0);
+const real_type DoPri5::a41 = real_type(44.0)/real_type(45.0);
+const real_type DoPri5::a42 = real_type(-56.0)/real_type(15.0);
+const real_type DoPri5::a43 = real_type(32.0)/real_type(9.0);
+const real_type DoPri5::a51 = real_type(19372.0)/real_type(6561.0);
+const real_type DoPri5::a52 = real_type(-25360.0)/real_type(2187.0);
+const real_type DoPri5::a53 = real_type(64448.0)/real_type(6561.0);
+const real_type DoPri5::a54 = real_type(-212.0)/real_type(729.0);
+const real_type DoPri5::a61 = real_type(9017.0)/real_type(3168.0);
+const real_type DoPri5::a62 = real_type(-355.0)/real_type(33.0);
+const real_type DoPri5::a63 = real_type(46732.0)/real_type(5247.0);
+const real_type DoPri5::a64 = real_type(49.0)/real_type(176.0);
+const real_type DoPri5::a65 = real_type(-5103.0)/real_type(18656.0);
+const real_type DoPri5::a71 = real_type(35.0)/real_type(384.0);
+const real_type DoPri5::a73 = real_type(500.0)/real_type(1113.0);
+const real_type DoPri5::a74 = real_type(125.0)/real_type(192.0);
+const real_type DoPri5::a75 = real_type(-2187.0)/real_type(6784.0);
+const real_type DoPri5::a76 = real_type(11.0)/real_type(84.0);
 
-const real_type DoPri5::c2 = 2.0/10.0;
-const real_type DoPri5::c3 = 3.0/10.0;
-const real_type DoPri5::c4 = 8.0/10.0;
-const real_type DoPri5::c5 = 8.0/9.0;
+const real_type DoPri5::c2 = real_type(2.0)/real_type(10.0);
+const real_type DoPri5::c3 = real_type(3.0)/real_type(10.0);
+const real_type DoPri5::c4 = real_type(8.0)/real_type(10.0);
+const real_type DoPri5::c5 = real_type(8.0)/real_type(9.0);
 
-const real_type DoPri5::d1 = -12715105075.0/11282082432.0;
-const real_type DoPri5::d3 = 87487479700.0/32700410799.0;
-const real_type DoPri5::d4 = -10690763975.0/1880347072.0;
-const real_type DoPri5::d5 = 701980252875.0/199316789632.0;
-const real_type DoPri5::d6 = -1453857185.0/822651844.0;
-const real_type DoPri5::d7 = 69997945.0/29380423.0;
+const real_type DoPri5::d1 = real_type(-12715105075.0)/real_type(11282082432.0);
+const real_type DoPri5::d3 = real_type(87487479700.0)/real_type(32700410799.0);
+const real_type DoPri5::d4 = real_type(-10690763975.0)/real_type(1880347072.0);
+const real_type DoPri5::d5 = real_type(701980252875.0)/real_type(199316789632.0);
+const real_type DoPri5::d6 = real_type(-1453857185.0)/real_type(822651844.0);
+const real_type DoPri5::d7 = real_type(69997945.0L)/real_type(29380423.0);
 
-const real_type DoPri5::e1 = 71.0/57600.0;
-const real_type DoPri5::e3 = -71.0/16695.0;
-const real_type DoPri5::e4 = 71.0/1920.0;
-const real_type DoPri5::e5 = -17253.0/339200.0;
-const real_type DoPri5::e6 = 22.0/525.0;
-const real_type DoPri5::e7 = -1.0/40.0;
+const real_type DoPri5::e1 = real_type(71.0)/real_type(57600.0);
+const real_type DoPri5::e3 = real_type(-71.0)/real_type(16695.0);
+const real_type DoPri5::e4 = real_type(71.0)/real_type(1920.0);
+const real_type DoPri5::e5 = real_type(-17253.0)/real_type(339200.0);
+const real_type DoPri5::e6 = real_type(22.0)/real_type(525.0);
+const real_type DoPri5::e7 = real_type(-1.0)/real_type(40.0);
 
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/ExplicitAdams.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/ExplicitAdams.cpp	2008-03-08 11:32:49 UTC (rev 374)
+++ trunk/OpenFDM/src/OpenFDM/ExplicitAdams.cpp	2008-03-08 13:59:33 UTC (rev 375)
@@ -12,19 +12,19 @@
 ExplicitAdams::ExplicitAdams(void)
 {
   // Initialize the coeficients for the explicit adams methods
-  mCoefs[0][0] =  static_cast<real_type>(1);
+  mCoefs[0][0] =  real_type(1);
 
-  mCoefs[1][0] =  static_cast<real_type>(3)/static_cast<real_type>(2);
-  mCoefs[1][1] = -static_cast<real_type>(1)/static_cast<real_type>(2);
+  mCoefs[1][0] =  real_type(3)/real_type(2);
+  mCoefs[1][1] = -real_type(1)/real_type(2);
 
-  mCoefs[2][0] =  static_cast<real_type>(23)/static_cast<real_type>(12);
-  mCoefs[2][1] = -static_cast<real_type>(16)/static_cast<real_type>(12);
-  mCoefs[2][2] =  static_cast<real_type>(5)/static_cast<real_type>(12);
+  mCoefs[2][0] =  real_type(23)/real_type(12);
+  mCoefs[2][1] = -real_type(16)/real_type(12);
+  mCoefs[2][2] =  real_type(5)/real_type(12);
 
-  mCoefs[3][0] =  static_cast<real_type>(55)/static_cast<real_type>(24);
-  mCoefs[3][1] = -static_cast<real_type>(59)/static_cast<real_type>(24);
-  mCoefs[3][2] =  static_cast<real_type>(37)/static_cast<real_type>(24);
-  mCoefs[3][3] = -static_cast<real_type>(9)/static_cast<real_type>(24);
+  mCoefs[3][0] =  real_type(55)/real_type(24);
+  mCoefs[3][1] = -real_type(59)/real_type(24);
+  mCoefs[3][2] =  real_type(37)/real_type(24);
+  mCoefs[3][3] = -real_type(9)/real_type(24);
 
   mOrder = 1;
   mMaxOrder = MaxAvailOrder;

Added: trunk/OpenFDM/src/OpenFDM/MPFRFloat.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/MPFRFloat.h	2008-03-08 11:32:49 UTC (rev 374)
+++ trunk/OpenFDM/src/OpenFDM/MPFRFloat.h	2008-03-08 13:59:33 UTC (rev 375)
@@ -0,0 +1,1152 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2007-2008 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_MPFloat_H
+#define OpenFDM_MPFloat_H
+
+#include <cstring>
+#include <iostream>
+#include <mpfr.h>
+
+namespace OpenFDM {
+
+/// Class for a floating point type that uses mpfr with an fixed but huge
+/// precision. This is just for doing test of the numeric included algorithms.
+/// Never use that for realtime simulations ...
+
+class MPFRFloat;
+
+#define _BINARY_OPERATOR_DECL(qualifier, ret, op)                           \
+qualifier ret                                                               \
+operator op(const MPFRFloat& value1, const MPFRFloat& value2);              \
+qualifier ret                                                               \
+operator op(const MPFRFloat& value1, const float& value2);                  \
+qualifier ret                                                               \
+operator op(const float& value1, const MPFRFloat& value2);                  \
+qualifier ret                                                               \
+operator op(const MPFRFloat& value1, const double& value2);                 \
+qualifier ret                                                               \
+operator op(const double& value1, const MPFRFloat& value2);                 \
+qualifier ret                                                               \
+operator op(const MPFRFloat& value1, const long double& value2);            \
+qualifier ret                                                               \
+operator op(const long double& value1, const MPFRFloat& value2);            \
+qualifier ret                                                               \
+operator op(const MPFRFloat& value1, const signed char& value2);            \
+qualifier ret                                                               \
+operator op(const MPFRFloat& value1, const signed short& value2);           \
+qualifier ret                                                               \
+operator op(const MPFRFloat& value1, const signed int& value2);             \
+qualifier ret                                                               \
+operator op(const MPFRFloat& value1, const signed long& value2);            \
+qualifier ret                                                               \
+operator op(const MPFRFloat& value1, const unsigned char& value2);          \
+qualifier ret                                                               \
+operator op(const MPFRFloat& value1, const unsigned short& value2);         \
+qualifier ret                                                               \
+operator op(const MPFRFloat& value1, const unsigned int& value2);           \
+qualifier ret                                                               \
+operator op(const MPFRFloat& value1, const unsigned long& value2);          \
+qualifier ret                                                               \
+operator op(const signed char& value1, const MPFRFloat& value2);            \
+qualifier ret                                                               \
+operator op(const signed short& value1, const MPFRFloat& value2);           \
+qualifier ret                                                               \
+operator op(const signed int& value1, const MPFRFloat& value2);             \
+qualifier ret                                                               \
+operator op(const signed long& value1, const MPFRFloat& value2);            \
+qualifier ret                                                               \
+operator op(const unsigned char& value1, const MPFRFloat& value2);          \
+qualifier ret                                                               \
+operator op(const unsigned short& value1, const MPFRFloat& value2);         \
+qualifier ret                                                               \
+operator op(const unsigned int& value1, const MPFRFloat& value2);           \
+qualifier ret                                                               \
+operator op(const unsigned long& value1, const MPFRFloat& value2);
+
+_BINARY_OPERATOR_DECL(inline,MPFRFloat,+)
+_BINARY_OPERATOR_DECL(inline,MPFRFloat,-)
+_BINARY_OPERATOR_DECL(inline,MPFRFloat,*)
+_BINARY_OPERATOR_DECL(inline,MPFRFloat,/)
+_BINARY_OPERATOR_DECL(inline,bool,==)
+_BINARY_OPERATOR_DECL(inline,bool,!=)
+_BINARY_OPERATOR_DECL(inline,bool,<)
+_BINARY_OPERATOR_DECL(inline,bool,<=)
+_BINARY_OPERATOR_DECL(inline,bool,>)
+_BINARY_OPERATOR_DECL(inline,bool,>=)
+
+#define _FUNCTIONS_DECL(qualifier)                                           \
+qualifier MPFRFloat abs(const MPFRFloat& value);                             \
+qualifier MPFRFloat acos(const MPFRFloat& value);                            \
+qualifier MPFRFloat asin(const MPFRFloat& value);                            \
+qualifier MPFRFloat atan(const MPFRFloat& value);                            \
+qualifier MPFRFloat atan2(const MPFRFloat& value1, const MPFRFloat& value2); \
+qualifier MPFRFloat ceil(const MPFRFloat& value);                            \
+qualifier MPFRFloat cos(const MPFRFloat& value);                             \
+qualifier MPFRFloat cosh(const MPFRFloat& value);                            \
+qualifier MPFRFloat exp(const MPFRFloat& value);                             \
+qualifier MPFRFloat fabs(const MPFRFloat& value);                            \
+qualifier MPFRFloat floor(const MPFRFloat& value);                           \
+qualifier MPFRFloat fmod(const MPFRFloat& value1, const MPFRFloat& value2);  \
+qualifier MPFRFloat frexp(const MPFRFloat& value1, int * value2);            \
+qualifier MPFRFloat ldexp(const MPFRFloat& value1, int value2);              \
+qualifier MPFRFloat log(const MPFRFloat& value);                             \
+qualifier MPFRFloat log10(const MPFRFloat& value);                           \
+qualifier MPFRFloat pow(const MPFRFloat& value1, const MPFRFloat& value2);   \
+qualifier MPFRFloat sin(const MPFRFloat& value);                             \
+qualifier MPFRFloat sinh(const MPFRFloat& value);                            \
+qualifier MPFRFloat sqrt(const MPFRFloat& value);                            \
+qualifier MPFRFloat tan(const MPFRFloat& value);                             \
+qualifier MPFRFloat tanh(const MPFRFloat& value);                            \
+qualifier int isfinite(const MPFRFloat& value);                              \
+qualifier MPFRFloat copysign(const MPFRFloat& value1, const MPFRFloat& value2);\
+template<typename char_t, typename traits_t>                                 \
+qualifier                                                                    \
+std::basic_ostream<char_t, traits_t>&                                        \
+operator<<(std::basic_ostream<char_t, traits_t>& os, const MPFRFloat& f);    \
+template<typename char_t, typename traits_t>                                 \
+qualifier                                                                    \
+std::basic_istream<char_t, traits_t>&                                        \
+operator>>(std::basic_istream<char_t, traits_t>& os, MPFRFloat& f);
+
+_FUNCTIONS_DECL(inline)
+
+class MPFRFloat {
+public:
+  MPFRFloat()
+  { mpfr_init2(_value, prec()); }
+  MPFRFloat(const MPFRFloat& value)
+  { mpfr_init2(_value, prec()); mpfr_set(_value, value._value, rm()); }
+  MPFRFloat(const float& d)
+  { mpfr_init2(_value, prec()); mpfr_set_d(_value, d, rm()); }
+  MPFRFloat(const double& d)
+  { mpfr_init2(_value, prec()); mpfr_set_d(_value, d, rm()); }
+  MPFRFloat(const long double& ld)
+  { mpfr_init2(_value, prec()); mpfr_set_ld(_value, ld, rm()); }
+  MPFRFloat(const bool& si)
+  { mpfr_init2(_value, prec()); mpfr_set_si(_value, si, rm()); }
+  MPFRFloat(const signed char& si)
+  { mpfr_init2(_value, prec()); mpfr_set_si(_value, si, rm()); }
+  MPFRFloat(const short& si)
+  { mpfr_init2(_value, prec()); mpfr_set_si(_value, si, rm()); }
+  MPFRFloat(const int& si)
+  { mpfr_init2(_value, prec()); mpfr_set_si(_value, si, rm()); }
+  MPFRFloat(const long& si)
+  { mpfr_init2(_value, prec()); mpfr_set_si(_value, si, rm()); }
+  MPFRFloat(const unsigned char& ui)
+  { mpfr_init2(_value, prec()); mpfr_set_ui(_value, ui, rm()); }
+  MPFRFloat(const unsigned short& ui)
+  { mpfr_init2(_value, prec()); mpfr_set_ui(_value, ui, rm()); }
+  MPFRFloat(const unsigned int& ui)
+  { mpfr_init2(_value, prec()); mpfr_set_ui(_value, ui, rm()); }
+  MPFRFloat(const unsigned long& ui)
+  { mpfr_init2(_value, prec()); mpfr_set_ui(_value, ui, rm()); }
+  explicit MPFRFloat(const char* str)
+  {
+    mpfr_init2(_value, prec());
+    mpfr_set_str(_value, str, std::strlen(str), rm());
+  }
+  explicit MPFRFloat(const std::string& str)
+  {
+    mpfr_init2(_value, prec());
+    mpfr_set_str(_value, str.c_str(), str.size(), rm());
+  }
+  ~MPFRFloat()
+  { mpfr_clear(_value); }
+
+  MPFRFloat& operator=(const MPFRFloat& value)
+  { mpfr_set(_value, value._value, rm()); return *this; }
+  MPFRFloat& operator=(const bool& si)
+  { mpfr_set_si(_value, si, rm()); return *this; }
+  MPFRFloat& operator=(const signed char& si)
+  { mpfr_set_si(_value, si, rm()); return *this; }
+  MPFRFloat& operator=(const short& si)
+  { mpfr_set_si(_value, si, rm()); return *this; }
+  MPFRFloat& operator=(const int& si)
+  { mpfr_set_si(_value, si, rm()); return *this; }
+  MPFRFloat& operator=(const long& si)
+  { mpfr_set_si(_value, si, rm()); return *this; }
+  MPFRFloat& operator=(const unsigned char& ui)
+  { mpfr_set_ui(_value, ui, rm()); return *this; }
+  MPFRFloat& operator=(const unsigned short& ui)
+  { mpfr_set_ui(_value, ui, rm()); return *this; }
+  MPFRFloat& operator=(const unsigned int& ui)
+  { mpfr_set_ui(_value, ui, rm()); return *this; }
+  MPFRFloat& operator=(const unsigned long& ui)
+  { mpfr_set_ui(_value, ui, rm()); return *this; }
+  MPFRFloat& operator=(const float& d)
+  { mpfr_set_d(_value, d, rm()); return *this; }
+  MPFRFloat& operator=(const double& d)
+  { mpfr_set_d(_value, d, rm()); return *this; }
+  MPFRFloat& operator=(const long double& ld)
+  { mpfr_set_ld(_value, ld, rm()); return *this; }
+  MPFRFloat& operator=(const char* str)
+  { mpfr_set_str(_value, str, std::strlen(str), rm()); return *this; }
+  MPFRFloat& operator=(const std::string& str)
+  { mpfr_set_str(_value, str.c_str(), str.size(), rm()); return *this; }
+
+  operator bool() const
+  { return mpfr_cmp_si(_value, 0); }
+  operator signed char() const
+  { return mpfr_get_si(_value, rm()); }
+  operator short() const
+  { return mpfr_get_si(_value, rm()); }
+  operator int() const
+  { return mpfr_get_si(_value, rm()); }
+  operator long() const
+  { return mpfr_get_si(_value, rm()); }
+  operator unsigned char() const
+  { return mpfr_get_ui(_value, rm()); }
+  operator unsigned short() const
+  { return mpfr_get_ui(_value, rm()); }
+  operator unsigned long() const
+  { return mpfr_get_ui(_value, rm()); }
+  operator unsigned int() const
+  { return mpfr_get_ui(_value, rm()); }
+  operator float() const
+  { return mpfr_get_d(_value, rm()); }
+  operator double() const
+  { return mpfr_get_d(_value, rm()); }
+  operator long double() const
+  { return mpfr_get_ld(_value, rm()); }
+
+#define _INPLACE_OPERATOR(op, mop)                                  \
+  MPFRFloat& operator op(const MPFRFloat& value)                    \
+  { mpfr_##mop(_value, _value, value._value, rm()); return *this; } \
+  MPFRFloat& operator op(const bool& value)                         \
+  { mpfr_##mop##_si(_value, _value, value, rm()); return *this; }   \
+  MPFRFloat& operator op(const signed char& value)                  \
+  { mpfr_##mop##_si(_value, _value, value, rm()); return *this; }   \
+  MPFRFloat& operator op(const signed short& value)                 \
+  { mpfr_##mop##_si(_value, _value, value, rm()); return *this; }   \
+  MPFRFloat& operator op(const int& value)                          \
+  { mpfr_##mop##_si(_value, _value, value, rm()); return *this; }   \
+  MPFRFloat& operator op(const long& value)                         \
+  { mpfr_##mop##_si(_value, _value, value, rm()); return *this; }   \
+  MPFRFloat& operator op(const unsigned char& value)                \
+  { mpfr_##mop##_ui(_value, _value, value, rm()); return *this; }   \
+  MPFRFloat& operator op(const unsigned short& value)               \
+  { mpfr_##mop##_ui(_value, _value, value, rm()); return *this; }   \
+  MPFRFloat& operator op(const unsigned int& value)                 \
+  { mpfr_##mop##_ui(_value, _value, value, rm()); return *this; }   \
+  MPFRFloat& operator op(const unsigned long& value)                \
+  { mpfr_##mop##_ui(_value, _value, value, rm()); return *this; }   \
+  MPFRFloat& operator op(const float& value)                        \
+  { return operator op(MPFRFloat(value)); }                         \
+  MPFRFloat& operator op(const double& value)                       \
+  { return operator op(MPFRFloat(value)); }                         \
+  MPFRFloat& operator op(const long double& value)                  \
+  { return operator op(MPFRFloat(value)); }
+
+  _INPLACE_OPERATOR(+=, add)
+  _INPLACE_OPERATOR(-=, sub)
+  _INPLACE_OPERATOR(*=, mul)
+  _INPLACE_OPERATOR(/=, div)
+#undef _INPLACE_OPERATOR
+
+  MPFRFloat operator-() const
+  {
+    mpfr_t tmp;
+    mpfr_init2(tmp, prec());
+    mpfr_neg(tmp, _value, rm());
+    return MPFRFloat(tmp);
+  }
+
+  static mpfr_rnd_t rm() { return GMP_RNDN; }
+  static mpfr_prec_t prec() { return 128; }
+
+  static MPFRFloat pi()
+  {
+    mpfr_t tmp;
+    mpfr_init2(tmp, MPFRFloat::prec());
+    mpfr_const_pi(tmp, rm());
+    return MPFRFloat(tmp);
+  }
+  static MPFRFloat euler()
+  {
+    mpfr_t tmp;
+    mpfr_init2(tmp, MPFRFloat::prec());
+    mpfr_const_euler(tmp, rm());
+    return MPFRFloat(tmp);
+  }
+  static MPFRFloat infinity()
+  {
+    mpfr_t tmp;
+    mpfr_init2(tmp, MPFRFloat::prec());
+    mpfr_set_inf(tmp, 1);
+    return MPFRFloat(tmp);
+  }
+  static MPFRFloat NaN()
+  {
+    mpfr_t tmp;
+    mpfr_init2(tmp, MPFRFloat::prec());
+    mpfr_set_nan(tmp);
+    return MPFRFloat(tmp);
+  }
+
+private:
+  _BINARY_OPERATOR_DECL(friend,MPFRFloat,+)
+  _BINARY_OPERATOR_DECL(friend,MPFRFloat,-)
+  _BINARY_OPERATOR_DECL(friend,MPFRFloat,*)
+  _BINARY_OPERATOR_DECL(friend,MPFRFloat,/)
+  _BINARY_OPERATOR_DECL(friend,bool,==)
+  _BINARY_OPERATOR_DECL(friend,bool,!=)
+  _BINARY_OPERATOR_DECL(friend,bool,<)
+  _BINARY_OPERATOR_DECL(friend,bool,<=)
+  _BINARY_OPERATOR_DECL(friend,bool,>)
+  _BINARY_OPERATOR_DECL(friend,bool,>=)
+  _FUNCTIONS_DECL(friend)
+
+  MPFRFloat(const mpfr_t value) { _value[0] = value[0]; }
+  mpfr_t _value;
+};
+
+#undef _BINARY_OPERATOR_DECL
+#undef _FUNCTIONS_DECL
+
+#define _BINARY_OPERATOR_FPFP(op, mop)                                      \
+inline MPFRFloat                                                            \
+operator op(const MPFRFloat& value1, const MPFRFloat& value2)               \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init2(tmp, MPFRFloat::prec());                                       \
+  mpfr_##mop(tmp, value1._value, value2._value, MPFRFloat::rm());           \
+  return MPFRFloat(tmp);                                                    \
+}                                                                           \
+inline MPFRFloat                                                            \
+operator op(const MPFRFloat& value1, const float& value2)                   \
+{                                                                           \
+  mpfr_t tmp1;                                                              \
+  mpfr_init_set_d(tmp1, value2, MPFRFloat::rm());                           \
+  mpfr_t tmp2;                                                              \
+  mpfr_init2(tmp2, MPFRFloat::prec());                                      \
+  mpfr_##mop(tmp2, value1._value, tmp1, MPFRFloat::rm());                   \
+  mpfr_clear(tmp1);                                                         \
+  return MPFRFloat(tmp2);                                                   \
+}                                                                           \
+inline MPFRFloat                                                            \
+operator op(const float& value1, const MPFRFloat& value2)                   \
+{                                                                           \
+  mpfr_t tmp1;                                                              \
+  mpfr_init_set_d(tmp1, value1, MPFRFloat::rm());                           \
+  mpfr_t tmp2;                                                              \
+  mpfr_init2(tmp2, MPFRFloat::prec());                                      \
+  mpfr_##mop(tmp2, tmp1, value2._value, MPFRFloat::rm());                   \
+  mpfr_clear(tmp1);                                                         \
+  return MPFRFloat(tmp2);                                                   \
+}                                                                           \
+inline MPFRFloat                                                            \
+operator op(const MPFRFloat& value1, const double& value2)                  \
+{                                                                           \
+  mpfr_t tmp1;                                                              \
+  mpfr_init_set_d(tmp1, value2, MPFRFloat::rm());                           \
+  mpfr_t tmp2;                                                              \
+  mpfr_init2(tmp2, MPFRFloat::prec());                                      \
+  mpfr_##mop(tmp2, value1._value, tmp1, MPFRFloat::rm());                   \
+  mpfr_clear(tmp1);                                                         \
+  return MPFRFloat(tmp2);                                                   \
+}                                                                           \
+inline MPFRFloat                                                            \
+operator op(const double& value1, const MPFRFloat& value2)                  \
+{                                                                           \
+  mpfr_t tmp1;                                                              \
+  mpfr_init_set_d(tmp1, value1, MPFRFloat::rm());                           \
+  mpfr_t tmp2;                                                              \
+  mpfr_init2(tmp2, MPFRFloat::prec());                                      \
+  mpfr_##mop(tmp2, tmp1, value2._value, MPFRFloat::rm());                   \
+  mpfr_clear(tmp1);                                                         \
+  return MPFRFloat(tmp2);                                                   \
+}                                                                           \
+inline MPFRFloat                                                            \
+operator op(const MPFRFloat& value1, const long double& value2)             \
+{                                                                           \
+  mpfr_t tmp1;                                                              \
+  mpfr_init_set_ld(tmp1, value2, MPFRFloat::rm());                          \
+  mpfr_t tmp2;                                                              \
+  mpfr_init2(tmp2, MPFRFloat::prec());                                      \
+  mpfr_##mop(tmp2, value1._value, tmp1, MPFRFloat::rm());                   \
+  mpfr_clear(tmp1);                                                         \
+  return MPFRFloat(tmp2);                                                   \
+}                                                                           \
+inline MPFRFloat                                                            \
+operator op(const long double& value1, const MPFRFloat& value2)             \
+{                                                                           \
+  mpfr_t tmp1;                                                              \
+  mpfr_init_set_ld(tmp1, value1, MPFRFloat::rm());                          \
+  mpfr_t tmp2;                                                              \
+  mpfr_init2(tmp2, MPFRFloat::prec());                                      \
+  mpfr_##mop(tmp2, tmp1, value2._value, MPFRFloat::rm());                   \
+  mpfr_clear(tmp1);                                                         \
+  return MPFRFloat(tmp2);                                                   \
+}
+
+
+#define _BINARY_OPERATOR_FPI(op, mop)                                       \
+inline MPFRFloat                                                            \
+operator op(const MPFRFloat& value1, const signed char& value2)             \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init2(tmp, MPFRFloat::prec());                                       \
+  mpfr_##mop##_si(tmp, value1._value, value2, MPFRFloat::rm());             \
+  return MPFRFloat(tmp);                                                    \
+}                                                                           \
+inline MPFRFloat                                                            \
+operator op(const MPFRFloat& value1, const signed short& value2)            \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init2(tmp, MPFRFloat::prec());                                       \
+  mpfr_##mop##_si(tmp, value1._value, value2, MPFRFloat::rm());             \
+  return MPFRFloat(tmp);                                                    \
+}                                                                           \
+inline MPFRFloat                                                            \
+operator op(const MPFRFloat& value1, const signed int& value2)              \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init2(tmp, MPFRFloat::prec());                                       \
+  mpfr_##mop##_si(tmp, value1._value, value2, MPFRFloat::rm());             \
+  return MPFRFloat(tmp);                                                    \
+}                                                                           \
+inline MPFRFloat                                                            \
+operator op(const MPFRFloat& value1, const signed long& value2)             \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init2(tmp, MPFRFloat::prec());                                       \
+  mpfr_##mop##_si(tmp, value1._value, value2, MPFRFloat::rm());             \
+  return MPFRFloat(tmp);                                                    \
+}                                                                           \
+inline MPFRFloat                                                            \
+operator op(const MPFRFloat& value1, const unsigned char& value2)           \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init2(tmp, MPFRFloat::prec());                                       \
+  mpfr_##mop##_ui(tmp, value1._value, value2, MPFRFloat::rm());             \
+  return MPFRFloat(tmp);                                                    \
+}                                                                           \
+inline MPFRFloat                                                            \
+operator op(const MPFRFloat& value1, const unsigned short& value2)          \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init2(tmp, MPFRFloat::prec());                                       \
+  mpfr_##mop##_ui(tmp, value1._value, value2, MPFRFloat::rm());             \
+  return MPFRFloat(tmp);                                                    \
+}                                                                           \
+inline MPFRFloat                                                            \
+operator op(const MPFRFloat& value1, const unsigned int& value2)            \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init2(tmp, MPFRFloat::prec());                                       \
+  mpfr_##mop##_ui(tmp, value1._value, value2, MPFRFloat::rm());             \
+  return MPFRFloat(tmp);                                                    \
+}                                                                           \
+inline MPFRFloat                                                            \
+operator op(const MPFRFloat& value1, const unsigned long& value2)           \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init2(tmp, MPFRFloat::prec());                                       \
+  mpfr_##mop##_ui(tmp, value1._value, value2, MPFRFloat::rm());             \
+  return MPFRFloat(tmp);                                                    \
+}
+
+
+#define _SYM_BINARY_OPERATOR_IFP(op, mop)                                   \
+inline MPFRFloat                                                            \
+operator op(const signed char& value1, const MPFRFloat& value2)             \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init2(tmp, MPFRFloat::prec());                                       \
+  mpfr_##mop##_si(tmp, value2._value, value1, MPFRFloat::rm());             \
+  return MPFRFloat(tmp);                                                    \
+}                                                                           \
+inline MPFRFloat                                                            \
+operator op(const signed short& value1, const MPFRFloat& value2)            \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init2(tmp, MPFRFloat::prec());                                       \
+  mpfr_##mop##_si(tmp, value2._value, value1, MPFRFloat::rm());             \
+  return MPFRFloat(tmp);                                                    \
+}                                                                           \
+inline MPFRFloat                                                            \
+operator op(const signed int& value1, const MPFRFloat& value2)              \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init2(tmp, MPFRFloat::prec());                                       \
+  mpfr_##mop##_si(tmp, value2._value, value1, MPFRFloat::rm());             \
+  return MPFRFloat(tmp);                                                    \
+}                                                                           \
+inline MPFRFloat                                                            \
+operator op(const signed long& value1, const MPFRFloat& value2)             \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init2(tmp, MPFRFloat::prec());                                       \
+  mpfr_##mop##_si(tmp, value2._value, value1, MPFRFloat::rm());             \
+  return MPFRFloat(tmp);                                                    \
+}                                                                           \
+inline MPFRFloat                                                            \
+operator op(const unsigned char& value1, const MPFRFloat& value2)           \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init2(tmp, MPFRFloat::prec());                                       \
+  mpfr_##mop##_ui(tmp, value2._value, value1, MPFRFloat::rm());             \
+  return MPFRFloat(tmp);                                                    \
+}                                                                           \
+inline MPFRFloat                                                            \
+operator op(const unsigned short& value1, const MPFRFloat& value2)          \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init2(tmp, MPFRFloat::prec());                                       \
+  mpfr_##mop##_ui(tmp, value2._value, value1, MPFRFloat::rm());             \
+  return MPFRFloat(tmp);                                                    \
+}                                                                           \
+inline MPFRFloat                                                            \
+operator op(const unsigned int& value1, const MPFRFloat& value2)            \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init2(tmp, MPFRFloat::prec());                                       \
+  mpfr_##mop##_ui(tmp, value2._value, value1, MPFRFloat::rm());             \
+  return MPFRFloat(tmp);                                                    \
+}                                                                           \
+inline MPFRFloat                                                            \
+operator op(const unsigned long& value1, const MPFRFloat& value2)           \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init2(tmp, MPFRFloat::prec());                                       \
+  mpfr_##mop##_ui(tmp, value2._value, value1, MPFRFloat::rm());             \
+  return MPFRFloat(tmp);                                                    \
+}
+
+
+#define _UNSYM_BINARY_OPERATOR_IFP(op, mop)                                 \
+inline MPFRFloat                                                            \
+operator op(const signed char& value1, const MPFRFloat& value2)             \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init2(tmp, MPFRFloat::prec());                                       \
+  mpfr_si_##mop(tmp, value1, value2._value, MPFRFloat::rm());               \
+  return MPFRFloat(tmp);                                                    \
+}                                                                           \
+inline MPFRFloat                                                            \
+operator op(const signed short& value1, const MPFRFloat& value2)            \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init2(tmp, MPFRFloat::prec());                                       \
+  mpfr_si_##mop(tmp, value1, value2._value, MPFRFloat::rm());               \
+  return MPFRFloat(tmp);                                                    \
+}                                                                           \
+inline MPFRFloat                                                            \
+operator op(const signed int& value1, const MPFRFloat& value2)              \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init2(tmp, MPFRFloat::prec());                                       \
+  mpfr_si_##mop(tmp, value1, value2._value, MPFRFloat::rm());               \
+  return MPFRFloat(tmp);                                                    \
+}                                                                           \
+inline MPFRFloat                                                            \
+operator op(const signed long& value1, const MPFRFloat& value2)             \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init2(tmp, MPFRFloat::prec());                                       \
+  mpfr_si_##mop(tmp, value1, value2._value, MPFRFloat::rm());               \
+  return MPFRFloat(tmp);                                                    \
+}                                                                           \
+inline MPFRFloat                                                            \
+operator op(const unsigned char& value1, const MPFRFloat& value2)           \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init2(tmp, MPFRFloat::prec());                                       \
+  mpfr_ui_##mop(tmp, value1, value2._value, MPFRFloat::rm());               \
+  return MPFRFloat(tmp);                                                    \
+}                                                                           \
+inline MPFRFloat                                                            \
+operator op(const unsigned short& value1, const MPFRFloat& value2)          \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init2(tmp, MPFRFloat::prec());                                       \
+  mpfr_ui_##mop(tmp, value1, value2._value, MPFRFloat::rm());               \
+  return MPFRFloat(tmp);                                                    \
+}                                                                           \
+inline MPFRFloat                                                            \
+operator op(const unsigned int& value1, const MPFRFloat& value2)            \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init2(tmp, MPFRFloat::prec());                                       \
+  mpfr_ui_##mop(tmp, value1, value2._value, MPFRFloat::rm());               \
+  return MPFRFloat(tmp);                                                    \
+}                                                                           \
+inline MPFRFloat                                                            \
+operator op(const unsigned long& value1, const MPFRFloat& value2)           \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init2(tmp, MPFRFloat::prec());                                       \
+  mpfr_ui_##mop(tmp, value1, value2._value, MPFRFloat::rm());               \
+  return MPFRFloat(tmp);                                                    \
+}
+
+#define _SYM_BINARY_OPERATOR(op, mop) \
+_BINARY_OPERATOR_FPFP(op, mop) \
+_BINARY_OPERATOR_FPI(op, mop) \
+_SYM_BINARY_OPERATOR_IFP(op, mop)
+
+#define _UNSYM_BINARY_OPERATOR(op, mop) \
+_BINARY_OPERATOR_FPFP(op, mop) \
+_BINARY_OPERATOR_FPI(op, mop) \
+_UNSYM_BINARY_OPERATOR_IFP(op, mop)
+
+// now implement ...
+_SYM_BINARY_OPERATOR(+, add)
+_SYM_BINARY_OPERATOR(*, mul)
+_UNSYM_BINARY_OPERATOR(-, sub)
+_UNSYM_BINARY_OPERATOR(/, div)
+
+#undef _BINARY_OPERATOR_FPFP
+#undef _BINARY_OPERATOR_FPI
+#undef _SYM_BINARY_OPERATOR_IFP
+#undef _UNSYM_BINARY_OPERATOR_IFP
+#undef _SYM_BINARY_OPERATOR
+#undef _UNSYM_BINARY_OPERATOR
+
+// Comparison
+#define _COMPARISON_OPERATOR(op, mop)                                       \
+inline bool                                                                 \
+operator op(const MPFRFloat& value1, const MPFRFloat& value2)               \
+{                                                                           \
+  return mpfr_##mop##_p(value1._value, value2._value);                      \
+}                                                                           \
+inline bool                                                                 \
+operator op(const MPFRFloat& value1, const float& value2)                   \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init_set_d(tmp, value2, MPFRFloat::rm());                            \
+  int ret = mpfr_##mop##_p(value1._value, tmp);                             \
+  mpfr_clear(tmp);                                                          \
+  return ret;                                                               \
+}                                                                           \
+inline bool                                                                 \
+operator op(const float& value1, const MPFRFloat& value2)                   \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init_set_d(tmp, value1, MPFRFloat::rm());                            \
+  int ret = mpfr_##mop##_p(tmp, value2._value);                             \
+  mpfr_clear(tmp);                                                          \
+  return ret;                                                               \
+}                                                                           \
+inline bool                                                                 \
+operator op(const MPFRFloat& value1, const double& value2)                  \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init_set_d(tmp, value2, MPFRFloat::rm());                            \
+  int ret = mpfr_##mop##_p(value1._value, tmp);                             \
+  mpfr_clear(tmp);                                                          \
+  return ret;                                                               \
+}                                                                           \
+inline bool                                                                 \
+operator op(const double& value1, const MPFRFloat& value2)                  \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init_set_d(tmp, value1, MPFRFloat::rm());                            \
+  int ret = mpfr_##mop##_p(tmp, value2._value);                             \
+  mpfr_clear(tmp);                                                          \
+  return ret;                                                               \
+}                                                                           \
+inline bool                                                                 \
+operator op(const MPFRFloat& value1, const long double& value2)             \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init_set_ld(tmp, value2, MPFRFloat::rm());                           \
+  int ret = mpfr_##mop##_p(value1._value, tmp);                             \
+  mpfr_clear(tmp);                                                          \
+  return ret;                                                               \
+}                                                                           \
+inline bool                                                                 \
+operator op(const long double& value1, const MPFRFloat& value2)             \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init_set_ld(tmp, value1, MPFRFloat::rm());                           \
+  int ret = mpfr_##mop##_p(tmp, value2._value);                             \
+  mpfr_clear(tmp);                                                          \
+  return ret;                                                               \
+}                                                                           \
+inline bool                                                                 \
+operator op(const MPFRFloat& value1, const signed char& value2)             \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init_set_si(tmp, value2, MPFRFloat::rm());                           \
+  int ret = mpfr_##mop##_p(value1._value, tmp);                             \
+  mpfr_clear(tmp);                                                          \
+  return ret;                                                               \
+}                                                                           \
+inline bool                                                                 \
+operator op(const MPFRFloat& value1, const signed short& value2)            \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init_set_si(tmp, value2, MPFRFloat::rm());                           \
+  int ret = mpfr_##mop##_p(value1._value, tmp);                             \
+  mpfr_clear(tmp);                                                          \
+  return ret;                                                               \
+}                                                                           \
+inline bool                                                                 \
+operator op(const MPFRFloat& value1, const signed int& value2)              \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init_set_si(tmp, value2, MPFRFloat::rm());                           \
+  int ret = mpfr_##mop##_p(value1._value, tmp);                             \
+  mpfr_clear(tmp);                                                          \
+  return ret;                                                               \
+}                                                                           \
+inline bool                                                                 \
+operator op(const MPFRFloat& value1, const signed long& value2)             \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init_set_si(tmp, value2, MPFRFloat::rm());                           \
+  int ret = mpfr_##mop##_p(value1._value, tmp);                             \
+  mpfr_clear(tmp);                                                          \
+  return ret;                                                               \
+}                                                                           \
+inline bool                                                                 \
+operator op(const MPFRFloat& value1, const unsigned char& value2)           \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init_set_ui(tmp, value2, MPFRFloat::rm());                           \
+  int ret = mpfr_##mop##_p(value1._value, tmp);                             \
+  mpfr_clear(tmp);                                                          \
+  return ret;                                                               \
+}                                                                           \
+inline bool                                                                 \
+operator op(const MPFRFloat& value1, const unsigned short& value2)          \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init_set_ui(tmp, value2, MPFRFloat::rm());                           \
+  int ret = mpfr_##mop##_p(value1._value, tmp);                             \
+  mpfr_clear(tmp);                                                          \
+  return ret;                                                               \
+}                                                                           \
+inline bool                                                                 \
+operator op(const MPFRFloat& value1, const unsigned int& value2)            \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init_set_ui(tmp, value2, MPFRFloat::rm());                           \
+  int ret = mpfr_##mop##_p(value1._value, tmp);                             \
+  mpfr_clear(tmp);                                                          \
+  return ret;                                                               \
+}                                                                           \
+inline bool                                                                 \
+operator op(const MPFRFloat& value1, const unsigned long& value2)           \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init_set_ui(tmp, value2, MPFRFloat::rm());                           \
+  int ret = mpfr_##mop##_p(value1._value, tmp);                             \
+  mpfr_clear(tmp);                                                          \
+  return ret;                                                               \
+}                                                                           \
+inline bool                                                                 \
+operator op(const signed char& value1, const MPFRFloat& value2)             \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init_set_si(tmp, value1, MPFRFloat::rm());                           \
+  int ret = mpfr_##mop##_p(tmp, value2._value);                             \
+  mpfr_clear(tmp);                                                          \
+  return ret;                                                               \
+}                                                                           \
+inline bool                                                                 \
+operator op(const signed short& value1, const MPFRFloat& value2)            \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init_set_si(tmp, value1, MPFRFloat::rm());                           \
+  int ret = mpfr_##mop##_p(tmp, value2._value);                             \
+  mpfr_clear(tmp);                                                          \
+  return ret;                                                               \
+}                                                                           \
+inline bool                                                                 \
+operator op(const signed int& value1, const MPFRFloat& value2)              \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init_set_si(tmp, value1, MPFRFloat::rm());                           \
+  int ret = mpfr_##mop##_p(tmp, value2._value);                             \
+  mpfr_clear(tmp);                                                          \
+  return ret;                                                               \
+}                                                                           \
+inline bool                                                                 \
+operator op(const signed long& value1, const MPFRFloat& value2)             \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init_set_si(tmp, value1, MPFRFloat::rm());                           \
+  int ret = mpfr_##mop##_p(tmp, value2._value);                             \
+  mpfr_clear(tmp);                                                          \
+  return ret;                                                               \
+}                                                                           \
+inline bool                                                                 \
+operator op(const unsigned char& value1, const MPFRFloat& value2)           \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init_set_ui(tmp, value1, MPFRFloat::rm());                           \
+  int ret = mpfr_##mop##_p(tmp, value2._value);                             \
+  mpfr_clear(tmp);                                                          \
+  return ret;                                                               \
+}                                                                           \
+inline bool                                                                 \
+operator op(const unsigned short& value1, const MPFRFloat& value2)          \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init_set_ui(tmp, value1, MPFRFloat::rm());                           \
+  int ret = mpfr_##mop##_p(tmp, value2._value);                             \
+  mpfr_clear(tmp);                                                          \
+  return ret;                                                               \
+}                                                                           \
+inline bool                                                                 \
+operator op(const unsigned int& value1, const MPFRFloat& value2)            \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init_set_ui(tmp, value1, MPFRFloat::rm());                           \
+  int ret = mpfr_##mop##_p(tmp, value2._value);                             \
+  mpfr_clear(tmp);                                                          \
+  return ret;                                                               \
+}                                                                           \
+inline bool                                                                 \
+operator op(const unsigned long& value1, const MPFRFloat& value2)           \
+{                                                                           \
+  mpfr_t tmp;                                                               \
+  mpfr_init_set_ui(tmp, value1, MPFRFloat::rm());                           \
+  int ret = mpfr_##mop##_p(tmp, value2._value);                             \
+  mpfr_clear(tmp);                                                          \
+  return ret;                                                               \
+}
+
+// now implement ...
+_COMPARISON_OPERATOR(==, equal)
+_COMPARISON_OPERATOR(!=, lessgreater)
+_COMPARISON_OPERATOR(<, less)
+_COMPARISON_OPERATOR(<=, lessequal)
+_COMPARISON_OPERATOR(>, greater)
+_COMPARISON_OPERATOR(>=, greaterequal)
+
+#undef _COMPARISON_OPERATOR
+
+inline
+MPFRFloat
+abs(const MPFRFloat& value)
+{
+  mpfr_t tmp;
+  mpfr_init2(tmp, MPFRFloat::prec());
+  mpfr_abs(tmp, value._value, MPFRFloat::rm());
+  return MPFRFloat(tmp);
+}
+
+inline
+MPFRFloat
+acos(const MPFRFloat& value)
+{
+  mpfr_t tmp;
+  mpfr_init2(tmp, MPFRFloat::prec());
+  mpfr_acos(tmp, value._value, MPFRFloat::rm());
+  return MPFRFloat(tmp);
+}
+
+inline
+MPFRFloat
+asin(const MPFRFloat& value)
+{
+  mpfr_t tmp;
+  mpfr_init2(tmp, MPFRFloat::prec());
+  mpfr_asin(tmp, value._value, MPFRFloat::rm());
+  return MPFRFloat(tmp);
+}
+
+inline
+MPFRFloat
+atan(const MPFRFloat& value)
+{
+  mpfr_t tmp;
+  mpfr_init2(tmp, MPFRFloat::prec());
+  mpfr_atan(tmp, value._value, MPFRFloat::rm());
+  return MPFRFloat(tmp);
+}
+
+inline
+MPFRFloat
+atan2(const MPFRFloat& value1, const MPFRFloat& value2)
+{
+  mpfr_t tmp;
+  mpfr_init2(tmp, MPFRFloat::prec());
+  mpfr_atan2(tmp, value1._value, value2._value, MPFRFloat::rm());
+  return MPFRFloat(tmp);
+}
+
+inline
+MPFRFloat
+ceil(const MPFRFloat& value)
+{
+  mpfr_t tmp;
+  mpfr_init2(tmp, MPFRFloat::prec());
+  mpfr_ceil(tmp, value._value);
+  return MPFRFloat(tmp);
+}
+
+inline
+MPFRFloat
+cos(const MPFRFloat& value)
+{
+  mpfr_t tmp;
+  mpfr_init2(tmp, MPFRFloat::prec());
+  mpfr_cos(tmp, value._value, MPFRFloat::rm());
+  return MPFRFloat(tmp);
+}
+
+inline
+MPFRFloat
+cosh(const MPFRFloat& value)
+{
+  mpfr_t tmp;
+  mpfr_init2(tmp, MPFRFloat::prec());
+  mpfr_cosh(tmp, value._value, MPFRFloat::rm());
+  return MPFRFloat(tmp);
+}
+
+inline
+MPFRFloat
+exp(const MPFRFloat& value)
+{
+  mpfr_t tmp;
+  mpfr_init2(tmp, MPFRFloat::prec());
+  mpfr_exp(tmp, value._value, MPFRFloat::rm());
+  return MPFRFloat(tmp);
+}
+
+inline
+MPFRFloat
+fabs(const MPFRFloat& value)
+{
+  mpfr_t tmp;
+  mpfr_init2(tmp, MPFRFloat::prec());
+  mpfr_abs(tmp, value._value, MPFRFloat::rm());
+  return MPFRFloat(tmp);
+}
+
+inline
+MPFRFloat
+floor(const MPFRFloat& value)
+{
+  mpfr_t tmp;
+  mpfr_init2(tmp, MPFRFloat::prec());
+  mpfr_floor(tmp, value._value);
+  return MPFRFloat(tmp);
+}
+
+inline
+MPFRFloat
+fmod(const MPFRFloat& value1, const MPFRFloat& value2)
+{
+  mpfr_t tmp;
+  mpfr_init2(tmp, MPFRFloat::prec());
+  mpfr_remainder(tmp, value1._value, value2._value, MPFRFloat::rm());
+  return MPFRFloat(tmp);
+}
+
+inline
+MPFRFloat
+frexp(const MPFRFloat& value1, int * value2)
+{
+  *value2 = mpfr_get_exp(value1._value);
+  mpfr_t tmp;
+  mpfr_init2(tmp, MPFRFloat::prec());
+  mpfr_set_exp(tmp, -*value2);
+  mpfr_mul(tmp, tmp, value1._value, MPFRFloat::rm());
+  return MPFRFloat(tmp);
+}
+
+inline
+MPFRFloat
+ldexp(const MPFRFloat& value1, int value2)
+{
+  mpfr_t tmp;
+  mpfr_init2(tmp, MPFRFloat::prec());
+  mpfr_set_si(tmp, 1, MPFRFloat::rm());
+  mpfr_set_exp(tmp, value2);
+  mpfr_mul(tmp, tmp, value1._value, MPFRFloat::rm());
+  return MPFRFloat(tmp);
+}
+
+inline
+MPFRFloat
+log(const MPFRFloat& value)
+{
+  mpfr_t tmp; mpfr_init2(tmp, MPFRFloat::prec());
+  mpfr_log(tmp, value._value, MPFRFloat::rm());
+  return MPFRFloat(tmp);
+}
+
+inline
+MPFRFloat
+log10(const MPFRFloat& value)
+{
+  mpfr_t tmp;
+  mpfr_init2(tmp, MPFRFloat::prec());
+  mpfr_log10(tmp, value._value, MPFRFloat::rm());
+  return MPFRFloat(tmp);
+}
+
+inline
+MPFRFloat
+pow(const MPFRFloat& value1, const MPFRFloat& value2)
+{
+  mpfr_t tmp;
+  mpfr_init2(tmp, MPFRFloat::prec());
+  mpfr_pow(tmp, value1._value, value2._value, MPFRFloat::rm());
+  return MPFRFloat(tmp);
+}
+
+inline
+MPFRFloat
+sin(const MPFRFloat& value)
+{
+  mpfr_t tmp;
+  mpfr_init2(tmp, MPFRFloat::prec());
+  mpfr_sin(tmp, value._value, MPFRFloat::rm());
+  return MPFRFloat(tmp);
+}
+
+inline
+MPFRFloat
+sinh(const MPFRFloat& value)
+{
+  mpfr_t tmp;
+  mpfr_init2(tmp, MPFRFloat::prec());
+  mpfr_sinh(tmp, value._value, MPFRFloat::rm());
+  return MPFRFloat(tmp);
+}
+
+inline
+MPFRFloat
+sqrt(const MPFRFloat& value)
+{
+  mpfr_t tmp;
+  mpfr_init2(tmp, MPFRFloat::prec());
+  mpfr_sqrt(tmp, value._value, MPFRFloat::rm());
+  return MPFRFloat(tmp);
+}
+
+inline
+MPFRFloat
+tan(const MPFRFloat& value)
+{
+  mpfr_t tmp;
+  mpfr_init2(tmp, MPFRFloat::prec());
+  mpfr_tan(tmp, value._value, MPFRFloat::rm());
+  return MPFRFloat(tmp);
+}
+
+inline
+MPFRFloat
+tanh(const MPFRFloat& value)
+{
+  mpfr_t tmp;
+  mpfr_init2(tmp, MPFRFloat::prec());
+  mpfr_tanh(tmp, value._value, MPFRFloat::rm());
+  return MPFRFloat(tmp);
+}
+
+// Not stdc++ functions but hopefully present ...
+inline
+int
+isfinite(const MPFRFloat& value)
+{
+  return mpfr_number_p(value._value);
+}
+
+inline
+MPFRFloat
+copysign(const MPFRFloat& value1, const MPFRFloat& value2)
+{
+  mpfr_t tmp;
+  mpfr_init2(tmp, MPFRFloat::prec());
+  mpfr_copysign(tmp, value1._value, value2._value, MPFRFloat::rm());
+  return MPFRFloat(tmp);
+}
+
+template<typename char_t, typename traits_t>
+inline
+std::basic_ostream<char_t, traits_t>&
+operator<<(std::basic_ostream<char_t, traits_t>& os, const MPFRFloat& f)
+{
+  int sign = copysign(f, MPFRFloat(1));
+  if (sign < 0)
+    os << os.widen('-');
+
+  if (mpfr_nan_p(f._value))
+    return os << os.widen('N') << os.widen('a') << os.widen('N');
+  if (mpfr_inf_p(f._value))
+    return os << os.widen('i') << os.widen('n') << os.widen('f');
+  if (mpfr_zero_p(f._value))
+    return os << os.widen('0');
+
+  std::streamsize prec = os.precision();
+
+  MPFRFloat tmp = abs(f);
+  mp_exp_t exponent;
+  char* s = mpfr_get_str(0, &exponent, 10 /*base*/,
+                         prec, tmp._value, MPFRFloat::rm());
+
+  if (0 < prec) {
+    os << os.widen(s[0]);
+    --prec;
+    os << os.widen('.');
+    for (unsigned i = 1; s[i] && 0 < prec; ++i) {
+      os << os.widen(s[i]);
+      --prec;
+    }
+    os << os.widen('e');
+    os << exponent-1;
+  }
+  mpfr_free_str(s);
+  return os;
+}
+
+template<typename char_t, typename traits_t>
+inline
+std::basic_istream<char_t, traits_t>&
+operator>>(std::basic_istream<char_t, traits_t>& os, MPFRFloat& f)
+{
+  // FIXME
+  long double tmp;
+  os >> tmp;
+  f = tmp;
+  return os;
+}
+
+template<typename T>
+struct Limits;
+
+template<>
+struct Limits<MPFRFloat> {
+  static MPFRFloat epsilon()
+  { return ldexp(MPFRFloat(1), 2 - MPFRFloat::prec()); }
+  static MPFRFloat min()
+  { return ldexp(MPFRFloat(1), mpfr_get_emin()); }
+  static MPFRFloat safe_min()
+  { return ldexp(MPFRFloat(1), MPFRFloat::prec() + mpfr_get_emin()); }
+  static MPFRFloat max()
+  { return ldexp(2*(MPFRFloat(1) - epsilon()), mpfr_get_emax()); }
+  static MPFRFloat round_error()
+  { return MPFRFloat::rm() == GMP_RNDN ? MPFRFloat(0.5) : MPFRFloat(1); }
+  static MPFRFloat infinity() 
+  { return MPFRFloat::infinity(); }
+  static MPFRFloat quiet_NaN()
+  { return MPFRFloat::NaN(); }
+  static MPFRFloat signaling_NaN()
+  { return MPFRFloat::NaN(); }
+  static MPFRFloat denorm_min()
+  { return min(); /*FIXME*/ }
+};
+
+
+template<typename T>
+struct Constants;
+
+template<>
+struct Constants<MPFRFloat> {
+  static MPFRFloat pi() { return MPFRFloat::pi(); }
+  static MPFRFloat e() { return MPFRFloat::pi(); }
+};
+
+} // namespace OpenFDM
+
+#endif

Modified: trunk/OpenFDM/src/OpenFDM/Math.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Math.h	2008-03-08 11:32:49 UTC (rev 374)
+++ trunk/OpenFDM/src/OpenFDM/Math.h	2008-03-08 13:59:33 UTC (rev 375)
@@ -53,6 +53,12 @@
 using std::max;
 
 template<typename T>
+struct Constants {
+  static T pi() { return T(3.1415926535897932384626433832795029L); }
+  static T e() { return T(2.7182818284590452353602874713526625L); }
+};
+
+template<typename T>
 inline int
 sign(const T& val)
 {
@@ -89,13 +95,10 @@
 inline T
 smoothSaturate(const T& val, const T& saturation)
 {
-  /// FIXME
-#define PI static_cast<T>(3.1415926535897932384626433832795029L)
   if (saturation <= Limits<T>::min())
     return 0;
   else
-    return atan(val*0.5*PI/saturation)*2*saturation/PI;
-#undef PI
+    return atan(val*Constants<T>::pi()/(2*saturation))*2*saturation/Constants<T>::pi();
 }
 
 template<typename T>

Modified: trunk/OpenFDM/src/OpenFDM/Types.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Types.h	2008-03-08 11:32:49 UTC (rev 374)
+++ trunk/OpenFDM/src/OpenFDM/Types.h	2008-03-08 13:59:33 UTC (rev 375)
@@ -5,6 +5,12 @@
 #ifndef OpenFDM_Types_H
 #define OpenFDM_Types_H
 
+#include "OpenFDMConfig.h"
+
+#if defined(OPENFDM_USE_MPFR)
+#include "MPFRFloat.h"
+#endif
+
 namespace OpenFDM {
 
 #if defined(__GNUC__) && (3 <= __GNUC__)
@@ -32,14 +38,12 @@
 // Definition of real_type.
 // This one is used for *all* real numbers in OpenFDM.
 //
-#if defined(OPENFDM_USE_LONGDOUBLE)
+#if defined(OPENFDM_USE_MPFR)
+typedef MPFRFloat real_type;
+#elif defined(OPENFDM_USE_LONGDOUBLE)
 typedef long double real_type;
-#elif defined(OPENFDM_USE_DOUBLEDOUBLE)
-// I have not tested that, just as an idea ...
-# include <doubledouble.h>
-typedef doubledouble real_type;
 #else
-typedef double OpenFDM_Align_Double real_type;
+typedef double real_type;
 #endif
 
 } // namespace OpenFDM

Modified: trunk/OpenFDM/src/OpenFDM/Unit.cpp
===================================================================
--- trunk/OpenFDM/src/OpenFDM/Unit.cpp	2008-03-08 11:32:49 UTC (rev 374)
+++ trunk/OpenFDM/src/OpenFDM/Unit.cpp	2008-03-08 13:59:33 UTC (rev 375)
@@ -10,21 +10,16 @@
 
 namespace OpenFDM {
 
-#ifdef PI
-#undef PI
-#endif
-#define PI static_cast<real_type>(3.1415926535897932384626433832795029L)
+const real_type pi2 = 2*Constants<real_type>::pi();
+const real_type pi = Constants<real_type>::pi();
+const real_type pi05 = Constants<real_type>::pi()/real_type(2);
+const real_type pi025 = Constants<real_type>::pi()/real_type(4);
 
-const real_type pi2 = 2*PI;
-const real_type pi = PI;
-const real_type pi05 = static_cast<real_type>(0.5L)*PI;
-const real_type pi025 = static_cast<real_type>(0.25L)*PI;
+const real_type deg2rad = Constants<real_type>::pi()/real_type(180);
+const real_type rad2deg = real_type(180)/Constants<real_type>::pi();
 
-const real_type deg2rad = PI/static_cast<real_type>(180);
-const real_type rad2deg = static_cast<real_type>(180)/PI;
-
 // The newtonian gravity constant.
-const real_type gravity_constant = 6.673e-11;
+const real_type gravity_constant = real_type(6.673e-11);
 
 } // namespace OpenFDM
 

Modified: trunk/OpenFDM/src/test/harmonic.cpp
===================================================================
--- trunk/OpenFDM/src/test/harmonic.cpp	2008-03-08 11:32:49 UTC (rev 374)
+++ trunk/OpenFDM/src/test/harmonic.cpp	2008-03-08 13:59:33 UTC (rev 375)
@@ -19,7 +19,7 @@
 int
 main(int argc, char *argv[])
 {
-  real_type omega = 20;
+  real_type omega = 2;
 
   SharedPtr<System> system = new System("Harmonic Oszilator");
   system->addSampleTime(real_type(1)/real_type(100));



From frohlich at mail.berlios.de  Wed Mar 19 08:00:17 2008
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Wed, 19 Mar 2008 08:00:17 +0100
Subject: [OpenFDM-svn] r377 - trunk/OpenFDM/src/OpenFDM/LinAlg
Message-ID: <200803190700.m2J70Hwm030266@sheep.berlios.de>

Author: frohlich
Date: 2008-03-19 08:00:10 +0100 (Wed, 19 Mar 2008)
New Revision: 377

Modified:
   trunk/OpenFDM/src/OpenFDM/LinAlg/Container.h
Log:
Hmm, name lookup problems ...


Modified: trunk/OpenFDM/src/OpenFDM/LinAlg/Container.h
===================================================================
--- trunk/OpenFDM/src/OpenFDM/LinAlg/Container.h	2008-03-08 14:01:15 UTC (rev 376)
+++ trunk/OpenFDM/src/OpenFDM/LinAlg/Container.h	2008-03-19 07:00:10 UTC (rev 377)
@@ -145,6 +145,7 @@
   { scalarMultiplyMatrix(*this, scalar); return *this; }
 
 private:
+  using MatrixLValue<Matrix<T,rows_,cols_>,rows_,cols_>::assign;
   RectangularArray<T,rows_,cols_> data_;
 };
 



