From frohlich at mail.berlios.de  Mon Jul 13 20:45:50 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Mon, 13 Jul 2009 20:45:50 +0200
Subject: [OpenFDM-svn] r1004 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200907131845.n6DIjoi9008147@sheep.berlios.de>

Author: frohlich
Date: 2009-07-13 20:45:50 +0200 (Mon, 13 Jul 2009)
New Revision: 1004

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Joint.h
Log:
Remove unused header.

M    Joint.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Joint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Joint.h	2009-06-23 16:58:41 UTC (rev 1003)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Joint.h	2009-07-13 18:45:50 UTC (rev 1004)
@@ -7,13 +7,11 @@
 
 #include "Assert.h"
 #include "Object.h"
-#include "Frame.h"
 #include "Vector.h"
 #include "Matrix.h"
 #include "Quaternion.h"
 #include "Inertia.h"
 #include "Interact.h"
-#include "Frame.h"
 #include "LogStream.h"
 
 #include "MechanicContext.h"



From frohlich at mail.berlios.de  Wed Jul 15 07:22:52 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Wed, 15 Jul 2009 07:22:52 +0200
Subject: [OpenFDM-svn] r1006 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200907150522.n6F5Mqep006515@sheep.berlios.de>

Author: frohlich
Date: 2009-07-15 07:22:50 +0200 (Wed, 15 Jul 2009)
New Revision: 1006

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicContext.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Task.h
Log:
Reuse the Coordinate System's position for the DesignPosition computation.

M    src/OpenFDM/Task.h
M    src/OpenFDM/MechanicContext.h
M    src/OpenFDM/MechanicLinkValue.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicContext.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicContext.h	2009-07-15 05:21:29 UTC (rev 1005)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicContext.h	2009-07-15 05:22:50 UTC (rev 1006)
@@ -57,10 +57,8 @@
 
   void initVelocities(const /*Init*/Task& task) const
   {
-    for (list_type::const_iterator i = begin(); i != end(); ++i) {
-      (*i)->initDesignPosition();
+    for (list_type::const_iterator i = begin(); i != end(); ++i)
       (*i)->initVelocities(task);
-    }
   }
   void velocities(const Task& task) const
   {

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.h	2009-07-15 05:21:29 UTC (rev 1005)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.h	2009-07-15 05:22:50 UTC (rev 1006)
@@ -104,11 +104,6 @@
     mVelocity = mCoordinateSystem.rotToReference(velocity) + parentVel;
   }
 
-  const Vector3& getDesignPosition() const
-  { return mDesignPosition; }
-  void setDesignPosition(const Vector3& designPosition)
-  { mDesignPosition = designPosition; }
-
 protected:
   /// The local coordinate system of the mechanic link.
   CoordinateSystem mCoordinateSystem;
@@ -122,10 +117,10 @@
   /// The spacial velocities pivot point is at the coordinate systems origin.
   Vector6 mAcceleration;
 
+  // These are stored in local coordinates.
+  // FIXME: move them to global coordinates too
   Vector6 mArticulatedForce;
   SpatialInertia mArticulatedInertia;
-
-  Vector3 mDesignPosition;
 };
 
 class ParentLink {
@@ -196,7 +191,8 @@
   void setDesignPosition(const Vector3& position)
   {
     OpenFDMAssert(isConnected());
-    mLinkRelPos = position - mMechanicLinkValue->getDesignPosition();
+    mLinkRelPos = position;
+    mLinkRelPos -= mMechanicLinkValue->getCoordinateSystem().getPosition();
   }
 
   void applyBodyForce(const Vector6& force)
@@ -282,7 +278,7 @@
   { return *mMechanicLinkValue; }
 
   void setDesignPosition(const Vector3& position)
-  { mMechanicLinkValue->setDesignPosition(position); }
+  { mMechanicLinkValue->setCoordinateSystem(CoordinateSystem(position)); }
 
   void setLocalAcceleration(const Vector6& accel)
   { mMechanicLinkValue->setLocalAcceleration(accel); }

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Task.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Task.h	2009-07-15 05:21:29 UTC (rev 1005)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Task.h	2009-07-15 05:22:50 UTC (rev 1006)
@@ -37,6 +37,8 @@
     setTime(t);
     // The model outputs before mechanical state propagation
     mModelContextList[0].initOutput(*this);
+    // The mechanical systems design positions
+    mMechanicContextList.initDesignPosition();
     // Now the mechanical state propagation
     mMechanicContextList.initVelocities(*this);
     // The model outputs before mechanical force propagation



From frohlich at mail.berlios.de  Fri Jul 17 20:02:42 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Fri, 17 Jul 2009 20:02:42 +0200
Subject: [OpenFDM-svn] r1007 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200907171802.n6HI2g9M005305@sheep.berlios.de>

Author: frohlich
Date: 2009-07-17 20:02:41 +0200 (Fri, 17 Jul 2009)
New Revision: 1007

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
Log:
Make sure the child links of root joints are set.

M    System.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2009-07-15 05:22:50 UTC (rev 1006)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2009-07-17 18:02:41 UTC (rev 1007)
@@ -1036,6 +1036,12 @@
     // have only one link ...
     JointInstanceDataList sortedJoints;
     sortedJoints.swap(mRootJointInstanceDataList);
+    // For the case that the root joint is the only joint in the chain
+    for (JointInstanceDataList::iterator i = sortedJoints.begin();
+         i != sortedJoints.end(); ++i) {
+      // FIXME
+      (*i)->makeRemainigLinksChildLinks();
+    }
 
     // Not the best algorithm, but for a first cut ...
     while (!mJointInstanceDataList.empty()) {



From frohlich at mail.berlios.de  Fri Jul 17 20:03:15 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Fri, 17 Jul 2009 20:03:15 +0200
Subject: [OpenFDM-svn] r1008 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200907171803.n6HI3FY2005358@sheep.berlios.de>

Author: frohlich
Date: 2009-07-17 20:03:15 +0200 (Fri, 17 Jul 2009)
New Revision: 1008

Added:
   branches/OpenFDM-StateSeparation/src/test/drop.cpp
Modified:
   branches/OpenFDM-StateSeparation/src/test/Makefile.am
   branches/OpenFDM-StateSeparation/src/test/mechanic.cpp
Log:
Add simple drop test.

AM   test/drop.cpp
M    test/mechanic.cpp
M    test/Makefile.am


Modified: branches/OpenFDM-StateSeparation/src/test/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/Makefile.am	2009-07-17 18:02:41 UTC (rev 1007)
+++ branches/OpenFDM-StateSeparation/src/test/Makefile.am	2009-07-17 18:03:15 UTC (rev 1008)
@@ -1,48 +1,65 @@
 INCLUDES = -I$(srcdir)/..
 
+# define some unit tests
+TESTS = \
+	constintegral \
+	harmonic \
+	limit \
+	linalg \
+	quattest \
+	simulationtime \
+	structure \
+	unitstest
+
 # define some util programs
-bin_PROGRAMS = foucault inertianav mechanic structure tiretestrig coordsys
+noinst_PROGRAMS = \
+	drop \
+	foucault \
+	inertianav \
+	mechanic \
+	structure \
+	tiretestrig \
+	coordsys \
+	$(TESTS)
 
-# define some unit tests
-check_PROGRAMS = constintegral harmonic limit linalg quattest \
-                 simulationtime structure unitstest
-TESTS          = $(check_PROGRAMS)
+constintegral_SOURCES = constintegral.cpp
+constintegral_LDADD = ../OpenFDM/libOpenFDM.la
 
-tiretestrig_SOURCES = tiretestrig.cpp
-tiretestrig_LDADD = ../OpenFDM/libOpenFDM.la
-
 coordsys_SOURCES = coordsys.cpp
 coordsys_LDADD = ../OpenFDM/libOpenFDM.la
 
-unitstest_SOURCES = unitstest.cpp
-unitstest_LDADD = ../OpenFDM/libOpenFDM.la
+drop_SOURCES = drop.cpp
+drop_LDADD = ../OpenFDM/libOpenFDM.la
 
-quattest_SOURCES = quattest.cpp
-quattest_LDADD = ../OpenFDM/libOpenFDM.la
+foucault_SOURCES = foucault.cpp
+foucault_LDADD = ../OpenFDM/libOpenFDM.la
 
-mechanic_SOURCES = mechanic.cpp
-mechanic_LDADD = ../OpenFDM/libOpenFDM.la
+harmonic_SOURCES = harmonic.cpp
+harmonic_LDADD = ../OpenFDM/libOpenFDM.la
 
 inertianav_SOURCES = inertianav.cpp
 inertianav_LDADD = ../OpenFDM/libOpenFDM.la
 
+limit_SOURCES = limit.cpp
+limit_LDADD = ../OpenFDM/libOpenFDM.la
+
 linalg_SOURCES = linalg.cpp
 linalg_LDADD = ../OpenFDM/libOpenFDM.la
 
-foucault_SOURCES = foucault.cpp
-foucault_LDADD = ../OpenFDM/libOpenFDM.la
+mechanic_SOURCES = mechanic.cpp
+mechanic_LDADD = ../OpenFDM/libOpenFDM.la
 
-structure_SOURCES = structure.cpp
-structure_LDADD = ../OpenFDM/libOpenFDM.la
+quattest_SOURCES = quattest.cpp
+quattest_LDADD = ../OpenFDM/libOpenFDM.la
 
 simulationtime_SOURCES = simulationtime.cpp
 simulationtime_LDADD = ../OpenFDM/libOpenFDM.la
 
-constintegral_SOURCES = constintegral.cpp
-constintegral_LDADD = ../OpenFDM/libOpenFDM.la
+structure_SOURCES = structure.cpp
+structure_LDADD = ../OpenFDM/libOpenFDM.la
 
-harmonic_SOURCES = harmonic.cpp
-harmonic_LDADD = ../OpenFDM/libOpenFDM.la
+tiretestrig_SOURCES = tiretestrig.cpp
+tiretestrig_LDADD = ../OpenFDM/libOpenFDM.la
 
-limit_SOURCES = limit.cpp
-limit_LDADD = ../OpenFDM/libOpenFDM.la
+unitstest_SOURCES = unitstest.cpp
+unitstest_LDADD = ../OpenFDM/libOpenFDM.la

Added: branches/OpenFDM-StateSeparation/src/test/drop.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/drop.cpp	2009-07-17 18:02:41 UTC (rev 1007)
+++ branches/OpenFDM-StateSeparation/src/test/drop.cpp	2009-07-17 18:03:15 UTC (rev 1008)
@@ -0,0 +1,61 @@
+#include <OpenFDM/ConstModel.h>
+#include <OpenFDM/Group.h>
+#include <OpenFDM/InternalInteract.h>
+#include <OpenFDM/LinearSpringDamper.h>
+#include <OpenFDM/Mass.h>
+#include <OpenFDM/MobileRootJoint.h>
+#include <OpenFDM/RevoluteJoint.h>
+#include <OpenFDM/RigidBody.h>
+#include <OpenFDM/ExternalInteract.h>
+#include <OpenFDM/System.h>
+#include <OpenFDM/SystemOutput.h>
+
+using namespace OpenFDM;
+
+Node* buildDrop()
+{
+  // A simple free falling mass.
+  SharedPtr<Group> group = new Group("Group");
+
+  MobileRootJoint* mobileRootJoint = new MobileRootJoint("Root Joint");
+  group->addChild(mobileRootJoint);
+
+  RigidBody* rigidBody = new RigidBody("Rigid Body");
+  rigidBody->addLink("externalInteractLink");
+  group->addChild(rigidBody);
+
+  Mass* mass = new Mass("Mass", 1, InertiaMatrix(1, 0, 0, 1, 0, 1));
+  group->addChild(mass);
+
+  ExternalInteract* externalInteract = new ExternalInteract("ExternalInteract");
+  externalInteract->setPosition(mass->getPosition());
+  externalInteract->setEnableAllOutputs(true);
+  group->addChild(externalInteract);
+
+  group->connect(mobileRootJoint->getPort("link"),
+                 rigidBody->getPort("link0"));
+  group->connect(rigidBody->getPort("link1"),
+                 mass->getPort("link"));
+  group->connect(rigidBody->getPort("externalInteractLink"),
+                 externalInteract->getPort("link"));
+
+  return group.release();
+}
+
+int main()
+{
+  SharedPtr<System> system = new System("System", buildDrop());
+
+  system->attach(SystemOutput::newDefaultSystemOutput("drop"));
+
+  if (!system->init())
+    return 1;
+
+  system->simulate(10);
+
+  return 0;
+}
+
+// Kabelbaum <-> PortBundle ??? Original Kabelbaum == Cabel Bundle
+// Oder Cable Set <-> Port Set???
+


Property changes on: branches/OpenFDM-StateSeparation/src/test/drop.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: branches/OpenFDM-StateSeparation/src/test/mechanic.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/mechanic.cpp	2009-07-17 18:02:41 UTC (rev 1007)
+++ branches/OpenFDM-StateSeparation/src/test/mechanic.cpp	2009-07-17 18:03:15 UTC (rev 1008)
@@ -12,45 +12,21 @@
 
 using namespace OpenFDM;
 
+/// sensible test cases:
+/// drop: gravity
+/// throw: just this test with a different start condition
+/// harmonic oszilator: compare with 2nd order linear system
+/// arrow: see if the tip stays in front
+/// satellit: coriolis
+/// paris pendulum: coriolis
+
 Node* buildSimpleMechanicExample()
 {
-  /// sensible test cases:
-  /// drop: gravity
-  /// throw: just this test with a different start condition
-  /// harmonic oszilator: compare with 2nd order linear system
-  /// arrow: see if the tip stays in front
-  /// satellit: coriolis
-  /// paris pendulum: coriolis
-
   SharedPtr<Group> group = new Group("G");
 
   MobileRootJoint* mobileRootJoint = new MobileRootJoint("Root Joint");
   group->addChild(mobileRootJoint);
-  RigidBody* rigidBody = new RigidBody("Rigid Body");
-  rigidBody->addLink("externalInteractLink");
-  group->addChild(rigidBody);
-  Mass* mass = new Mass("Mass", 1, InertiaMatrix(1, 0, 0, 1, 0, 1));
-  group->addChild(mass);
 
-  ExternalInteract* externalInteract = new ExternalInteract("ExternalInteract");
-  externalInteract->setPosition(mass->getPosition());
-  externalInteract->setEnableAllOutputs(true);
-  group->addChild(externalInteract);
-
-  group->connect(mobileRootJoint->getPort("link"), rigidBody->getPort("link0"));
-  group->connect(rigidBody->getPort("link1"), mass->getPort("link"));
-  group->connect(rigidBody->getPort("externalInteractLink"), externalInteract->getPort("link"));
-
-  return group.release();
-}
-
-Node* buildSimpleMechanicExample2()
-{
-  SharedPtr<Group> group = new Group("G");
-
-  MobileRootJoint* mobileRootJoint = new MobileRootJoint("Root Joint");
-  group->addChild(mobileRootJoint);
-
   RigidBody *rigidBody = new RigidBody("Rigid Body");
   rigidBody->addLink("link2");
   rigidBody->addLink("externalInteractLink");
@@ -133,8 +109,7 @@
 
 int main()
 {
-//   SharedPtr<System> system = new System("System", buildSimpleMechanicExample());
-  SharedPtr<System> system = new System("System", buildSimpleMechanicExample2());
+  SharedPtr<System> system = new System("System", buildSimpleMechanicExample());
 
   system->attach(SystemOutput::newDefaultSystemOutput("mechanic"));
 



From frohlich at mail.berlios.de  Fri Jul 17 21:15:48 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Fri, 17 Jul 2009 21:15:48 +0200
Subject: [OpenFDM-svn] r1009 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200907171915.n6HJFmJQ017855@sheep.berlios.de>

Author: frohlich
Date: 2009-07-17 21:15:47 +0200 (Fri, 17 Jul 2009)
New Revision: 1009

Added:
   branches/OpenFDM-StateSeparation/src/test/ballistic.cpp
Modified:
   branches/OpenFDM-StateSeparation/src/test/Makefile.am
   branches/OpenFDM-StateSeparation/src/test/drop.cpp
Log:
Add an other small test program.


Modified: branches/OpenFDM-StateSeparation/src/test/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/Makefile.am	2009-07-17 18:03:15 UTC (rev 1008)
+++ branches/OpenFDM-StateSeparation/src/test/Makefile.am	2009-07-17 19:15:47 UTC (rev 1009)
@@ -13,6 +13,7 @@
 
 # define some util programs
 noinst_PROGRAMS = \
+	ballistic \
 	drop \
 	foucault \
 	inertianav \
@@ -22,6 +23,9 @@
 	coordsys \
 	$(TESTS)
 
+ballistic_SOURCES = ballistic.cpp
+ballistic_LDADD = ../OpenFDM/libOpenFDM.la
+
 constintegral_SOURCES = constintegral.cpp
 constintegral_LDADD = ../OpenFDM/libOpenFDM.la
 

Added: branches/OpenFDM-StateSeparation/src/test/ballistic.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/ballistic.cpp	2009-07-17 18:03:15 UTC (rev 1008)
+++ branches/OpenFDM-StateSeparation/src/test/ballistic.cpp	2009-07-17 19:15:47 UTC (rev 1009)
@@ -0,0 +1,58 @@
+#include <OpenFDM/ConstModel.h>
+#include <OpenFDM/Group.h>
+#include <OpenFDM/InternalInteract.h>
+#include <OpenFDM/LinearSpringDamper.h>
+#include <OpenFDM/Mass.h>
+#include <OpenFDM/MobileRootJoint.h>
+#include <OpenFDM/RevoluteJoint.h>
+#include <OpenFDM/RigidBody.h>
+#include <OpenFDM/ExternalInteract.h>
+#include <OpenFDM/System.h>
+#include <OpenFDM/SystemOutput.h>
+
+using namespace OpenFDM;
+
+Node* buildBallistic()
+{
+  // A simple free falling mass.
+  SharedPtr<Group> group = new Group("Group");
+
+  MobileRootJoint* mobileRootJoint = new MobileRootJoint("Root Joint");
+  mobileRootJoint->setInitialLinearVelocity(50/sqrt(2)*Vector3(1, 0, -1));
+  group->addChild(mobileRootJoint);
+
+  RigidBody* rigidBody = new RigidBody("Rigid Body");
+  rigidBody->addLink("externalInteractLink");
+  group->addChild(rigidBody);
+
+  Mass* mass = new Mass("Mass", 1, InertiaMatrix(1, 0, 0, 1, 0, 1));
+  group->addChild(mass);
+
+  ExternalInteract* externalInteract = new ExternalInteract("ExternalInteract");
+  externalInteract->setPosition(mass->getPosition());
+  externalInteract->setEnableAllOutputs(true);
+  group->addChild(externalInteract);
+
+  group->connect(mobileRootJoint->getPort("link"),
+                 rigidBody->getPort("link0"));
+  group->connect(rigidBody->getPort("link1"),
+                 mass->getPort("link"));
+  group->connect(rigidBody->getPort("externalInteractLink"),
+                 externalInteract->getPort("link"));
+
+  return group.release();
+}
+
+int main()
+{
+  SharedPtr<System> system = new System("System", buildBallistic());
+
+  system->attach(SystemOutput::newDefaultSystemOutput("ballistic"));
+
+  if (!system->init())
+    return 1;
+
+  system->simulate(10);
+
+  return 0;
+}


Property changes on: branches/OpenFDM-StateSeparation/src/test/ballistic.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: branches/OpenFDM-StateSeparation/src/test/drop.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/drop.cpp	2009-07-17 18:03:15 UTC (rev 1008)
+++ branches/OpenFDM-StateSeparation/src/test/drop.cpp	2009-07-17 19:15:47 UTC (rev 1009)
@@ -18,6 +18,7 @@
   SharedPtr<Group> group = new Group("Group");
 
   MobileRootJoint* mobileRootJoint = new MobileRootJoint("Root Joint");
+  mobileRootJoint->setInitialAngularVelocity(Vector3(1, 1, 1));
   group->addChild(mobileRootJoint);
 
   RigidBody* rigidBody = new RigidBody("Rigid Body");
@@ -56,6 +57,3 @@
   return 0;
 }
 
-// Kabelbaum <-> PortBundle ??? Original Kabelbaum == Cabel Bundle
-// Oder Cable Set <-> Port Set???
-



From frohlich at mail.berlios.de  Fri Jul 17 22:15:49 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Fri, 17 Jul 2009 22:15:49 +0200
Subject: [OpenFDM-svn] r1010 -
	branches/OpenFDM-StateSeparation/src/OpenFDM/LinAlg
Message-ID: <200907172015.n6HKFnO7024276@sheep.berlios.de>

Author: frohlich
Date: 2009-07-17 22:15:49 +0200 (Fri, 17 Jul 2009)
New Revision: 1010

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/LinAlg/Container.h
Log:
Add some generic constructors.

M    Container.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/LinAlg/Container.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/LinAlg/Container.h	2009-07-17 19:15:47 UTC (rev 1009)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/LinAlg/Container.h	2009-07-17 20:15:49 UTC (rev 1010)
@@ -1165,7 +1165,12 @@
   SymMatrix3(const SymMatrix3& S)
     : SymMatrix<T,3>(S)
   { }
+  template<typename Impl2, size_type m2>
   OpenFDM_FORCE_INLINE
+  SymMatrix3(const MatrixRValue<Impl2,m2,m2>& A)
+    : SymMatrix<T,3>(A)
+  { }
+  OpenFDM_FORCE_INLINE
   ~SymMatrix3(void)
   { }
 };
@@ -1229,7 +1234,12 @@
   SymMatrix6(const SymMatrix6& S)
     : SymMatrix<T,6>(S)
   { }
+  template<typename Impl2, size_type m2>
   OpenFDM_FORCE_INLINE
+  SymMatrix6(const MatrixRValue<Impl2,m2,m2>& A)
+    : SymMatrix<T,6>(A)
+  { }
+  OpenFDM_FORCE_INLINE
   ~SymMatrix6(void)
   { }
 



From frohlich at mail.berlios.de  Fri Jul 17 22:17:42 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Fri, 17 Jul 2009 22:17:42 +0200
Subject: [OpenFDM-svn] r1011 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200907172017.n6HKHgo1024430@sheep.berlios.de>

Author: frohlich
Date: 2009-07-17 22:17:40 +0200 (Fri, 17 Jul 2009)
New Revision: 1011

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/CoordinateSystem.h
Log:
Add some more utility functions.

M    CoordinateSystem.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/CoordinateSystem.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/CoordinateSystem.h	2009-07-17 20:15:49 UTC (rev 1010)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/CoordinateSystem.h	2009-07-17 20:17:40 UTC (rev 1011)
@@ -22,15 +22,15 @@
     mPosition(Vector3::zeros()),
     mOrientation(Quaternion::unit())
   { }
-  CoordinateSystem(const Vector3& position) :
+  explicit CoordinateSystem(const Vector3& position) :
     mPosition(position),
     mOrientation(Quaternion::unit())
   { }
-  CoordinateSystem(const Quaternion& orientation) :
+  explicit CoordinateSystem(const Quaternion& orientation) :
     mPosition(Vector3::zeros()),
     mOrientation(orientation)
   { }
-  CoordinateSystem(const Rotation& orientation) :
+  explicit CoordinateSystem(const Rotation& orientation) :
     mPosition(Vector3::zeros()),
     mOrientation(orientation)
   { }
@@ -109,7 +109,63 @@
   { return Vector6(mOrientation.transform(v.getAngular()),
                    mOrientation.transform(v.getLinear())); }
 
+  template<unsigned n>
+  LinAlg::Matrix<real_type,3,n>
+  rotToReference(const LinAlg::Matrix<real_type,3,n>& m) const
+  {
+    LinAlg::Matrix<real_type,3,n> result;
+    for (unsigned i = 0; i < n; ++i)
+      result(Range(0, 2), i) = mOrientation.backTransform(m(Range(0, 2), i));
+    return result;
+  }
+  template<unsigned n>
+  LinAlg::Matrix<real_type,3,n>
+  rotToLocal(const LinAlg::Matrix<real_type,3,n>& m) const
+  {
+    LinAlg::Matrix<real_type,3,n> result;
+    for (unsigned i = 0; i < n; ++i)
+      result(Range(0, 2), i) = mOrientation.transform(m(Range(0, 2), i));
+    return result;
+  }
 
+
+  template<unsigned n>
+  LinAlg::Matrix<real_type,6,n>
+  rotToReference(const LinAlg::Matrix<real_type,6,n>& m) const
+  {
+    LinAlg::Matrix<real_type,6,n> result;
+    for (unsigned i = 0; i < n; ++i) {
+      result(Range(0, 2), i) = mOrientation.backTransform(m(Range(0, 2), i));
+      result(Range(3, 5), i) = mOrientation.backTransform(m(Range(3, 5), i));
+    }
+    return result;
+  }
+  template<unsigned n>
+  LinAlg::Matrix<real_type,6,n>
+  rotToLocal(const LinAlg::Matrix<real_type,6,n>& m) const
+  {
+    LinAlg::Matrix<real_type,6,n> result;
+    for (unsigned i = 0; i < n; ++i) {
+      result(Range(0, 2), i) = mOrientation.transform(m(Range(0, 2), i));
+      result(Range(3, 5), i) = mOrientation.transform(m(Range(3, 5), i));
+    }
+    return result;
+  }
+
+
+
+
+  InertiaMatrix rotToReference(const InertiaMatrix& inertia) const
+  { return inertiaFrom(mOrientation, inertia); }
+  InertiaMatrix rotToLocal(const InertiaMatrix& inertia) const
+  { return inertiaTo(mOrientation, inertia); }
+
+  SpatialInertia rotToReference(const SpatialInertia& inertia) const
+  { return inertiaFrom(mOrientation, inertia); }
+  SpatialInertia rotToLocal(const SpatialInertia& inertia) const
+  { return inertiaFrom(Rotation(inverse(mOrientation)), inertia); }
+
+
   // Avoid that here. We *only* handle coordinate systems not reference frames.
   Vector6 motionToReference(const Vector6& motion) const
   { return motionFrom(mPosition, mOrientation, motion); }



From frohlich at mail.berlios.de  Fri Jul 17 22:18:58 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Fri, 17 Jul 2009 22:18:58 +0200
Subject: [OpenFDM-svn] r1012 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200907172018.n6HKIvLq024580@sheep.berlios.de>

Author: frohlich
Date: 2009-07-17 22:18:57 +0200 (Fri, 17 Jul 2009)
New Revision: 1012

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Transform.h
Log:
Add transforms for the 3x3 Inertia matrix.

M    Transform.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Transform.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Transform.h	2009-07-17 20:17:40 UTC (rev 1011)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Transform.h	2009-07-17 20:18:57 UTC (rev 1012)
@@ -259,6 +259,20 @@
 
 
 
+OpenFDM_FORCE_INLINE InertiaMatrix
+inertiaTo(const Rotation& r, const InertiaMatrix& inertia)
+{
+  return r.getTransform()*inertia*r.getBackTransform();
+}
+
+OpenFDM_FORCE_INLINE InertiaMatrix
+inertiaFrom(const Rotation& r, const InertiaMatrix& inertia)
+{
+  return r.getBackTransform()*inertia*r.getTransform();
+}
+
+
+
 OpenFDM_FORCE_INLINE SpatialInertia
 inertiaFrom(const Vector3& p, const Rotation& r, const SpatialInertia& I)
 {



From frohlich at mail.berlios.de  Fri Jul 17 23:49:56 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Fri, 17 Jul 2009 23:49:56 +0200
Subject: [OpenFDM-svn] r1013 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200907172149.n6HLnueV002165@sheep.berlios.de>

Author: frohlich
Date: 2009-07-17 23:49:55 +0200 (Fri, 17 Jul 2009)
New Revision: 1013

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJoint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/HDF5SystemOutput.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Mass.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJoint.cpp
Log:
Do inertia and force computations also in global coordinates.

M    src/OpenFDM/MobileRootJoint.cpp
M    src/OpenFDM/CartesianJoint.h
M    src/OpenFDM/Mass.cpp
M    src/OpenFDM/MechanicLinkValue.cpp
M    src/OpenFDM/MechanicLinkValue.h
M    src/OpenFDM/FixedRootJoint.cpp
M    src/OpenFDM/HDF5SystemOutput.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h	2009-07-17 20:18:57 UTC (rev 1012)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h	2009-07-17 21:49:55 UTC (rev 1013)
@@ -101,7 +101,6 @@
     {
       mParentLink.setDesignPosition(mCartesianJoint->getPosition());
       mChildLink.setDesignPosition(mCartesianJoint->getPosition());
-      mJointMatrix = mCartesianJoint->getJointMatrix();
     }
 
     virtual void init(const /*Init*/Task& task)
@@ -136,14 +135,22 @@
     {
       // Set up the local coordinate system of the joint
       Vector3 relPosition = mParentLink.getLinkRelPos() + position;
-      mRelativeCoordinateSystem.setPosition(relPosition);
-      mRelativeCoordinateSystem.setOrientation(orientation);
 
       // Propagate the reference coordinate system to the parent.
-      mChildLink.setCoordinateSystem(mParentLink.getCoordinateSystem().toReference(mRelativeCoordinateSystem));
+      mChildLink.setCoordinateSystem(mParentLink.getCoordinateSystem().getRelative(relPosition, orientation));
 
+      const CoordinateSystem& cs = mChildLink.getCoordinateSystem();
+      const CoordinateSystem& ps = mParentLink.getCoordinateSystem();
+
+      mJointMatrix = cs.rotToReference(mCartesianJoint->getJointMatrix());
+
+      Vector3 positionDifference = cs.getPosition() - ps.getPosition();
+
+      Vector6 parentSpVel = mParentLink.getVelocity();
+      parentSpVel = motionTo(positionDifference, parentSpVel);
+
       Vector6 relVel = mJointMatrix*velocity;
-      mChildLink.setRelativeVelocity(mParentLink, relVel);
+      mChildLink.setVelocity(parentSpVel + relVel);
 
       /**
          This is the cross product of the inertial spatial velocity
@@ -155,11 +162,13 @@
          transformed spatial velocity of the parent frame cross the
          relative velocity.
       */
-      Vector6 pivel = mParentLink.getLocalVelocityAtLink();
-      pivel = mRelativeCoordinateSystem.motionToLocal(pivel);
-      mHdot = Vector6(cross(pivel.getAngular(), relVel.getAngular()),
-                      cross(pivel.getAngular(), relVel.getLinear()) + 
-                      cross(pivel.getLinear(), relVel.getAngular()));
+      mHdot = Vector6(cross(parentSpVel.getAngular(), relVel.getAngular()),
+                      cross(parentSpVel.getAngular(), relVel.getLinear()) + 
+                      cross(parentSpVel.getLinear(), relVel.getAngular()));
+
+
+      mChildLink.setSpatialForce(Vector6::zeros());
+      mChildLink.setSpatialInertia(SpatialInertia::zeros());
     }
 
     /** This is the derivative of the joint matrix times the joint velocity
@@ -175,36 +184,33 @@
       // The formulas conform to Roy Featherstones book eqn (6.37), (6.38)
 
       mJointForce = jointForce;
-    
-      // Store the outboard values since we will need them later in velocity
-      // derivative computations
-      SpatialInertia I = mChildLink.getInertia();
-      
-      // Compute the projection to the joint coordinate space
+
+      const CoordinateSystem& cs = mChildLink.getCoordinateSystem();
+
+      // Compute the projection of the inertia matrix to the
+      // joint coordinate space
+      SpatialInertia I = mChildLink.getSpatialInertia();
       Matrix6N Ih = I*mJointMatrix;
       hIh = trans(mJointMatrix)*Ih;
 
-      // Note that the momentum of the local mass is already included in the
-      // child links force due the the mass model ...
-      pAlpha = mChildLink.getForce() + I*getHdot();
-      
       if (hIh.singular()) {
         Log(ArtBody,Error) << "Detected singular mass matrix for "
                            << "CartesianJoint \"" << mCartesianJoint->getName()
                            << "\": Fix your model!" << endl;
         return;
       }
-      
-      // Project away the directions handled with this current joint
-      Vector6 force = pAlpha;
-      force -= Ih*hIh.solve(trans(mJointMatrix)*pAlpha - jointForce);
+
+      // Note that the momentum of the local mass is already included in the
+      // child links force due the the mass model ...
+      Vector6 force = mChildLink.getSpatialForce() + I*getHdot();
+
+      // Project away those axis handled with this current joint
+      force -= Ih*hIh.solve(trans(mJointMatrix)*force - jointForce);
       I -= SpatialInertia(Ih*hIh.solve(trans(Ih)));
-      
-      // Transform to parent link's coordinates and apply to the parent link
-      force = mRelativeCoordinateSystem.forceToReference(force);
-      I = mRelativeCoordinateSystem.inertiaToReference(I);
-      mParentLink.addForceAtLink(force);
-      mParentLink.addInertiaAtLink(I);
+
+      // Contribute the remaining force and inertiy to the parent link
+      mParentLink.addSpatialForce(cs.getPosition(), force);
+      mParentLink.addSpatialInertia(cs.getPosition(), I);
     }
 
     /** Compute the acceleration step for a given joint force.
@@ -215,14 +221,21 @@
       if (hIh.singular())
         return;
 
-      Vector6 parentSpAccel = mParentLink.getLocalAccelerationAtLink();
-      parentSpAccel = mRelativeCoordinateSystem.motionToLocal(parentSpAccel);
+      const CoordinateSystem& cs = mChildLink.getCoordinateSystem();
+      const CoordinateSystem& ps = mParentLink.getCoordinateSystem();
 
-      Vector6 f = mChildLink.getInertia()*parentSpAccel + pAlpha;
+      Vector3 positionDifference = cs.getPosition() - ps.getPosition();
+
+      Vector6 parentSpAccel = mParentLink.getAcceleration();
+      parentSpAccel = motionTo(positionDifference, parentSpAccel);
+
+      Vector6 f = mChildLink.getSpatialForce();
+      f += mChildLink.getSpatialInertia()*(parentSpAccel + getHdot());
+
       mVelDot = hIh.solve(mJointForce - trans(mJointMatrix)*f);
 
       Vector6 spAccel = parentSpAccel + getHdot() + mJointMatrix*mVelDot;
-      mChildLink.setLocalAcceleration(spAccel);
+      mChildLink.setAcceleration(spAccel);
     }
   
     /** Compute the articulation step for a given velocity derivative.
@@ -233,19 +246,19 @@
       // The formulas conform to Roy Featherstones book eqn (7.36), (7.37)
       
       mVelDot = velDot;
-      
+
       // Compute the articulated force and inertia.
       // This Since there is no projection step with the joint axis, it is clear
       // that this is just a rigid connection ...
-      SpatialInertia I = mChildLink.getInertia();
-      Vector6 force = mChildLink.getForce();
+
+      const CoordinateSystem& cs = mChildLink.getCoordinateSystem();
+
+      const SpatialInertia& I = mChildLink.getSpatialInertia();
+      Vector6 force = mChildLink.getSpatialForce();
       force += I*(getHdot() + mJointMatrix*mVelDot);
       
-      // Transform to parent link's coordinates and apply to the parent link
-      force = mRelativeCoordinateSystem.forceToReference(force);
-      I = mRelativeCoordinateSystem.inertiaToReference(I);
-      mParentLink.addForceAtLink(force);
-      mParentLink.addInertiaAtLink(I);
+      mParentLink.addSpatialForce(cs.getPosition(), force);
+      mParentLink.addSpatialInertia(cs.getPosition(), I);
     }
     
     /** Compute the acceleration step for a given velocity derivative.
@@ -253,11 +266,15 @@
      */
     void accelerateDueToVelDot()
     {
-      Vector6 parentSpAccel = mParentLink.getLocalAccelerationAtLink();
-      parentSpAccel = mRelativeCoordinateSystem.motionToLocal(parentSpAccel);
+      const CoordinateSystem& cs = mChildLink.getCoordinateSystem();
+      const CoordinateSystem& ps = mParentLink.getCoordinateSystem();
+      Vector3 positionDifference = cs.getPosition() - ps.getPosition();
 
+      Vector6 parentSpAccel = mParentLink.getAcceleration();
+      parentSpAccel = motionTo(positionDifference, parentSpAccel);
+
       Vector6 spAccel = parentSpAccel + getHdot() + mJointMatrix*mVelDot;
-      mChildLink.setLocalAcceleration(spAccel);
+      mChildLink.setAcceleration(spAccel);
     }
 
     const VectorN& getVelDot() const
@@ -267,12 +284,9 @@
     // Stores some values persistent accross velocity/articulation/acceleration
     MatrixFactorsNN hIh;
     Vector6 mHdot;
-    Vector6 pAlpha;
     VectorN mVelDot;
     VectorN mJointForce;
 
-    CoordinateSystem mRelativeCoordinateSystem;
-
     Matrix6N mJointMatrix;
     
     SharedPtr<const CartesianJoint> mCartesianJoint;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJoint.cpp	2009-07-17 20:18:57 UTC (rev 1012)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJoint.cpp	2009-07-17 21:49:55 UTC (rev 1013)
@@ -43,11 +43,14 @@
     CoordinateSystem coordSys(mFixedRootJoint->mRootPosition,
                               mFixedRootJoint->mRootOrientation);
     mChildLink.setCoordinateSystem(coordSys);
-    mChildLink.setBaseVelocity(angularVel, Vector6::zeros());
+    Vector6 vel = angularMotionTo(mFixedRootJoint->mRootPosition, angularVel);
+    mChildLink.setVelocity(vel);
+
+    mChildLink.setSpatialForce(Vector6::zeros());
+    mChildLink.setSpatialInertia(SpatialInertia::zeros());
   }
   virtual void accelerations(const Task& task)
   {
-    // FIXME
     Vector6 spAccel = getEnvironment().getAcceleration(task.getTime());
     spAccel = motionTo(mFixedRootJoint->mRootPosition, spAccel);
     mChildLink.setAcceleration(spAccel);

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/HDF5SystemOutput.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/HDF5SystemOutput.h	2009-07-17 20:18:57 UTC (rev 1012)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/HDF5SystemOutput.h	2009-07-17 21:49:55 UTC (rev 1013)
@@ -359,10 +359,10 @@
       _position.append(cs.getPosition());
       _orientation.append(cs.getOrientation());
       _eulerAngle.append(cs.getOrientation().getEuler());
-      _velocity.append(mMechanicLinkValue->getLocalVelocity());
-      _acceleration.append(mMechanicLinkValue->getLocalAcceleration());
-      _force.append(mMechanicLinkValue->getForce());
-      _inertia.append(mMechanicLinkValue->getInertia());
+      _velocity.append(mMechanicLinkValue->getVelocity());
+      _acceleration.append(mMechanicLinkValue->getAcceleration());
+      _force.append(mMechanicLinkValue->getSpatialForce());
+      _inertia.append(mMechanicLinkValue->getSpatialInertia());
     }
     virtual HDF5Object getObject()
     { return _group; }

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Mass.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Mass.cpp	2009-07-17 20:18:57 UTC (rev 1012)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Mass.cpp	2009-07-17 21:49:55 UTC (rev 1013)
@@ -21,8 +21,7 @@
   Context(const Mass* mass,
           const Environment* environment, PortValueList& portValueList) :
     SingleLinkInteract::Context(mass, environment, portValueList),
-    mMass(mass),
-    mSpatialInertia(SpatialInertia::zeros())
+    mMass(mass)
   { }
   virtual ~Context() {}
     
@@ -32,35 +31,33 @@
   virtual void initDesignPosition()
   {
     SingleLinkInteract::Context::initDesignPosition();
-    Vector3 relPos = getLink().getLinkRelPos();
-    mSpatialInertia = SpatialInertia(mMass->getInertia(), mMass->getMass());
-    mSpatialInertia = inertiaFrom(relPos, mSpatialInertia);
   }
   virtual void articulation(const Task&)
   {
+    CoordinateSystem cs = getLink().getCoordinateSystem();
+
+    SpatialInertia I(cs.rotToReference(mMass->getInertia()), mMass->getMass());
+
     // Contribute the inerita
-    getLink().addInertiaAtLink(mSpatialInertia);
+    getLink().addSpatialInertia(cs.getPosition(), I);
 
     // Each inertia has a contribution to the spatial bias force.
     // This part is handled here.
-    Vector6 v = getLink().getLocalVelocityAtLink();
-    Vector6 Iv = mSpatialInertia*v;
+    Vector6 v = getLink().getVelocity(cs.getPosition());
+    Vector6 Iv = I*v;
     Vector6 vIv = Vector6(cross(v.getAngular(), Iv.getAngular()) +
                           cross(v.getLinear(), Iv.getLinear()),
                           cross(v.getAngular(), Iv.getLinear()));
-    getLink().addForceAtLink(vIv);
+    getLink().addSpatialForce(cs.getPosition(), vIv);
 
     // Now the gravity part
-    Vector3 refPos = getLink().getRefPos();
-    Vector3 gravity = getEnvironment().getGravityAcceleration(refPos);
-    gravity = getLink().getCoordinateSystem().rotToLocal(gravity);
+    Vector3 gravity = getEnvironment().getGravityAcceleration(cs.getPosition());
     gravity *= mMass->getMass();
-    getLink().applyBodyForce(gravity);
+    getLink().applyForce(cs.getPosition(), gravity);
   }
 
 private:
   SharedPtr<const Mass> mMass;
-  SpatialInertia mSpatialInertia;
 };
 
 Mass::Mass(const std::string& name, const real_type& mass,

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.cpp	2009-07-17 20:18:57 UTC (rev 1012)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.cpp	2009-07-17 21:49:55 UTC (rev 1013)
@@ -7,8 +7,10 @@
 namespace OpenFDM {
 
 MechanicLinkValue::MechanicLinkValue() :
-  mArticulatedForce(Vector6::zeros()),
-  mArticulatedInertia(SpatialInertia::zeros())
+  mVelocity(Vector6::zeros()),
+  mAcceleration(Vector6::zeros()),
+  mForce(Vector6::zeros()),
+  mInertia(SpatialInertia::zeros())
 {
 }
 

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.h	2009-07-17 20:18:57 UTC (rev 1012)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.h	2009-07-17 21:49:55 UTC (rev 1013)
@@ -16,11 +16,16 @@
   MechanicLinkValue();
   virtual ~MechanicLinkValue();
 
+  /// Dynamic cast methods
   virtual MechanicLinkValue* toMechanicLinkValue();
   virtual const MechanicLinkValue* toMechanicLinkValue() const;
 
-  /// This is an attempt to seperate the coordinate system stuff away from
-  /// the reference frame handling.
+  /// The Coordinate system of this mechanic link
+  ///
+  /// The Coordinates position is the reference point of the reference frame
+  /// that moves with this mechanic link.
+  /// The spatial velocities, accelerations, forces and the inertia are all
+  /// based on this reference point.
   const CoordinateSystem& getCoordinateSystem() const
   { return mCoordinateSystem; }
   CoordinateSystem& getCoordinateSystem()
@@ -28,82 +33,149 @@
   void setCoordinateSystem(const CoordinateSystem& coordinateSystem)
   { mCoordinateSystem = coordinateSystem; }
 
+  /// The spatial velocity of this mechanic link
+  ///
+  /// The velocity is given in global coordinates and at this mechanic links
+  /// coordinate systems origin.
+  void setVelocity(const Vector6& velocity)
+  { mVelocity = velocity; }
+  const Vector6& getVelocity() const
+  { return mVelocity; }
 
-  const SpatialInertia& getInertia() const
-  { return mArticulatedInertia; }
-  void setInertia(const SpatialInertia& inertia)
-  { mArticulatedInertia = inertia; }
+  /// The spatial acceleration of this mechanic link
+  ///
+  /// The acceleration is given in global coordinates and at this mechanic links
+  /// coordinate systems origin.
+  void setAcceleration(const Vector6& acceleration)
+  { mAcceleration = acceleration; }
+  const Vector6& getAcceleration() const
+  { return mAcceleration; }
 
-  const Vector6& getForce() const
-  { return mArticulatedForce; }
-  void setForce(const Vector6& force)
-  { mArticulatedForce = force; }
+  /// The spatial force of this mechanic link
+  ///
+  /// The force is given in global coordinates and at this mechanic links
+  /// coordinate systems origin.
+  const Vector6& getSpatialForce() const
+  { return mForce; }
+  void setSpatialForce(const Vector6& force)
+  { mForce = force; }
 
+  /// The spatial inertia of this mechanic link
+  ///
+  /// The inertia is given in global coordinates and at this mechanic links
+  /// coordinate systems origin.
+  const SpatialInertia& getSpatialInertia() const
+  { return mInertia; }
+  void setSpatialInertia(const SpatialInertia& inertia)
+  { mInertia = inertia; }
 
-  void applyForce(const Vector6& force)
-  { mArticulatedForce -= force; }
-  void applyForce(const Vector3& position, const Vector6& force)
-  { applyForce(forceFrom(position, force)); }
-  void applyForce(const Vector3& force)
-  { applyForce(Vector6(Vector3::zeros(), force)); }
-  void applyForce(const Vector3& position, const Vector3& force)
-  { applyForce(forceFrom(position, force)); }
-  void applyTorque(const Vector3& torque)
-  { applyForce(Vector6(torque, Vector3::zeros())); }
 
-  void addForce(const Vector6& force)
-  { mArticulatedForce += force; }
-  void addInertia(const SpatialInertia& inertia)
-  { mArticulatedInertia += inertia; }
-
   /// Returns the coordinate system of link wrt this links coordinate system
   CoordinateSystem
   getRelativeCoordinateSystem(const MechanicLinkValue& link) const
   { return mCoordinateSystem.toLocal(link.mCoordinateSystem); }
 
-  void setLocalVelocity(const Vector6& velocity)
-  { mVelocity = mCoordinateSystem.rotToReference(velocity); }
-  Vector6 getLocalVelocity() const
-  { return mCoordinateSystem.rotToLocal(mVelocity); }
 
-  void setLocalAcceleration(const Vector6& acceleration)
-  { mAcceleration = mCoordinateSystem.rotToReference(acceleration); }
-  Vector6 getLocalAcceleration() const
-  { return mCoordinateSystem.rotToLocal(mAcceleration); }
+  /// Conveninent getters at different positions/coordinatesystems
+  Vector6 getSpatialVelocity(const Vector3& pos) const
+  { return motionTo(pos - mCoordinateSystem.getPosition(), getVelocity()); }
+  Vector6 getSpatialVelocity(const CoordinateSystem& cs) const
+  { return cs.rotToLocal(getSpatialVelocity(cs.getPosition())); }
 
+  Vector6 getSpatialAcceleration(const Vector3& pos) const
+  { return motionTo(pos - mCoordinateSystem.getPosition(), getAcceleration()); }
+  Vector6 getSpatialAcceleration(const CoordinateSystem& cs) const
+  { return cs.rotToLocal(getSpatialAcceleration(cs.getPosition())); }
 
-  void setVelocity(const Vector6& velocity)
-  { mVelocity = velocity; }
-  const Vector6& getVelocity() const
-  { return mVelocity; }
+  Vector6 getSpatialForce(const Vector3& pos) const
+  { return forceTo(pos - mCoordinateSystem.getPosition(), getSpatialForce()); }
+  Vector6 getSpatialForce(const CoordinateSystem& cs) const
+  { return cs.rotToLocal(getSpatialForce(cs.getPosition())); }
 
-  void setAcceleration(const Vector6& acceleration)
-  { mAcceleration = acceleration; }
-  const Vector6& getAcceleration() const
-  { return mAcceleration; }
+  SpatialInertia getSpatialInertia(const Vector3& pos) const
+  {
+    // is inertiaTo(pos - cs.getPosition(), ...)
+    return inertiaFrom(mCoordinateSystem.getPosition() - pos,
+                       getSpatialInertia());
+  }
+  SpatialInertia getSpatialInertia(const CoordinateSystem& cs) const
+  { return cs.rotToLocal(getSpatialInertia(cs.getPosition())); }
 
 
-  void setRelativeVelocity(const MechanicLinkValue& linkValue,
-                           const Vector6& velocity)
+  void applyForce(const Vector3& position, const Vector3& force)
   {
-    mArticulatedInertia = SpatialInertia::zeros();
-    mArticulatedForce = Vector6::zeros();
+    Vector3 positionDiff = position - mCoordinateSystem.getPosition();
+    mForce -= forceFrom(positionDiff, force);
+  }
+  void applyForce(const Vector3& position, const Vector6& force)
+  {
+    Vector3 positionDiff = position - mCoordinateSystem.getPosition();
+    mForce -= forceFrom(positionDiff, force);
+  }
+  void applyForce(const CoordinateSystem& cs, const Vector3& force)
+  {
+    Vector3 forceInGlobal = cs.rotToReference(force);
+    Vector3 positionDiff = cs.getPosition() - mCoordinateSystem.getPosition();
+    mForce -= forceFrom(positionDiff, forceInGlobal);
+  }
+  void applyForce(const CoordinateSystem& cs, const Vector6& force)
+  {
+    Vector6 forceInGlobal = cs.rotToReference(force);
+    Vector3 positionDiff = cs.getPosition() - mCoordinateSystem.getPosition();
+    mForce -= forceFrom(positionDiff, forceInGlobal);
+  }
 
-    Vector3 positionDiff = mCoordinateSystem.getPosition();
-    positionDiff -= linkValue.mCoordinateSystem.getPosition();
-    Vector6 parentVel = motionTo(positionDiff, linkValue.mVelocity);
-    mVelocity = mCoordinateSystem.rotToReference(velocity) + parentVel;
+
+  void addSpatialForce(const Vector3& position, const Vector6& force)
+  {
+    Vector3 offset = position - mCoordinateSystem.getPosition();
+    mForce += forceFrom(offset, force);
   }
-  void setBaseVelocity(const Vector3& baseAngularVel, const Vector6& velocity)
+  void addSpatialInertia(const Vector3& position, const SpatialInertia& inertia)
   {
-    mArticulatedInertia = SpatialInertia::zeros();
-    mArticulatedForce = Vector6::zeros();
+    if (position == mCoordinateSystem.getPosition()) {
+      mInertia += inertia;
+    } else {
+      Vector3 offset = position - mCoordinateSystem.getPosition();
+      mInertia += inertiaFrom(offset, inertia);
+    }
+  }
 
-    Vector3 referencePos = mCoordinateSystem.getPosition();
-    Vector6 parentVel = angularMotionTo(referencePos, baseAngularVel);
-    mVelocity = mCoordinateSystem.rotToReference(velocity) + parentVel;
+
+  SpatialInertia getLocalInertia() const
+  { return getSpatialInertia(mCoordinateSystem); }
+  Vector6 getLocalForce() const
+  { return getSpatialForce(mCoordinateSystem); }
+
+  void applyGlobalTorque(const Vector3& torque)
+  {
+    mForce -= Vector6(torque, Vector3::zeros());
   }
+  void applyGlobalForce(const Vector3& globalPosition, const Vector3& force)
+  {
+    Vector3 positionDiff = globalPosition - mCoordinateSystem.getPosition();
+    mForce -= forceFrom(positionDiff, force);
+  }
 
+  void applyLocalForce(const Vector6& force)
+  { mForce -= mCoordinateSystem.rotToReference(force); }
+  void applyLocalForce(const Vector3& position, const Vector6& force)
+  { applyLocalForce(forceFrom(position, force)); }
+  void applyLocalForce(const Vector3& force)
+  { applyLocalForce(Vector6(Vector3::zeros(), force)); }
+  void applyLocalForce(const Vector3& position, const Vector3& force)
+  { applyLocalForce(forceFrom(position, force)); }
+  void applyLocalTorque(const Vector3& torque)
+  { applyLocalForce(Vector6(torque, Vector3::zeros())); }
+
+  void setLocalVelocity(const Vector6& velocity)
+  { mVelocity = mCoordinateSystem.rotToReference(velocity); }
+  Vector6 getLocalVelocity() const
+  { return mCoordinateSystem.rotToLocal(mVelocity); }
+
+  Vector6 getLocalAcceleration() const
+  { return mCoordinateSystem.rotToLocal(mAcceleration); }
+
 protected:
   /// The local coordinate system of the mechanic link.
   CoordinateSystem mCoordinateSystem;
@@ -112,17 +184,27 @@
   /// measured in global coordinate systems coordinates.
   /// The spacial velocities pivot point is at the coordinate systems origin.
   Vector6 mVelocity;
+  // FIXME: make use of that!! Currently relative velocities do not work
+//   Vector6 mReferenceVelocity;
+
   /// The spatial acceleration at the origin of the coordinate system
   /// measured in global coordinate systems coordinates.
   /// The spacial velocities pivot point is at the coordinate systems origin.
   Vector6 mAcceleration;
 
-  // These are stored in local coordinates.
-  // FIXME: move them to global coordinates too
-  Vector6 mArticulatedForce;
-  SpatialInertia mArticulatedInertia;
+  /// The articulated force at the origin of the coordinate system
+  /// measured in global coordinate systems coordinates.
+  /// The articulated force pivot point is at the coordinate systems origin.
+  Vector6 mForce;
+
+  /// The articulated inertia at the origin of the coordinate system
+  /// measured in global coordinate systems coordinates.
+  /// The articulated inertia pivot point is at the coordinate systems origin.
+  SpatialInertia mInertia;
 };
 
+
+
 class ParentLink {
 public:
   ParentLink(MechanicLinkValue* mechanicLinkValue = 0) :
@@ -167,16 +249,28 @@
     return mMechanicLinkValue->getCoordinateSystem().getOrientation();
   }
 
-  Vector6 getLocalVelocityAtLink() const
+  Vector6 getVelocity(const Vector3& position) const
   {
     OpenFDMAssert(isConnected());
-    return mMechanicLinkValue->getLocalVelocity();
+    return mMechanicLinkValue->getSpatialVelocity(position);
   }
-  Vector6 getLocalAccelerationAtLink() const
+  Vector6 getVelocity(const CoordinateSystem& cs) const
   {
     OpenFDMAssert(isConnected());
-    return mMechanicLinkValue->getLocalAcceleration();
+    return mMechanicLinkValue->getSpatialVelocity(cs);
   }
+
+  Vector6 getAcceleration(const Vector3& position) const
+  {
+    OpenFDMAssert(isConnected());
+    return mMechanicLinkValue->getSpatialAcceleration(position);
+  }
+  Vector6 getAcceleration(const CoordinateSystem& cs) const
+  {
+    OpenFDMAssert(isConnected());
+    return mMechanicLinkValue->getSpatialAcceleration(cs);
+  }
+
   Vector6 getLocalVelocity() const
   {
     OpenFDMAssert(isConnected());
@@ -187,6 +281,10 @@
     OpenFDMAssert(isConnected());
     return motionTo(mLinkRelPos, mMechanicLinkValue->getLocalAcceleration());
   }
+  const Vector6& getAcceleration() const
+  { return mMechanicLinkValue->getAcceleration(); }
+  const Vector6& getVelocity() const
+  { return mMechanicLinkValue->getVelocity(); }
 
   void setDesignPosition(const Vector3& position)
   {
@@ -198,29 +296,29 @@
   void applyBodyForce(const Vector6& force)
   {
     OpenFDMAssert(isConnected());
-    mMechanicLinkValue->applyForce(mLinkRelPos, force);
+    mMechanicLinkValue->applyLocalForce(mLinkRelPos, force);
   }
   void applyBodyForce(const Vector3& bodyPosition, const Vector6& force)
   {
     OpenFDMAssert(isConnected());
-    mMechanicLinkValue->applyForce(bodyPosition + mLinkRelPos, force);
+    mMechanicLinkValue->applyLocalForce(bodyPosition + mLinkRelPos, force);
   }
   
   void applyBodyForce(const Vector3& force)
   {
     OpenFDMAssert(isConnected());
-    mMechanicLinkValue->applyForce(mLinkRelPos, force);
+    mMechanicLinkValue->applyLocalForce(mLinkRelPos, force);
   }
   void applyBodyForce(const Vector3& bodyPosition, const Vector3& force)
   {
     OpenFDMAssert(isConnected());
-    mMechanicLinkValue->applyForce(bodyPosition + mLinkRelPos, force);
+    mMechanicLinkValue->applyLocalForce(bodyPosition + mLinkRelPos, force);
   }
   
   void applyBodyTorque(const Vector3& torque)
   {
     OpenFDMAssert(isConnected());
-    mMechanicLinkValue->applyTorque(torque);
+    mMechanicLinkValue->applyLocalTorque(torque);
   }
 
 
@@ -228,41 +326,53 @@
   {
     OpenFDMAssert(isConnected());
     const CoordinateSystem& cs = mMechanicLinkValue->getCoordinateSystem();
-    Vector3 bodyForce = cs.rotToLocal(force);
-    mMechanicLinkValue->applyForce(mLinkRelPos, bodyForce);
+    mMechanicLinkValue->applyGlobalForce(cs.toReference(mLinkRelPos), force);
   }
-  void applyGlobalForce(const Vector3& bodyPosition, const Vector3& force)
+
+  void applyGlobalTorque(const Vector3& torque)
   {
     OpenFDMAssert(isConnected());
-    const CoordinateSystem& cs = mMechanicLinkValue->getCoordinateSystem();
-    Vector3 bodyForce = cs.rotToLocal(force);
-    mMechanicLinkValue->applyForce(bodyPosition + mLinkRelPos, bodyForce);
+    mMechanicLinkValue->applyGlobalTorque(torque);
   }
 
-  void applyGlobalTorque(const Vector3& torque)
+  void applyLocalForceAtLink(const Vector6& force)
   {
     OpenFDMAssert(isConnected());
-    const CoordinateSystem& cs = mMechanicLinkValue->getCoordinateSystem();
-    mMechanicLinkValue->applyTorque(cs.rotToLocal(torque));
+    mMechanicLinkValue->applyLocalForce(force);
   }
 
-
-  void applyForceAtLink(const Vector6& force)
+  void applyForce(const Vector3& position, const Vector3& force)
   {
     OpenFDMAssert(isConnected());
-    mMechanicLinkValue->applyForce(force);
+    mMechanicLinkValue->applyForce(position, force);
   }
-  void addForceAtLink(const Vector6& force)
+  void applyForce(const CoordinateSystem& cs, const Vector3& force)
   {
     OpenFDMAssert(isConnected());
-    mMechanicLinkValue->addForce(force);
+    mMechanicLinkValue->applyForce(cs, force);
   }
-  void addInertiaAtLink(const SpatialInertia& inertia)
+  void applyForce(const Vector3& position, const Vector6& force)
   {
     OpenFDMAssert(isConnected());
-    mMechanicLinkValue->addInertia(inertia);
+    mMechanicLinkValue->applyForce(position, force);
   }
+  void applyForce(const CoordinateSystem& cs, const Vector6& force)
+  {
+    OpenFDMAssert(isConnected());
+    mMechanicLinkValue->applyForce(cs, force);
+  }
 
+  void addSpatialForce(const Vector3& position, const Vector6& force)
+  {
+    OpenFDMAssert(isConnected());
+    mMechanicLinkValue->addSpatialForce(position, force);
+  }
+  void addSpatialInertia(const Vector3& position, const SpatialInertia& inertia)
+  {
+    OpenFDMAssert(isConnected());
+    mMechanicLinkValue->addSpatialInertia(position, inertia);
+  }
+
 private:
   SharedPtr<MechanicLinkValue> mMechanicLinkValue;
   Vector3 mLinkRelPos;
@@ -280,35 +390,30 @@
   void setDesignPosition(const Vector3& position)
   { mMechanicLinkValue->setCoordinateSystem(CoordinateSystem(position)); }
 
-  void setLocalAcceleration(const Vector6& accel)
-  { mMechanicLinkValue->setLocalAcceleration(accel); }
-  Vector6 getLocalAcceleration() const
-  { return mMechanicLinkValue->getLocalAcceleration(); }
-
   void setAcceleration(const Vector6& accel)
   { mMechanicLinkValue->setAcceleration(accel); }
   const Vector6& getAcceleration() const
   { return mMechanicLinkValue->getAcceleration(); }
 
-  void setBaseVelocity(const Vector3& angularBaseVel, const Vector6& velocity)
-  { mMechanicLinkValue->setBaseVelocity(angularBaseVel, velocity); }
+  void setVelocity(const Vector6& velocity)
+  { mMechanicLinkValue->setVelocity(velocity); }
+  const Vector6& getVelocity() const
+  { return mMechanicLinkValue->getVelocity(); }
 
-  void setRelativeVelocity(const ParentLink& parentLink,
-                           const Vector6& velocity)
-  {
-    const MechanicLinkValue& link = parentLink.getMechanicLinkValue();
-    mMechanicLinkValue->setRelativeVelocity(link, velocity);
-  }
-
   void setCoordinateSystem(const CoordinateSystem& coordinateSystem)
   { return mMechanicLinkValue->setCoordinateSystem(coordinateSystem); }
   const CoordinateSystem& getCoordinateSystem() const
   { return mMechanicLinkValue->getCoordinateSystem(); }
 
-  const Vector6& getForce() const
-  { return mMechanicLinkValue->getForce(); }
-  const SpatialInertia& getInertia() const
-  { return mMechanicLinkValue->getInertia(); }
+  void setSpatialForce(const Vector6& force)
+  { return mMechanicLinkValue->setSpatialForce(force); }
+  const Vector6& getSpatialForce() const
+  { return mMechanicLinkValue->getSpatialForce(); }
+
+  void setSpatialInertia(const SpatialInertia& inertia) const
+  { return mMechanicLinkValue->setSpatialInertia(inertia); }
+  const SpatialInertia& getSpatialInertia() const
+  { return mMechanicLinkValue->getSpatialInertia(); }
  
 private:
   SharedPtr<MechanicLinkValue> mMechanicLinkValue;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJoint.cpp	2009-07-17 20:18:57 UTC (rev 1012)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJoint.cpp	2009-07-17 21:49:55 UTC (rev 1013)
@@ -49,10 +49,10 @@
   }
   virtual void accelerations(const Task& task)
   {
-    SpatialInertia inertia = mChildLink.getInertia();
-    Vector6 force = -mChildLink.getForce();
+    const SpatialInertia& inertia = mChildLink.getSpatialInertia();
+    Vector6 force = -mChildLink.getSpatialForce();
     Vector6 spatialAcceleration = solve(inertia, force);
-    mChildLink.setLocalAcceleration(spatialAcceleration);
+    mChildLink.setAcceleration(spatialAcceleration);
   }
   
   virtual void derivative(const Task& task)
@@ -172,14 +172,19 @@
                           const ContinousStateValueVector& continousState,
                           ChildLink& childLink) const
 {
-  Vector3 angularBaseVelocity = environment.getAngularVelocity(task.getTime());
-
   Vector3 position = continousState[*mPositionStateInfo];
   Quaternion orientation = continousState[*mOrientationStateInfo];
   Vector6 velocity = continousState[*mVelocityStateInfo];
 
   childLink.setCoordinateSystem(CoordinateSystem(position, orientation));
-  childLink.setBaseVelocity(angularBaseVelocity, velocity);
+
+  velocity = childLink.getCoordinateSystem().rotToReference(velocity);
+  Vector3 angularBaseVelocity = environment.getAngularVelocity(task.getTime());
+  Vector6 baseVelocity(angularMotionTo(position, angularBaseVelocity));
+  childLink.setVelocity(baseVelocity + velocity);
+
+  childLink.setSpatialForce(Vector6::zeros());
+  childLink.setSpatialInertia(SpatialInertia::zeros());
 }
 
 void
@@ -189,6 +194,8 @@
                             const ChildLink& childLink,
                             ContinousStateValueVector& derivatives) const
 {
+  const CoordinateSystem& cs = childLink.getCoordinateSystem();
+
   Vector3 position = continousState[*mPositionStateInfo];
   Quaternion orientation = continousState[*mOrientationStateInfo];
   Vector6 velocity = continousState[*mVelocityStateInfo];
@@ -207,23 +214,20 @@
   // spatial acceleration and subtract the inertial base velocity and the
   // derivative of the 'joint matrix'.
   Vector6 spatialAcceleration = environment.getAcceleration(task.getTime());
-//       pivel = mRelativeCoordinateSystem.motionToLocal(pivel);
-  spatialAcceleration = motionTo(position, orientation, spatialAcceleration);
+  spatialAcceleration = motionTo(position, spatialAcceleration);
 
   Vector3 angularBaseVelocity = environment.getAngularVelocity(task.getTime());
-//       Vector6 pivel = mParentLink.getSpVelAtLink();
-  Vector6 pivel(angularBaseVelocity, Vector3::zeros());
-//       pivel = mRelativeCoordinateSystem.motionToLocal(pivel);
-  Vector6 relVel = velocity;
-  Vector6 Hdot = Vector6(cross(pivel.getAngular(), relVel.getAngular()),
-                         cross(pivel.getAngular(), relVel.getLinear()) + 
-                         cross(pivel.getLinear(), relVel.getAngular()));
+  Vector6 pivel(angularMotionTo(position, angularBaseVelocity));
+  Vector6 Hdot = Vector6(cross(pivel.getAngular(), velocity.getAngular()),
+                         cross(pivel.getAngular(), velocity.getLinear()) + 
+                         cross(pivel.getLinear(), velocity.getAngular()));
 
-  Vector6 velDeriv = childLink.getLocalAcceleration() - spatialAcceleration - Hdot;
+  Vector6 velDeriv = childLink.getAcceleration()
+    - spatialAcceleration - Hdot;
 
   derivatives[*mPositionStateInfo] = pDot;
   derivatives[*mOrientationStateInfo] = qderiv;
-  derivatives[*mVelocityStateInfo] = velDeriv;
+  derivatives[*mVelocityStateInfo] = cs.rotToLocal(velDeriv);
 }
 
 } // namespace OpenFDM



From frohlich at mail.berlios.de  Mon Jul 20 18:26:47 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Mon, 20 Jul 2009 18:26:47 +0200
Subject: [OpenFDM-svn] r1014 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200907201626.n6KGQlol027231@sheep.berlios.de>

Author: frohlich
Date: 2009-07-20 18:26:46 +0200 (Mon, 20 Jul 2009)
New Revision: 1014

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.h
Log:
Remove unused fwd decl.

M    MechanicNode.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.h	2009-07-17 21:49:55 UTC (rev 1013)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicNode.h	2009-07-20 16:26:46 UTC (rev 1014)
@@ -39,8 +39,6 @@
 // TODO:
 // * Remove AbstractNodeContext ...
 
-class MechanicContext;
-
 class MechanicNode : public LeafNode {
   OPENFDM_OBJECT(MechanicNode, LeafNode);
 public:



From frohlich at mail.berlios.de  Mon Jul 20 19:23:11 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Mon, 20 Jul 2009 19:23:11 +0200
Subject: [OpenFDM-svn] r1015 -
	branches/OpenFDM-StateSeparation/src/OpenFDM/LinAlg
Message-ID: <200907201723.n6KHNBGl018017@sheep.berlios.de>

Author: frohlich
Date: 2009-07-20 19:23:10 +0200 (Mon, 20 Jul 2009)
New Revision: 1015

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/LinAlg/Algorithm.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/LinAlg/Container.h
Log:
Remove last occurances of real_type in template code.
Add a new SpatialInertia constructor.

M    LinAlg/Container.h
M    LinAlg/Algorithm.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/LinAlg/Algorithm.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/LinAlg/Algorithm.h	2009-07-20 16:26:46 UTC (rev 1014)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/LinAlg/Algorithm.h	2009-07-20 17:23:10 UTC (rev 1015)
@@ -133,7 +133,7 @@
 {
   typedef typename Impl::value_type value_type;
   value_type nrm = norm(v);
-  if (fabs(nrm) <= Limits<real_type>::safe_min())
+  if (fabs(nrm) <= Limits<value_type>::safe_min())
     return Vector<value_type,n>(v);
   else
     return Vector<value_type,n>((1/nrm)*v);

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/LinAlg/Container.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/LinAlg/Container.h	2009-07-20 16:26:46 UTC (rev 1014)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/LinAlg/Container.h	2009-07-20 17:23:10 UTC (rev 1015)
@@ -864,7 +864,7 @@
   Vector1(void)
   { }
   OpenFDM_FORCE_INLINE
-  Vector1(T v1)
+  Vector1(const T& v1)
   { (*this)(0) = v1; }
   OpenFDM_FORCE_INLINE
   Vector1(const Vector1& v)
@@ -880,10 +880,10 @@
   { }
 
   OpenFDM_FORCE_INLINE
-  const real_type& x(void) const
+  const T& x(void) const
   { return Vector<T,1>::operator()(0); }
   OpenFDM_FORCE_INLINE
-  real_type& x(void)
+  T& x(void)
   { return Vector<T,1>::operator()(0); }
 };
 
@@ -895,7 +895,7 @@
   Vector2(void)
   { }
   OpenFDM_FORCE_INLINE
-  Vector2(T v1, T v2)
+  Vector2(const T& v1, const T& v2)
   { (*this)(0) = v1; (*this)(1) = v2; }
   OpenFDM_FORCE_INLINE
   Vector2(const Vector2& v)
@@ -916,16 +916,16 @@
   { }
 
   OpenFDM_FORCE_INLINE
-  const real_type& x(void) const
+  const T& x(void) const
   { return Vector<T,2>::operator()(0); }
   OpenFDM_FORCE_INLINE
-  real_type& x(void)
+  T& x(void)
   { return Vector<T,2>::operator()(0); }
   OpenFDM_FORCE_INLINE
-  const real_type& y(void) const
+  const T& y(void) const
   { return Vector<T,2>::operator()(1); }
   OpenFDM_FORCE_INLINE
-  real_type& y(void)
+  T& y(void)
   { return Vector<T,2>::operator()(1); }
 };
 
@@ -937,7 +937,7 @@
   Vector3(void)
   { }
   OpenFDM_FORCE_INLINE
-  Vector3(T v1, T v2, T v3)
+  Vector3(const T& v1, const T& v2, const T& v3)
   { (*this)(0) = v1; (*this)(1) = v2; (*this)(2) = v3; }
   OpenFDM_FORCE_INLINE
   Vector3(const Vector3& v)
@@ -958,22 +958,22 @@
   { }
 
   OpenFDM_FORCE_INLINE
-  const real_type& x(void) const
+  const T& x(void) const
   { return Vector<T,3>::operator()(0); }
   OpenFDM_FORCE_INLINE
-  real_type& x(void)
+  T& x(void)
   { return Vector<T,3>::operator()(0); }
   OpenFDM_FORCE_INLINE
-  const real_type& y(void) const
+  const T& y(void) const
   { return Vector<T,3>::operator()(1); }
   OpenFDM_FORCE_INLINE
-  real_type& y(void)
+  T& y(void)
   { return Vector<T,3>::operator()(1); }
   OpenFDM_FORCE_INLINE
-  const real_type& z(void) const
+  const T& z(void) const
   { return Vector<T,3>::operator()(2); }
   OpenFDM_FORCE_INLINE
-  real_type& z(void)
+  T& z(void)
   { return Vector<T,3>::operator()(2); }
 };
 
@@ -985,7 +985,7 @@
   Vector4(void)
   { }
   OpenFDM_FORCE_INLINE
-  Vector4(T v1, T v2, T v3, T v4)
+  Vector4(const T& v1, const T& v2, const T& v3, const T& v4)
   { (*this)(0) = v1; (*this)(1) = v2; (*this)(2) = v3; (*this)(3) = v4; }
   OpenFDM_FORCE_INLINE
   Vector4(const Vector4& v)
@@ -1014,7 +1014,7 @@
   Vector6(void)
   { }
   OpenFDM_FORCE_INLINE
-  Vector6(T v1, T v2, T v3, T v4, T v5, T v6)
+  Vector6(const T& v1, const T& v2, const T& v3, const T& v4, const T& v5, const T& v6)
   {
     (*this)(0) = v1; (*this)(1) = v2; (*this)(2) = v3;
     (*this)(3) = v4; (*this)(4) = v5; (*this)(5) = v6;
@@ -1066,7 +1066,7 @@
   Matrix22(void)
   { }
   OpenFDM_FORCE_INLINE
-  Matrix22(T m11, T m12, T m21, T m22)
+  Matrix22(const T& m11, const T& m12, const T& m21, const T& m22)
   {
     (*this)(0, 0) = m11; (*this)(0, 1) = m12;
     (*this)(1, 0) = m21; (*this)(1, 1) = m22;
@@ -1108,7 +1108,7 @@
   Matrix33(void)
   { }
   OpenFDM_FORCE_INLINE
-  Matrix33(T m11, T m12, T m13, T m21, T m22, T m23, T m31, T m32, T m33)
+  Matrix33(const T& m11, const T& m12, const T& m13, const T& m21, const T& m22, const T& m23, const T& m31, const T& m32, const T& m33)
   {
     (*this)(0, 0) = m11; (*this)(0, 1) = m12; (*this)(0, 2) = m13;
     (*this)(1, 0) = m21; (*this)(1, 1) = m22; (*this)(1, 2) = m23;
@@ -1151,7 +1151,7 @@
   SymMatrix3(void)
   { }
   OpenFDM_FORCE_INLINE
-  SymMatrix3(T S11, T S21, T S31, T S22, T S32, T S33)
+  SymMatrix3(const T& S11, const T& S21, const T& S31, const T& S22, const T& S32, const T& S33)
   {
     (*this)(0, 0) = S11;
     (*this)(1, 0) = S21; (*this)(1, 1) = S22;
@@ -1173,6 +1173,40 @@
   OpenFDM_FORCE_INLINE
   ~SymMatrix3(void)
   { }
+
+  // Compute the inertia of a solid cylinder aligned along the z axis with
+  // tha given radius length and mass.
+  OpenFDM_FORCE_INLINE
+  static SymMatrix3
+  cylinderInertia(const T& mass, const T& length, const T& radius)
+  {
+    T r2 = radius*radius;
+    T Ixx = T(0.25)*mass*(r2 + T(1)/3*length*length);
+    T Izz = T(0.5)*mass*r2;
+    return SymMatrix<T,3>(Ixx, 0, 0, Ixx, 0, Izz);
+  }
+  
+  // Compute the inertia of a solid quad with the given lengths and mass.
+  OpenFDM_FORCE_INLINE
+  static SymMatrix3
+  quadInertia(const T& mass, const T& x, const T& y, const T& z)
+  {
+    T x2 = 1/T(12)*mass*x*x;
+    T y2 = 1/T(12)*mass*y*y;
+    T z2 = 1/T(12)*mass*z*z;
+    return SymMatrix<T,3>(y2+z2, 0, 0, x2+z2, 0, x2+y2);
+  }
+
+  // Compute the inertia of a solid ellipsoid with the given semiaxis and mass.
+  OpenFDM_FORCE_INLINE
+  static SymMatrix3
+  ellipsoidInertia(const T& mass, const T& x, const T& y, const T& z)
+  {
+    T x2 = 1/T(5)*mass*x*x;
+    T y2 = 1/T(5)*mass*y*y;
+    T z2 = 1/T(5)*mass*z*z;
+    return SymMatrix<T,3>(y2+z2, 0, 0, x2+z2, 0, x2+y2);
+  }
 };
 
 template<typename T>
@@ -1183,7 +1217,7 @@
   SymMatrix6(void)
   { }
   OpenFDM_FORCE_INLINE
-  SymMatrix6(T m)
+  SymMatrix6(const T& m)
   {
     (*this)(0,0) = 0;
     (*this)(1,0) = 0; (*this)(1,1) = 0;
@@ -1196,7 +1230,7 @@
     (*this)(5,3) = 0; (*this)(5,4) = 0; (*this)(5,5) = m;
   }
   OpenFDM_FORCE_INLINE
-  SymMatrix6(const SymMatrix<T,3>& I, T m)
+  SymMatrix6(const SymMatrix<T,3>& I, const T& m)
   {
     (*this)(0,0) = I(0,0);
     (*this)(1,0) = I(1,0); (*this)(1,1) = I(1,1);
@@ -1209,23 +1243,53 @@
     (*this)(5,3) = 0;      (*this)(5,4) = 0;      (*this)(5,5) = m;
   }
   OpenFDM_FORCE_INLINE
-  SymMatrix6(T S11,
-             T S21, T S22,
-             T S31, T S32, T S33,
-             T S41, T S42, T S43, T S44,
-             T S51, T S52, T S53, T S54, T S55,
-             T S61, T S62, T S63, T S64, T S65, T S66)
+  SymMatrix6(const Matrix<T,3,1>& p, const SymMatrix<T,3>& I, const T& m)
   {
-    (*this)(0,0) = S11;
-    (*this)(1,0) = S21; (*this)(1,1) = S22;
-    (*this)(2,0) = S31; (*this)(2,1) = S32; (*this)(2,2) = S33;
-    (*this)(3,0) = S41; (*this)(3,1) = S42; (*this)(3,2) = S43;
-    (*this)(3,3) = S44;
-    (*this)(4,0) = S51; (*this)(4,1) = S52; (*this)(4,2) = S53;
-    (*this)(4,3) = S54; (*this)(4,4) = S55;
-    (*this)(5,0) = S61; (*this)(5,1) = S62; (*this)(5,2) = S63;
-    (*this)(5,3) = S64; (*this)(5,4) = S65; (*this)(5,5) = S66;
+    (*this)(0,0) = I(0,0) + m*(p(1,0)*p(1,0) + p(2,0)*p(2,0));
+
+    (*this)(1,0) = I(1,0) - m*p(1,0)*p(0,0);
+    (*this)(1,1) = I(1,1) + m*(p(0,0)*p(0,0) + p(2,0)*p(2,0));
+
+    (*this)(2,0) = I(2,0) - m*p(2,0)*p(0,0);
+    (*this)(2,1) = I(2,1) - m*p(2,0)*p(1,0);
+    (*this)(2,2) = I(2,2) + m*(p(0,0)*p(0,0) + p(1,0)*p(1,0));
+
+    (*this)(3,0) = 0;
+    (*this)(3,1) = m*p(2,0);
+    (*this)(3,2) = -m*p(1,0);
+    (*this)(3,3) = m;
+
+    (*this)(4,0) = -m*p(2,0);
+    (*this)(4,1) = 0;
+    (*this)(4,2) = m*p(0,0);
+    (*this)(4,3) = 0;
+    (*this)(4,4) = m;
+
+    (*this)(5,0) = m*p(1,0);
+    (*this)(5,1) = -m*p(0,0);
+    (*this)(5,2) = 0;
+    (*this)(5,3) = 0;
+    (*this)(5,4) = 0;
+    (*this)(5,5) = m;
   }
+//   OpenFDM_FORCE_INLINE
+//   SymMatrix6(const T& S11,
+//              const T& S21, const T& S22,
+//              const T& S31, const T& S32, const T& S33,
+//              const T& S41, const T& S42, const T& S43, const T& S44,
+//              const T& S51, const T& S52, const T& S53, const T& S54, const T& S55,
+//              const T& S61, const T& S62, const T& S63, const T& S64, const T& S65, const T& S66)
+//   {
+//     (*this)(0,0) = S11;
+//     (*this)(1,0) = S21; (*this)(1,1) = S22;
+//     (*this)(2,0) = S31; (*this)(2,1) = S32; (*this)(2,2) = S33;
+//     (*this)(3,0) = S41; (*this)(3,1) = S42; (*this)(3,2) = S43;
+//     (*this)(3,3) = S44;
+//     (*this)(4,0) = S51; (*this)(4,1) = S52; (*this)(4,2) = S53;
+//     (*this)(4,3) = S54; (*this)(4,4) = S55;
+//     (*this)(5,0) = S61; (*this)(5,1) = S62; (*this)(5,2) = S63;
+//     (*this)(5,3) = S64; (*this)(5,4) = S65; (*this)(5,5) = S66;
+//   }
   OpenFDM_FORCE_INLINE
   SymMatrix6(const SymMatrix<T,6>& S)
     : SymMatrix<T,6>(S)
@@ -1247,42 +1311,6 @@
   static SymMatrix6 zeros(void)
   { return SymMatrix6(Zeros<T,6,6>(6,6)); }
 
-  // Compute the inertia of a solid cylinder aligned along the z axis with
-  // tha given radius length and mass.
-  OpenFDM_FORCE_INLINE
-  static SymMatrix6
-  cylinderInertia(real_type mass, real_type length, real_type radius)
-  {
-    real_type r2 = radius*radius;
-    real_type Ixx = 0.25*mass*(r2 + real_type(1)/3*length*length);
-    real_type Izz = 0.5*mass*r2;
-    SymMatrix<T,3> I(Ixx, 0, 0, Ixx, 0, Izz);
-    return SymMatrix6(I, mass);
-  }
-  
-  // Compute the inertia of a solid quad with the given lengths and mass.
-  OpenFDM_FORCE_INLINE
-  static SymMatrix6
-  quadInertia(real_type mass, real_type x, real_type y, real_type z)
-  {
-    real_type x2 = (1.0/12.0)*mass*x*x;
-    real_type y2 = (1.0/12.0)*mass*y*y;
-    real_type z2 = (1.0/12.0)*mass*z*z;
-    SymMatrix<T,3> I(y2+z2, 0, 0, x2+z2, 0, x2+y2);
-    return SymMatrix6(I, mass);
-  }
-
-  // Compute the inertia of a solid ellipsoid with the given semiaxis and mass.
-  OpenFDM_FORCE_INLINE
-  static SymMatrix6
-  ellipsoidInertia(real_type mass, real_type x, real_type y, real_type z)
-  {
-    real_type x2 = (1.0/5.0)*mass*x*x;
-    real_type y2 = (1.0/5.0)*mass*y*y;
-    real_type z2 = (1.0/5.0)*mass*z*z;
-    SymMatrix<T,3> I(y2+z2, 0, 0, x2+z2, 0, x2+y2);
-    return SymMatrix6(I, mass);
-  }
 };
 
 } // namespace LinAlg



From frohlich at mail.berlios.de  Mon Jul 20 20:17:31 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Mon, 20 Jul 2009 20:17:31 +0200
Subject: [OpenFDM-svn] r1016 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200907201817.n6KIHV2O022386@sheep.berlios.de>

Author: frohlich
Date: 2009-07-20 20:17:30 +0200 (Mon, 20 Jul 2009)
New Revision: 1016

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Mass.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.h
Log:
Make use of the block diagonal structure of a local inertia matrix.

M    src/OpenFDM/Mass.cpp
M    src/OpenFDM/MechanicLinkValue.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Mass.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Mass.cpp	2009-07-20 17:23:10 UTC (rev 1015)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Mass.cpp	2009-07-20 18:17:30 UTC (rev 1016)
@@ -36,17 +36,20 @@
   {
     CoordinateSystem cs = getLink().getCoordinateSystem();
 
-    SpatialInertia I(cs.rotToReference(mMass->getInertia()), mMass->getMass());
+    // The inertia rotated to global axis
+    InertiaMatrix I(cs.rotToReference(mMass->getInertia()));
 
     // Contribute the inerita
-    getLink().addSpatialInertia(cs.getPosition(), I);
+    getLink().addInertia(cs.getPosition(), I, mMass->getMass());
 
     // Each inertia has a contribution to the spatial bias force.
     // This part is handled here.
     Vector6 v = getLink().getVelocity(cs.getPosition());
-    Vector6 Iv = I*v;
-    Vector6 vIv = Vector6(cross(v.getAngular(), Iv.getAngular()) +
-                          cross(v.getLinear(), Iv.getLinear()),
+    Vector6 Iv = Vector6(I*v.getAngular(), mMass->getMass()*v.getLinear());
+    Vector6 vIv = Vector6(cross(v.getAngular(), Iv.getAngular())
+                          /* Not needed since Iv.getLinear() is parallel to
+                             v.getLinear(), so the cross product is zero
+                          + cross(v.getLinear(), Iv.getLinear())*/,
                           cross(v.getAngular(), Iv.getLinear()));
     getLink().addSpatialForce(cs.getPosition(), vIv);
 

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.h	2009-07-20 17:23:10 UTC (rev 1015)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.h	2009-07-20 18:17:30 UTC (rev 1016)
@@ -176,6 +176,13 @@
   Vector6 getLocalAcceleration() const
   { return mCoordinateSystem.rotToLocal(mAcceleration); }
 
+  void addInertia(const Vector3& position,
+                  const InertiaMatrix& inertia, const real_type& mass)
+  {
+    Vector3 offset = position - mCoordinateSystem.getPosition();
+    mInertia += SpatialInertia(offset, inertia, mass);
+  }
+
 protected:
   /// The local coordinate system of the mechanic link.
   CoordinateSystem mCoordinateSystem;
@@ -372,6 +379,12 @@
     OpenFDMAssert(isConnected());
     mMechanicLinkValue->addSpatialInertia(position, inertia);
   }
+  void addInertia(const Vector3& position,
+                  const InertiaMatrix& inertia, const real_type& mass)
+  {
+    OpenFDMAssert(isConnected());
+    mMechanicLinkValue->addInertia(position, inertia, mass);
+  }
 
 private:
   SharedPtr<MechanicLinkValue> mMechanicLinkValue;



From frohlich at mail.berlios.de  Mon Jul 20 20:39:03 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Mon, 20 Jul 2009 20:39:03 +0200
Subject: [OpenFDM-svn] r1017 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200907201839.n6KId3u3024812@sheep.berlios.de>

Author: frohlich
Date: 2009-07-20 20:39:01 +0200 (Mon, 20 Jul 2009)
New Revision: 1017

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJoint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Mass.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJoint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/SystemOutput.cpp
Log:
Distinguish between the global reference frame and the
inertial reference frame.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h	2009-07-20 18:17:30 UTC (rev 1016)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h	2009-07-20 18:39:01 UTC (rev 1017)
@@ -152,6 +152,10 @@
       Vector6 relVel = mJointMatrix*velocity;
       mChildLink.setVelocity(parentSpVel + relVel);
 
+      Vector6 parentInVel = mParentLink.getInertialVelocity();
+      parentInVel = motionTo(positionDifference, parentInVel);
+      mChildLink.setInertialVelocity(parentInVel + relVel);
+
       /**
          This is the cross product of the inertial spatial velocity
          vector with the relative spatial velocity vector (motion type
@@ -162,9 +166,9 @@
          transformed spatial velocity of the parent frame cross the
          relative velocity.
       */
-      mHdot = Vector6(cross(parentSpVel.getAngular(), relVel.getAngular()),
-                      cross(parentSpVel.getAngular(), relVel.getLinear()) + 
-                      cross(parentSpVel.getLinear(), relVel.getAngular()));
+      mHdot = Vector6(cross(parentInVel.getAngular(), relVel.getAngular()),
+                      cross(parentInVel.getAngular(), relVel.getLinear()) + 
+                      cross(parentInVel.getLinear(), relVel.getAngular()));
 
 
       mChildLink.setSpatialForce(Vector6::zeros());

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJoint.cpp	2009-07-20 18:17:30 UTC (rev 1016)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJoint.cpp	2009-07-20 18:39:01 UTC (rev 1017)
@@ -44,7 +44,8 @@
                               mFixedRootJoint->mRootOrientation);
     mChildLink.setCoordinateSystem(coordSys);
     Vector6 vel = angularMotionTo(mFixedRootJoint->mRootPosition, angularVel);
-    mChildLink.setVelocity(vel);
+    mChildLink.setVelocity(Vector6::zeros());
+    mChildLink.setInertialVelocity(vel);
 
     mChildLink.setSpatialForce(Vector6::zeros());
     mChildLink.setSpatialInertia(SpatialInertia::zeros());

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Mass.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Mass.cpp	2009-07-20 18:17:30 UTC (rev 1016)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Mass.cpp	2009-07-20 18:39:01 UTC (rev 1017)
@@ -44,7 +44,7 @@
 
     // Each inertia has a contribution to the spatial bias force.
     // This part is handled here.
-    Vector6 v = getLink().getVelocity(cs.getPosition());
+    Vector6 v = getLink().getInertialVelocity(cs.getPosition());
     Vector6 Iv = Vector6(I*v.getAngular(), mMass->getMass()*v.getLinear());
     Vector6 vIv = Vector6(cross(v.getAngular(), Iv.getAngular())
                           /* Not needed since Iv.getLinear() is parallel to

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.cpp	2009-07-20 18:17:30 UTC (rev 1016)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.cpp	2009-07-20 18:39:01 UTC (rev 1017)
@@ -8,6 +8,7 @@
 
 MechanicLinkValue::MechanicLinkValue() :
   mVelocity(Vector6::zeros()),
+  mInertialVelocity(Vector6::zeros()),
   mAcceleration(Vector6::zeros()),
   mForce(Vector6::zeros()),
   mInertia(SpatialInertia::zeros())

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.h	2009-07-20 18:17:30 UTC (rev 1016)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.h	2009-07-20 18:39:01 UTC (rev 1017)
@@ -42,6 +42,11 @@
   const Vector6& getVelocity() const
   { return mVelocity; }
 
+  void setInertialVelocity(const Vector6& inertialVelocity)
+  { mInertialVelocity = inertialVelocity; }
+  const Vector6& getInertialVelocity() const
+  { return mInertialVelocity; }
+
   /// The spatial acceleration of this mechanic link
   ///
   /// The acceleration is given in global coordinates and at this mechanic links
@@ -82,6 +87,11 @@
   Vector6 getSpatialVelocity(const CoordinateSystem& cs) const
   { return cs.rotToLocal(getSpatialVelocity(cs.getPosition())); }
 
+  Vector6 getInertialVelocity(const Vector3& pos) const
+  { return motionTo(pos - mCoordinateSystem.getPosition(), getInertialVelocity()); }
+  Vector6 getInertialVelocity(const CoordinateSystem& cs) const
+  { return cs.rotToLocal(getInertialVelocity(cs.getPosition())); }
+
   Vector6 getSpatialAcceleration(const Vector3& pos) const
   { return motionTo(pos - mCoordinateSystem.getPosition(), getAcceleration()); }
   Vector6 getSpatialAcceleration(const CoordinateSystem& cs) const
@@ -191,8 +201,8 @@
   /// measured in global coordinate systems coordinates.
   /// The spacial velocities pivot point is at the coordinate systems origin.
   Vector6 mVelocity;
-  // FIXME: make use of that!! Currently relative velocities do not work
-//   Vector6 mReferenceVelocity;
+  /// Inertial velocity
+  Vector6 mInertialVelocity;
 
   /// The spatial acceleration at the origin of the coordinate system
   /// measured in global coordinate systems coordinates.
@@ -267,6 +277,17 @@
     return mMechanicLinkValue->getSpatialVelocity(cs);
   }
 
+  Vector6 getInertialVelocity(const Vector3& position) const
+  {
+    OpenFDMAssert(isConnected());
+    return mMechanicLinkValue->getInertialVelocity(position);
+  }
+  Vector6 getInertialVelocity(const CoordinateSystem& cs) const
+  {
+    OpenFDMAssert(isConnected());
+    return mMechanicLinkValue->getInertialVelocity(cs);
+  }
+
   Vector6 getAcceleration(const Vector3& position) const
   {
     OpenFDMAssert(isConnected());
@@ -292,6 +313,8 @@
   { return mMechanicLinkValue->getAcceleration(); }
   const Vector6& getVelocity() const
   { return mMechanicLinkValue->getVelocity(); }
+  const Vector6& getInertialVelocity() const
+  { return mMechanicLinkValue->getInertialVelocity(); }
 
   void setDesignPosition(const Vector3& position)
   {
@@ -413,6 +436,11 @@
   const Vector6& getVelocity() const
   { return mMechanicLinkValue->getVelocity(); }
 
+  void setInertialVelocity(const Vector6& velocity)
+  { mMechanicLinkValue->setInertialVelocity(velocity); }
+  const Vector6& getInertialVelocity() const
+  { return mMechanicLinkValue->getInertialVelocity(); }
+
   void setCoordinateSystem(const CoordinateSystem& coordinateSystem)
   { return mMechanicLinkValue->setCoordinateSystem(coordinateSystem); }
   const CoordinateSystem& getCoordinateSystem() const

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJoint.cpp	2009-07-20 18:17:30 UTC (rev 1016)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJoint.cpp	2009-07-20 18:39:01 UTC (rev 1017)
@@ -181,7 +181,8 @@
   velocity = childLink.getCoordinateSystem().rotToReference(velocity);
   Vector3 angularBaseVelocity = environment.getAngularVelocity(task.getTime());
   Vector6 baseVelocity(angularMotionTo(position, angularBaseVelocity));
-  childLink.setVelocity(baseVelocity + velocity);
+  childLink.setVelocity(velocity);
+  childLink.setInertialVelocity(baseVelocity + velocity);
 
   childLink.setSpatialForce(Vector6::zeros());
   childLink.setSpatialInertia(SpatialInertia::zeros());

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/SystemOutput.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/SystemOutput.cpp	2009-07-20 18:17:30 UTC (rev 1016)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/SystemOutput.cpp	2009-07-20 18:39:01 UTC (rev 1017)
@@ -28,6 +28,7 @@
 SystemOutput*
 SystemOutput::newDefaultSystemOutput(const std::string& filename)
 {
+  return 0;
 #ifdef HAVE_HDF5_H
   return new HDF5SystemOutput(filename);
 #else



From frohlich at mail.berlios.de  Mon Jul 20 20:40:07 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Mon, 20 Jul 2009 20:40:07 +0200
Subject: [OpenFDM-svn] r1018 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200907201840.n6KIe7xP024983@sheep.berlios.de>

Author: frohlich
Date: 2009-07-20 20:40:07 +0200 (Mon, 20 Jul 2009)
New Revision: 1018

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/SystemOutput.cpp
Log:
Revert bogous commit.

M    src/OpenFDM/SystemOutput.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/SystemOutput.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/SystemOutput.cpp	2009-07-20 18:39:01 UTC (rev 1017)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/SystemOutput.cpp	2009-07-20 18:40:07 UTC (rev 1018)
@@ -28,7 +28,6 @@
 SystemOutput*
 SystemOutput::newDefaultSystemOutput(const std::string& filename)
 {
-  return 0;
 #ifdef HAVE_HDF5_H
   return new HDF5SystemOutput(filename);
 #else



From frohlich at mail.berlios.de  Mon Jul 20 21:37:00 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Mon, 20 Jul 2009 21:37:00 +0200
Subject: [OpenFDM-svn] r1019 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200907201937.n6KJb0Ac031124@sheep.berlios.de>

Author: frohlich
Date: 2009-07-20 21:36:59 +0200 (Mon, 20 Jul 2009)
New Revision: 1019

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/ExternalInteract.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/ExternalInteract.h
Log:
Rename pressure -> staticPressure


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/ExternalInteract.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ExternalInteract.cpp	2009-07-20 18:40:07 UTC (rev 1018)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ExternalInteract.cpp	2009-07-20 19:36:59 UTC (rev 1019)
@@ -25,7 +25,7 @@
   DEF_OPENFDM_PROPERTY(Bool, EnableBodyWindVelocity, Serialized)
   DEF_OPENFDM_PROPERTY(Bool, EnableGlobalWindVelocity, Serialized)
   DEF_OPENFDM_PROPERTY(Bool, EnableTemperature, Serialized)
-  DEF_OPENFDM_PROPERTY(Bool, EnablePressure, Serialized)
+  DEF_OPENFDM_PROPERTY(Bool, EnableStaticPressure, Serialized)
   DEF_OPENFDM_PROPERTY(Bool, EnableDensity, Serialized)
   DEF_OPENFDM_PROPERTY(Bool, EnableSoundSpeed, Serialized)
   DEF_OPENFDM_PROPERTY(Bool, EnableAltitude, Serialized)
@@ -50,7 +50,7 @@
     mBodyWindVelocity(portValueList.getPortValue(externalInteract->mBodyWindVelocityPort)),
     mGlobalWindVelocity(portValueList.getPortValue(externalInteract->mGlobalWindVelocityPort)),
     mTemperature(portValueList.getPortValue(externalInteract->mTemperaturePort)),
-    mPressure(portValueList.getPortValue(externalInteract->mPressurePort)),
+    mStaticPressure(portValueList.getPortValue(externalInteract->mStaticPressurePort)),
     mDensity(portValueList.getPortValue(externalInteract->mDensityPort)),
     mSoundSpeed(portValueList.getPortValue(externalInteract->mSoundSpeedPort)),
     mAltitude(portValueList.getPortValue(externalInteract->mAltitudePort)),
@@ -119,10 +119,10 @@
     bool enableAltitude = mAltitude.isConnected();
     
     bool enableTemperature = mTemperature.isConnected();
-    bool enablePressure = mPressure.isConnected();
+    bool enableStaticPressure = mStaticPressure.isConnected();
     bool enableDensity = mDensity.isConnected();
     bool enableSoundSpeed = mSoundSpeed.isConnected();
-    bool enableAtmosphere = (enableTemperature || enablePressure ||
+    bool enableAtmosphere = (enableTemperature || enableStaticPressure ||
                              enableDensity || enableSoundSpeed);
     if (enableAltitude || enableAtmosphere) {
       real_type altitude = getEnvironment().getAltitude(refPosition);
@@ -134,8 +134,8 @@
         AtmosphereData data = atmosphere->getData(task.getTime(), altitude);
         if (enableTemperature)
           mTemperature = data.temperature;
-        if (enablePressure)
-          mPressure = data.pressure;
+        if (enableStaticPressure)
+          mStaticPressure = data.pressure;
         if (enableDensity)
           mDensity = data.density;
         if (enableSoundSpeed)
@@ -206,7 +206,7 @@
   MatrixOutputPortHandle mGlobalWindVelocity;
 
   RealOutputPortHandle mTemperature;
-  RealOutputPortHandle mPressure;
+  RealOutputPortHandle mStaticPressure;
   RealOutputPortHandle mDensity;
   RealOutputPortHandle mSoundSpeed;
 
@@ -453,20 +453,20 @@
 }
 
 void
-ExternalInteract::setEnablePressure(bool enable)
+ExternalInteract::setEnableStaticPressure(bool enable)
 {
-  if (enable == getEnablePressure())
+  if (enable == getEnableStaticPressure())
     return;
   if (enable)
-    mPressurePort = RealOutputPort(this, "pressure");
+    mStaticPressurePort = RealOutputPort(this, "staticPressure");
   else
-    mPressurePort.clear();
+    mStaticPressurePort.clear();
 }
 
 bool
-ExternalInteract::getEnablePressure() const
+ExternalInteract::getEnableStaticPressure() const
 {
-  return !mPressurePort.empty();
+  return !mStaticPressurePort.empty();
 }
 
 void
@@ -620,7 +620,7 @@
   setEnableBodyWindVelocity(enable);
   setEnableGlobalWindVelocity(enable);
   setEnableTemperature(enable);
-  setEnablePressure(enable);
+  setEnableStaticPressure(enable);
   setEnableDensity(enable);
   setEnableSoundSpeed(enable);
   setEnableAltitude(enable);

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/ExternalInteract.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ExternalInteract.h	2009-07-20 18:40:07 UTC (rev 1018)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ExternalInteract.h	2009-07-20 19:36:59 UTC (rev 1019)
@@ -95,10 +95,10 @@
   /// Get availabilty of the temperature output port
   bool getEnableTemperature() const;
 
-  /// Set availabilty of the pressure output port
-  void setEnablePressure(bool enable);
-  /// Get availabilty of the pressure output port
-  bool getEnablePressure() const;
+  /// Set availabilty of the static pressure output port
+  void setEnableStaticPressure(bool enable);
+  /// Get availabilty of the static pressure output port
+  bool getEnableStaticPressure() const;
 
   /// Set availabilty of the density output port
   void setEnableDensity(bool enable);
@@ -167,7 +167,7 @@
   MatrixOutputPort mGlobalWindVelocityPort;
 
   RealOutputPort mTemperaturePort;
-  RealOutputPort mPressurePort;
+  RealOutputPort mStaticPressurePort;
   RealOutputPort mDensityPort;
   RealOutputPort mSoundSpeedPort;
 



From frohlich at mail.berlios.de  Mon Jul 20 22:49:49 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Mon, 20 Jul 2009 22:49:49 +0200
Subject: [OpenFDM-svn] r1020 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200907202049.n6KKnnoI005189@sheep.berlios.de>

Author: frohlich
Date: 2009-07-20 22:49:48 +0200 (Mon, 20 Jul 2009)
New Revision: 1020

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJoint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/HDF5SystemOutput.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Mass.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJoint.cpp
Log:
Consolidate MechanicLinkValue handling a bit.

M    src/OpenFDM/MobileRootJoint.cpp
M    src/OpenFDM/CartesianJoint.h
M    src/OpenFDM/Mass.cpp
M    src/OpenFDM/MechanicLinkValue.cpp
M    src/OpenFDM/MechanicLinkValue.h
M    src/OpenFDM/FixedRootJoint.cpp
M    src/OpenFDM/HDF5SystemOutput.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h	2009-07-20 19:36:59 UTC (rev 1019)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h	2009-07-20 20:49:48 UTC (rev 1020)
@@ -171,8 +171,8 @@
                       cross(parentInVel.getLinear(), relVel.getAngular()));
 
 
-      mChildLink.setSpatialForce(Vector6::zeros());
-      mChildLink.setSpatialInertia(SpatialInertia::zeros());
+      mChildLink.setForce(Vector6::zeros());
+      mChildLink.setInertia(SpatialInertia::zeros());
     }
 
     /** This is the derivative of the joint matrix times the joint velocity
@@ -193,7 +193,7 @@
 
       // Compute the projection of the inertia matrix to the
       // joint coordinate space
-      SpatialInertia I = mChildLink.getSpatialInertia();
+      SpatialInertia I = mChildLink.getInertia();
       Matrix6N Ih = I*mJointMatrix;
       hIh = trans(mJointMatrix)*Ih;
 
@@ -206,15 +206,15 @@
 
       // Note that the momentum of the local mass is already included in the
       // child links force due the the mass model ...
-      Vector6 force = mChildLink.getSpatialForce() + I*getHdot();
+      Vector6 force = mChildLink.getForce() + I*getHdot();
 
       // Project away those axis handled with this current joint
       force -= Ih*hIh.solve(trans(mJointMatrix)*force - jointForce);
       I -= SpatialInertia(Ih*hIh.solve(trans(Ih)));
 
       // Contribute the remaining force and inertiy to the parent link
-      mParentLink.addSpatialForce(cs.getPosition(), force);
-      mParentLink.addSpatialInertia(cs.getPosition(), I);
+      mParentLink.addForce(cs.getPosition(), force);
+      mParentLink.addInertia(cs.getPosition(), I);
     }
 
     /** Compute the acceleration step for a given joint force.
@@ -230,16 +230,16 @@
 
       Vector3 positionDifference = cs.getPosition() - ps.getPosition();
 
-      Vector6 parentSpAccel = mParentLink.getAcceleration();
+      Vector6 parentSpAccel = mParentLink.getInertialAcceleration();
       parentSpAccel = motionTo(positionDifference, parentSpAccel);
 
-      Vector6 f = mChildLink.getSpatialForce();
-      f += mChildLink.getSpatialInertia()*(parentSpAccel + getHdot());
+      Vector6 f = mChildLink.getForce();
+      f += mChildLink.getInertia()*(parentSpAccel + getHdot());
 
       mVelDot = hIh.solve(mJointForce - trans(mJointMatrix)*f);
 
       Vector6 spAccel = parentSpAccel + getHdot() + mJointMatrix*mVelDot;
-      mChildLink.setAcceleration(spAccel);
+      mChildLink.setInertialAcceleration(spAccel);
     }
   
     /** Compute the articulation step for a given velocity derivative.
@@ -257,12 +257,12 @@
 
       const CoordinateSystem& cs = mChildLink.getCoordinateSystem();
 
-      const SpatialInertia& I = mChildLink.getSpatialInertia();
-      Vector6 force = mChildLink.getSpatialForce();
+      const SpatialInertia& I = mChildLink.getInertia();
+      Vector6 force = mChildLink.getForce();
       force += I*(getHdot() + mJointMatrix*mVelDot);
       
-      mParentLink.addSpatialForce(cs.getPosition(), force);
-      mParentLink.addSpatialInertia(cs.getPosition(), I);
+      mParentLink.addForce(cs.getPosition(), force);
+      mParentLink.addInertia(cs.getPosition(), I);
     }
     
     /** Compute the acceleration step for a given velocity derivative.
@@ -274,11 +274,11 @@
       const CoordinateSystem& ps = mParentLink.getCoordinateSystem();
       Vector3 positionDifference = cs.getPosition() - ps.getPosition();
 
-      Vector6 parentSpAccel = mParentLink.getAcceleration();
+      Vector6 parentSpAccel = mParentLink.getInertialAcceleration();
       parentSpAccel = motionTo(positionDifference, parentSpAccel);
 
       Vector6 spAccel = parentSpAccel + getHdot() + mJointMatrix*mVelDot;
-      mChildLink.setAcceleration(spAccel);
+      mChildLink.setInertialAcceleration(spAccel);
     }
 
     const VectorN& getVelDot() const

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJoint.cpp	2009-07-20 19:36:59 UTC (rev 1019)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJoint.cpp	2009-07-20 20:49:48 UTC (rev 1020)
@@ -47,14 +47,14 @@
     mChildLink.setVelocity(Vector6::zeros());
     mChildLink.setInertialVelocity(vel);
 
-    mChildLink.setSpatialForce(Vector6::zeros());
-    mChildLink.setSpatialInertia(SpatialInertia::zeros());
+    mChildLink.setForce(Vector6::zeros());
+    mChildLink.setInertia(SpatialInertia::zeros());
   }
   virtual void accelerations(const Task& task)
   {
     Vector6 spAccel = getEnvironment().getAcceleration(task.getTime());
     spAccel = motionTo(mFixedRootJoint->mRootPosition, spAccel);
-    mChildLink.setAcceleration(spAccel);
+    mChildLink.setInertialAcceleration(spAccel);
   }
   
 private:

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/HDF5SystemOutput.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/HDF5SystemOutput.h	2009-07-20 19:36:59 UTC (rev 1019)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/HDF5SystemOutput.h	2009-07-20 20:49:48 UTC (rev 1020)
@@ -349,7 +349,8 @@
       _orientation(_group, "orientation", Size(4, 1)),
       _eulerAngle(_group, "eulerAngles", Size(3, 1)),
       _velocity(_group, "velocity", Size(6, 1)),
-      _acceleration(_group, "acceleration", Size(6, 1)),
+      _inertialVelocity(_group, "inertialVelocity", Size(6, 1)),
+      _inertialAcceleration(_group, "inertialAcceleration", Size(6, 1)),
       _force(_group, "force", Size(6, 1)),
       _inertia(_group, "inertia", Size(6, 6))
     { }
@@ -360,9 +361,10 @@
       _orientation.append(cs.getOrientation());
       _eulerAngle.append(cs.getOrientation().getEuler());
       _velocity.append(mMechanicLinkValue->getVelocity());
-      _acceleration.append(mMechanicLinkValue->getAcceleration());
-      _force.append(mMechanicLinkValue->getSpatialForce());
-      _inertia.append(mMechanicLinkValue->getSpatialInertia());
+      _inertialVelocity.append(mMechanicLinkValue->getInertialVelocity());
+      _inertialAcceleration.append(mMechanicLinkValue->getInertialAcceleration());
+      _force.append(mMechanicLinkValue->getForce());
+      _inertia.append(mMechanicLinkValue->getInertia());
     }
     virtual HDF5Object getObject()
     { return _group; }
@@ -373,7 +375,8 @@
     HDFMatrixStream _orientation;
     HDFMatrixStream _eulerAngle;
     HDFMatrixStream _velocity;
-    HDFMatrixStream _acceleration;
+    HDFMatrixStream _inertialVelocity;
+    HDFMatrixStream _inertialAcceleration;
     HDFMatrixStream _force;
     HDFMatrixStream _inertia;
   };

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Mass.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Mass.cpp	2009-07-20 19:36:59 UTC (rev 1019)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Mass.cpp	2009-07-20 20:49:48 UTC (rev 1020)
@@ -51,7 +51,7 @@
                              v.getLinear(), so the cross product is zero
                           + cross(v.getLinear(), Iv.getLinear())*/,
                           cross(v.getAngular(), Iv.getLinear()));
-    getLink().addSpatialForce(cs.getPosition(), vIv);
+    getLink().addForce(cs.getPosition(), vIv);
 
     // Now the gravity part
     Vector3 gravity = getEnvironment().getGravityAcceleration(cs.getPosition());

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.cpp	2009-07-20 19:36:59 UTC (rev 1019)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.cpp	2009-07-20 20:49:48 UTC (rev 1020)
@@ -9,7 +9,7 @@
 MechanicLinkValue::MechanicLinkValue() :
   mVelocity(Vector6::zeros()),
   mInertialVelocity(Vector6::zeros()),
-  mAcceleration(Vector6::zeros()),
+  mInertialAcceleration(Vector6::zeros()),
   mForce(Vector6::zeros()),
   mInertia(SpatialInertia::zeros())
 {

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.h	2009-07-20 19:36:59 UTC (rev 1019)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.h	2009-07-20 20:49:48 UTC (rev 1020)
@@ -33,7 +33,7 @@
   void setCoordinateSystem(const CoordinateSystem& coordinateSystem)
   { mCoordinateSystem = coordinateSystem; }
 
-  /// The spatial velocity of this mechanic link
+  /// The velocity of this mechanic link
   ///
   /// The velocity is given in global coordinates and at this mechanic links
   /// coordinate systems origin.
@@ -42,36 +42,40 @@
   const Vector6& getVelocity() const
   { return mVelocity; }
 
+  /// The inertial velocity of this mechanic link
+  ///
+  /// The velocity is given in global coordinates and at this mechanic links
+  /// coordinate systems origin.
   void setInertialVelocity(const Vector6& inertialVelocity)
   { mInertialVelocity = inertialVelocity; }
   const Vector6& getInertialVelocity() const
   { return mInertialVelocity; }
 
-  /// The spatial acceleration of this mechanic link
+  /// The inertial acceleration of this mechanic link
   ///
   /// The acceleration is given in global coordinates and at this mechanic links
   /// coordinate systems origin.
-  void setAcceleration(const Vector6& acceleration)
-  { mAcceleration = acceleration; }
-  const Vector6& getAcceleration() const
-  { return mAcceleration; }
+  void setInertialAcceleration(const Vector6& inertialAcceleration)
+  { mInertialAcceleration = inertialAcceleration; }
+  const Vector6& getInertialAcceleration() const
+  { return mInertialAcceleration; }
 
-  /// The spatial force of this mechanic link
+  /// The force of this mechanic link
   ///
   /// The force is given in global coordinates and at this mechanic links
   /// coordinate systems origin.
-  const Vector6& getSpatialForce() const
+  const Vector6& getForce() const
   { return mForce; }
-  void setSpatialForce(const Vector6& force)
+  void setForce(const Vector6& force)
   { mForce = force; }
 
-  /// The spatial inertia of this mechanic link
+  /// The inertia of this mechanic link
   ///
   /// The inertia is given in global coordinates and at this mechanic links
   /// coordinate systems origin.
-  const SpatialInertia& getSpatialInertia() const
+  const SpatialInertia& getInertia() const
   { return mInertia; }
-  void setSpatialInertia(const SpatialInertia& inertia)
+  void setInertia(const SpatialInertia& inertia)
   { mInertia = inertia; }
 
 
@@ -82,35 +86,43 @@
 
 
   /// Conveninent getters at different positions/coordinatesystems
-  Vector6 getSpatialVelocity(const Vector3& pos) const
+  Vector6 getVelocity(const Vector3& pos) const
   { return motionTo(pos - mCoordinateSystem.getPosition(), getVelocity()); }
-  Vector6 getSpatialVelocity(const CoordinateSystem& cs) const
-  { return cs.rotToLocal(getSpatialVelocity(cs.getPosition())); }
+  Vector6 getVelocity(const CoordinateSystem& cs) const
+  { return cs.rotToLocal(getVelocity(cs.getPosition())); }
 
   Vector6 getInertialVelocity(const Vector3& pos) const
   { return motionTo(pos - mCoordinateSystem.getPosition(), getInertialVelocity()); }
   Vector6 getInertialVelocity(const CoordinateSystem& cs) const
   { return cs.rotToLocal(getInertialVelocity(cs.getPosition())); }
 
-  Vector6 getSpatialAcceleration(const Vector3& pos) const
-  { return motionTo(pos - mCoordinateSystem.getPosition(), getAcceleration()); }
-  Vector6 getSpatialAcceleration(const CoordinateSystem& cs) const
-  { return cs.rotToLocal(getSpatialAcceleration(cs.getPosition())); }
+  Vector6 getInertialAcceleration(const Vector3& pos) const
+  { return motionTo(pos - mCoordinateSystem.getPosition(), getInertialAcceleration()); }
+  Vector6 getInertialAcceleration(const CoordinateSystem& cs) const
+  { return cs.rotToLocal(getInertialAcceleration(cs.getPosition())); }
 
-  Vector6 getSpatialForce(const Vector3& pos) const
-  { return forceTo(pos - mCoordinateSystem.getPosition(), getSpatialForce()); }
-  Vector6 getSpatialForce(const CoordinateSystem& cs) const
-  { return cs.rotToLocal(getSpatialForce(cs.getPosition())); }
+  Vector6 getForce(const Vector3& pos) const
+  { return forceTo(pos - mCoordinateSystem.getPosition(), getForce()); }
+  Vector6 getForce(const CoordinateSystem& cs) const
+  { return cs.rotToLocal(getForce(cs.getPosition())); }
 
-  SpatialInertia getSpatialInertia(const Vector3& pos) const
+
+  /// Conveninent setters for the forces
+  void applyGlobalTorque(const Vector3& torque)
   {
-    // is inertiaTo(pos - cs.getPosition(), ...)
-    return inertiaFrom(mCoordinateSystem.getPosition() - pos,
-                       getSpatialInertia());
+    mForce -= Vector6(torque, Vector3::zeros());
   }
-  SpatialInertia getSpatialInertia(const CoordinateSystem& cs) const
-  { return cs.rotToLocal(getSpatialInertia(cs.getPosition())); }
 
+  void applyLocalForce(const Vector6& force)
+  { mForce -= mCoordinateSystem.rotToReference(force); }
+  void applyLocalForce(const Vector3& position, const Vector6& force)
+  { applyLocalForce(forceFrom(position, force)); }
+  void applyLocalForce(const Vector3& force)
+  { applyLocalForce(Vector6(Vector3::zeros(), force)); }
+  void applyLocalForce(const Vector3& position, const Vector3& force)
+  { applyLocalForce(forceFrom(position, force)); }
+  void applyLocalTorque(const Vector3& torque)
+  { applyLocalForce(Vector6(torque, Vector3::zeros())); }
 
   void applyForce(const Vector3& position, const Vector3& force)
   {
@@ -124,25 +136,32 @@
   }
   void applyForce(const CoordinateSystem& cs, const Vector3& force)
   {
-    Vector3 forceInGlobal = cs.rotToReference(force);
     Vector3 positionDiff = cs.getPosition() - mCoordinateSystem.getPosition();
-    mForce -= forceFrom(positionDiff, forceInGlobal);
+    mForce -= forceFrom(positionDiff, cs.rotToReference(force));
   }
   void applyForce(const CoordinateSystem& cs, const Vector6& force)
   {
-    Vector6 forceInGlobal = cs.rotToReference(force);
     Vector3 positionDiff = cs.getPosition() - mCoordinateSystem.getPosition();
-    mForce -= forceFrom(positionDiff, forceInGlobal);
+    mForce -= forceFrom(positionDiff, cs.rotToReference(force));
   }
 
 
-  void addSpatialForce(const Vector3& position, const Vector6& force)
+  void addForce(const Vector3& position, const Vector6& force)
   {
     Vector3 offset = position - mCoordinateSystem.getPosition();
     mForce += forceFrom(offset, force);
   }
-  void addSpatialInertia(const Vector3& position, const SpatialInertia& inertia)
+
+  SpatialInertia getInertia(const Vector3& pos) const
   {
+    // is inertiaTo(pos - cs.getPosition(), ...)
+    return inertiaFrom(mCoordinateSystem.getPosition() - pos, getInertia());
+  }
+  SpatialInertia getInertia(const CoordinateSystem& cs) const
+  { return cs.rotToLocal(getInertia(cs.getPosition())); }
+
+  void addInertia(const Vector3& position, const SpatialInertia& inertia)
+  {
     if (position == mCoordinateSystem.getPosition()) {
       mInertia += inertia;
     } else {
@@ -150,65 +169,38 @@
       mInertia += inertiaFrom(offset, inertia);
     }
   }
-
-
-  SpatialInertia getLocalInertia() const
-  { return getSpatialInertia(mCoordinateSystem); }
-  Vector6 getLocalForce() const
-  { return getSpatialForce(mCoordinateSystem); }
-
-  void applyGlobalTorque(const Vector3& torque)
+  void addInertia(const Vector3& position,
+                  const InertiaMatrix& inertia, const real_type& mass)
   {
-    mForce -= Vector6(torque, Vector3::zeros());
+    Vector3 offset = position - mCoordinateSystem.getPosition();
+    mInertia += SpatialInertia(offset, inertia, mass);
   }
-  void applyGlobalForce(const Vector3& globalPosition, const Vector3& force)
-  {
-    Vector3 positionDiff = globalPosition - mCoordinateSystem.getPosition();
-    mForce -= forceFrom(positionDiff, force);
-  }
 
-  void applyLocalForce(const Vector6& force)
-  { mForce -= mCoordinateSystem.rotToReference(force); }
-  void applyLocalForce(const Vector3& position, const Vector6& force)
-  { applyLocalForce(forceFrom(position, force)); }
-  void applyLocalForce(const Vector3& force)
-  { applyLocalForce(Vector6(Vector3::zeros(), force)); }
-  void applyLocalForce(const Vector3& position, const Vector3& force)
-  { applyLocalForce(forceFrom(position, force)); }
-  void applyLocalTorque(const Vector3& torque)
-  { applyLocalForce(Vector6(torque, Vector3::zeros())); }
-
-  void setLocalVelocity(const Vector6& velocity)
-  { mVelocity = mCoordinateSystem.rotToReference(velocity); }
   Vector6 getLocalVelocity() const
   { return mCoordinateSystem.rotToLocal(mVelocity); }
 
   Vector6 getLocalAcceleration() const
-  { return mCoordinateSystem.rotToLocal(mAcceleration); }
+  { return mCoordinateSystem.rotToLocal(mInertialAcceleration); }
 
-  void addInertia(const Vector3& position,
-                  const InertiaMatrix& inertia, const real_type& mass)
-  {
-    Vector3 offset = position - mCoordinateSystem.getPosition();
-    mInertia += SpatialInertia(offset, inertia, mass);
-  }
-
 protected:
   /// The local coordinate system of the mechanic link.
   CoordinateSystem mCoordinateSystem;
 
-  /// The spatial velocity at the origin of the coordinate system
+  /// The velocity at the origin of the coordinate system
   /// measured in global coordinate systems coordinates.
   /// The spacial velocities pivot point is at the coordinate systems origin.
   Vector6 mVelocity;
-  /// Inertial velocity
-  Vector6 mInertialVelocity;
 
-  /// The spatial acceleration at the origin of the coordinate system
+  /// The inertial velocity at the origin of the coordinate system
   /// measured in global coordinate systems coordinates.
   /// The spacial velocities pivot point is at the coordinate systems origin.
-  Vector6 mAcceleration;
+  Vector6 mInertialVelocity;
 
+  /// The inertial acceleration at the origin of the coordinate system
+  /// measured in global coordinate systems coordinates.
+  /// The spacial accelerations pivot point is at the coordinate systems origin.
+  Vector6 mInertialAcceleration;
+
   /// The articulated force at the origin of the coordinate system
   /// measured in global coordinate systems coordinates.
   /// The articulated force pivot point is at the coordinate systems origin.
@@ -233,10 +225,7 @@
   { return mMechanicLinkValue; }
 
   const Vector3& getLinkRelPos() const
-  {
-    OpenFDMAssert(isConnected());
-    return mLinkRelPos;
-  }
+  { return mLinkRelPos; }
 
   const MechanicLinkValue& getMechanicLinkValue() const
   {
@@ -251,9 +240,7 @@
   }
 
   CoordinateSystem getRelativeCoordinateSystem(const ParentLink& link) const
-  {
-    return getCoordinateSystem().toLocal(link.getCoordinateSystem());
-  }
+  { return getCoordinateSystem().toLocal(link.getCoordinateSystem()); }
 
   Vector3 getRefPos() const
   {
@@ -269,12 +256,12 @@
   Vector6 getVelocity(const Vector3& position) const
   {
     OpenFDMAssert(isConnected());
-    return mMechanicLinkValue->getSpatialVelocity(position);
+    return mMechanicLinkValue->getVelocity(position);
   }
   Vector6 getVelocity(const CoordinateSystem& cs) const
   {
     OpenFDMAssert(isConnected());
-    return mMechanicLinkValue->getSpatialVelocity(cs);
+    return mMechanicLinkValue->getVelocity(cs);
   }
 
   Vector6 getInertialVelocity(const Vector3& position) const
@@ -288,15 +275,15 @@
     return mMechanicLinkValue->getInertialVelocity(cs);
   }
 
-  Vector6 getAcceleration(const Vector3& position) const
+  Vector6 getInertialAcceleration(const Vector3& position) const
   {
     OpenFDMAssert(isConnected());
-    return mMechanicLinkValue->getSpatialAcceleration(position);
+    return mMechanicLinkValue->getInertialAcceleration(position);
   }
-  Vector6 getAcceleration(const CoordinateSystem& cs) const
+  Vector6 getInertialAcceleration(const CoordinateSystem& cs) const
   {
     OpenFDMAssert(isConnected());
-    return mMechanicLinkValue->getSpatialAcceleration(cs);
+    return mMechanicLinkValue->getInertialAcceleration(cs);
   }
 
   Vector6 getLocalVelocity() const
@@ -309,8 +296,8 @@
     OpenFDMAssert(isConnected());
     return motionTo(mLinkRelPos, mMechanicLinkValue->getLocalAcceleration());
   }
-  const Vector6& getAcceleration() const
-  { return mMechanicLinkValue->getAcceleration(); }
+  const Vector6& getInertialAcceleration() const
+  { return mMechanicLinkValue->getInertialAcceleration(); }
   const Vector6& getVelocity() const
   { return mMechanicLinkValue->getVelocity(); }
   const Vector6& getInertialVelocity() const
@@ -356,7 +343,7 @@
   {
     OpenFDMAssert(isConnected());
     const CoordinateSystem& cs = mMechanicLinkValue->getCoordinateSystem();
-    mMechanicLinkValue->applyGlobalForce(cs.toReference(mLinkRelPos), force);
+    mMechanicLinkValue->applyForce(cs.toReference(mLinkRelPos), force);
   }
 
   void applyGlobalTorque(const Vector3& torque)
@@ -365,12 +352,6 @@
     mMechanicLinkValue->applyGlobalTorque(torque);
   }
 
-  void applyLocalForceAtLink(const Vector6& force)
-  {
-    OpenFDMAssert(isConnected());
-    mMechanicLinkValue->applyLocalForce(force);
-  }
-
   void applyForce(const Vector3& position, const Vector3& force)
   {
     OpenFDMAssert(isConnected());
@@ -392,15 +373,15 @@
     mMechanicLinkValue->applyForce(cs, force);
   }
 
-  void addSpatialForce(const Vector3& position, const Vector6& force)
+  void addForce(const Vector3& position, const Vector6& force)
   {
     OpenFDMAssert(isConnected());
-    mMechanicLinkValue->addSpatialForce(position, force);
+    mMechanicLinkValue->addForce(position, force);
   }
-  void addSpatialInertia(const Vector3& position, const SpatialInertia& inertia)
+  void addInertia(const Vector3& position, const SpatialInertia& inertia)
   {
     OpenFDMAssert(isConnected());
-    mMechanicLinkValue->addSpatialInertia(position, inertia);
+    mMechanicLinkValue->addInertia(position, inertia);
   }
   void addInertia(const Vector3& position,
                   const InertiaMatrix& inertia, const real_type& mass)
@@ -426,10 +407,10 @@
   void setDesignPosition(const Vector3& position)
   { mMechanicLinkValue->setCoordinateSystem(CoordinateSystem(position)); }
 
-  void setAcceleration(const Vector6& accel)
-  { mMechanicLinkValue->setAcceleration(accel); }
-  const Vector6& getAcceleration() const
-  { return mMechanicLinkValue->getAcceleration(); }
+  void setInertialAcceleration(const Vector6& accel)
+  { mMechanicLinkValue->setInertialAcceleration(accel); }
+  const Vector6& getInertialAcceleration() const
+  { return mMechanicLinkValue->getInertialAcceleration(); }
 
   void setVelocity(const Vector6& velocity)
   { mMechanicLinkValue->setVelocity(velocity); }
@@ -446,15 +427,15 @@
   const CoordinateSystem& getCoordinateSystem() const
   { return mMechanicLinkValue->getCoordinateSystem(); }
 
-  void setSpatialForce(const Vector6& force)
-  { return mMechanicLinkValue->setSpatialForce(force); }
-  const Vector6& getSpatialForce() const
-  { return mMechanicLinkValue->getSpatialForce(); }
+  void setForce(const Vector6& force)
+  { return mMechanicLinkValue->setForce(force); }
+  const Vector6& getForce() const
+  { return mMechanicLinkValue->getForce(); }
 
-  void setSpatialInertia(const SpatialInertia& inertia) const
-  { return mMechanicLinkValue->setSpatialInertia(inertia); }
-  const SpatialInertia& getSpatialInertia() const
-  { return mMechanicLinkValue->getSpatialInertia(); }
+  void setInertia(const SpatialInertia& inertia) const
+  { return mMechanicLinkValue->setInertia(inertia); }
+  const SpatialInertia& getInertia() const
+  { return mMechanicLinkValue->getInertia(); }
  
 private:
   SharedPtr<MechanicLinkValue> mMechanicLinkValue;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJoint.cpp	2009-07-20 19:36:59 UTC (rev 1019)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJoint.cpp	2009-07-20 20:49:48 UTC (rev 1020)
@@ -49,10 +49,9 @@
   }
   virtual void accelerations(const Task& task)
   {
-    const SpatialInertia& inertia = mChildLink.getSpatialInertia();
-    Vector6 force = -mChildLink.getSpatialForce();
-    Vector6 spatialAcceleration = solve(inertia, force);
-    mChildLink.setAcceleration(spatialAcceleration);
+    Vector6 force = -mChildLink.getForce();
+    Vector6 acceleration = solve(mChildLink.getInertia(), force);
+    mChildLink.setInertialAcceleration(acceleration);
   }
   
   virtual void derivative(const Task& task)
@@ -184,8 +183,8 @@
   childLink.setVelocity(velocity);
   childLink.setInertialVelocity(baseVelocity + velocity);
 
-  childLink.setSpatialForce(Vector6::zeros());
-  childLink.setSpatialInertia(SpatialInertia::zeros());
+  childLink.setForce(Vector6::zeros());
+  childLink.setInertia(SpatialInertia::zeros());
 }
 
 void
@@ -223,7 +222,7 @@
                          cross(pivel.getAngular(), velocity.getLinear()) + 
                          cross(pivel.getLinear(), velocity.getAngular()));
 
-  Vector6 velDeriv = childLink.getAcceleration()
+  Vector6 velDeriv = childLink.getInertialAcceleration()
     - spatialAcceleration - Hdot;
 
   derivatives[*mPositionStateInfo] = pDot;



From frohlich at mail.berlios.de  Wed Jul 15 07:21:33 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Wed, 15 Jul 2009 07:21:33 +0200
Subject: [OpenFDM-svn] r1005 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200907150521.n6F5LXWB005086@sheep.berlios.de>

Author: frohlich
Date: 2009-07-15 07:21:29 +0200 (Wed, 15 Jul 2009)
New Revision: 1005

Removed:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Frame.h
Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/AeroForce.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/AeroForce.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Contact.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/CoordinateSystem.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/ExternalInteract.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJoint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/HDF5SystemOutput.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/InternalInteract.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Launchbar.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Launchbar.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
   branches/OpenFDM-StateSeparation/src/OpenFDM/Mass.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJoint.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/PacejkaTire.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Tailhook.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Tailhook.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/WheelContact.cpp
Log:
Remove Frame from MechanicLinkValue.
Introduce new values for the velocities and accelerations.
Remove Frame.h.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/AeroForce.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/AeroForce.cpp	2009-07-13 18:45:50 UTC (rev 1004)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/AeroForce.cpp	2009-07-15 05:21:29 UTC (rev 1005)
@@ -6,7 +6,6 @@
 
 #include "Object.h"
 #include "Vector.h"
-#include "Frame.h"
 #include "Force.h"
 #include "Atmosphere.h"
 

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/AeroForce.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/AeroForce.h	2009-07-13 18:45:50 UTC (rev 1004)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/AeroForce.h	2009-07-15 05:21:29 UTC (rev 1005)
@@ -8,7 +8,6 @@
 #include "Assert.h"
 #include "Object.h"
 #include "Vector.h"
-#include "Frame.h"
 #include "Force.h"
 #include "Atmosphere.h"
 #include "Ground.h"

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h	2009-07-13 18:45:50 UTC (rev 1004)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/CartesianJoint.h	2009-07-15 05:21:29 UTC (rev 1005)
@@ -143,7 +143,7 @@
       mChildLink.setCoordinateSystem(mParentLink.getCoordinateSystem().toReference(mRelativeCoordinateSystem));
 
       Vector6 relVel = mJointMatrix*velocity;
-      mChildLink.setPosAndVel(mParentLink, relPosition, orientation, relVel);
+      mChildLink.setRelativeVelocity(mParentLink, relVel);
 
       /**
          This is the cross product of the inertial spatial velocity
@@ -155,7 +155,7 @@
          transformed spatial velocity of the parent frame cross the
          relative velocity.
       */
-      Vector6 pivel = mParentLink.getSpVelAtLink();
+      Vector6 pivel = mParentLink.getLocalVelocityAtLink();
       pivel = mRelativeCoordinateSystem.motionToLocal(pivel);
       mHdot = Vector6(cross(pivel.getAngular(), relVel.getAngular()),
                       cross(pivel.getAngular(), relVel.getLinear()) + 
@@ -215,12 +215,14 @@
       if (hIh.singular())
         return;
 
-      Vector6 parentSpAccel = mParentLink.getSpAccelAtLink();
+      Vector6 parentSpAccel = mParentLink.getLocalAccelerationAtLink();
       parentSpAccel = mRelativeCoordinateSystem.motionToLocal(parentSpAccel);
 
       Vector6 f = mChildLink.getInertia()*parentSpAccel + pAlpha;
       mVelDot = hIh.solve(mJointForce - trans(mJointMatrix)*f);
-      mChildLink.setAccel(mParentLink, mJointMatrix*mVelDot);
+
+      Vector6 spAccel = parentSpAccel + getHdot() + mJointMatrix*mVelDot;
+      mChildLink.setLocalAcceleration(spAccel);
     }
   
     /** Compute the articulation step for a given velocity derivative.
@@ -251,7 +253,11 @@
      */
     void accelerateDueToVelDot()
     {
-      mChildLink.setAccel(mParentLink, mJointMatrix*mVelDot);
+      Vector6 parentSpAccel = mParentLink.getLocalAccelerationAtLink();
+      parentSpAccel = mRelativeCoordinateSystem.motionToLocal(parentSpAccel);
+
+      Vector6 spAccel = parentSpAccel + getHdot() + mJointMatrix*mVelDot;
+      mChildLink.setLocalAcceleration(spAccel);
     }
 
     const VectorN& getVelDot() const

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Contact.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Contact.cpp	2009-07-13 18:45:50 UTC (rev 1004)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Contact.cpp	2009-07-15 05:21:29 UTC (rev 1005)
@@ -49,7 +49,7 @@
     // The velocity of the ground patch in the current frame.
     Vector3 relVel = groundValues.vel.getLinear();
     // Now get the relative velocity of the ground wrt the contact point
-    relVel -= getLink().getRefVel().getLinear();
+    relVel -= getLink().getLocalVelocity().getLinear();
 
     
     // The velocity perpandicular to the plane.

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/CoordinateSystem.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/CoordinateSystem.h	2009-07-13 18:45:50 UTC (rev 1004)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/CoordinateSystem.h	2009-07-15 05:21:29 UTC (rev 1005)
@@ -30,10 +30,18 @@
     mPosition(Vector3::zeros()),
     mOrientation(orientation)
   { }
+  CoordinateSystem(const Rotation& orientation) :
+    mPosition(Vector3::zeros()),
+    mOrientation(orientation)
+  { }
   CoordinateSystem(const Vector3& position, const Quaternion& orientation) :
     mPosition(position),
     mOrientation(orientation)
   { }
+  CoordinateSystem(const Vector3& position, const Rotation& orientation) :
+    mPosition(position),
+    mOrientation(orientation)
+  { }
   CoordinateSystem(const CoordinateSystem& coordinateSystem) :
     mPosition(coordinateSystem.mPosition),
     mOrientation(coordinateSystem.mOrientation)
@@ -102,11 +110,14 @@
                    mOrientation.transform(v.getLinear())); }
 
 
+  // Avoid that here. We *only* handle coordinate systems not reference frames.
   Vector6 motionToReference(const Vector6& motion) const
   { return motionFrom(mPosition, mOrientation, motion); }
   Vector6 motionToLocal(const Vector6& motion) const
   { return motionTo(mPosition, mOrientation, motion); }
 
+  // Hmm force and inertia have this cross product stuff also,
+  // is that something reference frame related or not ???
   Vector6 forceToReference(const Vector6& force) const
   { return forceFrom(mPosition, mOrientation, force); }
   Vector6 forceToLocal(const Vector6& force) const

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/ExternalInteract.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ExternalInteract.cpp	2009-07-13 18:45:50 UTC (rev 1004)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ExternalInteract.cpp	2009-07-15 05:21:29 UTC (rev 1005)
@@ -90,7 +90,7 @@
     if (enableBodyAngularVelocity || enableBodyLinearVelocity
         || enableGlobalAngularVelocity || enableGlobalLinearVelocity
         || enableBodyWindVelocity || enableGlobalWindVelocity) {
-      Vector6 refVelocity = getLink().getRefVel();
+      Vector6 refVelocity = getLink().getLocalVelocity();
       if (enableBodyAngularVelocity)
         mBodyAngularVelocity = refVelocity.getAngular();
       if (enableGlobalAngularVelocity)
@@ -170,8 +170,8 @@
       = mBodyCentrifugalAcceleration.isConnected();
     bool enableBodyLoad = mBodyLoad.isConnected();
     if (enableBodyCentrifugalAcceleration || enableBodyLoad) {
-      Vector6 spatialVel = getLink().getSpVel();
-      Vector6 spatialAccel = getLink().getSpAccel();
+      Vector6 spatialVel = getLink().getLocalVelocity();
+      Vector6 spatialAccel = getLink().getLocalAcceleration();
       Vector3 centrifugalAccel = spatialAccel.getLinear();
       centrifugalAccel += cross(spatialVel.getAngular(),spatialVel.getLinear());
 

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJoint.cpp	2009-07-13 18:45:50 UTC (rev 1004)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/FixedRootJoint.cpp	2009-07-15 05:21:29 UTC (rev 1005)
@@ -43,16 +43,14 @@
     CoordinateSystem coordSys(mFixedRootJoint->mRootPosition,
                               mFixedRootJoint->mRootOrientation);
     mChildLink.setCoordinateSystem(coordSys);
-    mChildLink.setPosAndVel(angularVel, mFixedRootJoint->mRootPosition,
-                            mFixedRootJoint->mRootOrientation,
-                            Vector6::zeros());
+    mChildLink.setBaseVelocity(angularVel, Vector6::zeros());
   }
   virtual void accelerations(const Task& task)
   {
+    // FIXME
     Vector6 spAccel = getEnvironment().getAcceleration(task.getTime());
-    spAccel = motionTo(mFixedRootJoint->mRootPosition,
-                       mFixedRootJoint->mRootOrientation, spAccel);
-    mChildLink.setSpAccel(spAccel);
+    spAccel = motionTo(mFixedRootJoint->mRootPosition, spAccel);
+    mChildLink.setAcceleration(spAccel);
   }
   
 private:

Deleted: branches/OpenFDM-StateSeparation/src/OpenFDM/Frame.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Frame.h	2009-07-13 18:45:50 UTC (rev 1004)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Frame.h	2009-07-15 05:21:29 UTC (rev 1005)
@@ -1,420 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2009 Mathias Froehlich 
- *
- */
-
-#ifndef OpenFDM_Frame_H
-#define OpenFDM_Frame_H
-
-#include "Assert.h"
-#include "Vector.h"
-#include "Plane.h"
-#include "Transform.h"
-#include "Matrix.h"
-#include "Quaternion.h"
-#include "Rotation.h"
-
-namespace OpenFDM {
-
-/** 
-The \ref Frame class is the basic tool to model a tree of moving and
-accelerating coordinate frames.
-*/
-
-class Frame {
-public:
-  Frame() :
-    mPosition(Vector3::zeros()),
-    mOrientation(Quaternion::unit()),
-    mRelVel(Vector6::zeros()),
-    mRelVelDot(Vector6::zeros()),
-    mParentSpVel(Vector6::zeros()),
-    mParentSpAccel(Vector6::zeros()),
-    mRefOrient(Quaternion::unit()),
-    mRefPos(Vector3::zeros()),
-    mRefVel(Vector6::zeros())
-  { }
-  ~Frame(void)
-  { }
-
-  void setPosAndVel(const Frame& parent)
-  {
-    mPosition = Vector3::zeros();
-    mOrientation = Quaternion::unit();
-    mRelVel = Vector6::zeros();
-
-    mRefOrient = parent.getRefOrientation();
-    mRefPos = parent.getRefPosition();
-    mRefVel = parent.getRefVel();
-
-    mParentSpVel = parent.getSpVel();
-  }
-
-  void setAccel(const Frame& parent)
-  {
-    mRelVelDot = Vector6::zeros();
-    mParentSpAccel = parent.getSpAccel();
-  }
-
-  void setPosAndVel(const Frame& parent, const Vector3& position,
-                    const Quaternion& orientation, const Vector6& velocity)
-  {
-    mPosition = position;
-    mOrientation = orientation;
-    mRelVel = velocity;
-
-    mRefOrient = parent.getRefOrientation()*getOrientation();
-    mRefPos = parent.posToRef(getPosition());
-    mRefVel = velocity + motionFromParent(parent.getRefVel());
-
-    mParentSpVel = motionFromParent(parent.getSpVel());
-  }
-
-  void setAccel(const Frame& parent, const Vector6& acceleration)
-  {
-    mRelVelDot = acceleration;
-    mParentSpAccel = motionFromParent(parent.getSpAccel());
-  }
-
-  void setPosAndVel(const Vector3& parentAngularVel, const Vector3& position,
-                    const Quaternion& orientation, const Vector6& velocity)
-  {
-    mPosition = position;
-    mOrientation = orientation;
-    mRelVel = velocity;
-
-    mRefOrient = orientation;
-    mRefPos = position;
-
-    mParentSpVel = angularMotionTo(mPosition, mOrientation, parentAngularVel);
-    mRefVel = velocity + mParentSpVel;
-  }
-
-  void setAccel(const Vector6& acceleration)
-  {
-    mRelVelDot = acceleration;
-    mParentSpAccel = Vector6::zeros();
-  }
-
-  void setSpAccel(const Vector6& spatialAcceleration)
-  {
-    mParentSpAccel = Vector6::zeros();
-    mRelVelDot = spatialAcceleration - mParentSpAccel - getHdot();
-  }
-  void setSpAccel(const Frame& parent, const Vector6& spatialAcceleration)
-  {
-    mParentSpAccel = motionFromParent(parent.getSpAccel());
-    mRelVelDot = spatialAcceleration - mParentSpAccel - getHdot();
-  }
-
-  /** Position of the current frame.
-      @return The position vector of the current frame with repsect to the
-      parent frame. It is the only vector which is in the parent frames
-      coordinates.
-   */
-  const Vector3& getPosition(void) const
-  { return mPosition; }
-
-  /** Orientation of the current frame.
-      @return The orientation of the current frame with repsect to the
-      parent frame. The quaternion returned here rotates vectors in the parent
-      frames coordinated to vectors in current frames coordinates.
-   */
-  const Rotation& getOrientation(void) const
-  { return mOrientation; }
-
-
-  /** Rotation to parent frames coordinates.
-      @param v Vector in current frames coordinates to rotate to parent
-               frames coordinates.
-      @return  The vector v in the parent frames coordinates.
-   */
-  Vector3 rotToParent(const Vector3& v) const
-  { return getOrientation().backTransform(v); }
-
-  /** Rotation to current frames coordinates.
-      @param v Vector in parent frames coordinates to rotate to current
-               frames coordinates.
-      @return  The vector v in the current frames coordinates.
-   */
-  Vector3 rotFromParent(const Vector3& v) const
-  { return getOrientation().transform(v); }
-
-
-  /** Relative spatial velocity.
-      @return The spatial velocity vector of the current frame with respect
-              to the parent frame. The velocity is in the current frames
-              coordinates.
-   */
-  const Vector6& getRelVel(void) const
-  { return mRelVel; }
-
-  /** Relative spatial acceleration.
-      @return The spatial acceleration vector of the current frame with respect
-              to the parent frame. The velocity is in the current frames
-              coordinates.
-   */
-  const Vector6& getRelVelDot(void) const 
-  { return mRelVelDot; }
-
-
-  /** Linear velocity with respect to parent.
-      @return The linear velocity of this frame with respect to the parent
-      frame.
-   */
-  Vector3 getLinearRelVel(void) const
-  { return getRelVel().getLinear(); }
-
-  /** Angular velocity with respect to parent.
-      @return The angular velocity of this frame with respect to the parent
-      frame.
-   */
-  Vector3 getAngularRelVel(void) const
-  { return getRelVel().getAngular(); }
-
-  /** Spatial velocity of the parent frame.
-      @return The spatial velocity of the parent frame with respect to an
-      inertial frame transformed to the current frame. If the current frame
-      does not have a parent it is assumed to be an inertial frame.
-   */
-  const Vector6& getParentSpVel(void) const
-  { return mParentSpVel; }
-
-  /** Spatial velocity of the current frame.
-      @return The spatial velocity of the current frame with respect to an
-      inertial frame. If the current frame does not have a parent it is
-      assumed to be an inertial frame.
-   */
-  Vector6 getSpVel(void) const
-  { return getRelVel() + getParentSpVel(); }
-
-  const Vector6& getRefVel(void) const
-  { return mRefVel; }
-
-  /** Linear acceleration with respect to parent.
-      @return The linear acceleration of this frame with respect to the parent
-      frame.
-   */
-  Vector3 getLinearRelVelDot(void) const
-  { return getRelVelDot().getLinear(); }
-
-  /** Angular acceleration with respect to parent.
-      @return The angular acceleration of this frame with respect to the parent
-      frame.
-   */
-  Vector3 getAngularRelVelDot(void) const
-  { return getRelVelDot().getAngular(); }
-
-  /** Spatial acceleration of the parent frame.
-      @return The spatial acceleration of the parent frame with respect to an
-      inertial frame transformed to the current frame. If the current frame
-      does not have a parent it is assumed to be an inertial frame.
-      Note that the spatial acceleration is not the classical acceleration
-      of the moving and accelerating body (@see getClassicAccel).
-   */
-  const Vector6& getParentSpAccel(void) const
-  { return mParentSpAccel; }
-
-  /** Spatial acceleration of the current frame.
-      @return The spatial acceleration of the current frame with respect to an
-      inertial frame. If the current frame does not have a parent it is
-      assumed to be an inertial frame.
-      Note that the spatial acceleration is not the classical acceleration
-      of the moving and accelerating body (@see getClassicAccel).
-   */
-  Vector6 getSpAccel(void) const
-  { return getRelVelDot() + getParentSpAccel() + getHdot(); }
-
-  /** Classical acceleration of the current frame.
-      @return The sensed acceleration of the current frame with respect to an
-      inertial frame. If the current frame does not have a parent it is
-      assumed to be an inertial frame.
-   */
-  Vector6 getClassicAccel(void) const
-  {
-    Vector6 iv = getSpVel();
-    return getRelVelDot() + getParentSpAccel() + getHdot()
-      + Vector6(Vector3::zeros(), cross(iv.getAngular(), iv.getLinear()));
-  }
-
-
-  /** FIXME belongs into the joints.
-   */
-  Vector6 getHdot(void) const
-  {
-    /**
-       This is the cross product of the inertial spatial velocity
-       vector with the relative spatial velocity vector (motion type
-       cross product). Since the inertial velocity is the transformed
-       inertial velocity of the parent frame plus the relative
-       velocity of the current frame, all the relative velocity
-       components cancel out in this expression. What remains is the
-       transformed spatial velocity of the parent frame cross the
-       relative velocity.
-     */
-    Vector6 pivel = getParentSpVel();
-    return Vector6(cross(pivel.getAngular(), getAngularRelVel()),
-                   cross(pivel.getAngular(), getLinearRelVel()) + 
-                   cross(pivel.getLinear(), getAngularRelVel()));
-  }
-
-  /** Position vector transform.
-      Transforms a position vector from the parent frame to the current
-      frame.
-      @param v The position vector in the parent frame to be transformed.
-      @return  The motion vector transformed to the current frame.
-   */
-  Vector3 posFromParent(const Vector3& v) const
-  { return posTo(getPosition(), getOrientation(), v); }
-
-  /** Position vector transform.
-      Transforms a position vector from the current frame to the parent
-      frame.
-      @param v The position in the current frame to be transformed.
-      @return  The position transformed to the parent frame.
-   */
-  Vector3 posToParent(const Vector3& v) const
-  { return posFrom(getPosition(), getOrientation(), v); }
-
-  /** Spatial motion vector transform.
-      Transforms a spatial motion vector from the parent frame to the current
-      frame.
-      @param v The motion vector in the parent frame to be transformed.
-      @return  The motion vector transformed to the current frame.
-   */
-  Vector6 motionFromParent(const Vector6& v) const
-  { return motionTo(getPosition(), getOrientation(), v); }
-
-  /** Spatial motion vector transform.
-      Transforms a spatial motion vector from the current frame to the parent
-      frame.
-      @param v The motion vector in the current frame to be transformed.
-      @return  The motion vector transformed to the parent frame.
-   */
-  Vector6 motionToParent(const Vector6& v) const
-  { return motionFrom(getPosition(), getOrientation(), v); }
-
-  /** Spatial force vector transform.
-      Transforms a spatial force vector from the parent frame to the current
-      frame.
-      @param v The force vector in the parent frame to be transformed.
-      @return  The force vector transformed to the current frame.
-   */
-  Vector6 forceFromParent(const Vector6& v) const
-  { return forceTo(getPosition(), getOrientation(), v); }
-
-  /** Spatial force vector transform.
-      Transforms a spatial force vector from the current frame to the parent
-      frame.
-      @param v The force vector in the current frame to be transformed.
-      @return  The force vector transformed to the parent frame.
-   */
-  Vector6 forceToParent(const Vector6& v) const
-  { return forceFrom(getPosition(), getOrientation(), v); }
-
-  Plane planeFromParent(const Plane& plane) const
-  { return planeTo(getPosition(), getOrientation(), plane); }
-
-  Plane planeToParent(const Plane& plane) const
-  { return planeFrom(getPosition(), getOrientation(), plane); }
-
-  /** Rotation to reference frames coordinates.
-      @param v Vector in current frames coordinates to rotate to reference
-               frames coordinates.
-      @return  The vector v in the reference frames coordinates.
-   */
-  Vector3 rotToRef(const Vector3& v) const
-  { return getRefOrientation().backTransform(v); }
-
-  /** Rotation from reference frames coordinates.
-      @param v Vector in reference frames coordinates to rotate to current
-               frames coordinates.
-      @return  The vector v in the current frames coordinates.
-   */
-  Vector3 rotFromRef(const Vector3& v) const
-  { return getRefOrientation().transform(v); }
-
-
-  /** Position vector transform.
-      Transforms a position vector from the reference frame to the current
-      frame.
-      @param v The position vector in the reference frame to be transformed.
-      @return  The motion vector transformed to the current frame.
-   */
-  Vector3 posFromRef(const Vector3& v) const
-  { return posTo(getRefPosition(), getRefOrientation(), v); }
-
-  /** Position vector transform.
-      Transforms a position vector from the current frame to the reference
-      frame.
-      @param v The position in the current frame to be transformed.
-      @return  The position transformed to the reference frame.
-   */
-  Vector3 posToRef(const Vector3& v) const
-  { return posFrom(getRefPosition(), getRefOrientation(), v); }
-
-
-  /** Spatial motion vector transform.
-      Transforms a spatial motion vector from the parent frame to the current
-      frame.
-      @param v The motion vector in the parent frame to be transformed.
-      @return  The motion vector transformed to the current frame.
-   */
-  Vector6 motionFromRef(const Vector6& v) const
-  { return motionTo(getRefPosition(), getRefOrientation(), v); }
-
-  /** Spatial motion vector transform.
-      Transforms a spatial motion vector from the current frame to the parent
-      frame.
-      @param v The motion vector in the current frame to be transformed.
-      @return  The motion vector transformed to the parent frame.
-   */
-  Vector6 motionToRef(const Vector6& v) const
-  { return motionFrom(getRefPosition(), getRefOrientation(), v); }
-
-  Plane planeFromRef(const Plane& plane) const
-  { return planeTo(getRefPosition(), getRefOrientation(), plane); }
-
-  Plane planeToRef(const Plane& plane) const
-  { return planeFrom(getRefPosition(), getRefOrientation(), plane); }
-
-  /** Reference orientation.
-   * Returns the reference orientation of this frame wrt the topmost frame 
-   * this frame is attached to.
-   * It is measured in the topmost frames coordinates.
-   */
-  const Quaternion& getRefOrientation(void) const
-  { return mRefOrient; }
-
-  /** Reference position.
-   * Returns the reference position of this frame wrt the topmost frame 
-   * this frame is attached to.
-   * It is measured in the topmost frames coordinates.
-   */
-  const Vector3& getRefPosition(void) const
-  { return mRefPos; }
-
-private:
-  // The offset of this frames origin wrt the parent frame measured in
-  // the parent frames coordinates.
-  Vector3 mPosition;
-  // The orientation wrt the parent frame (measured in the parent frames
-  Rotation mOrientation;
-
-  // The spatial velocity wrt parent frame measured in
-  // this frames coordinates.
-  // True? more the relative velocity ...
-  Vector6 mRelVel;
-
-  Vector6 mRelVelDot;
-
-  Vector6 mParentSpVel;
-  Vector6 mParentSpAccel;
-
-  Quaternion mRefOrient;
-  Vector3 mRefPos;
-  Vector6 mRefVel;
-};
-
-} // namespace OpenFDM
-
-#endif

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/HDF5SystemOutput.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/HDF5SystemOutput.h	2009-07-13 18:45:50 UTC (rev 1004)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/HDF5SystemOutput.h	2009-07-15 05:21:29 UTC (rev 1005)
@@ -349,7 +349,6 @@
       _orientation(_group, "orientation", Size(4, 1)),
       _eulerAngle(_group, "eulerAngles", Size(3, 1)),
       _velocity(_group, "velocity", Size(6, 1)),
-      _refVelocity(_group, "refVelocity", Size(6, 1)),
       _acceleration(_group, "acceleration", Size(6, 1)),
       _force(_group, "force", Size(6, 1)),
       _inertia(_group, "inertia", Size(6, 6))
@@ -360,9 +359,8 @@
       _position.append(cs.getPosition());
       _orientation.append(cs.getOrientation());
       _eulerAngle.append(cs.getOrientation().getEuler());
-      _velocity.append(mMechanicLinkValue->getSpVel());
-      _refVelocity.append(mMechanicLinkValue->getReferenceVelocity());
-      _acceleration.append(mMechanicLinkValue->getSpAccel());
+      _velocity.append(mMechanicLinkValue->getLocalVelocity());
+      _acceleration.append(mMechanicLinkValue->getLocalAcceleration());
       _force.append(mMechanicLinkValue->getForce());
       _inertia.append(mMechanicLinkValue->getInertia());
     }
@@ -375,7 +373,6 @@
     HDFMatrixStream _orientation;
     HDFMatrixStream _eulerAngle;
     HDFMatrixStream _velocity;
-    HDFMatrixStream _refVelocity;
     HDFMatrixStream _acceleration;
     HDFMatrixStream _force;
     HDFMatrixStream _inertia;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/InternalInteract.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/InternalInteract.cpp	2009-07-13 18:45:50 UTC (rev 1004)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/InternalInteract.cpp	2009-07-15 05:21:29 UTC (rev 1005)
@@ -58,9 +58,9 @@
 
     if (mVelocityValue.isConnected()) {
       // The motion of link1 measured in link0
-      Vector6 relVel = mRelCoordSys.motionToReference(getLink1().getRefVel());
+      Vector6 relVel = mRelCoordSys.motionToReference(getLink1().getLocalVelocity());
       // The relative motion of link1 wrt link0 measured in link0
-      relVel -= getLink0().getRefVel();
+      relVel -= getLink0().getLocalVelocity();
       // The scalar product is what we need.
       // Here the additional cross product term cancels out
       mVelocityValue = dot(mDirection, relVel.getLinear());

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Launchbar.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Launchbar.cpp	2009-07-13 18:45:50 UTC (rev 1004)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Launchbar.cpp	2009-07-15 05:21:29 UTC (rev 1005)
@@ -8,7 +8,6 @@
 #include "LogStream.h"
 #include "Object.h"
 #include "Vector.h"
-#include "Frame.h"
 #include "Force.h"
 
 namespace OpenFDM {

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Launchbar.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Launchbar.h	2009-07-13 18:45:50 UTC (rev 1004)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Launchbar.h	2009-07-15 05:21:29 UTC (rev 1005)
@@ -8,7 +8,6 @@
 #include "Assert.h"
 #include "Object.h"
 #include "Vector.h"
-#include "Frame.h"
 #include "Force.h"
 #include "Ground.h"
 #include "Environment.h"

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2009-07-13 18:45:50 UTC (rev 1004)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2009-07-15 05:21:29 UTC (rev 1005)
@@ -38,7 +38,6 @@
   ExplicitEuler.h \
   FlatPlanet.h \
   Fraction.h \
-  Frame.h \
   Function.h \
   Group.h \
   GroupInterfaceNode.h \

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Mass.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Mass.cpp	2009-07-13 18:45:50 UTC (rev 1004)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Mass.cpp	2009-07-15 05:21:29 UTC (rev 1005)
@@ -43,7 +43,7 @@
 
     // Each inertia has a contribution to the spatial bias force.
     // This part is handled here.
-    Vector6 v = getLink().getSpVelAtLink();
+    Vector6 v = getLink().getLocalVelocityAtLink();
     Vector6 Iv = mSpatialInertia*v;
     Vector6 vIv = Vector6(cross(v.getAngular(), Iv.getAngular()) +
                           cross(v.getLinear(), Iv.getLinear()),

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.cpp	2009-07-13 18:45:50 UTC (rev 1004)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.cpp	2009-07-15 05:21:29 UTC (rev 1005)
@@ -16,4 +16,16 @@
 {
 }
 
+MechanicLinkValue*
+MechanicLinkValue::toMechanicLinkValue()
+{
+  return this;
+}
+
+const MechanicLinkValue*
+MechanicLinkValue::toMechanicLinkValue() const
+{
+  return this;
+}
+
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.h	2009-07-13 18:45:50 UTC (rev 1004)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.h	2009-07-15 05:21:29 UTC (rev 1005)
@@ -6,7 +6,6 @@
 #define OpenFDM_MechanicLinkValue_H
 
 #include "CoordinateSystem.h"
-#include "Frame.h"
 #include "Inertia.h"
 #include "PortValue.h"
 
@@ -17,10 +16,9 @@
   MechanicLinkValue();
   virtual ~MechanicLinkValue();
 
-  virtual MechanicLinkValue* toMechanicLinkValue() { return this; }
-  virtual const MechanicLinkValue* toMechanicLinkValue() const { return this; }
+  virtual MechanicLinkValue* toMechanicLinkValue();
+  virtual const MechanicLinkValue* toMechanicLinkValue() const;
 
-  /// Currently duplicate information from the Frame.
   /// This is an attempt to seperate the coordinate system stuff away from
   /// the reference frame handling.
   const CoordinateSystem& getCoordinateSystem() const
@@ -63,63 +61,67 @@
   getRelativeCoordinateSystem(const MechanicLinkValue& link) const
   { return mCoordinateSystem.toLocal(link.mCoordinateSystem); }
 
-  /// Returns the velocity of the link measured in this links coordinate
-  /// system and measured in this links reference frame
-  Vector6 getRelativeVelocity(const MechanicLinkValue& link) const
-  {
-    CoordinateSystem csys = getRelativeCoordinateSystem(link);
-    return csys.motionToReference(link.getSpVel()) - getSpVel();
-  }
+  void setLocalVelocity(const Vector6& velocity)
+  { mVelocity = mCoordinateSystem.rotToReference(velocity); }
+  Vector6 getLocalVelocity() const
+  { return mCoordinateSystem.rotToLocal(mVelocity); }
 
+  void setLocalAcceleration(const Vector6& acceleration)
+  { mAcceleration = mCoordinateSystem.rotToReference(acceleration); }
+  Vector6 getLocalAcceleration() const
+  { return mCoordinateSystem.rotToLocal(mAcceleration); }
 
-//   const Vector6& getSpVel() const
-  Vector6 getSpVel() const
-  { return mFrame.getSpVel(); }
-//   const Vector6& getSpAccel() const
-  Vector6 getSpAccel() const
-  { return mFrame.getSpAccel(); }
 
+  void setVelocity(const Vector6& velocity)
+  { mVelocity = velocity; }
+  const Vector6& getVelocity() const
+  { return mVelocity; }
 
+  void setAcceleration(const Vector6& acceleration)
+  { mAcceleration = acceleration; }
+  const Vector6& getAcceleration() const
+  { return mAcceleration; }
 
 
-  void setPosAndVel(const MechanicLinkValue& linkValue, const Vector3& position,
-                    const Quaternion& orientation, const Vector6& velocity)
+  void setRelativeVelocity(const MechanicLinkValue& linkValue,
+                           const Vector6& velocity)
   {
     mArticulatedInertia = SpatialInertia::zeros();
     mArticulatedForce = Vector6::zeros();
-    mFrame.setPosAndVel(linkValue.mFrame, position, orientation, velocity);
+
+    Vector3 positionDiff = mCoordinateSystem.getPosition();
+    positionDiff -= linkValue.mCoordinateSystem.getPosition();
+    Vector6 parentVel = motionTo(positionDiff, linkValue.mVelocity);
+    mVelocity = mCoordinateSystem.rotToReference(velocity) + parentVel;
   }
-  void setAccel(const MechanicLinkValue& linkValue, const Vector6& accel)
-  { mFrame.setAccel(linkValue.mFrame, accel); }
-  void setPosAndVel(const Vector3& parentAngularVel, const Vector3& position,
-                    const Quaternion& orientation, const Vector6& velocity)
+  void setBaseVelocity(const Vector3& baseAngularVel, const Vector6& velocity)
   {
     mArticulatedInertia = SpatialInertia::zeros();
     mArticulatedForce = Vector6::zeros();
-    mFrame.setPosAndVel(parentAngularVel, position, orientation, velocity);
+
+    Vector3 referencePos = mCoordinateSystem.getPosition();
+    Vector6 parentVel = angularMotionTo(referencePos, baseAngularVel);
+    mVelocity = mCoordinateSystem.rotToReference(velocity) + parentVel;
   }
-  void setSpAccel(const Vector6& accel)
-  { mFrame.setSpAccel(accel); }
 
-  Vector6 getRelVelDot() const
-  { return mFrame.getRelVelDot(); }
-
   const Vector3& getDesignPosition() const
   { return mDesignPosition; }
   void setDesignPosition(const Vector3& designPosition)
   { mDesignPosition = designPosition; }
 
-  /// Returns the spatial reference velocity at the local position
-  Vector6 getReferenceVelocity(const Vector3& position) const
-  { return motionTo(position, mFrame.getRefVel()); }
-  Vector6 getReferenceVelocity() const
-  { return mFrame.getRefVel(); }
-
 protected:
   /// The local coordinate system of the mechanic link.
   CoordinateSystem mCoordinateSystem;
 
-  Frame mFrame;
+  /// The spatial velocity at the origin of the coordinate system
+  /// measured in global coordinate systems coordinates.
+  /// The spacial velocities pivot point is at the coordinate systems origin.
+  Vector6 mVelocity;
+  /// The spatial acceleration at the origin of the coordinate system
+  /// measured in global coordinate systems coordinates.
+  /// The spacial velocities pivot point is at the coordinate systems origin.
+  Vector6 mAcceleration;
+
   Vector6 mArticulatedForce;
   SpatialInertia mArticulatedInertia;
 
@@ -170,31 +172,26 @@
     return mMechanicLinkValue->getCoordinateSystem().getOrientation();
   }
 
-  Vector6 getSpVelAtLink() const
+  Vector6 getLocalVelocityAtLink() const
   {
     OpenFDMAssert(isConnected());
-    return mMechanicLinkValue->getSpVel();
+    return mMechanicLinkValue->getLocalVelocity();
   }
-  Vector6 getSpAccelAtLink() const
+  Vector6 getLocalAccelerationAtLink() const
   {
     OpenFDMAssert(isConnected());
-    return mMechanicLinkValue->getSpAccel();
+    return mMechanicLinkValue->getLocalAcceleration();
   }
-  Vector6 getSpVel() const
+  Vector6 getLocalVelocity() const
   {
     OpenFDMAssert(isConnected());
-    return motionTo(mLinkRelPos, mMechanicLinkValue->getSpVel());
+    return motionTo(mLinkRelPos, mMechanicLinkValue->getLocalVelocity());
   }
-  Vector6 getRefVel() const
+  Vector6 getLocalAcceleration() const
   {
     OpenFDMAssert(isConnected());
-    return mMechanicLinkValue->getReferenceVelocity(mLinkRelPos);
+    return motionTo(mLinkRelPos, mMechanicLinkValue->getLocalAcceleration());
   }
-  Vector6 getSpAccel() const
-  {
-    OpenFDMAssert(isConnected());
-    return motionTo(mLinkRelPos, mMechanicLinkValue->getSpAccel());
-  }
 
   void setDesignPosition(const Vector3& position)
   {
@@ -287,54 +284,35 @@
   void setDesignPosition(const Vector3& position)
   { mMechanicLinkValue->setDesignPosition(position); }
 
-  void setPosAndVel(const Vector3& angularBaseVel, const Vector3& position,
-                    const Quaternion& orientation, const Vector6& velocity)
-  {
-    mMechanicLinkValue->setPosAndVel(angularBaseVel, position,
-                                     orientation, velocity);
-  }
-  void setSpAccel(const Vector6& accel)
-  {
-    mMechanicLinkValue->setSpAccel(accel);
-  }
-  Vector6 getSpAccel() const
-  {
-    return mMechanicLinkValue->getSpAccel();
-  }
+  void setLocalAcceleration(const Vector6& accel)
+  { mMechanicLinkValue->setLocalAcceleration(accel); }
+  Vector6 getLocalAcceleration() const
+  { return mMechanicLinkValue->getLocalAcceleration(); }
 
-  void setPosAndVel(const ParentLink& parentLink, const Vector3& position,
-                    const Quaternion& orientation, const Vector6& velocity)
+  void setAcceleration(const Vector6& accel)
+  { mMechanicLinkValue->setAcceleration(accel); }
+  const Vector6& getAcceleration() const
+  { return mMechanicLinkValue->getAcceleration(); }
+
+  void setBaseVelocity(const Vector3& angularBaseVel, const Vector6& velocity)
+  { mMechanicLinkValue->setBaseVelocity(angularBaseVel, velocity); }
+
+  void setRelativeVelocity(const ParentLink& parentLink,
+                           const Vector6& velocity)
   {
     const MechanicLinkValue& link = parentLink.getMechanicLinkValue();
-    mMechanicLinkValue->setPosAndVel(link, position, orientation, velocity);
+    mMechanicLinkValue->setRelativeVelocity(link, velocity);
   }
-  void setAccel(const ParentLink& parentLink, const Vector6& accel)
-  {
-    const MechanicLinkValue& link = parentLink.getMechanicLinkValue();
-    mMechanicLinkValue->setAccel(link, accel);
-  }
 
   void setCoordinateSystem(const CoordinateSystem& coordinateSystem)
-  {
-    OpenFDMAssert(mMechanicLinkValue);
-    return mMechanicLinkValue->setCoordinateSystem(coordinateSystem);
-  }
+  { return mMechanicLinkValue->setCoordinateSystem(coordinateSystem); }
   const CoordinateSystem& getCoordinateSystem() const
-  {
-    OpenFDMAssert(mMechanicLinkValue);
-    return mMechanicLinkValue->getCoordinateSystem();
-  }
+  { return mMechanicLinkValue->getCoordinateSystem(); }
 
   const Vector6& getForce() const
-  {
-    OpenFDMAssert(mMechanicLinkValue);
-    return mMechanicLinkValue->getForce();
-  }
+  { return mMechanicLinkValue->getForce(); }
   const SpatialInertia& getInertia() const
-  {
-    OpenFDMAssert(mMechanicLinkValue);
-    return mMechanicLinkValue->getInertia();
-  }
+  { return mMechanicLinkValue->getInertia(); }
  
 private:
   SharedPtr<MechanicLinkValue> mMechanicLinkValue;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJoint.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJoint.cpp	2009-07-13 18:45:50 UTC (rev 1004)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MobileRootJoint.cpp	2009-07-15 05:21:29 UTC (rev 1005)
@@ -52,7 +52,7 @@
     SpatialInertia inertia = mChildLink.getInertia();
     Vector6 force = -mChildLink.getForce();
     Vector6 spatialAcceleration = solve(inertia, force);
-    mChildLink.setSpAccel(spatialAcceleration);
+    mChildLink.setLocalAcceleration(spatialAcceleration);
   }
   
   virtual void derivative(const Task& task)
@@ -179,7 +179,7 @@
   Vector6 velocity = continousState[*mVelocityStateInfo];
 
   childLink.setCoordinateSystem(CoordinateSystem(position, orientation));
-  childLink.setPosAndVel(angularBaseVelocity, position, orientation, velocity);
+  childLink.setBaseVelocity(angularBaseVelocity, velocity);
 }
 
 void
@@ -219,7 +219,7 @@
                          cross(pivel.getAngular(), relVel.getLinear()) + 
                          cross(pivel.getLinear(), relVel.getAngular()));
 
-  Vector6 velDeriv = childLink.getSpAccel() - spatialAcceleration - Hdot;
+  Vector6 velDeriv = childLink.getLocalAcceleration() - spatialAcceleration - Hdot;
 
   derivatives[*mPositionStateInfo] = pDot;
   derivatives[*mOrientationStateInfo] = qderiv;

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/PacejkaTire.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/PacejkaTire.cpp	2009-07-13 18:45:50 UTC (rev 1004)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/PacejkaTire.cpp	2009-07-15 05:21:29 UTC (rev 1005)
@@ -91,7 +91,7 @@
     // The relative velocity of the wheel wrt the contact surface
     // measured in the hubs coordinate system.
     // This includes the wheels revolution speed.
-    Vector6 relVel = getLink().getRefVel() - groundValues.vel;
+    Vector6 relVel = getLink().getLocalVelocity() - groundValues.vel;
 
     // The compression velocity.
     // Positive when the contact spring is compressed,

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Tailhook.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Tailhook.cpp	2009-07-13 18:45:50 UTC (rev 1004)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Tailhook.cpp	2009-07-15 05:21:29 UTC (rev 1005)
@@ -8,7 +8,6 @@
 #include "LogStream.h"
 #include "Object.h"
 #include "Vector.h"
-#include "Frame.h"
 #include "Force.h"
 
 namespace OpenFDM {

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Tailhook.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Tailhook.h	2009-07-13 18:45:50 UTC (rev 1004)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Tailhook.h	2009-07-15 05:21:29 UTC (rev 1005)
@@ -8,7 +8,6 @@
 #include "Assert.h"
 #include "Object.h"
 #include "Vector.h"
-#include "Frame.h"
 #include "Force.h"
 #include "Ground.h"
 #include "Environment.h"

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/WheelContact.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/WheelContact.cpp	2009-07-13 18:45:50 UTC (rev 1004)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/WheelContact.cpp	2009-07-15 05:21:29 UTC (rev 1005)
@@ -56,7 +56,7 @@
     Vector3 contactPoint = distHubGround*down;
     
     // The relative velocity of the ground wrt the contact point
-    Vector6 relVel = getLink().getRefVel() - groundValues.vel;
+    Vector6 relVel = getLink().getLocalVelocity() - groundValues.vel;
     
     // The velocity perpandicular to the plane.
     // Positive when the contact spring is compressed,



From frohlich at mail.berlios.de  Tue Jul 21 20:05:31 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Tue, 21 Jul 2009 20:05:31 +0200
Subject: [OpenFDM-svn] r1021 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200907211805.n6LI5VSv031243@sheep.berlios.de>

Author: frohlich
Date: 2009-07-21 20:05:30 +0200 (Tue, 21 Jul 2009)
New Revision: 1021

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/ExternalInteract.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.h
Log:
More link value cleanup.

M    MechanicLinkValue.h
M    ExternalInteract.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/ExternalInteract.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ExternalInteract.cpp	2009-07-20 20:49:48 UTC (rev 1020)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ExternalInteract.cpp	2009-07-21 18:05:30 UTC (rev 1021)
@@ -70,15 +70,15 @@
     const CoordinateSystem& cs = getLink().getCoordinateSystem();
 
     // The global coordinates position
-    Vector3 refPosition = getLink().getRefPos();
+    Vector3 refPosition = cs.getPosition();
     if (mPosition.isConnected())
       mPosition = refPosition;
     
     if (mOrientation.isConnected())
-      mOrientation = getLink().getRefOr();
+      mOrientation = cs.getOrientation();
     
     if (mEulerAngles.isConnected())
-      mEulerAngles = getLink().getRefOr().getEuler();
+      mEulerAngles = cs.getOrientation().getEuler();
     
     // Velocity related sensing
     bool enableBodyAngularVelocity = mBodyAngularVelocity.isConnected();
@@ -90,28 +90,26 @@
     if (enableBodyAngularVelocity || enableBodyLinearVelocity
         || enableGlobalAngularVelocity || enableGlobalLinearVelocity
         || enableBodyWindVelocity || enableGlobalWindVelocity) {
-      Vector6 refVelocity = getLink().getLocalVelocity();
+      Vector6 refVelocity = getLink().getVelocity();
       if (enableBodyAngularVelocity)
-        mBodyAngularVelocity = refVelocity.getAngular();
+        mBodyAngularVelocity = cs.rotToLocal(refVelocity.getAngular());
       if (enableGlobalAngularVelocity)
-        mGlobalAngularVelocity = cs.rotToReference(refVelocity.getAngular());
+        mGlobalAngularVelocity = refVelocity.getAngular();
       
       if (enableBodyLinearVelocity)
-        mBodyLinearVelocity = refVelocity.getLinear();
+        mBodyLinearVelocity = cs.rotToLocal(refVelocity.getLinear());
       if (enableGlobalLinearVelocity)
-        mGlobalLinearVelocity = cs.rotToReference(refVelocity.getLinear());
+        mGlobalLinearVelocity = refVelocity.getLinear();
       
       // Wind sensing
       if (enableBodyWindVelocity || enableGlobalWindVelocity) {
         Vector6 wind = getEnvironment().getWindVelocity(task.getTime(),
                                                         refPosition);
-        wind = Vector6(cs.rotToLocal(wind.getAngular()),
-                       cs.rotToLocal(wind.getLinear()));
         wind -= refVelocity;
         if (enableBodyWindVelocity)
-          mBodyWindVelocity = wind.getLinear();
+          mBodyWindVelocity = cs.rotToLocal(wind.getLinear());
         if (enableGlobalWindVelocity)
-          mGlobalWindVelocity = cs.rotToReference(wind.getLinear());
+          mGlobalWindVelocity = wind.getLinear();
       }
     }
     
@@ -170,19 +168,20 @@
       = mBodyCentrifugalAcceleration.isConnected();
     bool enableBodyLoad = mBodyLoad.isConnected();
     if (enableBodyCentrifugalAcceleration || enableBodyLoad) {
-      Vector6 spatialVel = getLink().getLocalVelocity();
-      Vector6 spatialAccel = getLink().getLocalAcceleration();
+      const CoordinateSystem& cs = getLink().getCoordinateSystem();
+
+      Vector6 spatialVel = getLink().getInertialVelocity();
+      Vector6 spatialAccel = getLink().getInertialAcceleration();
       Vector3 centrifugalAccel = spatialAccel.getLinear();
       centrifugalAccel += cross(spatialVel.getAngular(),spatialVel.getLinear());
 
       if (enableBodyCentrifugalAcceleration)
-        mBodyCentrifugalAcceleration = centrifugalAccel;
+        mBodyCentrifugalAcceleration = cs.rotToLocal(centrifugalAccel);
       if (enableBodyLoad) {
         // May be cache that from the velocity step??
-        Vector3 refPosition = getLink().getRefPos();
+        Vector3 refPosition = cs.getPosition();
         Vector3 gravity = getEnvironment().getGravityAcceleration(refPosition);
-        gravity = getLink().getCoordinateSystem().rotToLocal(gravity);
-        mBodyLoad = centrifugalAccel - gravity;
+        mBodyLoad = cs.rotToLocal(Vector3(centrifugalAccel - gravity));
       }
     }
   }

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.h	2009-07-20 20:49:48 UTC (rev 1020)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.h	2009-07-21 18:05:30 UTC (rev 1021)
@@ -242,17 +242,6 @@
   CoordinateSystem getRelativeCoordinateSystem(const ParentLink& link) const
   { return getCoordinateSystem().toLocal(link.getCoordinateSystem()); }
 
-  Vector3 getRefPos() const
-  {
-    OpenFDMAssert(isConnected());
-    return mMechanicLinkValue->getCoordinateSystem().toReference(mLinkRelPos);
-  }
-  const Rotation& getRefOr() const
-  {
-    OpenFDMAssert(isConnected());
-    return mMechanicLinkValue->getCoordinateSystem().getOrientation();
-  }
-
   Vector6 getVelocity(const Vector3& position) const
   {
     OpenFDMAssert(isConnected());



From frohlich at mail.berlios.de  Tue Jul 21 20:17:30 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Tue, 21 Jul 2009 20:17:30 +0200
Subject: [OpenFDM-svn] r1022 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200907211817.n6LIHURo001167@sheep.berlios.de>

Author: frohlich
Date: 2009-07-21 20:17:29 +0200 (Tue, 21 Jul 2009)
New Revision: 1022

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.h
Log:
Remove unused function.

M    MechanicLinkValue.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.h	2009-07-21 18:05:30 UTC (rev 1021)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MechanicLinkValue.h	2009-07-21 18:17:29 UTC (rev 1022)
@@ -179,9 +179,6 @@
   Vector6 getLocalVelocity() const
   { return mCoordinateSystem.rotToLocal(mVelocity); }
 
-  Vector6 getLocalAcceleration() const
-  { return mCoordinateSystem.rotToLocal(mInertialAcceleration); }
-
 protected:
   /// The local coordinate system of the mechanic link.
   CoordinateSystem mCoordinateSystem;
@@ -280,11 +277,6 @@
     OpenFDMAssert(isConnected());
     return motionTo(mLinkRelPos, mMechanicLinkValue->getLocalVelocity());
   }
-  Vector6 getLocalAcceleration() const
-  {
-    OpenFDMAssert(isConnected());
-    return motionTo(mLinkRelPos, mMechanicLinkValue->getLocalAcceleration());
-  }
   const Vector6& getInertialAcceleration() const
   { return mMechanicLinkValue->getInertialAcceleration(); }
   const Vector6& getVelocity() const



From frohlich at mail.berlios.de  Fri Jul 24 20:22:01 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Fri, 24 Jul 2009 20:22:01 +0200
Subject: [OpenFDM-svn] r1023 - branches/OpenFDM-StateSeparation
Message-ID: <200907241822.n6OIM19f028916@sheep.berlios.de>

Author: frohlich
Date: 2009-07-24 20:22:00 +0200 (Fri, 24 Jul 2009)
New Revision: 1023

Modified:
   branches/OpenFDM-StateSeparation/TODO
Log:
More ideas.

M    TODO


Modified: branches/OpenFDM-StateSeparation/TODO
===================================================================
--- branches/OpenFDM-StateSeparation/TODO	2009-07-21 18:17:29 UTC (rev 1022)
+++ branches/OpenFDM-StateSeparation/TODO	2009-07-24 18:22:00 UTC (rev 1023)
@@ -56,10 +56,13 @@
 * System externe PortValues
 
 * Improove TransferFunction
-* Test TrasnferFunction!!
+* Test TransferFunction!!
 
 * AeroForces handling of alphadot/betadot.
 
+* Derivative by TransferFunction???
+* Stop simulation block?
+
 * Improove the WGS84 gravity
 * Add link property to tell if we already have the gravity applied at the
   root link or if this should be applied in the mass models.



From frohlich at mail.berlios.de  Sun Jul 26 22:52:40 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 26 Jul 2009 22:52:40 +0200
Subject: [OpenFDM-svn] r1024 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200907262052.n6QKqegC005906@sheep.berlios.de>

Author: frohlich
Date: 2009-07-26 22:52:40 +0200 (Sun, 26 Jul 2009)
New Revision: 1024

Added:
   branches/OpenFDM-StateSeparation/src/OpenFDM/MatrixConcat.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/MatrixConcat.h
Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
   branches/OpenFDM-StateSeparation/src/OpenFDM/Port.h
Log:
Add MatrixConcat model.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2009-07-24 18:22:00 UTC (rev 1023)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2009-07-26 20:52:40 UTC (rev 1024)
@@ -208,6 +208,7 @@
   Input.h \
   Integrator.h \
   LinearSpringDamper.h \
+  MatrixConcat.h \
   MaxModel.h \
   MinModel.h \
   Output.h \
@@ -237,6 +238,7 @@
   Input.cpp \
   Integrator.cpp \
   LinearSpringDamper.cpp \
+  MatrixConcat.cpp \
   MaxModel.cpp \
   MinModel.cpp \
   Output.cpp \

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/MatrixConcat.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MatrixConcat.cpp	2009-07-24 18:22:00 UTC (rev 1023)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MatrixConcat.cpp	2009-07-26 20:52:40 UTC (rev 1024)
@@ -0,0 +1,184 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2009 Mathias Froehlich 
+ *
+ */
+
+#include "MatrixConcat.h"
+
+#include "TypeInfo.h"
+
+namespace OpenFDM {
+
+BEGIN_OPENFDM_OBJECT_DEF(MatrixConcat, AbstractModel)
+  END_OPENFDM_OBJECT_DEF
+
+MatrixConcat::Context::Context(const MatrixConcat* matrixConcat,
+                               const InputValueVector& inputValues,
+                               NumericPortValue* outputValue) :
+  mMatrixConcat(matrixConcat),
+  mInputValues(inputValues),
+  mOutputValue(outputValue)
+{
+}
+
+MatrixConcat::Context::~Context()
+{
+}
+  
+const MatrixConcat&
+MatrixConcat::Context::getNode() const
+{
+  return *mMatrixConcat;
+}
+
+const PortValue*
+MatrixConcat::Context::getPortValue(const Port& port) const
+{
+  if (mMatrixConcat->mOutputPort == &port)
+    return mOutputValue;
+  OpenFDMAssert(mInputValues.size() == mMatrixConcat->mInputPorts.size());
+  for (unsigned i = 0; i < mInputValues.size(); ++i)
+    if (mMatrixConcat->mInputPorts[i] == &port)
+      return mInputValues[i];
+  return 0;
+}
+
+ContinousStateValue*
+MatrixConcat::Context::getStateValue(const ContinousStateInfo&)
+{
+  return 0;
+}
+
+ContinousStateValue*
+MatrixConcat::Context::getStateDerivative(const ContinousStateInfo&)
+{
+  return 0;
+}
+  
+void
+MatrixConcat::Context::init(const /*Init*/Task&)
+{
+}
+
+void
+MatrixConcat::Context::output(const Task& task)
+{
+  unsigned concatDimension = mMatrixConcat->getConcatDimension();
+  
+  // May be have two contexts for each if clause??
+  if (concatDimension == 0) {
+    unsigned currentPos = 0;
+    for (unsigned i = 0; i < mInputValues.size(); ++i) {
+      const Matrix& m = mInputValues[i]->getValue();
+      Size sz = size(m);
+      mOutputValue->getValue()(Range(currentPos, currentPos + sz(0) - 1),
+                               Range(0, sz(1) - 1)) = m;
+      currentPos += sz(0);
+    }
+  } else {
+    unsigned currentPos = 0;
+    for (unsigned i = 0; i < mInputValues.size(); ++i) {
+      const Matrix& m = mInputValues[i]->getValue();
+      Size sz = size(m);
+      mOutputValue->getValue()(Range(0, sz(0) - 1),
+                               Range(currentPos, currentPos + sz(1) - 1)) = m;
+      currentPos += sz(1);
+    }
+  }
+}
+
+void
+MatrixConcat::Context::update(const DiscreteTask&)
+{
+}
+
+void
+MatrixConcat::Context::derivative(const Task&)
+{
+}
+
+MatrixConcat::MatrixConcat(const std::string& name) :
+  AbstractModel(name),
+  mOutputPort(new OutputPort(this, "output", Size(0, 0), false)),
+  mConcatDimension(0)
+{
+}
+
+MatrixConcat::~MatrixConcat(void)
+{
+}
+  
+MatrixConcat::Context*
+MatrixConcat::newModelContext(PortValueList& portValueList) const
+{
+  if (mInputPorts.empty()) {
+    Log(Initialization, Info)
+      << "No input ports in models with multiple inputs!" << std::endl;
+    return 0;
+  }
+  
+  NumericPortValue* outputPortValue = portValueList.getPortValue(mOutputPort);
+  if (!outputPortValue) {
+    Log(Initialization, Warning)
+      << "Output port value not connected for model \"" << getName()
+      << "\"!" << std::endl;
+    return 0;
+  }
+  InputValueVector inputValues;
+  
+  // Look into all ports and get the best size match.
+  Size sz = size(outputPortValue->getValue());
+  unsigned concatSum = 0;
+  for (unsigned i = 0; i < mInputPorts.size(); ++i) {
+    NumericPortValue* npv = portValueList.getPortValue(mInputPorts[i]);
+    inputValues.push_back(npv);
+    Size sz2 = size(npv->getValue());
+    // If the ports size is undefined, use the size variabe here.
+    unsigned j = getNonConcatDimension();
+    if (sz(j) == 0) {
+      sz(j) = sz2(j);
+    } else {
+      if (sz2(j) != 0 && sz(j) != sz2(j)) {
+        Log(Initialization, Info)
+          << "Port size " << sz2 << "of port " << j
+          << " does not match for model \"" << getName() << "\"!" << std::endl;
+        return 0;
+      }
+    }
+    concatSum += sz2(getConcatDimension());
+  }
+  if (sz(getConcatDimension()) == 0) {
+    sz(getConcatDimension()) = concatSum;
+  } else if (sz(getConcatDimension()) != concatSum) {
+    Log(Initialization, Info)
+      << "Port size sum does not match for model \""
+      << getName() << "\"!" << std::endl;
+    return 0;
+  }
+  
+  // Ok, success in checking output and input ports, set them all.
+  if (!portValueList.setOrCheckPortSize(mOutputPort, sz)) {
+    Log(Initialization, Info) << "Port sizes do not match!" << std::endl;
+    return 0;
+  }
+  for (unsigned i = 0; i < mInputPorts.size(); ++i) {
+    Size sz2 = mInputPorts[i]->getSize();
+    sz2(getNonConcatDimension()) = sz(getNonConcatDimension());
+    if (!portValueList.setOrCheckPortSize(mInputPorts[i], sz2)) {
+      Log(Initialization, Info) << "Port sizes do not match!" << std::endl;
+      return 0;
+    }
+  }
+  
+  return new Context(this, inputValues, outputPortValue);
+}
+
+const InputPort*
+MatrixConcat::addInputPort(const std::string& name, unsigned dimension)
+{
+  Size size(0, 0);
+  size(getConcatDimension()) = dimension;
+  mInputPorts.push_back(new InputPort(this, name, size, true));
+  return mInputPorts.back();
+}
+
+} // namespace OpenFDM


Property changes on: branches/OpenFDM-StateSeparation/src/OpenFDM/MatrixConcat.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/MatrixConcat.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MatrixConcat.h	2009-07-24 18:22:00 UTC (rev 1023)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MatrixConcat.h	2009-07-26 20:52:40 UTC (rev 1024)
@@ -0,0 +1,72 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2009 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_MatrixConcat_H
+#define OpenFDM_MatrixConcat_H
+
+#include <string>
+
+#include "Types.h"
+#include "AbstractModel.h"
+#include "ModelContext.h"
+
+namespace OpenFDM {
+
+class MatrixConcat : public AbstractModel {
+  OPENFDM_OBJECT(MatrixConcat, AbstractModel);
+private:
+  class Context;
+public:
+  MatrixConcat(const std::string& name);
+  virtual ~MatrixConcat(void);
+  
+  virtual Context* newModelContext(PortValueList& portValueList) const;
+
+  unsigned getConcatDimension() const
+  { return mConcatDimension; }
+  void setConcatDimension(unsigned concatDimension)
+  { mConcatDimension = concatDimension; }
+
+  const InputPort* addInputPort(const std::string& name, unsigned dimension = 1);
+  
+private:
+  typedef std::vector<SharedPtr<const NumericPortValue> > InputValueVector;
+
+  class Context : public AbstractModelContext {
+  public:
+    Context(const MatrixConcat* matrixConcat,
+            const InputValueVector& inputValues,
+            NumericPortValue* outputValue);
+    virtual ~Context();
+  
+    virtual const MatrixConcat& getNode() const;
+    virtual const PortValue* getPortValue(const Port& port) const;
+  
+    virtual ContinousStateValue* getStateValue(const ContinousStateInfo&);
+    virtual ContinousStateValue* getStateDerivative(const ContinousStateInfo&);
+  
+    virtual void init(const /*Init*/Task&);
+    virtual void output(const Task& task);
+    virtual void update(const DiscreteTask&);
+    virtual void derivative(const Task&);
+  private:
+    SharedPtr<const MatrixConcat> mMatrixConcat;
+    InputValueVector mInputValues;
+    SharedPtr<NumericPortValue> mOutputValue;
+  };
+
+  unsigned getNonConcatDimension() const
+  { return (mConcatDimension == 0) ? 1 : 0; }
+
+  SharedPtr<OutputPort> mOutputPort;
+
+  typedef std::vector<SharedPtr<InputPort> > InputPortVector;
+  InputPortVector mInputPorts;
+
+  unsigned mConcatDimension;
+};
+
+} // namespace OpenFDM
+
+#endif


Property changes on: branches/OpenFDM-StateSeparation/src/OpenFDM/MatrixConcat.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Port.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Port.h	2009-07-24 18:22:00 UTC (rev 1023)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Port.h	2009-07-26 20:52:40 UTC (rev 1024)
@@ -109,15 +109,24 @@
     numericPortValue = portValue->toNumericPortValue();
     if (!numericPortValue)
       return false;
-    if (mSize == Size(0, 0))
-      return true;
-    if (size(numericPortValue->getValue()) == Size(0, 0)) {
-      numericPortValue->getValue().resize(mSize(0), mSize(1));
-      return true;
+    Size sz = size(numericPortValue->getValue());
+    for (unsigned i = 0; i < 2; ++i) {
+      if (mSize(i) == 0)
+        continue;
+      if (sz(i) == 0)
+        continue;
+      if (mSize(i) != sz(i))
+        return false;
     }
-    return size(numericPortValue->getValue()) == mSize;
+    numericPortValue->getValue().resize(sz(0), sz(1));
+    return true;
   }
 
+  const Size& getSize() const
+  { return mSize; }
+  void setSize(const Size& size)
+  { mSize = size; }
+
 protected:
   Size mSize;
 };



From frohlich at mail.berlios.de  Sun Jul 26 22:57:54 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 26 Jul 2009 22:57:54 +0200
Subject: [OpenFDM-svn] r1025 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200907262057.n6QKvsIH006474@sheep.berlios.de>

Author: frohlich
Date: 2009-07-26 22:57:53 +0200 (Sun, 26 Jul 2009)
New Revision: 1025

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
Log:
Make an error message more verbose.

M    System.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2009-07-26 20:52:40 UTC (rev 1024)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2009-07-26 20:57:53 UTC (rev 1025)
@@ -476,7 +476,7 @@
           return false;
         }
         if (!mPortDataVector[i]->getPort()->acceptPortValue(portValue)) {
-          Log(Schedule, Warning) << "Failed to fetch port value \""
+          Log(Schedule, Warning) << "Failed to accept fetched port value \""
                                  << mPortDataVector[i]->getPort()->getName()
                                  << "\" of \"" << getNodeNamePath()
                                  << "\".\nAborting!" << endl;



From frohlich at mail.berlios.de  Sun Jul 26 23:13:09 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 26 Jul 2009 23:13:09 +0200
Subject: [OpenFDM-svn] r1026 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200907262113.n6QLD9Yg007904@sheep.berlios.de>

Author: frohlich
Date: 2009-07-26 23:13:09 +0200 (Sun, 26 Jul 2009)
New Revision: 1026

Added:
   branches/OpenFDM-StateSeparation/src/OpenFDM/MatrixSplit.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/MatrixSplit.h
Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
Log:
Add MatrixSplit model.

AM   MatrixSplit.cpp
AM   MatrixSplit.h
M    Makefile.am


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2009-07-26 20:57:53 UTC (rev 1025)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2009-07-26 21:13:09 UTC (rev 1026)
@@ -209,6 +209,7 @@
   Integrator.h \
   LinearSpringDamper.h \
   MatrixConcat.h \
+  MatrixSplit.h \
   MaxModel.h \
   MinModel.h \
   Output.h \
@@ -239,6 +240,7 @@
   Integrator.cpp \
   LinearSpringDamper.cpp \
   MatrixConcat.cpp \
+  MatrixSplit.cpp \
   MaxModel.cpp \
   MinModel.cpp \
   Output.cpp \

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/MatrixSplit.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MatrixSplit.cpp	2009-07-26 20:57:53 UTC (rev 1025)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MatrixSplit.cpp	2009-07-26 21:13:09 UTC (rev 1026)
@@ -0,0 +1,184 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2009 Mathias Froehlich 
+ *
+ */
+
+#include "MatrixSplit.h"
+
+#include "TypeInfo.h"
+
+namespace OpenFDM {
+
+BEGIN_OPENFDM_OBJECT_DEF(MatrixSplit, AbstractModel)
+  END_OPENFDM_OBJECT_DEF
+
+MatrixSplit::Context::Context(const MatrixSplit* matrixSplit,
+                              const OutputValueVector& outputValues,
+                              NumericPortValue* inputValue) :
+  mMatrixSplit(matrixSplit),
+  mOutputValues(outputValues),
+  mInputValue(inputValue)
+{
+}
+
+MatrixSplit::Context::~Context()
+{
+}
+  
+const MatrixSplit&
+MatrixSplit::Context::getNode() const
+{
+  return *mMatrixSplit;
+}
+
+const PortValue*
+MatrixSplit::Context::getPortValue(const Port& port) const
+{
+  if (mMatrixSplit->mInputPort == &port)
+    return mInputValue;
+  OpenFDMAssert(mOutputValues.size() == mMatrixSplit->mOutputPorts.size());
+  for (unsigned i = 0; i < mOutputValues.size(); ++i)
+    if (mMatrixSplit->mOutputPorts[i] == &port)
+      return mOutputValues[i];
+  return 0;
+}
+
+ContinousStateValue*
+MatrixSplit::Context::getStateValue(const ContinousStateInfo&)
+{
+  return 0;
+}
+
+ContinousStateValue*
+MatrixSplit::Context::getStateDerivative(const ContinousStateInfo&)
+{
+  return 0;
+}
+  
+void
+MatrixSplit::Context::init(const /*Init*/Task&)
+{
+}
+
+void
+MatrixSplit::Context::output(const Task& task)
+{
+  unsigned concatDimension = mMatrixSplit->getSplitDimension();
+  
+  // May be have two contexts for each if clause??
+  if (concatDimension == 0) {
+    unsigned currentPos = 0;
+    for (unsigned i = 0; i < mOutputValues.size(); ++i) {
+      Matrix& m = mOutputValues[i]->getValue();
+      Size sz = size(m);
+      m = mInputValue->getValue()(Range(currentPos, currentPos + sz(0) - 1),
+                                  Range(0, sz(1) - 1));
+      currentPos += sz(0);
+    }
+  } else {
+    unsigned currentPos = 0;
+    for (unsigned i = 0; i < mOutputValues.size(); ++i) {
+      Matrix& m = mOutputValues[i]->getValue();
+      Size sz = size(m);
+      m = mInputValue->getValue()(Range(0, sz(0) - 1),
+                                  Range(currentPos, currentPos + sz(1) - 1));
+      currentPos += sz(1);
+    }
+  }
+}
+
+void
+MatrixSplit::Context::update(const DiscreteTask&)
+{
+}
+
+void
+MatrixSplit::Context::derivative(const Task&)
+{
+}
+
+MatrixSplit::MatrixSplit(const std::string& name) :
+  AbstractModel(name),
+  mInputPort(new InputPort(this, "input", Size(0, 0), true)),
+  mSplitDimension(0)
+{
+}
+
+MatrixSplit::~MatrixSplit(void)
+{
+}
+  
+MatrixSplit::Context*
+MatrixSplit::newModelContext(PortValueList& portValueList) const
+{
+  if (mOutputPorts.empty()) {
+    Log(Initialization, Info)
+      << "No input ports in models with multiple inputs!" << std::endl;
+    return 0;
+  }
+  
+  NumericPortValue* outputPortValue = portValueList.getPortValue(mInputPort);
+  if (!outputPortValue) {
+    Log(Initialization, Warning)
+      << "Input port value not connected for model \"" << getName()
+      << "\"!" << std::endl;
+    return 0;
+  }
+  OutputValueVector inputValues;
+  
+  // Look into all ports and get the best size match.
+  Size sz = size(outputPortValue->getValue());
+  unsigned concatSum = 0;
+  for (unsigned i = 0; i < mOutputPorts.size(); ++i) {
+    NumericPortValue* npv = portValueList.getPortValue(mOutputPorts[i]);
+    inputValues.push_back(npv);
+    Size sz2 = size(npv->getValue());
+    // If the ports size is undefined, use the size variabe here.
+    unsigned j = getNonSplitDimension();
+    if (sz(j) == 0) {
+      sz(j) = sz2(j);
+    } else {
+      if (sz2(j) != 0 && sz(j) != sz2(j)) {
+        Log(Initialization, Info)
+          << "Port size " << sz2 << "of port " << j
+          << " does not match for model \"" << getName() << "\"!" << std::endl;
+        return 0;
+      }
+    }
+    concatSum += sz2(getSplitDimension());
+  }
+  if (sz(getSplitDimension()) == 0) {
+    sz(getSplitDimension()) = concatSum;
+  } else if (sz(getSplitDimension()) != concatSum) {
+    Log(Initialization, Info)
+      << "Port size sum does not match for model \""
+      << getName() << "\"!" << std::endl;
+    return 0;
+  }
+  
+  // Ok, success in checking output and input ports, set them all.
+  if (!portValueList.setOrCheckPortSize(mInputPort, sz)) {
+    Log(Initialization, Info) << "Port sizes do not match!" << std::endl;
+    return 0;
+  }
+  for (unsigned i = 0; i < mOutputPorts.size(); ++i) {
+    Size sz2 = mOutputPorts[i]->getSize();
+    sz2(getNonSplitDimension()) = sz(getNonSplitDimension());
+    if (!portValueList.setOrCheckPortSize(mOutputPorts[i], sz2)) {
+      Log(Initialization, Info) << "Port sizes do not match!" << std::endl;
+      return 0;
+    }
+  }
+  
+  return new Context(this, inputValues, outputPortValue);
+}
+
+const OutputPort*
+MatrixSplit::addOutputPort(const std::string& name, unsigned dimension)
+{
+  Size size(0, 0);
+  size(getSplitDimension()) = dimension;
+  mOutputPorts.push_back(new OutputPort(this, name, size, true));
+  return mOutputPorts.back();
+}
+
+} // namespace OpenFDM


Property changes on: branches/OpenFDM-StateSeparation/src/OpenFDM/MatrixSplit.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/MatrixSplit.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MatrixSplit.h	2009-07-26 20:57:53 UTC (rev 1025)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MatrixSplit.h	2009-07-26 21:13:09 UTC (rev 1026)
@@ -0,0 +1,72 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2009 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_MatrixSplit_H
+#define OpenFDM_MatrixSplit_H
+
+#include <string>
+
+#include "Types.h"
+#include "AbstractModel.h"
+#include "ModelContext.h"
+
+namespace OpenFDM {
+
+class MatrixSplit : public AbstractModel {
+  OPENFDM_OBJECT(MatrixSplit, AbstractModel);
+private:
+  class Context;
+public:
+  MatrixSplit(const std::string& name);
+  virtual ~MatrixSplit(void);
+  
+  virtual Context* newModelContext(PortValueList& portValueList) const;
+
+  unsigned getSplitDimension() const
+  { return mSplitDimension; }
+  void setSplitDimension(unsigned concatDimension)
+  { mSplitDimension = concatDimension; }
+
+  const OutputPort* addOutputPort(const std::string& name, unsigned dimension = 1);
+  
+private:
+  typedef std::vector<SharedPtr<NumericPortValue> > OutputValueVector;
+
+  class Context : public AbstractModelContext {
+  public:
+    Context(const MatrixSplit* matrixSplit,
+            const OutputValueVector& outputValues,
+            NumericPortValue* inputValue);
+    virtual ~Context();
+  
+    virtual const MatrixSplit& getNode() const;
+    virtual const PortValue* getPortValue(const Port& port) const;
+  
+    virtual ContinousStateValue* getStateValue(const ContinousStateInfo&);
+    virtual ContinousStateValue* getStateDerivative(const ContinousStateInfo&);
+  
+    virtual void init(const /*Init*/Task&);
+    virtual void output(const Task& task);
+    virtual void update(const DiscreteTask&);
+    virtual void derivative(const Task&);
+  private:
+    SharedPtr<const MatrixSplit> mMatrixSplit;
+    OutputValueVector mOutputValues;
+    SharedPtr<const NumericPortValue> mInputValue;
+  };
+
+  unsigned getNonSplitDimension() const
+  { return (mSplitDimension == 0) ? 1 : 0; }
+
+  SharedPtr<InputPort> mInputPort;
+
+  typedef std::vector<SharedPtr<OutputPort> > OutputPortVector;
+  OutputPortVector mOutputPorts;
+
+  unsigned mSplitDimension;
+};
+
+} // namespace OpenFDM
+
+#endif


Property changes on: branches/OpenFDM-StateSeparation/src/OpenFDM/MatrixSplit.h
___________________________________________________________________
Name: svn:eol-style
   + native



From frohlich at mail.berlios.de  Sun Jul 26 23:21:43 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 26 Jul 2009 23:21:43 +0200
Subject: [OpenFDM-svn] r1027 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200907262121.n6QLLh3I008744@sheep.berlios.de>

Author: frohlich
Date: 2009-07-26 23:21:43 +0200 (Sun, 26 Jul 2009)
New Revision: 1027

Added:
   branches/OpenFDM-StateSeparation/src/OpenFDM/MachNumber.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/MachNumber.h
Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
Log:
Add a mach number model.

AM   MachNumber.cpp
AM   MachNumber.h
M    Makefile.am


Added: branches/OpenFDM-StateSeparation/src/OpenFDM/MachNumber.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MachNumber.cpp	2009-07-26 21:13:09 UTC (rev 1026)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MachNumber.cpp	2009-07-26 21:21:43 UTC (rev 1027)
@@ -0,0 +1,38 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2009 Mathias Froehlich 
+ *
+ */
+
+#include "MachNumber.h"
+
+#include "TypeInfo.h"
+
+namespace OpenFDM {
+
+BEGIN_OPENFDM_OBJECT_DEF(MachNumber, Model)
+  END_OPENFDM_OBJECT_DEF
+
+MachNumber::MachNumber(const std::string& name) :
+  Model(name),
+  mVelocityPort(this, "velocity", Size(3, 1), true),
+  mSoundSpeedPort(this, "soundSpeed", true),
+  mMachNumberPort(this, "machNumber")
+{
+}
+
+MachNumber::~MachNumber(void)
+{
+}
+
+void
+MachNumber::output(const Task&, const DiscreteStateValueVector&,
+                   const ContinousStateValueVector&,
+                   PortValueList& portValues) const
+{
+  //     Vector3 v = Vector6(portValues[mVelocityPort]).getLinear();
+  Vector3 v = portValues[mVelocityPort];
+  real_type soundSpeed = portValues[mSoundSpeedPort];
+  real_type eps = Limits<real_type>::epsilon();
+  portValues[mMachNumberPort] = norm(v)/(soundSpeed + eps);
+}
+
+} // namespace OpenFDM


Property changes on: branches/OpenFDM-StateSeparation/src/OpenFDM/MachNumber.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/MachNumber.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MachNumber.h	2009-07-26 21:13:09 UTC (rev 1026)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MachNumber.h	2009-07-26 21:21:43 UTC (rev 1027)
@@ -0,0 +1,36 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2009 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_MachNumber_H
+#define OpenFDM_MachNumber_H
+
+#include <string>
+
+#include "Types.h"
+#include "Model.h"
+
+namespace OpenFDM {
+
+class MachNumber : public Model {
+  OPENFDM_OBJECT(MachNumber, Model);
+public:
+  MachNumber(const std::string& name);
+  virtual ~MachNumber(void);
+
+  virtual void output(const Task&, const DiscreteStateValueVector&,
+                      const ContinousStateValueVector&,
+                      PortValueList& portValues) const;
+
+private:
+  /// The input port which must provide the fluid velocity vector
+  MatrixInputPort mVelocityPort;
+  /// The input port which must provide the sensed speed of sound
+  RealInputPort mSoundSpeedPort;
+  /// The resulting mach number
+  RealOutputPort mMachNumberPort;
+};
+
+} // namespace OpenFDM
+
+#endif


Property changes on: branches/OpenFDM-StateSeparation/src/OpenFDM/MachNumber.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2009-07-26 21:13:09 UTC (rev 1026)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2009-07-26 21:21:43 UTC (rev 1027)
@@ -208,6 +208,7 @@
   Input.h \
   Integrator.h \
   LinearSpringDamper.h \
+  MachNumber.h \
   MatrixConcat.h \
   MatrixSplit.h \
   MaxModel.h \
@@ -239,6 +240,7 @@
   Input.cpp \
   Integrator.cpp \
   LinearSpringDamper.cpp \
+  MachNumber.cpp \
   MatrixConcat.cpp \
   MatrixSplit.cpp \
   MaxModel.cpp \



From frohlich at mail.berlios.de  Sun Jul 26 23:26:17 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 26 Jul 2009 23:26:17 +0200
Subject: [OpenFDM-svn] r1028 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200907262126.n6QLQH1h009160@sheep.berlios.de>

Author: frohlich
Date: 2009-07-26 23:26:17 +0200 (Sun, 26 Jul 2009)
New Revision: 1028

Added:
   branches/OpenFDM-StateSeparation/src/OpenFDM/DynamicPressure.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/DynamicPressure.h
Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
Log:
Add a DynamicPressure model.

AM   DynamicPressure.h
AM   DynamicPressure.cpp
M    Makefile.am


Added: branches/OpenFDM-StateSeparation/src/OpenFDM/DynamicPressure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/DynamicPressure.cpp	2009-07-26 21:21:43 UTC (rev 1027)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/DynamicPressure.cpp	2009-07-26 21:26:17 UTC (rev 1028)
@@ -0,0 +1,43 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2009 Mathias Froehlich 
+ *
+ */
+
+#include "DynamicPressure.h"
+
+#include "TypeInfo.h"
+
+namespace OpenFDM {
+
+BEGIN_OPENFDM_OBJECT_DEF(DynamicPressure, Model)
+  END_OPENFDM_OBJECT_DEF
+
+DynamicPressure::DynamicPressure(const std::string& name) :
+  Model(name),
+  mVelocityPort(this, "velocity", Size(3, 1), true),
+  mDensityPort(this, "density", true),
+  mDynamicPressurePort(this, "dynamicPressure")
+{
+}
+
+DynamicPressure::~DynamicPressure(void)
+{
+}
+
+void
+DynamicPressure::output(const Task&, const DiscreteStateValueVector&,
+                        const ContinousStateValueVector&,
+                        PortValueList& portValues) const
+{
+  //     Vector3 v = Vector6(portValues[mVelocityPort]).getLinear();
+  Vector3 v = portValues[mVelocityPort];
+  real_type density = portValues[mDensityPort];
+  if (mDirection == Vector3::zeros())
+    portValues[mDynamicPressurePort] = 0.5*density*dot(v, v);
+  else {
+    real_type dv = dot(mDirection, v);
+    real_type dd = dot(mDirection, mDirection);
+    portValues[mDynamicPressurePort] = 0.5*density*dv*dv/dd;
+  }
+}
+
+} // namespace OpenFDM


Property changes on: branches/OpenFDM-StateSeparation/src/OpenFDM/DynamicPressure.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/DynamicPressure.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/DynamicPressure.h	2009-07-26 21:21:43 UTC (rev 1027)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/DynamicPressure.h	2009-07-26 21:26:17 UTC (rev 1028)
@@ -0,0 +1,45 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2009 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_DynamicPressure_H
+#define OpenFDM_DynamicPressure_H
+
+#include <string>
+
+#include "Types.h"
+#include "Model.h"
+
+namespace OpenFDM {
+
+class DynamicPressure : public Model {
+  OPENFDM_OBJECT(DynamicPressure, Model);
+public:
+  DynamicPressure(const std::string& name);
+  virtual ~DynamicPressure(void);
+
+  virtual void output(const Task&, const DiscreteStateValueVector&,
+                      const ContinousStateValueVector&,
+                      PortValueList& portValues) const;
+
+  const Vector3& getDirection() const
+  { return mDirection; }
+  void setDirection(const Vector3& direction)
+  { mDirection = direction; }
+
+private:
+  /// The input port which must provide the fluid velocity vector
+  MatrixInputPort mVelocityPort;
+  /// The input port which must provide the sensed density
+  RealInputPort mDensityPort;
+  /// The resulting dynamic pressure
+  RealOutputPort mDynamicPressurePort;
+
+  /// The direction vector for the dynamic pressure.
+  /// If set to zero, the dynamic pressure into the wind direction is measured
+  Vector3 mDirection;
+};
+
+} // namespace OpenFDM
+
+#endif


Property changes on: branches/OpenFDM-StateSeparation/src/OpenFDM/DynamicPressure.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2009-07-26 21:21:43 UTC (rev 1027)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2009-07-26 21:26:17 UTC (rev 1028)
@@ -204,6 +204,7 @@
   Delay.h \
   DiscBrake.h \
   DiscreteIntegrator.h \
+  DynamicPressure.h \
   Gain.h \
   Input.h \
   Integrator.h \
@@ -236,6 +237,7 @@
   Delay.cpp \
   DiscBrake.cpp \
   DiscreteIntegrator.cpp \
+  DynamicPressure.cpp \
   Gain.cpp \
   Input.cpp \
   Integrator.cpp \



From frohlich at mail.berlios.de  Sun Jul 26 23:41:41 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 26 Jul 2009 23:41:41 +0200
Subject: [OpenFDM-svn] r1029 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200907262141.n6QLffxZ011402@sheep.berlios.de>

Author: frohlich
Date: 2009-07-26 23:41:41 +0200 (Sun, 26 Jul 2009)
New Revision: 1029

Added:
   branches/OpenFDM-StateSeparation/src/OpenFDM/WindAxis.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/WindAxis.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/WindAxisForce.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/WindAxisForce.h
Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
Log:
Add a WindAxis model and a WindAxisForce model.

AM   WindAxis.h
AM   WindAxis.cpp
AM   WindAxisForce.cpp
AM   WindAxisForce.h
M    Makefile.am


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2009-07-26 21:26:17 UTC (rev 1028)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2009-07-26 21:41:41 UTC (rev 1029)
@@ -224,7 +224,9 @@
   TimeDerivative.h \
   TransferFunction.h \
   UnaryFunction.h \
-  UnitConversion.h
+  UnitConversion.h \
+  WindAxis.h \
+  WindAxisForce.h
 
 OpenFDMModelsSOURCES = \
   Actuator.cpp \
@@ -257,7 +259,9 @@
   TimeDerivative.cpp \
   TransferFunction.cpp \
   UnaryFunction.cpp \
-  UnitConversion.cpp
+  UnitConversion.cpp \
+  WindAxis.cpp \
+  WindAxisForce.cpp
 
 OpenFDMMechanicHEADERS = \
   AeroForce.h \

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/WindAxis.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/WindAxis.cpp	2009-07-26 21:26:17 UTC (rev 1028)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/WindAxis.cpp	2009-07-26 21:41:41 UTC (rev 1029)
@@ -0,0 +1,58 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2009 Mathias Froehlich 
+ *
+ */
+
+#include "WindAxis.h"
+
+#include "TypeInfo.h"
+
+namespace OpenFDM {
+
+BEGIN_OPENFDM_OBJECT_DEF(WindAxis, Model)
+  END_OPENFDM_OBJECT_DEF
+
+WindAxis::WindAxis(const std::string& name) :
+  Model(name),
+  mVelocityPort(this, "bodyVelocity", Size(3, 1), true),
+  mAlphaPort(this, "alpha"),
+  mAlphaDotPort(this, "alphaDot"),
+  mBetaPort(this, "beta"),
+  mBetaDotPort(this, "betaDot"),
+  mAirSpeedPort(this, "airSpeed")
+{
+}
+
+WindAxis::~WindAxis(void)
+{
+}
+
+void
+WindAxis::output(const Task&, const DiscreteStateValueVector&,
+                 const ContinousStateValueVector&,
+                 PortValueList& portValues) const
+{
+  Vector3 v = portValues[mVelocityPort];
+  
+  real_type alpha = 0;
+  if (Limits<real_type>::min() < fabs(v(0)))
+    alpha = atan2(v(2), v(0));
+  portValues[mAlphaPort] = alpha;
+  
+  real_type beta = 0;
+  real_type uw = sqrt(v(0)*v(0) + v(2)*v(2));
+  if (Limits<real_type>::min() < fabs(uw))
+    beta = atan2(v(1), uw);
+  portValues[mBetaPort] = beta;
+  
+  real_type vt = norm(v);
+  portValues[mAirSpeedPort] = vt;
+  
+  // FIXME: we need something that avoids the singularities when just doing
+  // finite differences with alpha and beta.
+  // may be we can also get then a representation of alpha and beta that is
+  // steady at zero velocity
+  portValues[mAlphaDotPort] = 0;
+  portValues[mBetaDotPort] = 0;
+}
+
+} // namespace OpenFDM


Property changes on: branches/OpenFDM-StateSeparation/src/OpenFDM/WindAxis.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/WindAxis.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/WindAxis.h	2009-07-26 21:26:17 UTC (rev 1028)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/WindAxis.h	2009-07-26 21:41:41 UTC (rev 1029)
@@ -0,0 +1,43 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2009 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_WindAxis_H
+#define OpenFDM_WindAxis_H
+
+#include <string>
+
+#include "Types.h"
+#include "Model.h"
+
+namespace OpenFDM {
+
+class WindAxis : public Model {
+  OPENFDM_OBJECT(WindAxis, Model);
+public:
+  WindAxis(const std::string& name);
+  virtual ~WindAxis(void);
+
+  virtual void output(const Task&, const DiscreteStateValueVector&,
+                      const ContinousStateValueVector&,
+                      PortValueList& portValues) const;
+
+private:
+  /// The input port which must provide the fluid velocity 6 vector
+  MatrixInputPort mVelocityPort;
+
+  /// The resulting angle of attack output
+  RealOutputPort mAlphaPort;
+  /// The resulting angle of attack derivative output
+  RealOutputPort mAlphaDotPort;
+  /// The resulting side slip angle output
+  RealOutputPort mBetaPort;
+  /// The resulting side slip angle derivative output
+  RealOutputPort mBetaDotPort;
+  /// The resulting true airspeed output
+  RealOutputPort mAirSpeedPort;
+};
+
+} // namespace OpenFDM
+
+#endif


Property changes on: branches/OpenFDM-StateSeparation/src/OpenFDM/WindAxis.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/WindAxisForce.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/WindAxisForce.cpp	2009-07-26 21:26:17 UTC (rev 1028)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/WindAxisForce.cpp	2009-07-26 21:41:41 UTC (rev 1029)
@@ -0,0 +1,65 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2009 Mathias Froehlich 
+ *
+ */
+
+#include "WindAxisForce.h"
+
+#include "TypeInfo.h"
+
+namespace OpenFDM {
+
+BEGIN_OPENFDM_OBJECT_DEF(WindAxisForce, Model)
+  END_OPENFDM_OBJECT_DEF
+
+WindAxisForce::WindAxisForce(const std::string& name) :
+  Model(name),
+  mAlphaPort(this, "alpha", true),
+  mBetaPort(this, "beta", true),
+  mDragPort(this, "drag", true),
+  mSidePort(this, "side", true),
+  mLiftPort(this, "lift", true),
+  mForcePort(this, "bodyForce", Size(3, 1))
+{
+}
+
+WindAxisForce::~WindAxisForce(void)
+{
+}
+
+void
+WindAxisForce::output(const Task&, const DiscreteStateValueVector&,
+                      const ContinousStateValueVector&,
+                      PortValueList& portValues) const
+{
+  // Get the matrix transforming from stability to body axis
+  real_type alpha = portValues[mAlphaPort];
+  real_type beta = portValues[mBetaPort];
+  real_type ca = cos(alpha);
+  real_type sa = sin(alpha);
+  real_type cb = cos(beta);
+  real_type sb = sin(beta);
+  
+  // The transform from stability axis to body axis where the
+  // stability axis x axis points into the wind, the y axis points
+  // to the right and the z axis points downwards
+  Matrix33 Tw2b(-ca*cb, -ca*sb,  sa,
+                -sb,     cb,   0,
+                -sa*cb, -sa*sb, -ca);
+  
+  // Get the forces
+  real_type drag = 0;
+  if (!mDragPort.empty())
+    drag = portValues[mDragPort];
+  real_type side = 0;
+  if (!mSidePort.empty())
+    side = portValues[mSidePort];
+  real_type lift = 0;
+  if (!mLiftPort.empty())
+    lift = portValues[mLiftPort];
+  
+  // Compute the force vector, note that drag is a force pointing
+  // afterwards and the lift upwards
+  portValues[mForcePort] = Tw2b*Vector3(-drag, side, -lift);
+}
+
+} // namespace OpenFDM


Property changes on: branches/OpenFDM-StateSeparation/src/OpenFDM/WindAxisForce.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/WindAxisForce.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/WindAxisForce.h	2009-07-26 21:26:17 UTC (rev 1028)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/WindAxisForce.h	2009-07-26 21:41:41 UTC (rev 1029)
@@ -0,0 +1,45 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2009 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_WindAxisForce_H
+#define OpenFDM_WindAxisForce_H
+
+#include <string>
+
+#include "Types.h"
+#include "Model.h"
+
+namespace OpenFDM {
+
+class WindAxisForce : public Model {
+  OPENFDM_OBJECT(WindAxisForce, Model);
+public:
+  WindAxisForce(const std::string& name);
+  virtual ~WindAxisForce(void);
+
+  virtual void output(const Task&, const DiscreteStateValueVector&,
+                      const ContinousStateValueVector&,
+                      PortValueList& portValues) const;
+
+  // FIXME insert the enable/disable stuff for the 3 inputs
+
+private:
+  /// The angle of attack input
+  RealInputPort mAlphaPort;
+  /// The side slip angle input
+  RealInputPort mBetaPort;
+  /// The drag force input
+  RealInputPort mDragPort;
+  /// The side force input
+  RealInputPort mSidePort;
+  /// The lift force input
+  RealInputPort mLiftPort;
+
+  /// The resulting force in body axis
+  MatrixOutputPort mForcePort;
+};
+
+} // namespace OpenFDM
+
+#endif


Property changes on: branches/OpenFDM-StateSeparation/src/OpenFDM/WindAxisForce.h
___________________________________________________________________
Name: svn:eol-style
   + native



From frohlich at mail.berlios.de  Sun Jul 26 23:42:48 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 26 Jul 2009 23:42:48 +0200
Subject: [OpenFDM-svn] r1030 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200907262142.n6QLgmKC011687@sheep.berlios.de>

Author: frohlich
Date: 2009-07-26 23:42:48 +0200 (Sun, 26 Jul 2009)
New Revision: 1030

Modified:
   branches/OpenFDM-StateSeparation/src/test/ballistic.cpp
Log:
Make use of the aerodanymic model classes.

M    ballistic.cpp


Modified: branches/OpenFDM-StateSeparation/src/test/ballistic.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/ballistic.cpp	2009-07-26 21:41:41 UTC (rev 1029)
+++ branches/OpenFDM-StateSeparation/src/test/ballistic.cpp	2009-07-26 21:42:48 UTC (rev 1030)
@@ -1,4 +1,5 @@
 #include <OpenFDM/ConstModel.h>
+#include <OpenFDM/Gain.h>
 #include <OpenFDM/Group.h>
 #include <OpenFDM/InternalInteract.h>
 #include <OpenFDM/LinearSpringDamper.h>
@@ -10,6 +11,11 @@
 #include <OpenFDM/System.h>
 #include <OpenFDM/SystemOutput.h>
 
+#include <OpenFDM/DynamicPressure.h>
+#include <OpenFDM/MachNumber.h>
+#include <OpenFDM/WindAxis.h>
+#include <OpenFDM/WindAxisForce.h>
+
 using namespace OpenFDM;
 
 Node* buildBallistic()
@@ -40,6 +46,61 @@
   group->connect(rigidBody->getPort("externalInteractLink"),
                  externalInteract->getPort("link"));
 
+  DynamicPressure* dynamicPressure = new DynamicPressure("DynamicPressure");
+  group->addChild(dynamicPressure);
+
+  group->connect(externalInteract->getPort("bodyWindVelocity"),
+                 dynamicPressure->getPort("velocity"));
+  group->connect(externalInteract->getPort("density"),
+                 dynamicPressure->getPort("density"));
+
+
+  MachNumber* machNumber = new MachNumber("MachNumber");
+  group->addChild(machNumber);
+
+  group->connect(externalInteract->getPort("bodyWindVelocity"),
+                 machNumber->getPort("velocity"));
+  group->connect(externalInteract->getPort("soundSpeed"),
+                 machNumber->getPort("soundSpeed"));
+
+
+  WindAxis* windAxis = new WindAxis("WindAxis");
+  group->addChild(windAxis);
+
+  group->connect(externalInteract->getPort("bodyWindVelocity"),
+                 windAxis->getPort("bodyVelocity"));
+
+
+  WindAxisForce* windAxisForce = new WindAxisForce("WindAxisForce");
+  group->addChild(windAxisForce);
+
+  group->connect(windAxis->getPort("alpha"),
+                 windAxisForce->getPort("alpha"));
+  group->connect(windAxis->getPort("beta"),
+                 windAxisForce->getPort("beta"));
+
+  externalInteract->setEnableBodyForce(true);
+  group->connect(windAxisForce->getPort("bodyForce"),
+                 externalInteract->getPort("bodyForce"));
+
+  ConstModel* zeroConst = new ConstModel("ConstModel 0");
+  group->addChild(zeroConst);
+
+  group->connect(zeroConst->getPort("output"),
+                 windAxisForce->getPort("side"));
+  group->connect(zeroConst->getPort("output"),
+                 windAxisForce->getPort("lift"));
+
+  Gain* dragCoeficient = new Gain("Drag Coeficient");
+  dragCoeficient->setGain(0.01);
+  group->addChild(dragCoeficient);
+
+  group->connect(dragCoeficient->getPort("input"),
+                 dynamicPressure->getPort("dynamicPressure"));
+
+  group->connect(dragCoeficient->getPort("output"),
+                 windAxisForce->getPort("drag"));
+
   return group.release();
 }
 



From frohlich at mail.berlios.de  Mon Jul 27 07:10:46 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Mon, 27 Jul 2009 07:10:46 +0200
Subject: [OpenFDM-svn] r1031 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200907270510.n6R5Akp9009004@sheep.berlios.de>

Author: frohlich
Date: 2009-07-27 07:10:43 +0200 (Mon, 27 Jul 2009)
New Revision: 1031

Removed:
   branches/OpenFDM-StateSeparation/src/OpenFDM/AeroForce.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/AeroForce.h
Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
Log:
Remove old AeroForce implementation.

M    Makefile.am
D    AeroForce.h
D    AeroForce.cpp


Deleted: branches/OpenFDM-StateSeparation/src/OpenFDM/AeroForce.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/AeroForce.cpp	2009-07-26 21:42:48 UTC (rev 1030)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/AeroForce.cpp	2009-07-27 05:10:43 UTC (rev 1031)
@@ -1,512 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2009 Mathias Froehlich 
- *
- */
-
-#include "AeroForce.h"
-
-#include "Object.h"
-#include "Vector.h"
-#include "Force.h"
-#include "Atmosphere.h"
-
-namespace OpenFDM {
-
-BEGIN_OPENFDM_OBJECT_DEF(AeroForce, ExternalForce)
-  DEF_OPENFDM_PROPERTY(Real, WingSpan, Serialized)
-  DEF_OPENFDM_PROPERTY(Real, WingArea, Serialized)
-  DEF_OPENFDM_PROPERTY(Real, Coord, Serialized)
-  END_OPENFDM_OBJECT_DEF
-
-AeroForce::AeroForce(const std::string& name)
-  : ExternalForce(name)
-{
-  mWingSpan = 0.0;
-  mWingArea = 0.0;
-  mCoord = 0.0;
-
-  dirtyAll();
-
-  addOutputPort("wingSpan", this, &AeroForce::getWingSpan);
-  addOutputPort("wingArea", this, &AeroForce::getWingArea);
-  addOutputPort("coord", this, &AeroForce::getCoord);
-
-  addOutputPort("trueSpeed", this, &AeroForce::getTrueSpeed);
-  addOutputPort("dynamicPressure", this, &AeroForce::getDynamicPressure);
-  addOutputPort("alpha", this, &AeroForce::getAlpha);
-  addOutputPort("alphaDot", this, &AeroForce::getAlphaDot);
-  addOutputPort("beta", this, &AeroForce::getBeta);
-  addOutputPort("betaDot", this, &AeroForce::getBetaDot);
-//   addOutputPort("mach", this, &AeroForce::getMach);
-  addOutputPort("machNumber", this, &AeroForce::getMachNumber);
-  addOutputPort("trueSpeedUW", this, &AeroForce::getTrueSpeedUW);
-
-  addOutputPort("wingSpanOver2Speed", this, &AeroForce::getWingSpanOver2Speed);
-  addOutputPort("coordOver2Speed", this, &AeroForce::getCoordOver2Speed);
-  addOutputPort("hOverWingSpan", this, &AeroForce::getHOverWingSpan);
-
-//   addOutputPort("equivalentAirSpeed", this, &AeroForce::getEquivalentAirSpeed);
-//   addOutputPort("calibratedAirSpeed", this, &AeroForce::getCalibratedAirSpeed);
-
-  addOutputPort("u", this, &AeroForce::getBodyU);
-  addOutputPort("v", this, &AeroForce::getBodyV);
-  addOutputPort("w", this, &AeroForce::getBodyW);
-  addOutputPort("p", this, &AeroForce::getBodyP);
-  addOutputPort("q", this, &AeroForce::getBodyQ);
-  addOutputPort("r", this, &AeroForce::getBodyR);
-
-  setNumInputPorts(6);
-  setInputPortName(0, "roll");
-  setInputPortName(1, "pitch");
-  setInputPortName(2, "yaw");
-  setInputPortName(3, "drag");
-  setInputPortName(4, "side");
-  setInputPortName(5, "lift");
-}
-
-AeroForce::~AeroForce(void)
-{
-}
-
-bool
-AeroForce::init(void)
-{
-  if (getInputPort("roll"))
-    mBodyAxisTorque[0] = getInputPort("roll")->toRealPortHandle();
-  else
-    mBodyAxisTorque[0] = 0;
-  if (getInputPort("pitch"))
-    mBodyAxisTorque[1] = getInputPort("pitch")->toRealPortHandle();
-  else
-    mBodyAxisTorque[1] = 0;
-  if (getInputPort("yaw"))
-    mBodyAxisTorque[2] = getInputPort("yaw")->toRealPortHandle();
-  else
-    mBodyAxisTorque[2] = 0;
-
-  if (getInputPort("drag"))
-    mStabilityAxisForce[0] = getInputPort("drag")->toRealPortHandle();
-  else
-    mStabilityAxisForce[0] = 0;
-  if (getInputPort("side"))
-    mStabilityAxisForce[1] = getInputPort("side")->toRealPortHandle();
-  else
-    mStabilityAxisForce[1] = 0;
-  if (getInputPort("lift"))
-    mStabilityAxisForce[2] = getInputPort("lift")->toRealPortHandle();
-  else
-    mStabilityAxisForce[2] = 0;
-
-  return ExternalForce::init();
-}
-
-void
-AeroForce::output(const TaskInfo& taskInfo)
-{
-  if (nonZeroIntersection(taskInfo.getSampleTimeSet(),
-                          SampleTime::PerTimestep)) {
-    Log(Model, Debug) << "AeroForce::output(): \"" << getName()
-                      << "\" computing ground plane below" << endl;
-    real_type t = taskInfo.getTime();
-    mGroundVal = getGround()->getGroundPlane(t, getRefPosition());
-  }
-  dirtyAll();
-
-  // FIXME: they can be computed cheaper ...
-  real_type ca = cos(getAlpha());
-  real_type sa = sin(getAlpha());
-  real_type cb = cos(getBeta());
-  real_type sb = sin(getBeta());
-  Matrix33 Ts2b(-ca*cb, -ca*sb,  sa,
-                   -sb,     cb,   0,
-                -sa*cb, -sa*sb, -ca);
-
-  // This is simple here. Just collect all summands ...
-  Vector3 stabilityForce = Vector3::zeros();
-  /// Lift points upward
-  /// Drag points backward
-  for (int i = 0; i < 3; ++i)
-    if (mStabilityAxisForce[i].isConnected())
-      stabilityForce(i) = mStabilityAxisForce[i].getRealValue();
-
-  Vector3 bodyTorque = Vector3::zeros();
-  for (int i = 0; i < 3; ++i)
-    if (mBodyAxisTorque[i].isConnected())
-      bodyTorque(i) = mBodyAxisTorque[i].getRealValue();
-
-  Vector6 force(bodyTorque, Ts2b*stabilityForce);
-  Log(ArtBody, Debug3) << "AeroForce::output() "
-                       << trans(force) << endl;
-  setForce(force);
-}
-
-void
-AeroForce::setWingSpan(const real_type& winSpan)
-{
-  mWingSpan = winSpan;
-}
-
-const real_type&
-AeroForce::getWingSpan(void) const
-{
-  return mWingSpan;
-}
-
-void
-AeroForce::setWingArea(const real_type& winArea)
-{
-  mWingArea = winArea;
-}
-
-const real_type&
-AeroForce::getWingArea(void) const
-{
-  return mWingArea;
-}
-
-void
-AeroForce::setCoord(const real_type& coord)
-{
-  mCoord = coord;
-}
-
-const real_type&
-AeroForce::getCoord(void) const
-{
-  return mCoord;
-}
-
-const Vector6&
-AeroForce::getAirSpeed(void) const
-{
-  if (mDirtyAirSpeed) {
-    // Get the position in the earth centered coordinate frame.
-    Vector3 windVel = getWind()->getWindVel(getRefPosition());
-    windVel = mMountFrame->rotFromRef(windVel);
-    mAirSpeed = Vector6(Vector3::zeros(), windVel) + mMountFrame->getRefVel();
-    mDirtyAirSpeed = false;
-  }
-  Log(ArtBody, Debug3) << "AeroForce::getAirSpeed()"
-                       << trans(mAirSpeed) << endl;
-  return mAirSpeed;
-}
-
-const Vector3&
-AeroForce::getMach(void) const
-{
-  if (mDirtyMach) {
-    mMach = (1/getSoundSpeed())*getAirSpeed().getLinear();
-    mDirtyMach = false;
-  }
-  Log(ArtBody, Debug3) << "AeroForce::getMach()"
-                       << trans(mMach) << endl;
-  return mMach;
-}
-
-const real_type&
-AeroForce::getTrueSpeed(void) const
-{
-  if (mDirtyTrueSpeed) {
-    mTrueSpeed = norm(getAirSpeed().getLinear());
-    mDirtyTrueSpeed = false;
-  }
-  Log(ArtBody, Debug3) << "AeroForce::getTrueSpeed()"
-                       << mTrueSpeed << endl;
-  return mTrueSpeed;
-}
-
-// const real_type&
-// AeroForce::getEquivalentAirSpeed(void) const
-// {
-//   if (mDirtyEquivalentAirSpeed)
-//     computeCalEquAirspeed();
-//   Log(ArtBody, Debug3) << "AeroForce::getEquivalentAirSpeed()"
-//                        << mEquivalentAirSpeed << endl;
-//   return mEquivalentAirSpeed;
-// }
-
-// const real_type&
-// AeroForce::getCalibratedAirSpeed(void) const
-// {
-//   if (mDirtyCalibratedAirSpeed)
-//     computeCalEquAirspeed();
-//   Log(ArtBody, Debug3) << "AeroForce::getCalibratedAirSpeed()"
-//                        << mCalibratedAirSpeed << endl;
-//   return mCalibratedAirSpeed;
-// }
-
-const real_type&
-AeroForce::getDynamicPressure(void) const
-{
-  if (mDirtyDynamicPressure) {
-    real_type V = getTrueSpeed();
-    real_type rho = getDensity();
-    mDynamicPressure = 0.5*rho*V*V;
-  }
-  Log(ArtBody, Debug3) << "AeroForce::getDynamicPressure()"
-                       << mDynamicPressure << endl;
-  return mDynamicPressure;
-}
-
-const real_type&
-AeroForce::getAlpha(void) const
-{
-  if (mDirtyAlpha) {
-    Vector3 V = getAirSpeed().getLinear();
-    if (fabs(V(0)) <= Limits<real_type>::min())
-      mAlpha = 0;
-    else
-      mAlpha = atan2(V(2), V(0));
-    mDirtyAlpha = false;
-  }
-  Log(ArtBody, Debug3) << "AeroForce::getAlpha()" << mAlpha << endl;
-  return mAlpha;
-}
-
-const real_type&
-AeroForce::getAlphaDot(void) const
-{
-  if (mDirtyAlphaDot) {
-  // The timederivative of alpha.
-  // Here it is getting difficult. The acceleration is not well defined
-  // at this time. But we just take the past one ...
-//   real_type alphadot = 0;
-//   if (airSpeedUW2 != 0)
-//     alphadot = (airSpeed(0)*stabAccel(2)-airSpeed(2)*stabAccel(0))/airSpeedUW2;
-
-    mAlphaDot = 0;
-    mDirtyAlphaDot = false;
-  }
-  Log(ArtBody, Debug3) << "AeroForce::getAlphaDot() " << mAlphaDot << endl;
-  return mAlphaDot;
-}
-
-const real_type&
-AeroForce::getBeta(void) const
-{
-  if (mDirtyBeta) {
-    real_type Vuw = getTrueSpeedUW();
-    Vector3 V = getAirSpeed().getLinear();
-    if (fabs(Vuw) <= Limits<real_type>::min())
-      mBeta = 0;
-    else
-      mBeta = atan2(V(1), Vuw);
-    
-    mDirtyBeta = false;
-  }
-  Log(ArtBody, Debug3) << "AeroForce::getBeta() " << mBeta << endl;
-  return mBeta;
-}
-
-const real_type&
-AeroForce::getBetaDot(void) const
-{
-  if (mDirtyBetaDot) {
-    mBetaDot = 0;
-//   // The timederivative of beta.
-//   // The same implicit dependency like with alphadot.
-//   real_type betadot = 0;
-//   if (airSpeedUW != 0 && trueSpeed != 0) {
-//     real_type trueSpeedDot = dot(airSpeed, stabAccel)/trueSpeed;
-//     betadot = (trueSpeed*stabAccel(2) - airSpeed(2)*trueSpeedDot);
-//     betadot /= trueSpeed*airSpeedUW;
-//   }
-
-    mDirtyBetaDot = false;
-  }
-  Log(ArtBody, Debug3) << "AeroForce::getBetaDot() " << mBetaDot << endl;
-  return mBetaDot;
-}
-
-const real_type&
-AeroForce::getBodyU(void) const
-{
-  const Vector6& speed = getAirSpeed();
-  return speed(3);
-}
-
-const real_type&
-AeroForce::getBodyV(void) const
-{
-  const Vector6& speed = getAirSpeed();
-  return speed(4);
-}
-
-const real_type&
-AeroForce::getBodyW(void) const
-{
-  const Vector6& speed = getAirSpeed();
-  return speed(5);
-}
-
-const real_type&
-AeroForce::getBodyP(void) const
-{
-  const Vector6& speed = getAirSpeed();
-  return speed(0);
-}
-
-const real_type&
-AeroForce::getBodyQ(void) const
-{
-  const Vector6& speed = getAirSpeed();
-  return speed(1);
-}
-
-const real_type&
-AeroForce::getBodyR(void) const
-{
-  const Vector6& speed = getAirSpeed();
-  return speed(2);
-}
-
-const real_type&
-AeroForce::getMachNumber(void) const
-{
-  if (mDirtyMachNumber) {
-    mMachNumber = norm(getMach());
-    mDirtyMachNumber = false;
-  }
-  Log(ArtBody, Debug3) << "AeroForce::getMachNumber()"
-                       << mMachNumber << endl;
-  return mMachNumber;
-}
-
-const real_type&
-AeroForce::getTrueSpeedUW(void) const
-{
-  if (mDirtyTrueSpeedUW) {
-    const Vector6& speed = getAirSpeed();
-    mTrueSpeedUW = sqrt(speed(3)*speed(3)+speed(5)*speed(5));
-    mDirtyTrueSpeedUW = false;
-  }
-  Log(ArtBody, Debug3) << "AeroForce::getTrueSpeedUW()"
-                       << mTrueSpeedUW << endl;
-  return mTrueSpeedUW;
-}
-
-const real_type&
-AeroForce::getWingSpanOver2Speed(void) const
-{
-  if (mDirtyWingSpanOver2Speed) {
-    real_type Vt2 = 2*getTrueSpeed();
-    if (fabs(Vt2) <= Limits<real_type>::min())
-      mWingSpanOver2Speed = 0;
-    else
-      mWingSpanOver2Speed = getWingSpan()/Vt2;
-    mDirtyWingSpanOver2Speed = false;
-  }
-  return mWingSpanOver2Speed;
-}
-
-const real_type&
-AeroForce::getCoordOver2Speed(void) const
-{
-  if (mDirtyCoordOver2Speed) {
-    real_type Vt2 = 2*getTrueSpeed();
-    if (fabs(Vt2) <= Limits<real_type>::min())
-      mCoordOver2Speed = 0;
-    else
-      mCoordOver2Speed = getCoord()/Vt2;
-    mDirtyCoordOver2Speed = false;
-  }
-  return mCoordOver2Speed;
-}
-
-const real_type&
-AeroForce::getHOverWingSpan(void) const
-{
-  if (mDirtyHOverWingSpan) {
-    mHOverWingSpan = getAboveGroundLevel()/getWingSpan();
-    mDirtyHOverWingSpan = false;
-  }
-  return mHOverWingSpan;
-}
-
-void
-AeroForce::setEnvironment(Environment* environment)
-{
-  mEnvironment = environment;
-}
-
-void
-AeroForce::dirtyAll(void)
-{
-  // Dirty everything.
-  mDirtyRefPosition = true;
-  mDirtyUnitDown = true;
-  mDirtyLocalGroundPlane = true;
-  mDirtyAtmosphere = true;
-  mDirtyAltitude = true;
-  mDirtyAboveGroundLevel = true;
-  mDirtyWingSpanOver2Speed = true;
-  mDirtyCoordOver2Speed = true;
-  mDirtyHOverWingSpan = true;
-  mDirtySLAtmosphere = true;
-  mDirtyAirSpeed = true;
-  mDirtyMach = true;
-  mDirtyMachNumber = true;
-  mDirtyTrueSpeed = true;
-  mDirtyTrueSpeedUW = true;
-  mDirtyCalibratedAirSpeed = true;
-  mDirtyEquivalentAirSpeed = true;
-  mDirtyDynamicPressure = true;
-  mDirtyAlpha = true;
-  mDirtyAlphaDot = true;
-  mDirtyBeta = true;
-  mDirtyBetaDot = true;
-}
-
-void
-AeroForce::computeAtmosphere(void) const
-{
-  if (mDirtyAtmosphere) {
-    // Get the Athmosphere information at this position and the given time.
-    mAtmos = getAtmosphere()->getData(getAltitude());
-    mSoundSpeed = getAtmosphere()->getSoundSpeed(mAtmos.temperature);
-    mDirtyAtmosphere = false;
-  }
-}
-
-void
-AeroForce::computeSLAtmosphere(void) const
-{
-  if (mDirtySLAtmosphere) {
-    // Hmm, may be this does not need to be computed each time???
-    mSLAtmos = getAtmosphere()->getData(0);
-    mSLSoundSpeed = getAtmosphere()->getSoundSpeed(mSLAtmos.temperature);
-    mDirtySLAtmosphere = false;
-  }
-}
-
-void
-AeroForce::computeCalEquAirspeed(void) const
-{
-  real_type p = getPressure();
-  real_type psl = getPressureSeaLevel();
-  real_type rhosl = getDensitySeaLevel();
-  Vector3 mach = getMach();
-  real_type qbar = getDynamicPressure();
-  // Calibrated Airspeed
-  real_type tube_press;
-  if (mach(0) < 1) {   // Calculate total pressure assuming isentropic flow
-    tube_press = p*pow((1 + 0.2*mach(0)*mach(0)), real_type(3.5));
-  } else {
-    // Use Rayleigh pitot tube formula for normal shock in front of pitot tube
-    real_type B = 5.76*mach(0)*mach(0)/(5.6*mach(0)*mach(0) - 0.8);
-    real_type D = 0.4167*(2.8*mach(0)*mach(0) - 0.4);
-    tube_press = p*pow(B, real_type(3.5))*D;
-  }
-  real_type A = pow(((tube_press-p)/psl+1), real_type(0.28571));
-  if (mach(0) > 0) {
-    mCalibratedAirSpeed = sqrt(7*psl/rhosl*(A-1));
-    mEquivalentAirSpeed = sqrt(2*qbar/rhosl);
-  } else {
-    mCalibratedAirSpeed = 0;
-    mEquivalentAirSpeed = 0;
-  }
-  
-  mDirtyCalibratedAirSpeed = false;
-  mDirtyEquivalentAirSpeed = false;
-}
-
-} // namespace OpenFDM

Deleted: branches/OpenFDM-StateSeparation/src/OpenFDM/AeroForce.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/AeroForce.h	2009-07-26 21:42:48 UTC (rev 1030)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/AeroForce.h	2009-07-27 05:10:43 UTC (rev 1031)
@@ -1,146 +0,0 @@
-/* -*-c++-*- OpenFDM - Copyright (C) 2004-2009 Mathias Froehlich 
- *
- */
-
-#ifndef OpenFDM_AeroForce_H
-#define OpenFDM_AeroForce_H
-
-#include "Assert.h"
-#include "Object.h"
-#include "Vector.h"
-#include "Force.h"
-#include "Atmosphere.h"
-#include "Ground.h"
-#include "Wind.h"
-#include "Planet.h"
-#include "Environment.h"
-
-namespace OpenFDM {
-
-class AeroForce : public ExternalForce {
-  OPENFDM_OBJECT(AeroForce, ExternalForce);
-public:
-  AeroForce(const std::string&);
-  virtual ~AeroForce(void);
-
-  virtual bool init(void);
-  virtual void output(const TaskInfo&);
-
-  void setWingSpan(const real_type& winSpan);
-  const real_type& getWingSpan(void) const;
-
-  void setWingArea(const real_type& winArea);
-  const real_type& getWingArea(void) const;
-
-  void setCoord(const real_type& coord);
-  const real_type& getCoord(void) const;
-
-  const Vector6& getAirSpeed(void) const;
-  const Vector3& getMach(void) const;
-  const real_type& getTrueSpeed(void) const;
-//   const real_type& getEquivalentAirSpeed(void) const;
-//   const real_type& getCalibratedAirSpeed(void) const;
-  const real_type& getDynamicPressure(void) const;
-  const real_type& getAlpha(void) const;
-  const real_type& getAlphaDot(void) const;
-  const real_type& getBeta(void) const;
-  const real_type& getBetaDot(void) const;
-
-  const real_type& getBodyU(void) const;
-  const real_type& getBodyV(void) const;
-  const real_type& getBodyW(void) const;
-
-  const real_type& getBodyP(void) const;
-  const real_type& getBodyQ(void) const;
-  const real_type& getBodyR(void) const;
-
-  const real_type& getMachNumber(void) const;
-  const real_type& getTrueSpeedUW(void) const;
-
-  /// FIXME, may be just provide 1/(2Vt)???
-  /// Or provide the whole set of nondimentionalized values ...
-  /// May be better since we can throw out the singularities ...
-  const real_type& getWingSpanOver2Speed(void) const;
-  const real_type& getCoordOver2Speed(void) const;
-  const real_type& getHOverWingSpan(void) const;
-
-protected:
-  virtual void setEnvironment(Environment* environment);
-
-private:
-  void dirtyAll(void);
-  void computeAtmosphere(void) const;
-  void computeSLAtmosphere(void) const;
-  void computeCalEquAirspeed(void) const;
-
-  RealPortHandle mStabilityAxisForce[3];
-  RealPortHandle mBodyAxisTorque[3];
-
-  const Atmosphere* getAtmosphere(void) const
-  { return mEnvironment->getAtmosphere(); }
-  const Planet* getPlanet(void) const
-  { return mEnvironment->getPlanet(); }
-  const Ground* getGround(void) const
-  { return mEnvironment->getGround(); }
-  const Wind* getWind(void) const
-  { return mEnvironment->getWind(); }
-
-  SharedPtr<const Environment> mEnvironment;
-
-  real_type mWingSpan;
-  real_type mWingArea;
-  real_type mCoord;
-
-  mutable bool mDirtyRefPosition:1;
-  mutable bool mDirtyUnitDown:1;
-  mutable bool mDirtyLocalGroundPlane:1;
-  mutable bool mDirtyAltitude:1;
-  mutable bool mDirtyAboveGroundLevel:1;
-  mutable bool mDirtyWingSpanOver2Speed:1;
-  mutable bool mDirtyCoordOver2Speed:1;
-  mutable bool mDirtyHOverWingSpan:1;
-  mutable bool mDirtyAtmosphere:1;
-  mutable bool mDirtySLAtmosphere:1;
-  mutable bool mDirtyAirSpeed:1;
-  mutable bool mDirtyMach:1;
-  mutable bool mDirtyMachNumber:1;
-  mutable bool mDirtyTrueSpeed:1;
-  mutable bool mDirtyTrueSpeedUW:1;
-  mutable bool mDirtyCalibratedAirSpeed:1;
-  mutable bool mDirtyEquivalentAirSpeed:1;
-  mutable bool mDirtyDynamicPressure:1;
-  mutable bool mDirtyAlpha:1;
-  mutable bool mDirtyAlphaDot:1;
-  mutable bool mDirtyBeta:1;
-  mutable bool mDirtyBetaDot:1;
-  mutable Vector3 mRefPosition;
-  mutable Vector3 mUnitDown;
-  mutable Plane mLocalGroundPlane;
-  mutable AtmosphereData mAtmos;
-  mutable real_type mSoundSpeed;
-  mutable AtmosphereData mSLAtmos;
-  mutable real_type mSLSoundSpeed;
-  mutable Vector6 mAirSpeed;
-  mutable Vector3 mMach;
-  mutable real_type mMachNumber;
-  mutable real_type mAltitude;
-  mutable real_type mAboveGroundLevel;
-  mutable real_type mWingSpanOver2Speed;
-  mutable real_type mCoordOver2Speed;
-  mutable real_type mHOverWingSpan;
-  mutable real_type mTrueSpeed;
-  mutable real_type mTrueSpeedUW;
-  mutable real_type mCalibratedAirSpeed;
-  mutable real_type mEquivalentAirSpeed;
-  mutable real_type mDynamicPressure;
-  mutable real_type mAlpha;
-  mutable real_type mAlphaDot;
-  mutable real_type mBeta;
-  mutable real_type mBetaDot;
-
-  GroundValues mGroundVal;
-};
-
-} // namespace OpenFDM
-
-#endif

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2009-07-26 21:42:48 UTC (rev 1030)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2009-07-27 05:10:43 UTC (rev 1031)
@@ -264,7 +264,6 @@
   WindAxisForce.cpp
 
 OpenFDMMechanicHEADERS = \
-  AeroForce.h \
   CartesianJoint.h \
   Contact.h \
   ExternalInteract.h \
@@ -313,12 +312,10 @@
   WheelContact.cpp
 
 
-#   AeroForce.cpp \
 #   Tank.cpp
 
-#   Launchbar.cpp \
-#   Tailhook.cpp \
-#
+#   Launchbar.cpp
+#   Tailhook.cpp
 
 nobase_OpenFDMinclude_HEADERS = \
   $(OpenFDMCoreHEADERS) \



From frohlich at mail.berlios.de  Tue Jul 28 07:34:03 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Tue, 28 Jul 2009 07:34:03 +0200
Subject: [OpenFDM-svn] r1032 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200907280534.n6S5Y3QY030646@sheep.berlios.de>

Author: frohlich
Date: 2009-07-28 07:34:00 +0200 (Tue, 28 Jul 2009)
New Revision: 1032

Added:
   branches/OpenFDM-StateSeparation/src/OpenFDM/SafeReciprocal.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/SafeReciprocal.h
Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
Log:
Add a division by zero safe 1/x block.

M    Makefile.am
AM   SafeReciprocal.cpp
AM   SafeReciprocal.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2009-07-27 05:10:43 UTC (rev 1031)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2009-07-28 05:34:00 UTC (rev 1032)
@@ -216,6 +216,7 @@
   MinModel.h \
   Output.h \
   Product.h \
+  SafeReciprocal.h \
   Saturation.h \
   SimpleDirectModel.h \
   SimulationTime.h \
@@ -251,6 +252,7 @@
   MinModel.cpp \
   Output.cpp \
   Product.cpp \
+  SafeReciprocal.cpp \
   Saturation.cpp \
   SimpleDirectModel.cpp \
   SimulationTime.cpp \

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/SafeReciprocal.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/SafeReciprocal.cpp	2009-07-27 05:10:43 UTC (rev 1031)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/SafeReciprocal.cpp	2009-07-28 05:34:00 UTC (rev 1032)
@@ -0,0 +1,42 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2009 Mathias Froehlich 
+ *
+ */
+
+#include "SafeReciprocal.h"
+
+#include "TypeInfo.h"
+#include "Variant.h"
+
+namespace OpenFDM {
+
+BEGIN_OPENFDM_OBJECT_DEF(SafeReciprocal, SimpleDirectModel)
+  DEF_OPENFDM_PROPERTY(Real, Epsilon, Serialized)
+  END_OPENFDM_OBJECT_DEF
+
+SafeReciprocal::SafeReciprocal(const std::string& name, const real_type& eps) :
+  SimpleDirectModel(name),
+  mEpsilon(eps)
+{
+  addInputPort("input");
+}
+
+SafeReciprocal::~SafeReciprocal(void)
+{
+}
+
+void
+SafeReciprocal::output(Context& context) const
+{
+  // FIXME, optimize, move that into a proper context ...
+  // For now make it work
+  Size sz = size(context.getInputValue(0));
+  for (unsigned j = 0; j < sz(1); ++j) {
+    for (unsigned i = 0; i < sz(0); ++i) {
+      real_type value = context.getInputValue(0)(i, j);
+      real_type rvalue = copysign(real_type(1)/(fabs(value) + mEpsilon), value);
+      context.getOutputValue()(i, j) = rvalue;
+    }
+  }
+}
+
+} // namespace OpenFDM


Property changes on: branches/OpenFDM-StateSeparation/src/OpenFDM/SafeReciprocal.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/SafeReciprocal.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/SafeReciprocal.h	2009-07-27 05:10:43 UTC (rev 1031)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/SafeReciprocal.h	2009-07-28 05:34:00 UTC (rev 1032)
@@ -0,0 +1,33 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2009 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_SafeReciprocal_H
+#define OpenFDM_SafeReciprocal_H
+
+#include <string>
+#include "SimpleDirectModel.h"
+
+namespace OpenFDM {
+
+class SafeReciprocal : public SimpleDirectModel {
+  OPENFDM_OBJECT(SafeReciprocal, SimpleDirectModel);
+public:
+  SafeReciprocal(const std::string& name,
+                 const real_type& epsilon = Limits<real_type>::safe_min());
+  virtual ~SafeReciprocal(void);
+
+  void output(Context& context) const;
+
+  const real_type& getEpsilon() const
+  { return mEpsilon; }
+  void setEpsilon(const real_type& epsilon)
+  { mEpsilon = epsilon; }
+
+private:
+  real_type mEpsilon;
+};
+
+} // namespace OpenFDM
+
+#endif


Property changes on: branches/OpenFDM-StateSeparation/src/OpenFDM/SafeReciprocal.h
___________________________________________________________________
Name: svn:eol-style
   + native



From frohlich at mail.berlios.de  Tue Jul 28 07:36:02 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Tue, 28 Jul 2009 07:36:02 +0200
Subject: [OpenFDM-svn] r1033 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200907280536.n6S5a2nb032686@sheep.berlios.de>

Author: frohlich
Date: 2009-07-28 07:35:53 +0200 (Tue, 28 Jul 2009)
New Revision: 1033

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/WindAxis.cpp
Log:
Check both arguments to atan2 for zero.

M    WindAxis.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/WindAxis.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/WindAxis.cpp	2009-07-28 05:34:00 UTC (rev 1032)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/WindAxis.cpp	2009-07-28 05:35:53 UTC (rev 1033)
@@ -34,13 +34,13 @@
   Vector3 v = portValues[mVelocityPort];
   
   real_type alpha = 0;
-  if (Limits<real_type>::min() < fabs(v(0)))
+  if (Limits<real_type>::min() < fabs(v(0)*v(2)))
     alpha = atan2(v(2), v(0));
   portValues[mAlphaPort] = alpha;
   
   real_type beta = 0;
   real_type uw = sqrt(v(0)*v(0) + v(2)*v(2));
-  if (Limits<real_type>::min() < fabs(uw))
+  if (Limits<real_type>::min() < fabs(v(1)*uw))
     beta = atan2(v(1), uw);
   portValues[mBetaPort] = beta;
   



From frohlich at mail.berlios.de  Tue Jul 28 20:52:10 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Tue, 28 Jul 2009 20:52:10 +0200
Subject: [OpenFDM-svn] r1034 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200907281852.n6SIqAkZ009477@sheep.berlios.de>

Author: frohlich
Date: 2009-07-28 20:52:09 +0200 (Tue, 28 Jul 2009)
New Revision: 1034

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/ExternalInteract.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/WindAxisForce.cpp
Log:
Fix wind axis conventions.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/ExternalInteract.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ExternalInteract.cpp	2009-07-28 05:35:53 UTC (rev 1033)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ExternalInteract.cpp	2009-07-28 18:52:09 UTC (rev 1034)
@@ -70,9 +70,8 @@
     const CoordinateSystem& cs = getLink().getCoordinateSystem();
 
     // The global coordinates position
-    Vector3 refPosition = cs.getPosition();
     if (mPosition.isConnected())
-      mPosition = refPosition;
+      mPosition = cs.getPosition();
     
     if (mOrientation.isConnected())
       mOrientation = cs.getOrientation();
@@ -90,7 +89,7 @@
     if (enableBodyAngularVelocity || enableBodyLinearVelocity
         || enableGlobalAngularVelocity || enableGlobalLinearVelocity
         || enableBodyWindVelocity || enableGlobalWindVelocity) {
-      Vector6 refVelocity = getLink().getVelocity();
+      Vector6 refVelocity = getLink().getVelocity(cs.getPosition());
       if (enableBodyAngularVelocity)
         mBodyAngularVelocity = cs.rotToLocal(refVelocity.getAngular());
       if (enableGlobalAngularVelocity)
@@ -104,8 +103,8 @@
       // Wind sensing
       if (enableBodyWindVelocity || enableGlobalWindVelocity) {
         Vector6 wind = getEnvironment().getWindVelocity(task.getTime(),
-                                                        refPosition);
-        wind -= refVelocity;
+                                                        cs.getPosition());
+        wind = refVelocity - wind;
         if (enableBodyWindVelocity)
           mBodyWindVelocity = cs.rotToLocal(wind.getLinear());
         if (enableGlobalWindVelocity)
@@ -123,7 +122,7 @@
     bool enableAtmosphere = (enableTemperature || enableStaticPressure ||
                              enableDensity || enableSoundSpeed);
     if (enableAltitude || enableAtmosphere) {
-      real_type altitude = getEnvironment().getAltitude(refPosition);
+      real_type altitude = getEnvironment().getAltitude(cs.getPosition());
       if (enableAltitude)
         mAltitude = altitude;
       
@@ -143,7 +142,8 @@
     
     if (mAboveGroundLevel.isConnected()) {
       real_type agl;
-      agl = getEnvironment().getAboveGroundLevel(task.getTime(), refPosition);
+      agl = getEnvironment().getAboveGroundLevel(task.getTime(),
+                                                 cs.getPosition());
       mAboveGroundLevel = agl;
     }
   }
@@ -170,8 +170,8 @@
     if (enableBodyCentrifugalAcceleration || enableBodyLoad) {
       const CoordinateSystem& cs = getLink().getCoordinateSystem();
 
-      Vector6 spatialVel = getLink().getInertialVelocity();
-      Vector6 spatialAccel = getLink().getInertialAcceleration();
+      Vector6 spatialVel = getLink().getInertialVelocity(cs.getPosition());
+      Vector6 spatialAccel = getLink().getInertialAcceleration(cs.getPosition());
       Vector3 centrifugalAccel = spatialAccel.getLinear();
       centrifugalAccel += cross(spatialVel.getAngular(),spatialVel.getLinear());
 
@@ -179,8 +179,7 @@
         mBodyCentrifugalAcceleration = cs.rotToLocal(centrifugalAccel);
       if (enableBodyLoad) {
         // May be cache that from the velocity step??
-        Vector3 refPosition = cs.getPosition();
-        Vector3 gravity = getEnvironment().getGravityAcceleration(refPosition);
+        Vector3 gravity = getEnvironment().getGravityAcceleration(cs.getPosition());
         mBodyLoad = cs.rotToLocal(Vector3(centrifugalAccel - gravity));
       }
     }

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/WindAxisForce.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/WindAxisForce.cpp	2009-07-28 05:35:53 UTC (rev 1033)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/WindAxisForce.cpp	2009-07-28 18:52:09 UTC (rev 1034)
@@ -42,9 +42,9 @@
   // The transform from stability axis to body axis where the
   // stability axis x axis points into the wind, the y axis points
   // to the right and the z axis points downwards
-  Matrix33 Tw2b(-ca*cb, -ca*sb,  sa,
-                -sb,     cb,   0,
-                -sa*cb, -sa*sb, -ca);
+  Matrix33 Tw2b(ca*cb, -ca*sb, -sa,
+                   sb,     cb,   0,
+                sa*cb, -sa*sb,  ca);
   
   // Get the forces
   real_type drag = 0;



From frohlich at mail.berlios.de  Tue Jul 28 20:53:03 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Tue, 28 Jul 2009 20:53:03 +0200
Subject: [OpenFDM-svn] r1035 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200907281853.n6SIr3Q6009728@sheep.berlios.de>

Author: frohlich
Date: 2009-07-28 20:53:03 +0200 (Tue, 28 Jul 2009)
New Revision: 1035

Modified:
   branches/OpenFDM-StateSeparation/src/test/ballistic.cpp
Log:
Extend the ballistic testcase.

M    ballistic.cpp


Modified: branches/OpenFDM-StateSeparation/src/test/ballistic.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/ballistic.cpp	2009-07-28 18:52:09 UTC (rev 1034)
+++ branches/OpenFDM-StateSeparation/src/test/ballistic.cpp	2009-07-28 18:53:03 UTC (rev 1035)
@@ -1,18 +1,17 @@
 #include <OpenFDM/ConstModel.h>
+#include <OpenFDM/DynamicPressure.h>
+#include <OpenFDM/ExternalInteract.h>
 #include <OpenFDM/Gain.h>
 #include <OpenFDM/Group.h>
-#include <OpenFDM/InternalInteract.h>
-#include <OpenFDM/LinearSpringDamper.h>
+#include <OpenFDM/MachNumber.h>
 #include <OpenFDM/Mass.h>
+#include <OpenFDM/MatrixConcat.h>
+#include <OpenFDM/MatrixSplit.h>
 #include <OpenFDM/MobileRootJoint.h>
-#include <OpenFDM/RevoluteJoint.h>
+#include <OpenFDM/Product.h>
 #include <OpenFDM/RigidBody.h>
-#include <OpenFDM/ExternalInteract.h>
 #include <OpenFDM/System.h>
 #include <OpenFDM/SystemOutput.h>
-
-#include <OpenFDM/DynamicPressure.h>
-#include <OpenFDM/MachNumber.h>
 #include <OpenFDM/WindAxis.h>
 #include <OpenFDM/WindAxisForce.h>
 
@@ -24,7 +23,8 @@
   SharedPtr<Group> group = new Group("Group");
 
   MobileRootJoint* mobileRootJoint = new MobileRootJoint("Root Joint");
-  mobileRootJoint->setInitialLinearVelocity(50/sqrt(2)*Vector3(1, 0, -1));
+  mobileRootJoint->setInitialLinearVelocity(50*Vector3(1, 0, 0));
+  mobileRootJoint->setInitialOrientation(Quaternion::fromEulerSeq(1, 45*deg2rad));
   group->addChild(mobileRootJoint);
 
   RigidBody* rigidBody = new RigidBody("Rigid Body");
@@ -101,6 +101,55 @@
   group->connect(dragCoeficient->getPort("output"),
                  windAxisForce->getPort("drag"));
 
+
+  Product* alphaProduct = new Product("Alpha Product");
+  group->addChild(alphaProduct);
+
+  group->connect(alphaProduct->getPort("input0"),
+                 dynamicPressure->getPort("dynamicPressure"));
+  group->connect(alphaProduct->getPort("input1"),
+                 windAxis->getPort("alpha"));
+
+  Gain* alphaCoeficient = new Gain("Alpha Coeficient");
+  alphaCoeficient->setGain(-10);
+  group->addChild(alphaCoeficient);
+
+  group->connect(alphaCoeficient->getPort("input"),
+                 alphaProduct->getPort("output"));
+
+
+
+  Product* betaProduct = new Product("Beta Product");
+  group->addChild(betaProduct);
+
+  group->connect(betaProduct->getPort("input0"),
+                 dynamicPressure->getPort("dynamicPressure"));
+  group->connect(betaProduct->getPort("input1"),
+                 windAxis->getPort("beta"));
+
+  Gain* betaCoeficient = new Gain("Beta Coeficient");
+  betaCoeficient->setGain(-10);
+  group->addChild(betaCoeficient);
+
+  group->connect(betaCoeficient->getPort("input"),
+                 betaProduct->getPort("output"));
+
+
+
+  MatrixConcat* torque = new MatrixConcat("Torque");
+  group->addChild(torque);
+
+  group->connect(zeroConst->getPort("output"),
+                 torque->addInputPort("x"));
+  group->connect(alphaCoeficient->getPort("output"),
+                 torque->addInputPort("y"));
+  group->connect(betaCoeficient->getPort("output"),
+                 torque->addInputPort("z"));
+
+  externalInteract->setEnableBodyTorque(true);
+  group->connect(torque->getPort("output"),
+                 externalInteract->getPort("bodyTorque"));
+
   return group.release();
 }
 



