From frohlich at mail.berlios.de  Sat Aug  1 09:50:14 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 1 Aug 2009 09:50:14 +0200
Subject: [OpenFDM-svn] r1038 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200908010750.n717oEcU016070@sheep.berlios.de>

Author: frohlich
Date: 2009-08-01 09:50:13 +0200 (Sat, 01 Aug 2009)
New Revision: 1038

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/ReaderWriter.h
Log:
Make the toplevel information a System.

M    ReaderWriter.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/ReaderWriter.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ReaderWriter.h	2009-08-01 07:43:52 UTC (rev 1037)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ReaderWriter.h	2009-08-01 07:50:13 UTC (rev 1038)
@@ -12,7 +12,7 @@
 
 namespace OpenFDM {
 
-class Vehicle;
+class System;
 
 /** Abstract base class for a reader/writer of OpenFDM vehicles.
  * (At present only reading ...) FIXME
@@ -46,8 +46,8 @@
 
   /** Returns a pointer to the vehicle.
    */
-//   Vehicle* getVehicle(void)
-//   { return mVehicle; }
+  System* getSystem(void)
+  { return mSystem; }
   
 protected:
   /** Slot where a ReaderWriter implementation should reset it's state.
@@ -63,9 +63,9 @@
    */
   bool error(const std::string& message);
 
-//   /** The Vehicle handle.
-//    */
-//   SharedPtr<Vehicle> mVehicle;
+  /** The System.
+   */
+  SharedPtr<System> mSystem;
 
 private:
   /** A list of errors during import.



From frohlich at mail.berlios.de  Sat Aug  1 14:20:43 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 1 Aug 2009 14:20:43 +0200
Subject: [OpenFDM-svn] r1039 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200908011220.n71CKhYF025019@sheep.berlios.de>

Author: frohlich
Date: 2009-08-01 14:20:42 +0200 (Sat, 01 Aug 2009)
New Revision: 1039

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/WheelContact.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/WheelContact.h
Log:
Unify names.

M    WheelContact.h
M    WheelContact.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/WheelContact.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/WheelContact.cpp	2009-08-01 07:50:13 UTC (rev 1038)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/WheelContact.cpp	2009-08-01 12:20:42 UTC (rev 1039)
@@ -16,7 +16,7 @@
   DEF_OPENFDM_PROPERTY(Vector3, Axis, Serialized)
   DEF_OPENFDM_PROPERTY(Real, WheelRadius, Serialized)
   DEF_OPENFDM_PROPERTY(Real, SpringConstant, Serialized)
-  DEF_OPENFDM_PROPERTY(Real, DampingConstant, Serialized)
+  DEF_OPENFDM_PROPERTY(Real, DamperConstant, Serialized)
   DEF_OPENFDM_PROPERTY(Real, FrictionCoeficient, Serialized)
   END_OPENFDM_OBJECT_DEF
 
@@ -115,7 +115,7 @@
 {
   mWheelRadius = 0.3;
   mSpringConstant = 0;
-  mDampingConstant = 0;
+  mDamperConstant = 0;
   mFrictionCoeficient = 0.8;
 }
 
@@ -135,7 +135,7 @@
                                  real_type compressVel,
                                  PortValueList&) const
 {
-  return compressLen*mSpringConstant + mDampingConstant*compressVel;
+  return compressLen*mSpringConstant + mDamperConstant*compressVel;
 }
 
 Vector2

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/WheelContact.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/WheelContact.h	2009-08-01 07:50:13 UTC (rev 1038)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/WheelContact.h	2009-08-01 12:20:42 UTC (rev 1039)
@@ -49,10 +49,10 @@
   const real_type& getSpringConstant(void) const
   { return mSpringConstant; }
 
-  void setDampingConstant(const real_type& dampingConstant)
-  { mDampingConstant = dampingConstant; }
-  const real_type& getDampingConstant(void) const
-  { return mDampingConstant; }
+  void setDamperConstant(const real_type& dampingConstant)
+  { mDamperConstant = dampingConstant; }
+  const real_type& getDamperConstant(void) const
+  { return mDamperConstant; }
 
   void setFrictionCoeficient(const real_type& frictionCoeficient)
   { mFrictionCoeficient = frictionCoeficient; }
@@ -64,7 +64,7 @@
   real_type mWheelRadius;
 
   real_type mSpringConstant;
-  real_type mDampingConstant;
+  real_type mDamperConstant;
   real_type mFrictionCoeficient;
 };
 



From frohlich at mail.berlios.de  Sat Aug  1 14:41:57 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 1 Aug 2009 14:41:57 +0200
Subject: [OpenFDM-svn] r1041 - branches/OpenFDM-StateSeparation/src
Message-ID: <200908011241.n71CfvvC026717@sheep.berlios.de>

Author: frohlich
Date: 2009-08-01 14:41:56 +0200 (Sat, 01 Aug 2009)
New Revision: 1041

Modified:
   branches/OpenFDM-StateSeparation/src/Makefile.am
Log:
Zap useless comment.

M    Makefile.am


Modified: branches/OpenFDM-StateSeparation/src/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/Makefile.am	2009-08-01 12:25:53 UTC (rev 1040)
+++ branches/OpenFDM-StateSeparation/src/Makefile.am	2009-08-01 12:41:56 UTC (rev 1041)
@@ -1,5 +1,4 @@
 SUBDIRS = OpenFDM JSBSim test
-# SUBDIRS = OpenFDM test
 if ENABLE_BUILDER
 SUBDIRS += builder
 endif



From frohlich at mail.berlios.de  Sat Aug  1 14:42:25 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 1 Aug 2009 14:42:25 +0200
Subject: [OpenFDM-svn] r1042 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200908011242.n71CgP8s026769@sheep.berlios.de>

Author: frohlich
Date: 2009-08-01 14:42:21 +0200 (Sat, 01 Aug 2009)
New Revision: 1042

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/XMLDumpModelVisitor.h
Log:
Make it compile.

M    XMLDumpModelVisitor.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/XMLDumpModelVisitor.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/XMLDumpModelVisitor.h	2009-08-01 12:41:56 UTC (rev 1041)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/XMLDumpModelVisitor.h	2009-08-01 12:42:21 UTC (rev 1042)
@@ -10,13 +10,14 @@
 #include <sstream>
 #include <iomanip>
 
-#include "ModelVisitor.h"
-#include "Model.h"
-#include "ModelGroup.h"
+#include "NodeVisitor.h"
+#include "Node.h"
+#include "Group.h"
+#include "TypeInfo.h"
 
 namespace OpenFDM {
 
-class XMLDumpModelVisitor : public ModelVisitor {
+class XMLDumpModelVisitor : public NodeVisitor {
 public:
   XMLDumpModelVisitor(std::ostream& os) :
     mOs(os),
@@ -27,7 +28,7 @@
   virtual ~XMLDumpModelVisitor(void)
   { }
 
-  virtual void apply(Model& model)
+  virtual void apply(Node& model)
   {
     indent() << "<model type=\"" << model.getTypeName() << "\">\n";
     ++mIndent;
@@ -35,63 +36,52 @@
     --mIndent;
     indent() << "</model>\n";
   }
-  virtual void apply(ModelGroup& modelGroup)
+  virtual void apply(Group& modelGroup)
   {
     indent() << "<model type=\"ModelGroup\">\n";
     ++mIndent;
     dumpProperties(modelGroup);
-    traverse(modelGroup);
+    modelGroup.traverse(*this);
     dumpConnections(modelGroup);
     --mIndent;
     indent() << "</model>\n";
   }
-  virtual void apply(System& system)
+//   virtual void apply(System& system)
+//   {
+//     indent() << "<?xml version=\"1.0\"?>\n";
+//     indent() << "<OpenFDM>\n";
+//     ++mIndent;
+//     indent() << "<model type=\"System\">\n";
+//     ++mIndent;
+//     dumpProperties(system);
+//     traverse(system);
+//     dumpConnections(system);
+//     --mIndent;
+//     indent() << "</model>\n";
+//     --mIndent;
+//     indent() << "</OpenFDM>\n";
+//   }
+private:
+  void dumpPort(const Port* port)
   {
-    indent() << "<?xml version=\"1.0\"?>\n";
-    indent() << "<OpenFDM>\n";
-    ++mIndent;
-    indent() << "<model type=\"System\">\n";
-    ++mIndent;
-    dumpProperties(system);
-    traverse(system);
-    dumpConnections(system);
-    --mIndent;
-    indent() << "</model>\n";
-    --mIndent;
-    indent() << "</OpenFDM>\n";
+    if (!port)
+      return;
+    SharedPtr<const Node> node = port->getNode();
+    if (!node)
+      return;
+    indent() << "<Port ModelName=\"" << node->getName()
+             << "\" PortName=\"" << port->getName()
+             << "\"/>\n";
   }
-private:
-  void dumpConnections(const ModelGroup& modelGroup)
+  void dumpConnections(const Group& modelGroup)
   {
-    unsigned numConnections = modelGroup.getNumConnections();
+    unsigned numConnections = modelGroup.getNumConnects();
     for (unsigned i = 0; i < numConnections; ++i) {
-      const Connection* connection = modelGroup.getConnection(i);
-      if (connection->getName().empty())
-        indent() << "<connect>\n";
-      else
-        indent() << "<connect name=\"" << connection->getName() << "\">\n";
+      const Connect* connection = modelGroup.getConnect(i);
+      indent() << "<connect>\n";
       ++mIndent;
-      dumpProperties(*connection);
-      SharedPtr<const PortProvider> portProvider;
-      portProvider = connection->getPortProvider().lock();
-      if (portProvider) {
-        SharedPtr<Node> node = portProvider->getModel().lock();
-        if (node) {
-          indent() << "<PortProvider ModelName=\"" << node->getName()
-                   << "\" PortName=\"" << portProvider->getName()
-                   << "\"/>\n";
-        }
-      }
-      SharedPtr<const PortAcceptor> portAcceptor;
-      portAcceptor = connection->getPortAcceptor().lock();
-      if (portAcceptor) {
-        SharedPtr<Node> node = portAcceptor->getModel().lock();
-        if (node) {
-          indent() << "<PortAcceptor ModelName=\"" << node->getName()
-                   << "\" PortName=\"" << portAcceptor->getName()
-                   << "\"/>\n";
-        }
-      }
+      dumpPort(connection->getPort0());
+      dumpPort(connection->getPort1());
       --mIndent;
       indent() << "</connect>\n";
     }



From frohlich at mail.berlios.de  Sat Aug  1 14:43:01 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 1 Aug 2009 14:43:01 +0200
Subject: [OpenFDM-svn] r1043 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200908011243.n71Ch1nB026819@sheep.berlios.de>

Author: frohlich
Date: 2009-08-01 14:43:00 +0200 (Sat, 01 Aug 2009)
New Revision: 1043

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
   branches/OpenFDM-StateSeparation/src/OpenFDM/ReaderWriter.cpp
Log:
Add issing file. Make this one compile.

M    Makefile.am
M    ReaderWriter.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2009-08-01 12:42:21 UTC (rev 1042)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2009-08-01 12:43:00 UTC (rev 1043)
@@ -177,6 +177,7 @@
   ODESolver.cpp \
   Port.cpp \
   PortValue.cpp \
+  ReaderWriter.cpp \
   RigidBody.cpp \
   RootJoint.cpp \
   SphericalEarth.cpp \

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/ReaderWriter.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ReaderWriter.cpp	2009-08-01 12:42:21 UTC (rev 1042)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ReaderWriter.cpp	2009-08-01 12:43:00 UTC (rev 1043)
@@ -4,6 +4,8 @@
 
 #include "ReaderWriter.h"
 
+#include "System.h"
+
 namespace OpenFDM {
 
 ReaderWriter::ReaderWriter(void)



From frohlich at mail.berlios.de  Sat Aug  1 14:43:27 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 1 Aug 2009 14:43:27 +0200
Subject: [OpenFDM-svn] r1044 - branches/OpenFDM-StateSeparation/src/JSBSim
Message-ID: <200908011243.n71ChRZb026918@sheep.berlios.de>

Author: frohlich
Date: 2009-08-01 14:43:26 +0200 (Sat, 01 Aug 2009)
New Revision: 1044

Modified:
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.cpp
   branches/OpenFDM-StateSeparation/src/JSBSim/Makefile.am
   branches/OpenFDM-StateSeparation/src/JSBSim/jsb2openfdm.cpp
Log:
Now it compiles ..

M    JSBSim/JSBSimReaderBase.cpp
M    JSBSim/jsb2openfdm.cpp
M    JSBSim/Makefile.am


Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.cpp	2009-08-01 12:43:00 UTC (rev 1043)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.cpp	2009-08-01 12:43:26 UTC (rev 1044)
@@ -50,7 +50,7 @@
 #include <OpenFDM/XML/ErrorHandler.h>
 #include <OpenFDM/XML/Attributes.h>
 
-#include <OpenFDM/XML/EasyXMLReader.h> // FIXME
+#include <OpenFDM/XML/ExpatXMLReader.h> // FIXME
 
 #include "JSBSimAerodynamic.h"
 #include "JSBSimAerosurfaceScale.h"
@@ -110,7 +110,7 @@
 JSBSimReaderBase::parseXMLStream(std::istream& stream)
 {
   // Get a parser FIXME
-  SharedPtr<XML::XMLReader> reader = new XML::EasyXMLReader;
+  SharedPtr<XML::XMLReader> reader = new XML::ExpatXMLReader;
   
   // Set the handlers
   SharedPtr<SimpleContentHandler> ch = new SimpleContentHandler;

Modified: branches/OpenFDM-StateSeparation/src/JSBSim/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/Makefile.am	2009-08-01 12:43:00 UTC (rev 1043)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/Makefile.am	2009-08-01 12:43:26 UTC (rev 1044)
@@ -1,5 +1,12 @@
 INCLUDES = -I$(srcdir)/..
 
+if ENABLE_EXPAT
+xml_library = ../OpenFDM/XML/libOpenFDMexpatXML.la
+endif
+if ENABLE_EASYXML
+xml_library = ../OpenFDM/XML/libOpenFDMeasyxmlXML.la
+endif
+
 bin_PROGRAMS = jsb2openfdm
 jsb2openfdm_SOURCES = jsb2openfdm.cpp
 jsb2openfdm_LDFLAGS = 
@@ -30,6 +37,6 @@
   JSBSimScheduledGain.cpp \
   Tablereader.cpp \
   XMLReader.cpp
-libOpenFDMJSBReader_la_LIBADD = ../OpenFDM/XML/libOpenFDMeasyxmlXML.la \
+libOpenFDMJSBReader_la_LIBADD = $(xml_library) \
                                 ../OpenFDM/XML/libOpenFDMXML.la \
                                 ../OpenFDM/libOpenFDM.la

Modified: branches/OpenFDM-StateSeparation/src/JSBSim/jsb2openfdm.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/jsb2openfdm.cpp	2009-08-01 12:43:00 UTC (rev 1043)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/jsb2openfdm.cpp	2009-08-01 12:43:26 UTC (rev 1044)
@@ -1,13 +1,14 @@
 #include <iostream>
 
 #include <OpenFDM/ReaderWriter.h>
+#include <OpenFDM/System.h>
 #include <OpenFDM/XMLDumpModelVisitor.h>
 #include "JSBSimReader.h"
 
 using OpenFDM::ReaderWriter;
 using OpenFDM::JSBSimReader;
-using OpenFDM::Vehicle;
 using OpenFDM::SharedPtr;
+using OpenFDM::System;
 
 int
 main(int argc, char *argv[])
@@ -34,13 +35,13 @@
     
     return EXIT_FAILURE;
   }
-  SharedPtr<Vehicle> vehicle = reader.getVehicle();
+  SharedPtr<System> system = reader.getSystem();
 
   // Ok, now the Vehicle here contains the imported data
   // When the reflection stuff is ready, we can dump that data to a
   // native format ...
   OpenFDM::XMLDumpModelVisitor debugDumpVisitor(std::cout);
-  vehicle->getSystem()->accept(debugDumpVisitor);
+  system->getNode()->accept(debugDumpVisitor);
 
   return 0;
 }



From frohlich at mail.berlios.de  Sat Aug  1 14:53:52 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 1 Aug 2009 14:53:52 +0200
Subject: [OpenFDM-svn] r1045 - branches/OpenFDM-StateSeparation/src/JSBSim
Message-ID: <200908011253.n71CrqrK027898@sheep.berlios.de>

Author: frohlich
Date: 2009-08-01 14:53:51 +0200 (Sat, 01 Aug 2009)
New Revision: 1045

Modified:
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimAerodynamic.cpp
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimScheduledGain.cpp
Log:
Fix some typos.

M    JSBSim/JSBSimAerodynamic.cpp
M    JSBSim/JSBSimScheduledGain.cpp
M    JSBSim/JSBSimReader.cpp


Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimAerodynamic.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimAerodynamic.cpp	2009-08-01 12:43:26 UTC (rev 1044)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimAerodynamic.cpp	2009-08-01 12:53:51 UTC (rev 1045)
@@ -73,11 +73,10 @@
   mGroup->connect(mVTailArmModel->getPort("output"),
                   mVTailArmOutputModel->getPort("input"));
 
-
   mMechanicLinkModel = new GroupMechanicLink("Mechanic Link Model");
+  mGroup->addChild(mMechanicLinkModel);
 
   mExternalInteract = new ExternalInteract("ExternalInteract");
-//   mExternalInteract->setPosition(mass->getPosition());
   mGroup->addChild(mExternalInteract);
 
   mGroup->connect(mMechanicLinkModel->getPort("link"),
@@ -132,7 +131,7 @@
                   mAlphaOutputModel->getPort("input"));
 
   mAlphaDotOutputModel = new GroupOutput("AlphaDot Output");
-  mGroup->addChild(mAlphaOutputModel);
+  mGroup->addChild(mAlphaDotOutputModel);
   mGroup->connect(windAxis->getPort("alphaDot"),
                   mAlphaDotOutputModel->getPort("input"));
 
@@ -142,7 +141,7 @@
                   mBetaOutputModel->getPort("input"));
 
   mBetaDotOutputModel = new GroupOutput("BetaDot Output");
-  mGroup->addChild(mBetaOutputModel);
+  mGroup->addChild(mBetaDotOutputModel);
   mGroup->connect(windAxis->getPort("betaDot"),
                   mBetaDotOutputModel->getPort("input"));
 
@@ -222,7 +221,7 @@
   mGroup->connect(angularVel->getPort("q"),
                   mQOutputModel->getPort("input"));
   mROutputModel = new GroupOutput("R Output");
-  mGroup->addChild(mQOutputModel);
+  mGroup->addChild(mROutputModel);
   mGroup->connect(angularVel->getPort("r"),
                   mROutputModel->getPort("input"));
 

Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp	2009-08-01 12:43:26 UTC (rev 1044)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp	2009-08-01 12:53:51 UTC (rev 1045)
@@ -934,7 +934,7 @@
         addOutputModel(port, "Gear " + numStr + " Position",
                        "gear/gear[" + numStr + "]/position-norm");
         
-//       } else if (type == "TAILHOOK") {
+      } else if (type == "TAILHOOK") {
 //         const XMLElement* tailhookElem = (*it);
 //         std::string name = (*it)->getAttribute("name");
 

Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimScheduledGain.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimScheduledGain.cpp	2009-08-01 12:43:26 UTC (rev 1044)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimScheduledGain.cpp	2009-08-01 12:53:51 UTC (rev 1045)
@@ -35,14 +35,14 @@
 
   // Now connect the input and the output to this groups in and outputs
   GroupInput* groupInput = new GroupInput("Input");
+  getGroup()->addChild(groupInput);
   groupInput->setExternalPortName("input");
-  getGroup()->addChild(groupInput);
   getGroup()->connect(product->getPort("input1"),
                       groupInput->getPort("output"));
  
   groupInput = new GroupInput("Schedule Input");
+  getGroup()->addChild(groupInput);
   groupInput->setExternalPortName("scheduleInput");
-  getGroup()->addChild(groupInput);
   getGroup()->connect(mBreakPointLookup->getPort("input"),
                       groupInput->getPort("output"));
 



From frohlich at mail.berlios.de  Sat Aug  1 15:14:49 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 1 Aug 2009 15:14:49 +0200
Subject: [OpenFDM-svn] r1046 - branches/OpenFDM-StateSeparation/src/JSBSim
Message-ID: <200908011314.n71DEnrc030236@sheep.berlios.de>

Author: frohlich
Date: 2009-08-01 15:14:49 +0200 (Sat, 01 Aug 2009)
New Revision: 1046

Modified:
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimAerosurfaceScale.cpp
Log:
Fix convert bug.

M    JSBSim/JSBSimAerosurfaceScale.cpp


Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimAerosurfaceScale.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimAerosurfaceScale.cpp	2009-08-01 12:53:51 UTC (rev 1045)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimAerosurfaceScale.cpp	2009-08-01 13:14:49 UTC (rev 1046)
@@ -81,8 +81,11 @@
   tmp(0, 0) = minDomain;
   mInputSaturation->setMinSaturation(tmp);
   BreakPointVector tl = mBreakPointLookup->getBreakPointVector();
-  tl.insert(minDomain);
-  mBreakPointLookup->setBreakPointVector(tl);
+  BreakPointVector tl2;
+  tl2.insert(minDomain);
+  tl2.insert(tl[1]);
+  tl2.insert(tl[2]);
+  mBreakPointLookup->setBreakPointVector(tl2);
 }
 
 void
@@ -92,8 +95,11 @@
   tmp(0, 0) = maxDomain;
   mInputSaturation->setMaxSaturation(tmp);
   BreakPointVector tl = mBreakPointLookup->getBreakPointVector();
-  tl.insert(maxDomain);
-  mBreakPointLookup->setBreakPointVector(tl);
+  BreakPointVector tl2;
+  tl2.insert(tl[0]);
+  tl2.insert(tl[1]);
+  tl2.insert(maxDomain);
+  mBreakPointLookup->setBreakPointVector(tl2);
 }
 
 void



From frohlich at mail.berlios.de  Sat Aug  1 20:19:48 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 1 Aug 2009 20:19:48 +0200
Subject: [OpenFDM-svn] r1047 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200908011819.n71IJmWe006632@sheep.berlios.de>

Author: frohlich
Date: 2009-08-01 20:19:48 +0200 (Sat, 01 Aug 2009)
New Revision: 1047

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/XMLDumpModelVisitor.h
Log:
Dump a complete xml file. Fix problems with matrices.

M    XMLDumpModelVisitor.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/XMLDumpModelVisitor.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/XMLDumpModelVisitor.h	2009-08-01 13:14:49 UTC (rev 1046)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/XMLDumpModelVisitor.h	2009-08-01 18:19:48 UTC (rev 1047)
@@ -10,9 +10,10 @@
 #include <sstream>
 #include <iomanip>
 
+#include "Group.h"
+#include "Node.h"
 #include "NodeVisitor.h"
-#include "Node.h"
-#include "Group.h"
+#include "System.h"
 #include "TypeInfo.h"
 
 namespace OpenFDM {
@@ -28,39 +29,38 @@
   virtual ~XMLDumpModelVisitor(void)
   { }
 
-  virtual void apply(Node& model)
+  virtual void apply(Node& node)
   {
-    indent() << "<model type=\"" << model.getTypeName() << "\">\n";
+    indent() << "<node type=\"" << node.getTypeName() << "\">\n";
     ++mIndent;
-    dumpProperties(model);
+    dumpProperties(node);
     --mIndent;
-    indent() << "</model>\n";
+    indent() << "</node>\n";
   }
-  virtual void apply(Group& modelGroup)
+  virtual void apply(Group& group)
   {
-    indent() << "<model type=\"ModelGroup\">\n";
+    indent() << "<node type=\"NodeGroup\">\n";
     ++mIndent;
-    dumpProperties(modelGroup);
-    modelGroup.traverse(*this);
-    dumpConnections(modelGroup);
+    dumpProperties(group);
+    group.traverse(*this);
+    dumpConnections(group);
     --mIndent;
-    indent() << "</model>\n";
+    indent() << "</node>\n";
   }
-//   virtual void apply(System& system)
-//   {
-//     indent() << "<?xml version=\"1.0\"?>\n";
-//     indent() << "<OpenFDM>\n";
-//     ++mIndent;
-//     indent() << "<model type=\"System\">\n";
-//     ++mIndent;
-//     dumpProperties(system);
-//     traverse(system);
-//     dumpConnections(system);
-//     --mIndent;
-//     indent() << "</model>\n";
-//     --mIndent;
-//     indent() << "</OpenFDM>\n";
-//   }
+  void apply(System& system)
+  {
+    indent() << "<?xml version=\"1.0\"?>\n";
+    indent() << "<OpenFDM>\n";
+    ++mIndent;
+    indent() << "<System>\n";
+    ++mIndent;
+    dumpProperties(system);
+    system.getNode()->accept(*this);
+    --mIndent;
+    indent() << "</System>\n";
+    --mIndent;
+    indent() << "</OpenFDM>\n";
+  }
 private:
   void dumpPort(const Port* port)
   {
@@ -69,15 +69,15 @@
     SharedPtr<const Node> node = port->getNode();
     if (!node)
       return;
-    indent() << "<Port ModelName=\"" << node->getName()
-             << "\" PortName=\"" << port->getName()
+    indent() << "<port nodeName=\"" << node->getName()
+             << "\" portName=\"" << port->getName()
              << "\"/>\n";
   }
-  void dumpConnections(const Group& modelGroup)
+  void dumpConnections(const Group& group)
   {
-    unsigned numConnections = modelGroup.getNumConnects();
+    unsigned numConnections = group.getNumConnects();
     for (unsigned i = 0; i < numConnections; ++i) {
-      const Connect* connection = modelGroup.getConnect(i);
+      const Connect* connection = group.getConnect(i);
       indent() << "<connect>\n";
       ++mIndent;
       dumpPort(connection->getPort0());
@@ -122,24 +122,28 @@
             valStr.precision(mPrecision);
             if (cols(mVal) == 1) {
               // A pure vector is written transposed
-              for (unsigned i = 1; i < rows(mVal); ++i)
-                valStr << mVal(i, 1) << "; ";
-              valStr << mVal(rows(mVal), 1);
+              for (unsigned i = 0; i < rows(mVal) - 1; ++i)
+                valStr << mVal(i, 0) << "; ";
+              valStr << mVal(rows(mVal) - 1, 0);
+
+              indent() << "<property name=\"" << it->getName()
+                       << "\" type=\"matrix\">"
+                       << valStr.str()
+                       << "</property>\n";
             } else {
               valStr << '\n';
-              for (unsigned i = 1; i < rows(mVal); ++i) {
+              for (unsigned i = 0; i < rows(mVal); ++i) {
                 // Indent too??
                 valStr << std::setw((mIndent+1)*mIndentWidth) << ' ';
-                valStr << mVal(cols(mVal), i) << '\n';
-                for (unsigned j = 1; j < cols(mVal); ++j)
-                  valStr << mVal(i, 1) << ' ';
-                valStr << mVal(cols(mVal), i) << '\n';
+                for (unsigned j = 0; j < cols(mVal) - 1; ++j)
+                  valStr << mVal(i, j) << ' ';
+                valStr << mVal(i, cols(mVal) - 1) << '\n';
               }
+              indent() << "<property name=\"" << it->getName()
+                       << "\" type=\"matrix\">"
+                       << valStr.str();
+              indent() << "</property>\n";
             }
-            indent() << "<property name=\"" << it->getName()
-                     << "\" type=\"matrix\">"
-                     << valStr.str()
-                     << "</property>\n";
           }
         } else if (value.isString()) {
           std::string stringValue = value.toString();



From frohlich at mail.berlios.de  Sat Aug  1 20:20:09 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 1 Aug 2009 20:20:09 +0200
Subject: [OpenFDM-svn] r1048 - branches/OpenFDM-StateSeparation/src/JSBSim
Message-ID: <200908011820.n71IK9Ix006705@sheep.berlios.de>

Author: frohlich
Date: 2009-08-01 20:20:09 +0200 (Sat, 01 Aug 2009)
New Revision: 1048

Modified:
   branches/OpenFDM-StateSeparation/src/JSBSim/jsb2openfdm.cpp
Log:
Dump cpmplete xml files.

M    JSBSim/jsb2openfdm.cpp


Modified: branches/OpenFDM-StateSeparation/src/JSBSim/jsb2openfdm.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/jsb2openfdm.cpp	2009-08-01 18:19:48 UTC (rev 1047)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/jsb2openfdm.cpp	2009-08-01 18:20:09 UTC (rev 1048)
@@ -41,7 +41,7 @@
   // When the reflection stuff is ready, we can dump that data to a
   // native format ...
   OpenFDM::XMLDumpModelVisitor debugDumpVisitor(std::cout);
-  system->getNode()->accept(debugDumpVisitor);
+  debugDumpVisitor.apply(*system);
 
   return 0;
 }



From frohlich at mail.berlios.de  Mon Aug  3 18:18:54 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Mon, 3 Aug 2009 18:18:54 +0200
Subject: [OpenFDM-svn] r1049 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200908031618.n73GIs0D023792@sheep.berlios.de>

Author: frohlich
Date: 2009-08-03 18:18:53 +0200 (Mon, 03 Aug 2009)
New Revision: 1049

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.h
Log:
Add a default delay argument to the constructor.

M    Delay.h
M    Delay.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.cpp	2009-08-01 18:20:09 UTC (rev 1048)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.cpp	2009-08-03 16:18:53 UTC (rev 1049)
@@ -18,7 +18,7 @@
   DEF_OPENFDM_PROPERTY(Unsigned, Delay, Serialized)
   END_OPENFDM_OBJECT_DEF
 
-Delay::Delay(const std::string& name) :
+Delay::Delay(const std::string& name, unsigned delay) :
   Model(name),
   mInputPort(newMatrixInputPort("input", true)),
   mOutputPort(newMatrixOutputPort("output")),
@@ -27,6 +27,8 @@
 {
   mMatrixStateInfo = new MatrixListStateInfo;
   addDiscreteStateInfo(mMatrixStateInfo);
+
+  setDelay(delay);
 }
 
 Delay::~Delay()

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.h	2009-08-01 18:20:09 UTC (rev 1048)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Delay.h	2009-08-03 16:18:53 UTC (rev 1049)
@@ -15,7 +15,7 @@
 class Delay : public Model {
   OPENFDM_OBJECT(Delay, Model);
 public:
-  Delay(const std::string& name);
+  Delay(const std::string& name, unsigned delay = 0);
   virtual ~Delay();
 
   virtual bool alloc(ModelContext&) const;



From frohlich at mail.berlios.de  Mon Aug  3 18:19:49 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Mon, 3 Aug 2009 18:19:49 +0200
Subject: [OpenFDM-svn] r1050 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200908031619.n73GJnQS024029@sheep.berlios.de>

Author: frohlich
Date: 2009-08-03 18:19:40 +0200 (Mon, 03 Aug 2009)
New Revision: 1050

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/XMLDumpModelVisitor.h
Log:
Make sure we dump the correct class names.

M    XMLDumpModelVisitor.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/XMLDumpModelVisitor.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/XMLDumpModelVisitor.h	2009-08-03 16:18:53 UTC (rev 1049)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/XMLDumpModelVisitor.h	2009-08-03 16:19:40 UTC (rev 1050)
@@ -39,7 +39,7 @@
   }
   virtual void apply(Group& group)
   {
-    indent() << "<node type=\"NodeGroup\">\n";
+    indent() << "<node type=\"" << group.getTypeName() << "\">\n";
     ++mIndent;
     dumpProperties(group);
     group.traverse(*this);



From frohlich at mail.berlios.de  Mon Aug  3 18:21:09 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Mon, 3 Aug 2009 18:21:09 +0200
Subject: [OpenFDM-svn] r1051 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200908031621.n73GL9q5024438@sheep.berlios.de>

Author: frohlich
Date: 2009-08-03 18:21:08 +0200 (Mon, 03 Aug 2009)
New Revision: 1051

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/MatrixConcat.cpp
Log:
Add the ConcatDimension to the properties.

M    MatrixConcat.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MatrixConcat.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MatrixConcat.cpp	2009-08-03 16:19:40 UTC (rev 1050)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MatrixConcat.cpp	2009-08-03 16:21:08 UTC (rev 1051)
@@ -9,6 +9,7 @@
 namespace OpenFDM {
 
 BEGIN_OPENFDM_OBJECT_DEF(MatrixConcat, AbstractModel)
+  DEF_OPENFDM_PROPERTY(Unsigned, ConcatDimension, Serialized)
   END_OPENFDM_OBJECT_DEF
 
 MatrixConcat::Context::Context(const MatrixConcat* matrixConcat,



From frohlich at mail.berlios.de  Mon Aug  3 18:21:53 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Mon, 3 Aug 2009 18:21:53 +0200
Subject: [OpenFDM-svn] r1052 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200908031621.n73GLrH2024614@sheep.berlios.de>

Author: frohlich
Date: 2009-08-03 18:21:52 +0200 (Mon, 03 Aug 2009)
New Revision: 1052

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/MatrixSplit.cpp
Log:
Add the SplitDimension to the properties list.

M    MatrixSplit.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MatrixSplit.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MatrixSplit.cpp	2009-08-03 16:21:08 UTC (rev 1051)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MatrixSplit.cpp	2009-08-03 16:21:52 UTC (rev 1052)
@@ -9,6 +9,7 @@
 namespace OpenFDM {
 
 BEGIN_OPENFDM_OBJECT_DEF(MatrixSplit, AbstractModel)
+  DEF_OPENFDM_PROPERTY(Unsigned, SplitDimension, Serialized)
   END_OPENFDM_OBJECT_DEF
 
 MatrixSplit::Context::Context(const MatrixSplit* matrixSplit,



From frohlich at mail.berlios.de  Mon Aug  3 18:22:39 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Mon, 3 Aug 2009 18:22:39 +0200
Subject: [OpenFDM-svn] r1053 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200908031622.n73GMdVP024795@sheep.berlios.de>

Author: frohlich
Date: 2009-08-03 18:22:38 +0200 (Mon, 03 Aug 2009)
New Revision: 1053

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/DiscreteIntegrator.cpp
Log:
Add EnableInitialValuePort to the list of properties.

M    DiscreteIntegrator.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/DiscreteIntegrator.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/DiscreteIntegrator.cpp	2009-08-03 16:21:52 UTC (rev 1052)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/DiscreteIntegrator.cpp	2009-08-03 16:22:38 UTC (rev 1053)
@@ -13,6 +13,7 @@
 namespace OpenFDM {
 
 BEGIN_OPENFDM_OBJECT_DEF(DiscreteIntegrator, Model)
+  DEF_OPENFDM_PROPERTY(Bool, EnableInitialValuePort, Serialized)
   DEF_OPENFDM_PROPERTY(Matrix, InitialValue, Serialized)
   DEF_OPENFDM_PROPERTY(Matrix, MinSaturation, Serialized)
   DEF_OPENFDM_PROPERTY(Matrix, MaxSaturation, Serialized)



From frohlich at mail.berlios.de  Mon Aug  3 18:25:15 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Mon, 3 Aug 2009 18:25:15 +0200
Subject: [OpenFDM-svn] r1054 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200908031625.n73GPF4p025439@sheep.berlios.de>

Author: frohlich
Date: 2009-08-03 18:25:13 +0200 (Mon, 03 Aug 2009)
New Revision: 1054

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Connect.cpp
Log:
Be more verbose when connects fail.

M    Connect.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Connect.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Connect.cpp	2009-08-03 16:22:38 UTC (rev 1053)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Connect.cpp	2009-08-03 16:25:13 UTC (rev 1054)
@@ -4,6 +4,7 @@
 
 #include "Connect.h"
 #include "Group.h"
+#include "LogStream.h"
 
 namespace OpenFDM {
 
@@ -32,8 +33,10 @@
 Connect::setPort0(const Port* portInfo0)
 {
   SharedPtr<const Port> portInfo1 = mPort1.lock();
-  if (!isCompatible(portInfo0, portInfo1))
+  if (!isCompatible(portInfo0, portInfo1)) {
+    Log(Model, Warning) << "Trying to connect incompatible ports" << std::endl;
     return false;
+  }
   mPort0 = portInfo0;
   return true;
 }
@@ -48,8 +51,10 @@
 Connect::setPort1(const Port* portInfo1)
 {
   SharedPtr<const Port> portInfo0 = mPort0.lock();
-  if (!isCompatible(portInfo0, portInfo1))
+  if (!isCompatible(portInfo0, portInfo1)) {
+    Log(Model, Warning) << "Trying to connect incompatible ports" << std::endl;
     return false;
+  }
   mPort1 = portInfo1;
   return true;
 }
@@ -61,10 +66,14 @@
     return true;
   if (!portInfo1)
     return true;
-  if (!isInGroup(*portInfo0))
+  if (!isInGroup(*portInfo0)) {
+    Log(Model, Warning) << "Port is in different group than model" << std::endl;
     return false;
-  if (!isInGroup(*portInfo1))
+  }
+  if (!isInGroup(*portInfo1)) {
+    Log(Model, Warning) << "Port is in different group than model" << std::endl;
     return false;
+  }
   // Just a crude first time check if this will work in principle.
   return portInfo0->canConnect(*portInfo1);
 }



From frohlich at mail.berlios.de  Mon Aug  3 18:26:09 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Mon, 3 Aug 2009 18:26:09 +0200
Subject: [OpenFDM-svn] r1055 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200908031626.n73GQ9Pg025788@sheep.berlios.de>

Author: frohlich
Date: 2009-08-03 18:26:08 +0200 (Mon, 03 Aug 2009)
New Revision: 1055

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/GroupInterfaceNode.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/GroupInterfaceNode.h
Log:
Avoid crashes if called in the wrong order.

M    GroupInterfaceNode.h
M    GroupInterfaceNode.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/GroupInterfaceNode.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/GroupInterfaceNode.cpp	2009-08-03 16:25:13 UTC (rev 1054)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/GroupInterfaceNode.cpp	2009-08-03 16:26:08 UTC (rev 1055)
@@ -40,18 +40,33 @@
 unsigned
 GroupInterfaceNode::getExternalPortIndex() const
 {
+  if (!mExternalPort) {
+    Log(Model, Warning) << "Get ExternalPortIndex failed for \"" << getName()
+                        << "\"." << std::endl;
+    return ~0u;
+  }
   return mExternalPort->getIndex();
 }
 
 void
 GroupInterfaceNode::setExternalPortName(const std::string& portName)
 {
+  if (!mExternalPort) {
+    Log(Model, Warning) << "setExternalPortName failed for \"" << getName()
+                        << "\"." << std::endl;
+    return;
+  }
   mExternalPort->setName(portName);
 }
 
-const std::string&
+std::string
 GroupInterfaceNode::getExternalPortName() const
 {
+  if (!mExternalPort) {
+    Log(Model, Warning) << "getExternalPortName failed for \"" << getName()
+                        << "\"." << std::endl;
+    return std::string();
+  }
   return mExternalPort->getName();
 }
 

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/GroupInterfaceNode.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/GroupInterfaceNode.h	2009-08-03 16:25:13 UTC (rev 1054)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/GroupInterfaceNode.h	2009-08-03 16:26:08 UTC (rev 1055)
@@ -29,7 +29,7 @@
   unsigned getExternalPortIndex() const;
 
   void setExternalPortName(const std::string& portName);
-  const std::string& getExternalPortName() const;
+  std::string getExternalPortName() const;
 
 protected:
   virtual bool addParent(Node* parent);



From frohlich at mail.berlios.de  Mon Aug  3 18:26:59 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Mon, 3 Aug 2009 18:26:59 +0200
Subject: [OpenFDM-svn] r1056 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200908031626.n73GQxto026039@sheep.berlios.de>

Author: frohlich
Date: 2009-08-03 18:26:58 +0200 (Mon, 03 Aug 2009)
New Revision: 1056

Added:
   branches/OpenFDM-StateSeparation/src/test/mechanicstructure.cpp
Modified:
   branches/OpenFDM-StateSeparation/src/test/Makefile.am
Log:
Add a new test for the topology of a mechanic system.

M    test/Makefile.am
AM   test/mechanicstructure.cpp


Modified: branches/OpenFDM-StateSeparation/src/test/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/Makefile.am	2009-08-03 16:26:08 UTC (rev 1055)
+++ branches/OpenFDM-StateSeparation/src/test/Makefile.am	2009-08-03 16:26:58 UTC (rev 1056)
@@ -7,6 +7,7 @@
 	limit \
 	linalg \
 	quattest \
+	mechanicstructure \
 	simulationtime \
 	structure \
 	unitstest
@@ -18,6 +19,7 @@
 	foucault \
 	inertianav \
 	mechanic \
+	mechanicstructure \
 	structure \
 	tiretestrig \
 	coordsys \
@@ -53,6 +55,9 @@
 mechanic_SOURCES = mechanic.cpp
 mechanic_LDADD = ../OpenFDM/libOpenFDM.la
 
+mechanicstructure_SOURCES = mechanicstructure.cpp
+mechanicstructure_LDADD = ../OpenFDM/libOpenFDM.la
+
 quattest_SOURCES = quattest.cpp
 quattest_LDADD = ../OpenFDM/libOpenFDM.la
 

Added: branches/OpenFDM-StateSeparation/src/test/mechanicstructure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/mechanicstructure.cpp	2009-08-03 16:26:08 UTC (rev 1055)
+++ branches/OpenFDM-StateSeparation/src/test/mechanicstructure.cpp	2009-08-03 16:26:58 UTC (rev 1056)
@@ -0,0 +1,142 @@
+#include <OpenFDM/Group.h>
+#include <OpenFDM/Mass.h>
+#include <OpenFDM/MobileRootJoint.h>
+#include <OpenFDM/PrismaticJoint.h>
+#include <OpenFDM/RevoluteJoint.h>
+#include <OpenFDM/RigidBody.h>
+#include <OpenFDM/System.h>
+
+using namespace OpenFDM;
+
+void addBodiesRecursive(unsigned numLevels, unsigned numBodies,
+                        RigidBody* rigidBody, Group* group)
+{
+  if (!numLevels)
+    return;
+
+  for (unsigned i = 0; i < numBodies; ++i) {
+    RevoluteJoint* revoluteJoint = new RevoluteJoint("RevoluteJoint");
+    group->addChild(revoluteJoint);
+    group->connect(revoluteJoint->getPort("link0"),
+                   rigidBody->addLink("childLink"));
+    
+    RigidBody* rigidBody2 = new RigidBody("RigidBody");
+    group->addChild(rigidBody2);
+    group->connect(revoluteJoint->getPort("link1"),
+                   rigidBody2->addLink("parentLink"));
+    
+    Mass* mass = new Mass("Mass", 1, InertiaMatrix(1, 0, 0, 1, 0, 1));
+    group->addChild(mass);
+    group->connect(mass->getPort("link"), rigidBody2->addLink("massLink"));
+    
+    addBodiesRecursive(numLevels - 1, numBodies, rigidBody2, group);
+  }
+}
+
+bool testBodyTreeModel1(unsigned numLevels, unsigned numBodies)
+{
+  SharedPtr<Group> group = new Group("Group");
+
+  MobileRootJoint* mechanicRootJoint = new MobileRootJoint("RootJoint");
+  group->addChild(mechanicRootJoint);
+
+  RigidBody* rigidBody = new RigidBody("RigidBody");
+  group->addChild(rigidBody);
+  group->connect(mechanicRootJoint->getPort("link"),
+                 rigidBody->addLink("rootLink"));
+  
+  Mass* mass = new Mass("Mass", 1, InertiaMatrix(1, 0, 0, 1, 0, 1));
+  group->addChild(mass);
+  group->connect(mass->getPort("link"), rigidBody->addLink("massLink"));
+
+  addBodiesRecursive(numLevels, numBodies, rigidBody, group);
+
+  SharedPtr<System> system = new System("Closed kinematic Loop 1");
+  system->setNode(group);
+
+  if (!system->init()) {
+    std::cerr << "Initialization of single body model failed!" << std::endl;
+    return false;
+  }
+  return true;
+}
+
+
+bool testClosedKinematicLoop1()
+{
+  SharedPtr<Group> group = new Group("Group");
+
+  MobileRootJoint* mechanicRootJoint = new MobileRootJoint("RootJoint");
+  group->addChild(mechanicRootJoint);
+
+  PrismaticJoint* prismaticJoint = new PrismaticJoint("PrismaticJoint");
+  group->addChild(prismaticJoint);
+  group->connect(mechanicRootJoint->getPort("link"),
+                 prismaticJoint->getPort("link0"));
+  group->connect(mechanicRootJoint->getPort("link"),
+                 prismaticJoint->getPort("link1"));
+
+  SharedPtr<System> system = new System("Closed kinematic Loop 1");
+  system->setNode(group);
+
+  if (system->init()) {
+    std::cerr << "Detection of klosed kinematic loop failed!" << std::endl;
+    return false;
+  }
+  return true;
+}
+
+bool testClosedKinematicLoop2()
+{
+  SharedPtr<Group> group = new Group("Group");
+
+  MobileRootJoint* mechanicRootJoint = new MobileRootJoint("RootJoint");
+  group->addChild(mechanicRootJoint);
+
+  RigidBody* rigidBody = new RigidBody("RigidBody");
+  group->addChild(rigidBody);
+  group->connect(mechanicRootJoint->getPort("link"),
+                 rigidBody->addLink("rootLink"));
+
+  PrismaticJoint* prismaticJoint = new PrismaticJoint("PrismaticJoint");
+  group->addChild(prismaticJoint);
+  group->connect(rigidBody->addLink("jointLink0"),
+                 prismaticJoint->getPort("link0"));
+  group->connect(rigidBody->addLink("jointLink1"),
+                 prismaticJoint->getPort("link1"));
+
+  SharedPtr<System> system = new System("Closed kinematic Loop 1");
+  system->setNode(group);
+
+  if (system->init()) {
+    std::cerr << "Detection of klosed kinematic loop failed!" << std::endl;
+    return false;
+  }
+  return true;
+}
+
+int main()
+{
+  // Test a single body mass model
+  if (!testBodyTreeModel1(0, 1))
+    return EXIT_FAILURE;
+
+  // Tests with multiple linear (numBodies = 1) and
+  // tree (1 < numBodies) chained bodies
+  for (unsigned numBodies = 1; numBodies < 4; ++numBodies) {
+    for (unsigned numLevels = 1; numLevels < 4; ++numLevels) {
+      if (!testBodyTreeModel1(numLevels, numBodies))
+        return EXIT_FAILURE;
+    }
+  }
+
+  // Some simple explicit kinematic loops
+  if (!testClosedKinematicLoop1())
+    return EXIT_FAILURE;
+  if (!testClosedKinematicLoop2())
+    return EXIT_FAILURE;
+
+  std::cout << "PASSED" << std::endl;
+
+  return EXIT_SUCCESS;
+}


Property changes on: branches/OpenFDM-StateSeparation/src/test/mechanicstructure.cpp
___________________________________________________________________
Name: svn:eol-style
   + native



From frohlich at mail.berlios.de  Mon Aug  3 18:27:42 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Mon, 3 Aug 2009 18:27:42 +0200
Subject: [OpenFDM-svn] r1057 - branches/OpenFDM-StateSeparation/src/JSBSim
Message-ID: <200908031627.n73GRgQw026269@sheep.berlios.de>

Author: frohlich
Date: 2009-08-03 18:27:40 +0200 (Mon, 03 Aug 2009)
New Revision: 1057

Modified:
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimAerodynamic.cpp
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimAerosurfaceScale.cpp
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimFCSComponent.cpp
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimKinemat.cpp
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.h
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.cpp
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimScheduledGain.cpp
   branches/OpenFDM-StateSeparation/src/JSBSim/jsb2openfdm.cpp
Log:
Unsorted fixes.

M    JSBSim/JSBSimKinemat.cpp
M    JSBSim/JSBSimAerodynamic.cpp
M    JSBSim/JSBSimReaderBase.cpp
M    JSBSim/JSBSimFCSComponent.cpp
M    JSBSim/JSBSimScheduledGain.cpp
M    JSBSim/jsb2openfdm.cpp
M    JSBSim/JSBSimReader.cpp
M    JSBSim/JSBSimReader.h
M    JSBSim/JSBSimAerosurfaceScale.cpp


Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimAerodynamic.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimAerodynamic.cpp	2009-08-03 16:26:58 UTC (rev 1056)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimAerodynamic.cpp	2009-08-03 16:27:40 UTC (rev 1057)
@@ -20,6 +20,7 @@
   mGroup->addChild(mWingAreaModel);
   mWingAreaOutputModel = new GroupOutput("Wing Area Output");
   mGroup->addChild(mWingAreaOutputModel);
+  mWingAreaOutputModel->setExternalPortName("wingArea");
   mGroup->connect(mWingAreaModel->getPort("output"),
                   mWingAreaOutputModel->getPort("input"));
 
@@ -27,6 +28,7 @@
   mGroup->addChild(mWingSpanModel);
   mWingSpanOutputModel = new GroupOutput("Wing Span Output");
   mGroup->addChild(mWingSpanOutputModel);
+  mWingSpanOutputModel->setExternalPortName("wingSpan");
   mGroup->connect(mWingSpanModel->getPort("output"),
                   mWingSpanOutputModel->getPort("input"));
 
@@ -34,6 +36,7 @@
   mGroup->addChild(mChordModel);
   mChordOutputModel = new GroupOutput("Chord Output");
   mGroup->addChild(mChordOutputModel);
+  mChordOutputModel->setExternalPortName("chord");
   mGroup->connect(mChordModel->getPort("output"),
                   mChordOutputModel->getPort("input"));
 
@@ -41,6 +44,7 @@
   mGroup->addChild(mWingIncidenceModel);
   mWingIncidenceOutputModel = new GroupOutput("Wing Incidence Output");
   mGroup->addChild(mWingIncidenceOutputModel);
+  mWingIncidenceOutputModel->setExternalPortName("wingIncidence");
   mGroup->connect(mWingIncidenceModel->getPort("output"),
                   mWingIncidenceOutputModel->getPort("input"));
 
@@ -48,6 +52,7 @@
   mGroup->addChild(mHTailAreaModel);
   mHTailAreaOutputModel = new GroupOutput("HTailArea Output");
   mGroup->addChild(mHTailAreaOutputModel);
+  mHTailAreaOutputModel->setExternalPortName("hTailArea");
   mGroup->connect(mHTailAreaModel->getPort("output"),
                   mHTailAreaOutputModel->getPort("input"));
 
@@ -55,6 +60,7 @@
   mGroup->addChild(mHTailArmModel);
   mHTailArmOutputModel = new GroupOutput("HTailArm Output");
   mGroup->addChild(mHTailArmOutputModel);
+  mHTailArmOutputModel->setExternalPortName("hTailArm");
   mGroup->connect(mHTailArmModel->getPort("output"),
                   mHTailArmOutputModel->getPort("input"));
 
@@ -63,6 +69,7 @@
   mGroup->addChild(mVTailAreaModel);
   mVTailAreaOutputModel = new GroupOutput("VTailArea Output");
   mGroup->addChild(mVTailAreaOutputModel);
+  mVTailAreaOutputModel->setExternalPortName("vTailArea");
   mGroup->connect(mVTailAreaModel->getPort("output"),
                   mVTailAreaOutputModel->getPort("input"));
 
@@ -70,6 +77,7 @@
   mGroup->addChild(mVTailArmModel);
   mVTailArmOutputModel = new GroupOutput("VTailArm Output");
   mGroup->addChild(mVTailArmOutputModel);
+  mVTailArmOutputModel->setExternalPortName("vTailArm");
   mGroup->connect(mVTailArmModel->getPort("output"),
                   mVTailArmOutputModel->getPort("input"));
 
@@ -87,7 +95,7 @@
   mExternalInteract->setEnableStaticPressure(true);
   mExternalInteract->setEnableTemperature(true);
   mExternalInteract->setEnableSoundSpeed(true);
-  mExternalInteract->setEnableAltitude(true);
+  mExternalInteract->setEnableBodyForce(true);
 
   DynamicPressure* dynamicPressure = new DynamicPressure("DynamicPressure");
   mGroup->addChild(dynamicPressure);
@@ -121,43 +129,50 @@
   mGroup->connect(windAxis->getPort("beta"),
                   windAxisForce->getPort("beta"));
 
-  mGroup->connect(windAxis->getPort("bodyForce"),
+  mGroup->connect(windAxisForce->getPort("bodyForce"),
                   mExternalInteract->getPort("bodyForce"));
 
 
   mAlphaOutputModel = new GroupOutput("Alpha Output");
   mGroup->addChild(mAlphaOutputModel);
+  mAlphaOutputModel->setExternalPortName("alpha");
   mGroup->connect(windAxis->getPort("alpha"),
                   mAlphaOutputModel->getPort("input"));
 
   mAlphaDotOutputModel = new GroupOutput("AlphaDot Output");
   mGroup->addChild(mAlphaDotOutputModel);
+  mAlphaDotOutputModel->setExternalPortName("alphaDot");
   mGroup->connect(windAxis->getPort("alphaDot"),
                   mAlphaDotOutputModel->getPort("input"));
 
   mBetaOutputModel = new GroupOutput("Beta Output");
   mGroup->addChild(mBetaOutputModel);
+  mBetaOutputModel->setExternalPortName("beta");
   mGroup->connect(windAxis->getPort("beta"),
                   mBetaOutputModel->getPort("input"));
 
   mBetaDotOutputModel = new GroupOutput("BetaDot Output");
   mGroup->addChild(mBetaDotOutputModel);
+  mBetaDotOutputModel->setExternalPortName("betaDot");
   mGroup->connect(windAxis->getPort("betaDot"),
                   mBetaDotOutputModel->getPort("input"));
 
   mTrueAirSpeedOutputModel = new GroupOutput("True Air Speed Output");
   mGroup->addChild(mTrueAirSpeedOutputModel);
+  mTrueAirSpeedOutputModel->setExternalPortName("airSpeed");
   mGroup->connect(windAxis->getPort("airSpeed"),
                   mTrueAirSpeedOutputModel->getPort("input"));
 
   mCalibratedAirSpeedOutputModel = new GroupOutput("Calibrated Air Speed Output");
   mGroup->addChild(mCalibratedAirSpeedOutputModel);
+  mCalibratedAirSpeedOutputModel->setExternalPortName("calibratedAirSpeed");
   /// FIXME wrong
   mGroup->connect(windAxis->getPort("airSpeed"),
                   mCalibratedAirSpeedOutputModel->getPort("input"));
 
   mEquivalentAirSpeedOutputModel = new GroupOutput("Equivalent Air Speed Output");
   mGroup->addChild(mEquivalentAirSpeedOutputModel);
+  mEquivalentAirSpeedOutputModel->setExternalPortName("equivalentAirSpeed");
   /// FIXME wrong
   mGroup->connect(windAxis->getPort("airSpeed"),
                   mEquivalentAirSpeedOutputModel->getPort("input"));
@@ -165,26 +180,32 @@
 
   mMachOutputModel = new GroupOutput("Mach Output");
   mGroup->addChild(mMachOutputModel);
-  mGroup->connect(machNumber->getPort("mach"),
+  mMachOutputModel->setExternalPortName("machNumber");
+  mGroup->connect(machNumber->getPort("machNumber"),
                   mMachOutputModel->getPort("input"));
 
   mDynamicPressureOutputModel = new GroupOutput("Dynamic Pressure Output");
   mGroup->addChild(mDynamicPressureOutputModel);
+  mDynamicPressureOutputModel->setExternalPortName("dynamicPressure");
   mGroup->connect(dynamicPressure->getPort("dynamicPressure"),
                   mDynamicPressureOutputModel->getPort("input"));
 
   mStaticPressureOutputModel = new GroupOutput("Static Pressure Output");
   mGroup->addChild(mStaticPressureOutputModel);
+  mStaticPressureOutputModel->setExternalPortName("staticPressure");
   mGroup->connect(mExternalInteract->getPort("staticPressure"),
                   mStaticPressureOutputModel->getPort("input"));
 
   mTemperatureOutputModel = new GroupOutput("Temperature Output");
   mGroup->addChild(mTemperatureOutputModel);
+  mTemperatureOutputModel->setExternalPortName("temperature");
   mGroup->connect(mExternalInteract->getPort("temperature"),
                   mTemperatureOutputModel->getPort("input"));
 
   
   MatrixSplit* linearVel = new MatrixSplit("Linear Velocity Split");
+  mGroup->addChild(linearVel);
+  mExternalInteract->setEnableBodyWindVelocity(true);
   mGroup->connect(mExternalInteract->getPort("bodyWindVelocity"),
                   linearVel->getPort("input"));
   linearVel->addOutputPort("u");
@@ -193,18 +214,23 @@
 
   mUOutputModel = new GroupOutput("U Output");
   mGroup->addChild(mUOutputModel);
+  mUOutputModel->setExternalPortName("u");
   mGroup->connect(linearVel->getPort("u"),
                   mUOutputModel->getPort("input"));
   mVOutputModel = new GroupOutput("V Output");
   mGroup->addChild(mVOutputModel);
+  mVOutputModel->setExternalPortName("v");
   mGroup->connect(linearVel->getPort("v"),
                   mVOutputModel->getPort("input"));
   mWOutputModel = new GroupOutput("W Output");
   mGroup->addChild(mWOutputModel);
+  mWOutputModel->setExternalPortName("w");
   mGroup->connect(linearVel->getPort("w"),
                   mWOutputModel->getPort("input"));
 
   MatrixSplit* angularVel = new MatrixSplit("Angular Velocity Split");
+  mGroup->addChild(angularVel);
+  mExternalInteract->setEnableBodyAngularVelocity(true);
   /// FIXME make wind angular velocity sensable
   mGroup->connect(mExternalInteract->getPort("bodyAngularVelocity"),
                   angularVel->getPort("input"));
@@ -214,14 +240,17 @@
 
   mPOutputModel = new GroupOutput("P Output");
   mGroup->addChild(mPOutputModel);
+  mPOutputModel->setExternalPortName("p");
   mGroup->connect(angularVel->getPort("p"),
                   mPOutputModel->getPort("input"));
   mQOutputModel = new GroupOutput("Q Output");
   mGroup->addChild(mQOutputModel);
+  mQOutputModel->setExternalPortName("q");
   mGroup->connect(angularVel->getPort("q"),
                   mQOutputModel->getPort("input"));
   mROutputModel = new GroupOutput("R Output");
   mGroup->addChild(mROutputModel);
+  mROutputModel->setExternalPortName("r");
   mGroup->connect(angularVel->getPort("r"),
                   mROutputModel->getPort("input"));
 
@@ -245,6 +274,7 @@
 
   mWingSpanOver2SpeedOutputModel = new GroupOutput("WingSpanOver2Speed Output");
   mGroup->addChild(mWingSpanOver2SpeedOutputModel);
+  mWingSpanOver2SpeedOutputModel->setExternalPortName("wingSpanOver2Speed");
   mGroup->connect(wingSpanOver2Speed->getPort("output"),
                   mWingSpanOver2SpeedOutputModel->getPort("input"));
 
@@ -258,6 +288,7 @@
 
   mChordOver2SpeedOutputModel = new GroupOutput("ChordOver2Speed Output");
   mGroup->addChild(mChordOver2SpeedOutputModel);
+  mChordOver2SpeedOutputModel->setExternalPortName("chordOver2Speed");
   mGroup->connect(chordOver2Speed->getPort("output"),
                   mChordOver2SpeedOutputModel->getPort("input"));
 
@@ -272,13 +303,16 @@
   mGroup->connect(recWingSpan->getPort("output"),
                   hOverWingSpan->getPort("input0"));
   // FIXME??
+//   mExternalInteract->setEnableAltitude(true);
 //   mGroup->connect(mExternalInteract->getPort("altitude"),
 //                   hOverWingSpan->getPort("input1"));
+  mExternalInteract->setEnableAboveGroundLevel(true);
   mGroup->connect(mExternalInteract->getPort("aboveGroundLevel"),
                   hOverWingSpan->getPort("input1"));
 
   mHOverWingSpanOutputModel = new GroupOutput("HOverWingSpan Output");
   mGroup->addChild(mHOverWingSpanOutputModel);
+  mHOverWingSpanOutputModel->setExternalPortName("hOverWingSpan");
   mGroup->connect(hOverWingSpan->getPort("output"),
                   mHOverWingSpanOutputModel->getPort("input"));
 
@@ -319,6 +353,7 @@
   mGroup->connect(mYawInputModel->getPort("output"),
                   torque->addInputPort("z"));
 
+  mExternalInteract->setEnableBodyTorque(true);
   mGroup->connect(torque->getPort("output"),
                   mExternalInteract->getPort("bodyTorque"));
 }

Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimAerosurfaceScale.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimAerosurfaceScale.cpp	2009-08-03 16:26:58 UTC (rev 1056)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimAerosurfaceScale.cpp	2009-08-03 16:27:40 UTC (rev 1057)
@@ -37,7 +37,7 @@
   tl.insert(1);
   mBreakPointLookup->setBreakPointVector(tl);
   getGroup()->addChild(mBreakPointLookup);
-  getGroup()->connect(mBreakPointLookup->getPort("input"),
+  getGroup()->connect(mBreakPointLookup->getInputPort(0),
                       mInputSaturation->getPort("output"));
 
   mTable = new Table1D("Table");
@@ -53,7 +53,7 @@
   tableData(iv) = mGain;
   mTable->setTableData(tableData);
   getGroup()->addChild(mTable);
-  getGroup()->connect(mTable->getPort("input"),
+  getGroup()->connect(mTable->getInputPort(0),
                       mBreakPointLookup->getPort("output"));
 
   // Now connect the input and the output to this groups in and outputs

Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimFCSComponent.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimFCSComponent.cpp	2009-08-03 16:26:58 UTC (rev 1056)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimFCSComponent.cpp	2009-08-03 16:27:40 UTC (rev 1057)
@@ -53,6 +53,7 @@
 
   mOutputModel = new GroupOutput("Output");
   getGroup()->addChild(mOutputModel);
+  mOutputModel->setExternalPortName("output");
   return mOutputModel;
 }
 
@@ -64,6 +65,7 @@
 
   mOutputNormModel = new GroupOutput("OutputNorm");
   getGroup()->addChild(mOutputNormModel);
+  mOutputNormModel->setExternalPortName("outputNorm");
   return mOutputNormModel;
 }
 

Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimKinemat.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimKinemat.cpp	2009-08-03 16:26:58 UTC (rev 1056)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimKinemat.cpp	2009-08-03 16:27:40 UTC (rev 1057)
@@ -27,10 +27,10 @@
   //  -------------------------------
   //  |
   //  o-|BreakPointVector|-o-|Minus|-| FIXME: that table lookup is still missing
-  //  |               |         |
-  //  +-|ErrorGain|--|Min|----|Max|-|Integrator|-o-|Outgain|-
-  //  |                                          |
-  //  -----------|FeedbackGain|-------------------
+  //  |                    |         |
+  //  +-|ErrorGain|-------|Min|----|Max|-|Integrator|-o-|Outgain|-
+  //  |                                               |
+  //  -----------|FeedbackGain|------------------------
   //
   // FIXME: simplify
   // FIXME: implement tables
@@ -66,9 +66,8 @@
   getGroup()->addChild(integrator);
   getGroup()->connect(integrator->getPort("input"),
                       mKinematRateLimit->getPort("output"));
-  Matrix tmp(1, 1);
-  tmp(0, 0) = 1;
-  integrator->setInitialValue(tmp);
+
+  integrator->setEnableInitialValuePort(true);
   getGroup()->connect(integrator->getPort("initialValue"),
                       mInputSaturation->getPort("output"));
   

Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp	2009-08-03 16:26:58 UTC (rev 1056)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp	2009-08-03 16:27:40 UTC (rev 1057)
@@ -17,6 +17,7 @@
 #include <OpenFDM/Bias.h>
 #include <OpenFDM/ConstModel.h>
 #include <OpenFDM/DeadBand.h>
+#include <OpenFDM/Delay.h>
 #include <OpenFDM/DiscreteIntegrator.h>
 #include <OpenFDM/TransferFunction.h>
 #include <OpenFDM/Gain.h>
@@ -24,6 +25,7 @@
 #include <OpenFDM/Mass.h>
 #include <OpenFDM/MaxModel.h>
 #include <OpenFDM/MatrixSplit.h>
+#include <OpenFDM/MobileRootJoint.h>
 #include <OpenFDM/AirSpring.h>
 #include <OpenFDM/InternalInteract.h>
 #include <OpenFDM/PrismaticJoint.h>
@@ -279,6 +281,11 @@
   mTopLevelGroup->connect(mTopLevelBody->addLink("aerodynamicLink"),
                           mAeroForce->getMechanicLink());
 
+  MobileRootJoint* mobileRootJoint = new MobileRootJoint("Root Joint");
+  mTopLevelGroup->addChild(mobileRootJoint);
+  mTopLevelGroup->connect(mTopLevelBody->addLink("rootJointLink"),
+                          mobileRootJoint->getPort("link"));
+
   // Default discrete stepsize of JSBSim
   mTopLevelGroup->setSampleTime(SampleTime(1.0/120));
 
@@ -440,7 +447,11 @@
                           load->getPort("input"));
   load->addOutputPort("x");
   load->addOutputPort("y");
-  const Port* port = load->addOutputPort("z");
+  load->addOutputPort("z");
+  Delay* delay = new Delay("Normalized Load Delay", 1);
+  mTopLevelGroup->addChild(delay);
+  mTopLevelGroup->connect(load->getPort("z"), delay->getPort("input"));
+  const Port* port = delay->getPort("output");
   registerJSBExpression("accelerations/n-pilot-z-norm", port);
   addOutputModel(port, "Normalized load value", "accelerations/nlf");
 
@@ -450,17 +461,24 @@
                           accel->getPort("input"));
   accel->addOutputPort("x");
   accel->addOutputPort("y");
-  port = accel->addOutputPort("z");
+  accel->addOutputPort("z");
+
+  delay = new Delay("Acceleration Delay", 1);
+  mTopLevelGroup->addChild(delay);
+  mTopLevelGroup->connect(accel->getPort("z"), delay->getPort("input"));
+  port = delay->getPort("output");
+
   registerJSBExpression("accelerations/accel-z-norm", port);
 
   // Set the position of the aerodynamic force frame.
   mAeroForce->setPosition(structToBody(ap));
-//   port = lookupJSBExpression("aero/alpha-deg", mAeroForce->getPath());
-//   addOutputModel(port, "Alpha", "orientation/alpha-deg");
-//   port = lookupJSBExpression("aero/beta-rad", mAeroForce->getPath());
-//   addOutputModel(port, "Beta rad", "orientation/side-slip-rad");
-//   port = lookupJSBExpression("aero/beta-deg", mAeroForce->getPath());
-//   addOutputModel(port, "Beta", "orientation/side-slip-deg");
+  NodePath nodePath = mTopLevelGroup->getNodePathList().front();
+  port = lookupJSBExpression("aero/alpha-deg", nodePath);
+  addOutputModel(port, "Alpha", "orientation/alpha-deg");
+  port = lookupJSBExpression("aero/beta-rad", nodePath);
+  addOutputModel(port, "Beta rad", "orientation/side-slip-rad");
+  port = lookupJSBExpression("aero/beta-deg", nodePath);
+  addOutputModel(port, "Beta", "orientation/side-slip-deg");
 
   return true;
 }
@@ -522,8 +540,7 @@
 
 bool
 JSBSimReader::attachWheel(const XMLElement* wheelElem, const std::string& name,
-                          const std::string& numStr, RigidBody* parent,
-                          const Vector3& parentDesignPos)
+                          const std::string& numStr, RigidBody* parent)
 {
   RigidBody* wheel = new RigidBody(name + " Wheel");
   mTopLevelGroup->addChild(wheel);
@@ -543,7 +560,7 @@
                           wj->getPort("link1"));
   wj->setAxis(Vector3(0, 1, 0));
   Vector3 pos = structToBody(locationData(wheelElem->getElement("location")));
-  wj->setPosition(pos - parentDesignPos);
+  wj->setPosition(pos);
   wj->setInitialPosition(0);
   wj->setInitialVelocity(0);
 
@@ -568,7 +585,8 @@
     // That one reads the joint position and velocity ...
     mTopLevelGroup->connect(wj->getPort("velocity"), brakeF->getPort("velocity"));
     // ... and provides an output force
-    mTopLevelGroup->connect(brakeF->getPort("position"), wj->getPort("position"));
+    wj->setEnableExternalForce(true);
+    mTopLevelGroup->connect(brakeF->getPort("force"), wj->getPort("force"));
   } else {
     // Just some 'bearing friction'
     Gain* rollingFric = new Gain(name + " Bearing Friction Force");
@@ -576,6 +594,7 @@
     rollingFric->setGain(-10);
     mTopLevelGroup->connect(wj->getPort("velocity"), rollingFric->getInputPort(0));
     // ... and provides an output force
+    wj->setEnableExternalForce(true);
     mTopLevelGroup->connect(rollingFric->getPort("output"), wj->getPort("force"));
   }
   
@@ -719,14 +738,13 @@
         sc->setFrictionCoeficient(fs);
         
       } else if (type == "NOSEGEAR") {
-        // Ok, a compressable gear like the F-18's main gear is.
+        // Ok, a compressable gear like the F-18's nose gear.
         // Some kind of hardcoding here ...
         std::stringstream sstr;
         sstr << gearNumber++;
         std::string numStr = sstr.str();
         std::string name = (*it)->getAttribute("name");
 
-        Vector3 parentPos = structToBody(Vector3::zeros());
         Vector3 compressJointPos = locationData((*it)->getElement("location"));
         // Model steering here ...
         // normally we connect the compressible part to the top level body, but
@@ -750,8 +768,7 @@
           sj->setAxis(Vector3(0, 0, 1));
           sj->setInitialPosition(0);
           sj->setInitialVelocity(0);
-          parentPos = structToBody(compressJointPos) + Vector3(0.05, 0, 0);
-          sj->setPosition(parentPos);
+          sj->setPosition(structToBody(compressJointPos) + Vector3(0.05, 0, 0));
           
           UnaryFunction* scale
             = new UnaryFunction(name + " Scale", UnaryFunction::Abs);
@@ -795,7 +812,7 @@
 //           real_type force = realData(launchbarElem->getElement("launchForce"), 1000);
 //           launchbar->setLaunchForce(force);
 //           Vector3 loc = structToBody(locationData(launchbarElem->getElement("location")));
-//           launchbar->setPosition(loc - parentPos);
+//           launchbar->setPosition(loc);
 
 
 //           if (!connectJSBExpression("/controls/gear/launchbar",
@@ -831,19 +848,19 @@
         mTopLevelGroup->connect(arm->addLink("strutJoint"),
                                 pj->getPort("link1"));
         pj->setAxis(Vector3(0, 0, -1));
-        pj->setPosition(structToBody(compressJointPos) - parentPos);
-        parentPos = structToBody(compressJointPos);
+        pj->setPosition(structToBody(compressJointPos));
         
         // The damper element
         const XMLElement* airSpringElem = (*it)->getElement("damper");
         AirSpring* aoDamp = getAirSpring(airSpringElem, name);
         addMultiBodyModel(aoDamp);
+        pj->setEnableExternalForce(true);
         mTopLevelGroup->connect(aoDamp->getPort("force"), pj->getPort("force"));
         mTopLevelGroup->connect(pj->getPort("position"), aoDamp->getPort("position"));
         mTopLevelGroup->connect(pj->getPort("velocity"), aoDamp->getPort("velocity"));
         
         // Attach a wheel to that strut part.
-        attachWheel((*it)->getElement("wheel"), name, numStr, arm, parentPos);
+        attachWheel((*it)->getElement("wheel"), name, numStr, arm);
         
         // Prepare some outputs ...
         const Port* port = pj->getPort("position");
@@ -882,10 +899,10 @@
         Vector3 compressJointAxis = locationData((*it)->getElement("axis"),
                                                  Vector3(0, 1, 0));
         rj->setAxis(normalize(compressJointAxis));
+        Vector3 compressJointPos = locationData((*it)->getElement("location"));
+        rj->setPosition(structToBody(compressJointPos));
         rj->setInitialPosition(0);
         rj->setInitialVelocity(0);
-        Vector3 compressJointPos = locationData((*it)->getElement("location"));
-        rj->setPosition(structToBody(compressJointPos));
         
         InternalInteract* lineForce = new InternalInteract(name + " Air Spring LineForce");
         lineForce->setEnableDistance(true);
@@ -905,8 +922,7 @@
                                       compressJointPos +
                                       Unit::inch().convertTo(Vector3(-0.5, 0, 0)));
         lineForce->setPosition0(structToBody(asMnt0));
-        lineForce->setPosition1(structToBody(asMnt1)
-                                - structToBody(compressJointPos));
+        lineForce->setPosition1(structToBody(asMnt1));
         
         // The damper element
         const XMLElement* airSpringElem = (*it)->getElement("damper");
@@ -922,8 +938,7 @@
                                 lineForce->getPort("force"));
         
         // Attach a wheel to that strut part.
-        attachWheel((*it)->getElement("wheel"), name, numStr, arm,
-                    structToBody(compressJointPos));
+        attachWheel((*it)->getElement("wheel"), name, numStr, arm);
         
         const Port* port = rj->getPort("position");
         addOutputModel(port, "Gear " + numStr + " Compression",

Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.h	2009-08-03 16:26:58 UTC (rev 1056)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.h	2009-08-03 16:27:40 UTC (rev 1057)
@@ -41,8 +41,7 @@
   bool convertFCSList(const XMLElement* fcsElem);
   bool convertFCSComponent(const XMLElement* fcsComponent);
   bool attachWheel(const XMLElement* wheelElem, const std::string& name,
-                   const std::string& numStr, RigidBody* parent,
-                   const Vector3& parentDesignPos);
+                   const std::string& numStr, RigidBody* parent);
   bool convertGroundReactionsElem(const XMLElement* gr);
   bool convertPropulsion(const XMLElement* prop);
   bool convertTank(const XMLElement* tElem, const std::string& number);

Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.cpp	2009-08-03 16:26:58 UTC (rev 1056)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.cpp	2009-08-03 16:27:40 UTC (rev 1057)
@@ -218,6 +218,8 @@
 JSBSimReaderBase::connectJSBExpression(const std::string& name,
                                        const Port* pa, bool recheckAeroProp)
 {
+  if (!pa)
+    return false;
   SharedPtr<const Node> model = pa->getNode();
   if (!model)
     return false;
@@ -858,9 +860,9 @@
     = new BreakPointLookup(name + " Table Prelookup");
   addMultiBodyModel(tablePreLookup);
   tablePreLookup->setBreakPointVector(tl);
-  mTopLevelGroup->connect(in, tablePreLookup->getPort("input"));
+  mTopLevelGroup->connect(in, tablePreLookup->getInputPort(0));
   mBreakPointVectors.push_back(tablePreLookup);
-  return tablePreLookup->getPort("output");
+  return tablePreLookup->getOutputPort();
 }
 
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimScheduledGain.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimScheduledGain.cpp	2009-08-03 16:26:58 UTC (rev 1056)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimScheduledGain.cpp	2009-08-03 16:27:40 UTC (rev 1057)
@@ -28,27 +28,27 @@
 
   mTable = new Table1D("Table");
   getGroup()->addChild(mTable);
-  getGroup()->connect(product->getPort("input0"),
-                      mTable->getPort("output"));
-  getGroup()->connect(mTable->getPort("input"),
-                      mBreakPointLookup->getPort("output"));
+  getGroup()->connect(product->getInputPort(0),
+                      mTable->getOutputPort());
+  getGroup()->connect(mTable->getInputPort(0),
+                      mBreakPointLookup->getOutputPort());
 
   // Now connect the input and the output to this groups in and outputs
   GroupInput* groupInput = new GroupInput("Input");
   getGroup()->addChild(groupInput);
   groupInput->setExternalPortName("input");
-  getGroup()->connect(product->getPort("input1"),
+  getGroup()->connect(product->getInputPort(1),
                       groupInput->getPort("output"));
  
   groupInput = new GroupInput("Schedule Input");
   getGroup()->addChild(groupInput);
   groupInput->setExternalPortName("scheduleInput");
-  getGroup()->connect(mBreakPointLookup->getPort("input"),
+  getGroup()->connect(mBreakPointLookup->getInputPort(0),
                       groupInput->getPort("output"));
 
   // That single output port is this one
   getGroup()->connect(getInternalOutputPort(),
-                      product->getPort("output"));
+                      product->getOutputPort());
 }
 
 JSBSimScheduledGain::~JSBSimScheduledGain(void)

Modified: branches/OpenFDM-StateSeparation/src/JSBSim/jsb2openfdm.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/jsb2openfdm.cpp	2009-08-03 16:26:58 UTC (rev 1056)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/jsb2openfdm.cpp	2009-08-03 16:27:40 UTC (rev 1057)
@@ -36,7 +36,16 @@
     return EXIT_FAILURE;
   }
   SharedPtr<System> system = reader.getSystem();
+  if (!system) {
+    std::cerr << "No imported aircraft system!" << std::endl;
+    return EXIT_FAILURE;
+  }
 
+  if (!system->init()) {
+    std::cerr << "Could not initialize aircraft system!" << std::endl;
+    return EXIT_FAILURE;
+  }
+  
   // Ok, now the Vehicle here contains the imported data
   // When the reflection stuff is ready, we can dump that data to a
   // native format ...



From frohlich at mail.berlios.de  Mon Aug  3 20:30:59 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Mon, 3 Aug 2009 20:30:59 +0200
Subject: [OpenFDM-svn] r1058 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200908031830.n73IUxNi008756@sheep.berlios.de>

Author: frohlich
Date: 2009-08-03 20:30:58 +0200 (Mon, 03 Aug 2009)
New Revision: 1058

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
Log:
Improove sorting.

M    src/OpenFDM/System.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2009-08-03 16:27:40 UTC (rev 1057)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2009-08-03 18:30:58 UTC (rev 1058)
@@ -77,6 +77,47 @@
 /// FIXME: IMO THIS MUST WORK THIS WAY
 ///
 
+/// Topological sorting.
+/// On success, the sourceList is empty and the sortedList contains the sorted
+/// entries.
+/// On failure, the sourceList contains those entries that could be sorted, and
+/// the sourceList still contains those that have cycles.
+template<typename T, typename D>
+static inline void
+tsort(std::list<T>& sortedList, std::list<T>& sourceList, const D& dependency)
+{
+  /// The algorithm is simple.
+  /// Just push all those items from the sourceList into the sortedList
+  /// that do not depend on any item still in the sourceList.
+  /// Items that do depend on anything still in the source list are
+  /// moved to the tail of the sourceList.
+  /// Do that until sourceList is empty or until we do no longer find any
+  /// independent item.
+  typename std::list<T>::size_type size = sourceList.size();
+  typename std::list<T>::size_type tryCount = 0;
+  while (!sourceList.empty() && size <= tryCount) {
+    
+    // Check if the front item is independent of sourceList
+    typename std::list<T>::iterator i = sourceList.begin();
+    for (; i != sourceList.end(); ++i) {
+      if (dependency(sourceList.front(), *i))
+        break;
+    }
+    // If we came here with i == end, the front item is independent so
+    // schedule it now
+    if (i == sourceList.end()) {
+      sortedList.splice(sortedList.end(), sourceList, sourceList.begin());
+      --size;
+      tryCount = 0;
+    }
+    // Else defer that item
+    else {
+      sourceList.splice(sourceList.end(), sourceList, sourceList.begin());
+      ++tryCount;
+    }
+  }
+}
+
 class ContinousSystemFunction : public Function {
 public:
   virtual size_type inSize(void) const
@@ -559,6 +600,7 @@
     MechanicContext* getMechanicContext()
     { return mMechanicContext; }
 
+    // Currently unused
     bool isLinkedTo(const MechanicInstanceData& instance) const
     {
       unsigned numPorts = getNode()->getNumPorts();
@@ -639,6 +681,29 @@
       return false;
     }
 
+    // detect if this child link is connected to any mechanic port of instance
+    bool isChildLinkedTo(const JointInstanceData& instance) const
+    {
+      unsigned i = mChildLink->getIndex();
+      OpenFDMAssert(i < mPortDataVector.size());
+      OpenFDMAssert(mPortDataVector[i]);
+
+      const Node* otherNode = instance.getNode();
+      unsigned otherNumPorts = otherNode->getNumPorts();
+      for (unsigned j = 0; j < otherNumPorts; ++j) {
+        if (!otherNode->getPort(j)->toMechanicLink())
+          continue;
+        
+        OpenFDMAssert(j < instance.mPortDataVector.size());
+        OpenFDMAssert(instance.mPortDataVector[j]);
+        if (!mPortDataVector[i]->isConnected(*instance.mPortDataVector[j]))
+          continue;
+        
+        return true;
+      }
+      return false;
+    }
+
     // FIXME: do real checks in this case, connected and so forth ...
     bool makeRemainigLinksChildLinks()
     {
@@ -1056,6 +1121,7 @@
         
           if ((*j)->isLinkedToAndSetChild(*(*i))) {
             SharedPtr<JointInstanceData> mechanicInstanceData = *i;
+            mechanicInstanceData->makeRemainigLinksChildLinks();
             nextLevelList.push_back(mechanicInstanceData);
             i = mJointInstanceDataList.erase(i);
 
@@ -1066,7 +1132,7 @@
                  k != sortedJoints.end(); ++k) {
               if (*k == *j)
                 continue;
-              if (mechanicInstanceData->isLinkedTo(*(*k))) {
+              if (mechanicInstanceData->isChildLinkedTo(*(*k))) {
                 Log(Schedule,Warning)
                   << "Detected closed kinematic loop: MechanicNode \""
                   << mechanicInstanceData->getNodeNamePath()
@@ -1088,7 +1154,7 @@
       for (j = nextLevelList.begin(); j != nextLevelList.end(); ++j) {
         JointInstanceDataList::iterator i = j;
         for (++i; i != nextLevelList.end(); ++i) {
-          if ((*j)->isLinkedTo(*(*i))) {
+          if ((*j)->isChildLinkedTo(*(*i))) {
             Log(Schedule,Warning)
               << "Detected closed kinematic loop: MechanicNode \""
               << (*j)->getNodeNamePath()
@@ -1101,8 +1167,6 @@
       
 
       for (j = nextLevelList.begin(); j != nextLevelList.end(); ++j) {
-        // FIXME
-        (*j)->makeRemainigLinksChildLinks();
         sortedJoints.push_back(*j);
       }
     }
@@ -1237,64 +1301,32 @@
     return true;
   }
 
-  // method to sort the leafs according to their dependency
+  struct ModelInstanceDataDepend {
+    bool operator()(const SharedPtr<ModelInstanceData>& m0,
+                    const SharedPtr<ModelInstanceData>& m1) const
+    { return m0->dependsOn(*m1); }
+  };
+
   bool sortModelList(ModelInstanceDataList& modelInstanceDataList)
   {
     ModelInstanceDataList sortedModelInstanceDataList;
-    while (!modelInstanceDataList.empty()) {
-      SharedPtr<ModelInstanceData> modelInstanceData;
-      modelInstanceData = modelInstanceDataList.front();
-      modelInstanceDataList.pop_front();
+    tsort(sortedModelInstanceDataList, modelInstanceDataList,
+          ModelInstanceDataDepend());
 
-      if (modelInstanceData->dependsOn(*modelInstanceData)) {
-        Log(Schedule, Warning)
-          << "Self referencing direct dependency for Model \""
-          << modelInstanceData->getNodeNamePath()
-          << "\" detected!" << std::endl;
-        return false;
-      }
+    // Check if we have some unsorted cycles left
+    if (!modelInstanceDataList.empty()) {
+      Log(Schedule,Warning) << "Detected cyclic loop:" << std::endl;
 
-      ModelInstanceDataList::iterator i;
-      for (i = sortedModelInstanceDataList.begin();
-           i != sortedModelInstanceDataList.end();
-           ++i) {
-        if (!(*i)->dependsOn(*modelInstanceData))
-          continue;
-
-        // Something already sorted in depends on modelInstanceData,
-        // so schedule that new thing just before.
-        Log(Schedule, Debug)
-          << "Inserting Model \""
-          << modelInstanceData->getNodeNamePath()
-          << "\" before Model \""
-          << (*i)->getNodeNamePath() << "\"" << std::endl;
-        i = sortedModelInstanceDataList.insert(i, modelInstanceData);
-        break;
+      ModelInstanceDataList::iterator i = modelInstanceDataList.begin();
+      for (; i != modelInstanceDataList.end(); ++i) {
+        Log(Schedule,Warning)
+          << "  Model \"" << (*i)->getNodeNamePath() << "\"" << std::endl;
       }
-      if (i == sortedModelInstanceDataList.end()) {
-        // nothing found so far that depends on model instance.
-        // So put it at the end.
-        Log(Schedule, Debug)
-          << "Appending Model \""
-          << modelInstanceData->getNodeNamePath()
-          << "\"" << std::endl;
+      modelInstanceDataList.splice(modelInstanceDataList.begin(),
+                                   sortedModelInstanceDataList);
+      return false;
+    }
 
-        sortedModelInstanceDataList.push_back(modelInstanceData);
-      } else {
-        // If it cannot be put at the end, check if modelInstanceData depends
-        // on any model that is already scheduled behind to detect cyclic loops.
-        for (; i != sortedModelInstanceDataList.end(); ++i) {
-          if (!modelInstanceData->dependsOn(*(*i)))
-            continue;
-          Log(Schedule,Warning)
-            << "Detected cyclic loop: Model \""
-            << modelInstanceData->getNodeNamePath()
-            << "\" depends on Model \""
-            << (*i)->getNodeNamePath() << "\"" << std::endl;
-          return false;
-        }
-      }
-    }
     modelInstanceDataList.swap(sortedModelInstanceDataList);
 
     Log(Schedule,Info) << "Model Schedule" << std::endl;



From frohlich at mail.berlios.de  Mon Aug  3 20:38:13 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Mon, 3 Aug 2009 20:38:13 +0200
Subject: [OpenFDM-svn] r1059 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200908031838.n73IcDhD011028@sheep.berlios.de>

Author: frohlich
Date: 2009-08-03 20:38:12 +0200 (Mon, 03 Aug 2009)
New Revision: 1059

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
Log:
As always last minite changes brake something. Fixed ...

M    System.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2009-08-03 18:30:58 UTC (rev 1058)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2009-08-03 18:38:12 UTC (rev 1059)
@@ -95,7 +95,7 @@
   /// independent item.
   typename std::list<T>::size_type size = sourceList.size();
   typename std::list<T>::size_type tryCount = 0;
-  while (!sourceList.empty() && size <= tryCount) {
+  while (!sourceList.empty() && tryCount < size) {
     
     // Check if the front item is independent of sourceList
     typename std::list<T>::iterator i = sourceList.begin();



From frohlich at mail.berlios.de  Mon Aug  3 21:54:55 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Mon, 3 Aug 2009 21:54:55 +0200
Subject: [OpenFDM-svn] r1060 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200908031954.n73Jst3X024002@sheep.berlios.de>

Author: frohlich
Date: 2009-08-03 21:54:55 +0200 (Mon, 03 Aug 2009)
New Revision: 1060

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Input.cpp
Log:
Do not crash on null callback.

M    Input.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Input.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Input.cpp	2009-08-03 18:38:12 UTC (rev 1059)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Input.cpp	2009-08-03 19:54:55 UTC (rev 1060)
@@ -49,7 +49,10 @@
               const ContinousStateValueVector&,
               PortValueList& portValues) const
 {
-  portValues[mOutputPort] = mInputGain*mCallback->getValue();
+  real_type value = 0;
+  if (mCallback)
+    value = mInputGain*mCallback->getValue();
+  portValues[mOutputPort] = value;
 }
 
 Input::Callback*



From frohlich at mail.berlios.de  Tue Aug  4 07:36:24 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Tue, 4 Aug 2009 07:36:24 +0200
Subject: [OpenFDM-svn] r1061 - in branches/OpenFDM-StateSeparation/src:
	OpenFDM test
Message-ID: <200908040536.n745aOYP031585@sheep.berlios.de>

Author: frohlich
Date: 2009-08-04 07:36:21 +0200 (Tue, 04 Aug 2009)
New Revision: 1061

Added:
   branches/OpenFDM-StateSeparation/src/OpenFDM/TopologySort.h
   branches/OpenFDM-StateSeparation/src/test/tsort.cpp
Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
   branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
   branches/OpenFDM-StateSeparation/src/test/Makefile.am
Log:
Split out tsort.
Add test for tsort.

M    OpenFDM/Makefile.am
M    OpenFDM/System.cpp
AM   OpenFDM/TopologySort.h
AM   test/tsort.cpp
M    test/Makefile.am


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2009-08-03 19:54:55 UTC (rev 1060)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2009-08-04 05:36:21 UTC (rev 1061)
@@ -118,6 +118,7 @@
   TemplateStateInfo.h \
   TemplateValueVector.h \
   Time.h \
+  TopologySort.h \
   Transform.h \
   TypeInfo.h \
   Types.h \

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2009-08-03 19:54:55 UTC (rev 1060)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/System.cpp	2009-08-04 05:36:21 UTC (rev 1061)
@@ -17,6 +17,7 @@
 #include "RootJoint.h"
 #include "SystemOutput.h"
 #include "Task.h"
+#include "TopologySort.h"
 #include "TypeInfo.h"
 #include "Variant.h"
 
@@ -77,47 +78,6 @@
 /// FIXME: IMO THIS MUST WORK THIS WAY
 ///
 
-/// Topological sorting.
-/// On success, the sourceList is empty and the sortedList contains the sorted
-/// entries.
-/// On failure, the sourceList contains those entries that could be sorted, and
-/// the sourceList still contains those that have cycles.
-template<typename T, typename D>
-static inline void
-tsort(std::list<T>& sortedList, std::list<T>& sourceList, const D& dependency)
-{
-  /// The algorithm is simple.
-  /// Just push all those items from the sourceList into the sortedList
-  /// that do not depend on any item still in the sourceList.
-  /// Items that do depend on anything still in the source list are
-  /// moved to the tail of the sourceList.
-  /// Do that until sourceList is empty or until we do no longer find any
-  /// independent item.
-  typename std::list<T>::size_type size = sourceList.size();
-  typename std::list<T>::size_type tryCount = 0;
-  while (!sourceList.empty() && tryCount < size) {
-    
-    // Check if the front item is independent of sourceList
-    typename std::list<T>::iterator i = sourceList.begin();
-    for (; i != sourceList.end(); ++i) {
-      if (dependency(sourceList.front(), *i))
-        break;
-    }
-    // If we came here with i == end, the front item is independent so
-    // schedule it now
-    if (i == sourceList.end()) {
-      sortedList.splice(sortedList.end(), sourceList, sourceList.begin());
-      --size;
-      tryCount = 0;
-    }
-    // Else defer that item
-    else {
-      sourceList.splice(sourceList.end(), sourceList, sourceList.begin());
-      ++tryCount;
-    }
-  }
-}
-
 class ContinousSystemFunction : public Function {
 public:
   virtual size_type inSize(void) const

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/TopologySort.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/TopologySort.h	2009-08-03 19:54:55 UTC (rev 1060)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/TopologySort.h	2009-08-04 05:36:21 UTC (rev 1061)
@@ -0,0 +1,55 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2009 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_TopologySort_H
+#define OpenFDM_TopologySort_H
+
+#include <list>
+
+namespace OpenFDM {
+
+/// Topological sorting.
+/// On success, the sourceList is empty and the sortedList contains the sorted
+/// entries.
+/// On failure, the sourceList contains those entries that could be sorted, and
+/// the sourceList still contains those that have cycles.
+template<typename T, typename D>
+static inline void
+tsort(std::list<T>& sortedList, std::list<T>& sourceList, const D& dependency)
+{
+  /// The algorithm is simple.
+  /// Just push all those items from the sourceList into the sortedList
+  /// that do not depend on any item still in the sourceList.
+  /// Items that do depend on anything still in the source list are
+  /// moved to the tail of the sourceList.
+  /// Do that until sourceList is empty or until we do no longer find any
+  /// independent item.
+  typename std::list<T>::size_type size = sourceList.size();
+  typename std::list<T>::size_type tryCount = 0;
+  while (!sourceList.empty() && tryCount < size) {
+    
+    // Check if the front item is independent of sourceList
+    typename std::list<T>::iterator i = sourceList.begin();
+    for (; i != sourceList.end(); ++i) {
+      if (dependency(sourceList.front(), *i))
+        break;
+    }
+    // If we came here with i == end, the front item is independent so
+    // schedule it now
+    if (i == sourceList.end()) {
+      sortedList.splice(sortedList.end(), sourceList, sourceList.begin());
+      --size;
+      tryCount = 0;
+    }
+    // Else defer that item
+    else {
+      sourceList.splice(sourceList.end(), sourceList, sourceList.begin());
+      ++tryCount;
+    }
+  }
+}
+
+} // namespace OpenFDM
+
+#endif


Property changes on: branches/OpenFDM-StateSeparation/src/OpenFDM/TopologySort.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: branches/OpenFDM-StateSeparation/src/test/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/Makefile.am	2009-08-03 19:54:55 UTC (rev 1060)
+++ branches/OpenFDM-StateSeparation/src/test/Makefile.am	2009-08-04 05:36:21 UTC (rev 1061)
@@ -10,6 +10,7 @@
 	mechanicstructure \
 	simulationtime \
 	structure \
+	tsort \
 	unitstest
 
 # define some util programs
@@ -22,6 +23,7 @@
 	mechanicstructure \
 	structure \
 	tiretestrig \
+	tsort \
 	coordsys \
 	$(TESTS)
 
@@ -70,5 +72,8 @@
 tiretestrig_SOURCES = tiretestrig.cpp
 tiretestrig_LDADD = ../OpenFDM/libOpenFDM.la
 
+tsort_SOURCES = tsort.cpp
+tsort_LDADD = ../OpenFDM/libOpenFDM.la
+
 unitstest_SOURCES = unitstest.cpp
 unitstest_LDADD = ../OpenFDM/libOpenFDM.la

Added: branches/OpenFDM-StateSeparation/src/test/tsort.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/tsort.cpp	2009-08-03 19:54:55 UTC (rev 1060)
+++ branches/OpenFDM-StateSeparation/src/test/tsort.cpp	2009-08-04 05:36:21 UTC (rev 1061)
@@ -0,0 +1,204 @@
+#include <vector>
+#include <list>
+#include <iostream>
+#include <cstdlib>
+
+#include <OpenFDM/TopologySort.h>
+
+using namespace OpenFDM;
+
+struct Test {
+  Test(unsigned i) :
+    id(i)
+  { }
+  Test(unsigned i, unsigned d) :
+    id(i)
+  { depends.push_back(d); }
+  Test(unsigned i, unsigned d1, unsigned d2) :
+    id(i)
+  { depends.push_back(d1); depends.push_back(d2); }
+  Test(unsigned i, unsigned d1, unsigned d2, unsigned d3) :
+    id(i)
+  { depends.push_back(d1); depends.push_back(d2); depends.push_back(d3); }
+
+  void addDependency(unsigned d)
+  { depends.push_back(d); }
+
+  bool dependsOn(const Test& other) const
+  {
+    for (unsigned i = 0; i < depends.size(); ++i)
+      if (depends[i] == other.id)
+        return true;
+    return false;
+  }
+
+  unsigned id;
+  std::vector<unsigned> depends;
+};
+
+std::ostream&
+operator<<(std::ostream& s, const Test& t)
+{
+  s << "(" << t.id;
+  for (unsigned i = 0; i < t.depends.size(); ++i)
+    s << " " << t.depends[i];
+  return s << ")";
+}
+
+template<typename T>
+std::ostream&
+operator<<(std::ostream& s, const std::list<T>& l)
+{
+  for (typename std::list<T>::const_iterator i = l.begin(); i != l.end(); ++i)
+    s << " " << *i;
+  return s;
+}
+
+struct Depends {
+  bool operator()(const Test& t0, const Test& t1) const
+  { return t0.dependsOn(t1); }
+};
+
+template<typename T, typename D>
+inline bool
+verify(const std::list<T>& sortedList, const D& depends)
+{
+  for (typename std::list<T>::const_iterator i = sortedList.begin();
+       i != sortedList.end(); ++i) {
+    for (typename std::list<T>::const_iterator j = i;
+         j != sortedList.end(); ++j) {
+      if (depends(*i, *j))
+        return false;
+    }
+  }
+  return true;
+}
+
+template<typename T, typename D>
+bool
+testrun(std::list<T>& source, const D& depends)
+{
+  std::list<T> orig = source;
+  std::list<T> sorted;
+  tsort(sorted, source, depends);
+  if (verify(sorted, depends))
+    return true;
+  std::cout << "---- FAIL ----" << std::endl;
+  std::cout << "Original:" << orig << std::endl;
+  std::cout << "Sorted:" << sorted << std::endl;
+  std::cout << "Cycles:" << source << std::endl;
+  std::cout << std::endl;
+  return false;
+}
+
+bool
+randomTest(unsigned num, unsigned maxNumDeps)
+{
+  // Build up a direct acyclic graph
+  std::vector<Test> source0;
+  source0.reserve(num);
+  for (unsigned i = 0; i < num; ++i) {
+    Test t(i);
+    unsigned numdeps = rand() % (maxNumDeps + 1);
+    if (i < numdeps)
+      numdeps = i;
+    for (unsigned j = 0; j < numdeps; ++j)
+      t.addDependency(rand()%i);
+    source0.push_back(t);
+  }
+
+  // Build a permutation of 0:num-1
+  std::vector<unsigned> perm(num);
+  for (unsigned i = 0; i < num; ++i)
+    perm[i] = i;
+  for (unsigned i = 0; i < num*num; ++i)
+    std::swap(perm[rand()%num], perm[rand()%num]);
+
+  // Now permute the dag
+  std::list<Test> source;
+  for (unsigned i = 0; i < num; ++i)
+    source.push_back(source0[perm[i]]);
+
+  // Test if the algorithm works
+  return testrun(source, Depends());
+}
+
+int main()
+{
+  std::list<Test> hmm;
+
+  /////////////////////////////////////////////
+  hmm.clear();
+  hmm.push_back(Test(0, 0));
+
+  if (!testrun(hmm, Depends()))
+    return EXIT_FAILURE;
+
+  /////////////////////////////////////////////
+  hmm.clear();
+  hmm.push_back(Test(0, 1));
+  hmm.push_back(Test(1, 0));
+
+  if (!testrun(hmm, Depends()))
+    return EXIT_FAILURE;
+
+  /////////////////////////////////////////////
+  /// Breaks at pure depth first
+  hmm.clear();
+  hmm.push_back(Test(3, 1, 2));
+  hmm.push_back(Test(2, 1));
+  hmm.push_back(Test(1, 0));
+  hmm.push_back(Test(0));
+
+  if (!testrun(hmm, Depends()))
+    return EXIT_FAILURE;
+
+  /////////////////////////////////////////////
+  /// Breaks at pure broad first
+  hmm.clear();
+  hmm.push_back(Test(3, 2, 1));
+  hmm.push_back(Test(1, 0));
+  hmm.push_back(Test(2, 1));
+  hmm.push_back(Test(0));
+
+  if (!testrun(hmm, Depends()))
+    return EXIT_FAILURE;
+
+  /////////////////////////////////////////////
+  /// Breaks with bread first and depth first
+  hmm.clear();
+  hmm.push_back(Test(5, 3, 4));
+  hmm.push_back(Test(4, 1));
+  hmm.push_back(Test(3, 1, 2));
+  hmm.push_back(Test(2, 1));
+  hmm.push_back(Test(1, 0));
+  hmm.push_back(Test(0));
+
+  if (!testrun(hmm, Depends()))
+    return EXIT_FAILURE;
+
+
+  /////////////////////////////////////////////
+  /// Breaks ???
+  hmm.clear();
+  hmm.push_back(Test(3, 0, 2));
+  hmm.push_back(Test(0));
+  hmm.push_back(Test(2, 1));
+  hmm.push_back(Test(1, 0));
+
+  if (!testrun(hmm, Depends()))
+    return EXIT_FAILURE;
+
+  /// Random tests ...
+  unsigned numTests = 100;
+  for (unsigned maxNumDeps = 1; maxNumDeps < 10; ++maxNumDeps) {
+    for (unsigned num = 2; num < 100; ++num) {
+      for (unsigned count = 0; count < numTests; ++count) {
+        if (!randomTest(num, maxNumDeps))
+          return EXIT_FAILURE;
+      }
+    }
+  }
+
+  return EXIT_SUCCESS;
+}


Property changes on: branches/OpenFDM-StateSeparation/src/test/tsort.cpp
___________________________________________________________________
Name: svn:eol-style
   + native



From frohlich at mail.berlios.de  Tue Aug  4 23:10:38 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Tue, 4 Aug 2009 23:10:38 +0200
Subject: [OpenFDM-svn] r1062 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200908042110.n74LAcLw012065@sheep.berlios.de>

Author: frohlich
Date: 2009-08-04 23:10:38 +0200 (Tue, 04 Aug 2009)
New Revision: 1062

Modified:
   branches/OpenFDM-StateSeparation/src/test/drop.cpp
Log:
Remove unused headers.

M    drop.cpp


Modified: branches/OpenFDM-StateSeparation/src/test/drop.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/drop.cpp	2009-08-04 05:36:21 UTC (rev 1061)
+++ branches/OpenFDM-StateSeparation/src/test/drop.cpp	2009-08-04 21:10:38 UTC (rev 1062)
@@ -1,10 +1,7 @@
 #include <OpenFDM/ConstModel.h>
 #include <OpenFDM/Group.h>
-#include <OpenFDM/InternalInteract.h>
-#include <OpenFDM/LinearSpringDamper.h>
 #include <OpenFDM/Mass.h>
 #include <OpenFDM/MobileRootJoint.h>
-#include <OpenFDM/RevoluteJoint.h>
 #include <OpenFDM/RigidBody.h>
 #include <OpenFDM/ExternalInteract.h>
 #include <OpenFDM/System.h>



From frohlich at mail.berlios.de  Wed Aug  5 17:11:40 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Wed, 5 Aug 2009 17:11:40 +0200
Subject: [OpenFDM-svn] r1063 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200908051511.n75FBeEL017531@sheep.berlios.de>

Author: frohlich
Date: 2009-08-05 17:11:36 +0200 (Wed, 05 Aug 2009)
New Revision: 1063

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/TableData.h
Log:
Fix iterator problem.

M    TableData.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/TableData.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/TableData.h	2009-08-04 21:10:38 UTC (rev 1062)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/TableData.h	2009-08-05 15:11:36 UTC (rev 1063)
@@ -50,14 +50,14 @@
     // Find the table bounds for the requested input.
     vector_type::const_iterator upBoundIt;
     upBoundIt = std::upper_bound(vectorBegin, vectorEnd, input);
+    if (upBoundIt == vectorEnd)
+      return value_type(mVector.size() - 1);
+    if (upBoundIt == vectorBegin)
+      return value_type(0);
+
     vector_type::const_iterator loBoundIt = upBoundIt;
     --loBoundIt;
 
-    if (upBoundIt == vectorBegin)
-      return value_type(0);
-    if (upBoundIt == vectorEnd)
-      return value_type(mVector.size() - 1);
-
     // Just do linear interpolation.
     value_type loIdx = value_type(std::distance(vectorBegin, loBoundIt));
     if (loBoundIt == upBoundIt)



From frohlich at mail.berlios.de  Wed Aug  5 23:38:45 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Wed, 5 Aug 2009 23:38:45 +0200
Subject: [OpenFDM-svn] r1064 -
	branches/OpenFDM-StateSeparation/src/OpenFDM/LinAlg
Message-ID: <200908052138.n75LcjL1032301@sheep.berlios.de>

Author: frohlich
Date: 2009-08-05 23:38:44 +0200 (Wed, 05 Aug 2009)
New Revision: 1064

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/LinAlg/Container.h
Log:
Compile fixes.

M    Container.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/LinAlg/Container.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/LinAlg/Container.h	2009-08-05 15:11:36 UTC (rev 1063)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/LinAlg/Container.h	2009-08-05 21:38:44 UTC (rev 1064)
@@ -1181,9 +1181,9 @@
   cylinderInertia(const T& mass, const T& length, const T& radius)
   {
     T r2 = radius*radius;
-    T Ixx = T(0.25)*mass*(r2 + T(1)/3*length*length);
+    T Ixx = T(0.25)*mass*(r2 + T(1)/T(3)*length*length);
     T Izz = T(0.5)*mass*r2;
-    return SymMatrix<T,3>(Ixx, 0, 0, Ixx, 0, Izz);
+    return SymMatrix3(Ixx, T(0), T(0), Ixx, T(0), Izz);
   }
   
   // Compute the inertia of a solid quad with the given lengths and mass.
@@ -1194,7 +1194,7 @@
     T x2 = 1/T(12)*mass*x*x;
     T y2 = 1/T(12)*mass*y*y;
     T z2 = 1/T(12)*mass*z*z;
-    return SymMatrix<T,3>(y2+z2, 0, 0, x2+z2, 0, x2+y2);
+    return SymMatrix3(y2+z2, T(0), T(0), x2+z2, T(0), x2+y2);
   }
 
   // Compute the inertia of a solid ellipsoid with the given semiaxis and mass.
@@ -1205,7 +1205,7 @@
     T x2 = 1/T(5)*mass*x*x;
     T y2 = 1/T(5)*mass*y*y;
     T z2 = 1/T(5)*mass*z*z;
-    return SymMatrix<T,3>(y2+z2, 0, 0, x2+z2, 0, x2+y2);
+    return SymMatrix3(y2+z2, T(0), T(0), x2+z2, T(0), x2+y2);
   }
 };
 



From frohlich at mail.berlios.de  Wed Aug  5 23:39:41 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Wed, 5 Aug 2009 23:39:41 +0200
Subject: [OpenFDM-svn] r1065 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200908052139.n75Ldfgq032600@sheep.berlios.de>

Author: frohlich
Date: 2009-08-05 23:39:40 +0200 (Wed, 05 Aug 2009)
New Revision: 1065

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractPlanet.h
Log:
Misc updates.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractPlanet.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractPlanet.h	2009-08-05 21:38:44 UTC (rev 1064)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/AbstractPlanet.h	2009-08-05 21:39:40 UTC (rev 1065)
@@ -23,7 +23,7 @@
    */
   AbstractPlanet(void);
 
-  /** Default destructor.
+  /** Destructor.
    */
   virtual ~AbstractPlanet(void);
 
@@ -37,7 +37,7 @@
    *  reference frame as this effect is captured by the inertial
    *  frame methods.
    */
-  virtual Vector3 getGravityAcceleration(const Vector3&) const = 0;
+  virtual Vector3 getGravityAcceleration(const Vector3& position) const = 0;
 
   /** Return the global reference frames velocity and acceleration.
    *  Note that these both must fit together to make the simulation



From frohlich at mail.berlios.de  Wed Aug  5 23:44:04 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Wed, 5 Aug 2009 23:44:04 +0200
Subject: [OpenFDM-svn] r1066 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200908052144.n75Li4EW001472@sheep.berlios.de>

Author: frohlich
Date: 2009-08-05 23:44:04 +0200 (Wed, 05 Aug 2009)
New Revision: 1066

Modified:
   branches/OpenFDM-StateSeparation/src/test/ballistic.cpp
Log:
Improove the ballistic model.

M    test/ballistic.cpp


Modified: branches/OpenFDM-StateSeparation/src/test/ballistic.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/ballistic.cpp	2009-08-05 21:39:40 UTC (rev 1065)
+++ branches/OpenFDM-StateSeparation/src/test/ballistic.cpp	2009-08-05 21:44:04 UTC (rev 1066)
@@ -10,8 +10,10 @@
 #include <OpenFDM/MobileRootJoint.h>
 #include <OpenFDM/Product.h>
 #include <OpenFDM/RigidBody.h>
+#include <OpenFDM/Summer.h>
 #include <OpenFDM/System.h>
 #include <OpenFDM/SystemOutput.h>
+#include <OpenFDM/UnaryFunction.h>
 #include <OpenFDM/WindAxis.h>
 #include <OpenFDM/WindAxisForce.h>
 
@@ -31,11 +33,15 @@
   rigidBody->addLink("externalInteractLink");
   group->addChild(rigidBody);
 
-  Mass* mass = new Mass("Mass", 1, InertiaMatrix(1, 0, 0, 1, 0, 1));
+  real_type m = 0.01;
+  real_type length = 1;
+  real_type radius = 0.01;
+  InertiaMatrix I = InertiaMatrix::cylinderInertia(m, length, radius);
+  Mass* mass = new Mass("Mass", m, I);
   group->addChild(mass);
 
   ExternalInteract* externalInteract = new ExternalInteract("ExternalInteract");
-  externalInteract->setPosition(mass->getPosition());
+  externalInteract->setPosition(mass->getPosition() - Vector3(0.3, 0, 0));
   externalInteract->setEnableAllOutputs(true);
   group->addChild(externalInteract);
 
@@ -83,73 +89,58 @@
   group->connect(windAxisForce->getPort("bodyForce"),
                  externalInteract->getPort("bodyForce"));
 
-  ConstModel* zeroConst = new ConstModel("ConstModel 0");
-  group->addChild(zeroConst);
+  UnaryFunction* alphaAbs = new UnaryFunction("Alpha Abs", UnaryFunction::Abs);
+  group->addChild(alphaAbs);
 
-  group->connect(zeroConst->getPort("output"),
-                 windAxisForce->getPort("side"));
-  group->connect(zeroConst->getPort("output"),
-                 windAxisForce->getPort("lift"));
+  group->connect(alphaAbs->getPort("input"),
+                 windAxis->getPort("alpha"));
 
-  Gain* dragCoeficient = new Gain("Drag Coeficient");
-  dragCoeficient->setGain(0.01);
-  group->addChild(dragCoeficient);
+  UnaryFunction* betaAbs = new UnaryFunction("Beta Abs", UnaryFunction::Abs);
+  group->addChild(betaAbs);
 
-  group->connect(dragCoeficient->getPort("input"),
-                 dynamicPressure->getPort("dynamicPressure"));
+  group->connect(betaAbs->getPort("input"),
+                 windAxis->getPort("beta"));
 
-  group->connect(dragCoeficient->getPort("output"),
-                 windAxisForce->getPort("drag"));
+  ConstModel* dragAtZeroAlpha = new ConstModel("Drag at zero Alpha", 1);
+  group->addChild(dragAtZeroAlpha);
 
+  Summer* dragFactor = new Summer("Drag Factor");
+  dragFactor->setNumSummands(3);
+  group->addChild(dragFactor);
 
-  Product* alphaProduct = new Product("Alpha Product");
-  group->addChild(alphaProduct);
+  group->connect(dragFactor->getPort("input0"),
+                 dragAtZeroAlpha->getPort("output"));
+  group->connect(dragFactor->getPort("input1"),
+                 alphaAbs->getPort("output"));
+  group->connect(dragFactor->getPort("input2"),
+                 betaAbs->getPort("output"));
 
-  group->connect(alphaProduct->getPort("input0"),
-                 dynamicPressure->getPort("dynamicPressure"));
-  group->connect(alphaProduct->getPort("input1"),
-                 windAxis->getPort("alpha"));
+  Gain* dragCoeficient = new Gain("Drag Coeficient", 0.0001);
+  group->addChild(dragCoeficient);
 
-  Gain* alphaCoeficient = new Gain("Alpha Coeficient");
-  alphaCoeficient->setGain(-10);
-  group->addChild(alphaCoeficient);
+  group->connect(dragCoeficient->getPort("input"),
+                 dragFactor->getPort("output"));
 
-  group->connect(alphaCoeficient->getPort("input"),
-                 alphaProduct->getPort("output"));
+  Product* drag = new Product("Drag");
+  drag->setNumFactors(2);
+  group->addChild(drag);
 
-
-
-  Product* betaProduct = new Product("Beta Product");
-  group->addChild(betaProduct);
-
-  group->connect(betaProduct->getPort("input0"),
+  group->connect(drag->getPort("input0"),
                  dynamicPressure->getPort("dynamicPressure"));
-  group->connect(betaProduct->getPort("input1"),
-                 windAxis->getPort("beta"));
+  group->connect(drag->getPort("input1"),
+                 dragCoeficient->getPort("output"));
 
-  Gain* betaCoeficient = new Gain("Beta Coeficient");
-  betaCoeficient->setGain(-10);
-  group->addChild(betaCoeficient);
 
-  group->connect(betaCoeficient->getPort("input"),
-                 betaProduct->getPort("output"));
+  ConstModel* zeroConst = new ConstModel("ConstModel 0");
+  group->addChild(zeroConst);
 
-
-
-  MatrixConcat* torque = new MatrixConcat("Torque");
-  group->addChild(torque);
-
+  group->connect(drag->getPort("output"),
+                 windAxisForce->getPort("drag"));
   group->connect(zeroConst->getPort("output"),
-                 torque->addInputPort("x"));
-  group->connect(alphaCoeficient->getPort("output"),
-                 torque->addInputPort("y"));
-  group->connect(betaCoeficient->getPort("output"),
-                 torque->addInputPort("z"));
+                 windAxisForce->getPort("side"));
+  group->connect(zeroConst->getPort("output"),
+                 windAxisForce->getPort("lift"));
 
-  externalInteract->setEnableBodyTorque(true);
-  group->connect(torque->getPort("output"),
-                 externalInteract->getPort("bodyTorque"));
-
   return group.release();
 }
 



From frohlich at mail.berlios.de  Fri Aug  7 20:59:00 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Fri, 7 Aug 2009 20:59:00 +0200
Subject: [OpenFDM-svn] r1067 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200908071859.n77Ix0Bb003564@sheep.berlios.de>

Author: frohlich
Date: 2009-08-07 20:58:59 +0200 (Fri, 07 Aug 2009)
New Revision: 1067

Modified:
   branches/OpenFDM-StateSeparation/src/test/drop.cpp
Log:
Make sure we do not drop below ground.

M    drop.cpp


Modified: branches/OpenFDM-StateSeparation/src/test/drop.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/drop.cpp	2009-08-05 21:44:04 UTC (rev 1066)
+++ branches/OpenFDM-StateSeparation/src/test/drop.cpp	2009-08-07 18:58:59 UTC (rev 1067)
@@ -15,6 +15,7 @@
   SharedPtr<Group> group = new Group("Group");
 
   MobileRootJoint* mobileRootJoint = new MobileRootJoint("Root Joint");
+  mobileRootJoint->setInitialPosition(Vector3(0, 0, -10000));
   mobileRootJoint->setInitialAngularVelocity(Vector3(1, 1, 1));
   group->addChild(mobileRootJoint);
 
@@ -49,7 +50,7 @@
   if (!system->init())
     return 1;
 
-  system->simulate(10);
+  system->simulate(45);
 
   return 0;
 }



From frohlich at mail.berlios.de  Fri Aug  7 21:07:44 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Fri, 7 Aug 2009 21:07:44 +0200
Subject: [OpenFDM-svn] r1068 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200908071907.n77J7i9I004715@sheep.berlios.de>

Author: frohlich
Date: 2009-08-07 21:07:41 +0200 (Fri, 07 Aug 2009)
New Revision: 1068

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/AtmosphereSTD1976.cpp
Log:
Remove unused include.

M    AtmosphereSTD1976.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/AtmosphereSTD1976.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/AtmosphereSTD1976.cpp	2009-08-07 18:58:59 UTC (rev 1067)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/AtmosphereSTD1976.cpp	2009-08-07 19:07:41 UTC (rev 1068)
@@ -8,7 +8,6 @@
 #include "Types.h"
 #include "LogStream.h"
 #include "Math.h"
-#include <iostream>
 
 namespace OpenFDM {
 



From frohlich at mail.berlios.de  Fri Aug  7 21:14:47 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Fri, 7 Aug 2009 21:14:47 +0200
Subject: [OpenFDM-svn] r1069 - in
	branches/OpenFDM-StateSeparation/src/OpenFDM: . LinAlg
Message-ID: <200908071914.n77JEltm005694@sheep.berlios.de>

Author: frohlich
Date: 2009-08-07 21:14:47 +0200 (Fri, 07 Aug 2009)
New Revision: 1069

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/LinAlg/IO.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/MPFRFloat.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/XMLDumpModelVisitor.h
Log:
avoid including iostream if not required.

M    XMLDumpModelVisitor.h
M    LinAlg/IO.h
M    MPFRFloat.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/LinAlg/IO.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/LinAlg/IO.h	2009-08-07 19:07:41 UTC (rev 1068)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/LinAlg/IO.h	2009-08-07 19:14:47 UTC (rev 1069)
@@ -5,8 +5,9 @@
 #ifndef OpenFDM_Matrix_IO_H
 #define OpenFDM_Matrix_IO_H
 
-#include <iostream>
+#include <iosfwd>
 #include <iomanip>
+#include <ostream>
 
 namespace OpenFDM {
 

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/MPFRFloat.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/MPFRFloat.h	2009-08-07 19:07:41 UTC (rev 1068)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/MPFRFloat.h	2009-08-07 19:14:47 UTC (rev 1069)
@@ -6,7 +6,8 @@
 #define OpenFDM_MPFloat_H
 
 #include <cstring>
-#include <iostream>
+#include <iosfwd>
+#include <ostream>
 #include <mpfr.h>
 
 namespace OpenFDM {

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/XMLDumpModelVisitor.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/XMLDumpModelVisitor.h	2009-08-07 19:07:41 UTC (rev 1068)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/XMLDumpModelVisitor.h	2009-08-07 19:14:47 UTC (rev 1069)
@@ -5,10 +5,10 @@
 #ifndef OpenFDM_XMLDumpModelVisitor_H
 #define OpenFDM_XMLDumpModelVisitor_H
 
+#include <iomanip>
 #include <iosfwd>
-#include <iostream>
+#include <ostream>
 #include <sstream>
-#include <iomanip>
 
 #include "Group.h"
 #include "Node.h"



From frohlich at mail.berlios.de  Fri Aug  7 21:21:42 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Fri, 7 Aug 2009 21:21:42 +0200
Subject: [OpenFDM-svn] r1070 - in
	branches/OpenFDM-StateSeparation/src/OpenFDM: . XML
Message-ID: <200908071921.n77JLgSL006655@sheep.berlios.de>

Author: frohlich
Date: 2009-08-07 21:21:42 +0200 (Fri, 07 Aug 2009)
New Revision: 1070

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Assert.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/XML/ExpatXMLReader.cpp
Log:
Avoid using iostream.

M    XML/ExpatXMLReader.cpp
M    Assert.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Assert.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Assert.cpp	2009-08-07 19:14:47 UTC (rev 1069)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Assert.cpp	2009-08-07 19:21:42 UTC (rev 1070)
@@ -18,7 +18,6 @@
 #include <string.h>
 #endif
 
-#include <iostream>
 #include <cstdlib>
 
 namespace OpenFDM {

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/XML/ExpatXMLReader.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/XML/ExpatXMLReader.cpp	2009-08-07 19:14:47 UTC (rev 1069)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/XML/ExpatXMLReader.cpp	2009-08-07 19:21:42 UTC (rev 1070)
@@ -3,7 +3,7 @@
  */
 
 #include "ExpatXMLReader.h"
-#include <iostream>
+#include <istream>
 #include <cstring>
 #include <expat.h>
 #include "config.h"



From frohlich at mail.berlios.de  Fri Aug  7 21:23:22 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Fri, 7 Aug 2009 21:23:22 +0200
Subject: [OpenFDM-svn] r1071 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200908071923.n77JNMFA006872@sheep.berlios.de>

Author: frohlich
Date: 2009-08-07 21:23:21 +0200 (Fri, 07 Aug 2009)
New Revision: 1071

Modified:
   branches/OpenFDM-StateSeparation/src/test/mechanicstructure.cpp
Log:
Add iostream where it is needed.

M    mechanicstructure.cpp


Modified: branches/OpenFDM-StateSeparation/src/test/mechanicstructure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/mechanicstructure.cpp	2009-08-07 19:21:42 UTC (rev 1070)
+++ branches/OpenFDM-StateSeparation/src/test/mechanicstructure.cpp	2009-08-07 19:23:21 UTC (rev 1071)
@@ -1,3 +1,5 @@
+#include <iostream>
+
 #include <OpenFDM/Group.h>
 #include <OpenFDM/Mass.h>
 #include <OpenFDM/MobileRootJoint.h>



From frohlich at mail.berlios.de  Fri Aug  7 21:24:06 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Fri, 7 Aug 2009 21:24:06 +0200
Subject: [OpenFDM-svn] r1072 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200908071924.n77JO6I9006976@sheep.berlios.de>

Author: frohlich
Date: 2009-08-07 21:24:06 +0200 (Fri, 07 Aug 2009)
New Revision: 1072

Modified:
   branches/OpenFDM-StateSeparation/src/test/structure.cpp
Log:
Add iostream where it is needed.

M    structure.cpp


Modified: branches/OpenFDM-StateSeparation/src/test/structure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/structure.cpp	2009-08-07 19:23:21 UTC (rev 1071)
+++ branches/OpenFDM-StateSeparation/src/test/structure.cpp	2009-08-07 19:24:06 UTC (rev 1072)
@@ -1,3 +1,5 @@
+#include <iostream>
+
 #include <OpenFDM/Gain.h>
 #include <OpenFDM/DiscreteIntegrator.h>
 #include <OpenFDM/Integrator.h>



From frohlich at mail.berlios.de  Fri Aug  7 23:03:30 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Fri, 7 Aug 2009 23:03:30 +0200
Subject: [OpenFDM-svn] r1073 -
	branches/OpenFDM-StateSeparation/src/OpenFDM/LinAlg
Message-ID: <200908072103.n77L3U90020856@sheep.berlios.de>

Author: frohlich
Date: 2009-08-07 23:03:28 +0200 (Fri, 07 Aug 2009)
New Revision: 1073

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/LinAlg/Expressions.h
Log:
Add ceil and floor for vector valued functions.

M    LinAlg/Expressions.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/LinAlg/Expressions.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/LinAlg/Expressions.h	2009-08-07 19:24:06 UTC (rev 1072)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/LinAlg/Expressions.h	2009-08-07 21:03:28 UTC (rev 1073)
@@ -748,6 +748,44 @@
   return ret;
 }
 
+template<typename Impl, size_type m, size_type n>
+OpenFDM_FORCE_INLINE
+Matrix<typename Impl::value_type,m,n>
+floor(const MatrixRValue<Impl,m,n>& A)
+{
+  const Impl& Ai = A.asImpl();
+
+  size_type rows = Ai.rows();
+  size_type cols = Ai.cols();
+
+  Matrix<typename Impl::value_type,m,n> ret(rows, cols);
+  size_type i, j;
+  for (j = 0; j < cols; ++j)
+    for (i = 0; i < rows; ++i)
+      ret(i,j) = OpenFDM::floor(Ai(i,j));
+
+  return ret;
+}
+
+template<typename Impl, size_type m, size_type n>
+OpenFDM_FORCE_INLINE
+Matrix<typename Impl::value_type,m,n>
+ceil(const MatrixRValue<Impl,m,n>& A)
+{
+  const Impl& Ai = A.asImpl();
+
+  size_type rows = Ai.rows();
+  size_type cols = Ai.cols();
+
+  Matrix<typename Impl::value_type,m,n> ret(rows, cols);
+  size_type i, j;
+  for (j = 0; j < cols; ++j)
+    for (i = 0; i < rows; ++i)
+      ret(i,j) = OpenFDM::ceil(Ai(i,j));
+
+  return ret;
+}
+
 template<typename Impl1, size_type m1, size_type n1,
          typename Impl2, size_type m2, size_type n2>
 OpenFDM_FORCE_INLINE



From frohlich at mail.berlios.de  Fri Aug  7 23:37:03 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Fri, 7 Aug 2009 23:37:03 +0200
Subject: [OpenFDM-svn] r1074 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200908072137.n77Lb3PR023597@sheep.berlios.de>

Author: frohlich
Date: 2009-08-07 23:37:02 +0200 (Fri, 07 Aug 2009)
New Revision: 1074

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/DynamicPressure.cpp
Log:
Initialize all.

M    DynamicPressure.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/DynamicPressure.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/DynamicPressure.cpp	2009-08-07 21:03:28 UTC (rev 1073)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/DynamicPressure.cpp	2009-08-07 21:37:02 UTC (rev 1074)
@@ -9,13 +9,15 @@
 namespace OpenFDM {
 
 BEGIN_OPENFDM_OBJECT_DEF(DynamicPressure, Model)
+  DEF_OPENFDM_PROPERTY(Vector3, Direction, Serialized)
   END_OPENFDM_OBJECT_DEF
 
 DynamicPressure::DynamicPressure(const std::string& name) :
   Model(name),
   mVelocityPort(this, "velocity", Size(3, 1), true),
   mDensityPort(this, "density", true),
-  mDynamicPressurePort(this, "dynamicPressure")
+  mDynamicPressurePort(this, "dynamicPressure"),
+  mDirection(0, 0, 0)
 {
 }
 



From frohlich at mail.berlios.de  Fri Aug  7 23:43:55 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Fri, 7 Aug 2009 23:43:55 +0200
Subject: [OpenFDM-svn] r1075 - branches/OpenFDM-StateSeparation/src/test
Message-ID: <200908072143.n77Lht2j024360@sheep.berlios.de>

Author: frohlich
Date: 2009-08-07 23:43:54 +0200 (Fri, 07 Aug 2009)
New Revision: 1075

Modified:
   branches/OpenFDM-StateSeparation/src/test/ballistic.cpp
Log:
Do not fall below ground by starting at an other position.

M    ballistic.cpp


Modified: branches/OpenFDM-StateSeparation/src/test/ballistic.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/ballistic.cpp	2009-08-07 21:37:02 UTC (rev 1074)
+++ branches/OpenFDM-StateSeparation/src/test/ballistic.cpp	2009-08-07 21:43:54 UTC (rev 1075)
@@ -25,8 +25,10 @@
   SharedPtr<Group> group = new Group("Group");
 
   MobileRootJoint* mobileRootJoint = new MobileRootJoint("Root Joint");
+  mobileRootJoint->setInitialPosition(Vector3(0, 0, -200));
+  mobileRootJoint->setInitialOrientation(Quaternion::fromEulerSeq(1, 45*deg2rad));
   mobileRootJoint->setInitialLinearVelocity(50*Vector3(1, 0, 0));
-  mobileRootJoint->setInitialOrientation(Quaternion::fromEulerSeq(1, 45*deg2rad));
+  mobileRootJoint->setInitialAngularVelocity(Vector3(180*deg2rad, 0, 0));
   group->addChild(mobileRootJoint);
 
   RigidBody* rigidBody = new RigidBody("Rigid Body");



From frohlich at mail.berlios.de  Sat Aug  8 14:52:04 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 8 Aug 2009 14:52:04 +0200
Subject: [OpenFDM-svn] r1077 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200908081252.n78Cq4Wt012588@sheep.berlios.de>

Author: frohlich
Date: 2009-08-08 14:52:03 +0200 (Sat, 08 Aug 2009)
New Revision: 1077

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/TableData.h
Log:
Use std::vector instead of new/delete

M    TableData.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/TableData.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/TableData.h	2009-08-08 07:57:44 UTC (rev 1076)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/TableData.h	2009-08-08 12:52:03 UTC (rev 1077)
@@ -79,47 +79,17 @@
   typedef LinAlg::Vector<unsigned,numDims>  SizeVector;
   typedef LinAlg::Vector<real_type,numDims> InterpVector;
 
-  TableData(void) :
-    mData(0)
+  TableData(void)
   {}
   TableData(const SizeVector& size) :
-    mData(new real_type[product(size)]), mSize(size)
-  {
-    unsigned totalLen = product(mSize);
-    for (unsigned i = 0; i < totalLen; ++i)
-      mData[i] = 0;
-  }
+    mData(product(size), real_type(0)), mSize(size)
+  { }
   TableData(const TableData& ndarray) :
-    mData(new real_type[product(ndarray.size())]), mSize(ndarray.size())
-  {
-    unsigned totalLen = product(mSize);
-    for (unsigned i = 0; i < totalLen; ++i)
-      mData[i] = ndarray.mData[i];
-  }
+    mData(ndarray.mData), mSize(ndarray.size())
+  { }
   ~TableData(void)
-  { delete[] mData; }
+  { }
 
-  TableData& operator=(const TableData& ndarray)
-  {
-    if (this == &ndarray)
-      return *this;
-    delete[] mData;
-    if (ndarray.mData) {
-      mSize = ndarray.size();
-      unsigned totalLen = product(mSize);
-      if (0 < totalLen) {
-        mData = new real_type[totalLen];
-        for (unsigned i = 0; i < totalLen; ++i)
-          mData[i] = ndarray.mData[i];
-      } else {
-        mData = 0;
-      }
-    } else {
-      mData = 0;
-    }
-    return *this;
-  }
-
   const SizeVector& size(void) const
   { return mSize; }
   unsigned size(unsigned i) const
@@ -201,7 +171,7 @@
     return value;
   }
 
-  real_type* mData;
+  std::vector<real_type> mData;
   SizeVector mSize;
 };
 



From frohlich at mail.berlios.de  Sat Aug  8 14:53:15 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 8 Aug 2009 14:53:15 +0200
Subject: [OpenFDM-svn] r1078 - branches/OpenFDM-StateSeparation/src/JSBSim
Message-ID: <200908081253.n78CrFOt012868@sheep.berlios.de>

Author: frohlich
Date: 2009-08-08 14:53:14 +0200 (Sat, 08 Aug 2009)
New Revision: 1078

Modified:
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.h
Log:
various small updates.

M    JSBSim/JSBSimReader.cpp
M    JSBSim/JSBSimReader.h


Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp	2009-08-08 12:52:03 UTC (rev 1077)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp	2009-08-08 12:53:14 UTC (rev 1078)
@@ -348,14 +348,14 @@
   const XMLElement* propulsionElem = topElem->getElement("propulsion");
   if (propulsionElem) {
     if (!convertPropulsion(propulsionElem))
-      return error("Cannot convert PROPULSION data");
+      return error("Cannot convert propulsion data");
   }
   
   // Convert the aerodynamic force.
   const XMLElement* aeroElem = topElem->getElement("aerodynamics");
   if (aeroElem) {
     if (!convertAerodynamics(aeroElem))
-      return error("Cannot convert AERODYNAMICS elements");
+      return error("Cannot convert aerodynamics elements");
   }
 
   return true;
@@ -1085,16 +1085,16 @@
     if (!convertTurbine(engineTopElem, number, loc, orientation, 0))
       return error("Error readinge turbine configuration");
     
-//   } else if (engineTopElem->getName() == "piston_engine") {
-//     if (!convertPiston(engineTopElem, number, 0))
-//       return error("Error readinge piston configuration");
+  } else if (engineTopElem->getName() == "piston_engine") {
+    if (!convertPiston(engineTopElem, number, 0))
+      return error("Error readinge piston configuration");
 
 //   } else if (engineTopElem->getName() == "rocket_engine") {
 //     return error("FG_ROCKET's are not (yet?) supported!");
 
-//   } else if (engineTopElem->getName() == "electric_engine") {
-//     if (!convertElectric(engineTopElem, number, 0))
-//       return error("Error readinge electric configuration");
+  } else if (engineTopElem->getName() == "electric_engine") {
+    if (!convertElectric(engineTopElem, number, 0))
+      return error("Error readinge electric configuration");
 
   } else
     return error("Unknown toplevel xml element for engine file \""
@@ -1221,21 +1221,23 @@
   return true;
 }
 
-// bool
-// JSBSimReader::convertElectric(const XMLElement* turbine,
-//                               const std::string& number,
-//                               const Port* thrusterDriver)
-// {
-//   return true;
-// }
+bool
+JSBSimReader::convertElectric(const XMLElement* turbine,
+                              const std::string& number,
+                              const Port* thrusterDriver)
+{
+  std::cout << "Skipping electric engine!" << std::endl;
+  return true;
+}
 
-// bool
-// JSBSimReader::convertPiston(const XMLElement* turbine,
-//                             const std::string& number,
-//                             const Port* thrusterDriver)
-// {
-//   return true;
-// }
+bool
+JSBSimReader::convertPiston(const XMLElement* turbine,
+                            const std::string& number,
+                            const Port* thrusterDriver)
+{
+  std::cout << "Skipping piston engine!" << std::endl;
+  return true;
+}
 
 bool
 JSBSimReader::convertFCSList(const XMLElement* fcsElem)
@@ -1621,7 +1623,8 @@
       addMultiBodyModel(prod);
       std::list<const Port*> inputs = readFunctionInputs(*it, name);
       if (inputs.empty())
-        return error("Cannot read product inputs!");
+        return error("Cannot read product inputs of function \"" + bindName
+                     + "\"!");
       unsigned i = 0;
       std::list<const Port*>::iterator iit = inputs.begin();
       while (iit != inputs.end()) {
@@ -1630,12 +1633,12 @@
       }
       port = prod->getPort("output");
     } else {
-      return error("Unknown tag in function");
+      return error("Unknown tag in function \"" + bindName + "\"!");
     }
   }
 
   if (!port)
-    return error("function without output!");
+    return error("function without output \"" + bindName + "\"!");
 
   registerJSBExpression(bindName, port);
   if (sum) {
@@ -1838,6 +1841,7 @@
     if (!stream)
       break;
     lookup[0].insert(val);
+    ++rows;
 
     for (unsigned i = 0; i < cols; ++i) {
       stream >> val;
@@ -1861,7 +1865,7 @@
     }
   }
 
-  return lookup[0].size() == data.size(1) && lookup[1].size() == data.size(2);
+  return lookup[0].size() == data.size(0) && lookup[1].size() == data.size(1);
 }
 
 bool

Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.h	2009-08-08 12:52:03 UTC (rev 1077)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.h	2009-08-08 12:53:14 UTC (rev 1078)
@@ -50,6 +50,10 @@
   bool convertTurbine(const XMLElement* turbine, const std::string& number,
                       const Vector3& pos, const Quaternion& orientation,
                       const Port* thrusterDriver);
+  bool convertElectric(const XMLElement* turbine, const std::string& number,
+                       const Port* thrusterDriver);
+  bool convertPiston(const XMLElement* turbine, const std::string& number,
+                     const Port* thrusterDriver);
   bool convertAerodynamics(const XMLElement* aero);
   bool convertFunction(const XMLElement* function, Summer* sum);
   std::list<const Port*> readFunctionInputs(const XMLElement* operationTag,



From frohlich at mail.berlios.de  Sat Aug  8 15:08:08 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 8 Aug 2009 15:08:08 +0200
Subject: [OpenFDM-svn] r1079 - branches/OpenFDM-StateSeparation/src/JSBSim
Message-ID: <200908081308.n78D88mc014961@sheep.berlios.de>

Author: frohlich
Date: 2009-08-08 15:08:07 +0200 (Sat, 08 Aug 2009)
New Revision: 1079

Modified:
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimAerodynamic.cpp
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimAerodynamic.h
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp
Log:
Use constants defined in the aerodynamic subblock.

M    JSBSim/JSBSimAerodynamic.cpp
M    JSBSim/JSBSimAerodynamic.h
M    JSBSim/JSBSimReader.cpp


Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimAerodynamic.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimAerodynamic.cpp	2009-08-08 12:53:14 UTC (rev 1078)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimAerodynamic.cpp	2009-08-08 13:08:07 UTC (rev 1079)
@@ -40,14 +40,6 @@
   mGroup->connect(mChordModel->getPort("output"),
                   mChordOutputModel->getPort("input"));
 
-  mWingIncidenceModel = new ConstModel("Wing Incidence Constant", 0);
-  mGroup->addChild(mWingIncidenceModel);
-  mWingIncidenceOutputModel = new GroupOutput("Wing Incidence Output");
-  mGroup->addChild(mWingIncidenceOutputModel);
-  mWingIncidenceOutputModel->setExternalPortName("wingIncidence");
-  mGroup->connect(mWingIncidenceModel->getPort("output"),
-                  mWingIncidenceOutputModel->getPort("input"));
-
   mHTailAreaModel = new ConstModel("HTailArea Constant", 0);
   mGroup->addChild(mHTailAreaModel);
   mHTailAreaOutputModel = new GroupOutput("HTailArea Output");
@@ -401,18 +393,6 @@
 }
 
 void
-JSBSimAerodynamic::setWingIncidence(const real_type& wingIncidence)
-{
-  mWingIncidenceModel->setScalarValue(wingIncidence);
-}
-
-const Port*
-JSBSimAerodynamic::getWingIncidencePort(void)
-{
-  return mGroup->getPort(mWingIncidenceOutputModel->getExternalPortIndex());
-}
-
-void
 JSBSimAerodynamic::setHTailArea(const real_type& hTailArea)
 {
   mHTailAreaModel->setScalarValue(hTailArea);

Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimAerodynamic.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimAerodynamic.h	2009-08-08 12:53:14 UTC (rev 1078)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimAerodynamic.h	2009-08-08 13:08:07 UTC (rev 1079)
@@ -35,9 +35,6 @@
   void setChord(const real_type& chord);
   const Port* getChordPort(void);
 
-  void setWingIncidence(const real_type& wingIncidence);
-  const Port* getWingIncidencePort(void);
-
   void setHTailArea(const real_type& hTailArea);
   const Port* getHTailAreaPort(void);
 
@@ -99,9 +96,6 @@
   SharedPtr<ConstModel> mChordModel;
   SharedPtr<GroupOutput> mChordOutputModel;
 
-  SharedPtr<ConstModel> mWingIncidenceModel;
-  SharedPtr<GroupOutput> mWingIncidenceOutputModel;
-
   SharedPtr<ConstModel> mHTailAreaModel;
   SharedPtr<GroupOutput> mHTailAreaOutputModel;
 

Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp	2009-08-08 12:53:14 UTC (rev 1078)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp	2009-08-08 13:08:07 UTC (rev 1079)
@@ -380,40 +380,28 @@
   real_type chord = realData(metricsElem->getElement("chord"), 0);
   mAeroForce->setChord(Unit::foot().convertFrom(chord));
 
-  // FIXME alphaw from aerodynamic = alpha + iw is missing
   real_type iw = realData(metricsElem->getElement("wing_incidence"), 0);
-  mAeroForce->setWingIncidence(Unit::degree().convertFrom(iw));
-  registerJSBExpression("metrics/iw-rad", mAeroForce->getWingIncidencePort());
-//   registerJSBExpression("metrics/iw-deg", mAeroForce->getWingIncidencePort());
+  const Port* iwPort = addMultiBodyConstModel("Wing Incidence", iw);
+  registerJSBExpression("metrics/iw-rad", iwPort);
 
-  const XMLElement* htareaElem = metricsElem->getElement("htailarea");
-  if (htareaElem) {
-    real_type htailarea = realData(htareaElem, 0);
-    const Port* port = addMultiBodyConstModel("HTail Area Constant", htailarea);
-    registerJSBExpression("metrics/Sh-sqft", port);
-  }
+  Summer* summer = new Summer("Alpha Wing Incidence");
+  summer->setNumSummands(2);
+  addMultiBodyModel(summer);
+  connectJSBExpression("metrics/iw-rad", summer->getInputPort(0));
+  connectJSBExpression("aero/alpha-rad", summer->getInputPort(1));
+  registerJSBExpression("aero/alpha-wing-rad", summer->getOutputPort());
 
-  const XMLElement* htarmElem = metricsElem->getElement("htailarm");
-  if (htarmElem) {
-    real_type htailarm = realData(htarmElem, 0);
-    const Port* port = addMultiBodyConstModel("HTail Arm Constant", htailarm);
-    registerJSBExpression("metrics/lh-ft", port);
-  }
+  real_type htailarea = realData(metricsElem->getElement("htailarea"), 0);
+  mAeroForce->setHTailArea(htailarea);
 
-  const XMLElement* vtareaElem = metricsElem->getElement("vtailarea");
-  if (vtareaElem) {
-    real_type vtailarea = realData(vtareaElem, 0);
-    const Port* port = addMultiBodyConstModel("VTail Area Constant", vtailarea);
-    registerJSBExpression("metrics/Sv-sqft", port);
-  }
+  real_type htailarm = realData(metricsElem->getElement("htailarm"), 0);
+  mAeroForce->setHTailArm(htailarm);
 
-  const XMLElement* vtarmElem = metricsElem->getElement("vtailarm");
-  if (vtarmElem) {
-    real_type vtailarm = realData(vtarmElem, 0);
-    const Port* port = addMultiBodyConstModel("VTail Arm Constant", vtailarm);
-    registerJSBExpression("metrics/lv-ft", port);
-  }
+  real_type vtailarea = realData(metricsElem->getElement("vtailarea"), 0);
+  mAeroForce->setVTailArea(vtailarea);
 
+  real_type vtailarm = realData(metricsElem->getElement("vtailarm"), 0);
+  mAeroForce->setVTailArm(vtailarm);
 
   std::list<const XMLElement*> locList = metricsElem->getElements("location");
   Vector3 ap = locationData(locList, "AERORP", Vector3(0, 0, 0));



From frohlich at mail.berlios.de  Sat Aug  8 16:15:23 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 8 Aug 2009 16:15:23 +0200
Subject: [OpenFDM-svn] r1080 - branches/OpenFDM-StateSeparation/src/JSBSim
Message-ID: <200908081415.n78EFNAm023252@sheep.berlios.de>

Author: frohlich
Date: 2009-08-08 16:15:23 +0200 (Sat, 08 Aug 2009)
New Revision: 1080

Modified:
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp
Log:
Prepare for more tags.

M    JSBSimReader.cpp


Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp	2009-08-08 13:08:07 UTC (rev 1079)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp	2009-08-08 14:15:23 UTC (rev 1080)
@@ -344,12 +344,28 @@
       return error("Cannot convert ground_reactions");
   }
 
+  // external_reactions - neat
+  const XMLElement* externalReactionsElem = topElem->getElement("external_reactions");
+  if (externalReactionsElem) {
+    std::cout << "Ignoring external_reactions section" << std::endl;
+//     if (!convertGroundReactionsElem(groundReactionsElem))
+//       return error("Cannot convert ground_reactions");
+  }
+
   // Parse the propulsion section.
   const XMLElement* propulsionElem = topElem->getElement("propulsion");
   if (propulsionElem) {
     if (!convertPropulsion(propulsionElem))
       return error("Cannot convert propulsion data");
   }
+
+  // Include the system tags.
+  std::list<const XMLElement*> systemElems = topElem->getElements("system");
+  if (!systemElems.empty()) {
+    std::cout << "Ignoring system sections" << std::endl;
+//     if (!convertPropulsion(propulsionElem))
+//       return error("Cannot convert propulsion data");
+  }
   
   // Convert the aerodynamic force.
   const XMLElement* aeroElem = topElem->getElement("aerodynamics");
@@ -1518,9 +1534,30 @@
 
     out = model->getPort("output");
 
+  } else if (type == "FCS_FUNCTION" || type == "fcs_function") {
+    SharedPtr<Summer> summer = new Summer(name);
+    addFCSModel(summer);
+    
+    if (!convertFunction(fcsComponent->getElement("function"), summer))
+      return error("could not read fcs_function \"" + name + "\"");
+    model = summer;
+    out = summer->getOutputPort();
+
+  } else if (type == "PID" || type == "pid") {
+    std::cout << "Ignoring PID" << std::endl;
+
+  } else if (type == "PROPERTY" || type == "property") {
+    std::cout << "Ignoring PROPERTY" << std::endl;
+
   } else if (type == "SENSOR" || type == "sensor") {
     std::cout << "Ignoring SENSOR" << std::endl;
 
+  } else if (type == "ACCELEROMETER" || type == "accelerometer") {
+    std::cout << "Ignoring ACCELEROMETER" << std::endl;
+
+  } else if (type == "ACTUATOR" || type == "actuator") {
+    std::cout << "Ignoring ACTUATOR" << std::endl;
+
   } else
     return error("Unknown FCS COMPONENT type: \"" + type
                  + "\". Ignoring whole FCS component \"" + name + "\"" );



From frohlich at mail.berlios.de  Sun Aug  9 12:43:18 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 9 Aug 2009 12:43:18 +0200
Subject: [OpenFDM-svn] r1081 - branches/OpenFDM-StateSeparation/src/JSBSim
Message-ID: <200908091043.n79AhIn0026463@sheep.berlios.de>

Author: frohlich
Date: 2009-08-09 12:43:16 +0200 (Sun, 09 Aug 2009)
New Revision: 1081

Modified:
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.cpp
Log:
Avoid crashing due to out of range substring access.

M    JSBSimReaderBase.cpp


Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.cpp	2009-08-08 14:15:23 UTC (rev 1080)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.cpp	2009-08-09 10:43:16 UTC (rev 1081)
@@ -293,7 +293,7 @@
   // input property. If so, it schedules and registers a discrete input model.
   // If the propName points directly into the controls directory,
   // schedule an input
-  if (propName.substr(0, 9) == "controls/") {
+  if (propName.find("controls/") == 0) {
 //     std::string inputName = propName.substr(propName.rfind('/'));
     std::string inputName = propName;
     return addInputModel("Control " + inputName, propName);
@@ -331,7 +331,7 @@
       // if this is replaced note that the above line needs to be chenged too
       port = addInputModel("Rudder", "controls/flight/rudder");
 
-    } else if (propName.substr(0, 28) == "fdm/jsbsim/fcs/steer-pos-deg") {
+    } else if (propName.find("fdm/jsbsim/fcs/steer-pos-deg") == 0) {
       return lookupJSBExpression("fcs/steer-cmd-norm", path);
 
     } else if (propName == "fdm/jsbsim/fcs/flap-cmd-norm") {
@@ -347,34 +347,39 @@
                            "controls/flight/spoiler");
 
 
-    } else if (propName.substr(0, 32) == "fdm/jsbsim/fcs/throttle-cmd-norm") {
+    } else if (propName.find("fdm/jsbsim/fcs/throttle-cmd-norm") == 0) {
       std::string control = "controls/engines/engine" +
         propName.substr(32) + "/throttle";
       port = addInputModel("Throttle Input " + propName.substr(32),
                            control);
 
-    } else if (propName.substr(0, 32) == "fdm/jsbsim/fcs/throttle-pos-norm") {
+    } else if (propName.find("fdm/jsbsim/fcs/throttle-pos-norm") == 0) {
       std::string cmd = "fcs/throttle-cmd-norm" + propName.substr(32);
       return lookupJSBExpression(cmd, path);
 
 
-    } else if (propName.substr(0, 31) == "fdm/jsbsim/fcs/mixture-cmd-norm") {
+    } else if (propName.find("fdm/jsbsim/fcs/mixture-cmd-norm") == 0) {
       std::string control = "controls/engines/engine" + 
         propName.substr(31) + "/mixture";
-      port = addInputModel("Mixture Input " + propName.substr(32, 1), control);
+      std::string number = "0";
+      if (32 <= propName.size())
+        number = propName.substr(32, 1);
+      port = addInputModel("Mixture Input " + number, control);
 
-    } else if (propName.substr(0, 31) == "fdm/jsbsim/fcs/mixture-pos-norm") {
+    } else if (propName.find("fdm/jsbsim/fcs/mixture-pos-norm") == 0) {
       std::string cmd = "fcs/mixture-cmd-norm" + propName.substr(31);
       return lookupJSBExpression(cmd, path);
 
 
-    } else if (propName.substr(0, 31) == "fdm/jsbsim/fcs/advance-cmd-norm") {
+    } else if (propName.find("fdm/jsbsim/fcs/advance-cmd-norm") == 0) {
       std::string control = "controls/engines/engine" + 
         propName.substr(31) + "/propeller-pitch";
-      port = addInputModel("Propeller Pitch Input " + propName.substr(32, 1),
-                           control);
+      std::string number = "0";
+      if (32 <= propName.size())
+        number = propName.substr(32, 1);
+      port = addInputModel("Propeller Pitch Input " + number, control);
 
-    } else if (propName.substr(0, 31) == "fdm/jsbsim/fcs/advance-pos-norm") {
+    } else if (propName.find("fdm/jsbsim/fcs/advance-pos-norm") == 0) {
       std::string cmd = "fcs/advance-cmd-norm" + propName.substr(31);
       return lookupJSBExpression(cmd, path);
 
@@ -466,7 +471,7 @@
       port = lookupJSBExpression("fcs/rudder-pos-rad", path, false);
       port = addToUnit("rudder-pos-deg unit", Unit::degree(), port);
 
-    } else if (propName.substr(0, 19) == "fdm/jsbsim/fcs/mag-") {
+    } else if (propName.find("fdm/jsbsim/fcs/mag-") == 0) {
       // Special absolute modules for fcs/mag-*
       // remove the 'mag-' substring here and use that as input for the
       // Abs block



From frohlich at mail.berlios.de  Sun Aug  9 12:44:35 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 9 Aug 2009 12:44:35 +0200
Subject: [OpenFDM-svn] r1082 - branches/OpenFDM-StateSeparation/src/JSBSim
Message-ID: <200908091044.n79AiZdL027383@sheep.berlios.de>

Author: frohlich
Date: 2009-08-09 12:44:30 +0200 (Sun, 09 Aug 2009)
New Revision: 1082

Modified:
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp
Log:
Add property tag handling.

M    src/JSBSim/JSBSimReader.cpp


Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp	2009-08-09 10:43:16 UTC (rev 1081)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp	2009-08-09 10:44:30 UTC (rev 1082)
@@ -55,11 +55,9 @@
 namespace OpenFDM {
 
 static real_type
-realData(const XMLElement* element, real_type def = 0)
+asciiToReal(const std::string& s, const real_type& def = 0)
 {
-  if (!element)
-    return def;
-  std::stringstream stream(element->getData());
+  std::stringstream stream(s);
   real_type value;
   stream >> value;
   if (!stream)
@@ -67,6 +65,14 @@
   return value;
 }
 
+static real_type
+realData(const XMLElement* element, real_type def = 0)
+{
+  if (!element)
+    return def;
+  return asciiToReal(element->getData(), def);
+}
+
 static Vector3
 locationData(const XMLElement* element, const Vector3& def = Vector3(0, 0, 0))
 {
@@ -1547,7 +1553,13 @@
     std::cout << "Ignoring PID" << std::endl;
 
   } else if (type == "PROPERTY" || type == "property") {
-    std::cout << "Ignoring PROPERTY" << std::endl;
+    name = fcsComponent->getData();
+    real_type value = asciiToReal(fcsComponent->getAttribute("value"), 0);
+    SharedPtr<ConstModel> constModel;
+    constModel = new ConstModel("Property " + name, value);
+    addFCSModel(constModel);
+    model = constModel;
+    out = constModel->getPort("output");
 
   } else if (type == "SENSOR" || type == "sensor") {
     std::cout << "Ignoring SENSOR" << std::endl;
@@ -1563,8 +1575,9 @@
                  + "\". Ignoring whole FCS component \"" + name + "\"" );
 
   // Register all output property names.
-  std::string implicitOutname = normalizeComponentName(name);
-  registerJSBExpression(std::string("fcs/") + implicitOutname, out);
+  std::string implicitOutname = std::string("fcs/")
+    + normalizeComponentName(name);
+  registerJSBExpression(implicitOutname, out);
   if (fcsComponent->getElement("output")) {
     std::string outname = stringData(fcsComponent->getElement("output"));
     if (outname != implicitOutname)



From frohlich at mail.berlios.de  Sun Aug  9 12:58:52 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 9 Aug 2009 12:58:52 +0200
Subject: [OpenFDM-svn] r1083 - branches/OpenFDM-StateSeparation/src/JSBSim
Message-ID: <200908091058.n79Awq96010272@sheep.berlios.de>

Author: frohlich
Date: 2009-08-09 12:58:43 +0200 (Sun, 09 Aug 2009)
New Revision: 1083

Modified:
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp
Log:
Implement reading abs functions.

M    JSBSimReader.cpp


Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp	2009-08-09 10:44:30 UTC (rev 1082)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp	2009-08-09 10:58:43 UTC (rev 1083)
@@ -1698,12 +1698,22 @@
   std::list<const XMLElement*>::const_iterator ait;
   for (ait = args.begin(); ait != args.end(); ++ait) {
     if ((*ait)->getName() == "value") {
-      std::stringstream stream((*ait)->getData());
-      real_type value;
-      stream >> value;
+      real_type value = asciiToReal((*ait)->getData());
       inputs.push_back(addMultiBodyConstModel(name + " Constant", value));
     } else if ((*ait)->getName() == "property") {
       inputs.push_back(lookupJSBExpression(stringData(*ait), path));
+    } else if ((*ait)->getName() == "abs") {
+      std::list<const Port*> absInput = readFunctionInputs(*ait, "abs-" + name);
+      if (absInput.size() != 1) {
+          error("abs function inputtag must have 2DTable data does not have 2 inputs!");
+          return std::list<const Port*>();
+      }
+      
+      SharedPtr<UnaryFunction> absModel;
+      absModel = new UnaryFunction("Abs " + name, UnaryFunction::Abs);
+      addMultiBodyModel(absModel);
+      mTopLevelGroup->connect(absInput.front(), absModel->getInputPort(0));
+      inputs.push_back(absModel->getOutputPort());
     } else if ((*ait)->getName() == "table") {
       unsigned dim = getNumTableDims(*ait);
       if (dim == 1) {



From frohlich at mail.berlios.de  Sun Aug  9 13:16:32 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 9 Aug 2009 13:16:32 +0200
Subject: [OpenFDM-svn] r1084 - branches/OpenFDM-StateSeparation/src/JSBSim
Message-ID: <200908091116.n79BGWjs002757@sheep.berlios.de>

Author: frohlich
Date: 2009-08-09 13:16:31 +0200 (Sun, 09 Aug 2009)
New Revision: 1084

Modified:
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.cpp
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.h
Log:
Reenable brakepoint lookup reuse.

M    JSBSimReaderBase.cpp
M    JSBSimReaderBase.h


Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.cpp	2009-08-09 10:58:43 UTC (rev 1083)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.cpp	2009-08-09 11:16:31 UTC (rev 1084)
@@ -852,13 +852,11 @@
 
   // First check if we already have a table lookup for this port/brakepoint
   // combination. If so return that output port
-  // FIXME: cannot share the brakepoint lookups ???
-//   std::vector<SharedPtr<BreakPointLookup> >::iterator it;
-//   for (it = mBreakPointVectors.begin(); it != mBreakPointVectors.end(); ++it) {
-//     if (tl == (*it)->getBreakPointVector() &&
-//         in->getPortInterface() == (*it)->getPort("input")->getPortInterface())
-//       return (*it)->getPort("output");
-//   }
+  std::vector<BreakPointLookupEntry>::iterator it;
+  for (it = mBreakPointVectors.begin(); it != mBreakPointVectors.end(); ++it) {
+    if (tl == it->lookup->getBreakPointVector() && in == it->inputConnection)
+      return it->lookup->getPort("output");
+  }
 
   // No sharable table lookup found, we need to create a new one
   BreakPointLookup* tablePreLookup
@@ -866,7 +864,7 @@
   addMultiBodyModel(tablePreLookup);
   tablePreLookup->setBreakPointVector(tl);
   mTopLevelGroup->connect(in, tablePreLookup->getInputPort(0));
-  mBreakPointVectors.push_back(tablePreLookup);
+  mBreakPointVectors.push_back(BreakPointLookupEntry(in, tablePreLookup));
   return tablePreLookup->getOutputPort();
 }
 

Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.h	2009-08-09 10:58:43 UTC (rev 1083)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.h	2009-08-09 11:16:31 UTC (rev 1084)
@@ -265,7 +265,8 @@
   const Port* addMultiBodyConstModel(const std::string& name, real_type value);
   void addMultiBodyModel(Node* model);
   /// </FIXME> document and rethink
-  const Port* getTablePrelookup(const std::string& name, const Port* in, const BreakPointVector& tl);
+  const Port* getTablePrelookup(const std::string& name, const Port* in,
+                                const BreakPointVector& tl);
   /// List for the aircraft search path.
   std::list<std::string> mAircraftPath;
   /// List for the engine search path.
@@ -275,7 +276,13 @@
   PropertyMap mExpressionTable;
   SharedPtr<JSBSimAerodynamic> mAeroForce;
   SharedPtr<RigidBody> mTopLevelBody;
-  std::vector<SharedPtr<BreakPointLookup> > mBreakPointVectors;
+  struct BreakPointLookupEntry {
+    BreakPointLookupEntry(const Port* in = 0, BreakPointLookup* tl = 0) :
+      inputConnection(in), lookup(tl) {}
+    SharedPtr<const Port> inputConnection;
+    SharedPtr<BreakPointLookup> lookup;
+  };
+  std::vector<BreakPointLookupEntry> mBreakPointVectors;
 
   // For now just copies from the prevous try ...
   Vector3 structToBody(const Vector3& v)



From frohlich at mail.berlios.de  Sun Aug  9 13:32:22 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 9 Aug 2009 13:32:22 +0200
Subject: [OpenFDM-svn] r1085 - branches/OpenFDM-StateSeparation/src/JSBSim
Message-ID: <200908091132.n79BWM2l002603@sheep.berlios.de>

Author: frohlich
Date: 2009-08-09 13:32:21 +0200 (Sun, 09 Aug 2009)
New Revision: 1085

Modified:
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp
Log:
Make the fake engine model initialize.

M    src/JSBSim/JSBSimReader.cpp


Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp	2009-08-09 11:16:31 UTC (rev 1084)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp	2009-08-09 11:32:21 UTC (rev 1085)
@@ -14,20 +14,21 @@
 #include <OpenFDM/Matrix.h>
 #include <OpenFDM/Quaternion.h>
 
+#include <OpenFDM/AirSpring.h>
 #include <OpenFDM/Bias.h>
 #include <OpenFDM/ConstModel.h>
 #include <OpenFDM/DeadBand.h>
 #include <OpenFDM/Delay.h>
+#include <OpenFDM/DiscBrake.h>
 #include <OpenFDM/DiscreteIntegrator.h>
-#include <OpenFDM/TransferFunction.h>
 #include <OpenFDM/Gain.h>
 #include <OpenFDM/Input.h>
+#include <OpenFDM/InternalInteract.h>
 #include <OpenFDM/Mass.h>
 #include <OpenFDM/MaxModel.h>
+#include <OpenFDM/MatrixConcat.h>
 #include <OpenFDM/MatrixSplit.h>
 #include <OpenFDM/MobileRootJoint.h>
-#include <OpenFDM/AirSpring.h>
-#include <OpenFDM/InternalInteract.h>
 #include <OpenFDM/PrismaticJoint.h>
 #include <OpenFDM/Product.h>
 #include <OpenFDM/RevoluteActuator.h>
@@ -40,11 +41,11 @@
 #include <OpenFDM/System.h>
 #include <OpenFDM/Table.h>
 #include <OpenFDM/TimeDerivative.h>
+#include <OpenFDM/TransferFunction.h>
 #include <OpenFDM/UnaryFunction.h>
 #include <OpenFDM/Unit.h>
 #include <OpenFDM/UnitConversion.h>
 #include <OpenFDM/WheelContact.h>
-#include <OpenFDM/DiscBrake.h>
 
 #include <OpenFDM/ReaderWriter.h>
 
@@ -1207,17 +1208,31 @@
   real_type maxThrust = realData(turbine->getElement("milthrust"), 0);
 
   std::string namestr = "Engine<" + number + ">";
-  ConstModel* fullForce = new ConstModel(namestr + " full");
+  real_type fullThrustN = Unit::lbf().convertFrom(maxThrust);
+  ConstModel* fullForce = new ConstModel(namestr + " full", fullThrustN);
   addMultiBodyModel(fullForce);
-  fullForce->setValue(Vector6(0, 0, 0, Unit::lbf().convertFrom(maxThrust), 0, 0));
 
   Product* prod = new Product(namestr + " modulation");
   addMultiBodyModel(prod);
   std::string throttlename = "fcs/throttle-cmd-norm[" + number + "]";
   if (!connectJSBExpression(throttlename, prod->getPort("input0")))
     return error("could not connect to throttle command");
-  mTopLevelGroup->connect(fullForce->getPort("output"), prod->getPort("input1"));
+  mTopLevelGroup->connect(fullForce->getPort("output"),
+                          prod->getPort("input1"));
 
+  ConstModel* zeroComponent = new ConstModel(namestr + " zero", 0);
+  addMultiBodyModel(zeroComponent);
+
+  MatrixConcat* force = new MatrixConcat(namestr + " Force");
+  addMultiBodyModel(force);
+
+  mTopLevelGroup->connect(prod->getPort("output"),
+                          force->addInputPort("x"));
+  mTopLevelGroup->connect(zeroComponent->getPort("output"),
+                          force->addInputPort("y"));
+  mTopLevelGroup->connect(zeroComponent->getPort("output"),
+                          force->addInputPort("z"));
+
   ExternalInteract* engineForce = new ExternalInteract(namestr);
   mTopLevelGroup->addChild(engineForce);
   engineForce->setEnableForce(true);
@@ -1225,8 +1240,8 @@
                           engineForce->getPort("link"));
   engineForce->setPosition(pos);
   engineForce->setOrientation(orientation);
-  mTopLevelGroup->connect(prod->getPort("output"),
-                          engineForce->getPort("bodyForce"));
+  mTopLevelGroup->connect(force->getPort("output"),
+                          engineForce->getPort("force"));
 
   return true;
 }



From frohlich at mail.berlios.de  Sun Aug  9 13:51:23 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 9 Aug 2009 13:51:23 +0200
Subject: [OpenFDM-svn] r1086 - branches/OpenFDM-StateSeparation/src/JSBSim
Message-ID: <200908091151.n79BpNn6005612@sheep.berlios.de>

Author: frohlich
Date: 2009-08-09 13:51:22 +0200 (Sun, 09 Aug 2009)
New Revision: 1086

Modified:
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp
Log:
Improove expression parsing.

M    src/JSBSim/JSBSimReader.cpp


Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp	2009-08-09 11:32:21 UTC (rev 1085)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp	2009-08-09 11:51:22 UTC (rev 1086)
@@ -1665,39 +1665,15 @@
   std::string::size_type slachPos = bindName.rfind('/');
   if (slachPos != std::string::npos)
     name = name.substr(slachPos+1);
-  const Port* port = 0;
-  std::list<const XMLElement*> elems = function->getElements();
-  std::list<const XMLElement*>::const_iterator it;
-  for (it = elems.begin(); it != elems.end(); ++it) {
-    if ((*it)->getName() == "description") {
-      // Just ignore
-    } else if ((*it)->getName() == "product") {
-      SharedPtr<Product> prod = new Product(name + " product");
-      addMultiBodyModel(prod);
-      std::list<const Port*> inputs = readFunctionInputs(*it, name);
-      if (inputs.empty())
-        return error("Cannot read product inputs of function \"" + bindName
-                     + "\"!");
-      unsigned i = 0;
-      std::list<const Port*>::iterator iit = inputs.begin();
-      while (iit != inputs.end()) {
-        prod->setNumFactors(i+1);
-        mTopLevelGroup->connect(*iit++, prod->getInputPort(i++));
-      }
-      port = prod->getPort("output");
-    } else {
-      return error("Unknown tag in function \"" + bindName + "\"!");
-    }
-  }
-
-  if (!port)
+  std::list<const Port*> inputs = readFunctionInputs(function, name);
+  if (inputs.size() != 1)
     return error("function without output \"" + bindName + "\"!");
 
-  registerJSBExpression(bindName, port);
+  registerJSBExpression(bindName, inputs.front());
   if (sum) {
     unsigned num = sum->getNumSummands();
     sum->setNumSummands(num+1);
-    mTopLevelGroup->connect(port, sum->getInputPort(num));
+    mTopLevelGroup->connect(inputs.front(), sum->getInputPort(num));
   }
 
   return true;
@@ -1712,7 +1688,9 @@
   std::list<const XMLElement*> args = operationTag->getElements();
   std::list<const XMLElement*>::const_iterator ait;
   for (ait = args.begin(); ait != args.end(); ++ait) {
-    if ((*ait)->getName() == "value") {
+    if ((*ait)->getName() == "description") {
+      // Just ignore
+    } else if ((*ait)->getName() == "value") {
       real_type value = asciiToReal((*ait)->getData());
       inputs.push_back(addMultiBodyConstModel(name + " Constant", value));
     } else if ((*ait)->getName() == "property") {
@@ -1729,6 +1707,38 @@
       addMultiBodyModel(absModel);
       mTopLevelGroup->connect(absInput.front(), absModel->getInputPort(0));
       inputs.push_back(absModel->getOutputPort());
+    } else if ((*ait)->getName() == "product") {
+      SharedPtr<Product> prod = new Product(name + " product");
+      addMultiBodyModel(prod);
+      std::list<const Port*> pInputs = readFunctionInputs(*ait, name);
+      if (pInputs.empty()) {
+        error("Cannot read product inputs of function \"" + name + "\"!");
+        return std::list<const Port*>();
+      }
+      unsigned i = 0;
+      std::list<const Port*>::iterator iit = pInputs.begin();
+      while (iit != pInputs.end()) {
+        prod->setNumFactors(i+1);
+        mTopLevelGroup->connect(*iit++, prod->getInputPort(i++));
+      }
+      inputs.push_back(prod->getPort("output"));
+
+    } else if ((*ait)->getName() == "sum") {
+      SharedPtr<Summer> summer = new Summer(name + " sum");
+      addMultiBodyModel(summer);
+      std::list<const Port*> pInputs = readFunctionInputs(*ait, name);
+      if (pInputs.empty()) {
+        error("Cannot read sum inputs of function \"" + name + "\"!");
+        return std::list<const Port*>();
+      }
+      unsigned i = 0;
+      std::list<const Port*>::iterator iit = pInputs.begin();
+      while (iit != pInputs.end()) {
+        summer->setNumSummands(i+1);
+        mTopLevelGroup->connect(*iit++, summer->getInputPort(i++));
+      }
+      inputs.push_back(summer->getPort("output"));
+
     } else if ((*ait)->getName() == "table") {
       unsigned dim = getNumTableDims(*ait);
       if (dim == 1) {



From frohlich at mail.berlios.de  Sun Aug  9 14:09:59 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 9 Aug 2009 14:09:59 +0200
Subject: [OpenFDM-svn] r1087 - branches/OpenFDM-StateSeparation/src/JSBSim
Message-ID: <200908091209.n79C9xuD007691@sheep.berlios.de>

Author: frohlich
Date: 2009-08-09 14:09:59 +0200 (Sun, 09 Aug 2009)
New Revision: 1087

Modified:
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.h
Log:
Add an other yet unhandled engine.

M    src/JSBSim/JSBSimReader.cpp
M    src/JSBSim/JSBSimReader.h


Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp	2009-08-09 11:51:22 UTC (rev 1086)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp	2009-08-09 12:09:59 UTC (rev 1087)
@@ -1096,6 +1096,10 @@
     if (!convertTurbine(engineTopElem, number, loc, orientation, 0))
       return error("Error readinge turbine configuration");
     
+  } else if (engineTopElem->getName() == "turboprop_engine") {
+    if (!convertTurboProp(engineTopElem, number, loc, orientation, 0))
+      return error("Error readinge turbine configuration");
+    
   } else if (engineTopElem->getName() == "piston_engine") {
     if (!convertPiston(engineTopElem, number, 0))
       return error("Error readinge piston configuration");
@@ -1247,6 +1251,17 @@
 }
 
 bool
+JSBSimReader::convertTurboProp(const XMLElement* turbine,
+                               const std::string& number,
+                               const Vector3& pos,
+                               const Quaternion& orientation,
+                               const Port* thrusterDriver)
+{
+  std::cout << "Skipping turboprop engine!" << std::endl;
+  return true;
+}
+
+bool
 JSBSimReader::convertElectric(const XMLElement* turbine,
                               const std::string& number,
                               const Port* thrusterDriver)

Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.h	2009-08-09 11:51:22 UTC (rev 1086)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.h	2009-08-09 12:09:59 UTC (rev 1087)
@@ -50,6 +50,9 @@
   bool convertTurbine(const XMLElement* turbine, const std::string& number,
                       const Vector3& pos, const Quaternion& orientation,
                       const Port* thrusterDriver);
+  bool convertTurboProp(const XMLElement* turbine, const std::string& number,
+                        const Vector3& pos, const Quaternion& orientation,
+                        const Port* thrusterDriver);
   bool convertElectric(const XMLElement* turbine, const std::string& number,
                        const Port* thrusterDriver);
   bool convertPiston(const XMLElement* turbine, const std::string& number,



From frohlich at mail.berlios.de  Sun Aug  9 14:33:56 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 9 Aug 2009 14:33:56 +0200
Subject: [OpenFDM-svn] r1088 - in branches/OpenFDM-StateSeparation/src:
	JSBSim OpenFDM
Message-ID: <200908091233.n79CXu9C009847@sheep.berlios.de>

Author: frohlich
Date: 2009-08-09 14:33:56 +0200 (Sun, 09 Aug 2009)
New Revision: 1088

Modified:
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimAerodynamic.cpp
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimAerodynamic.h
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/ExternalInteract.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/ExternalInteract.h
Log:
Add ground speed sensing.

M    src/JSBSim/JSBSimAerodynamic.cpp
M    src/JSBSim/JSBSimReaderBase.cpp
M    src/JSBSim/JSBSimAerodynamic.h
M    src/OpenFDM/ExternalInteract.h
M    src/OpenFDM/ExternalInteract.cpp


Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimAerodynamic.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimAerodynamic.cpp	2009-08-09 12:09:59 UTC (rev 1087)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimAerodynamic.cpp	2009-08-09 12:33:56 UTC (rev 1088)
@@ -155,6 +155,13 @@
   mGroup->connect(windAxis->getPort("airSpeed"),
                   mTrueAirSpeedOutputModel->getPort("input"));
 
+  mGroundSpeedOutputModel = new GroupOutput("Ground Speed Output");
+  mGroup->addChild(mGroundSpeedOutputModel);
+  mGroundSpeedOutputModel->setExternalPortName("groundSpeed");
+  mExternalInteract->setEnableGroundSpeed(true);
+  mGroup->connect(mExternalInteract->getPort("groundSpeed"),
+                  mGroundSpeedOutputModel->getPort("input"));
+
   mCalibratedAirSpeedOutputModel = new GroupOutput("Calibrated Air Speed Output");
   mGroup->addChild(mCalibratedAirSpeedOutputModel);
   mCalibratedAirSpeedOutputModel->setExternalPortName("calibratedAirSpeed");
@@ -471,6 +478,12 @@
 }
 
 const Port*
+JSBSimAerodynamic::getGroundSpeedPort(void)
+{
+  return mGroup->getPort(mGroundSpeedOutputModel->getExternalPortIndex());
+}
+
+const Port*
 JSBSimAerodynamic::getCalibratedAirSpeedPort(void)
 {
   return mGroup->getPort(mCalibratedAirSpeedOutputModel->getExternalPortIndex());

Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimAerodynamic.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimAerodynamic.h	2009-08-09 12:09:59 UTC (rev 1087)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimAerodynamic.h	2009-08-09 12:33:56 UTC (rev 1088)
@@ -52,6 +52,7 @@
   const Port* getBetaPort(void);
   const Port* getBetaDotPort(void);
   const Port* getTrueAirSpeedPort(void);
+  const Port* getGroundSpeedPort(void);
   const Port* getCalibratedAirSpeedPort(void);
   const Port* getEquivalentAirSpeedPort(void);
   const Port* getMachPort(void);
@@ -113,6 +114,7 @@
   SharedPtr<GroupOutput> mBetaOutputModel;
   SharedPtr<GroupOutput> mBetaDotOutputModel;
   SharedPtr<GroupOutput> mTrueAirSpeedOutputModel;
+  SharedPtr<GroupOutput> mGroundSpeedOutputModel;
   SharedPtr<GroupOutput> mCalibratedAirSpeedOutputModel;
   SharedPtr<GroupOutput> mEquivalentAirSpeedOutputModel;
   SharedPtr<GroupOutput> mMachOutputModel;

Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.cpp	2009-08-09 12:09:59 UTC (rev 1087)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.cpp	2009-08-09 12:33:56 UTC (rev 1088)
@@ -615,6 +615,12 @@
   } else if (propName == "fdm/jsbsim/velocities/pt-lbs_sqft") {
     port = lookupJSBExpression("propulsion/pt-lbs_sqft", path);
 
+  } else if (propName == "fdm/jsbsim/velocities/vg-mps") {
+    port = mAeroForce->getGroundSpeedPort();
+  } else if (propName == "fdm/jsbsim/velocities/vg-fps") {
+    port = mAeroForce->getGroundSpeedPort();
+    port = addToUnit("Ground Speed fps", Unit::footPerSecond(), port);
+
   } else if (propName == "fdm/jsbsim/aero/alpha-rad") {
     port = mAeroForce->getAlphaPort();
   } else if (propName == "fdm/jsbsim/aero/mag-alpha-rad") {

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/ExternalInteract.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ExternalInteract.cpp	2009-08-09 12:09:59 UTC (rev 1087)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ExternalInteract.cpp	2009-08-09 12:33:56 UTC (rev 1088)
@@ -24,6 +24,7 @@
   DEF_OPENFDM_PROPERTY(Bool, EnableAngularAcceleration, Serialized)
   DEF_OPENFDM_PROPERTY(Bool, EnableLinearWindVelocity, Serialized)
   DEF_OPENFDM_PROPERTY(Bool, EnableAngularWindVelocity, Serialized)
+  DEF_OPENFDM_PROPERTY(Bool, EnableGroundSpeed, Serialized)
   DEF_OPENFDM_PROPERTY(Bool, EnableTemperature, Serialized)
   DEF_OPENFDM_PROPERTY(Bool, EnableStaticPressure, Serialized)
   DEF_OPENFDM_PROPERTY(Bool, EnableDensity, Serialized)
@@ -51,6 +52,7 @@
     mAngularAcceleration(portValueList.getPortValue(externalInteract->mAngularAccelerationPort)),
     mLinearWindVelocity(portValueList.getPortValue(externalInteract->mLinearWindVelocityPort)),
     mAngularWindVelocity(portValueList.getPortValue(externalInteract->mAngularWindVelocityPort)),
+    mGroundSpeed(portValueList.getPortValue(externalInteract->mGroundSpeedPort)),
     mTemperature(portValueList.getPortValue(externalInteract->mTemperaturePort)),
     mStaticPressure(portValueList.getPortValue(externalInteract->mStaticPressurePort)),
     mDensity(portValueList.getPortValue(externalInteract->mDensityPort)),
@@ -122,8 +124,10 @@
     bool enableAngularVelocity = mAngularVelocity.isConnected();
     bool enableLinearWindVelocity = mLinearWindVelocity.isConnected();
     bool enableAngularWindVelocity = mAngularWindVelocity.isConnected();
+    bool enableGroundSpeed = mGroundSpeed.isConnected();
     if (enableLinearVelocity || enableAngularVelocity
-        || enableLinearWindVelocity || enableAngularWindVelocity) {
+        || enableLinearWindVelocity || enableAngularWindVelocity
+        || enableGroundSpeed) {
       Vector6 refVelocity = getLink().getVelocity(mCoordinateSystem);
       if (enableLinearVelocity)
         mLinearVelocity = refVelocity.getLinear();
@@ -141,6 +145,11 @@
         if (enableAngularWindVelocity)
           mAngularWindVelocity = wind.getAngular();
       }
+
+      if (enableGroundSpeed) {
+        Plane plane = getEnvironment().getHorizontalLocalPlane(mCoordinateSystem.getPosition());
+        mGroundSpeed = norm(plane.projectToPlane(refVelocity.getLinear()));
+      }
     }
     
     // Atmosphere related sensing
@@ -235,6 +244,8 @@
   MatrixOutputPortHandle mLinearWindVelocity;
   MatrixOutputPortHandle mAngularWindVelocity;
 
+  RealOutputPortHandle mGroundSpeed;
+
   RealOutputPortHandle mTemperature;
   RealOutputPortHandle mStaticPressure;
   RealOutputPortHandle mDensity;
@@ -460,6 +471,24 @@
 }
 
 void
+ExternalInteract::setEnableGroundSpeed(bool enable)
+{
+  if (enable == getEnableGroundSpeed())
+    return;
+  if (enable)
+    mGroundSpeedPort = RealOutputPort(this, "groundSpeed");
+  else
+    mGroundSpeedPort.clear();
+}
+
+bool
+ExternalInteract::getEnableGroundSpeed() const
+{
+  return !mGroundSpeedPort.empty();
+}
+
+
+void
 ExternalInteract::setEnableTemperature(bool enable)
 {
   if (enable == getEnableTemperature())
@@ -625,6 +654,7 @@
   setEnableCentrifugalAcceleration(enable);
   setEnableLoad(enable);
   setEnableAngularAcceleration(enable);
+  setEnableGroundSpeed(enable);
   setEnableTemperature(enable);
   setEnableStaticPressure(enable);
   setEnableDensity(enable);

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/ExternalInteract.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ExternalInteract.h	2009-08-09 12:09:59 UTC (rev 1087)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ExternalInteract.h	2009-08-09 12:33:56 UTC (rev 1088)
@@ -92,6 +92,12 @@
   bool getEnableAngularWindVelocity() const;
 
 
+  /// Set availabilty of the ground speed output port
+  void setEnableGroundSpeed(bool enable);
+  /// Get availabilty of the ground speed output port
+  bool getEnableGroundSpeed() const;
+
+
   /// Set availabilty of the temperature output port
   void setEnableTemperature(bool enable);
   /// Get availabilty of the temperature output port
@@ -169,6 +175,8 @@
   MatrixOutputPort mLinearWindVelocityPort;
   MatrixOutputPort mAngularWindVelocityPort;
 
+  RealOutputPort mGroundSpeedPort;
+
   RealOutputPort mTemperaturePort;
   RealOutputPort mStaticPressurePort;
   RealOutputPort mDensityPort;



From frohlich at mail.berlios.de  Sun Aug  9 15:09:24 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 9 Aug 2009 15:09:24 +0200
Subject: [OpenFDM-svn] r1089 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200908091309.n79D9OOp013166@sheep.berlios.de>

Author: frohlich
Date: 2009-08-09 15:09:24 +0200 (Sun, 09 Aug 2009)
New Revision: 1089

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/TransferFunction.cpp
Log:
The TransferFunction has discrete state.


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/TransferFunction.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/TransferFunction.cpp	2009-08-09 12:33:56 UTC (rev 1088)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/TransferFunction.cpp	2009-08-09 13:09:24 UTC (rev 1089)
@@ -25,6 +25,8 @@
   mDen(1),
   mNum(1)
 {
+  mMatrixStateInfo = new MatrixStateInfo;
+  addDiscreteStateInfo(mMatrixStateInfo);
   mNum(0) = 1;
   mDen(0) = 1;
 }
@@ -114,7 +116,7 @@
                    << ", denominator: " << trans(mDenNorm)
                    << ", direct factor: " << mD << endl;
 
-  return true;
+  return Model::alloc(context);
 }
 
 void



From frohlich at mail.berlios.de  Wed Aug 12 20:12:41 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Wed, 12 Aug 2009 20:12:41 +0200
Subject: [OpenFDM-svn] r1090 - in branches/OpenFDM-StateSeparation/src:
	JSBSim OpenFDM
Message-ID: <200908121812.n7CICftI017903@sheep.berlios.de>

Author: frohlich
Date: 2009-08-12 20:12:40 +0200 (Wed, 12 Aug 2009)
New Revision: 1090

Added:
   branches/OpenFDM-StateSeparation/src/OpenFDM/UniqueNameVisitor.h
Modified:
   branches/OpenFDM-StateSeparation/src/JSBSim/jsb2openfdm.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
Log:
Add a step makeing the node names unique within their group.

M    OpenFDM/Makefile.am
AM   OpenFDM/UniqueNameVisitor.h
M    JSBSim/jsb2openfdm.cpp


Modified: branches/OpenFDM-StateSeparation/src/JSBSim/jsb2openfdm.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/jsb2openfdm.cpp	2009-08-09 13:09:24 UTC (rev 1089)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/jsb2openfdm.cpp	2009-08-12 18:12:40 UTC (rev 1090)
@@ -2,6 +2,7 @@
 
 #include <OpenFDM/ReaderWriter.h>
 #include <OpenFDM/System.h>
+#include <OpenFDM/UniqueNameVisitor.h>
 #include <OpenFDM/XMLDumpModelVisitor.h>
 #include "JSBSimReader.h"
 
@@ -45,7 +46,16 @@
     std::cerr << "Could not initialize aircraft system!" << std::endl;
     return EXIT_FAILURE;
   }
-  
+
+  if (!system->getNode()) {
+    std::cerr << "No model modes attached to the aircraft system!" << std::endl;
+    return EXIT_FAILURE;
+  }
+
+  // Make names in the model unique
+  OpenFDM::UniqueNameVisitor uniqueNameVisitor;
+  system->getNode()->accept(uniqueNameVisitor);
+
   // Ok, now the Vehicle here contains the imported data
   // When the reflection stuff is ready, we can dump that data to a
   // native format ...

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2009-08-09 13:09:24 UTC (rev 1089)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2009-08-12 18:12:40 UTC (rev 1090)
@@ -123,6 +123,7 @@
   TypeInfo.h \
   Types.h \
   TypeTraits.h \
+  UniqueNameVisitor.h \
   Unit.h \
   Variant.h \
   Vector.h \

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/UniqueNameVisitor.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/UniqueNameVisitor.h	2009-08-09 13:09:24 UTC (rev 1089)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/UniqueNameVisitor.h	2009-08-12 18:12:40 UTC (rev 1090)
@@ -0,0 +1,43 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2009 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_UniqueNameVisitor_H
+#define OpenFDM_UniqueNameVisitor_H
+
+#include <set>
+#include <string>
+#include <sstream>
+
+#include "Group.h"
+#include "NodeVisitor.h"
+
+namespace OpenFDM {
+
+class UniqueNameVisitor : public NodeVisitor {
+public:
+  virtual ~UniqueNameVisitor(void)
+  { }
+  virtual void apply(Group& group)
+  {
+    group.traverse(*this);
+
+    typedef std::set<std::string> NameSet;
+    NameSet nameSet;
+    for (unsigned i = 0; i < group.getNumChildren(); ++i) {
+      Node* node = group.getChild(i);
+      std::string name = node->getName();
+      unsigned counter = 0;
+      while (nameSet.find(node->getName()) != nameSet.end()) {
+        std::stringstream ss;
+        ss << name << ++counter;
+        node->setName(ss.str());
+      }
+      nameSet.insert(node->getName());
+    }
+  }
+};
+
+} // namespace OpenFDM
+
+#endif


Property changes on: branches/OpenFDM-StateSeparation/src/OpenFDM/UniqueNameVisitor.h
___________________________________________________________________
Name: svn:eol-style
   + native



From frohlich at mail.berlios.de  Thu Aug 13 20:17:47 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Thu, 13 Aug 2009 20:17:47 +0200
Subject: [OpenFDM-svn] r1091 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200908131817.n7DIHlFr004100@sheep.berlios.de>

Author: frohlich
Date: 2009-08-13 20:17:47 +0200 (Thu, 13 Aug 2009)
New Revision: 1091

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Group.cpp
Log:
Slightly better error handling.

M    Group.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Group.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Group.cpp	2009-08-12 18:12:40 UTC (rev 1090)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Group.cpp	2009-08-13 18:17:47 UTC (rev 1091)
@@ -5,6 +5,7 @@
 #include "Group.h"
 
 #include "ConstNodeVisitor.h"
+#include "LogStream.h"
 #include "NodeVisitor.h"
 #include "TypeInfo.h"
 #include "Variant.h"
@@ -172,11 +173,25 @@
 Connect*
 Group::connect(const Port* port0, const Port* port1)
 {
+  if (!port0) {
+    Log(Model, Warning) << "Port0 is zero." << std::endl;
+    return 0;
+  }
+  if (!port1) {
+    Log(Model, Warning) << "Port1 is zero." << std::endl;
+    return 0;
+  }
+
   SharedPtr<Connect> connect = new Connect(this);
-  if (!connect->setPort0(port0))
+  if (!connect->setPort0(port0)) {
+    Log(Model, Warning) << "Could not set port0" << std::endl;
     return 0;
-  if (!connect->setPort1(port1))
+  }
+  if (!connect->setPort1(port1)) {
+    Log(Model, Warning) << "Could not set port1" << std::endl;
     return 0;
+  }
+
   mConnectList.push_back(connect);
   return connect.get();
 }



From frohlich at mail.berlios.de  Thu Aug 13 21:53:47 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Thu, 13 Aug 2009 21:53:47 +0200
Subject: [OpenFDM-svn] r1093 - branches/OpenFDM-StateSeparation/src/JSBSim
Message-ID: <200908131953.n7DJrlfk015346@sheep.berlios.de>

Author: frohlich
Date: 2009-08-13 21:53:46 +0200 (Thu, 13 Aug 2009)
New Revision: 1093

Modified:
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp
Log:
Accept some more documentation tags.

M    src/JSBSim/JSBSimReader.cpp


Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp	2009-08-13 18:18:53 UTC (rev 1092)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp	2009-08-13 19:53:46 UTC (rev 1093)
@@ -999,6 +999,7 @@
       } else {
         return error("Unknown groundreactions component of type " + type);
       }
+    } else if ((*it)->getName() == "documentation") {
     } else {
       return error("Unknown groundreactions tag " + (*it)->getName());
     }
@@ -1028,6 +1029,8 @@
       if (!convertTank(*it, sstr.str()))
         return error("Cannot parse tank");
     }
+    else if ((*it)->getName() == "documentation") {
+    }
     else
       return error("Unexpected PROPULSION element \"" + (*it)->getName() + "\"");
   }



From frohlich at mail.berlios.de  Thu Aug 13 22:19:57 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Thu, 13 Aug 2009 22:19:57 +0200
Subject: [OpenFDM-svn] r1094 - branches/OpenFDM-StateSeparation/src/JSBSim
Message-ID: <200908132019.n7DKJvbd020597@sheep.berlios.de>

Author: frohlich
Date: 2009-08-13 22:19:56 +0200 (Thu, 13 Aug 2009)
New Revision: 1094

Added:
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimPropertyManager.cpp
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimPropertyManager.h
Modified:
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.cpp
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.h
   branches/OpenFDM-StateSeparation/src/JSBSim/Makefile.am
Log:
Factor out some implementation details.

M    src/JSBSim/JSBSimReaderBase.cpp
M    src/JSBSim/JSBSimReaderBase.h
M    src/JSBSim/JSBSimReader.cpp
AM   src/JSBSim/JSBSimPropertyManager.cpp
M    src/JSBSim/Makefile.am
AM   src/JSBSim/JSBSimPropertyManager.h


Added: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimPropertyManager.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimPropertyManager.cpp	2009-08-13 19:53:46 UTC (rev 1093)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimPropertyManager.cpp	2009-08-13 20:19:56 UTC (rev 1094)
@@ -0,0 +1,149 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2009 Mathias Froehlich 
+ *
+ */
+
+#include "JSBSimPropertyManager.h"
+
+namespace OpenFDM {
+
+class PortSet {
+  struct PathPort {
+    NodePath modelPath;
+    SharedPtr<const Port> portProvider;
+  };
+public:
+  PortSet(const Port* sourcePort = 0)
+  {
+    if (!sourcePort)
+      return;
+    PathPort pathPort;
+    pathPort.portProvider = sourcePort;
+
+    SharedPtr<const Node> node = sourcePort->getNode();
+    if (node)
+      // FIXME
+      pathPort.modelPath = node->getNodePathList().front();
+
+    mPortList.push_back(pathPort);
+  }
+
+  const Port* routeTo(const NodePath& path)
+  {
+    // could happen if the initialzer failed
+    if (mPortList.empty())
+      return 0;
+
+    // ok, shortcut for old style connections
+    if (path.empty())
+      return mPortList.front().portProvider;
+
+    const NodePath& originatingPath = mPortList.front().modelPath;
+    // fast return if the models are not connected to the same root system
+    if (path.front() != originatingPath.front())
+      return 0;
+
+    // first check, if we already have a route
+    const Port* portProvider = findProvider(path);
+    if (portProvider)
+      return portProvider;
+
+    // Compute the iterators for seperating the common part of the model path
+    // from the different part
+    NodePath::const_iterator mi1 = path.begin();
+    NodePath::const_iterator mi2 = originatingPath.begin();
+    while (mi1 != path.end() && mi2 != originatingPath.end()) {
+      if (*mi1 != *mi2)
+        break;
+      ++mi1;
+      ++mi2;
+    }
+
+    if (mi1 != path.end()) {
+      // that is: we must first go up that path and search again
+      NodePath pathUp = path;
+      pathUp.pop_back();
+      portProvider = routeTo(pathUp);
+      if (!portProvider)
+        return 0;
+      
+      GroupInput* groupInput = new GroupInput(portProvider->getName());
+      Group* group = const_cast<Group*>(dynamic_cast<const Group*>(path.back().get()));
+      group->addChild(groupInput);
+
+      PathPort pathPort;
+      pathPort.modelPath = groupInput->getNodePathList().front();
+      pathPort.portProvider = group->getPort(groupInput->getExternalPortIndex());
+      mPortList.push_back(pathPort);
+
+      if (!group->connect(portProvider, groupInput->getPort("input")))
+        return 0;
+      
+      return pathPort.portProvider.get();
+
+    } else if (mi2 != originatingPath.end()) {
+      // that is: we need to step deeper towards the origin of that port
+      NodePath pathDown = path;
+      pathDown.push_back(*mi2);
+      portProvider = routeTo(pathDown);
+      if (!portProvider)
+        return 0;
+
+      GroupOutput* groupOutput = new GroupOutput(portProvider->getName());
+      Group* group = const_cast<Group*>(dynamic_cast<const Group*>(pathDown.back().get()));
+      group->addChild(groupOutput);
+
+      PathPort pathPort;
+      pathPort.modelPath = groupOutput->getNodePathList().front();
+      pathPort.portProvider = group->getPort(groupOutput->getExternalPortIndex());
+      mPortList.push_back(pathPort);
+
+      if (!group->connect(portProvider, groupOutput->getPort("input")))
+        return 0;
+      
+      return pathPort.portProvider.get();
+
+    } else {
+      // should not happen, in this case the find provider must have been
+      // successful,
+      return 0;
+    }
+  }
+
+  const Port* findProvider(const NodePath& path)
+  {
+    PortList::iterator i = mPortList.begin();
+    while (i != mPortList.end()) {
+      if (i->modelPath == path)
+        return i->portProvider;
+      ++i;
+    }
+
+    return 0;
+  }
+
+private:
+  typedef std::list<PathPort> PortList;
+  PortList mPortList;
+};
+
+/// Connect all the loose ends stored here
+bool
+JSBSimProperty::connect()
+{
+  if (!hasProviderPort())
+    return false;
+  
+  PortSet portSet(mProvider.first);
+  for (unsigned i = 0; i < mConsumers.size(); ++i) {
+    SharedPtr<const Node> node = mConsumers[i].first->getNode();
+    OpenFDMAssert(node);
+    NodePathList nodePathList = node->getNodePathList();
+    const Port* p = portSet.routeTo(nodePathList.front());
+    if (!mConsumers[i].second->connect(p, mConsumers[i].first))
+      return false;
+  }
+  
+  return true;
+}
+
+} // namespace OpenFDM


Property changes on: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimPropertyManager.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimPropertyManager.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimPropertyManager.h	2009-08-13 19:53:46 UTC (rev 1093)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimPropertyManager.h	2009-08-13 20:19:56 UTC (rev 1094)
@@ -0,0 +1,162 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2009 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_JSBSimPropertyManager_H
+#define OpenFDM_JSBSimPropertyManager_H
+
+#include <map>
+#include <string>
+#include <cstring>
+#include <list>
+#include <map>
+#include <iosfwd>
+
+#include <OpenFDM/Assert.h>
+#include <OpenFDM/ReaderWriter.h>
+#include <OpenFDM/BreakPointLookup.h>
+#include <OpenFDM/Table.h>
+#include <OpenFDM/Model.h>
+#include <OpenFDM/GroupInput.h>
+#include <OpenFDM/GroupOutput.h>
+#include <OpenFDM/Port.h>
+
+#include <OpenFDM/XML/XMLReader.h>
+#include <OpenFDM/XML/ContentHandler.h>
+#include <OpenFDM/XML/ErrorHandler.h>
+#include <OpenFDM/XML/Attributes.h>
+
+#include "JSBSimAerodynamic.h"
+#include "XMLReader.h"
+
+namespace OpenFDM {
+
+class JSBSimProperty {
+public:
+  typedef std::pair<SharedPtr<const Port>, SharedPtr<Group> > PortGroupPair;
+
+  void setProvider(const Port* port)
+  {
+    if (!port)
+      return;
+    SharedPtr<const Node> node = port->getNode();
+    OpenFDMAssert(node);
+    NodePathList nodePathList = node->getNodePathList();
+    OpenFDMAssert(nodePathList.size() == 1);
+    Group* group = dynamic_cast<Group*>(const_cast<Node*>(nodePathList.front().back().get()));
+    setProvider(port, group);
+  }
+  void setProvider(const Port* port, Group* group)
+  { setProvider(PortGroupPair(port, group)); }
+  void setProvider(const PortGroupPair& portPathPair)
+  { mProvider = portPathPair; }
+  const SharedPtr<const Port>& getProviderPort() const
+  { return mProvider.first; }
+  const SharedPtr<Group>& getProviderGroup() const
+  { return mProvider.second; }
+
+  bool hasProviderPort() const
+  { return mProvider.first.valid(); }
+
+  void addConsumer(const Port* port)
+  {
+    if (!port)
+      return;
+    SharedPtr<const Node> node = port->getNode();
+    OpenFDMAssert(node);
+    NodePathList nodePathList = node->getNodePathList();
+    OpenFDMAssert(nodePathList.size() == 1);
+    Group* group = dynamic_cast<Group*>(const_cast<Node*>(nodePathList.front().back().get()));
+    addConsumer(port, group);
+  }
+  void addConsumer(const Port* port, Group* group)
+  { addConsumer(PortGroupPair(port, group)); }
+  void addConsumer(const PortGroupPair& portPathPair)
+  { mConsumers.push_back(portPathPair); }
+
+  /// Connect all the loose ends stored here
+  bool connect();
+
+  static std::string simplify(std::string path)
+  {
+    std::string::size_type idx;
+    while ((idx = path.find("[0]")) != std::string::npos) {
+      path.erase(idx, 3);
+    }
+    while ((idx = path.find("//")) != std::string::npos) {
+      path.erase(idx, 1);
+    }
+    return path;
+  }
+  static std::string propertyPath(const std::string& path)
+  {
+    std::string simplePath = simplify(path);
+    std::string::size_type idx = simplePath.rfind('/');
+    if (idx == std::string::npos)
+      return std::string();
+    simplePath = simplePath.substr(0, idx);
+    while (!simplePath.empty() && simplePath[simplePath.size() - 1] == '/')
+      simplePath = simplePath.substr(0, simplePath.size() - 1);
+    return simplePath.substr(0, idx);
+  }
+  static std::string propertyName(const std::string& path)
+  {
+    std::string simplePath = simplify(path);
+    std::string::size_type idx = simplePath.rfind('/');
+    if (idx == std::string::npos)
+      return simplePath;
+    return simplePath.substr(idx+1);
+  }
+  static bool startsWith(const std::string& path, const char* start)
+  {
+    return path.find(start) == 0;
+  }
+  static bool endsWith(const std::string& path, const char* start)
+  {
+    return path.size() - path.rfind(start) == strlen(start);
+  }
+
+private:
+  /// The port that delivers the value
+  PortGroupPair mProvider;
+  /// The ports that need that value as input
+  std::vector<PortGroupPair> mConsumers;
+};
+
+class JSBSimPropertyManager {
+public:
+  typedef std::map<std::string,JSBSimProperty> PropertyMap;
+
+  const PropertyMap& getPropertyMap() const
+  { return mPropertyMap; }
+  PropertyMap& getPropertyMap()
+  { return mPropertyMap; }
+
+  /// Clears the property map. Is used in the readers to reuse a reader
+  void clear()
+  { mPropertyMap.clear(); }
+
+  /// Set the port providing this property value
+  void setProvider(const std::string& name, const Port* port)
+  { mPropertyMap[JSBSimProperty::simplify(name)].setProvider(port); }
+
+  /// Add a port that consumes this property value
+  void addConsumer(const std::string& name, const Port* port)
+  { mPropertyMap[JSBSimProperty::simplify(name)].addConsumer(port); }
+
+  /// Returns true if this property is already registered
+  bool exists(const std::string& propertyName) const
+  {
+    PropertyMap::const_iterator i = mPropertyMap.find(JSBSimProperty::simplify(propertyName));
+    if (i == mPropertyMap.end())
+      return false;
+    return i->second.hasProviderPort();
+  }
+
+private:
+  PropertyMap mPropertyMap;
+};
+
+} // namespace OpenFDM
+
+#endif


Property changes on: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimPropertyManager.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp	2009-08-13 19:53:46 UTC (rev 1093)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp	2009-08-13 20:19:56 UTC (rev 1094)
@@ -310,7 +310,7 @@
     return false;
 
   // Finnaly connect all the collected properties ports together
-  if (!mPropertyManager.connect())
+  if (!connect())
     return false;
 
   return true;

Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.cpp	2009-08-13 19:53:46 UTC (rev 1093)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.cpp	2009-08-13 20:19:56 UTC (rev 1094)
@@ -205,10 +205,8 @@
     mPropertyManager.addConsumer(canonicalJSBProperty(name), pa);
   } else {
     SharedPtr<Group> group = getGroup(pa);
-    if (!group) {
-      std::cerr << "Could not add output model \"" << name << "\"" << std::endl;
-      return false;
-    }
+    if (!group)
+      return error("Could not add output model \"" + name + "\"");
 
     Gain* gain = new Gain("Minus " + canonicalJSBProperty(name), -1);
     group->addChild(gain);
@@ -222,19 +220,18 @@
   return true;
 }
 
-void
+bool
 JSBSimReaderBase::registerExpression(const std::string& name, const Port* port)
 {
   if (name.empty())
-    return;
+    return false;
   if (!port)
-    return;
-  if (mPropertyManager.exists(name)) {
-    std::cerr << "Already have an expression for " << name << std::endl;
-    return;
-  }
+    return false;
+  if (mPropertyManager.exists(name))
+    return error("Already have an expression for \"" + name + "\"");
 
   mPropertyManager.setProvider(name, port);
+  return true;
 }
 
 std::string
@@ -257,13 +254,13 @@
   return JSBSimProperty::simplify(path + '/' + name);
 }
 
-void
+bool
 JSBSimReaderBase::registerJSBExpression(const std::string& name, const Port* port)
 {
   if (name.empty())
-    return;
+    return error("Registering empty property?");
   if (!port)
-    return;
+    return error("Registering zero port?");
   if (name[0] == '/')
     registerExpression(name.substr(1), port);
   else
@@ -295,6 +292,7 @@
     addOutputModel(port, name.substr(4),
                    "surface-positions/flap-pos-norm");
   }
+  return true;
 }
 
 bool
@@ -308,7 +306,7 @@
          i != mPropertyManager.getPropertyMap().end(); ++i) {
       if (i->second.hasProviderPort())
         continue;
-      if (!provideSubstitute(i->first, i->second))
+      if (!provideSubstitute(i->first))
         return false;
       foundSubstitute = true;
     }
@@ -318,8 +316,7 @@
 }
 
 bool
-JSBSimReaderBase::provideSubstitute(const std::string& propName,
-                                    const JSBSimProperty& property)
+JSBSimReaderBase::provideSubstitute(const std::string& propName)
 {
   if (propName.find("/") == 0) {
     addInputModel("Property Input " + propName, propName);
@@ -673,6 +670,18 @@
   return false;
 }
 
+bool
+JSBSimReaderBase::connect()
+{
+  JSBSimPropertyManager::PropertyMap::iterator i;
+  for (i = mPropertyManager.getPropertyMap().begin();
+       i != mPropertyManager.getPropertyMap().end(); ++i) {
+    if (!i->second.connect())
+      return error("Error connecting \"" + i->first + "\"");
+  }
+  return true;
+}
+
 const Port*
 JSBSimReaderBase::addInputModel(const std::string& name,
                                 const std::string& propName, real_type gain)
@@ -693,7 +702,7 @@
 {
   SharedPtr<Group> group = getGroup(out);
   if (!group) {
-    std::cerr << "Could not add output model \"" << name << "\"" << std::endl;
+    error("Could not add output model \"" + name + "\"");
     return;
   }
   Output* output = new Output(name + " Output");
@@ -720,7 +729,7 @@
 {
   SharedPtr<Group> group = getGroup(in);
   if (!group) {
-    std::cerr << "Could not add inverter model \"" << name << "\"" << std::endl;
+    error("Could not add inverter model \"" + name + "\"");
     return 0;
   }
   UnaryFunction *unary
@@ -749,7 +758,7 @@
 {
   SharedPtr<Group> group = getGroup(in);
   if (!group) {
-    std::cerr << "Could not add inverter model \"" << name << "\"" << std::endl;
+    error("Could not add inverter model \"" + name + "\"");
     return 0;
   }
   UnaryFunction *unary
@@ -795,7 +804,7 @@
 {
   SharedPtr<Group> group = getGroup(in);
   if (!group) {
-    std::cerr << "Could not add inverter model \"" << name << "\"" << std::endl;
+    error("Could not add unit conversion model \"" + name + "\"");
     return 0;
   }
   UnitConversion* unitConv
@@ -824,7 +833,7 @@
 {
   SharedPtr<Group> group = getGroup(in);
   if (!group) {
-    std::cerr << "Could not add inverter model \"" << name << "\"" << std::endl;
+    error("Could not add unit conversion model \"" + name + "\"");
     return 0;
   }
   UnitConversion* unitConv
@@ -852,21 +861,20 @@
 JSBSimReaderBase::getGroup(const Port* in)
 {
   if (!in) {
-    std::cerr << "Could not find model group for input port: "
-      "no port given!" << std::endl;
+    error("Could not find model group for input port: no port given!");
     return 0;
   }
   SharedPtr<const Node> node = in->getNode();
   if (!node) {
-    std::cerr << "Could not find model group for input port: "
-      "port does not belong to a Node!" << std::endl;
+    error("Could not find model group for input port: "
+          "port does not belong to a Node!");
     return 0;
   }
   SharedPtr<const Node> parent = node->getParent(0).lock();
   SharedPtr<Group> group = const_cast<Group*>(dynamic_cast<const Group*>(parent.get()));
   if (!group) {
-    std::cerr << "Could not find model group for input port: "
-      "model has no parent!" << std::endl;
+    error("Could not find model group for input port: "
+          "model has no parent!");
     return 0;
   }
   return group;

Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.h	2009-08-13 19:53:46 UTC (rev 1093)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.h	2009-08-13 20:19:56 UTC (rev 1094)
@@ -28,299 +28,12 @@
 
 #include <OpenFDM/XML/EasyXMLReader.h> // FIXME
 
+#include "JSBSimPropertyManager.h"
 #include "JSBSimAerodynamic.h"
 #include "XMLReader.h"
 
 namespace OpenFDM {
 
-class Summer;
-class Product;
-
-class PortSet {
-  struct PathPort {
-    NodePath modelPath;
-    SharedPtr<const Port> portProvider;
-  };
-public:
-  PortSet(const Port* sourcePort = 0)
-  {
-    if (!sourcePort)
-      return;
-    PathPort pathPort;
-    pathPort.portProvider = sourcePort;
-
-    SharedPtr<const Node> node = sourcePort->getNode();
-    if (node)
-      // FIXME
-      pathPort.modelPath = node->getNodePathList().front();
-
-    mPortList.push_back(pathPort);
-  }
-
-  const Port* routeTo(const NodePath& path)
-  {
-    // could happen if the initialzer failed
-    if (mPortList.empty())
-      return 0;
-
-    // ok, shortcut for old style connections
-    if (path.empty())
-      return mPortList.front().portProvider;
-
-    const NodePath& originatingPath = mPortList.front().modelPath;
-    // fast return if the models are not connected to the same root system
-    if (path.front() != originatingPath.front())
-      return 0;
-
-    // first check, if we already have a route
-    const Port* portProvider = findProvider(path);
-    if (portProvider)
-      return portProvider;
-
-    // Compute the iterators for seperating the common part of the model path
-    // from the different part
-    NodePath::const_iterator mi1 = path.begin();
-    NodePath::const_iterator mi2 = originatingPath.begin();
-    while (mi1 != path.end() && mi2 != originatingPath.end()) {
-      if (*mi1 != *mi2)
-        break;
-      ++mi1;
-      ++mi2;
-    }
-
-    if (mi1 != path.end()) {
-      // that is: we must first go up that path and search again
-      NodePath pathUp = path;
-      pathUp.pop_back();
-      portProvider = routeTo(pathUp);
-      if (!portProvider)
-        return 0;
-      
-      GroupInput* groupInput = new GroupInput(portProvider->getName());
-      Group* group = const_cast<Group*>(dynamic_cast<const Group*>(path.back().get()));
-      group->addChild(groupInput);
-
-      PathPort pathPort;
-      pathPort.modelPath = groupInput->getNodePathList().front();
-      pathPort.portProvider = group->getPort(groupInput->getExternalPortIndex());
-      mPortList.push_back(pathPort);
-
-      if (!group->connect(portProvider, groupInput->getPort("input")))
-        return 0;
-      
-      return pathPort.portProvider.get();
-
-    } else if (mi2 != originatingPath.end()) {
-      // that is: we need to step deeper towards the origin of that port
-      NodePath pathDown = path;
-      pathDown.push_back(*mi2);
-      portProvider = routeTo(pathDown);
-      if (!portProvider)
-        return 0;
-
-      GroupOutput* groupOutput = new GroupOutput(portProvider->getName());
-      Group* group = const_cast<Group*>(dynamic_cast<const Group*>(pathDown.back().get()));
-      group->addChild(groupOutput);
-
-      PathPort pathPort;
-      pathPort.modelPath = groupOutput->getNodePathList().front();
-      pathPort.portProvider = group->getPort(groupOutput->getExternalPortIndex());
-      mPortList.push_back(pathPort);
-
-      if (!group->connect(portProvider, groupOutput->getPort("input")))
-        return 0;
-      
-      return pathPort.portProvider.get();
-
-    } else {
-      // should not happen, in this case the find provider must have been
-      // successful,
-      return 0;
-    }
-  }
-
-  const Port* findProvider(const NodePath& path)
-  {
-    PortList::iterator i = mPortList.begin();
-    while (i != mPortList.end()) {
-      if (i->modelPath == path)
-        return i->portProvider;
-      ++i;
-    }
-
-    return 0;
-  }
-
-private:
-  typedef std::list<PathPort> PortList;
-  PortList mPortList;
-};
-
-
-
-
-
-
-
-
-
-
-
-
-class JSBSimProperty {
-public:
-  typedef std::pair<SharedPtr<const Port>, SharedPtr<Group> > PortGroupPair;
-
-  void setProvider(const Port* port)
-  {
-    if (!port)
-      return;
-    SharedPtr<const Node> node = port->getNode();
-    OpenFDMAssert(node);
-    NodePathList nodePathList = node->getNodePathList();
-    OpenFDMAssert(nodePathList.size() == 1);
-    Group* group = dynamic_cast<Group*>(const_cast<Node*>(nodePathList.front().back().get()));
-    setProvider(port, group);
-  }
-  void setProvider(const Port* port, Group* group)
-  { setProvider(PortGroupPair(port, group)); }
-  void setProvider(const PortGroupPair& portPathPair)
-  { mProvider = portPathPair; }
-  const SharedPtr<const Port>& getProviderPort() const
-  { return mProvider.first; }
-  const SharedPtr<Group>& getProviderGroup() const
-  { return mProvider.second; }
-
-  bool hasProviderPort() const
-  { return mProvider.first.valid(); }
-
-  void addConsumer(const Port* port)
-  {
-    if (!port)
-      return;
-    SharedPtr<const Node> node = port->getNode();
-    OpenFDMAssert(node);
-    NodePathList nodePathList = node->getNodePathList();
-    OpenFDMAssert(nodePathList.size() == 1);
-    Group* group = dynamic_cast<Group*>(const_cast<Node*>(nodePathList.front().back().get()));
-    addConsumer(port, group);
-  }
-  void addConsumer(const Port* port, Group* group)
-  { addConsumer(PortGroupPair(port, group)); }
-  void addConsumer(const PortGroupPair& portPathPair)
-  { mConsumers.push_back(portPathPair); }
-
-  /// Connect all the loose ends stored here
-  bool connect()
-  {
-    if (!hasProviderPort())
-      return false;
-
-    PortSet portSet(mProvider.first);
-    for (unsigned i = 0; i < mConsumers.size(); ++i) {
-      SharedPtr<const Node> node = mConsumers[i].first->getNode();
-      OpenFDMAssert(node);
-      NodePathList nodePathList = node->getNodePathList();
-      const Port* p = portSet.routeTo(nodePathList.front());
-      if (!mConsumers[i].second->connect(p, mConsumers[i].first))
-        return false;
-    }
-
-    return true;
-  }
-
-  static std::string simplify(std::string path)
-  {
-    std::string::size_type idx;
-    while ((idx = path.find("[0]")) != std::string::npos) {
-      path.erase(idx, 3);
-    }
-    while ((idx = path.find("//")) != std::string::npos) {
-      path.erase(idx, 1);
-    }
-    return path;
-  }
-  static std::string propertyPath(const std::string& path)
-  {
-    std::string simplePath = simplify(path);
-    std::string::size_type idx = simplePath.rfind('/');
-    if (idx == std::string::npos)
-      return std::string();
-    simplePath = simplePath.substr(0, idx);
-    while (!simplePath.empty() && simplePath[simplePath.size() - 1] == '/')
-      simplePath = simplePath.substr(0, simplePath.size() - 1);
-    return simplePath.substr(0, idx);
-  }
-  static std::string propertyName(const std::string& path)
-  {
-    std::string simplePath = simplify(path);
-    std::string::size_type idx = simplePath.rfind('/');
-    if (idx == std::string::npos)
-      return simplePath;
-    return simplePath.substr(idx+1);
-  }
-  static bool startsWith(const std::string& path, const char* start)
-  {
-    return path.find(start) == 0;
-  }
-  static bool endsWith(const std::string& path, const char* start)
-  {
-    return path.size() - path.rfind(start) == strlen(start);
-  }
-
-private:
-  /// The port that delivers the value
-  PortGroupPair mProvider;
-  /// The ports that need that value as input
-  std::vector<PortGroupPair> mConsumers;
-};
-
-class JSBSimPropertyManager {
-public:
-  typedef std::map<std::string,JSBSimProperty> PropertyMap;
-
-  const PropertyMap& getPropertyMap() const
-  { return mPropertyMap; }
-  PropertyMap& getPropertyMap()
-  { return mPropertyMap; }
-
-  /// Clears the property map. Is used in the readers to reuse a reader
-  void clear()
-  { mPropertyMap.clear(); }
-
-  /// Set the port providing this property value
-  void setProvider(const std::string& name, const Port* port)
-  { mPropertyMap[JSBSimProperty::simplify(name)].setProvider(port); }
-
-  /// Add a port that consumes this property value
-  void addConsumer(const std::string& name, const Port* port)
-  { mPropertyMap[JSBSimProperty::simplify(name)].addConsumer(port); }
-
-  /// Returns true if this property is already registered
-  bool exists(const std::string& propertyName) const
-  {
-    PropertyMap::const_iterator i = mPropertyMap.find(JSBSimProperty::simplify(propertyName));
-    if (i == mPropertyMap.end())
-      return false;
-    return i->second.hasProviderPort();
-  }
-
-  bool connect()
-  {
-    for (PropertyMap::iterator i = mPropertyMap.begin();
-         i != mPropertyMap.end(); ++i) {
-      if (!i->second.connect()) {
-        std::cerr << "Connecting " << i->first << " failed" << std::endl;
-        return false;
-      }
-    }
-    return true;
-  }
-
-private:
-  PropertyMap mPropertyMap;
-};
-
 class JSBSimReaderBase : public ReaderWriter {
 public:
   JSBSimReaderBase(void);
@@ -370,11 +83,12 @@
 
   std::string canonicalJSBProperty(std::string name);
 
-  void registerExpression(const std::string& name, const Port* expr);
-  void registerJSBExpression(const std::string& name, const Port* expr);
+  bool registerExpression(const std::string& name, const Port* expr);
+  bool registerJSBExpression(const std::string& name, const Port* expr);
 
   bool provideSubstitutes();
-  bool provideSubstitute(const std::string&, const JSBSimProperty& property);
+  bool provideSubstitute(const std::string&);
+  bool connect();
 
   const Port* addInputModel(const std::string& name,
                             const std::string& propName, real_type gain = 1);
@@ -397,7 +111,7 @@
   const Port* addFromUnit(const std::string& name, Unit u,
                           const std::string& inProp);
 
-  static SharedPtr<Group> getGroup(const Port* in);
+  SharedPtr<Group> getGroup(const Port* in);
   void addFCSModel(Node* model);
 
   const Port* addMultiBodyConstModel(const std::string& name, real_type value);

Modified: branches/OpenFDM-StateSeparation/src/JSBSim/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/Makefile.am	2009-08-13 19:53:46 UTC (rev 1093)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/Makefile.am	2009-08-13 20:19:56 UTC (rev 1094)
@@ -20,6 +20,7 @@
   JSBSimAerosurfaceScale.h \
   JSBSimFCSComponent.h \
   JSBSimKinemat.h \
+  JSBSimPropertyManager.h \
   JSBSimReader.h \
   JSBSimReaderBase.h \
   JSBSimScheduledGain.h \
@@ -32,6 +33,7 @@
   JSBSimAerosurfaceScale.cpp \
   JSBSimFCSComponent.cpp \
   JSBSimKinemat.cpp \
+  JSBSimPropertyManager.cpp \
   JSBSimReader.cpp \
   JSBSimReaderBase.cpp \
   JSBSimScheduledGain.cpp \



From frohlich at mail.berlios.de  Thu Aug 13 22:46:13 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Thu, 13 Aug 2009 22:46:13 +0200
Subject: [OpenFDM-svn] r1095 - branches/OpenFDM-StateSeparation/src/JSBSim
Message-ID: <200908132046.n7DKkDK8026780@sheep.berlios.de>

Author: frohlich
Date: 2009-08-13 22:46:12 +0200 (Thu, 13 Aug 2009)
New Revision: 1095

Modified:
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.h
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.cpp
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.h
   branches/OpenFDM-StateSeparation/src/JSBSim/jsb2openfdm.cpp
Log:
Add loading of system tags.

M    src/JSBSim/JSBSimReaderBase.cpp
M    src/JSBSim/jsb2openfdm.cpp
M    src/JSBSim/JSBSimReaderBase.h
M    src/JSBSim/JSBSimReader.cpp
M    src/JSBSim/JSBSimReader.h


Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp	2009-08-13 20:19:56 UTC (rev 1094)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp	2009-08-13 20:46:12 UTC (rev 1095)
@@ -379,10 +379,10 @@
 
   // Include the system tags.
   std::list<const XMLElement*> systemElems = topElem->getElements("system");
-  if (!systemElems.empty()) {
-    std::cout << "Ignoring system sections" << std::endl;
-//     if (!convertPropulsion(propulsionElem))
-//       return error("Cannot convert propulsion data");
+  for (std::list<const XMLElement*>::iterator i = systemElems.begin();
+       i != systemElems.end(); ++i) {
+    if (!convertSystem(*i))
+      return error("Cannot convert system data");
   }
   
   // Convert the aerodynamic force.
@@ -1611,6 +1611,7 @@
   } else if (type == "ACTUATOR" || type == "actuator") {
     std::cout << "Ignoring ACTUATOR" << std::endl;
 
+  } else if (type == "documentation") {
   } else
     return error("Unknown FCS COMPONENT type: \"" + type
                  + "\". Ignoring whole FCS component \"" + name + "\"" );
@@ -1629,6 +1630,23 @@
 }
 
 bool
+JSBSimReader::convertSystem(const XMLElement* system)
+{
+  std::string systemName = system->getAttribute("file");
+  std::string sFileName = systemName + ".xml";
+  std::ifstream sFileStream;
+  if (!openFile(mSystemPath, sFileName, sFileStream))
+    return error("Cannot find system \"" + systemName + "\"");
+
+  SharedPtr<XMLElement> systemTopElem = parseXMLStream(sFileStream);
+
+  if (!convertFCSList(systemTopElem))
+    return error("Cannot convert system file \"" + sFileName + "\"");
+
+  return true;
+}
+
+bool
 JSBSimReader::convertAerodynamics(const XMLElement* aero)
 {
   std::list<const XMLElement*> elems = aero->getElements();

Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.h	2009-08-13 20:19:56 UTC (rev 1094)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.h	2009-08-13 20:46:12 UTC (rev 1095)
@@ -40,6 +40,7 @@
   bool convertMassBalance(const XMLElement* massBalanceElement);
   bool convertFCSList(const XMLElement* fcsElem);
   bool convertFCSComponent(const XMLElement* fcsComponent);
+  bool convertSystem(const XMLElement* system);
   bool attachWheel(const XMLElement* wheelElem, const std::string& name,
                    const std::string& numStr, RigidBody* parent);
   bool convertGroundReactionsElem(const XMLElement* gr);

Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.cpp	2009-08-13 20:19:56 UTC (rev 1094)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.cpp	2009-08-13 20:46:12 UTC (rev 1095)
@@ -89,6 +89,12 @@
   mEnginePath.push_back(path);
 }
 
+void
+JSBSimReaderBase::addSystemPath(const std::string& path)
+{
+  mSystemPath.push_back(path);
+}
+
 bool
 JSBSimReaderBase::openFile(const std::list<std::string>& paths,
                            const std::string& file, std::ifstream& fs)

Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.h	2009-08-13 20:19:56 UTC (rev 1094)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.h	2009-08-13 20:46:12 UTC (rev 1095)
@@ -49,6 +49,10 @@
   /// no getter available
   void addEnginePath(const std::string& path);
 
+  /// Add a new path component to search for system configurations
+  /// no getter available
+  void addSystemPath(const std::string& path);
+
 protected:
   /// Locates a file from a given path list
   static bool openFile(const std::list<std::string>& paths,
@@ -124,6 +128,8 @@
   std::list<std::string> mAircraftPath;
   /// List for the engine search path.
   std::list<std::string> mEnginePath;
+  /// List for the system search path.
+  std::list<std::string> mSystemPath;
 
   SharedPtr<Group> mTopLevelGroup;
   JSBSimPropertyManager mPropertyManager;

Modified: branches/OpenFDM-StateSeparation/src/JSBSim/jsb2openfdm.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/jsb2openfdm.cpp	2009-08-13 20:19:56 UTC (rev 1094)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/jsb2openfdm.cpp	2009-08-13 20:46:12 UTC (rev 1095)
@@ -21,11 +21,13 @@
 
   std::string aircraftDir = argv[1];
   std::string engineDir = aircraftDir + "/Engines";
+  std::string systemDir = aircraftDir + "/Systems";
   std::string aircraftFile = argv[2];
 
   JSBSimReader reader;
   reader.addAircraftPath(aircraftDir);
   reader.addEnginePath(engineDir);
+  reader.addSystemPath(systemDir);
   reader.loadAircraft(aircraftFile);
   if (reader.getErrorState()) {
     std::cerr << "Cannot read aircraft!" << std::endl;



From frohlich at mail.berlios.de  Fri Aug 14 21:46:09 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Fri, 14 Aug 2009 21:46:09 +0200
Subject: [OpenFDM-svn] r1096 - in branches/OpenFDM-StateSeparation/src:
	JSBSim OpenFDM
Message-ID: <200908141946.n7EJk99Y026034@sheep.berlios.de>

Author: frohlich
Date: 2009-08-14 21:46:08 +0200 (Fri, 14 Aug 2009)
New Revision: 1096

Modified:
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimAerodynamic.cpp
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimAerodynamic.h
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/ExternalInteract.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/ExternalInteract.h
Log:
Add climb speed sensing.

M    src/JSBSim/JSBSimAerodynamic.cpp
M    src/JSBSim/JSBSimReaderBase.cpp
M    src/JSBSim/JSBSimAerodynamic.h
M    src/OpenFDM/ExternalInteract.h
M    src/OpenFDM/ExternalInteract.cpp


Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimAerodynamic.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimAerodynamic.cpp	2009-08-13 20:46:12 UTC (rev 1095)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimAerodynamic.cpp	2009-08-14 19:46:08 UTC (rev 1096)
@@ -162,6 +162,13 @@
   mGroup->connect(mExternalInteract->getPort("groundSpeed"),
                   mGroundSpeedOutputModel->getPort("input"));
 
+  mClimbSpeedOutputModel = new GroupOutput("Climb Speed Output");
+  mGroup->addChild(mClimbSpeedOutputModel);
+  mClimbSpeedOutputModel->setExternalPortName("climbSpeed");
+  mExternalInteract->setEnableClimbSpeed(true);
+  mGroup->connect(mExternalInteract->getPort("climbSpeed"),
+                  mClimbSpeedOutputModel->getPort("input"));
+
   mCalibratedAirSpeedOutputModel = new GroupOutput("Calibrated Air Speed Output");
   mGroup->addChild(mCalibratedAirSpeedOutputModel);
   mCalibratedAirSpeedOutputModel->setExternalPortName("calibratedAirSpeed");
@@ -484,6 +491,12 @@
 }
 
 const Port*
+JSBSimAerodynamic::getClimbSpeedPort(void)
+{
+  return mGroup->getPort(mClimbSpeedOutputModel->getExternalPortIndex());
+}
+
+const Port*
 JSBSimAerodynamic::getCalibratedAirSpeedPort(void)
 {
   return mGroup->getPort(mCalibratedAirSpeedOutputModel->getExternalPortIndex());

Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimAerodynamic.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimAerodynamic.h	2009-08-13 20:46:12 UTC (rev 1095)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimAerodynamic.h	2009-08-14 19:46:08 UTC (rev 1096)
@@ -53,6 +53,7 @@
   const Port* getBetaDotPort(void);
   const Port* getTrueAirSpeedPort(void);
   const Port* getGroundSpeedPort(void);
+  const Port* getClimbSpeedPort(void);
   const Port* getCalibratedAirSpeedPort(void);
   const Port* getEquivalentAirSpeedPort(void);
   const Port* getMachPort(void);
@@ -120,6 +121,7 @@
   SharedPtr<GroupOutput> mBetaDotOutputModel;
   SharedPtr<GroupOutput> mTrueAirSpeedOutputModel;
   SharedPtr<GroupOutput> mGroundSpeedOutputModel;
+  SharedPtr<GroupOutput> mClimbSpeedOutputModel;
   SharedPtr<GroupOutput> mCalibratedAirSpeedOutputModel;
   SharedPtr<GroupOutput> mEquivalentAirSpeedOutputModel;
   SharedPtr<GroupOutput> mMachOutputModel;

Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.cpp	2009-08-13 20:46:12 UTC (rev 1095)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.cpp	2009-08-14 19:46:08 UTC (rev 1096)
@@ -348,6 +348,10 @@
     registerExpression(propName, mAeroForce->getGroundSpeedPort());
     return true;
 
+  } else if (propName == "fdm/jsbsim/velocities/hdot-mps") {
+    registerExpression(propName, mAeroForce->getClimbSpeedPort());
+    return true;
+
   } else if (propName == "fdm/jsbsim/velocities/mach-norm" ||
              propName == "fdm/jsbsim/velocities/mach") {
     registerExpression(propName, mAeroForce->getMachPort());

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/ExternalInteract.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ExternalInteract.cpp	2009-08-13 20:46:12 UTC (rev 1095)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ExternalInteract.cpp	2009-08-14 19:46:08 UTC (rev 1096)
@@ -25,6 +25,7 @@
   DEF_OPENFDM_PROPERTY(Bool, EnableLinearWindVelocity, Serialized)
   DEF_OPENFDM_PROPERTY(Bool, EnableAngularWindVelocity, Serialized)
   DEF_OPENFDM_PROPERTY(Bool, EnableGroundSpeed, Serialized)
+  DEF_OPENFDM_PROPERTY(Bool, EnableClimbSpeed, Serialized)
   DEF_OPENFDM_PROPERTY(Bool, EnableTemperature, Serialized)
   DEF_OPENFDM_PROPERTY(Bool, EnableStaticPressure, Serialized)
   DEF_OPENFDM_PROPERTY(Bool, EnableDensity, Serialized)
@@ -53,6 +54,7 @@
     mLinearWindVelocity(portValueList.getPortValue(externalInteract->mLinearWindVelocityPort)),
     mAngularWindVelocity(portValueList.getPortValue(externalInteract->mAngularWindVelocityPort)),
     mGroundSpeed(portValueList.getPortValue(externalInteract->mGroundSpeedPort)),
+    mClimbSpeed(portValueList.getPortValue(externalInteract->mClimbSpeedPort)),
     mTemperature(portValueList.getPortValue(externalInteract->mTemperaturePort)),
     mStaticPressure(portValueList.getPortValue(externalInteract->mStaticPressurePort)),
     mDensity(portValueList.getPortValue(externalInteract->mDensityPort)),
@@ -125,9 +127,10 @@
     bool enableLinearWindVelocity = mLinearWindVelocity.isConnected();
     bool enableAngularWindVelocity = mAngularWindVelocity.isConnected();
     bool enableGroundSpeed = mGroundSpeed.isConnected();
+    bool enableClimbSpeed = mClimbSpeed.isConnected();
     if (enableLinearVelocity || enableAngularVelocity
         || enableLinearWindVelocity || enableAngularWindVelocity
-        || enableGroundSpeed) {
+        || enableGroundSpeed || enableClimbSpeed) {
       Vector6 refVelocity = getLink().getVelocity(mCoordinateSystem);
       if (enableLinearVelocity)
         mLinearVelocity = refVelocity.getLinear();
@@ -146,12 +149,16 @@
           mAngularWindVelocity = wind.getAngular();
       }
 
-      if (enableGroundSpeed) {
+      if (enableGroundSpeed || enableClimbSpeed) {
+        Vector3 linVel = mCoordinateSystem.rotToReference(refVelocity.getLinear());
         Plane plane = getEnvironment().getHorizontalLocalPlane(mCoordinateSystem.getPosition());
-        mGroundSpeed = norm(plane.projectToPlane(refVelocity.getLinear()));
+        if (enableGroundSpeed)
+          mGroundSpeed = norm(plane.projectToPlane(linVel));
+        if (enableClimbSpeed)
+          mClimbSpeed = -dot(plane.getNormal(), linVel);
       }
     }
-    
+
     // Atmosphere related sensing
     bool enableAltitude = mAltitude.isConnected();
     
@@ -245,6 +252,7 @@
   MatrixOutputPortHandle mAngularWindVelocity;
 
   RealOutputPortHandle mGroundSpeed;
+  RealOutputPortHandle mClimbSpeed;
 
   RealOutputPortHandle mTemperature;
   RealOutputPortHandle mStaticPressure;
@@ -487,7 +495,24 @@
   return !mGroundSpeedPort.empty();
 }
 
+void
+ExternalInteract::setEnableClimbSpeed(bool enable)
+{
+  if (enable == getEnableClimbSpeed())
+    return;
+  if (enable)
+    mClimbSpeedPort = RealOutputPort(this, "climbSpeed");
+  else
+    mClimbSpeedPort.clear();
+}
 
+bool
+ExternalInteract::getEnableClimbSpeed() const
+{
+  return !mClimbSpeedPort.empty();
+}
+
+
 void
 ExternalInteract::setEnableTemperature(bool enable)
 {
@@ -655,6 +680,7 @@
   setEnableLoad(enable);
   setEnableAngularAcceleration(enable);
   setEnableGroundSpeed(enable);
+  setEnableClimbSpeed(enable);
   setEnableTemperature(enable);
   setEnableStaticPressure(enable);
   setEnableDensity(enable);

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/ExternalInteract.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ExternalInteract.h	2009-08-13 20:46:12 UTC (rev 1095)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ExternalInteract.h	2009-08-14 19:46:08 UTC (rev 1096)
@@ -97,7 +97,12 @@
   /// Get availabilty of the ground speed output port
   bool getEnableGroundSpeed() const;
 
+  /// Set availabilty of the climb speed output port
+  void setEnableClimbSpeed(bool enable);
+  /// Get availabilty of the climb speed output port
+  bool getEnableClimbSpeed() const;
 
+
   /// Set availabilty of the temperature output port
   void setEnableTemperature(bool enable);
   /// Get availabilty of the temperature output port
@@ -176,6 +181,7 @@
   MatrixOutputPort mAngularWindVelocityPort;
 
   RealOutputPort mGroundSpeedPort;
+  RealOutputPort mClimbSpeedPort;
 
   RealOutputPort mTemperaturePort;
   RealOutputPort mStaticPressurePort;



From frohlich at mail.berlios.de  Fri Aug 14 23:49:43 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Fri, 14 Aug 2009 23:49:43 +0200
Subject: [OpenFDM-svn] r1097 - branches/OpenFDM-StateSeparation/src/JSBSim
Message-ID: <200908142149.n7ELnhNq005376@sheep.berlios.de>

Author: frohlich
Date: 2009-08-14 23:49:42 +0200 (Fri, 14 Aug 2009)
New Revision: 1097

Added:
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimPID.cpp
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimPID.h
Modified:
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimFCSComponent.h
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp
   branches/OpenFDM-StateSeparation/src/JSBSim/Makefile.am
Log:
Add kind of pid model.


Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimFCSComponent.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimFCSComponent.h	2009-08-14 19:46:08 UTC (rev 1096)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimFCSComponent.h	2009-08-14 21:49:42 UTC (rev 1097)
@@ -21,8 +21,7 @@
 /// the available OpenFDM discrete systems.
 /// As JSBSim usually munges several independent things into one thing,
 /// this is a Group for the first cut.
-class JSBSimFCSComponent :
-    public Referenced {
+class JSBSimFCSComponent : public Referenced {
 public:
   JSBSimFCSComponent(const std::string& name);
   virtual ~JSBSimFCSComponent(void);
@@ -43,6 +42,8 @@
   GroupOutput* getOutputModel(void);
   GroupOutput* getOutputNormModel(void);
 
+  // FIXME clipto??? here ???
+
   Group* getGroup(void)
   { return mGroup; }
 private:

Added: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimPID.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimPID.cpp	2009-08-14 19:46:08 UTC (rev 1096)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimPID.cpp	2009-08-14 21:49:42 UTC (rev 1097)
@@ -0,0 +1,165 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2009 Mathias Froehlich 
+ *
+ */
+
+#include "JSBSimPID.h"
+
+#include <OpenFDM/DiscreteIntegrator.h>
+#include <OpenFDM/Group.h>
+#include <OpenFDM/Product.h>
+#include <OpenFDM/Summer.h>
+#include <OpenFDM/TimeDerivative.h>
+
+namespace OpenFDM {
+
+JSBSimPID::JSBSimPID(const std::string& name) :
+  JSBSimFCSComponent(name)
+{
+  // The error input of the JSBSim PID controller
+  GroupInput* groupInput = new GroupInput("Input");
+  getGroup()->addChild(groupInput);
+
+
+  mKIProduct = new Product("Integrator Gain");
+  mKIProduct->setNumFactors(2);
+  getGroup()->addChild(mKIProduct);
+  getGroup()->connect(mKIProduct->getInputPort(0),
+                      groupInput->getPort("output"));
+
+  DiscreteIntegrator* mIntegrator = new DiscreteIntegrator("Integrator");
+  getGroup()->addChild(mIntegrator);
+  getGroup()->connect(mKIProduct->getOutputPort(),
+                      mIntegrator->getPort("input"));
+
+  
+  mKPProduct = new Product("Proportional Gain");
+  mKPProduct->setNumFactors(2);
+  getGroup()->addChild(mKPProduct);
+  getGroup()->connect(mKPProduct->getInputPort(0),
+                      groupInput->getPort("output"));
+
+
+  mKDProduct = new Product("Derivative Gain");
+  mKDProduct->setNumFactors(2);
+  getGroup()->addChild(mKDProduct);
+  getGroup()->connect(mKDProduct->getInputPort(0),
+                      groupInput->getPort("output"));
+
+  TimeDerivative* mDerivative = new TimeDerivative("Derivative");
+  getGroup()->addChild(mDerivative);
+  getGroup()->connect(mKDProduct->getOutputPort(),
+                      mDerivative->getPort("input"));
+
+  Summer* mControlSum = new Summer("Control Sum");
+  mControlSum->setNumSummands(3);
+  getGroup()->addChild(mControlSum);
+  getGroup()->connect(mIntegrator->getPort("output"),
+                      mControlSum->getInputPort(0));
+  getGroup()->connect(mKPProduct->getPort("output"),
+                      mControlSum->getInputPort(1));
+  getGroup()->connect(mDerivative->getPort("output"),
+                      mControlSum->getInputPort(2));
+
+  // That single output port is this one
+  getGroup()->connect(getInternalOutputPort(),
+                      mControlSum->getOutputPort());
+}
+
+JSBSimPID::~JSBSimPID(void)
+{
+}
+
+void
+JSBSimPID::setKI(real_type ki)
+{
+  if (mKIGroupInput) {
+    getGroup()->removeChild(mKIGroupInput);
+    mKIGroupInput = 0;
+    // FIXME disconnect ...
+  }
+  mKIConstant = new ConstModel("ki", ki);
+  getGroup()->addChild(mKIConstant);
+  getGroup()->connect(mKIConstant->getPort("output"),
+                      mKIProduct->getInputPort(1));
+}
+
+const Port*
+JSBSimPID::getKIPort()
+{
+  if (mKIConstant) {
+    getGroup()->removeChild(mKIConstant);
+    mKIConstant = 0;
+    // FIXME disconnect ...
+  }
+  mKIGroupInput = new GroupInput("ki");
+  getGroup()->addChild(mKIConstant);
+  mKIGroupInput->setExternalPortName("ki");
+  getGroup()->connect(mKIGroupInput->getPort("output"),
+                      mKIProduct->getInputPort(1));
+  
+  return getGroup()->getPort(mKIGroupInput->getExternalPortIndex());
+}
+
+void
+JSBSimPID::setKP(real_type kp)
+{
+  if (mKPGroupInput) {
+    getGroup()->removeChild(mKPGroupInput);
+    mKPGroupInput = 0;
+    // FIXME disconnect ...
+  }
+  mKPConstant = new ConstModel("kp", kp);
+  getGroup()->addChild(mKPConstant);
+  getGroup()->connect(mKPConstant->getPort("output"),
+                      mKPProduct->getInputPort(1));
+}
+
+const Port*
+JSBSimPID::getKPPort()
+{
+  if (mKPConstant) {
+    getGroup()->removeChild(mKPConstant);
+    mKPConstant = 0;
+    // FIXME disconnect ...
+  }
+  mKPGroupInput = new GroupInput("kp");
+  getGroup()->addChild(mKPConstant);
+  mKPGroupInput->setExternalPortName("kp");
+  getGroup()->connect(mKPGroupInput->getPort("output"),
+                      mKPProduct->getInputPort(1));
+
+  return getGroup()->getPort(mKPGroupInput->getExternalPortIndex());
+}
+
+void
+JSBSimPID::setKD(real_type kd)
+{
+  if (mKDGroupInput) {
+    getGroup()->removeChild(mKDGroupInput);
+    mKDGroupInput = 0;
+    // FIXME disconnect ...
+  }
+  mKDConstant = new ConstModel("kd", kd);
+  getGroup()->addChild(mKDConstant);
+  getGroup()->connect(mKDConstant->getPort("output"),
+                      mKDProduct->getInputPort(1));
+}
+
+const Port*
+JSBSimPID::getKDPort()
+{
+  if (mKDConstant) {
+    getGroup()->removeChild(mKDConstant);
+    mKDConstant = 0;
+    // FIXME disconnect ...
+  }
+  mKDGroupInput = new GroupInput("kd");
+  getGroup()->addChild(mKDConstant);
+  mKDGroupInput->setExternalPortName("kd");
+  getGroup()->connect(mKDGroupInput->getPort("output"),
+                      mKDProduct->getInputPort(1));
+
+  return getGroup()->getPort(mKDGroupInput->getExternalPortIndex());
+}
+
+} //namespace OpenFDM


Property changes on: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimPID.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimPID.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimPID.h	2009-08-14 19:46:08 UTC (rev 1096)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimPID.h	2009-08-14 21:49:42 UTC (rev 1097)
@@ -0,0 +1,48 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2009 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_JSBSimPID_H
+#define OpenFDM_JSBSimPID_H
+
+#include "JSBSimFCSComponent.h"
+#include <OpenFDM/ConstModel.h>
+#include <OpenFDM/GroupInput.h>
+#include <OpenFDM/Product.h>
+#include <OpenFDM/SharedPtr.h>
+
+namespace OpenFDM {
+
+/// Just a small container mapping the JSBSim PID parameters to
+/// the OpenFDM models.
+class JSBSimPID : public JSBSimFCSComponent {
+public:
+  JSBSimPID(const std::string& name);
+  virtual ~JSBSimPID(void);
+
+  void setKI(real_type ki);
+  const Port* getKIPort();
+
+  void setKP(real_type kp);
+  const Port* getKPPort();
+
+  void setKD(real_type kd);
+  const Port* getKDPort();
+
+private:
+  SharedPtr<ConstModel> mKIConstant;
+  SharedPtr<GroupInput> mKIGroupInput;
+  SharedPtr<Product> mKIProduct;
+
+  SharedPtr<ConstModel> mKPConstant;
+  SharedPtr<GroupInput> mKPGroupInput;
+  SharedPtr<Product> mKPProduct;
+
+  SharedPtr<ConstModel> mKDConstant;
+  SharedPtr<GroupInput> mKDGroupInput;
+  SharedPtr<Product> mKDProduct;
+};
+
+} //namespace OpenFDM
+
+#endif


Property changes on: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimPID.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp	2009-08-14 19:46:08 UTC (rev 1096)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp	2009-08-14 21:49:42 UTC (rev 1097)
@@ -51,10 +51,28 @@
 
 #include "JSBSimAerosurfaceScale.h"
 #include "JSBSimKinemat.h"
+#include "JSBSimPID.h"
 #include "JSBSimScheduledGain.h"
 
 namespace OpenFDM {
 
+static bool
+isReal(const std::string& s)
+{
+  std::stringstream stream(s);
+  real_type value;
+  stream >> value;
+  return stream;
+}
+
+static bool
+isReal(const XMLElement* element)
+{
+  if (!element)
+    return false;
+  return isReal(element->getData());
+}
+
 static real_type
 asciiToReal(const std::string& s, const real_type& def = 0)
 {
@@ -1591,8 +1609,26 @@
     out = summer->getOutputPort();
 
   } else if (type == "PID" || type == "pid") {
-    std::cout << "Ignoring PID" << std::endl;
+    SharedPtr<JSBSimPID> pid = new JSBSimPID(name);
+    addFCSModel(pid->getGroup());
 
+    std::string data = stringData(fcsComponent->getElement("ki"));
+    if (!connectJSBExpression(data, pid->getKIPort())){
+      pid->setKI(realData(fcsComponent->getElement("ki"), 0));
+    }
+
+    data = stringData(fcsComponent->getElement("kp"));
+    if (!connectJSBExpression(data, pid->getKPPort())){
+      pid->setKP(realData(fcsComponent->getElement("kp"), 0));
+    }
+
+    data = stringData(fcsComponent->getElement("kd"));
+    if (!connectJSBExpression(data, pid->getKDPort())){
+      pid->setKD(realData(fcsComponent->getElement("kd"), 0));
+    }
+    model = pid->getGroup();
+    out = pid->getOutputPort();
+
   } else if (type == "PROPERTY" || type == "property") {
     name = fcsComponent->getData();
     real_type value = asciiToReal(fcsComponent->getAttribute("value"), 0);

Modified: branches/OpenFDM-StateSeparation/src/JSBSim/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/Makefile.am	2009-08-14 19:46:08 UTC (rev 1096)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/Makefile.am	2009-08-14 21:49:42 UTC (rev 1097)
@@ -20,6 +20,7 @@
   JSBSimAerosurfaceScale.h \
   JSBSimFCSComponent.h \
   JSBSimKinemat.h \
+  JSBSimPID.h \
   JSBSimPropertyManager.h \
   JSBSimReader.h \
   JSBSimReaderBase.h \
@@ -33,6 +34,7 @@
   JSBSimAerosurfaceScale.cpp \
   JSBSimFCSComponent.cpp \
   JSBSimKinemat.cpp \
+  JSBSimPID.cpp \
   JSBSimPropertyManager.cpp \
   JSBSimReader.cpp \
   JSBSimReaderBase.cpp \



From frohlich at mail.berlios.de  Fri Aug 14 23:58:04 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Fri, 14 Aug 2009 23:58:04 +0200
Subject: [OpenFDM-svn] r1098 - branches/OpenFDM-StateSeparation/src/JSBSim
Message-ID: <200908142158.n7ELw44P005833@sheep.berlios.de>

Author: frohlich
Date: 2009-08-14 23:58:04 +0200 (Fri, 14 Aug 2009)
New Revision: 1098

Modified:
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimPID.cpp
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimPID.h
Log:
Correctly disconnect pid ports.


Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimPID.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimPID.cpp	2009-08-14 21:49:42 UTC (rev 1097)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimPID.cpp	2009-08-14 21:58:04 UTC (rev 1098)
@@ -75,12 +75,15 @@
   if (mKIGroupInput) {
     getGroup()->removeChild(mKIGroupInput);
     mKIGroupInput = 0;
-    // FIXME disconnect ...
   }
+  if (mKIConnect) {
+    getGroup()->removeConnect(mKIConnect);
+    mKIConnect = 0;
+  }
   mKIConstant = new ConstModel("ki", ki);
   getGroup()->addChild(mKIConstant);
-  getGroup()->connect(mKIConstant->getPort("output"),
-                      mKIProduct->getInputPort(1));
+  mKIConnect = getGroup()->connect(mKIConstant->getPort("output"),
+                                   mKIProduct->getInputPort(1));
 }
 
 const Port*
@@ -89,13 +92,16 @@
   if (mKIConstant) {
     getGroup()->removeChild(mKIConstant);
     mKIConstant = 0;
-    // FIXME disconnect ...
   }
+  if (mKIConnect) {
+    getGroup()->removeConnect(mKIConnect);
+    mKIConnect = 0;
+  }
   mKIGroupInput = new GroupInput("ki");
   getGroup()->addChild(mKIConstant);
   mKIGroupInput->setExternalPortName("ki");
-  getGroup()->connect(mKIGroupInput->getPort("output"),
-                      mKIProduct->getInputPort(1));
+  mKIConnect = getGroup()->connect(mKIGroupInput->getPort("output"),
+                                   mKIProduct->getInputPort(1));
   
   return getGroup()->getPort(mKIGroupInput->getExternalPortIndex());
 }
@@ -106,12 +112,15 @@
   if (mKPGroupInput) {
     getGroup()->removeChild(mKPGroupInput);
     mKPGroupInput = 0;
-    // FIXME disconnect ...
   }
+  if (mKPConnect) {
+    getGroup()->removeConnect(mKPConnect);
+    mKPConnect = 0;
+  }
   mKPConstant = new ConstModel("kp", kp);
   getGroup()->addChild(mKPConstant);
-  getGroup()->connect(mKPConstant->getPort("output"),
-                      mKPProduct->getInputPort(1));
+  mKPConnect = getGroup()->connect(mKPConstant->getPort("output"),
+                                   mKPProduct->getInputPort(1));
 }
 
 const Port*
@@ -120,13 +129,16 @@
   if (mKPConstant) {
     getGroup()->removeChild(mKPConstant);
     mKPConstant = 0;
-    // FIXME disconnect ...
   }
+  if (mKPConnect) {
+    getGroup()->removeConnect(mKPConnect);
+    mKPConnect = 0;
+  }
   mKPGroupInput = new GroupInput("kp");
   getGroup()->addChild(mKPConstant);
   mKPGroupInput->setExternalPortName("kp");
-  getGroup()->connect(mKPGroupInput->getPort("output"),
-                      mKPProduct->getInputPort(1));
+  mKPConnect = getGroup()->connect(mKPGroupInput->getPort("output"),
+                                   mKPProduct->getInputPort(1));
 
   return getGroup()->getPort(mKPGroupInput->getExternalPortIndex());
 }
@@ -137,12 +149,15 @@
   if (mKDGroupInput) {
     getGroup()->removeChild(mKDGroupInput);
     mKDGroupInput = 0;
-    // FIXME disconnect ...
   }
+  if (mKDConnect) {
+    getGroup()->removeConnect(mKDConnect);
+    mKDConnect = 0;
+  }
   mKDConstant = new ConstModel("kd", kd);
   getGroup()->addChild(mKDConstant);
-  getGroup()->connect(mKDConstant->getPort("output"),
-                      mKDProduct->getInputPort(1));
+  mKDConnect = getGroup()->connect(mKDConstant->getPort("output"),
+                                   mKDProduct->getInputPort(1));
 }
 
 const Port*
@@ -151,13 +166,16 @@
   if (mKDConstant) {
     getGroup()->removeChild(mKDConstant);
     mKDConstant = 0;
-    // FIXME disconnect ...
   }
+  if (mKDConnect) {
+    getGroup()->removeConnect(mKDConnect);
+    mKDConnect = 0;
+  }
   mKDGroupInput = new GroupInput("kd");
   getGroup()->addChild(mKDConstant);
   mKDGroupInput->setExternalPortName("kd");
-  getGroup()->connect(mKDGroupInput->getPort("output"),
-                      mKDProduct->getInputPort(1));
+  mKDConnect = getGroup()->connect(mKDGroupInput->getPort("output"),
+                                   mKDProduct->getInputPort(1));
 
   return getGroup()->getPort(mKDGroupInput->getExternalPortIndex());
 }

Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimPID.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimPID.h	2009-08-14 21:49:42 UTC (rev 1097)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimPID.h	2009-08-14 21:58:04 UTC (rev 1098)
@@ -6,6 +6,7 @@
 #define OpenFDM_JSBSimPID_H
 
 #include "JSBSimFCSComponent.h"
+#include <OpenFDM/Connect.h>
 #include <OpenFDM/ConstModel.h>
 #include <OpenFDM/GroupInput.h>
 #include <OpenFDM/Product.h>
@@ -32,14 +33,17 @@
 private:
   SharedPtr<ConstModel> mKIConstant;
   SharedPtr<GroupInput> mKIGroupInput;
+  SharedPtr<Connect> mKIConnect;
   SharedPtr<Product> mKIProduct;
 
   SharedPtr<ConstModel> mKPConstant;
   SharedPtr<GroupInput> mKPGroupInput;
+  SharedPtr<Connect> mKPConnect;
   SharedPtr<Product> mKPProduct;
 
   SharedPtr<ConstModel> mKDConstant;
   SharedPtr<GroupInput> mKDGroupInput;
+  SharedPtr<Connect> mKDConnect;
   SharedPtr<Product> mKDProduct;
 };
 



From frohlich at mail.berlios.de  Sat Aug 15 00:15:57 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 15 Aug 2009 00:15:57 +0200
Subject: [OpenFDM-svn] r1099 - branches/OpenFDM-StateSeparation/src/JSBSim
Message-ID: <200908142215.n7EMFvds007046@sheep.berlios.de>

Author: frohlich
Date: 2009-08-15 00:15:57 +0200 (Sat, 15 Aug 2009)
New Revision: 1099

Modified:
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp
Log:
Add some more model handling.

M    src/JSBSim/JSBSimReader.cpp


Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp	2009-08-14 21:58:04 UTC (rev 1098)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp	2009-08-14 22:15:57 UTC (rev 1099)
@@ -16,6 +16,7 @@
 
 #include <OpenFDM/AirSpring.h>
 #include <OpenFDM/Bias.h>
+#include <OpenFDM/BinaryFunction.h>
 #include <OpenFDM/ConstModel.h>
 #include <OpenFDM/DeadBand.h>
 #include <OpenFDM/Delay.h>
@@ -1652,14 +1653,14 @@
     return error("Unknown FCS COMPONENT type: \"" + type
                  + "\". Ignoring whole FCS component \"" + name + "\"" );
 
-  // Register all output property names.
-  std::string implicitOutname = std::string("fcs/")
-    + normalizeComponentName(name);
-  registerJSBExpression(implicitOutname, out);
+  // Register output property names.
   if (fcsComponent->getElement("output")) {
     std::string outname = stringData(fcsComponent->getElement("output"));
-    if (outname != implicitOutname)
-      registerJSBExpression(outname, out);
+    registerJSBExpression(outname, out);
+  } else {
+    std::string implicitOutname = std::string("fcs/")
+      + normalizeComponentName(name);
+    registerJSBExpression(implicitOutname, out);
   }
 
   return true;
@@ -1775,6 +1776,33 @@
       inputs.push_back(addMultiBodyConstModel(name + " Constant", value));
     } else if ((*ait)->getName() == "property") {
       inputs.push_back(lookupJSBExpression(stringData(*ait), path));
+    } else if ((*ait)->getName() == "difference") {
+      std::list<const Port*> differenceInput = readFunctionInputs(*ait, "difference-" + name);
+      if (differenceInput.size() != 2) {
+          error("difference function inputtag must have 2 inputs!");
+          return std::list<const Port*>();
+      }
+      SharedPtr<Summer> summer = new Summer(name + " Difference");
+      addMultiBodyModel(summer);
+      mTopLevelGroup->connect(differenceInput.front(), summer->getInputPort(0));
+
+      SharedPtr<Gain> gain = new Gain(name + " Minus", -1);
+      addMultiBodyModel(gain);
+      mTopLevelGroup->connect(differenceInput.back(), gain->getInputPort(0));
+      mTopLevelGroup->connect(gain->getOutputPort(), summer->getInputPort(1));
+      inputs.push_back(summer->getOutputPort());
+    } else if ((*ait)->getName() == "quotient") {
+      std::list<const Port*> divInput = readFunctionInputs(*ait, "div-" + name);
+      if (divInput.size() != 2) {
+          error("div function inputtag must have 2 inputs!");
+          return std::list<const Port*>();
+      }
+      SharedPtr<BinaryFunction> div;
+      div = new BinaryFunction(name + " Difference", BinaryFunction::Div);
+      addMultiBodyModel(div);
+      mTopLevelGroup->connect(divInput.front(), div->getInputPort(0));
+      mTopLevelGroup->connect(divInput.back(), div->getInputPort(1));
+      inputs.push_back(div->getOutputPort());
     } else if ((*ait)->getName() == "abs") {
       std::list<const Port*> absInput = readFunctionInputs(*ait, "abs-" + name);
       if (absInput.size() != 1) {



From frohlich at mail.berlios.de  Sun Aug 16 19:50:25 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 16 Aug 2009 19:50:25 +0200
Subject: [OpenFDM-svn] r1100 - branches/OpenFDM-StateSeparation/src/JSBSim
Message-ID: <200908161750.n7GHoPEP015146@sheep.berlios.de>

Author: frohlich
Date: 2009-08-16 19:50:24 +0200 (Sun, 16 Aug 2009)
New Revision: 1100

Modified:
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimPID.cpp
Log:
Add the correct new child.

M    src/JSBSim/JSBSimPID.cpp


Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimPID.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimPID.cpp	2009-08-14 22:15:57 UTC (rev 1099)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimPID.cpp	2009-08-16 17:50:24 UTC (rev 1100)
@@ -98,7 +98,7 @@
     mKIConnect = 0;
   }
   mKIGroupInput = new GroupInput("ki");
-  getGroup()->addChild(mKIConstant);
+  getGroup()->addChild(mKIGroupInput);
   mKIGroupInput->setExternalPortName("ki");
   mKIConnect = getGroup()->connect(mKIGroupInput->getPort("output"),
                                    mKIProduct->getInputPort(1));
@@ -135,7 +135,7 @@
     mKPConnect = 0;
   }
   mKPGroupInput = new GroupInput("kp");
-  getGroup()->addChild(mKPConstant);
+  getGroup()->addChild(mKPGroupInput);
   mKPGroupInput->setExternalPortName("kp");
   mKPConnect = getGroup()->connect(mKPGroupInput->getPort("output"),
                                    mKPProduct->getInputPort(1));
@@ -172,7 +172,7 @@
     mKDConnect = 0;
   }
   mKDGroupInput = new GroupInput("kd");
-  getGroup()->addChild(mKDConstant);
+  getGroup()->addChild(mKDGroupInput);
   mKDGroupInput->setExternalPortName("kd");
   mKDConnect = getGroup()->connect(mKDGroupInput->getPort("output"),
                                    mKDProduct->getInputPort(1));



From frohlich at mail.berlios.de  Sun Aug 16 21:55:34 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sun, 16 Aug 2009 21:55:34 +0200
Subject: [OpenFDM-svn] r1101 - branches/OpenFDM-StateSeparation/src/JSBSim
Message-ID: <200908161955.n7GJtYPw024289@sheep.berlios.de>

Author: frohlich
Date: 2009-08-16 21:55:33 +0200 (Sun, 16 Aug 2009)
New Revision: 1101

Modified:
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.h
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.cpp
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.h
Log:
Improove function expressions.

M    src/JSBSim/JSBSimReaderBase.cpp
M    src/JSBSim/JSBSimReaderBase.h
M    src/JSBSim/JSBSimReader.cpp
M    src/JSBSim/JSBSimReader.h


Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp	2009-08-16 17:50:24 UTC (rev 1100)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp	2009-08-16 19:55:33 UTC (rev 1101)
@@ -1707,8 +1707,9 @@
         if (!convertFunction(*fit, sum))
           return error("Cannot convert function");
       }
-      
+
       if (!sum->getNumSummands())
+        // FIXME connect that then with a zero port ...
         continue;
       const Port* port = sum->getPort("output");
 
@@ -1746,197 +1747,339 @@
   std::string::size_type slachPos = bindName.rfind('/');
   if (slachPos != std::string::npos)
     name = name.substr(slachPos+1);
-  std::list<const Port*> inputs = readFunctionInputs(function, name);
-  if (inputs.size() != 1)
-    return error("function without output \"" + bindName + "\"!");
 
-  registerJSBExpression(bindName, inputs.front());
+  // FIXME put that into a group and use a GroupOutput for that
+  SharedPtr<Gain> gain = new Gain(name);
+  mTopLevelGroup->addChild(gain);
+
+  std::list<const XMLElement*> elements = function->getElements();
+  std::list<const XMLElement*>::iterator i;
+  for (i = elements.begin(); i != elements.end(); ++i) {
+    if ((*i)->getName() == "description")
+      continue;
+    if (!connectFunctionInput(*i, gain->getInputPort(0), mTopLevelGroup))
+      return error("Can not connect product input!");
+    // FIXME check that we get here only once
+  }
+
+  registerJSBExpression(bindName, gain->getOutputPort());
   if (sum) {
     unsigned num = sum->getNumSummands();
     sum->setNumSummands(num+1);
-    mTopLevelGroup->connect(inputs.front(), sum->getInputPort(num));
+    mTopLevelGroup->connect(gain->getOutputPort(), sum->getInputPort(num));
   }
 
   return true;
 }
 
-std::list<const Port*>
-JSBSimReader::readFunctionInputs(const XMLElement* operationTag,
-                                 const std::string& name)
+bool
+JSBSimReader::connectUnaryFunctionInput(const std::string& name,
+                                        UnaryFunction::Type type,
+                                        const XMLElement* element,
+                                        const Port* port, Group* parentGroup)
 {
-  NodePath path = mTopLevelGroup->getNodePathList().front();
-  std::list<const Port*> inputs;
-  std::list<const XMLElement*> args = operationTag->getElements();
-  std::list<const XMLElement*>::const_iterator ait;
-  for (ait = args.begin(); ait != args.end(); ++ait) {
-    if ((*ait)->getName() == "description") {
-      // Just ignore
-    } else if ((*ait)->getName() == "value") {
-      real_type value = asciiToReal((*ait)->getData());
-      inputs.push_back(addMultiBodyConstModel(name + " Constant", value));
-    } else if ((*ait)->getName() == "property") {
-      inputs.push_back(lookupJSBExpression(stringData(*ait), path));
-    } else if ((*ait)->getName() == "difference") {
-      std::list<const Port*> differenceInput = readFunctionInputs(*ait, "difference-" + name);
-      if (differenceInput.size() != 2) {
-          error("difference function inputtag must have 2 inputs!");
-          return std::list<const Port*>();
-      }
-      SharedPtr<Summer> summer = new Summer(name + " Difference");
-      addMultiBodyModel(summer);
-      mTopLevelGroup->connect(differenceInput.front(), summer->getInputPort(0));
+  SharedPtr<UnaryFunction> unaryFunction;
+  unaryFunction = new UnaryFunction(name, type);
+  parentGroup->addChild(unaryFunction);
+  
+  if (!parentGroup->connect(port, unaryFunction->getOutputPort()))
+    return error("Can not connect UnaryFunction output to port!");
+  
+  std::list<const XMLElement*> elements = element->getElements();
+  if (elements.size() != 1)
+    return error("Input ports to Unary models must have exactly one input!");
+  if (!connectFunctionInput(elements.front(), unaryFunction->getInputPort(0),
+                            parentGroup))
+    return error("Can not connect UnaryFunction input to port!");
+  
+  return true;
+}
 
-      SharedPtr<Gain> gain = new Gain(name + " Minus", -1);
-      addMultiBodyModel(gain);
-      mTopLevelGroup->connect(differenceInput.back(), gain->getInputPort(0));
-      mTopLevelGroup->connect(gain->getOutputPort(), summer->getInputPort(1));
-      inputs.push_back(summer->getOutputPort());
-    } else if ((*ait)->getName() == "quotient") {
-      std::list<const Port*> divInput = readFunctionInputs(*ait, "div-" + name);
-      if (divInput.size() != 2) {
-          error("div function inputtag must have 2 inputs!");
-          return std::list<const Port*>();
-      }
-      SharedPtr<BinaryFunction> div;
-      div = new BinaryFunction(name + " Difference", BinaryFunction::Div);
-      addMultiBodyModel(div);
-      mTopLevelGroup->connect(divInput.front(), div->getInputPort(0));
-      mTopLevelGroup->connect(divInput.back(), div->getInputPort(1));
-      inputs.push_back(div->getOutputPort());
-    } else if ((*ait)->getName() == "abs") {
-      std::list<const Port*> absInput = readFunctionInputs(*ait, "abs-" + name);
-      if (absInput.size() != 1) {
-          error("abs function inputtag must have 1 input!");
-          return std::list<const Port*>();
-      }
-      
-      SharedPtr<UnaryFunction> absModel;
-      absModel = new UnaryFunction("Abs " + name, UnaryFunction::Abs);
-      addMultiBodyModel(absModel);
-      mTopLevelGroup->connect(absInput.front(), absModel->getInputPort(0));
-      inputs.push_back(absModel->getOutputPort());
-    } else if ((*ait)->getName() == "product") {
-      SharedPtr<Product> prod = new Product(name + " product");
-      addMultiBodyModel(prod);
-      std::list<const Port*> pInputs = readFunctionInputs(*ait, name);
-      if (pInputs.empty()) {
-        error("Cannot read product inputs of function \"" + name + "\"!");
-        return std::list<const Port*>();
-      }
-      unsigned i = 0;
-      std::list<const Port*>::iterator iit = pInputs.begin();
-      while (iit != pInputs.end()) {
-        prod->setNumFactors(i+1);
-        mTopLevelGroup->connect(*iit++, prod->getInputPort(i++));
-      }
-      inputs.push_back(prod->getPort("output"));
 
-    } else if ((*ait)->getName() == "sum") {
-      SharedPtr<Summer> summer = new Summer(name + " sum");
-      addMultiBodyModel(summer);
-      std::list<const Port*> pInputs = readFunctionInputs(*ait, name);
-      if (pInputs.empty()) {
-        error("Cannot read sum inputs of function \"" + name + "\"!");
-        return std::list<const Port*>();
-      }
-      unsigned i = 0;
-      std::list<const Port*>::iterator iit = pInputs.begin();
-      while (iit != pInputs.end()) {
-        summer->setNumSummands(i+1);
-        mTopLevelGroup->connect(*iit++, summer->getInputPort(i++));
-      }
-      inputs.push_back(summer->getPort("output"));
+bool
+JSBSimReader::connectBinaryFunctionInput(const std::string& name,
+                                         BinaryFunction::Type type,
+                                         const XMLElement* element,
+                                         const Port* port, Group* parentGroup)
+{
+  SharedPtr<BinaryFunction> binaryFunction;
+  binaryFunction = new BinaryFunction(name, type);
+  parentGroup->addChild(binaryFunction);
+  
+  if (!parentGroup->connect(port, binaryFunction->getOutputPort()))
+    return error("Can not connect BinaryFunction output to port!");
+  
+  std::list<const XMLElement*> elements = element->getElements();
+  if (elements.size() != 2)
+    return error("Input ports to Binary models must have exactly two inputs!");
+  if (!connectFunctionInput(elements.front(), binaryFunction->getInputPort(0),
+                            parentGroup))
+    return error("Can not connect BinaryFunction input to port0!");
+  if (!connectFunctionInput(elements.back(), binaryFunction->getInputPort(1),
+                            parentGroup))
+    return error("Can not connect BinaryFunction input to port1!");
+  
+  return true;
+}
 
-    } else if ((*ait)->getName() == "table") {
-      unsigned dim = getNumTableDims(*ait);
-      if (dim == 1) {
-        TableData<1> data;
-        BreakPointVector lookup;
-        if (!readTable1D(*ait, data, lookup)) {
-          error("Cannot read 1D table data.");
-          return std::list<const Port*>();
-        }
-        std::string token = stringData((*ait)->getElement("independentVar"));
-        const Port* port = getTablePrelookup(name + " lookup", token, lookup);
+bool
+JSBSimReader::connectFunctionInput(const XMLElement* element, const Port* port,
+                                   Group* parentGroup)
+{
+  if (element->getName() == "abs") {
+    if (!connectUnaryFunctionInput("abs", UnaryFunction::Abs,
+                                   element, port, parentGroup))
+        return error("Can not connect abs output to port!");
+    return true;
 
-        SharedPtr<Table1D> table = new Table1D(name + " Table");
-        addMultiBodyModel(table);
-        mTopLevelGroup->connect(port, table->getInputPort(0));
-        table->setTableData(data);
-        inputs.push_back(table->getPort("output"));
+  } else if (element->getName() == "acos") {
+    if (!connectUnaryFunctionInput("acos", UnaryFunction::Acos,
+                                   element, port, parentGroup))
+        return error("Can not connect acos output to port!");
+    return true;
 
-      } else if (dim == 2) {
-        TableData<2> data;
-        BreakPointVector lookup[2];
-        if (!readTable2D(*ait, data, lookup)) {
-          error("Cannot read 2D table data.");
-          return std::list<const Port*>();
-        }
+  } else if (element->getName() == "asin") {
+    if (!connectUnaryFunctionInput("asin", UnaryFunction::Asin,
+                                   element, port, parentGroup))
+        return error("Can not connect asin output to port!");
+    return true;
 
-        std::list<const XMLElement*> indeps
-          = (*ait)->getElements("independentVar");
-        if (indeps.size() != 2) {
-          error("2DTable data does not have 2 inputs!");
-          return std::list<const Port*>();
-        }
-        std::string rowInput = indepData(indeps, "row");
-        std::string colInput = indepData(indeps, "column");
+  } else if (element->getName() == "atan") {
+    if (!connectUnaryFunctionInput("atan", UnaryFunction::Atan,
+                                   element, port, parentGroup))
+        return error("Can not connect atan output to port!");
+    return true;
 
-        const Port* rPort = getTablePrelookup(name + " row lookup", rowInput,
-                                              lookup[0]);
-        const Port* cPort = getTablePrelookup(name + " column lookup", colInput,
-                                              lookup[1]);
+  } else if (element->getName() == "atan2") {
+    if (!connectBinaryFunctionInput("Atan2", BinaryFunction::Atan2,
+                                    element, port, parentGroup))
+        return error("Can not connect atan2 output to port!");
+    return true;
 
-        SharedPtr<Table2D> table = new Table2D(name  + " Table");
-        addMultiBodyModel(table);
-        mTopLevelGroup->connect(rPort, table->getInputPort(0));
-        mTopLevelGroup->connect(cPort, table->getInputPort(1));
-        table->setTableData(data);
-        inputs.push_back(table->getPort("output"));
+  } else if (element->getName() == "ceil") {
+    if (!connectUnaryFunctionInput("ceil", UnaryFunction::Ceil,
+                                   element, port, parentGroup))
+        return error("Can not connect ceil output to port!");
+    return true;
 
-      } else if (dim == 3) {
-        TableData<3> data;
-        BreakPointVector lookup[3];
-        if (!readTable3D(*ait, data, lookup)) {
-          error("Cannot read 1D table data.");
-          return std::list<const Port*>();
-        }
+  } else if (element->getName() == "cos") {
+    if (!connectUnaryFunctionInput("cos", UnaryFunction::Cos,
+                                   element, port, parentGroup))
+        return error("Can not connect cos output to port!");
+    return true;
 
-        std::list<const XMLElement*> indeps
-          = (*ait)->getElements("independentVar");
-        if (indeps.size() != 3) {
-          error("3DTable data does not have 3 inputs!");
-          return std::list<const Port*>();
-        }
-        std::string rowInput = indepData(indeps, "row");
-        std::string colInput = indepData(indeps, "column");
-        std::string pageInput = indepData(indeps, "table");
+  } else if (element->getName() == "difference") {
+    SharedPtr<Summer> summer = new Summer("Difference");
+    parentGroup->addChild(summer);
 
-        const Port* rPort = getTablePrelookup(name + " row lookup", rowInput,
-                                              lookup[0]);
-        const Port* cPort = getTablePrelookup(name + " column lookup", colInput,
-                                              lookup[1]);
-        const Port* pPort = getTablePrelookup(name + " page lookup", pageInput,
-                                              lookup[2]);
+    SharedPtr<UnaryFunction> unaryFunction;
+    unaryFunction = new UnaryFunction("Minus", UnaryFunction::Minus);
+    parentGroup->addChild(unaryFunction);
+    
+    if (!parentGroup->connect(unaryFunction->getOutputPort(),
+                              summer->getInputPort(1)))
+      return error("Can not connect negative Summer input to port!");
+    if (!parentGroup->connect(port, summer->getOutputPort()))
+      return error("Can not connect Summer output to port!");
+    
+    std::list<const XMLElement*> elements = element->getElements();
+    if (elements.size() != 2)
+      return error("Input ports to Difference model must have exactly two inputs!");
+    if (!connectFunctionInput(elements.front(), summer->getInputPort(0),
+                              parentGroup))
+      return error("Can not connect UnaryFunction input to port!");
 
-        SharedPtr<Table3D> table = new Table3D(name  + " Table");
-        addMultiBodyModel(table);
-        mTopLevelGroup->connect(rPort, table->getInputPort(0));
-        mTopLevelGroup->connect(cPort, table->getInputPort(1));
-        mTopLevelGroup->connect(pPort, table->getInputPort(2));
-        table->setTableData(data);
-        inputs.push_back(table->getPort("output"));
+    if (!connectFunctionInput(elements.back(), unaryFunction->getInputPort(0),
+                              parentGroup))
+      return error("Can not connect UnaryFunction input to port!");
 
-      } else {
-        error("Unknown tabel dimension.");
-        return std::list<const Port*>();
-      }
-    } else {
-      error("Unknown function input");
-      return std::list<const Port*>();
+    return true;
+
+  } else if (element->getName() == "exp") {
+    if (!connectUnaryFunctionInput("Exp", UnaryFunction::Exp,
+                                   element, port, parentGroup))
+        return error("Can not connect exp output to port!");
+    return true;
+
+  } else if (element->getName() == "floor") {
+    if (!connectUnaryFunctionInput("Floor", UnaryFunction::Floor,
+                                   element, port, parentGroup))
+        return error("Can not connect floor output to port!");
+    return true;
+
+  } else if (element->getName() == "log") {
+    if (!connectUnaryFunctionInput("Log", UnaryFunction::Log,
+                                   element, port, parentGroup))
+        return error("Can not connect log output to port!");
+    return true;
+
+  } else if (element->getName() == "log10") {
+    if (!connectUnaryFunctionInput("Log10", UnaryFunction::Log10,
+                                   element, port, parentGroup))
+        return error("Can not connect log10 output to port!");
+    return true;
+
+  } else if (element->getName() == "log10") {
+    if (!connectUnaryFunctionInput("Log10", UnaryFunction::Log10,
+                                   element, port, parentGroup))
+        return error("Can not connect log10 output to port!");
+    return true;
+
+  } else if (element->getName() == "product") {
+    SharedPtr<Product> product = new Product("product");
+    parentGroup->addChild(product);
+  
+    if (!parentGroup->connect(port, product->getOutputPort()))
+      return error("Can not connect product output to port!");
+  
+    product->setNumFactors(0);
+    std::list<const XMLElement*> elements = element->getElements();
+    std::list<const XMLElement*>::iterator i;
+    for (i = elements.begin(); i != elements.end(); ++i) {
+      unsigned idx = product->getNumFactors();
+      product->setNumFactors(idx + 1);
+      if (!connectFunctionInput(*i, product->getInputPort(idx),
+                                parentGroup))
+        return error("Can not connect product input!");
     }
+  
+    return true;
+
+  } else if (element->getName() == "property") {
+    if (!connectJSBExpression(stringData(element), port))
+        return error("Can not connect property to port!");
+    return true;
+
+  } else if (element->getName() == "quotient") {
+    if (!connectBinaryFunctionInput("Div", BinaryFunction::Div,
+                                    element, port, parentGroup))
+        return error("Can not connect quotient output to port!");
+    return true;
+
+  } else if (element->getName() == "sin") {
+    if (!connectUnaryFunctionInput("Sin", UnaryFunction::Sin,
+                                   element, port, parentGroup))
+        return error("Can not connect sin output to port!");
+    return true;
+
+  } else if (element->getName() == "sum") {
+    SharedPtr<Summer> summer = new Summer("sum");
+    parentGroup->addChild(summer);
+  
+    if (!parentGroup->connect(port, summer->getOutputPort()))
+      return error("Can not connect sum output to port!");
+  
+    summer->setNumSummands(0);
+    std::list<const XMLElement*> elements = element->getElements();
+    std::list<const XMLElement*>::iterator i;
+    for (i = elements.begin(); i != elements.end(); ++i) {
+      unsigned idx = summer->getNumSummands();
+      summer->setNumSummands(idx + 1);
+      if (!connectFunctionInput(*i, summer->getInputPort(idx),
+                                parentGroup))
+        return error("Can not connect product input!");
+    }
+  
+    return true;
+
+  } else if (element->getName() == "sqr") {
+    if (!connectUnaryFunctionInput("sqr", UnaryFunction::Sqr,
+                                   element, port, parentGroup))
+        return error("Can not connect sqr output to port!");
+    return true;
+
+  } else if (element->getName() == "sqrt") {
+    if (!connectUnaryFunctionInput("sqrt", UnaryFunction::Sqrt,
+                                   element, port, parentGroup))
+        return error("Can not connect sqrt output to port!");
+    return true;
+
+  } else if (element->getName() == "table") {
+    unsigned dim = getNumTableDims(element);
+    if (dim == 1) {
+      TableData<1> data;
+      BreakPointVector lookup;
+      if (!readTable1D(element, data, lookup))
+        return error("Cannot read 1D table data.");
+      std::string token = stringData(element->getElement("independentVar"));
+      const Port* portP = getTablePrelookup("lookup", token, lookup);
+
+      SharedPtr<Table1D> table = new Table1D("Table");
+      parentGroup->addChild(table);
+      parentGroup->connect(portP, table->getInputPort(0));
+      table->setTableData(data);
+      parentGroup->connect(port, table->getPort("output"));
+      return true;
+
+    } else if (dim == 2) {
+      TableData<2> data;
+      BreakPointVector lookup[2];
+      if (!readTable2D(element, data, lookup))
+        return error("Cannot read 2D table data.");
+      
+      std::list<const XMLElement*> indeps
+        = element->getElements("independentVar");
+      if (indeps.size() != 2)
+        return error("2DTable data does not have 2 inputs!");
+      std::string rowInput = indepData(indeps, "row");
+      std::string colInput = indepData(indeps, "column");
+      
+      const Port* rPort = getTablePrelookup("Row lookup", rowInput, lookup[0]);
+      const Port* cPort = getTablePrelookup("Column lookup", colInput, lookup[1]);
+      
+      SharedPtr<Table2D> table = new Table2D("Table");
+      parentGroup->addChild(table);
+      parentGroup->connect(rPort, table->getInputPort(0));
+      parentGroup->connect(cPort, table->getInputPort(1));
+      table->setTableData(data);
+      parentGroup->connect(port, table->getPort("output"));
+      return true;
+
+    } else if (dim == 3) {
+      TableData<3> data;
+      BreakPointVector lookup[3];
+      if (!readTable3D(element, data, lookup))
+        return error("Cannot read 1D table data.");
+      
+      std::list<const XMLElement*> indeps
+        = element->getElements("independentVar");
+      if (indeps.size() != 3)
+        return error("3DTable data does not have 3 inputs!");
+      std::string rowInput = indepData(indeps, "row");
+      std::string colInput = indepData(indeps, "column");
+      std::string pageInput = indepData(indeps, "table");
+      
+      const Port* rPort = getTablePrelookup("Row lookup", rowInput, lookup[0]);
+      const Port* cPort = getTablePrelookup("Column lookup", colInput, lookup[1]);
+      const Port* pPort = getTablePrelookup("Page lookup", pageInput, lookup[2]);
+      
+      SharedPtr<Table3D> table = new Table3D("Table");
+      parentGroup->addChild(table);
+      parentGroup->connect(rPort, table->getInputPort(0));
+      parentGroup->connect(cPort, table->getInputPort(1));
+      parentGroup->connect(pPort, table->getInputPort(2));
+      table->setTableData(data);
+      parentGroup->connect(port, table->getPort("output"));
+      return true;
+
+    }
+
+  } else if (element->getName() == "tan") {
+    if (!connectUnaryFunctionInput("tan", UnaryFunction::Tan,
+                                   element, port, parentGroup))
+        return error("Can not connect tan output to port!");
+    return true;
+
+  } else if (element->getName() == "value") {
+    real_type value = realData(element, 0);
+    SharedPtr<ConstModel> constModel = new ConstModel("Value", value);
+    parentGroup->addChild(constModel);
+    if (!parentGroup->connect(port, constModel->getPort("output")))
+      return error("Can not connect ConstModel output to port!");
+    return true;
+
   }
-  return inputs;
+  return false;
 }
 
 unsigned

Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.h	2009-08-16 17:50:24 UTC (rev 1100)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.h	2009-08-16 19:55:33 UTC (rev 1101)
@@ -12,6 +12,8 @@
 
 #include <OpenFDM/ReaderWriter.h>
 #include <OpenFDM/Table.h>
+#include <OpenFDM/UnaryFunction.h>
+#include <OpenFDM/BinaryFunction.h>
 
 #include "JSBSimReaderBase.h"
 
@@ -60,9 +62,19 @@
                      const Port* thrusterDriver);
   bool convertAerodynamics(const XMLElement* aero);
   bool convertFunction(const XMLElement* function, Summer* sum);
-  std::list<const Port*> readFunctionInputs(const XMLElement* operationTag,
-                                            const std::string& name);
 
+  bool connectUnaryFunctionInput(const std::string& name,
+                                 UnaryFunction::Type type,
+                                 const XMLElement* element,
+                                 const Port* port, Group* parentGroup);
+  bool connectBinaryFunctionInput(const std::string& name,
+                                  BinaryFunction::Type type,
+                                  const XMLElement* element,
+                                  const Port* port, Group* parentGroup);
+
+  bool connectFunctionInput(const XMLElement* element, const Port* port,
+                            Group* parentGroup);
+
   unsigned getNumTableDims(const XMLElement* tableElem);
   bool readTable1D(const XMLElement* tableElem,
                    TableData<1>& data, BreakPointVector& lookup);

Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.cpp	2009-08-16 17:50:24 UTC (rev 1100)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.cpp	2009-08-16 19:55:33 UTC (rev 1101)
@@ -183,23 +183,6 @@
   return ret;
 }
 
-const Port*
-JSBSimReaderBase::lookupJSBExpression(const std::string& name,
-                                      const NodePath& path,
-                                      bool recheckAeroProp)
-{
-  Group* parent = 0;
-  if (path.empty())
-    parent = mTopLevelGroup;
-  else
-    parent = const_cast<Group*>(dynamic_cast<const Group*>(path.back().get()));
-  OpenFDMAssert(parent);
-  Gain* gain = new Gain("FIXME dummy");
-  parent->addChild(gain);
-  connectJSBExpression(name, gain->getInputPort(0), recheckAeroProp);
-  return gain->getOutputPort();
-}
-
 bool
 JSBSimReaderBase::connectJSBExpression(const std::string& name,
                                        const Port* pa, bool recheckAeroProp)

Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.h	2009-08-16 17:50:24 UTC (rev 1100)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.h	2009-08-16 19:55:33 UTC (rev 1101)
@@ -70,18 +70,6 @@
   /// Returns the name of the output property given the fcs component's name
   static std::string normalizeComponentName(const std::string& name);
 
-
-  /// <FIXME> document and rethink
-  // Deprecated
-  // const Port* lookupJSBExpression2(const std::string& name,
-  //                                 const NodePath& path = NodePath(),
-  //                                 bool recheckAeroProp = true);
-
-  // FIXME
-  const Port* lookupJSBExpression(const std::string& name,
-                                  const NodePath& path = NodePath(),
-                                  bool recheckAeroProp = true);
-
   bool connectJSBExpression(const std::string& name, const Port*,
                             bool recheckAeroProp = true);
 



From frohlich at mail.berlios.de  Mon Aug 17 21:18:09 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Mon, 17 Aug 2009 21:18:09 +0200
Subject: [OpenFDM-svn] r1102 - branches/OpenFDM-StateSeparation/src/JSBSim
Message-ID: <200908171918.n7HJI9LY007324@sheep.berlios.de>

Author: frohlich
Date: 2009-08-17 21:18:08 +0200 (Mon, 17 Aug 2009)
New Revision: 1102

Added:
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimActuator.cpp
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimActuator.h
Modified:
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp
   branches/OpenFDM-StateSeparation/src/JSBSim/Makefile.am
Log:
Add a dummy actuator model.

AM   JSBSim/JSBSimActuator.h
M    JSBSim/JSBSimReader.cpp
M    JSBSim/Makefile.am
AM   JSBSim/JSBSimActuator.cpp


Added: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimActuator.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimActuator.cpp	2009-08-16 19:55:33 UTC (rev 1101)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimActuator.cpp	2009-08-17 19:18:08 UTC (rev 1102)
@@ -0,0 +1,37 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2009 Mathias Froehlich 
+ *
+ */
+
+#include "JSBSimActuator.h"
+
+#include <OpenFDM/DiscreteIntegrator.h>
+#include <OpenFDM/Group.h>
+#include <OpenFDM/Product.h>
+#include <OpenFDM/Summer.h>
+#include <OpenFDM/TimeDerivative.h>
+
+namespace OpenFDM {
+
+JSBSimActuator::JSBSimActuator(const std::string& name) :
+  JSBSimFCSComponent(name)
+{
+  // The error input of the JSBSim Actuator controller
+  mGroupInput = new GroupInput("Input");
+  getGroup()->addChild(mGroupInput);
+
+  // That single output port is this one
+  getGroup()->connect(getInternalOutputPort(),
+                      mGroupInput->getPort("output"));
+}
+
+JSBSimActuator::~JSBSimActuator(void)
+{
+}
+
+const Port*
+JSBSimActuator::getInputPort()
+{
+  return getGroup()->getPort(mGroupInput->getExternalPortIndex());
+}
+
+} //namespace OpenFDM


Property changes on: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimActuator.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimActuator.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimActuator.h	2009-08-16 19:55:33 UTC (rev 1101)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimActuator.h	2009-08-17 19:18:08 UTC (rev 1102)
@@ -0,0 +1,32 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2009 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_JSBSimActuator_H
+#define OpenFDM_JSBSimActuator_H
+
+#include "JSBSimFCSComponent.h"
+#include <OpenFDM/Connect.h>
+#include <OpenFDM/ConstModel.h>
+#include <OpenFDM/GroupInput.h>
+#include <OpenFDM/Product.h>
+#include <OpenFDM/SharedPtr.h>
+
+namespace OpenFDM {
+
+/// Just a small container mapping the JSBSim Actuator parameters to
+/// the OpenFDM models.
+class JSBSimActuator : public JSBSimFCSComponent {
+public:
+  JSBSimActuator(const std::string& name);
+  virtual ~JSBSimActuator(void);
+
+  const Port* getInputPort();
+
+private:
+  SharedPtr<GroupInput> mGroupInput;
+};
+
+} //namespace OpenFDM
+
+#endif


Property changes on: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimActuator.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp	2009-08-16 19:55:33 UTC (rev 1101)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp	2009-08-17 19:18:08 UTC (rev 1102)
@@ -50,6 +50,7 @@
 
 #include <OpenFDM/ReaderWriter.h>
 
+#include "JSBSimActuator.h"
 #include "JSBSimAerosurfaceScale.h"
 #include "JSBSimKinemat.h"
 #include "JSBSimPID.h"
@@ -1646,8 +1647,16 @@
     std::cout << "Ignoring ACCELEROMETER" << std::endl;
 
   } else if (type == "ACTUATOR" || type == "actuator") {
-    std::cout << "Ignoring ACTUATOR" << std::endl;
+    SharedPtr<JSBSimActuator> actuator = new JSBSimActuator(name);
+    addFCSModel(actuator->getGroup());
 
+    std::string token = stringData(fcsComponent->getElement("input"));
+    if (!connectJSBExpression(token, actuator->getInputPort()))
+      return error("could not connect to actuator input \"" + token + "\"");
+
+    model = actuator->getGroup();
+    out = actuator->getOutputPort();
+
   } else if (type == "documentation") {
   } else
     return error("Unknown FCS COMPONENT type: \"" + type

Modified: branches/OpenFDM-StateSeparation/src/JSBSim/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/Makefile.am	2009-08-16 19:55:33 UTC (rev 1101)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/Makefile.am	2009-08-17 19:18:08 UTC (rev 1102)
@@ -16,6 +16,7 @@
 OpenFDMincludedir = $(includedir)/JSBSim
 
 OpenFDMinclude_HEADERS = \
+  JSBSimActuator.h \
   JSBSimAerodynamic.h \
   JSBSimAerosurfaceScale.h \
   JSBSimFCSComponent.h \
@@ -30,6 +31,7 @@
 
 lib_LTLIBRARIES = libOpenFDMJSBReader.la
 libOpenFDMJSBReader_la_SOURCES = \
+  JSBSimActuator.cpp \
   JSBSimAerodynamic.cpp \
   JSBSimAerosurfaceScale.cpp \
   JSBSimFCSComponent.cpp \



From frohlich at mail.berlios.de  Wed Aug 19 07:26:10 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Wed, 19 Aug 2009 07:26:10 +0200
Subject: [OpenFDM-svn] r1103 - branches/OpenFDM-StateSeparation/src/JSBSim
Message-ID: <200908190526.n7J5QATx030199@sheep.berlios.de>

Author: frohlich
Date: 2009-08-19 07:26:01 +0200 (Wed, 19 Aug 2009)
New Revision: 1103

Added:
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimSwitch.cpp
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimSwitch.h
Modified:
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.cpp
   branches/OpenFDM-StateSeparation/src/JSBSim/Makefile.am
Log:
Various fixes.
Add an empty switch model.

M    JSBSim/JSBSimReaderBase.cpp
AM   JSBSim/JSBSimSwitch.cpp
M    JSBSim/JSBSimReader.cpp
AM   JSBSim/JSBSimSwitch.h
M    JSBSim/Makefile.am


Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp	2009-08-17 19:18:08 UTC (rev 1102)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp	2009-08-19 05:26:01 UTC (rev 1103)
@@ -55,6 +55,7 @@
 #include "JSBSimKinemat.h"
 #include "JSBSimPID.h"
 #include "JSBSimScheduledGain.h"
+#include "JSBSimSwitch.h"
 
 namespace OpenFDM {
 
@@ -1393,8 +1394,12 @@
     out = model->getPort("output");
 
   } else if (type == "SWITCH" || type == "switch") {
-    std::cout << "Ignoring SWITCH" << std::endl;
+    SharedPtr<JSBSimSwitch> sw = new JSBSimSwitch(name);
+    addFCSModel(sw->getGroup());
 
+    model = sw->getGroup();
+    out = sw->getOutputPort();
+
   } else if (type == "KINEMAT" || type == "kinematic") {
     // Use that special proxy class
     SharedPtr<JSBSimKinemat> kinemat;
@@ -1663,14 +1668,13 @@
                  + "\". Ignoring whole FCS component \"" + name + "\"" );
 
   // Register output property names.
-  if (fcsComponent->getElement("output")) {
-    std::string outname = stringData(fcsComponent->getElement("output"));
+  std::string implicitOutname = std::string("fcs/")
+    + normalizeComponentName(name);
+  registerJSBExpression(implicitOutname, out);
+  std::string outname = stringData(fcsComponent->getElement("output"));
+  if (!outname.empty() &&
+      canonicalJSBProperty(outname) != canonicalJSBProperty(implicitOutname))
     registerJSBExpression(outname, out);
-  } else {
-    std::string implicitOutname = std::string("fcs/")
-      + normalizeComponentName(name);
-    registerJSBExpression(implicitOutname, out);
-  }
 
   return true;
 }
@@ -1771,7 +1775,8 @@
     // FIXME check that we get here only once
   }
 
-  registerJSBExpression(bindName, gain->getOutputPort());
+  if (!bindName.empty())
+    registerJSBExpression(bindName, gain->getOutputPort());
   if (sum) {
     unsigned num = sum->getNumSummands();
     sum->setNumSummands(num+1);
@@ -1934,6 +1939,12 @@
         return error("Can not connect log10 output to port!");
     return true;
 
+  } else if (element->getName() == "pow") {
+    if (!connectBinaryFunctionInput("pow", BinaryFunction::Pow,
+                                    element, port, parentGroup))
+        return error("Can not connect pow output to port!");
+    return true;
+
   } else if (element->getName() == "product") {
     SharedPtr<Product> product = new Product("product");
     parentGroup->addChild(product);

Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.cpp	2009-08-17 19:18:08 UTC (rev 1102)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.cpp	2009-08-19 05:26:01 UTC (rev 1103)
@@ -217,7 +217,9 @@
   if (!port)
     return false;
   if (mPropertyManager.exists(name))
-    return error("Already have an expression for \"" + name + "\"");
+    // FIXME, at least warn about that ...
+    return true;
+    // return error("Already have an expression for \"" + name + "\"");
 
   mPropertyManager.setProvider(name, port);
   return true;
@@ -480,6 +482,12 @@
     std::string control = "/controls/flight/flaps";
     registerExpression(propName, addInputModel("Flaps Input", control));
     return true;
+  } else if (propName == "fdm/jsbsim/fcs/flap-pos-norm") {
+    Gain* gain = new Gain("Implicit fdm/jsbsim/fcs/flap-pos-norm");
+    addFCSModel(gain);
+    connectJSBExpression("fdm/jsbsim/fcs/flap-cmd-norm", gain->getInputPort(0));
+    registerExpression(propName, gain->getOutputPort());
+    return true;
   } else if (propName == "fdm/jsbsim/fcs/speedbrake-cmd-norm") {
     std::string control = "/controls/flight/speedbrake";
     registerExpression(propName, addInputModel("Speedbrake Input", control));

Added: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimSwitch.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimSwitch.cpp	2009-08-17 19:18:08 UTC (rev 1102)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimSwitch.cpp	2009-08-19 05:26:01 UTC (rev 1103)
@@ -0,0 +1,30 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2009 Mathias Froehlich 
+ *
+ */
+
+#include "JSBSimSwitch.h"
+
+#include <OpenFDM/DiscreteIntegrator.h>
+#include <OpenFDM/Group.h>
+#include <OpenFDM/Product.h>
+#include <OpenFDM/Summer.h>
+#include <OpenFDM/TimeDerivative.h>
+
+namespace OpenFDM {
+
+JSBSimSwitch::JSBSimSwitch(const std::string& name) :
+  JSBSimFCSComponent(name)
+{
+  // Currently a dummy implementation
+  ConstModel* constModel = new ConstModel("Constant", 1);
+  getGroup()->addChild(constModel);
+
+  getGroup()->connect(getInternalOutputPort(),
+                      constModel->getPort("output"));
+}
+
+JSBSimSwitch::~JSBSimSwitch(void)
+{
+}
+
+} //namespace OpenFDM


Property changes on: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimSwitch.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimSwitch.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimSwitch.h	2009-08-17 19:18:08 UTC (rev 1102)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimSwitch.h	2009-08-19 05:26:01 UTC (rev 1103)
@@ -0,0 +1,27 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2009 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_JSBSimSwitch_H
+#define OpenFDM_JSBSimSwitch_H
+
+#include "JSBSimFCSComponent.h"
+#include <OpenFDM/Connect.h>
+#include <OpenFDM/ConstModel.h>
+#include <OpenFDM/GroupInput.h>
+#include <OpenFDM/Product.h>
+#include <OpenFDM/SharedPtr.h>
+
+namespace OpenFDM {
+
+/// Just a small container mapping the JSBSim Switch parameters to
+/// the OpenFDM models.
+class JSBSimSwitch : public JSBSimFCSComponent {
+public:
+  JSBSimSwitch(const std::string& name);
+  virtual ~JSBSimSwitch(void);
+};
+
+} //namespace OpenFDM
+
+#endif


Property changes on: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimSwitch.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: branches/OpenFDM-StateSeparation/src/JSBSim/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/Makefile.am	2009-08-17 19:18:08 UTC (rev 1102)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/Makefile.am	2009-08-19 05:26:01 UTC (rev 1103)
@@ -26,6 +26,7 @@
   JSBSimReader.h \
   JSBSimReaderBase.h \
   JSBSimScheduledGain.h \
+  JSBSimSwitch.h \
   Tablereader.h \
   XMLReader.h
 
@@ -41,6 +42,7 @@
   JSBSimReader.cpp \
   JSBSimReaderBase.cpp \
   JSBSimScheduledGain.cpp \
+  JSBSimSwitch.cpp \
   Tablereader.cpp \
   XMLReader.cpp
 libOpenFDMJSBReader_la_LIBADD = $(xml_library) \



From frohlich at mail.berlios.de  Wed Aug 19 07:27:34 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Wed, 19 Aug 2009 07:27:34 +0200
Subject: [OpenFDM-svn] r1104 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200908190527.n7J5RYhK032399@sheep.berlios.de>

Author: frohlich
Date: 2009-08-19 07:27:34 +0200 (Wed, 19 Aug 2009)
New Revision: 1104

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/UniqueNameVisitor.h
Log:
Also replace empty names with Unnamed.

M    UniqueNameVisitor.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/UniqueNameVisitor.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/UniqueNameVisitor.h	2009-08-19 05:26:01 UTC (rev 1103)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/UniqueNameVisitor.h	2009-08-19 05:27:34 UTC (rev 1104)
@@ -27,6 +27,10 @@
     for (unsigned i = 0; i < group.getNumChildren(); ++i) {
       Node* node = group.getChild(i);
       std::string name = node->getName();
+      if (name.empty()) {
+        name = "Unnamed";
+        node->setName(name);
+      }
       unsigned counter = 0;
       while (nameSet.find(node->getName()) != nameSet.end()) {
         std::stringstream ss;



From frohlich at mail.berlios.de  Wed Aug 19 21:52:03 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Wed, 19 Aug 2009 21:52:03 +0200
Subject: [OpenFDM-svn] r1105 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200908191952.n7JJq3va015212@sheep.berlios.de>

Author: frohlich
Date: 2009-08-19 21:52:03 +0200 (Wed, 19 Aug 2009)
New Revision: 1105

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/CSVSystemOutput.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/HDF5SystemOutput.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/System.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/SystemOutput.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/SystemOutput.h
Log:
Clean up includes to satisfy concept checks.

M    SystemOutput.cpp
M    CSVSystemOutput.h
M    System.h
M    SystemOutput.h
M    HDF5SystemOutput.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/CSVSystemOutput.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/CSVSystemOutput.h	2009-08-19 05:27:34 UTC (rev 1104)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/CSVSystemOutput.h	2009-08-19 19:52:03 UTC (rev 1105)
@@ -9,6 +9,7 @@
 #include <set>
 #include <fstream>
 #include "Group.h"
+#include "System.h"
 #include "SystemOutput.h"
 #include "ConstNodeVisitor.h"
 #include "NodeInstance.h"

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/HDF5SystemOutput.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/HDF5SystemOutput.h	2009-08-19 05:27:34 UTC (rev 1104)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/HDF5SystemOutput.h	2009-08-19 19:52:03 UTC (rev 1105)
@@ -9,6 +9,7 @@
 #include <set>
 #include <hdf5.h>
 #include "Group.h"
+#include "System.h"
 #include "SystemOutput.h"
 #include "ConstNodeVisitor.h"
 #include "NodeInstance.h"

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/System.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/System.h	2009-08-19 05:27:34 UTC (rev 1104)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/System.h	2009-08-19 19:52:03 UTC (rev 1105)
@@ -11,6 +11,7 @@
 #include "Node.h"
 #include "Object.h"
 #include "SampleTime.h"
+#include "SystemOutput.h"
 
 namespace OpenFDM {
 

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/SystemOutput.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/SystemOutput.cpp	2009-08-19 05:27:34 UTC (rev 1104)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/SystemOutput.cpp	2009-08-19 19:52:03 UTC (rev 1105)
@@ -13,6 +13,8 @@
 #endif
 #include "CSVSystemOutput.h"
 
+#include "System.h"
+
 namespace OpenFDM {
 
 SystemOutput::~SystemOutput()
@@ -35,4 +37,10 @@
 #endif
 }
 
+SharedPtr<const System>
+SystemOutput::getSystem() const
+{
+  return mSystem.lock();
+}
+
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/SystemOutput.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/SystemOutput.h	2009-08-19 05:27:34 UTC (rev 1104)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/SystemOutput.h	2009-08-19 19:52:03 UTC (rev 1105)
@@ -5,10 +5,16 @@
 #ifndef OpenFDM_SystemOutput_H
 #define OpenFDM_SystemOutput_H
 
-#include "System.h"
+#include <string>
+#include "Referenced.h"
+#include "SharedPtr.h"
+#include "Types.h"
+#include "WeakPtr.h"
 
 namespace OpenFDM {
 
+class System;
+
 class SystemOutput : public Referenced {
 public:
   virtual ~SystemOutput();
@@ -21,8 +27,7 @@
   virtual void attachTo(const System* system) = 0;
 
 protected:
-  SharedPtr<const System> getSystem() const
-  { return mSystem.lock(); }
+  SharedPtr<const System> getSystem() const;
 
 private:
   WeakPtr<const System> mSystem;



From frohlich at mail.berlios.de  Thu Aug 20 18:25:33 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Thu, 20 Aug 2009 18:25:33 +0200
Subject: [OpenFDM-svn] r1106 - in branches/OpenFDM-StateSeparation/src:
	OpenFDM test
Message-ID: <200908201625.n7KGPXpi015258@sheep.berlios.de>

Author: frohlich
Date: 2009-08-20 18:25:32 +0200 (Thu, 20 Aug 2009)
New Revision: 1106

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Time.h
   branches/OpenFDM-StateSeparation/src/test/ballistic.cpp
   branches/OpenFDM-StateSeparation/src/test/drop.cpp
   branches/OpenFDM-StateSeparation/src/test/foucault.cpp
   branches/OpenFDM-StateSeparation/src/test/harmonic.cpp
   branches/OpenFDM-StateSeparation/src/test/linalg.cpp
   branches/OpenFDM-StateSeparation/src/test/tiretestrig.cpp
Log:
Add timers to get some timing statistics.

M    src/test/harmonic.cpp
M    src/test/drop.cpp
M    src/test/tiretestrig.cpp
M    src/test/linalg.cpp
M    src/test/ballistic.cpp
M    src/test/foucault.cpp
M    src/OpenFDM/Time.h


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Time.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Time.h	2009-08-19 19:52:03 UTC (rev 1105)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Time.h	2009-08-20 16:25:32 UTC (rev 1106)
@@ -6,6 +6,7 @@
 #define OpenFDM_Time_H
 
 #include <ctime>
+#include <sstream>
 #include <istream>
 #include <ostream>
 #include <iomanip>
@@ -149,7 +150,7 @@
 public:
   TimeCounter(Time::Type type = Time::CPUTime) :
     mType(type),
-    mTime(real_type(0)),
+    mTime(0, 0),
     mRunCounter(0)
   { }
   

Modified: branches/OpenFDM-StateSeparation/src/test/ballistic.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/ballistic.cpp	2009-08-19 19:52:03 UTC (rev 1105)
+++ branches/OpenFDM-StateSeparation/src/test/ballistic.cpp	2009-08-20 16:25:32 UTC (rev 1106)
@@ -1,3 +1,4 @@
+#include <iostream>
 #include <OpenFDM/ConstModel.h>
 #include <OpenFDM/DynamicPressure.h>
 #include <OpenFDM/ExternalInteract.h>
@@ -13,6 +14,7 @@
 #include <OpenFDM/Summer.h>
 #include <OpenFDM/System.h>
 #include <OpenFDM/SystemOutput.h>
+#include <OpenFDM/Time.h>
 #include <OpenFDM/UnaryFunction.h>
 #include <OpenFDM/WindAxis.h>
 #include <OpenFDM/WindAxisForce.h>
@@ -152,10 +154,18 @@
 
   system->attach(SystemOutput::newDefaultSystemOutput("ballistic"));
 
+  OpenFDM::TimeCounter timeCounter;
+  timeCounter.start();
+
   if (!system->init())
     return 1;
 
   system->simulate(10);
 
+  timeCounter.stop();
+  std::cout << "Execution time: " << timeCounter.getTime()
+            << "s (" << double(timeCounter.getTime())/system->getTime() << ")"
+            << std::endl;
+
   return 0;
 }

Modified: branches/OpenFDM-StateSeparation/src/test/drop.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/drop.cpp	2009-08-19 19:52:03 UTC (rev 1105)
+++ branches/OpenFDM-StateSeparation/src/test/drop.cpp	2009-08-20 16:25:32 UTC (rev 1106)
@@ -1,3 +1,4 @@
+#include <iostream>
 #include <OpenFDM/ConstModel.h>
 #include <OpenFDM/Group.h>
 #include <OpenFDM/Mass.h>
@@ -6,6 +7,7 @@
 #include <OpenFDM/ExternalInteract.h>
 #include <OpenFDM/System.h>
 #include <OpenFDM/SystemOutput.h>
+#include <OpenFDM/Time.h>
 
 using namespace OpenFDM;
 
@@ -47,11 +49,19 @@
 
   system->attach(SystemOutput::newDefaultSystemOutput("drop"));
 
+  OpenFDM::TimeCounter timeCounter;
+  timeCounter.start();
+
   if (!system->init())
     return 1;
 
   system->simulate(45);
 
+  timeCounter.stop();
+  std::cout << "Execution time: " << timeCounter.getTime()
+            << "s (" << double(timeCounter.getTime())/system->getTime() << ")"
+            << std::endl;
+
   return 0;
 }
 

Modified: branches/OpenFDM-StateSeparation/src/test/foucault.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/foucault.cpp	2009-08-19 19:52:03 UTC (rev 1105)
+++ branches/OpenFDM-StateSeparation/src/test/foucault.cpp	2009-08-20 16:25:32 UTC (rev 1106)
@@ -1,3 +1,4 @@
+#include <iostream>
 #include <OpenFDM/Group.h>
 #include <OpenFDM/Mass.h>
 #include <OpenFDM/FixedRootJoint.h>
@@ -6,6 +7,7 @@
 #include <OpenFDM/ExternalInteract.h>
 #include <OpenFDM/System.h>
 #include <OpenFDM/SystemOutput.h>
+#include <OpenFDM/Time.h>
 #include <OpenFDM/WGS84Planet.h>
 
 using namespace OpenFDM;
@@ -58,6 +60,9 @@
   system->getEnvironment()->setPlanet(planet);
   system->attach(SystemOutput::newDefaultSystemOutput("foucault"));
 
+  OpenFDM::TimeCounter timeCounter;
+  timeCounter.start();
+
   if (!system->init())
     return 1;
 
@@ -65,5 +70,10 @@
 //   system->simulate(60*60);
   system->simulate(60);
 
+  timeCounter.stop();
+  std::cout << "Execution time: " << timeCounter.getTime()
+            << "s (" << double(timeCounter.getTime())/system->getTime() << ")"
+            << std::endl;
+
   return 0;
 }

Modified: branches/OpenFDM-StateSeparation/src/test/harmonic.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/harmonic.cpp	2009-08-19 19:52:03 UTC (rev 1105)
+++ branches/OpenFDM-StateSeparation/src/test/harmonic.cpp	2009-08-20 16:25:32 UTC (rev 1106)
@@ -12,6 +12,7 @@
 #include <OpenFDM/SimulationTime.h>
 #include <OpenFDM/Summer.h>
 #include <OpenFDM/System.h>
+#include <OpenFDM/Time.h>
 #include <OpenFDM/UnaryFunction.h>
 #include "ErrorCollectorCallback.h"
 
@@ -97,6 +98,9 @@
   SharedPtr<System> system = new System("Harmonic Oszilator");
   system->setNode(group);
 
+  OpenFDM::TimeCounter timeCounter;
+  timeCounter.start();
+
   if (!system->init()) {
     std::cout << "Could not initialize the system" << std::endl;
     return EXIT_FAILURE;
@@ -104,6 +108,11 @@
 
   system->simulate(10);
 
+  timeCounter.stop();
+  std::cout << "Execution time: " << timeCounter.getTime()
+            << "s (" << double(timeCounter.getTime())/system->getTime() << ")"
+            << std::endl;
+
   real_type posError = posErrorCallback->error();
   std::cout << "Position error check with error = " << posError << std::endl;
   real_type velError = velErrorCallback->error();

Modified: branches/OpenFDM-StateSeparation/src/test/linalg.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/linalg.cpp	2009-08-19 19:52:03 UTC (rev 1105)
+++ branches/OpenFDM-StateSeparation/src/test/linalg.cpp	2009-08-20 16:25:32 UTC (rev 1106)
@@ -7,6 +7,7 @@
 #include <OpenFDM/Quaternion.h>
 #include <OpenFDM/Matrix.h>
 #include <OpenFDM/Vector.h>
+#include <OpenFDM/Time.h>
 
 namespace OpenFDM {
 
@@ -117,7 +118,10 @@
 int
 main(int argc, char *argv[])
 {
+  OpenFDM::TimeCounter timeCounter;
+  timeCounter.start();
   if (!OpenFDM::solvetest())
     return EXIT_FAILURE;
+  std::cout << "SUCCESS execution time: " << timeCounter.getTime() << std::endl;
   return EXIT_SUCCESS;
 }

Modified: branches/OpenFDM-StateSeparation/src/test/tiretestrig.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/test/tiretestrig.cpp	2009-08-19 19:52:03 UTC (rev 1105)
+++ branches/OpenFDM-StateSeparation/src/test/tiretestrig.cpp	2009-08-20 16:25:32 UTC (rev 1106)
@@ -2,6 +2,7 @@
  *
  */
 
+#include <iostream>
 #include <OpenFDM/Bias.h>
 #include <OpenFDM/BinaryFunction.h>
 #include <OpenFDM/ConstModel.h>
@@ -25,6 +26,7 @@
 #include <OpenFDM/Summer.h>
 #include <OpenFDM/System.h>
 #include <OpenFDM/SystemOutput.h>
+#include <OpenFDM/Time.h>
 #include <OpenFDM/UnaryFunction.h>
 #include <OpenFDM/Pacejka89.h>
 #include <OpenFDM/Pacejka94.h>
@@ -288,6 +290,9 @@
   normalForceNode->setPropertyValue("Value", Variant(Matrix(normalForce)));
   sideslipNode->setPropertyValue("Value", Variant(Matrix(0)));
 
+  OpenFDM::TimeCounter timeCounter;
+  timeCounter.start();
+
   if (!system->init())
     return EXIT_FAILURE;
 
@@ -303,5 +308,10 @@
   sideslipNode->setPropertyValue("Value", Variant(Matrix(0)));
   system->simulate(system->getTime() + alphaRange/alphaSpeed);
 
+  timeCounter.stop();
+  std::cout << "Execution time: " << timeCounter.getTime()
+            << "s (" << double(timeCounter.getTime())/system->getTime() << ")"
+            << std::endl;
+
   return EXIT_SUCCESS;
 }



From frohlich at mail.berlios.de  Fri Aug 21 21:05:36 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Fri, 21 Aug 2009 21:05:36 +0200
Subject: [OpenFDM-svn] r1107 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200908211905.n7LJ5aui009347@sheep.berlios.de>

Author: frohlich
Date: 2009-08-21 21:05:35 +0200 (Fri, 21 Aug 2009)
New Revision: 1107

Added:
   branches/OpenFDM-StateSeparation/src/OpenFDM/ComparisonOperator.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/ComparisonOperator.h
   branches/OpenFDM-StateSeparation/src/OpenFDM/LogicalOperator.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/LogicalOperator.h
Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/BinaryFunction.cpp
   branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
Log:
Add comparisons and logical operations.

AM   OpenFDM/ComparisonOperator.h
M    OpenFDM/Makefile.am
AM   OpenFDM/LogicalOperator.cpp
AM   OpenFDM/ComparisonOperator.cpp
AM   OpenFDM/LogicalOperator.h
M    OpenFDM/BinaryFunction.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/BinaryFunction.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/BinaryFunction.cpp	2009-08-20 16:25:32 UTC (rev 1106)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/BinaryFunction.cpp	2009-08-21 19:05:35 UTC (rev 1107)
@@ -12,6 +12,7 @@
 namespace OpenFDM {
 
 BEGIN_OPENFDM_OBJECT_DEF(BinaryFunction, SimpleDirectModel)
+  DEF_OPENFDM_PROPERTY(Unsigned, Type, Serialized)
   END_OPENFDM_OBJECT_DEF
 
 BinaryFunction::BinaryFunction(const std::string& name, Type type) :

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/ComparisonOperator.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ComparisonOperator.cpp	2009-08-20 16:25:32 UTC (rev 1106)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ComparisonOperator.cpp	2009-08-21 19:05:35 UTC (rev 1107)
@@ -0,0 +1,76 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2009 Mathias Froehlich
+ *
+ */
+
+#include "ComparisonOperator.h"
+
+#include "ModelContext.h"
+#include "PortValueList.h"
+#include "TypeInfo.h"
+#include "Variant.h"
+
+namespace OpenFDM {
+
+BEGIN_OPENFDM_OBJECT_DEF(ComparisonOperator, SimpleDirectModel)
+  DEF_OPENFDM_PROPERTY(Unsigned, Type, Serialized)
+  END_OPENFDM_OBJECT_DEF
+
+ComparisonOperator::ComparisonOperator(const std::string& name, Type type) :
+  SimpleDirectModel(name),
+  mType(type)
+{
+  setNumInputPorts(2);
+}
+
+ComparisonOperator::~ComparisonOperator(void)
+{
+}
+
+void
+ComparisonOperator::output(Context& context) const
+{
+  Size sz = size(context.getInputValue(0));
+  for (unsigned j = 0; j < sz(1); ++j) {
+    for (unsigned i = 0; i < sz(0); ++i) {
+      real_type input0 = context.getInputValue(0)(i, j);
+      real_type input1 = context.getInputValue(1)(i, j);
+      switch (mType) {
+      case Equal:
+        context.getOutputValue()(i, j) = (input0 == input1);
+        break;
+      case NotEqual:
+        context.getOutputValue()(i, j) = (input0 != input1);
+        break;
+      case Less:
+        context.getOutputValue()(i, j) = (input0 < input1);
+        break;
+      case LessEqual:
+        context.getOutputValue()(i, j) = (input0 <= input1);
+        break;
+      case Greater:
+        context.getOutputValue()(i, j) = (input0 > input1);
+        break;
+      case GreaterEqual:
+        context.getOutputValue()(i, j) = (input0 >= input1);
+        break;
+      default:
+        OpenFDMAssert(false);
+        break;
+      }
+    }
+  }
+}
+
+void
+ComparisonOperator::setType(const ComparisonOperator::Type& type)
+{
+  mType = type;
+}
+
+const ComparisonOperator::Type&
+ComparisonOperator::getType(void) const
+{
+  return mType;
+}
+
+} // namespace OpenFDM


Property changes on: branches/OpenFDM-StateSeparation/src/OpenFDM/ComparisonOperator.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/ComparisonOperator.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/ComparisonOperator.h	2009-08-20 16:25:32 UTC (rev 1106)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/ComparisonOperator.h	2009-08-21 19:05:35 UTC (rev 1107)
@@ -0,0 +1,39 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2009 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_ComparisonOperator_H
+#define OpenFDM_ComparisonOperator_H
+
+#include <string>
+#include "SimpleDirectModel.h"
+
+namespace OpenFDM {
+
+class ComparisonOperator : public SimpleDirectModel {
+  OPENFDM_OBJECT(ComparisonOperator, SimpleDirectModel);
+public:
+  enum Type {
+    Equal,
+    NotEqual,
+    Less,
+    LessEqual,
+    Greater,
+    GreaterEqual
+  };
+
+  ComparisonOperator(const std::string& name, Type type);
+  virtual ~ComparisonOperator(void);
+
+  virtual void output(Context& context) const;
+
+  void setType(const Type& type);
+  const Type& getType(void) const;
+
+private:
+  Type mType;
+};
+
+} // namespace OpenFDM
+
+#endif


Property changes on: branches/OpenFDM-StateSeparation/src/OpenFDM/ComparisonOperator.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/LogicalOperator.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/LogicalOperator.cpp	2009-08-20 16:25:32 UTC (rev 1106)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/LogicalOperator.cpp	2009-08-21 19:05:35 UTC (rev 1107)
@@ -0,0 +1,95 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2009 Mathias Froehlich
+ *
+ */
+
+#include "LogicalOperator.h"
+
+#include "ModelContext.h"
+#include "PortValueList.h"
+#include "TypeInfo.h"
+#include "Variant.h"
+
+namespace OpenFDM {
+
+BEGIN_OPENFDM_OBJECT_DEF(LogicalOperator, SimpleDirectModel)
+  DEF_OPENFDM_PROPERTY(Unsigned, Type, Serialized)
+  END_OPENFDM_OBJECT_DEF
+
+LogicalOperator::LogicalOperator(const std::string& name, Type type) :
+  SimpleDirectModel(name),
+  mType(type)
+{
+  setType(type);
+}
+
+LogicalOperator::~LogicalOperator(void)
+{
+}
+
+void
+LogicalOperator::output(Context& context) const
+{
+  Size sz = size(context.getInputValue(0));
+  for (unsigned j = 0; j < sz(1); ++j) {
+    for (unsigned i = 0; i < sz(0); ++i) {
+      switch (mType) {
+      case LogicalNOT:
+        {
+          real_type input0 = context.getInputValue(0)(i, j);
+          context.getOutputValue()(i, j) = !bool(input0);
+        }
+        break;
+        
+      default:
+        {
+          real_type input0 = context.getInputValue(0)(i, j);
+          real_type input1 = context.getInputValue(1)(i, j);
+          switch (mType) {
+          case LogicalAND:
+            context.getOutputValue()(i, j) = (bool(input0) && bool(input1));
+            break;
+          case LogicalOR:
+            context.getOutputValue()(i, j) = (bool(input0) || bool(input1));
+            break;
+          case LogicalNAND:
+            context.getOutputValue()(i, j) = !(bool(input0) && bool(input1));
+            break;
+          case LogicalNOR:
+            context.getOutputValue()(i, j) = !(bool(input0) || bool(input1));
+            break;
+          case LogicalXOR:
+            context.getOutputValue()(i, j) = (bool(input0) ^ bool(input1));
+            break;
+          default:
+            OpenFDMAssert(false);
+            break;
+          }
+        }
+        break;
+      }
+    }
+  }
+}
+
+void
+LogicalOperator::setType(const LogicalOperator::Type& type)
+{
+  mType = type;
+  switch (mType) {
+  case LogicalNOT:
+    setNumInputPorts(1);
+    break;
+    
+  default:
+    setNumInputPorts(2);
+    break;
+  }
+}
+
+const LogicalOperator::Type&
+LogicalOperator::getType(void) const
+{
+  return mType;
+}
+
+} // namespace OpenFDM


Property changes on: branches/OpenFDM-StateSeparation/src/OpenFDM/LogicalOperator.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/OpenFDM-StateSeparation/src/OpenFDM/LogicalOperator.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/LogicalOperator.h	2009-08-20 16:25:32 UTC (rev 1106)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/LogicalOperator.h	2009-08-21 19:05:35 UTC (rev 1107)
@@ -0,0 +1,39 @@
+/* -*-c++-*- OpenFDM - Copyright (C) 2004-2009 Mathias Froehlich 
+ *
+ */
+
+#ifndef OpenFDM_LogicalOperator_H
+#define OpenFDM_LogicalOperator_H
+
+#include <string>
+#include "SimpleDirectModel.h"
+
+namespace OpenFDM {
+
+class LogicalOperator : public SimpleDirectModel {
+  OPENFDM_OBJECT(LogicalOperator, SimpleDirectModel);
+public:
+  enum Type {
+    LogicalAND,
+    LogicalOR,
+    LogicalNAND,
+    LogicalNOR,
+    LogicalXOR,
+    LogicalNOT
+  };
+
+  LogicalOperator(const std::string& name, Type type);
+  virtual ~LogicalOperator(void);
+
+  virtual void output(Context& context) const;
+
+  void setType(const Type& type);
+  const Type& getType(void) const;
+
+private:
+  Type mType;
+};
+
+} // namespace OpenFDM
+
+#endif


Property changes on: branches/OpenFDM-StateSeparation/src/OpenFDM/LogicalOperator.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2009-08-20 16:25:32 UTC (rev 1106)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Makefile.am	2009-08-21 19:05:35 UTC (rev 1107)
@@ -202,6 +202,7 @@
   Bias.h \
   BinaryFunction.h \
   BreakPointLookup.h \
+  ComparisonOperator.h \
   ConstModel.h \
   DeadBand.h \
   Delay.h \
@@ -212,6 +213,7 @@
   Input.h \
   Integrator.h \
   LinearSpringDamper.h \
+  LogicalOperator.h \
   MachNumber.h \
   MatrixConcat.h \
   MatrixSplit.h \
@@ -238,6 +240,7 @@
   Bias.cpp \
   BinaryFunction.cpp \
   BreakPointLookup.cpp \
+  ComparisonOperator.cpp \
   ConstModel.cpp \
   DeadBand.cpp \
   Delay.cpp \
@@ -248,6 +251,7 @@
   Input.cpp \
   Integrator.cpp \
   LinearSpringDamper.cpp \
+  LogicalOperator.cpp \
   MachNumber.cpp \
   MatrixConcat.cpp \
   MatrixSplit.cpp \



From frohlich at mail.berlios.de  Sat Aug 22 12:00:15 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 22 Aug 2009 12:00:15 +0200
Subject: [OpenFDM-svn] r1108 - branches/OpenFDM-StateSeparation/src/OpenFDM
Message-ID: <200908221000.n7MA0FBS006226@sheep.berlios.de>

Author: frohlich
Date: 2009-08-22 12:00:15 +0200 (Sat, 22 Aug 2009)
New Revision: 1108

Modified:
   branches/OpenFDM-StateSeparation/src/OpenFDM/Node.cpp
Log:
Node paths should be top down.

M    Node.cpp


Modified: branches/OpenFDM-StateSeparation/src/OpenFDM/Node.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/OpenFDM/Node.cpp	2009-08-21 19:05:35 UTC (rev 1107)
+++ branches/OpenFDM-StateSeparation/src/OpenFDM/Node.cpp	2009-08-22 10:00:15 UTC (rev 1108)
@@ -221,6 +221,7 @@
       node.ascend(*this);
     } else {
       mNodePathList.push_back(getNodePath());
+      std::reverse(mNodePathList.back().begin(), mNodePathList.back().end());
     }
   }
 



From frohlich at mail.berlios.de  Sat Aug 22 17:17:39 2009
From: frohlich at mail.berlios.de (frohlich at BerliOS)
Date: Sat, 22 Aug 2009 17:17:39 +0200
Subject: [OpenFDM-svn] r1109 - branches/OpenFDM-StateSeparation/src/JSBSim
Message-ID: <200908221517.n7MFHd2J007729@sheep.berlios.de>

Author: frohlich
Date: 2009-08-22 17:17:36 +0200 (Sat, 22 Aug 2009)
New Revision: 1109

Modified:
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimPropertyManager.cpp
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimPropertyManager.h
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp
   branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.cpp
Log:
Put functions into subgroups.

Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimPropertyManager.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimPropertyManager.cpp	2009-08-22 10:00:15 UTC (rev 1108)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimPropertyManager.cpp	2009-08-22 15:17:36 UTC (rev 1109)
@@ -33,9 +33,9 @@
     if (mPortList.empty())
       return 0;
 
-    // ok, shortcut for old style connections
+    // Should also not happen!
     if (path.empty())
-      return mPortList.front().portProvider;
+      return 0;
 
     const NodePath& originatingPath = mPortList.front().modelPath;
     // fast return if the models are not connected to the same root system
@@ -70,12 +70,18 @@
       Group* group = const_cast<Group*>(dynamic_cast<const Group*>(path.back().get()));
       group->addChild(groupInput);
 
+      SharedPtr<Node> parentNode = group->getParent(0).lock();
+      SharedPtr<Group> parentGroup = dynamic_cast<Group*>(parentNode.get());
+
+
+
+
       PathPort pathPort;
       pathPort.modelPath = groupInput->getNodePathList().front();
-      pathPort.portProvider = group->getPort(groupInput->getExternalPortIndex());
+      pathPort.portProvider = groupInput->getPort("output");
       mPortList.push_back(pathPort);
 
-      if (!group->connect(portProvider, groupInput->getPort("input")))
+      if (!parentGroup->connect(portProvider, group->getPort(groupInput->getExternalPortIndex())))
         return 0;
       
       return pathPort.portProvider.get();
@@ -146,4 +152,21 @@
   return true;
 }
 
+bool
+JSBSimPropertyManager::connect(const Port* port0, Group* group0,
+                               const Port* port1, Group* group1)
+{
+  if (!port0)
+    return false;
+  if (!port1)
+    return false;
+  PortSet portSet(port0);
+  SharedPtr<const Node> node = port1->getNode();
+  if (!node.valid())
+    return false;
+  NodePathList nodePathList = node->getNodePathList();
+  const Port* p = portSet.routeTo(nodePathList.front());
+  return group1->connect(p, port1);
+}
+
 } // namespace OpenFDM

Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimPropertyManager.h
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimPropertyManager.h	2009-08-22 10:00:15 UTC (rev 1108)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimPropertyManager.h	2009-08-22 15:17:36 UTC (rev 1109)
@@ -147,12 +147,16 @@
   /// Returns true if this property is already registered
   bool exists(const std::string& propertyName) const
   {
-    PropertyMap::const_iterator i = mPropertyMap.find(JSBSimProperty::simplify(propertyName));
+    PropertyMap::const_iterator i;
+    i = mPropertyMap.find(JSBSimProperty::simplify(propertyName));
     if (i == mPropertyMap.end())
       return false;
     return i->second.hasProviderPort();
   }
 
+  static bool connect(const Port* port0, Group* group0,
+                      const Port* port1, Group* group1);
+
 private:
   PropertyMap mPropertyMap;
 };

Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp	2009-08-22 10:00:15 UTC (rev 1108)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReader.cpp	2009-08-22 15:17:36 UTC (rev 1109)
@@ -1761,26 +1761,27 @@
   if (slachPos != std::string::npos)
     name = name.substr(slachPos+1);
 
-  // FIXME put that into a group and use a GroupOutput for that
-  SharedPtr<Gain> gain = new Gain(name);
-  mTopLevelGroup->addChild(gain);
-
+  SharedPtr<Group> group = new Group(name);
+  mTopLevelGroup->addChild(group);
+  GroupOutput* groupOutput = new GroupOutput("Output");
+  group->addChild(groupOutput);
+  
   std::list<const XMLElement*> elements = function->getElements();
   std::list<const XMLElement*>::iterator i;
   for (i = elements.begin(); i != elements.end(); ++i) {
     if ((*i)->getName() == "description")
       continue;
-    if (!connectFunctionInput(*i, gain->getInputPort(0), mTopLevelGroup))
+    if (!connectFunctionInput(*i, groupOutput->getPort("input"), group))
       return error("Can not connect product input!");
     // FIXME check that we get here only once
   }
 
   if (!bindName.empty())
-    registerJSBExpression(bindName, gain->getOutputPort());
+    registerJSBExpression(bindName, group->getPort(groupOutput->getExternalPortIndex()));
   if (sum) {
     unsigned num = sum->getNumSummands();
     sum->setNumSummands(num+1);
-    mTopLevelGroup->connect(gain->getOutputPort(), sum->getInputPort(num));
+    mTopLevelGroup->connect(group->getPort(groupOutput->getExternalPortIndex()), sum->getInputPort(num));
   }
 
   return true;
@@ -2026,9 +2027,12 @@
 
       SharedPtr<Table1D> table = new Table1D("Table");
       parentGroup->addChild(table);
-      parentGroup->connect(portP, table->getInputPort(0));
       table->setTableData(data);
-      parentGroup->connect(port, table->getPort("output"));
+      if (!JSBSimPropertyManager::connect(portP, mTopLevelGroup,
+                                          table->getInputPort(0), parentGroup))
+        return false;
+      if (!parentGroup->connect(port, table->getPort("output")))
+        return false;
       return true;
 
     } else if (dim == 2) {
@@ -2049,10 +2053,16 @@
       
       SharedPtr<Table2D> table = new Table2D("Table");
       parentGroup->addChild(table);
-      parentGroup->connect(rPort, table->getInputPort(0));
-      parentGroup->connect(cPort, table->getInputPort(1));
       table->setTableData(data);
-      parentGroup->connect(port, table->getPort("output"));
+
+      if (!JSBSimPropertyManager::connect(rPort, mTopLevelGroup,
+                                          table->getInputPort(0), parentGroup))
+        return false;
+      if (!JSBSimPropertyManager::connect(cPort, mTopLevelGroup,
+                                          table->getInputPort(1), parentGroup))
+        return false;
+      if (!parentGroup->connect(port, table->getPort("output")))
+        return false;
       return true;
 
     } else if (dim == 3) {
@@ -2075,11 +2085,20 @@
       
       SharedPtr<Table3D> table = new Table3D("Table");
       parentGroup->addChild(table);
-      parentGroup->connect(rPort, table->getInputPort(0));
-      parentGroup->connect(cPort, table->getInputPort(1));
-      parentGroup->connect(pPort, table->getInputPort(2));
       table->setTableData(data);
-      parentGroup->connect(port, table->getPort("output"));
+
+      if (!JSBSimPropertyManager::connect(rPort, mTopLevelGroup,
+                                          table->getInputPort(0), parentGroup))
+        return false;
+      if (!JSBSimPropertyManager::connect(cPort, mTopLevelGroup,
+                                          table->getInputPort(1), parentGroup))
+        return false;
+      if (!JSBSimPropertyManager::connect(pPort, mTopLevelGroup,
+                                          table->getInputPort(2), parentGroup))
+        return false;
+      if (!parentGroup->connect(port, table->getPort("output")))
+        return false;
+
       return true;
 
     }

Modified: branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.cpp
===================================================================
--- branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.cpp	2009-08-22 10:00:15 UTC (rev 1108)
+++ branches/OpenFDM-StateSeparation/src/JSBSim/JSBSimReaderBase.cpp	2009-08-22 15:17:36 UTC (rev 1109)
@@ -923,7 +923,7 @@
   // No sharable table lookup found, we need to create a new one
   BreakPointLookup* tablePreLookup
     = new BreakPointLookup(name + " Table Prelookup");
-  addMultiBodyModel(tablePreLookup);
+  mTopLevelGroup->addChild(tablePreLookup);
   tablePreLookup->setBreakPointVector(tl);
   connectJSBExpression(normalizedInputProperty,
                        tablePreLookup->getInputPort(0));



